(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["PostItModeler"] = factory();
	else
		root["PostItModeler"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/BaseModeler.js":
/*!****************************!*\
  !*** ./lib/BaseModeler.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseModeler)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ids__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ids */ "./node_modules/ids/dist/index.esm.js");
/* harmony import */ var _BaseViewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseViewer */ "./lib/BaseViewer.js");







/**
 * A base modeler for postit-js boards.
 *
 * Have a look at {@link Modeler} for a bundle that includes actual features.
 *
 * @param {Object} [options] configuration options to pass to the viewer
 * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.
 * @param {String|Number} [options.width] the width of the viewer
 * @param {String|Number} [options.height] the height of the viewer
 * @param {Object} [options.moddleExtensions] extension packages to provide
 * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules
 * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules
 */
function BaseModeler(options) {
  _BaseViewer__WEBPACK_IMPORTED_MODULE_2__.default.call(this, options);

  // hook ID collection into the modeler
  this.on('import.parse.complete', function(event) {
    if (!event.error) {
      this._collectIds(event.definitions, event.context);
    }
  }, this);

  this.on('diagram.destroy', function() {
    this.get('moddle').ids.clear();
  }, this);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(BaseModeler, _BaseViewer__WEBPACK_IMPORTED_MODULE_2__.default);


/**
 * Create a moddle instance, attaching ids to it.
 *
 * @param {Object} options
 */
BaseModeler.prototype._createModdle = function(options) {
  var moddle = _BaseViewer__WEBPACK_IMPORTED_MODULE_2__.default.prototype._createModdle.call(this, options);

  // attach ids to moddle to be able to track
  // and validated ids in the XML document
  // tree
  moddle.ids = new ids__WEBPACK_IMPORTED_MODULE_1__.default([ 32, 36, 1 ]);

  return moddle;
};

/**
 * Collect ids processed during parsing of the
 * definitions object.
 *
 * @param {ModdleElement} definitions
 * @param {Context} context
 */
BaseModeler.prototype._collectIds = function(definitions, context) {

  var moddle = definitions.$model,
      ids = moddle.ids,
      id;

  // remove references from previous import
  ids.clear();

  for (id in context.elementsById) {
    ids.claim(id, context.elementsById[id]);
  }
};


/***/ }),

/***/ "./lib/BaseViewer.js":
/*!***************************!*\
  !*** ./lib/BaseViewer.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseViewer)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var diagram_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js */ "./node_modules/diagram-js/lib/Diagram.js");
/* harmony import */ var _moddle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./moddle */ "./lib/moddle/index.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _import_Importer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./import/Importer */ "./lib/import/Importer.js");
/**
 * The code in the <project-logo></project-logo> area
 * must not be changed.
 *
 * @see http://bpmn.io/license for more information.
 */
















/**
 * A base viewer for Postit boards.
 *
 * Have a look at {@link Viewer}, {@link NavigatedViewer} or {@link Modeler} for
 * bundles that include actual features.
 *
 * @param {Object} [options] configuration options to pass to the viewer
 * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.
 * @param {String|Number} [options.width] the width of the viewer
 * @param {String|Number} [options.height] the height of the viewer
 * @param {Object} [options.moddleExtensions] extension packages to provide
 * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules
 * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules
 */
function BaseViewer(options) {

  options = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({}, DEFAULT_OPTIONS, options);

  this._moddle = this._createModdle(options);

  this._container = this._createContainer(options);

  this._init(this._container, this._moddle, options);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(BaseViewer, diagram_js__WEBPACK_IMPORTED_MODULE_2__.default);

/**
* The importXML result.
*
* @typedef {Object} ImportXMLResult
*
* @property {Array<string>} warnings
*/

/**
* The importXML error.
*
* @typedef {Error} ImportXMLError
*
* @property {Array<string>} warnings
*/


/**
 * Parse and render a Postit diagram.
 *
 * Once finished the viewer reports back the result to the
 * provided callback function with (err, warnings).
 *
 * ## Life-Cycle Events
 *
 * During import the viewer will fire life-cycle events:
 *
 *   * import.parse.start (about to read model from xml)
 *   * import.parse.complete (model read; may have worked or not)
 *   * import.render.start (graphical import start)
 *   * import.render.complete (graphical import finished)
 *   * import.done (everything done)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {String} xml the Postit xml
 * @param {ModdleElement<PostitRootBoard>|String} [rootBoard] Postit board or id of board to render (if not provided, the first one will be rendered)
 *
 * @returns {Promise<ImportXMLResult, ImportXMLError>}
 */
BaseViewer.prototype.importXML = function(xml, rootBoard) {

  var self = this;

  return new Promise(function(resolve, reject) {

    // hook in pre-parse listeners +
    // allow xml manipulation
    xml = self._emit('import.parse.start', { xml: xml }) || xml;

    self._moddle.fromXML(xml, 'postit:Definitions').then(function(result) {

      var definitions = result.rootElement;
      var references = result.references;
      var parseWarnings = result.warnings;
      var elementsById = result.elementsById;

      var context = {
        references: references,
        elementsById: elementsById,
        warnings: parseWarnings
      };

      // hook in post parse listeners +
      // allow definitions manipulation
      definitions = self._emit('import.parse.complete', {
        definitions: definitions,
        context: context
      }) || definitions;

      self.importDefinitions(definitions, rootBoard).then(function(result) {
        var allWarnings = [].concat(parseWarnings, result.warnings || []);

        self._emit('import.done', { error: null, warnings: allWarnings });

        return resolve({ warnings: allWarnings });
      }).catch(function(err) {
        var allWarnings = [].concat(parseWarnings, err.warnings || []);

        self._emit('import.done', { error: err, warnings: allWarnings });

        return reject(addWarningsToError(err, allWarnings));
      });
    }).catch(function(err) {

      self._emit('import.parse.complete', {
        error: err
      });

      err = checkValidationError(err);

      self._emit('import.done', { error: err, warnings: err.warnings });

      return reject(err);
    });

  });
};

/**
* The importDefinitions result.
*
* @typedef {Object} ImportDefinitionsResult
*
* @property {Array<string>} warnings
*/

/**
* The importDefinitions error.
*
* @typedef {Error} ImportDefinitionsError
*
* @property {Array<string>} warnings
*/

/**
 * Import parsed definitions and render a Postit diagram.
 *
 * Once finished the viewer reports back the result to the
 * provided callback function with (err, warnings).
 *
 * ## Life-Cycle Events
 *
 * During import the viewer will fire life-cycle events:
 *
 *   * import.render.start (graphical import start)
 *   * import.render.complete (graphical import finished)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {ModdleElement<Definitions>} definitions parsed Postit definitions
 * @param {ModdleElement<PostitRootBoard>|String} [rootBoard] Postit board or id of board to render (if not provided, the first one will be rendered)
 *
 * returns {Promise<ImportDefinitionsResult, ImportDefinitionsError>}
 */
BaseViewer.prototype.importDefinitions = function(definitions, rootBoard) {

  var self = this;

  return new Promise(function(resolve, reject) {

    self._setDefinitions(definitions);

    self.open(rootBoard).then(function(result) {

      var warnings = result.warnings;

      return resolve({ warnings: warnings });
    }).catch(function(err) {

      return reject(err);
    });
  });
};

/**
 * The open result.
 *
 * @typedef {Object} OpenResult
 *
 * @property {Array<string>} warnings
 */

/**
* The open error.
*
* @typedef {Error} OpenError
*
* @property {Array<string>} warnings
*/

/**
 * Open board of previously imported XML.
 *
 * Once finished the viewer reports back the result to the
 * provided callback function with (err, warnings).
 *
 * ## Life-Cycle Events
 *
 * During switch the viewer will fire life-cycle events:
 *
 *   * import.render.start (graphical import start)
 *   * import.render.complete (graphical import finished)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {String|ModdleElement<PostitRootBoard>} [rootBoardOrId] id or the diagram to open
 *
 * returns {Promise<OpenResult, OpenError>}
 */
BaseViewer.prototype.open = function(rootBoardOrId) {

  var definitions = this._definitions;
  var rootBord = rootBoardOrId;

  var self = this;

  return new Promise(function(resolve, reject) {
    if (!definitions) {
      var err1 = new Error('no XML imported');

      return reject(addWarningsToError(err1, []));
    }

    if (typeof rootBoardOrId === 'string') {
      rootBord = findRootBoard(definitions, rootBoardOrId);

      if (!rootBord) {
        var err2 = new Error('PostitRootBoard <' + rootBoardOrId + '> not found');

        return reject(addWarningsToError(err2, []));
      }
    }

    // clear existing rendered diagram
    // catch synchronous exceptions during #clear()
    try {
      self.clear();
    } catch (error) {

      return reject(addWarningsToError(error, []));
    }

    // perform graphical import
    (0,_import_Importer__WEBPACK_IMPORTED_MODULE_3__.importPostitDiagram)(self, definitions, rootBord).then(function(result) {

      var warnings = result.warnings;

      return resolve({ warnings: warnings });
    }).catch(function(err) {

      return reject(err);
    });
  });
};

/**
 * The saveXML result.
 *
 * @typedef {Object} SaveXMLResult
 *
 * @property {string} xml
 */

/**
 * Export the currently displayed Postit diagram as
 * a Postit XML document.
 *
 * ## Life-Cycle Events
 *
 * During XML saving the viewer will fire life-cycle events:
 *
 *   * saveXML.start (before serialization)
 *   * saveXML.serialized (after xml generation)
 *   * saveXML.done (everything done)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {Object} [options] export options
 * @param {Boolean} [options.format=false] output formatted XML
 * @param {Boolean} [options.preamble=true] output preamble
 *
 * returns {Promise<SaveXMLResult, Error>}
 */
BaseViewer.prototype.saveXML = function(options) {

  options = options || {};

  var self = this;

  var definitions = this._definitions;

  return new Promise(function(resolve, reject) {

    if (!definitions) {
      var err = new Error('no definitions loaded');

      return reject(err);
    }

    // allow to fiddle around with definitions
    definitions = self._emit('saveXML.start', {
      definitions: definitions
    }) || definitions;

    self._moddle.toXML(definitions, options).then(function(result) {

      var xml = result.xml;

      try {
        xml = self._emit('saveXML.serialized', {
          error: null,
          xml: xml
        }) || xml;

        self._emit('saveXML.done', {
          error: null,
          xml: xml
        });
      } catch (e) {
        console.error('error in saveXML life-cycle listener', e);
      }

      return resolve({ xml: xml });
    }).catch(function(err) {

      return reject(err);
    });
  });
};

/**
 * The saveSVG result.
 *
 * @typedef {Object} SaveSVGResult
 *
 * @property {string} svg
 */

/**
 * Export the currently displayed Postit diagram as
 * an SVG image.
 *
 * ## Life-Cycle Events
 *
 * During SVG saving the viewer will fire life-cycle events:
 *
 *   * saveSVG.start (before serialization)
 *   * saveSVG.done (everything done)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {Object} [options]
 *
 * returns {Promise<SaveSVGResult, Error>}
 */
BaseViewer.prototype.saveSVG = function(options) {

  options = options || {};

  var self = this;

  return new Promise(function(resolve, reject) {

    self._emit('saveSVG.start');

    var svg, err;

    try {
      var canvas = self.get('canvas');

      var contentNode = canvas.getDefaultLayer(),
          defsNode = (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.query)('defs', canvas._svg);

      var contents = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_5__.innerSVG)(contentNode),
          defs = defsNode ? '<defs>' + (0,tiny_svg__WEBPACK_IMPORTED_MODULE_5__.innerSVG)(defsNode) + '</defs>' : '';

      var bbox = contentNode.getBBox();

      svg =
        '<?xml version="1.0" encoding="utf-8"?>\n' +
        '<!-- created with diagram-js / http://bpmn.io -->\n' +
        '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' +
        '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ' +
             'width="' + bbox.width + '" height="' + bbox.height + '" ' +
             'viewBox="' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '" version="1.1">' +
          defs + contents +
        '</svg>';
    } catch (e) {
      err = e;
    }

    self._emit('saveSVG.done', {
      error: err,
      svg: svg
    });

    if (!err) {
      return resolve({ svg: svg });
    }

    return reject(err);
  });
};

/**
 * Get a named diagram service.
 *
 * @example
 *
 * var elementRegistry = viewer.get('elementRegistry');
 * var startEventShape = elementRegistry.get('StartEvent_1');
 *
 * @param {String} name
 *
 * @return {Object} diagram service instance
 *
 * @method BaseViewer#get
 */

/**
 * Invoke a function in the context of this viewer.
 *
 * @example
 *
 * viewer.invoke(function(elementRegistry) {
 *   var startEventShape = elementRegistry.get('StartEvent_1');
 * });
 *
 * @param {Function} fn to be invoked
 *
 * @return {Object} the functions return value
 *
 * @method BaseViewer#invoke
 */


BaseViewer.prototype._setDefinitions = function(definitions) {
  this._definitions = definitions;
};

BaseViewer.prototype.getModules = function() {
  return this._modules;
};

/**
 * Remove all drawn elements from the viewer.
 *
 * After calling this method the viewer can still
 * be reused for opening another diagram.
 *
 * @method BaseViewer#clear
 */
BaseViewer.prototype.clear = function() {
  if (!this.getDefinitions()) {

    // no diagram to clear
    return;
  }

  // remove businessObject#di binding
  //
  // this is necessary, as we establish the bindings
  // in the PostitTreeWalker (and assume none are given
  // on reimport)
  this.get('elementRegistry').forEach(function(element) {
    var bo = element.businessObject;

    if (bo && bo.di) {
      delete bo.di;
    }
  });

  // remove drawn elements
  diagram_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.clear.call(this);
};

/**
 * Destroy the viewer instance and remove all its
 * remainders from the document tree.
 */
BaseViewer.prototype.destroy = function() {

  // diagram destroy
  diagram_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.destroy.call(this);

  // dom detach
  (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.remove)(this._container);
};

/**
 * Register an event listener
 *
 * Remove a previously added listener via {@link #off(event, callback)}.
 *
 * @param {String} event
 * @param {Number} [priority]
 * @param {Function} callback
 * @param {Object} [that]
 */
BaseViewer.prototype.on = function(event, priority, callback, target) {
  return this.get('eventBus').on(event, priority, callback, target);
};

/**
 * De-register an event listener
 *
 * @param {String} event
 * @param {Function} callback
 */
BaseViewer.prototype.off = function(event, callback) {
  this.get('eventBus').off(event, callback);
};

BaseViewer.prototype.attachTo = function(parentNode) {

  if (!parentNode) {
    throw new Error('parentNode required');
  }

  // ensure we detach from the
  // previous, old parent
  this.detach();

  // unwrap jQuery if provided
  if (parentNode.get && parentNode.constructor.prototype.jquery) {
    parentNode = parentNode.get(0);
  }

  if (typeof parentNode === 'string') {
    parentNode = (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.query)(parentNode);
  }

  parentNode.appendChild(this._container);

  this._emit('attach', {});

  this.get('canvas').resized();
};

BaseViewer.prototype.getDefinitions = function() {
  return this._definitions;
};

BaseViewer.prototype.detach = function() {

  var container = this._container,
      parentNode = container.parentNode;

  if (!parentNode) {
    return;
  }

  this._emit('detach', {});

  parentNode.removeChild(container);
};

BaseViewer.prototype._init = function(container, moddle, options) {

  var baseModules = options.modules || this.getModules(),
      additionalModules = options.additionalModules || [],
      staticModules = [
        {
          postitjs: [ 'value', this ],
          moddle: [ 'value', moddle ]
        }
      ];

  var diagramModules = [].concat(staticModules, baseModules, additionalModules);

  var diagramOptions = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.omit)(options, [ 'additionalModules' ]), {
    canvas: (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({}, options.canvas, { container: container }),
    modules: diagramModules
  });

  // invoke diagram constructor
  diagram_js__WEBPACK_IMPORTED_MODULE_2__.default.call(this, diagramOptions);

  if (options && options.container) {
    this.attachTo(options.container);
  }
};

/**
 * Emit an event on the underlying {@link EventBus}
 *
 * @param  {String} type
 * @param  {Object} event
 *
 * @return {Object} event processing result (if any)
 */
BaseViewer.prototype._emit = function(type, event) {
  return this.get('eventBus').fire(type, event);
};

BaseViewer.prototype._createContainer = function(options) {

  var container = (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.domify)('<div class="pjs-container"></div>');

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(container.style, {
    width: ensureUnit(options.width),
    height: ensureUnit(options.height),
    position: options.position
  });

  return container;
};

BaseViewer.prototype._createModdle = function(options) {
  var moddleOptions = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({}, this._moddleExtensions, options.moddleExtensions);

  return new _moddle__WEBPACK_IMPORTED_MODULE_6__.default(moddleOptions);
};

BaseViewer.prototype._modules = [];

BaseViewer.prototype._moddleExtensions = {};


// helpers ///////////////

function addWarningsToError(err, warningsAry) {
  err.warnings = warningsAry;
  return err;
}

function checkValidationError(err) {

  // check if we can help the user by indicating wrong Postit xml
  // (in case he or the exporting tool did not get that right)

  var pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/;
  var match = pattern.exec(err.message);

  if (match) {
    err.message =
      'unparsable content <' + match[1] + '> detected; ' +
      'this may indicate an invalid Postit board file' + match[2];
  }

  return err;
}

var DEFAULT_OPTIONS = {
  width: '100%',
  height: '100%',
  position: 'relative'
};


/**
 * Ensure the passed argument is a proper unit (defaulting to px)
 */
function ensureUnit(val) {
  return val + ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isNumber)(val) ? 'px' : '');
}


/**
 * Find RootBoard in definitions by ID
 *
 * @param {ModdleElement<Definitions>} definitions
 * @param {String} boardId
 *
 * @return {ModdleElement<PostitRootBoard>|null}
 */
function findRootBoard(definitions, boardId) {
  if (!boardId) {
    return null;
  }

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(definitions.rootBoards, function(element) {
    return element.id === boardId;
  }) || null;
}





/***/ }),

/***/ "./lib/Modeler.js":
/*!************************!*\
  !*** ./lib/Modeler.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Modeler)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseModeler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseModeler */ "./lib/BaseModeler.js");
/* harmony import */ var _Viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Viewer */ "./lib/Viewer.js");
/* harmony import */ var _NavigatedViewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NavigatedViewer */ "./lib/NavigatedViewer.js");
/* harmony import */ var diagram_js_lib_navigation_keyboard_move__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/navigation/keyboard-move */ "./node_modules/diagram-js/lib/navigation/keyboard-move/index.js");
/* harmony import */ var diagram_js_lib_navigation_movecanvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! diagram-js/lib/navigation/movecanvas */ "./node_modules/diagram-js/lib/navigation/movecanvas/index.js");
/* harmony import */ var diagram_js_lib_navigation_touch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! diagram-js/lib/navigation/touch */ "./node_modules/diagram-js/lib/navigation/touch/index.js");
/* harmony import */ var diagram_js_lib_navigation_zoomscroll__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! diagram-js/lib/navigation/zoomscroll */ "./node_modules/diagram-js/lib/navigation/zoomscroll/index.js");
/* harmony import */ var diagram_js_lib_features_align_elements__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! diagram-js/lib/features/align-elements */ "./node_modules/diagram-js/lib/features/align-elements/index.js");
/* harmony import */ var diagram_js_lib_features_auto_scroll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! diagram-js/lib/features/auto-scroll */ "./node_modules/diagram-js/lib/features/auto-scroll/index.js");
/* harmony import */ var diagram_js_lib_features_bendpoints__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! diagram-js/lib/features/bendpoints */ "./node_modules/diagram-js/lib/features/bendpoints/index.js");
/* harmony import */ var _features_canvas_create__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./features/canvas-create */ "./lib/features/canvas-create/index.js");
/* harmony import */ var diagram_js_lib_features_connect__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! diagram-js/lib/features/connect */ "./node_modules/diagram-js/lib/features/connect/index.js");
/* harmony import */ var diagram_js_lib_features_connection_preview__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! diagram-js/lib/features/connection-preview */ "./node_modules/diagram-js/lib/features/connection-preview/index.js");
/* harmony import */ var _features_context_pad__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./features/context-pad */ "./lib/features/context-pad/index.js");
/* harmony import */ var _features_copy_paste__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./features/copy-paste */ "./lib/features/copy-paste/index.js");
/* harmony import */ var diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! diagram-js/lib/features/create */ "./node_modules/diagram-js/lib/features/create/index.js");
/* harmony import */ var _features_editor_actions__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./features/editor-actions */ "./lib/features/editor-actions/index.js");
/* harmony import */ var _features_image_selection__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./features/image-selection */ "./lib/features/image-selection/index.js");
/* harmony import */ var _features_keyboard__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./features/keyboard */ "./lib/features/keyboard/index.js");
/* harmony import */ var diagram_js_lib_features_keyboard_move_selection__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! diagram-js/lib/features/keyboard-move-selection */ "./node_modules/diagram-js/lib/features/keyboard-move-selection/index.js");
/* harmony import */ var _features_label_editing__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./features/label-editing */ "./lib/features/label-editing/index.js");
/* harmony import */ var _features_modeling__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./features/modeling */ "./lib/features/modeling/index.js");
/* harmony import */ var diagram_js_lib_features_move__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! diagram-js/lib/features/move */ "./node_modules/diagram-js/lib/features/move/index.js");
/* harmony import */ var _features_palette__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./features/palette */ "./lib/features/palette/index.js");
/* harmony import */ var _features_replace_preview__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./features/replace-preview */ "./lib/features/replace-preview/index.js");
/* harmony import */ var diagram_js_lib_features_resize__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! diagram-js/lib/features/resize */ "./node_modules/diagram-js/lib/features/resize/index.js");
/* harmony import */ var _features_snapping__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./features/snapping */ "./lib/features/snapping/index.js");
/* harmony import */ var _features_drag_drop_images__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./features/drag-drop-images */ "./lib/features/drag-drop-images/index.js");


































//import SelectionOrganizerModule from './features/selection-organizer';
//import PropertiesPanelModule from './features/properties-panel-v2';
//import ImageSelectionModule from './features/image-selection-v2';
// CTODO


var initialDiagram =
  `<?xml version="1.0" encoding="UTF-8"?>
  <postit:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:di="http://www.omg.org/spec/DD/20100524/DI" id="sample-diagram">
    <postit:PostitBoard id="Board_1">
    </postit:PostitBoard>
    <postitDi:PostitRootBoard id="RootBoard_1">
      <postitDi:PostitPlane id="PositPlane_1" boardElement="Board_1">
      </postitDi:PostitPlane>
    </postitDi:PostitRootBoard>
  </postit:definitions>`;

function Modeler(options) {
  _BaseModeler__WEBPACK_IMPORTED_MODULE_1__.default.call(this, options);
}
inherits__WEBPACK_IMPORTED_MODULE_0___default()(Modeler, _BaseModeler__WEBPACK_IMPORTED_MODULE_1__.default);


Modeler.Viewer = _Viewer__WEBPACK_IMPORTED_MODULE_2__.default;
Modeler.NavigatedViewer = _NavigatedViewer__WEBPACK_IMPORTED_MODULE_3__.default;

/**
* The createDiagram result.
*
* @typedef {Object} CreateDiagramResult
*
* @property {Array<string>} warnings
*/

/**
* The createDiagram error.
*
* @typedef {Error} CreateDiagramError
*
* @property {Array<string>} warnings
*/

/**
 * Create a new diagram to start modeling.
 *
 * @returns {Promise<CreateDiagramResult, CreateDiagramError>}
 *
 */
Modeler.prototype.createDiagram = function() {
  return this.importXML(initialDiagram);
};


Modeler.prototype._interactionModules = [

  // non-modeling components
  diagram_js_lib_navigation_keyboard_move__WEBPACK_IMPORTED_MODULE_4__.default,
  diagram_js_lib_navigation_movecanvas__WEBPACK_IMPORTED_MODULE_5__.default,
  diagram_js_lib_navigation_touch__WEBPACK_IMPORTED_MODULE_6__.default,
  diagram_js_lib_navigation_zoomscroll__WEBPACK_IMPORTED_MODULE_7__.default
];

Modeler.prototype._modelingModules = [

  // modeling components
  diagram_js_lib_features_align_elements__WEBPACK_IMPORTED_MODULE_8__.default,
  diagram_js_lib_features_auto_scroll__WEBPACK_IMPORTED_MODULE_9__.default,
  diagram_js_lib_features_bendpoints__WEBPACK_IMPORTED_MODULE_10__.default,
  _features_canvas_create__WEBPACK_IMPORTED_MODULE_11__.default,
  diagram_js_lib_features_connect__WEBPACK_IMPORTED_MODULE_12__.default,
  diagram_js_lib_features_connection_preview__WEBPACK_IMPORTED_MODULE_13__.default,
  _features_context_pad__WEBPACK_IMPORTED_MODULE_14__.default,
  _features_copy_paste__WEBPACK_IMPORTED_MODULE_15__.default,
  diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_16__.default,
  _features_editor_actions__WEBPACK_IMPORTED_MODULE_17__.default,
  _features_image_selection__WEBPACK_IMPORTED_MODULE_18__.default,
  _features_keyboard__WEBPACK_IMPORTED_MODULE_19__.default,
  diagram_js_lib_features_keyboard_move_selection__WEBPACK_IMPORTED_MODULE_20__.default,
  _features_label_editing__WEBPACK_IMPORTED_MODULE_21__.default,
  _features_modeling__WEBPACK_IMPORTED_MODULE_22__.default,
  diagram_js_lib_features_move__WEBPACK_IMPORTED_MODULE_23__.default,
  _features_palette__WEBPACK_IMPORTED_MODULE_24__.default,
  _features_replace_preview__WEBPACK_IMPORTED_MODULE_25__.default,
  diagram_js_lib_features_resize__WEBPACK_IMPORTED_MODULE_26__.default,
  _features_snapping__WEBPACK_IMPORTED_MODULE_27__.default,

  _features_drag_drop_images__WEBPACK_IMPORTED_MODULE_28__.default,
  //SelectionOrganizerModule,
  //PropertiesPanelModule,
  //ImageSelectionModule,
  // CTODO
  
];


// modules the modeler is composed of
//
// - viewer modules
// - interaction modules
// - modeling modules

Modeler.prototype._modules = [].concat(
  _Viewer__WEBPACK_IMPORTED_MODULE_2__.default.prototype._modules,
  Modeler.prototype._interactionModules,
  Modeler.prototype._modelingModules
);


/***/ }),

/***/ "./lib/NavigatedViewer.js":
/*!********************************!*\
  !*** ./lib/NavigatedViewer.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NavigatedViewer)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Viewer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Viewer */ "./lib/Viewer.js");
/* harmony import */ var diagram_js_lib_navigation_keyboard_move__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/navigation/keyboard-move */ "./node_modules/diagram-js/lib/navigation/keyboard-move/index.js");
/* harmony import */ var diagram_js_lib_navigation_movecanvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/navigation/movecanvas */ "./node_modules/diagram-js/lib/navigation/movecanvas/index.js");
/* harmony import */ var diagram_js_lib_navigation_zoomscroll__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/navigation/zoomscroll */ "./node_modules/diagram-js/lib/navigation/zoomscroll/index.js");









/**
 * A viewer that includes mouse navigation facilities
 *
 * @param {Object} options
 */
function NavigatedViewer(options) {
  _Viewer__WEBPACK_IMPORTED_MODULE_1__.default.call(this, options);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(NavigatedViewer, _Viewer__WEBPACK_IMPORTED_MODULE_1__.default);


NavigatedViewer.prototype._navigationModules = [
  diagram_js_lib_navigation_keyboard_move__WEBPACK_IMPORTED_MODULE_2__.default,
  diagram_js_lib_navigation_movecanvas__WEBPACK_IMPORTED_MODULE_3__.default,
  diagram_js_lib_navigation_zoomscroll__WEBPACK_IMPORTED_MODULE_4__.default
];

NavigatedViewer.prototype._modules = [].concat(
  _Viewer__WEBPACK_IMPORTED_MODULE_1__.default.prototype._modules,
  NavigatedViewer.prototype._navigationModules
);

/***/ }),

/***/ "./lib/Viewer.js":
/*!***********************!*\
  !*** ./lib/Viewer.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Viewer)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core */ "./lib/core/index.js");
/* harmony import */ var diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/i18n/translate */ "./node_modules/diagram-js/lib/i18n/translate/index.js");
/* harmony import */ var diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/features/selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var diagram_js_lib_features_overlays__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! diagram-js/lib/features/overlays */ "./node_modules/diagram-js/lib/features/overlays/index.js");
/* harmony import */ var _BaseViewer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseViewer */ "./lib/BaseViewer.js");









function Viewer(options) {
  _BaseViewer__WEBPACK_IMPORTED_MODULE_1__.default.call(this, options);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Viewer, _BaseViewer__WEBPACK_IMPORTED_MODULE_1__.default);

// modules the viewer is composed of
Viewer.prototype._modules = [
  _core__WEBPACK_IMPORTED_MODULE_2__.default,
  diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_3__.default,
  diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_4__.default,
  diagram_js_lib_features_overlays__WEBPACK_IMPORTED_MODULE_5__.default
];

// default moddle extensions the viewer is composed of
Viewer.prototype._moddleExtensions = {};

/***/ }),

/***/ "./lib/core/index.js":
/*!***************************!*\
  !*** ./lib/core/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../draw */ "./lib/draw/index.js");
/* harmony import */ var _import__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../import */ "./lib/import/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _draw__WEBPACK_IMPORTED_MODULE_0__.default,
    _import__WEBPACK_IMPORTED_MODULE_1__.default
  ]
});

/***/ }),

/***/ "./lib/draw/PathMap.js":
/*!*****************************!*\
  !*** ./lib/draw/PathMap.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathMap)
/* harmony export */ });
/**
 * Map containing SVG paths needed by PostitRenderer.
 */

function PathMap() {

  /**
   * Contains a map of path elements
   *
   * <h1>Path definition</h1>
   * A parameterized path is defined like this:
   * <pre>
   * 'GATEWAY_PARALLEL': {
   *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
          '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
   *   height: 17.5,
   *   width:  17.5,
   *   heightElements: [2.5, 7.5],
   *   widthElements: [2.5, 7.5]
   * }
   * </pre>
   * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling
   * is based on the ratio between the specified height and width in this object and the
   * height and width that is set as scale target (Note x,y coordinates will be scaled with
   * individual ratios).</p>
   * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.
   * The scaling is based on the computed ratios.
   * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using
   * the computed ratio coefficient.
   * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.
   *   <ul>
   *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>
   *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>
   *   </ul>
   *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.
   * </p>
   */
  this.pathMap = {
    'EVENT_MESSAGE': {
      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
      height: 36,
      width:  36,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    'EVENT_SIGNAL': {
      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',
      height: 36,
      width: 36,
      heightElements: [18],
      widthElements: [10, 20]
    },
    'EVENT_ESCALATION': {
      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',
      height: 36,
      width: 36,
      heightElements: [20, 7],
      widthElements: [8]
    },
    'EVENT_CONDITIONAL': {
      d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' +
         'M {e.x2},{e.y3} l {e.x0},0 ' +
         'M {e.x2},{e.y4} l {e.x0},0 ' +
         'M {e.x2},{e.y5} l {e.x0},0 ' +
         'M {e.x2},{e.y6} l {e.x0},0 ' +
         'M {e.x2},{e.y7} l {e.x0},0 ' +
         'M {e.x2},{e.y8} l {e.x0},0 ',
      height: 36,
      width:  36,
      heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],
      widthElements:  [10.5, 14.5, 12.5]
    },
    'EVENT_LINK': {
      d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',
      height: 36,
      width: 36,
      heightElements: [4.4375, 6.75, 7.8125],
      widthElements: [9.84375, 13.5]
    },
    'EVENT_ERROR': {
      d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',
      height: 36,
      width: 36,
      heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],
      widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]
    },
    'EVENT_CANCEL_45': {
      d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' +
        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
      height: 36,
      width: 36,
      heightElements: [4.75, 8.5],
      widthElements: [4.75, 8.5]
    },
    'EVENT_COMPENSATION': {
      d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',
      height: 36,
      width: 36,
      heightElements: [6.5, 13, 0.4, 6.1],
      widthElements: [9, 9.3, 8.7]
    },
    'EVENT_TIMER_WH': {
      d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',
      height: 36,
      width:  36,
      heightElements: [10, 2],
      widthElements: [3, 7]
    },
    'EVENT_TIMER_LINE': {
      d:  'M {mx},{my} ' +
          'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',
      height: 36,
      width:  36,
      heightElements: [10, 3],
      widthElements: [0, 0]
    },
    'EVENT_MULTIPLE': {
      d:'m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',
      height: 36,
      width:  36,
      heightElements: [6.28099, 12.56199],
      widthElements: [3.1405, 9.42149, 12.56198]
    },
    'EVENT_PARALLEL_MULTIPLE': {
      d:'m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
        '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
      height: 36,
      width:  36,
      heightElements: [2.56228, 7.68683],
      widthElements: [2.56228, 7.68683]
    },
    'GATEWAY_EXCLUSIVE': {
      d:'m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' +
                    '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' +
                    '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',
      height: 17.5,
      width:  17.5,
      heightElements: [8.5, 6.5312, -6.5312, -8.5],
      widthElements:  [6.5, -6.5, 3, -3, 5, -5]
    },
    'GATEWAY_PARALLEL': {
      d:'m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' +
        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
      height: 30,
      width:  30,
      heightElements: [5, 12.5],
      widthElements: [5, 12.5]
    },
    'GATEWAY_EVENT_BASED': {
      d:'m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',
      height: 11,
      width:  11,
      heightElements: [-6, 6, 12, -12],
      widthElements: [9, -3, -12]
    },
    'GATEWAY_COMPLEX': {
      d:'m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' +
        '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' +
        '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' +
        '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',
      height: 17.125,
      width:  17.125,
      heightElements: [4.875, 3.4375, 2.125, 3],
      widthElements: [3.4375, 2.125, 4.875, 3]
    },
    'DATA_OBJECT_PATH': {
      d:'m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',
      height: 61,
      width:  51,
      heightElements: [10, 50, 60],
      widthElements: [10, 40, 50, 60]
    },
    'DATA_OBJECT_COLLECTION_PATH': {
      d:'m {mx}, {my} ' +
        'm  0 15  l 0 -15 ' +
        'm  4 15  l 0 -15 ' +
        'm  4 15  l 0 -15 ',
      height: 61,
      width:  51,
      heightElements: [12],
      widthElements: [1, 6, 12, 15]
    },
    'DATA_ARROW': {
      d:'m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',
      height: 61,
      width:  51,
      heightElements: [],
      widthElements: []
    },
    'DATA_STORE': {
      d:'m  {mx},{my} ' +
        'l  0,{e.y2} ' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +
        'l  0,-{e.y2} ' +
        'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +
        'm  -{e.x2},{e.y0}' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' +
        'm  -{e.x2},{e.y0}' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',
      height: 61,
      width:  61,
      heightElements: [7, 10, 45],
      widthElements:  [2, 58, 60]
    },
    'TEXT_ANNOTATION': {
      d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',
      height: 30,
      width: 10,
      heightElements: [30],
      widthElements: [10]
    },
    'MARKER_SUB_PROCESS': {
      d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    'MARKER_PARALLEL': {
      d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    'MARKER_SEQUENTIAL': {
      d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    'MARKER_COMPENSATION': {
      d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',
      height: 10,
      width: 21,
      heightElements: [],
      widthElements: []
    },
    'MARKER_LOOP': {
      d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' +
        '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' +
        '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' +
        'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',
      height: 13.9,
      width: 13.7,
      heightElements: [],
      widthElements: []
    },
    'MARKER_ADHOC': {
      d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' +
        '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' +
        '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' +
        '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' +
        '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',
      height: 4,
      width: 15,
      heightElements: [],
      widthElements: []
    },
    'TASK_TYPE_SEND': {
      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
      height: 14,
      width:  21,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    'TASK_TYPE_SCRIPT': {
      d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' +
        'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' +
        'm -7,-12 l 5,0 ' +
        'm -4.5,3 l 4.5,0 ' +
        'm -3,3 l 5,0' +
        'm -4,3 l 5,0',
      height: 15,
      width:  12.6,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    'TASK_TYPE_USER_1': {
      d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' +
        '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' +
        '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' +
        'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' +
        'm -8,6 l 0,5.5 m 11,0 l 0,-5'
    },
    'TASK_TYPE_USER_2': {
      d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' +
        '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '
    },
    'TASK_TYPE_USER_3': {
      d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' +
        '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' +
        '-4.20799998,3.36699999 -4.20699998,4.34799999 z'
    },
    'TASK_TYPE_MANUAL': {
      d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' +
        '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' +
        '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' +
        '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' +
        '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' +
        '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' +
        '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' +
        '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' +
        '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' +
        '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' +
        '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' +
        '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'
    },
    'TASK_TYPE_INSTANTIATING_SEND': {
      d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'
    },
    'TASK_TYPE_SERVICE': {
      d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' +
        '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' +
        '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' +
        'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' +
        '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' +
        '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' +
        'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' +
        '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' +
        'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' +
        'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' +
        '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' +
        'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' +
        'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +
        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +
        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
    },
    'TASK_TYPE_SERVICE_FILL': {
      d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +
        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +
        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
    },
    'TASK_TYPE_BUSINESS_RULE_HEADER': {
      d: 'm {mx},{my} 0,4 20,0 0,-4 z'
    },
    'TASK_TYPE_BUSINESS_RULE_MAIN': {
      d: 'm {mx},{my} 0,12 20,0 0,-12 z' +
        'm 0,8 l 20,0 ' +
        'm -13,-4 l 0,8'
    },
    'MESSAGE_FLOW_MARKER': {
      d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'
    }
  };

  this.getRawPath = function getRawPath(pathId) {
    return this.pathMap[pathId].d;
  };

  /**
   * Scales the path to the given height and width.
   * <h1>Use case</h1>
   * <p>Use case is to scale the content of elements (event, gateways) based
   * on the element bounding box's size.
   * </p>
   * <h1>Why not transform</h1>
   * <p>Scaling a path with transform() will also scale the stroke and IE does not support
   * the option 'non-scaling-stroke' to prevent this.
   * Also there are use cases where only some parts of a path should be
   * scaled.</p>
   *
   * @param {String} pathId The ID of the path.
   * @param {Object} param <p>
   *   Example param object scales the path to 60% size of the container (data.width, data.height).
   *   <pre>
   *   {
   *     xScaleFactor: 0.6,
   *     yScaleFactor:0.6,
   *     containerWidth: data.width,
   *     containerHeight: data.height,
   *     position: {
   *       mx: 0.46,
   *       my: 0.2,
   *     }
   *   }
   *   </pre>
   *   <ul>
   *    <li>targetpathwidth = xScaleFactor * containerWidth</li>
   *    <li>targetpathheight = yScaleFactor * containerHeight</li>
   *    <li>Position is used to set the starting coordinate of the path. M is computed:
    *    <ul>
    *      <li>position.x * containerWidth</li>
    *      <li>position.y * containerHeight</li>
    *    </ul>
    *    Center of the container <pre> position: {
   *       mx: 0.5,
   *       my: 0.5,
   *     }</pre>
   *     Upper left corner of the container
   *     <pre> position: {
   *       mx: 0.0,
   *       my: 0.0,
   *     }</pre>
   *    </li>
   *   </ul>
   * </p>
   *
   */
  this.getScaledPath = function getScaledPath(pathId, param) {
    var rawPath = this.pathMap[pathId];

    // positioning
    // compute the start point of the path
    var mx, my;

    if (param.abspos) {
      mx = param.abspos.x;
      my = param.abspos.y;
    } else {
      mx = param.containerWidth * param.position.mx;
      my = param.containerHeight * param.position.my;
    }

    var coordinates = {}; // map for the scaled coordinates
    if (param.position) {

      // path
      var heightRatio = (param.containerHeight / rawPath.height) * param.yScaleFactor;
      var widthRatio = (param.containerWidth / rawPath.width) * param.xScaleFactor;


      // Apply height ratio
      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
        coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
      }

      // Apply width ratio
      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
        coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
      }
    }

    // Apply value to raw path
    var path = format(
      rawPath.d, {
        mx: mx,
        my: my,
        e: coordinates
      }
    );
    return path;
  };
}

// helpers //////////////////////

// copied from https://github.com/adobe-webplatform/Snap.svg/blob/master/src/svg.js
var tokenRegex = /\{([^}]+)\}/g,
    objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g; // matches .xxxxx or ["xxxxx"] to run over object properties

function replacer(all, key, obj) {
  var res = obj;
  key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {
    name = name || quotedName;
    if (res) {
      if (name in res) {
        res = res[name];
      }
      typeof res == 'function' && isFunc && (res = res());
    }
  });
  res = (res == null || res == obj ? all : res) + '';

  return res;
}

function format(str, obj) {
  return String(str).replace(tokenRegex, function(all, key) {
    return replacer(all, key, obj);
  });
}


/***/ }),

/***/ "./lib/draw/PostitRenderer.js":
/*!************************************!*\
  !*** ./lib/draw/PostitRenderer.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitRenderer)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_draw_BaseRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/draw/BaseRenderer */ "./node_modules/diagram-js/lib/draw/BaseRenderer.js");
/* harmony import */ var _features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../features/label-editing/LabelUtil */ "./lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var _PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PostitRendererUtil */ "./lib/draw/PostitRendererUtil.js");














var DEFAULT_FILL_OPACITY = .95;

var TASK_BORDER_RADIUS = 10;

var DEFAULT_TEXT_SIZE = 16;

function PostitRenderer(
    config, eventBus, styles, pathMap,
    canvas, textRenderer, priority) {

  diagram_js_lib_draw_BaseRenderer__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus, priority);

  var defaultFillColor = config && config.defaultFillColor,
      defaultStrokeColor = config && config.defaultStrokeColor;

  var computeStyle = styles.computeStyle;

  function drawCircle(parentGfx, width, height, offset, attrs) {

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isObject)(offset)) {
      attrs = offset;
      offset = 0;
    }

    offset = offset || 0;

    attrs = computeStyle(attrs, {
      stroke: 'black',
      strokeWidth: 2,
      fill: 'white'
    });

    if (attrs.fill === 'none') {
      delete attrs.fillOpacity;
    }

    var cx = width / 2,
        cy = height / 2;

    var circle = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('circle');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(circle, {
      cx: cx,
      cy: cy,
      r: Math.round((width + height) / 4 - offset)
    });
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(circle, attrs);

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(parentGfx, circle);

    return circle;
  }

  function drawRect(parentGfx, width, height, r, offset, attrs) {

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isObject)(offset)) {
      attrs = offset;
      offset = 0;
    }

    offset = offset || 0;

    attrs = computeStyle(attrs, {
      stroke: 'black',
      strokeWidth: 2,
      fill: 'white'
    });

    var rect = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('rect');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(rect, {
      x: offset,
      y: offset,
      width: width - offset * 2,
      height: height - offset * 2,
      rx: r,
      ry: r
    });
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(rect, attrs);

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(parentGfx, rect);

    return rect;
  }

  function drawPath(parentGfx, d, attrs) {

    attrs = computeStyle(attrs, [ 'no-fill' ], {
      strokeWidth: 2,
      stroke: 'black'
    });

    var path = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('path');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(path, { d: d });
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(path, attrs);

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(parentGfx, path);

    return path;
  }


  function renderLabel(parentGfx, label, options) {

    options = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
      size: {
        width: 100
      }
    }, options);

    var text = textRenderer.createText(label || '', options);

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(text).add('djs-label');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(parentGfx, text);

    return text;
  }

  function renderEmbeddedLabel(parentGfx, element, align, fontSize) {
    var semantic = (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getSemantic)(element);

    return renderLabel(parentGfx, semantic.name, {
      box: element,
      align: align,
      padding: 5,
      style: {
        fill: getColor(element) === 'black' ? 'white' : 'black',
        fontSize: fontSize || DEFAULT_TEXT_SIZE
      },
    });
  }

  function renderExternalLabel(parentGfx, element) {

    var box = {
      width: 90,
      height: 30,
      x: element.width / 2 + element.x,
      y: element.height / 2 + element.y
    };

    return renderLabel(parentGfx, (0,_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_5__.getLabel)(element), {
      box: box,
      fitBox: true,
      style: (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(
        {},
        textRenderer.getExternalStyle(),
        {
          fill: 'black'
        }
      )
    });
  }

  this.handlers = {
    'postit:SquarePostit': function(parentGfx, element) {

      var attrs = {
        fill: (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getFillColor)(element, defaultFillColor),
        stroke: (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getStrokeColor)(element, defaultStrokeColor)
      };

      if (!('fillOpacity' in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }

      var rect = drawRect(parentGfx, element.width, element.height, 0, attrs);

      renderEmbeddedLabel(parentGfx, element, 'center-middle');

      return rect;
    },

    'postit:Group': function(parentGfx, element) {

      var group = drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {
        stroke: 'black',
        strokeWidth: 1,
        strokeDasharray: '8,3,1,3',
        fill: 'none',
        pointerEvents: 'none'
      });

      return group;
    },

    'postit:CirclePostit': function(parentGfx, element) {
      var attrs = {
        fill: (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getFillColor)(element, defaultFillColor),
        stroke: (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getStrokeColor)(element, defaultStrokeColor)
      };

      if (!('fillOpacity' in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }

      var rect = drawCircle(parentGfx, element.width, element.height, attrs);

      renderEmbeddedLabel(parentGfx, element, 'center-middle');

      return rect;
    },
    'postit:TextBox': function(parentGfx, element) {
      var attrs = {
        fill: 'none',
        stroke: 'none'
      };

      var textSize = element.textSize || DEFAULT_TEXT_SIZE;

      var rect = drawRect(parentGfx, element.width, element.height, 0, attrs);

      renderEmbeddedLabel(parentGfx, element, 'center-middle', textSize);

      return rect;
    },
    'postit:Image': function(parentGfx, element) {
      var imageSource = getImageSource(element);

      var gfx;
      if (!imageSource) {

        // default placeholder
        gfx = drawRect(parentGfx, element.width, element.height, 0, {
          fill: '#ccc',
          stroke: '#ccc'
        });

        renderLabel(parentGfx, 'Image Placeholder', {
          box: element,
          align: 'center-middle',
          padding: 5,
          style: {
            fill: 'black',
            fontSize: DEFAULT_TEXT_SIZE
          },
        });

      } else {
        gfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('image', {
          x: 0,
          y: 0,
          width: element.width,
          height: element.height,
          href: getImageSource(element)
        });

        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(parentGfx, gfx);
      }

      return gfx;
    },

    'label': function(parentGfx, element) {
      return renderExternalLabel(parentGfx, element);
    }
  };


  // extension API, use at your own risk
  this._drawPath = drawPath;

}


inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitRenderer, diagram_js_lib_draw_BaseRenderer__WEBPACK_IMPORTED_MODULE_1__.default);

PostitRenderer.$inject = [
  'config.postit',
  'eventBus',
  'styles',
  'pathMap',
  'canvas',
  'textRenderer'
];


PostitRenderer.prototype.canRender = function(element) {
  return (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_6__.is)(element, 'postit:BoardElement');
};

PostitRenderer.prototype.drawShape = function(parentGfx, element) {
  var type = element.type;
  var h = this.handlers[type];

  /* jshint -W040 */
  return h(parentGfx, element);
};

PostitRenderer.prototype.getShapePath = function(element) {

  return (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getRectPath)(element);
};

// helpers //////////

function getColor(element) {
  var bo = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_6__.getBusinessObject)(element);

  return bo.color || element.color;
}

function getImageSource(element) {
  var bo = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_6__.getBusinessObject)(element);

  return bo.source || element.source;
}



/***/ }),

/***/ "./lib/draw/PostitRendererUtil.js":
/*!****************************************!*\
  !*** ./lib/draw/PostitRendererUtil.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isTypedEvent": () => (/* binding */ isTypedEvent),
/* harmony export */   "getDi": () => (/* binding */ getDi),
/* harmony export */   "getSemantic": () => (/* binding */ getSemantic),
/* harmony export */   "getFillColor": () => (/* binding */ getFillColor),
/* harmony export */   "getStrokeColor": () => (/* binding */ getStrokeColor),
/* harmony export */   "getCirclePath": () => (/* binding */ getCirclePath),
/* harmony export */   "getRoundRectPath": () => (/* binding */ getRoundRectPath),
/* harmony export */   "getDiamondPath": () => (/* binding */ getDiamondPath),
/* harmony export */   "getRectPath": () => (/* binding */ getRectPath)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/util/RenderUtil */ "./node_modules/diagram-js/lib/util/RenderUtil.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/ModelUtil */ "./lib/util/ModelUtil.js");







// element utils //////////////////////

/**
 * Checks if eventDefinition of the given element matches with semantic type.
 *
 * @return {boolean} true if element is of the given semantic type
 */
function isTypedEvent(event, eventDefinitionType, filter) {

  function matches(definition, filter) {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.every)(filter, function(val, key) {

      // we want a == conversion here, to be able to catch
      // undefined == false and friends
      /* jshint -W116 */
      return definition[key] == val;
    });
  }

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.some)(event.eventDefinitions, function(definition) {
    return definition.$type === eventDefinitionType && matches(event, filter);
  });
}

function getDi(element) {
  return element.businessObject.di;
}

function getSemantic(element) {
  return element.businessObject;
}


// color access //////////////////////

function getFillColor(element, defaultColor) {
  return (
    getColor(element) ||
    getDi(element).get('bioc:fill') ||
    defaultColor ||
    'white'
  );
}

function getStrokeColor(element, defaultColor) {
  return (
    getColor(element) ||
    getDi(element).get('bioc:stroke') ||
    defaultColor ||
    'black'
  );
}


// cropping path customizations //////////////////////

function getCirclePath(shape) {

  var cx = shape.x + shape.width / 2,
      cy = shape.y + shape.height / 2,
      radius = shape.width / 2;

  var circlePath = [
    ['M', cx, cy],
    ['m', 0, -radius],
    ['a', radius, radius, 0, 1, 1, 0, 2 * radius],
    ['a', radius, radius, 0, 1, 1, 0, -2 * radius],
    ['z']
  ];

  return (0,diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__.componentsToPath)(circlePath);
}

function getRoundRectPath(shape, borderRadius) {

  var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;

  var roundRectPath = [
    ['M', x + borderRadius, y],
    ['l', width - borderRadius * 2, 0],
    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],
    ['l', 0, height - borderRadius * 2],
    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],
    ['l', borderRadius * 2 - width, 0],
    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],
    ['l', 0, borderRadius * 2 - height],
    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],
    ['z']
  ];

  return (0,diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__.componentsToPath)(roundRectPath);
}

function getDiamondPath(shape) {

  var width = shape.width,
      height = shape.height,
      x = shape.x,
      y = shape.y,
      halfWidth = width / 2,
      halfHeight = height / 2;

  var diamondPath = [
    ['M', x + halfWidth, y],
    ['l', halfWidth, halfHeight],
    ['l', -halfWidth, halfHeight],
    ['l', -halfWidth, -halfHeight],
    ['z']
  ];

  return (0,diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__.componentsToPath)(diamondPath);
}

function getRectPath(shape) {
  var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;

  var rectPath = [
    ['M', x, y],
    ['l', width, 0],
    ['l', 0, height],
    ['l', -width, 0],
    ['z']
  ];

  return (0,diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__.componentsToPath)(rectPath);
}

// helpers //////////

function getColor(element) {
  var bo = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.getBusinessObject)(element);

  return bo.color || element.color;
}

/***/ }),

/***/ "./lib/draw/TextRenderer.js":
/*!**********************************!*\
  !*** ./lib/draw/TextRenderer.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextRenderer)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_util_Text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/util/Text */ "./node_modules/diagram-js/lib/util/Text.js");




var DEFAULT_FONT_SIZE = 16;
var LINE_HEIGHT_RATIO = 1.2;


function TextRenderer(config) {

  var defaultStyle = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
    fontFamily: 'IBM Plex, sans-serif',
    fontSize: DEFAULT_FONT_SIZE,
    fontWeight: 'normal',
    lineHeight: LINE_HEIGHT_RATIO
  }, config && config.defaultStyle || {});

  var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;

  var externalStyle = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, defaultStyle, {
    fontSize: fontSize
  }, config && config.externalStyle || {});

  var textUtil = new diagram_js_lib_util_Text__WEBPACK_IMPORTED_MODULE_1__.default({
    style: defaultStyle
  });

  /**
   * Get the new bounds of an externally rendered,
   * layouted label.
   *
   * @param  {Bounds} bounds
   * @param  {String} text
   *
   * @return {Bounds}
   */
  this.getExternalLabelBounds = function(bounds, text) {

    var layoutedDimensions = textUtil.getDimensions(text, {
      box: {
        width: 90,
        height: 30,
        x: bounds.width / 2 + bounds.x,
        y: bounds.height / 2 + bounds.y
      },
      style: externalStyle
    });

    // resize label shape to fit label text
    return {
      x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),
      y: Math.round(bounds.y),
      width: Math.ceil(layoutedDimensions.width),
      height: Math.ceil(layoutedDimensions.height)
    };

  };

  /**
   * Create a layouted text element.
   *
   * @param {String} text
   * @param {Object} [options]
   *
   * @return {SVGElement} rendered text
   */
  this.createText = function(text, options) {
    return textUtil.createText(text, options || {});
  };

  /**
   * Get default text style.
   */
  this.getDefaultStyle = function() {
    return defaultStyle;
  };

  /**
   * Get the external text style.
   */
  this.getExternalStyle = function() {
    return externalStyle;
  };

}

TextRenderer.$inject = [
  'config.textRenderer'
];

/***/ }),

/***/ "./lib/draw/index.js":
/*!***************************!*\
  !*** ./lib/draw/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PostitRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PostitRenderer */ "./lib/draw/PostitRenderer.js");
/* harmony import */ var _TextRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextRenderer */ "./lib/draw/TextRenderer.js");
/* harmony import */ var _PathMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PathMap */ "./lib/draw/PathMap.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'postitRenderer' ],
  postitRenderer: [ 'type', _PostitRenderer__WEBPACK_IMPORTED_MODULE_0__.default ],
  textRenderer: [ 'type', _TextRenderer__WEBPACK_IMPORTED_MODULE_1__.default ],
  pathMap: [ 'type', _PathMap__WEBPACK_IMPORTED_MODULE_2__.default ]
});


/***/ }),

/***/ "./lib/features/canvas-create/CanvasCreate.js":
/*!****************************************************!*\
  !*** ./lib/features/canvas-create/CanvasCreate.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CanvasCreate)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var _util_ColorUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/ColorUtil */ "./lib/util/ColorUtil.js");
/* harmony import */ var diagram_js_lib_util_Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/util/Event */ "./node_modules/diagram-js/lib/util/Event.js");
/* harmony import */ var _modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modeling/util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");











var DEFAULT_SHAPE = {
  type: 'postit:SquarePostit',
  color: _util_ColorUtil__WEBPACK_IMPORTED_MODULE_0__.default.YELLOW,
  $instanceOf: function() { return true; }
};

function CanvasCreate(
    eventBus, elementFactory, canvas, directEditing, modeling) {

  var lastCreatedShape = DEFAULT_SHAPE;

  function _getNewShapePosition(event) {
    var eventPoint = (0,diagram_js_lib_util_Event__WEBPACK_IMPORTED_MODULE_1__.toPoint)(event);

    return {
      x: eventPoint.x,
      y: eventPoint.y
    };
  }

  function _activateDirectEdit(element) {
    if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_2__.isAny)(element, [ 'postit:Postit', 'postit:Group', 'postit:TextBox' ])) {

      directEditing.activate(element);
    }
  }

  function _createShapeOnCanvas(event) {
    var position = _getNewShapePosition(event);

    var newShape = elementFactory.createPostitElement(
      'shape', (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)(lastCreatedShape, position));

    var root = canvas.getRootElement();

    var createdShape = modeling.createShape(newShape, position, root);

    _activateDirectEdit(createdShape);
  }

  function _saveLastCreatedShape(shape) {
    if (!shape) {
      lastCreatedShape = DEFAULT_SHAPE;
      return;
    }

    var bo = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.getBusinessObject)(shape);

    lastCreatedShape = {
      type: shape.type,
      color: shape.color || bo.color,
      $instanceOf: function(type) {
        return (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);
      }
    };
  }


  function _createDropShadowFilter(viewport) {
    viewport.innerHTML = '<filter id="noteDropShadow" style="height: 130%;"><feGaussianBlur in="SourceAlpha" stdDeviation="3"></feGaussianBlur><feOffset dx="1" dy="2" result="offsetblur"></feOffset><feMerge><feMergeNode></feMergeNode><feMergeNode in="SourceGraphic"></feMergeNode></feMerge></filter>';
  }


  eventBus.on('canvas.init', function(context) {
    var svg = context.svg;

    _createDropShadowFilter(context.viewport);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.delegate.bind(svg, 'svg', 'dblclick', function(event) {
      if (event.target !== svg) {
        return;
      }

      _createShapeOnCanvas(event);
    });

    eventBus.on('create.end', function(context) {
      var shape = context.shape;
      _saveLastCreatedShape(shape);
    });
  });
}

CanvasCreate.prototype.$inject = [
  'eventBus',
  'elementFactory',
  'canvas',
  'directEditing',
  'modeling'
];


/***/ }),

/***/ "./lib/features/canvas-create/index.js":
/*!*********************************************!*\
  !*** ./lib/features/canvas-create/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CanvasCreate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CanvasCreate */ "./lib/features/canvas-create/CanvasCreate.js");
/* harmony import */ var diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js-direct-editing */ "./node_modules/diagram-js-direct-editing/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'canvasCreate' ],
  canvasCreate: [ 'type', _CanvasCreate__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./lib/features/context-pad/ContextPadProvider.js":
/*!********************************************************!*\
  !*** ./lib/features/context-pad/ContextPadProvider.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ContextPadProvider)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_util_Mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var _util_ColorUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/ColorUtil */ "./lib/util/ColorUtil.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");








/**
 * A provider for postit elements context pad
 */
function ContextPadProvider(
    config, injector, eventBus,
    contextPad, modeling, rules,
    imageSelection, translate) {

  config = config || {};

  contextPad.registerProvider(this);

  this._contextPad = contextPad;

  this._modeling = modeling;

  this._rules = rules;
  this._imageSelection = imageSelection;
  this._translate = translate;

  if (config.autoPlace !== false) {
    this._autoPlace = injector.get('autoPlace', false);
  }

  eventBus.on('create.end', 250, function(event) {
    var context = event.context,
        shape = context.shape;

    if (!(0,diagram_js_lib_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.hasPrimaryModifier)(event) || !contextPad.isOpen(shape)) {
      return;
    }

    var entries = contextPad.getEntries(shape);

    if (entries.replace) {
      entries.replace.action.click(event, shape);
    }
  });
}

ContextPadProvider.$inject = [
  'config.contextPad',
  'injector',
  'eventBus',
  'contextPad',
  'modeling',
  'rules',
  'imageSelection',
  'translate'
];


ContextPadProvider.prototype.getContextPadEntries = function(element) {

  const {
    _rules: rules,
    _modeling: modeling,
    _imageSelection: imageSelection,
    _translate: translate
  } = this;

  let actions = {};

  function _removeElement(e) {
    var urlParams = new URLSearchParams(window.location.search);
    var s_key = urlParams.get('s_key');
    if( s_key === null ) {
      shepherdAlert("Script Required", "You must open a script to update it's notes.");
    } else {
      $.ajax({
        type: "DELETE",
        beforeSend: function(xhr) {
                      xhr.setRequestHeader('X-CSRF-Token',
                          $('meta[name="csrf-token"]').attr('content'));
                    },
        url: "/scripts/" + s_key + "/destroy_image/" + element.businessObject.$attrs["key"],
        responseType: 'application/json',
        dataType: 'json',
        failure: function(data) {
          // Consciously not doing anything. Fail silently and clean up
          // later.
        }
      });
    }
    modeling.removeElements([ element ]);
  }

  function removeElement(e) {
    if( element.type === "postit:Image" ) {
      shepherdConfirm("Confirm Delete?", "Are you sure you want to delete this element?", _removeElement, [e]);
    } else {
      modeling.removeElements([ element ]);
    }
  }

  function setColor(color) {
    modeling.setColor(element, color);
  }

  function createDeleteEntry(actions) {

    // delete element entry, only show if allowed by rules
    let deleteAllowed = rules.allowed('elements.delete', { elements: [ element ] });

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isArray)(deleteAllowed)) {

      // was the element returned as a deletion candidate?
      deleteAllowed = deleteAllowed[0] === element;
    }

    if (deleteAllowed) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(actions, {
        'delete': {
          group: 'edit',
          className: 'bpmn-icon-trash',
          title: translate('Remove'),
          action: {
            click: removeElement
          }
        }
      });
    }
  }

  function createColoringEntries(actions) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.keys)(_util_ColorUtil__WEBPACK_IMPORTED_MODULE_2__.default), key => {
      var color = _util_ColorUtil__WEBPACK_IMPORTED_MODULE_2__.default[key];

      function getClassNames() {
        var classNames = [];

        if (color === getColor(element)) {

          classNames.push('pjs-color-entry-disabled');
        }

        classNames.push('pjs-color-entry-' + key);

        return classNames;
      }

      (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(actions, {
        ['color-' + key]: {
          group: 'color',
          className: getClassNames(),
          title: translate('Set Color'),
          action: {
            click: (event) => setColor(color)
          }
        }
      });
    });
  }

  if (element.type === 'label') {
    return actions;
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(element, 'postit:Postit')) {
    createColoringEntries(actions);
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(element, 'postit:Image')) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(actions, {
      'replace.image': {
        group: 'replace',
        className: 'bpmn-icon-screw-wrench',
        title: translate('Change image source'),
        action: {
          click: (event) => imageSelection.select(element)
        }
      }
    });
  }

  createDeleteEntry(actions);

  return actions;
};

// helpers //////////

function getColor(element) {
  var bo = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.getBusinessObject)(element);

  return bo.color || element.color;
}


/***/ }),

/***/ "./lib/features/context-pad/index.js":
/*!*******************************************!*\
  !*** ./lib/features/context-pad/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js-direct-editing */ "./node_modules/diagram-js-direct-editing/index.js");
/* harmony import */ var diagram_js_lib_features_context_pad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/context-pad */ "./node_modules/diagram-js/lib/features/context-pad/index.js");
/* harmony import */ var diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/features/selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var diagram_js_lib_features_connect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/features/connect */ "./node_modules/diagram-js/lib/features/connect/index.js");
/* harmony import */ var diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/features/create */ "./node_modules/diagram-js/lib/features/create/index.js");
/* harmony import */ var _popup_menu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../popup-menu */ "./lib/features/popup-menu/index.js");
/* harmony import */ var _ContextPadProvider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ContextPadProvider */ "./lib/features/context-pad/ContextPadProvider.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__.default,
    diagram_js_lib_features_context_pad__WEBPACK_IMPORTED_MODULE_1__.default,
    diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_2__.default,
    diagram_js_lib_features_connect__WEBPACK_IMPORTED_MODULE_3__.default,
    diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_4__.default,
    _popup_menu__WEBPACK_IMPORTED_MODULE_5__.default
  ],
  __init__: [ 'contextPadProvider' ],
  contextPadProvider: [ 'type', _ContextPadProvider__WEBPACK_IMPORTED_MODULE_6__.default ]
});

/***/ }),

/***/ "./lib/features/copy-paste/ModdleCopy.js":
/*!***********************************************!*\
  !*** ./lib/features/copy-paste/ModdleCopy.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ModdleCopy),
/* harmony export */   "getPropertyNames": () => (/* binding */ getPropertyNames)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var DISALLOWED_PROPERTIES = [
  'boardElements'
];

/**
 * @typedef {Function} <moddleCopy.canCopyProperties> listener
 *
 * @param {Object} context
 * @param {Array<string>} context.propertyNames
 * @param {ModdleElement} context.sourceElement
 * @param {ModdleElement} context.targetElement
 *
 * @returns {Array<string>|boolean} - Return properties to be copied or false to disallow
 * copying.
 */

/**
 * @typedef {Function} <moddleCopy.canCopyProperty> listener
 *
 * @param {Object} context
 * @param {ModdleElement} context.parent
 * @param {*} context.property
 * @param {string} context.propertyName
 *
 * @returns {*|boolean} - Return copied property or false to disallow
 * copying.
 */

/**
 * @typedef {Function} <moddleCopy.canSetCopiedProperty> listener
 *
 * @param {Object} context
 * @param {ModdleElement} context.parent
 * @param {*} context.property
 * @param {string} context.propertyName
 *
 * @returns {boolean} - Return false to disallow
 * setting copied property.
 */

/**
 * Utility for copying model properties from source element to target element.
 *
 * @param {EventBus} eventBus
 * @param {PostitFactory} postitFactory
 * @param {PostitModdle} moddle
 */
function ModdleCopy(eventBus, postitFactory, moddle) {
  this._postitFactory = postitFactory;
  this._eventBus = eventBus;
  this._moddle = moddle;

  // copy extension elements last
  eventBus.on('moddleCopy.canCopyProperties', function(context) {
    var propertyNames = context.propertyNames;

    if (!propertyNames || !propertyNames.length) {
      return;
    }

    return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(propertyNames, function(propertyName) {
      return propertyName === 'extensionElements';
    });
  });

  // default check whether property can be copied
  eventBus.on('moddleCopy.canCopyProperty', function(context) {
    var parent = context.parent,
        parentDescriptor = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(parent) && parent.$descriptor,
        propertyName = context.propertyName;

    if (propertyName && DISALLOWED_PROPERTIES.indexOf(propertyName) !== -1) {

      // disallow copying property
      return false;
    }

    if (propertyName &&
      parentDescriptor &&
      !(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(parentDescriptor.properties, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.matchPattern)({ name: propertyName }))) {

      // disallow copying property
      return false;
    }
  });
}

ModdleCopy.$inject = [
  'eventBus',
  'postitFactory',
  'moddle'
];

/**
 * Copy model properties of source element to target element.
 *
 * @param {ModdleElement} sourceElement
 * @param {ModdleElement} targetElement
 * @param {Array<string>} [propertyNames]
 *
 * @param {ModdleElement}
 */
ModdleCopy.prototype.copyElement = function(sourceElement, targetElement, propertyNames) {
  var self = this;

  if (propertyNames && !(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(propertyNames)) {
    propertyNames = [ propertyNames ];
  }

  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);

  var canCopyProperties = this._eventBus.fire('moddleCopy.canCopyProperties', {
    propertyNames: propertyNames,
    sourceElement: sourceElement,
    targetElement: targetElement
  });

  if (canCopyProperties === false) {
    return targetElement;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(canCopyProperties)) {
    propertyNames = canCopyProperties;
  }

  // copy properties
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(propertyNames, function(propertyName) {
    var sourceProperty;

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.has)(sourceElement, propertyName)) {
      sourceProperty = sourceElement.get(propertyName);
    }

    var copiedProperty = self.copyProperty(sourceProperty, targetElement, propertyName);

    var canSetProperty = self._eventBus.fire('moddleCopy.canSetCopiedProperty', {
      parent: targetElement,
      property: copiedProperty,
      propertyName: propertyName
    });

    if (canSetProperty === false) {
      return;
    }

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isDefined)(copiedProperty)) {
      targetElement.set(propertyName, copiedProperty);
    }
  });

  return targetElement;
};

/**
 * Copy model property.
 *
 * @param {*} property
 * @param {ModdleElement} parent
 * @param {string} propertyName
 *
 * @returns {*}
 */
ModdleCopy.prototype.copyProperty = function(property, parent, propertyName) {
  var self = this;

  // allow others to copy property
  var copiedProperty = this._eventBus.fire('moddleCopy.canCopyProperty', {
    parent: parent,
    property: property,
    propertyName: propertyName
  });

  // return if copying is NOT allowed
  if (copiedProperty === false) {
    return;
  }

  if (copiedProperty) {
    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {
      copiedProperty.$parent = parent;
    }

    return copiedProperty;
  }

  var propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName);

  // do NOT copy Ids and references
  if (propertyDescriptor.isId || propertyDescriptor.isReference) {
    return;
  }

  // copy arrays
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(property)) {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(property, function(childProperties, childProperty) {

      // recursion
      copiedProperty = self.copyProperty(childProperty, parent, propertyName);

      // copying might NOT be allowed
      if (copiedProperty) {
        copiedProperty.$parent = parent;

        return childProperties.concat(copiedProperty);
      }

      return childProperties;
    }, []);
  }

  // copy model elements
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(property) && property.$type) {
    if (this._moddle.getElementDescriptor(property).isGeneric) {
      return;
    }

    copiedProperty = self._postitFactory.create(property.$type);

    copiedProperty.$parent = parent;

    // recursion
    copiedProperty = self.copyElement(property, copiedProperty);

    return copiedProperty;
  }

  // copy primitive properties
  return property;
};

// helpers //////////

function getPropertyNames(descriptor, keepDefaultProperties) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(descriptor.properties, function(properties, property) {

    if (keepDefaultProperties && property.default) {
      return properties;
    }

    return properties.concat(property.name);
  }, []);
}

/***/ }),

/***/ "./lib/features/copy-paste/PostitCopyPaste.js":
/*!****************************************************!*\
  !*** ./lib/features/copy-paste/PostitCopyPaste.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitCopyPaste)
/* harmony export */ });
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");




function copyProperties(source, target, properties) {
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(properties)) {
    properties = [ properties ];
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(properties, function(property) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(source[property])) {
      target[property] = source[property];
    }
  });
}

function removeProperties(element, properties) {
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(properties)) {
    properties = [ properties ];
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(properties, function(property) {
    if (element[property]) {
      delete element[property];
    }
  });
}

var LOW_PRIORITY = 750;


function PostitCopyPaste(postitFactory, eventBus, moddleCopy) {

  eventBus.on('copyPaste.copyElement', LOW_PRIORITY, function(context) {
    var descriptor = context.descriptor,
        element = context.element;

    var businessObject = descriptor.oldBusinessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__.getBusinessObject)(element);

    descriptor.type = element.type;

    copyProperties(businessObject, descriptor, 'name');

    descriptor.di = {};

    // fill and stroke will be set to DI
    copyProperties(businessObject.di, descriptor.di, [
      'fill',
      'stroke'
    ]);

    if (isLabel(descriptor)) {
      return descriptor;
    }

  });

  var references;

  function resolveReferences(descriptor, cache) {
    var businessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__.getBusinessObject)(descriptor);

    // default sequence flows
    if (descriptor.default) {

      // relationship cannot be resolved immediately
      references[ descriptor.default ] = {
        element: businessObject,
        property: 'default'
      };
    }

    references = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(references, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(references, function(array, reference, key) {
      var element = reference.element,
          property = reference.property;

      if (key === descriptor.id) {
        element[ property ] = businessObject;

        array.push(descriptor.id);
      }

      return array;
    }, []));
  }

  eventBus.on('copyPaste.pasteElements', function() {
    references = {};
  });

  eventBus.on('copyPaste.pasteElement', function(context) {
    var cache = context.cache,
        descriptor = context.descriptor,
        oldBusinessObject = descriptor.oldBusinessObject,
        newBusinessObject;

    // do NOT copy business object if external label
    if (isLabel(descriptor)) {
      descriptor.businessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__.getBusinessObject)(cache[ descriptor.labelTarget ]);

      return;
    }

    newBusinessObject = postitFactory.create(oldBusinessObject.$type);

    descriptor.businessObject = moddleCopy.copyElement(
      oldBusinessObject,
      newBusinessObject
    );

    // resolve references e.g. default sequence flow
    resolveReferences(descriptor, cache);

    copyProperties(descriptor, newBusinessObject, [
      'color',
      'name'
    ]);

    removeProperties(descriptor, 'oldBusinessObject');
  });

}


PostitCopyPaste.$inject = [
  'postitFactory',
  'eventBus',
  'moddleCopy'
];

// helpers //////////

function isLabel(element) {
  return !!element.labelTarget;
}


/***/ }),

/***/ "./lib/features/copy-paste/index.js":
/*!******************************************!*\
  !*** ./lib/features/copy-paste/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_copy_paste__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/copy-paste */ "./node_modules/diagram-js/lib/features/copy-paste/index.js");
/* harmony import */ var _PostitCopyPaste__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitCopyPaste */ "./lib/features/copy-paste/PostitCopyPaste.js");
/* harmony import */ var _ModdleCopy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ModdleCopy */ "./lib/features/copy-paste/ModdleCopy.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_copy_paste__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'postitCopyPaste', 'moddleCopy' ],
  postitCopyPaste: [ 'type', _PostitCopyPaste__WEBPACK_IMPORTED_MODULE_1__.default ],
  moddleCopy: [ 'type', _ModdleCopy__WEBPACK_IMPORTED_MODULE_2__.default ]
});


/***/ }),

/***/ "./lib/features/di-ordering/PostitDiOrdering.js":
/*!******************************************************!*\
  !*** ./lib/features/di-ordering/PostitDiOrdering.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitDiOrdering)
/* harmony export */ });
/* harmony import */ var _draw_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../draw/PostitRendererUtil */ "./lib/draw/PostitRendererUtil.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_util_Elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");








var HIGH_PRIORITY = 2000;

function PostitDiOrdering(eventBus, canvas) {

  eventBus.on('saveXML.start', HIGH_PRIORITY, orderDi);

  function orderDi() {
    var root = canvas.getRootElement(),
        rootDi = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.getBusinessObject)(root).di,
        elements,
        diElements;

    elements = (0,diagram_js_lib_util_Elements__WEBPACK_IMPORTED_MODULE_1__.selfAndAllChildren)([ root ], false);

    // only postitDi:Shape can be direct children of postitDi:Plane
    elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(elements, function(element) {
      return element !== root && !element.labelTarget;
    });

    diElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.map)(elements, _draw_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_3__.getDi);

    rootDi.set('planeElement', diElements);
  }
}

PostitDiOrdering.$inject = [ 'eventBus', 'canvas' ];


/***/ }),

/***/ "./lib/features/di-ordering/index.js":
/*!*******************************************!*\
  !*** ./lib/features/di-ordering/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PostitDiOrdering__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PostitDiOrdering */ "./lib/features/di-ordering/PostitDiOrdering.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [
    'postitDiOrdering'
  ],
  postitDiOrdering: [ 'type', _PostitDiOrdering__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./lib/features/drag-drop-images/DragDropImages.js":
/*!*********************************************************!*\
  !*** ./lib/features/drag-drop-images/DragDropImages.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragDropImages)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _FileUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FileUtil.js */ "./lib/features/drag-drop-images/FileUtil.js");






/* constants */
const POSTIT_IMAGE = 'postit:Image';
function randStr(length=5) {
  var result = '';
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  var charactersLength = characters.length;
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
const ENTRY_PROTOTYPE = () => {
  return {
    objId: randStr(),
    objType: POSTIT_IMAGE,
    objTitle: '',
    objDescription: '',
    objStarred: false,
    objHidden: false,
    objUnkeyed: false,
    objUnkeyedOriginal: false,
    objSrcUnkeyed: '',
    objCreationDate: '',
    source: '',
    objPositionX: null,
    objPositionY: null,
  };
};

/* constants */


var text;
function DragDropImages(eventBus, canvas, modeling, elementFactory, create, translate) {

  this._eventBus = eventBus;
  this._canvas = canvas;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._create = create;
  this._translate = translate;

  text = { 'URL': this._translate('URL'),
    'An error occured during the file upload': this._translate('An error occured during the file upload'),
    'Upload files here': this._translate('Upload files here'),
    'Upload from local is for demo purposes only. It slows down the page and increases the file size.': this._translate('Upload from local is for demo purposes only. It slows down the page and increases the file size.'),
    'uploaded': this._translate('uploaded'),
    'file': this._translate('file'),
    'files': this._translate('files'),
    'selected': this._translate('selected'),
    'Upload again': this._translate('Upload again'),
    'Drag here': this._translate('Drag here'),
  };

  DragDropImages.CSS = `
    .pjs-visible {
      visibility: visible !important;
      display: block !important;
    }
    
    #pjs-drop-zone {
      visibility: hidden;
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: #555555;
      z-index: 1;
      opacity: 0.9;
    }

    #pjs-drop-zone-border {
      border-radius: 10px 10px 10px 10px;
      -moz-border-radius: 10px 10px 10px 10px;
      -webkit-border-radius: 10px 10px 10px 10px;
      border: 5px dashed #000000;
      z-index: 2;
      display: table;
      width: 98.9%;
      height: 100%; 
    }

    .pjs-drop-zone-text {
      vertical-align: middle;
      width: 100%;
      font-size: 25px;
      font-weight: bold;
      margin: 0 auto;
      text-align: center;
      display: table-cell;
  }`;

  DragDropImages.HTML_MARKUP = '<div id="pjs-drop-zone">'+
        '<div id="pjs-drop-zone-border">'+
          '<div class="pjs-drop-zone-text">'+
          text['Drag here']+
        '</div>'+
      '</div>'+
  '</div>';

  var style = document.createElement('style');
  style.type = 'text/css';
  style.innerHTML = DragDropImages.CSS;
  document.getElementsByTagName('HEAD')[0].appendChild(style);

  const canvasDOM = document.getElementById('noteCanvas');

  const container = this._container = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(DragDropImages.HTML_MARKUP);
  canvasDOM.insertBefore(container, canvas.firstChild);

  function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
  }

  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'drag', function(ev) {
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'dragstart', function(ev) {
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'dragend', function(ev) {
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'dragover', function(ev) {
    preventDefaults(ev);
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'dragenter', function(ev) {
    document.getElementById('pjs-drop-zone').classList.add('pjs-visible');
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM,'dragleave', function(ev) {
    document.getElementById('pjs-drop-zone').classList.remove('pjs-visible');
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'drop', function(ev) {
    preventDefaults(ev);
    document.getElementById('pjs-drop-zone').classList.remove('pjs-visible');
    uploadFiles(ev);
  }, false);


  async function uploadFiles(ev) {
    let uploadDisplayText;
    let uploadResultObj = await (0,_FileUtil_js__WEBPACK_IMPORTED_MODULE_1__.fileReader)(ev, null);
    let uploadResult = uploadResultObj.results;
    let errors = uploadResultObj.errors;
    if (!errors) {
      let uploadedFilesCount = (uploadResult.length) ? uploadResult.length : null;
      uploadDisplayText = uploadedFilesCount;
      if (isNaN(uploadedFilesCount) === false) {
        const filePluralText =+ (uploadResult.length == 1) ? text['file'] : text['files'];
        uploadDisplayText += ' ' + filePluralText + ' ' + text['uploaded'];
      }
      let i = uploadResult.length;
      while (i--) {
        await createImageElement(ev, convertToEntry({ source: uploadResult[i] }));
      }
      console.log(uploadDisplayText);

    }
  }

  async function createImageElement(event, options) {
    options = options || [];

    var urlParams = new URLSearchParams(window.location.search);
    var s_key = urlParams.get('s_key');
    if( s_key === null ) {
      shepherdAlert("Script Required", "You must open a script before you can take notes!")
      return { ...ENTRY_PROTOTYPE(), ...options };
    } else {
      let image, blob;
      blob = options.source;

      // Ugly because we expect this URL to exist on the page.
      var upload = new ActiveStorage.DirectUpload(
        blob,
        direct_upload_url
      );

      await upload.create(function(error, blob) {
        if( error !== null ) {
          if( error.search("Status: 403") >= 0 ) {
            shepherdAlert("Subscription Needed!", "You must have an active subscription to save images! You can sign up <button data-toggle=\"modal\" href=\"#subscriptionModal\" onclick=\"Shepherd.activeTour.complete(); $('#ideatorNotesModal').modal('hide');\" data-description=\"Sign up for image uploading and other great featuers!\" data-reset=\"$('#ideatorNotesModal').modal(\'show\');\" style=\"color: blue; margin-left: -6px; text-decoration: underline;\">here!</button>");
          } else {
            shepherdAlert("Unknown Error", "We've logged this issue.  If it continues, please reach out to support.");
            Bugsnag.notify("Unknown upload response: " + blob.toString() )
          }
        }

        // Now build our local copy.
        const shape = this._elementFactory.createShape({
          type: POSTIT_IMAGE,
          ...options,
        });
        const attach = false;
        const hints = { createElementsBehavior: false };
        const position = { x: event.x + (Math.random() * 100), y: event.y + (Math.random() * 100) };
        const target = this._canvas.getRootElement();
        this._modeling.createElements([shape], position, target, (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, hints, {
          attach: attach,
        }));

        if( blob.key ) {

          // Now register it with the server.
          $.ajax({
            type: "GET",
            beforeSend: function(xhr) {
                          xhr.setRequestHeader('X-CSRF-Token',
                              $('meta[name="csrf-token"]').attr('content'));
                        },
            url: "/scripts/" + s_key + "/image_url/" + blob.key,
            responseType: 'application/json',
            dataType: 'json',
            success: function(data) {
              self._modeling.updateProperties(element, {
                source: data.url,
                key: data.key
              });
              }
          });
        }
        return { id: shape.id, x: position.x, y: position.y, shape, width: shape.width, height: shape.height };
      });
    }
  }
}

const convertToEntry = function(options) {
  return { ...ENTRY_PROTOTYPE(), ...options };
};

DragDropImages.prototype.$inject = [
  'eventBus',
  'canvas',
  'modeling',
  'elementFactory',
  'create',
  'translate'
];


/***/ }),

/***/ "./lib/features/drag-drop-images/FileUtil.js":
/*!***************************************************!*\
  !*** ./lib/features/drag-drop-images/FileUtil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fileToDataURL": () => (/* binding */ fileToDataURL),
/* harmony export */   "imageProcessor": () => (/* binding */ imageProcessor),
/* harmony export */   "fileReader": () => (/* binding */ fileReader)
/* harmony export */ });
function fileToDataURL(file) {
  return new Promise((resolve, reject) => {
    try {
      var reader = new FileReader();
      reader.onloadend = function() {
        resolve(reader.result);
      };
      reader.readAsDataURL(file);
    } catch (e) {
      reject(e);
    }
  });
}

async function imageProcessor(ev, file) {
  const base64file = await fileToDataURL(file);
  return base64file; // passing any errors through
}

async function fileReader(ev, files) {
  let uploadResult = [];
  let errors;
  let fileItems = files;
  if (ev && (ev.dataTransfer.items || ev.dataTransfer.files)) {
    fileItems = ev.dataTransfer.items || ev.dataTransfer.files;
  }
  try {
    if (fileItems) {
      for (var i = 0; i < fileItems.length; i++) {
        if (ev && ev.dataTransfer.items) {
          if (fileItems[i].kind === 'file') {
            var file = fileItems[i].getAsFile();
            uploadResult.push(file);
          }
        } else {
          uploadResult.push(fileItems[i]);
        }
      }
    }
  } catch (e) {
    errors = e;
    uploadResult = null;
  }
  const results = [];
  var j = 0;
  while (j < uploadResult.length) {
    const fileImg = await imageProcessor(ev, uploadResult[j]);
    results.push(fileImg);
    j+=1;
  }
  return { results, errors };
}



/***/ }),

/***/ "./lib/features/drag-drop-images/index.js":
/*!************************************************!*\
  !*** ./lib/features/drag-drop-images/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DragDropImages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragDropImages */ "./lib/features/drag-drop-images/DragDropImages.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'dragDropImages' ],
  dragDropImages: [ 'type', _DragDropImages__WEBPACK_IMPORTED_MODULE_0__.default]
});


/***/ }),

/***/ "./lib/features/editor-actions/PostitEditorActions.js":
/*!************************************************************!*\
  !*** ./lib/features/editor-actions/PostitEditorActions.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitEditorActions)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_features_editor_actions_EditorActions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/editor-actions/EditorActions */ "./node_modules/diagram-js/lib/features/editor-actions/EditorActions.js");
/* harmony import */ var diagram_js_lib_util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");







/**
 * Registers and executes Postit specific editor actions.
 *
 * @param {Injector} injector
 */
function PostitEditorActions(injector) {
  injector.invoke(diagram_js_lib_features_editor_actions_EditorActions__WEBPACK_IMPORTED_MODULE_1__.default, this);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitEditorActions, diagram_js_lib_features_editor_actions_EditorActions__WEBPACK_IMPORTED_MODULE_1__.default);

PostitEditorActions.$inject = [
  'injector'
];

/**
 * Register default actions.
 *
 * @param {Injector} injector
 */
PostitEditorActions.prototype._registerDefaultActions = function(injector) {

  // (0) invoke super method

  diagram_js_lib_features_editor_actions_EditorActions__WEBPACK_IMPORTED_MODULE_1__.default.prototype._registerDefaultActions.call(this, injector);

  // (1) retrieve optional components to integrate with

  var canvas = injector.get('canvas', false);
  var elementRegistry = injector.get('elementRegistry', false);
  var selection = injector.get('selection', false);
  var spaceTool = injector.get('spaceTool', false);
  var lassoTool = injector.get('lassoTool', false);
  var handTool = injector.get('handTool', false);
  var distributeElements = injector.get('distributeElements', false);
  var alignElements = injector.get('alignElements', false);
  var directEditing = injector.get('directEditing', false);
  var searchPad = injector.get('searchPad', false);
  var modeling = injector.get('modeling', false);

  // (2) check components and register actions

  if (canvas && elementRegistry && selection) {
    this._registerAction('selectElements', function() {

      // select all elements except for the invisible
      // root element
      var rootElement = canvas.getRootElement();

      var elements = elementRegistry.filter(function(element) {
        return element !== rootElement;
      });

      selection.select(elements);

      return elements;
    });
  }

  if (spaceTool) {
    this._registerAction('spaceTool', function() {
      spaceTool.toggle();
    });
  }

  if (lassoTool) {
    this._registerAction('lassoTool', function() {
      lassoTool.toggle();
    });
  }

  if (handTool) {
    this._registerAction('handTool', function() {
      handTool.toggle();
    });
  }

  if (selection && distributeElements) {
    this._registerAction('distributeElements', function(opts) {
      var currentSelection = selection.get(),
          type = opts.type;

      if (currentSelection.length) {
        distributeElements.trigger(currentSelection, type);
      }
    });
  }

  if (selection && alignElements) {
    this._registerAction('alignElements', function(opts) {
      var currentSelection = selection.get(),
          type = opts.type;

      if (currentSelection.length) {
        alignElements.trigger(currentSelection, type);
      }
    });
  }

  if (selection && modeling) {
    this._registerAction('setColor', function(opts) {
      var currentSelection = selection.get();

      if (currentSelection.length) {
        modeling.setColor(currentSelection, opts);
      }
    });
  }

  if (selection && directEditing) {
    this._registerAction('directEditing', function() {
      var currentSelection = selection.get();

      if (currentSelection.length) {
        directEditing.activate(currentSelection[0]);
      }
    });
  }

  if (searchPad) {
    this._registerAction('find', function() {
      searchPad.toggle();
    });
  }

  if (canvas && modeling) {
    this._registerAction('moveToOrigin', function() {
      var rootElement = canvas.getRootElement(),
          boundingBox;


      var elements = elementRegistry.filter(function(element) {
        return element !== rootElement;
      });

      boundingBox = (0,diagram_js_lib_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getBBox)(elements);

      modeling.moveElements(
        elements,
        { x: -boundingBox.x, y: -boundingBox.y },
        rootElement
      );
    });
  }

};

/***/ }),

/***/ "./lib/features/editor-actions/index.js":
/*!**********************************************!*\
  !*** ./lib/features/editor-actions/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_editor_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/editor-actions */ "./node_modules/diagram-js/lib/features/editor-actions/index.js");
/* harmony import */ var _PostitEditorActions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitEditorActions */ "./lib/features/editor-actions/PostitEditorActions.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_editor_actions__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  editorActions: [ 'type', _PostitEditorActions__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./lib/features/image-selection/ImageSelection.js":
/*!********************************************************!*\
  !*** ./lib/features/image-selection/ImageSelection.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageSelection)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_FileUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/FileUtil.js */ "./lib/util/FileUtil.js");
/* harmony import */ var _util_ScreenUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ScreenUtil.js */ "./lib/util/ScreenUtil.js");






var LOW_PRIORITY = 500;
var text;

function ImageSelection(canvas, eventBus, modeling, translate) {

  this._canvas = canvas;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._translate = translate;

  var self = this;

  eventBus.on('create.end', LOW_PRIORITY, function(event) {
    var context = event.context,
        element = context.shape,
        hints = context.hints;

    if (hints.selectImage) {
      self.select(element);
    }
  });

  text = { 'URL': this._translate('URL'),
    'An error occured during the file upload': this._translate('An error occured during the file upload'),
    'Upload files here': this._translate('Upload files here'),
    'Upload': this._translate('Upload'),
    'file': this._translate('file'),
    'files': this._translate('files'),
    'selected': this._translate('selected'),
    'Upload again': this._translate('Upload again'),
  };

  ImageSelection.IMAGE_SELECTION_MARKUP = '<div id="pjs-image-selection-modal" class="pjs-io-dialog-local">'+
    '<div class="pjs-io-dialog-section pjs-first">'+
      '<div id="pjs-image-selection-input-wrapper"><input id="pjs-image-selection-input" class="pjs-ui-element-bordered"></input></div>'+
      '<div class="pjs-labeled-input">'+
      '<label for="pjs-image-selection-input" class="pjs-input-text-static"><!--Search / -->'+text['URL']+':</label>'+
      '</div>'+
    '</div">'+
    '<div class="pjs-io-dialog-section">'+
    '<div class="pjs-section-spacer"></div>'+
    '<label for="pjs-image-upload"><div class="pjs-io-dialog-text-hint">'+
      '<a style="display:block"><ul id="pjs-image-dialog-text-hint-list" class="pjs-horizontal">'+
        '<li><div class="pjs-general-icon pjs-image-dialog-upload-icon"></div></li>'+
        '<li id="pjs-image-selection-files-text-error">'+text['An error occured during the file upload']+'</li>'+
        '<li id="pjs-image-selection-files-text-upload">'+text['Upload files here']+'</li>'+
      '</ul></a>'+
    '</div></label>'+
    '<input type="file" id="pjs-image-upload" style="display:none" multiple/>'+
    '<div class="pjs-io-dialog-section">'+
    '<div class="pjs-buttons pjs-image-selection-submit-wrapper"><button id="pjs-image-selection-submit">'+text['Upload']+'</button></div>'+
    '</div>'+
    '</div>'+
  '</div>';

}

ImageSelection.prototype._getParentContainer = function() {
  return this._canvas.getContainer();
};

ImageSelection.prototype.select = function(element, callback) {

  const self = this;

  const container = this._container = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(ImageSelection.IMAGE_SELECTION_MARKUP);

  const canvas = this._canvas._container.parentElement.parentElement;
  canvas.insertBefore(container, canvas.firstChild);

  const mousePosition = (0,_util_ScreenUtil_js__WEBPACK_IMPORTED_MODULE_1__.getMousePosition)(null);
  container.style.left = ( mousePosition.pageX - getOffsetLeft(container) ) + 'px';
  container.style.top = ( mousePosition.pageY - getOffsetTop(container) ) + 'px';

  const inputField = document.getElementById('pjs-image-selection-input'),
        submitButton = document.getElementById('pjs-image-selection-submit'),
        imageUploadTextError = document.getElementById('pjs-image-selection-files-text-error'),
        imageUploadTextUpload = document.getElementById('pjs-image-selection-files-text-upload'),
        imageUploadTextList = document.getElementById('pjs-image-dialog-text-hint-list'),
        imageUploadReader = document.getElementById('pjs-image-upload'),
        modal = document.getElementById('pjs-image-selection-modal');

  var uploadTextListHeight = imageUploadTextList.style.height;

  var source, filesToUpload;

  // focus url input field on modal open
  inputField.focus();

  // remove modal by clicking anywhere else
  const canvasDefaultClick = min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvas, 'click', function(ev) {
    if (modal) {

      // If we clicked one of our update buttons, don't close the dialog.
      var isBtn = false;
      document.querySelectorAll('.djs-context-pad .entry').forEach( function(btn) {
        if (btn == event.target ) {
          isBtn = true;
        }
      });

      const mousePos = (0,_util_ScreenUtil_js__WEBPACK_IMPORTED_MODULE_1__.getMousePosition)(ev);

      // The dialog is displaced by a box the size of font-size on each edge.
      var fontSize = document.defaultView.getComputedStyle(modal)['font-size'];
      fontSize = parseInt(fontSize.substring(0, fontSize.indexOf('px')));
      if (!isBtn && (
          (mousePos.pageX > modal.offsetLeft+getOffsetLeft(canvas)+modal.clientWidth
          || mousePos.pageX < modal.offsetLeft+getOffsetLeft(canvas) - fontSize)
          || (mousePos.pageY > modal.offsetTop+getOffsetTop(canvas)+modal.clientHeight
          || mousePos.pageY < modal.offsetTop+getOffsetTop(canvas) - fontSize) )) {
        removeImageSelectionModal();
      }
    }
  });


  for (var i=0; i < imageUploadReader.labels.length; i++) {
    // open file dialog
    min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(imageUploadReader.labels[i], 'click', function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      
      imageUploadReader.dispatchEvent(new MouseEvent(ev.type, ev));
    });
  }

  // after we open file dialog
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(imageUploadReader, 'change', async function() {
    inputField.disabled = 'true';

    let uploadDisplayText;

    let uploadResultObj = await (0,_util_FileUtil_js__WEBPACK_IMPORTED_MODULE_2__.fileReader)(null, imageUploadReader.files),
        uploadResult = uploadResultObj.uploadResult,
        errors = uploadResultObj.errors;

    if (!errors) {
      let uploadedFilesCount = (uploadResult.length) ? uploadResult.length : 0;
      uploadDisplayText = uploadedFilesCount;

      if (isNaN(uploadedFilesCount) === false) {

        const filePluralText =+ (uploadResult.length == 1) ? text['file'] : text['files'];
        uploadDisplayText += ' ' + filePluralText + ' ' + text['selected'];

        // uploaded files are saved in global var
        filesToUpload = uploadResult;
      }

      displayUploadStaging(uploadDisplayText);
    } else {
      displayError();
    }
  });

  // upload button
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(submitButton, 'click', async function() {
    source = filesToUpload;

    // (1) call from canvas, providing a target element
    if (element !== null) {

      // (1.1) local file selection upload
      if (source) {
        for (const f in filesToUpload) {
          uploadImage(self, filesToUpload[f]);
        }

      // (1.2) url upload
      } else {
        source = inputField.value;
        uploadImage(self, source);
      }

      self._eventBus.fire('imageSelection.complete', { element: element });

    // (2) external call w/o canvas target
    } else {

      // (2.1 default) local file selection data is used

      // (2.2) url upload
      if (!source) {
        source = inputField.value;
      }

      callback(source);
    }

    // error handling not necessary as default img will be shown in error situation
    removeImageSelectionModal();
  });

  // enter pressed
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(inputField, 'keyup', function(esvent) {
    if (event.keyCode === 13) {
      event.preventDefault();
      submitButton.click();
    }
  });

  function getOffsetLeft(elem) {
    var offsetLeft = 0;
    do {
      if ( !isNaN( elem.offsetLeft ) )
      {
          offsetLeft += elem.offsetLeft;
      }
    } while( elem = elem.offsetParent );
    return offsetLeft;
  }

  function getOffsetTop(elem) {
    var offsetTop = 0;
    do {
      if ( !isNaN( elem.offsetTop ) )
      {
          offsetTop += elem.offsetTop;
      }
    } while( elem = elem.offsetParent );
    return offsetTop;
  }

  function displayUploadStaging(text) {
    imageUploadTextList.style.height = uploadTextListHeight;
    imageUploadTextError.style.display = 'none';
    imageUploadTextUpload.innerHTML = text;

    if (document.getElementsByClassName('pjs-image-dialog-upload-icon').length > 0) {
      document.getElementsByClassName('pjs-image-dialog-upload-icon')[0].classList.remove('pjs-image-dialog-upload-icon-error');
    }
  }

  function displayError() {
    uploadTextListHeight = imageUploadTextList.style.height;

    imageUploadTextList.style.height = 'auto';
    imageUploadTextError.style.display = 'block';
    imageUploadTextUpload.innerHTML = text['Upload again'];

    document.getElementsByClassName('pjs-image-dialog-upload-icon')[0].classList.add('pjs-image-dialog-upload-icon-error');
  }

  async function uploadImage(self, source) {
    var urlParams = new URLSearchParams(window.location.search);
    var s_key = urlParams.get('s_key');
    if( s_key === null ) {
      shepherdAlert("Script Required", "You must open a script before you can take notes!")
    } else {
      let image, blob;
      if( source.substring(0,4) !== "data" ) {
        blob = await fetch('https://cors-anywhere-dot-indieskedge-production.wl.r.appspot.com/' + source).then( r => r.blob() );
        blob.name = "Remote File";
      } else {
        blob = imageUploadReader.files[0];
      }

      // Ugly because we expect this URL to exist on the page.
      var upload = new ActiveStorage.DirectUpload(
        blob,
        direct_upload_url
      );

      upload.create(function(error, blob) {
        if( error !== null ) {
          if( error.search("Status: 403") >= 0 ) {
            shepherdAlert("Subscription Needed!", "You must have an active subscription to save images! You can sign up <button data-toggle=\"modal\" href=\"#subscriptionModal\" onclick=\"Shepherd.activeTour.complete(); $('#ideatorNotesModal').modal('hide');\" data-description=\"Sign up for image uploading and other great featuers!\" data-reset=\"$('#ideatorNotesModal').modal(\'show\');\" style=\"color: blue; margin-left: -6px; text-decoration: underline;\">here!</button>");
          } else {
            shepherdAlert("Upload Error", error);
          }
        } else if( blob.key ) {
          $.ajax({
            type: "GET",
            beforeSend: function(xhr) {
                          xhr.setRequestHeader('X-CSRF-Token',
                              $('meta[name="csrf-token"]').attr('content'));
                        },
            url: "/scripts/" + s_key + "/image_url/" + blob.key,
            responseType: 'application/json',
            dataType: 'json',
            success: function(data) {
              self._modeling.updateProperties(element, {
                source: data.url,
                key: data.key
              });
            }
          });
        } else {
          shepherdAlert("Unknown Error", "We've logged this issue.  If it continues, please reach out to support.");
          Bugsnag.notify("Unknown upload response: " + blob.toString() )
        }
      });
    }
  }

  function removeImageSelectionModal() {
    if (modal && modal.parentNode) {
      modal.parentNode.removeChild(modal);
      if (canvasDefaultClick) {
        canvas.removeEventListener('click', canvasDefaultClick);
      }
    }
  }

};

ImageSelection.prototype.$inject = [
  'canvas',
  'eventBus',
  'modelng',
  'translate'
];


/***/ }),

/***/ "./lib/features/image-selection/index.js":
/*!***********************************************!*\
  !*** ./lib/features/image-selection/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageSelection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageSelection */ "./lib/features/image-selection/ImageSelection.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'imageSelection' ],
  imageSelection: [ 'type', _ImageSelection__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./lib/features/keyboard/PostitKeyboardBindings.js":
/*!*********************************************************!*\
  !*** ./lib/features/keyboard/PostitKeyboardBindings.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitKeyboardBindings)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_features_keyboard_KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/keyboard/KeyboardBindings */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardBindings.js");





/**
 * Postit specific keyboard bindings.
 *
 * @param {Injector} injector
 */
function PostitKeyboardBindings(injector) {
  injector.invoke(diagram_js_lib_features_keyboard_KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__.default, this);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitKeyboardBindings, diagram_js_lib_features_keyboard_KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__.default);

PostitKeyboardBindings.$inject = [
  'injector'
];


/**
 * Register available keyboard bindings.
 *
 * @param {Keyboard} keyboard
 * @param {EditorActions} editorActions
 */
PostitKeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {

  // inherit default bindings
  diagram_js_lib_features_keyboard_KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__.default.prototype.registerBindings.call(this, keyboard, editorActions);

  /**
   * Add keyboard binding if respective editor action
   * is registered.
   *
   * @param {String} action name
   * @param {Function} fn that implements the key binding
   */
  function addListener(action, fn) {

    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  }

  // select all elements
  // CTRL + A
  addListener('selectElements', function(context) {

    var event = context.keyEvent;

    if (keyboard.isKey(['a', 'A'], event) && keyboard.isCmd(event)) {
      editorActions.trigger('selectElements');

      return true;
    }
  });

  // search labels
  // CTRL + F
  addListener('find', function(context) {

    var event = context.keyEvent;

    if (keyboard.isKey(['f', 'F'], event) && keyboard.isCmd(event)) {
      editorActions.trigger('find');

      return true;
    }
  });

  // activate space tool
  // S
  addListener('spaceTool', function(context) {

    var event = context.keyEvent;

    if (keyboard.hasModifier(event)) {
      return;
    }

    if (keyboard.isKey(['s', 'S'], event)) {
      editorActions.trigger('spaceTool');

      return true;
    }
  });

  // activate lasso tool
  // L
  addListener('lassoTool', function(context) {

    var event = context.keyEvent;

    if (keyboard.hasModifier(event)) {
      return;
    }

    if (keyboard.isKey(['l', 'L'], event)) {
      editorActions.trigger('lassoTool');

      return true;
    }
  });

  // activate hand tool
  // H
  addListener('handTool', function(context) {

    var event = context.keyEvent;

    if (keyboard.hasModifier(event)) {
      return;
    }

    if (keyboard.isKey(['h', 'H'], event)) {
      editorActions.trigger('handTool');

      return true;
    }
  });

  // activate direct editing
  // E
  addListener('directEditing', function(context) {

    var event = context.keyEvent;

    if (keyboard.hasModifier(event)) {
      return;
    }

    if (keyboard.isKey(['e', 'E'], event)) {
      editorActions.trigger('directEditing');

      return true;
    }
  });

};

/***/ }),

/***/ "./lib/features/keyboard/index.js":
/*!****************************************!*\
  !*** ./lib/features/keyboard/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/keyboard */ "./node_modules/diagram-js/lib/features/keyboard/index.js");
/* harmony import */ var _PostitKeyboardBindings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitKeyboardBindings */ "./lib/features/keyboard/PostitKeyboardBindings.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_keyboard__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'keyboardBindings' ],
  keyboardBindings: [ 'type', _PostitKeyboardBindings__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./lib/features/label-editing/LabelEditingPreview.js":
/*!***********************************************************!*\
  !*** ./lib/features/label-editing/LabelEditingPreview.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LabelEditingPreview)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");




var MARKER_HIDDEN = 'djs-element-hidden',
    MARKER_LABEL_HIDDEN = 'djs-label-hidden';


function LabelEditingPreview(
    eventBus, canvas, elementRegistry,
    pathMap) {


  var element, gfx;

  eventBus.on('directEditing.activate', function(context) {
    var activeProvider = context.active;

    element = activeProvider.element.label || activeProvider.element;


    if (element.labelTarget) {
      canvas.addMarker(element, MARKER_HIDDEN);
    } else if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.is)(element, 'postit:Postit')) {
      canvas.addMarker(element, MARKER_LABEL_HIDDEN);
    }
  });


  eventBus.on([ 'directEditing.complete', 'directEditing.cancel' ], function(context) {
    var activeProvider = context.active;

    if (activeProvider) {
      canvas.removeMarker(activeProvider.element.label || activeProvider.element, MARKER_HIDDEN);
      canvas.removeMarker(element, MARKER_LABEL_HIDDEN);
    }

    element = undefined;

    if (gfx) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(gfx);

      gfx = undefined;
    }
  });
}

LabelEditingPreview.$inject = [
  'eventBus',
  'canvas',
  'elementRegistry',
  'pathMap'
];

/***/ }),

/***/ "./lib/features/label-editing/LabelEditingProvider.js":
/*!************************************************************!*\
  !*** ./lib/features/label-editing/LabelEditingProvider.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LabelEditingProvider)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _LabelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LabelUtil */ "./lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modeling/util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/LabelUtil */ "./lib/util/LabelUtil.js");









function LabelEditingProvider(
    eventBus, postitFactory, canvas, directEditing,
    modeling, resizeHandles, textRenderer) {

  this._postitFactory = postitFactory;
  this._canvas = canvas;
  this._modeling = modeling;
  this._textRenderer = textRenderer;

  directEditing.registerProvider(this);

  // listen to dblclick on non-root elements
  eventBus.on('element.dblclick', function(event) {
    activateDirectEdit(event.element, true);
  });

  // complete on followup canvas operation
  eventBus.on([
    'autoPlace.start',
    'canvas.viewbox.changing',
    'drag.init',
    'element.mousedown',
    'popupMenu.open'
  ], function(event) {

    if (directEditing.isActive()) {
      directEditing.complete();
    }
  });

  // cancel on command stack changes
  eventBus.on([ 'commandStack.changed' ], function(e) {
    if (directEditing.isActive()) {
      directEditing.cancel();
    }
  });


  eventBus.on('directEditing.activate', function(event) {
    resizeHandles.removeResizers();
  });

  eventBus.on('create.end', 500, function(event) {

    var context = event.context,
        element = context.shape,
        canExecute = event.context.canExecute,
        isTouch = event.isTouch;

    // TODO(nikku): we need to find a way to support the
    // direct editing on mobile devices; right now this will
    // break for desworkflowediting on mobile devices
    // as it breaks the user interaction workflow

    // TODO(nre): we should temporarily focus the edited element
    // here and release the focused viewport after the direct edit
    // operation is finished
    if (isTouch) {
      return;
    }

    if (!canExecute) {
      return;
    }

    if (context.hints && context.hints.createElementsBehavior === false) {
      return;
    }

    activateDirectEdit(element);
  });

  eventBus.on('autoPlace.end', 500, function(event) {
    activateDirectEdit(event.shape);
  });


  function activateDirectEdit(element, force) {
    if (force ||
        (0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(element, [ 'postit:Postit', 'postit:Group', 'postit:TextBox' ])) {

      directEditing.activate(element);
    }
  }

}

LabelEditingProvider.$inject = [
  'eventBus',
  'postitFactory',
  'canvas',
  'directEditing',
  'modeling',
  'resizeHandles',
  'textRenderer'
];


/**
 * Activate direct editing for activities and text annotations.
 *
 * @param  {djs.model.Base} element
 *
 * @return {Object} an object with properties bounds (position and size), text and options
 */
LabelEditingProvider.prototype.activate = function(element) {

  // text
  var text = (0,_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.getLabel)(element);

  if (text === undefined) {
    return;
  }

  var context = {
    text: text
  };

  // bounds
  var bounds = this.getEditingBBox(element);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(context, bounds);

  var options = {};

  // postits and text boxes
  if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(element, ['postit:Postit', 'postit:TextBox'])) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(options, {
      centerVertically: true
    });
  }

  // external labels
  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.isLabelExternal)(element)) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(options, {
      autoResize: true
    });
  }


  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(context, {
    options: options
  });

  return context;
};


/**
 * Get the editing bounding box based on the element's size and position
 *
 * @param  {djs.model.Base} element
 *
 * @return {Object} an object containing information about position
 *                  and size (fixed or minimum and/or maximum)
 */
LabelEditingProvider.prototype.getEditingBBox = function(element) {
  var canvas = this._canvas;

  var target = element.label || element;

  var bbox = canvas.getAbsoluteBBox(target);

  var mid = {
    x: bbox.x + bbox.width / 2,
    y: bbox.y + bbox.height / 2
  };

  // default position
  var bounds = { x: bbox.x, y: bbox.y };

  var zoom = canvas.zoom();

  var defaultStyle = this._textRenderer.getDefaultStyle(),
      externalStyle = this._textRenderer.getExternalStyle();

  // take zoom into account
  var externalFontSize = externalStyle.fontSize * zoom,
      externalLineHeight = externalStyle.lineHeight,
      defaultFontSize = defaultStyle.fontSize * zoom,
      defaultLineHeight = defaultStyle.lineHeight;

  var style = {
    fontFamily: this._textRenderer.getDefaultStyle().fontFamily,
    fontWeight: this._textRenderer.getDefaultStyle().fontWeight
  };


  if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(element, [ 'postit:Postit', 'postit:TextBox', 'postit:Group'])) {

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(bounds, {
      width: bbox.width,
      height: bbox.height
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(style, {
      fontSize: defaultFontSize + 'px',
      lineHeight: defaultLineHeight,
      paddingTop: (7 * zoom) + 'px',
      paddingBottom: (7 * zoom) + 'px',
      paddingLeft: (5 * zoom) + 'px',
      paddingRight: (5 * zoom) + 'px'
    });
  }

  var width = 90 * zoom,
      paddingTop = 7 * zoom,
      paddingBottom = 4 * zoom;

  // external labels for events, data elements, gateways, groups and connections
  if (target.labelTarget) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(bounds, {
      width: width,
      height: bbox.height + paddingTop + paddingBottom,
      x: mid.x - width / 2,
      y: bbox.y - paddingTop
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(style, {
      fontSize: externalFontSize + 'px',
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + 'px',
      paddingBottom: paddingBottom + 'px'
    });
  }

  // external label not yet created
  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.isLabelExternal)(target)
      && !(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.hasExternalLabel)(target)
      && !(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.isLabel)(target)) {

    var externalLabelMid = (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.getExternalLabelMid)(element);

    var absoluteBBox = canvas.getAbsoluteBBox({
      x: externalLabelMid.x,
      y: externalLabelMid.y,
      width: 0,
      height: 0
    });

    var height = externalFontSize + paddingTop + paddingBottom;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(bounds, {
      width: width,
      height: height,
      x: absoluteBBox.x - width / 2,
      y: absoluteBBox.y - height / 2
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(style, {
      fontSize: externalFontSize + 'px',
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + 'px',
      paddingBottom: paddingBottom + 'px'
    });
  }


  // transparent edit box
  if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(element, [ 'postit:Postit' ])) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(style, {
      backgroundColor: 'transparent'
    });
  }

  return { bounds: bounds, style: style };
};


LabelEditingProvider.prototype.update = function(element, newLabel) {

  if (isEmptyText(newLabel)) {
    newLabel = null;
  }

  this._modeling.updateLabel(element, newLabel);
};



// helpers //////////////////////

function isEmptyText(label) {
  return !label || !label.trim();
}

/***/ }),

/***/ "./lib/features/label-editing/LabelUtil.js":
/*!*************************************************!*\
  !*** ./lib/features/label-editing/LabelUtil.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLabel": () => (/* binding */ getLabel),
/* harmony export */   "setLabel": () => (/* binding */ setLabel)
/* harmony export */ });
/* harmony import */ var _modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modeling/util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");


function getLabelAttr(semantic) {
  if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(semantic, [ 'postit:Postit', 'postit:TextBox', 'postit:Group' ])) {
    return 'name';
  }
}

function getLabel(element) {
  var semantic = element.businessObject,
      attr = getLabelAttr(semantic);

  if (attr) {
    return semantic[attr] || '';
  }
}


function setLabel(element, text) {
  var semantic = element.businessObject,
      attr = getLabelAttr(semantic);

  if (attr) {
    semantic[attr] = text;
  }

  return element;
}

/***/ }),

/***/ "./lib/features/label-editing/cmd/UpdateLabelHandler.js":
/*!**************************************************************!*\
  !*** ./lib/features/label-editing/cmd/UpdateLabelHandler.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpdateLabelHandler)
/* harmony export */ });
/* harmony import */ var _LabelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LabelUtil */ "./lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/LabelUtil */ "./lib/util/LabelUtil.js");




var NULL_DIMENSIONS = {
  width: 0,
  height: 0
};


/**
 * A handler that updates the text of a postit element.
 */
function UpdateLabelHandler(modeling, textRenderer) {

  /**
   * Set the label and return the changed elements.
   *
   * Element parameter can be label itself or connection (i.e. sequence flow).
   *
   * @param {djs.model.Base} element
   * @param {String} text
   */
  function setText(element, text) {

    // external label if present
    var label = element.label || element;

    var labelTarget = element.labelTarget || element;

    (0,_LabelUtil__WEBPACK_IMPORTED_MODULE_0__.setLabel)(label, text, labelTarget !== label);

    return [ label, labelTarget ];
  }

  function preExecute(ctx) {
    var element = ctx.element,
        businessObject = element.businessObject,
        newLabel = ctx.newLabel;

    if (!(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.isLabel)(element)
        && (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.isLabelExternal)(element)
        && !(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.hasExternalLabel)(element)
        && !isEmptyText(newLabel)) {

      // create label
      var paddingTop = 7;

      var labelCenter = (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.getExternalLabelMid)(element);

      labelCenter = {
        x: labelCenter.x,
        y: labelCenter.y + paddingTop
      };

      modeling.createLabel(element, labelCenter, {
        id: businessObject.id + '_label',
        businessObject: businessObject
      });
    }
  }

  function execute(ctx) {
    ctx.oldLabel = (0,_LabelUtil__WEBPACK_IMPORTED_MODULE_0__.getLabel)(ctx.element);
    return setText(ctx.element, ctx.newLabel);
  }

  function revert(ctx) {
    return setText(ctx.element, ctx.oldLabel);
  }

  function postExecute(ctx) {
    var element = ctx.element,
        label = element.label || element,
        newLabel = ctx.newLabel,
        newBounds = ctx.newBounds,
        hints = ctx.hints || {};

    // ignore internal labels for elements
    if (!(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.isLabel)(label)) {
      return;
    }

    if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.isLabel)(label) && isEmptyText(newLabel)) {

      if (hints.removeShape !== false) {
        modeling.removeShape(label, { unsetLabel: false });
      }

      return;
    }

    var text = (0,_LabelUtil__WEBPACK_IMPORTED_MODULE_0__.getLabel)(label);

    // resize element based on label _or_ pre-defined bounds
    if (typeof newBounds === 'undefined') {
      newBounds = textRenderer.getExternalLabelBounds(label, text);
    }

    // setting newBounds to false or _null_ will
    // disable the postExecute resize operation
    if (newBounds) {
      modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);
    }
  }

  // API

  this.preExecute = preExecute;
  this.execute = execute;
  this.revert = revert;
  this.postExecute = postExecute;
}

UpdateLabelHandler.$inject = [
  'modeling',
  'textRenderer'
];


// helpers ///////////////////////

function isEmptyText(label) {
  return !label || !label.trim();
}

/***/ }),

/***/ "./lib/features/label-editing/index.js":
/*!*********************************************!*\
  !*** ./lib/features/label-editing/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_change_support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/change-support */ "./node_modules/diagram-js/lib/features/change-support/index.js");
/* harmony import */ var diagram_js_lib_features_resize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/features/resize */ "./node_modules/diagram-js/lib/features/resize/index.js");
/* harmony import */ var diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js-direct-editing */ "./node_modules/diagram-js-direct-editing/index.js");
/* harmony import */ var _LabelEditingProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LabelEditingProvider */ "./lib/features/label-editing/LabelEditingProvider.js");
/* harmony import */ var _LabelEditingPreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LabelEditingPreview */ "./lib/features/label-editing/LabelEditingPreview.js");








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_change_support__WEBPACK_IMPORTED_MODULE_1__.default,
    diagram_js_lib_features_resize__WEBPACK_IMPORTED_MODULE_2__.default,
    diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [
    'labelEditingProvider',
    'labelEditingPreview'
  ],
  labelEditingProvider: [ 'type', _LabelEditingProvider__WEBPACK_IMPORTED_MODULE_3__.default ],
  labelEditingPreview: [ 'type', _LabelEditingPreview__WEBPACK_IMPORTED_MODULE_4__.default ]
});


/***/ }),

/***/ "./lib/features/modeling/ElementFactory.js":
/*!*************************************************!*\
  !*** ./lib/features/modeling/ElementFactory.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementFactory)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var diagram_js_lib_core_ElementFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/core/ElementFactory */ "./node_modules/diagram-js/lib/core/ElementFactory.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/LabelUtil */ "./lib/util/LabelUtil.js");











/**
 * A postit-aware factory for diagram-js shapes
 */
function ElementFactory(postitFactory, moddle, translate) {
  diagram_js_lib_core_ElementFactory__WEBPACK_IMPORTED_MODULE_1__.default.call(this);

  this._postitFactory = postitFactory;
  this._moddle = moddle;
  this._translate = translate;
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(ElementFactory, diagram_js_lib_core_ElementFactory__WEBPACK_IMPORTED_MODULE_1__.default);

ElementFactory.$inject = [
  'postitFactory',
  'moddle',
  'translate'
];

ElementFactory.prototype.baseCreate = diagram_js_lib_core_ElementFactory__WEBPACK_IMPORTED_MODULE_1__.default.prototype.create;

ElementFactory.prototype.create = function(elementType, attrs) {

  // no special magic for labels,
  // we assume their businessObjects have already been created
  // and wired via attrs
  if (elementType === 'label') {
    return this.baseCreate(elementType, (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ type: 'label' }, _util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_LABEL_SIZE, attrs));
  }

  return this.createPostitElement(elementType, attrs);
};

ElementFactory.prototype.createPostitElement = function(elementType, attrs) {
  var size,
      translate = this._translate;

  attrs = attrs || {};

  var businessObject = attrs.businessObject;

  if (!businessObject) {
    if (!attrs.type) {
      throw new Error(translate('no shape type specified'));
    }

    businessObject = this._postitFactory.create(attrs.type);
  }

  if (!businessObject.di) {
    if (elementType === 'root') {
      businessObject.di = this._postitFactory.createDiPlane(businessObject, [], {
        id: businessObject.id + '_di'
      });
    } else {
      businessObject.di = this._postitFactory.createDiShape(businessObject, {}, {
        id: businessObject.id + '_di'
      });
    }
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.is)(businessObject, 'postit:Group')) {
    attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
      isFrame: true
    }, attrs);
  }

  if (attrs.di) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(businessObject.di, attrs.di);

    delete attrs.di;
  }

  applyAttributes(businessObject, attrs, [
    'processRef',
    'isInterrupting',
    'associationDirection',
    'isForCompensation'
  ]);

  size = this._getDefaultSize(businessObject);

  attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
    businessObject: businessObject,
    id: businessObject.id
  }, size, attrs);

  return this.baseCreate(elementType, attrs);
};


ElementFactory.prototype._getDefaultSize = function(semantic) {
  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.is)(semantic, 'postit:Postit')) {
    return { width: 150, height: 150 };
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.is)(semantic, 'postit:Group')) {
    return { width: 300, height: 300 };
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.is)(semantic, 'postit:Image')) {
    return { width: 300, height: 300 };
  }

  return { width: 100, height: 80 };
};



// helpers //////////////////////

/**
 * Apply attributes from a map to the given element,
 * remove attribute from the map on application.
 *
 * @param {Base} element
 * @param {Object} attrs (in/out map of attributes)
 * @param {Array<String>} attributeNames name of attributes to apply
 */
function applyAttributes(element, attrs, attributeNames) {

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attributeNames, function(property) {
    if (attrs[property] !== undefined) {
      applyAttribute(element, attrs, property);
    }
  });
}

/**
 * Apply named property to element and drain it from the attrs
 * collection.
 *
 * @param {Base} element
 * @param {Object} attrs (in/out map of attributes)
 * @param {String} attributeName to apply
 */
function applyAttribute(element, attrs, attributeName) {
  element[attributeName] = attrs[attributeName];

  delete attrs[attributeName];
}

/***/ }),

/***/ "./lib/features/modeling/Modeling.js":
/*!*******************************************!*\
  !*** ./lib/features/modeling/Modeling.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Modeling)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_features_modeling_Modeling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/modeling/Modeling */ "./node_modules/diagram-js/lib/features/modeling/Modeling.js");
/* harmony import */ var _cmd_UpdatePropertiesHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cmd/UpdatePropertiesHandler */ "./lib/features/modeling/cmd/UpdatePropertiesHandler.js");
/* harmony import */ var _cmd_UpdateCanvasRootHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cmd/UpdateCanvasRootHandler */ "./lib/features/modeling/cmd/UpdateCanvasRootHandler.js");
/* harmony import */ var _cmd_IdClaimHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cmd/IdClaimHandler */ "./lib/features/modeling/cmd/IdClaimHandler.js");
/* harmony import */ var _cmd_SetColorHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cmd/SetColorHandler */ "./lib/features/modeling/cmd/SetColorHandler.js");
/* harmony import */ var _label_editing_cmd_UpdateLabelHandler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../label-editing/cmd/UpdateLabelHandler */ "./lib/features/label-editing/cmd/UpdateLabelHandler.js");












/**
 * Postit modeling features activator
 *
 * @param {EventBus} eventBus
 * @param {ElementFactory} elementFactory
 * @param {CommandStack} commandStack
 * @param {PostitRules} postitRules
 */
function Modeling(
    eventBus, elementFactory, commandStack,
    postitRules) {

  diagram_js_lib_features_modeling_Modeling__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus, elementFactory, commandStack);

  this._postitRules = postitRules;
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Modeling, diagram_js_lib_features_modeling_Modeling__WEBPACK_IMPORTED_MODULE_1__.default);

Modeling.$inject = [
  'eventBus',
  'elementFactory',
  'commandStack',
  'postitRules'
];


Modeling.prototype.getHandlers = function() {
  var handlers = diagram_js_lib_features_modeling_Modeling__WEBPACK_IMPORTED_MODULE_1__.default.prototype.getHandlers.call(this);

  handlers['element.updateProperties'] = _cmd_UpdatePropertiesHandler__WEBPACK_IMPORTED_MODULE_2__.default;
  handlers['canvas.updateRoot'] = _cmd_UpdateCanvasRootHandler__WEBPACK_IMPORTED_MODULE_3__.default;
  handlers['id.updateClaim'] = _cmd_IdClaimHandler__WEBPACK_IMPORTED_MODULE_4__.default;
  handlers['element.setColor'] = _cmd_SetColorHandler__WEBPACK_IMPORTED_MODULE_5__.default;
  handlers['element.updateLabel'] = _label_editing_cmd_UpdateLabelHandler__WEBPACK_IMPORTED_MODULE_6__.default;

  return handlers;
};


Modeling.prototype.updateLabel = function(element, newLabel, newBounds, hints) {
  this._commandStack.execute('element.updateLabel', {
    element: element,
    newLabel: newLabel,
    newBounds: newBounds,
    hints: hints || {}
  });
};


Modeling.prototype.updateProperties = function(element, properties) {
  this._commandStack.execute('element.updateProperties', {
    element: element,
    properties: properties
  });
};

Modeling.prototype.claimId = function(id, moddleElement) {
  this._commandStack.execute('id.updateClaim', {
    id: id,
    element: moddleElement,
    claiming: true
  });
};


Modeling.prototype.unclaimId = function(id, moddleElement) {
  this._commandStack.execute('id.updateClaim', {
    id: id,
    element: moddleElement
  });
};

Modeling.prototype.setColor = function(elements, color) {
  if (!elements.length) {
    elements = [ elements ];
  }

  this._commandStack.execute('element.setColor', {
    elements: elements,
    color: color
  });
};


/***/ }),

/***/ "./lib/features/modeling/PostitFactory.js":
/*!************************************************!*\
  !*** ./lib/features/modeling/PostitFactory.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PositFactory)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");







function PositFactory(moddle) {
  this._model = moddle;
}

PositFactory.$inject = [ 'moddle' ];


PositFactory.prototype._needsId = function(element) {
  return (0,_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(element, [
    'postit:BoardElement'
  ]);
};

PositFactory.prototype._ensureId = function(element) {

  // generate semantic ids for elements
  // postit:Postit -> Positit_ID
  var prefix;

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__.is)(element, 'postit:Postit')) {
    prefix = 'Postit';
  } else {
    prefix = (element.$type || '').replace(/^[^:]*:/g, '');
  }

  prefix += '_';

  if (!element.id && this._needsId(element)) {
    element.id = this._model.ids.nextPrefixed(prefix, element);
  }
};


PositFactory.prototype.create = function(type, attrs) {
  var element = this._model.create(type, attrs || {});

  this._ensureId(element);

  return element;
};


PositFactory.prototype.createDiLabel = function() {
  return this.create('postitDi:PostitLabel', {
    bounds: this.createDiBounds()
  });
};


PositFactory.prototype.createDiShape = function(semantic, bounds, attrs) {

  return this.create('postitDi:PostitShape', (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
    boardElement: semantic,
    bounds: this.createDiBounds(bounds)
  }, attrs));
};


PositFactory.prototype.createDiBounds = function(bounds) {
  return this.create('dc:Bounds', bounds);
};


PositFactory.prototype.createDiPlane = function(semantic) {
  return this.create('postitDi:PostitPlane', {
    boardElement: semantic
  });
};

/***/ }),

/***/ "./lib/features/modeling/PostitUpdater.js":
/*!************************************************!*\
  !*** ./lib/features/modeling/PostitUpdater.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitUpdater)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! diagram-js/lib/util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");
/* harmony import */ var diagram_js_lib_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/model */ "./node_modules/diagram-js/lib/model/index.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");












/**
 * A handler responsible for updating the underlying Postit XML + DI
 * once changes on the diagram happen
 */
function PostitUpdater(
    eventBus, postitFactory, connectionDocking,
    translate) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  this._postitFactory = postitFactory;
  this._translate = translate;

  var self = this;


  // Postit + DI update //////////////////////


  // update parent
  function updateParent(e) {
    var context = e.context;

    self.updateParent(context.shape || context.connection, context.oldParent);
  }

  function reverseUpdateParent(e) {
    var context = e.context;

    var element = context.shape || context.connection,

        // oldParent is the (old) new parent, because we are undoing
        oldParent = context.parent || context.newParent;

    self.updateParent(element, oldParent);
  }

  this.executed([
    'shape.move',
    'shape.create',
    'shape.delete'
  ], ifPostit(updateParent));

  this.reverted([
    'shape.move',
    'shape.create',
    'shape.delete'
  ], ifPostit(reverseUpdateParent));

  /*
   * ## Updating Parent
   *
   * When morphing a root element
   * make sure that both the *semantic* and *di* parent of each element
   * is updated.
   *
   */
  function updateRoot(event) {
    var context = event.context,
        oldRoot = context.oldRoot,
        children = oldRoot.children;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(children, function(child) {
      if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(child, 'postit:BoardElement')) {
        self.updateParent(child);
      }
    });
  }

  this.executed([ 'canvas.updateRoot' ], updateRoot);
  this.reverted([ 'canvas.updateRoot' ], updateRoot);


  // update bounds
  function updateBounds(e) {
    var shape = e.context.shape;

    if (!(0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(shape, 'postit:BoardElement')) {
      return;
    }

    self.updateBounds(shape);
  }

  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], ifPostit(function(event) {

    // exclude labels because they're handled separately during shape.changed
    if (event.context.shape.type === 'label') {
      return;
    }

    updateBounds(event);
  }));

  this.reverted([ 'shape.move', 'shape.create', 'shape.resize' ], ifPostit(function(event) {

    // exclude labels because they're handled separately during shape.changed
    if (event.context.shape.type === 'label') {
      return;
    }

    updateBounds(event);
  }));

  // Handle labels separately. This is necessary, because the label bounds have to be updated
  // every time its shape changes, not only on move, create and resize.
  eventBus.on('shape.changed', function(event) {
    if (event.element.type === 'label') {
      updateBounds({ context: { shape: event.element } });
    }
  });

}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitUpdater, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

PostitUpdater.$inject = [
  'eventBus',
  'postitFactory',
  'connectionDocking',
  'translate'
];


// implementation //////////////////////

PostitUpdater.prototype.updateAttachment = function(context) {

  var shape = context.shape,
      businessObject = shape.businessObject,
      host = shape.host;

  businessObject.attachedToRef = host && host.businessObject;
};

PostitUpdater.prototype.updateParent = function(element, oldParent) {

  // do not update label parent
  if (element instanceof diagram_js_lib_model__WEBPACK_IMPORTED_MODULE_4__.Label) {
    return;
  }

  var parentShape = element.parent;

  var businessObject = element.businessObject,
      parentBusinessObject = parentShape && parentShape.businessObject,
      parentDi = parentBusinessObject && parentBusinessObject.di;

  this.updateSemanticParent(businessObject, parentBusinessObject);

  this.updateDiParent(businessObject.di, parentDi);
};


PostitUpdater.prototype.updateBounds = function(shape) {

  var di = shape.businessObject.di;

  var target = (shape instanceof diagram_js_lib_model__WEBPACK_IMPORTED_MODULE_4__.Label) ? this._getLabel(di) : di;

  var bounds = target.bounds;

  if (!bounds) {
    bounds = this._postitFactory.createDiBounds();
    target.set('bounds', bounds);
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(bounds, {
    x: shape.x,
    y: shape.y,
    width: shape.width,
    height: shape.height
  });
};


PostitUpdater.prototype.updateDiParent = function(di, parentDi) {

  if (parentDi && !(0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(parentDi, 'postitDi:PostitPlane')) {
    parentDi = parentDi.$parent;
  }

  if (di.$parent === parentDi) {
    return;
  }

  var planeElements = (parentDi || di.$parent).get('planeElement');

  if (parentDi) {
    planeElements.push(di);
    di.$parent = parentDi;
  } else {
    (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_5__.remove)(planeElements, di);
    di.$parent = null;
  }
};


PostitUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {

  var containment,
      translate = this._translate;

  if (businessObject.$parent === newParent) {
    return;
  }


  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(businessObject, 'postit:BoardElement')) {
    containment = 'boardElements';
  }

  if (!containment) {
    throw new Error(translate(
      'no parent for {element} in {parent}',
      {
        element: businessObject.id,
        parent: newParent.id
      }
    ));
  }

  var children;

  if (businessObject.$parent) {

    // remove from old parent
    children = businessObject.$parent.get(containment);
    (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_5__.remove)(children, businessObject);
  }

  if (!newParent) {
    businessObject.$parent = null;
  } else {

    // add to new parent
    children = newParent.get(containment);
    children.push(businessObject);
    businessObject.$parent = newParent;
  }

  if (visualParent) {
    var diChildren = visualParent.get(containment);

    (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_5__.remove)(children, businessObject);

    if (newParent) {

      if (!diChildren) {
        diChildren = [];
        newParent.set(containment, diChildren);
      }

      diChildren.push(businessObject);
    }
  }
};


// helpers //////////////////////

PostitUpdater.prototype._getLabel = function(di) {
  if (!di.label) {
    di.label = this._postitFactory.createDiLabel();
  }

  return di.label;
};


/**
 * Make sure the event listener is only called
 * if the touched element is a postit element.
 *
 * @param  {Function} fn
 * @return {Function} guarded function
 */
function ifPostit(fn) {

  return function(event) {

    var context = event.context,
        element = context.shape || context.connection;

    if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(element, 'postit:BoardElement')) {
      fn(event);
    }
  };
}


/***/ }),

/***/ "./lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js":
/*!****************************************************************************!*\
  !*** ./lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AdaptiveLabelPositioningBehavior)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var diagram_js_lib_util_Math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/util/Math */ "./node_modules/diagram-js/lib/util/PositionUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/LabelUtil */ "./lib/util/LabelUtil.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");










var ALIGNMENTS = [
  'top',
  'bottom',
  'left',
  'right'
];

var ELEMENT_LABEL_DISTANCE = 10;

/**
 * A component that makes sure that external labels are added
 * together with respective elements and properly updated (DI wise)
 * during move.
 *
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 */
function AdaptiveLabelPositioningBehavior(eventBus, modeling) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  this.postExecuted([
    'connection.create',
    'connection.layout',
    'connection.updateWaypoints'
  ], function(event) {
    var context = event.context,
        connection = context.connection,
        source = connection.source,
        target = connection.target,
        hints = context.hints || {};

    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(source);
      checkLabelAdjustment(target);
    }
  });


  this.postExecuted([
    'label.create'
  ], function(event) {
    var context = event.context,
        shape = context.shape,
        hints = context.hints || {};

    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(shape.labelTarget);
    }
  });


  this.postExecuted([
    'elements.create'
  ], function(event) {
    var context = event.context,
        elements = context.elements,
        hints = context.hints || {};

    if (hints.createElementsBehavior !== false) {
      elements.forEach(function(element) {
        checkLabelAdjustment(element);
      });
    }
  });

  function checkLabelAdjustment(element) {

    // skip non-existing labels
    if (!(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.hasExternalLabel)(element)) {
      return;
    }

    var optimalPosition = getOptimalPosition(element);

    // no optimal position found
    if (!optimalPosition) {
      return;
    }

    adjustLabelPosition(element, optimalPosition);
  }

  function adjustLabelPosition(element, orientation) {

    var elementMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(element),
        label = element.label,
        labelMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(label);

    // ignore labels that are being created
    if (!label.parent) {
      return;
    }

    var elementTrbl = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.asTRBL)(element);

    var newLabelMid;

    switch (orientation) {
    case 'top':
      newLabelMid = {
        x: elementMid.x,
        y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2
      };

      break;

    case 'left':

      newLabelMid = {
        x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,
        y: elementMid.y
      };

      break;

    case 'bottom':

      newLabelMid = {
        x: elementMid.x,
        y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2
      };

      break;

    case 'right':

      newLabelMid = {
        x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,
        y: elementMid.y
      };

      break;
    }

    var delta = (0,diagram_js_lib_util_Math__WEBPACK_IMPORTED_MODULE_4__.delta)(newLabelMid, labelMid);

    modeling.moveShape(label, delta);
  }

}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(AdaptiveLabelPositioningBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

AdaptiveLabelPositioningBehavior.$inject = [
  'eventBus',
  'modeling'
];


// helpers //////////////////////

/**
 * Return alignments which are taken by a boundary's host element
 *
 * @param {Shape} element
 *
 * @return {Array<String>}
 */
function getTakenHostAlignments(element) {

  var hostElement = element.host,
      elementMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(element),
      hostOrientation = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getOrientation)(elementMid, hostElement);

  var freeAlignments;

  // check whether there is a multi-orientation, e.g. 'top-left'
  if (hostOrientation.indexOf('-') >= 0) {
    freeAlignments = hostOrientation.split('-');
  } else {
    freeAlignments = [ hostOrientation ];
  }

  var takenAlignments = ALIGNMENTS.filter(function(alignment) {

    return freeAlignments.indexOf(alignment) === -1;
  });

  return takenAlignments;

}

/**
 * Return alignments which are taken by related connections
 *
 * @param {Shape} element
 *
 * @return {Array<String>}
 */
function getTakenConnectionAlignments(element) {

  var elementMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(element);

  var takenAlignments = [].concat(
    element.incoming.map(function(c) {
      return c.waypoints[c.waypoints.length - 2 ];
    }),
    element.outgoing.map(function(c) {
      return c.waypoints[1];
    })
  ).map(function(point) {
    return getApproximateOrientation(elementMid, point);
  });

  return takenAlignments;
}

/**
 * Return the optimal label position around an element
 * or _undefined_, if none was found.
 *
 * @param  {Shape} element
 *
 * @return {String} positioning identifier
 */
function getOptimalPosition(element) {

  var labelMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(element.label);

  var elementMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(element);

  var labelOrientation = getApproximateOrientation(elementMid, labelMid);

  if (!isAligned(labelOrientation)) {
    return;
  }

  var takenAlignments = getTakenConnectionAlignments(element);

  if (element.host) {
    var takenHostAlignments = getTakenHostAlignments(element);

    takenAlignments = takenAlignments.concat(takenHostAlignments);
  }

  var freeAlignments = ALIGNMENTS.filter(function(alignment) {

    return takenAlignments.indexOf(alignment) === -1;
  });

  // NOTHING TO DO; label already aligned a.O.K.
  if (freeAlignments.indexOf(labelOrientation) !== -1) {
    return;
  }

  return freeAlignments[0];
}

function getApproximateOrientation(p0, p1) {
  return (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getOrientation)(p1, p0, 5);
}

function isAligned(orientation) {
  return ALIGNMENTS.indexOf(orientation) !== -1;
}


/***/ }),

/***/ "./lib/features/modeling/behavior/AppendBehavior.js":
/*!**********************************************************!*\
  !*** ./lib/features/modeling/behavior/AppendBehavior.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AppendBehavior)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");





function AppendBehavior(eventBus) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  // assign correct shape position unless already set

  this.preExecute('shape.append', function(context) {

    var source = context.source,
        shape = context.shape;

    if (!context.position) {

      context.position = {
        x: source.x + source.width + 80 + shape.width / 2,
        y: source.y + source.height / 2
      };

    }
  }, true);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(AppendBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

AppendBehavior.$inject = [
  'eventBus'
];

/***/ }),

/***/ "./lib/features/modeling/behavior/CreateBoardElementBehavior.js":
/*!**********************************************************************!*\
  !*** ./lib/features/modeling/behavior/CreateBoardElementBehavior.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateBoardElementBehavior)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");









function CreateBoardElementBehavior(eventBus) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  // ensure properties were set in business object

  this.execute('shape.create', function(context) {

    var shape = context.context.shape;

    if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(shape, 'postit:Postit')) {
      const businessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.getBusinessObject)(shape);
      !businessObject.color && (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)(businessObject, { color: shape.color });
    }

    if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(shape, 'postit:Image')) {
      const businessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.getBusinessObject)(shape);
      !businessObject.source && (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)(businessObject, { source: shape.source });
    }
  });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(CreateBoardElementBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

CreateBoardElementBehavior.$inject = [
  'eventBus'
];

/***/ }),

/***/ "./lib/features/modeling/behavior/EmptyTextBoxBehavior.js":
/*!****************************************************************!*\
  !*** ./lib/features/modeling/behavior/EmptyTextBoxBehavior.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EmptyTextBoxBehavior)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");







function EmptyTextBoxBehavior(eventBus, modeling, directEditing) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  // delete text box if it has no text
  this.postExecute('element.updateLabel', function(context) {

    var element = context.element,
        newLabel = context.newLabel;

    if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(element, 'postit:TextBox') && isEmpty(newLabel)) {
      modeling.removeElements([ element ]);
    }
  }, true);

  eventBus.on('directEditing.cancel', 1001, function(event) {
    var active = event.active,
        element = active.element;

    if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(element, 'postit:TextBox') && isEmpty((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.getBusinessObject)(element).name)) {
      directEditing._active = false;
      modeling.removeElements([ element ]);
    }
  });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(EmptyTextBoxBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

EmptyTextBoxBehavior.$inject = [
  'eventBus',
  'modeling',
  'directEditing'
];


// helpers //////////

function isEmpty(label) {
  return !label || label === '';
}

/***/ }),

/***/ "./lib/features/modeling/behavior/FixHoverBehavior.js":
/*!************************************************************!*\
  !*** ./lib/features/modeling/behavior/FixHoverBehavior.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FixHoverBehavior)
/* harmony export */ });
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");


var HIGH_PRIORITY = 1500;


/**
 * Correct hover targets in certain situations to improve diagram interaction.
 *
 * @param {ElementRegistry} elementRegistry
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function FixHoverBehavior(elementRegistry, eventBus, canvas) {

  eventBus.on([
    'create.hover',
    'create.move',
    'create.end',
    'shape.move.hover',
    'shape.move.move',
    'shape.move.end'
  ], HIGH_PRIORITY, function(event) {
    var context = event.context,
        shape = context.shape || event.shape,
        hover = event.hover;

    var rootElement = canvas.getRootElement();

    // ensure group & label elements are dropped always onto the root
    if (hover !== rootElement && (shape.labelTarget || (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.is)(shape, 'postit:Group'))) {
      event.hover = rootElement;
      event.hoverGfx = elementRegistry.getGraphics(event.hover);
    }
  });

}

FixHoverBehavior.$inject = [
  'elementRegistry',
  'eventBus',
  'canvas'
];

/***/ }),

/***/ "./lib/features/modeling/behavior/ImportDockingFix.js":
/*!************************************************************!*\
  !*** ./lib/features/modeling/behavior/ImportDockingFix.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImportDockingFix)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var _util_LineIntersect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/LineIntersect */ "./lib/features/modeling/behavior/util/LineIntersect.js");





/**
 * Fix broken dockings after DI imports.
 *
 * @param {EventBus} eventBus
 */
function ImportDockingFix(eventBus) {

  function adjustDocking(startPoint, nextPoint, elementMid) {

    var elementTop = {
      x: elementMid.x,
      y: elementMid.y - 50
    };

    var elementLeft = {
      x: elementMid.x - 50,
      y: elementMid.y
    };

    var verticalIntersect = (0,_util_LineIntersect__WEBPACK_IMPORTED_MODULE_0__.default)(startPoint, nextPoint, elementMid, elementTop),
        horizontalIntersect = (0,_util_LineIntersect__WEBPACK_IMPORTED_MODULE_0__.default)(startPoint, nextPoint, elementMid, elementLeft);

    // original is horizontal or vertical center cross intersection
    var centerIntersect;

    if (verticalIntersect && horizontalIntersect) {
      if (getDistance(verticalIntersect, elementMid) > getDistance(horizontalIntersect, elementMid)) {
        centerIntersect = horizontalIntersect;
      } else {
        centerIntersect = verticalIntersect;
      }
    } else {
      centerIntersect = verticalIntersect || horizontalIntersect;
    }

    startPoint.original = centerIntersect;
  }

  function fixDockings(connection) {
    var waypoints = connection.waypoints;

    adjustDocking(
      waypoints[0],
      waypoints[1],
      (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(connection.source)
    );

    adjustDocking(
      waypoints[waypoints.length - 1],
      waypoints[waypoints.length - 2],
      (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(connection.target)
    );
  }

  eventBus.on('boardElement.added', function(e) {

    var element = e.element;

    if (element.waypoints) {
      fixDockings(element);
    }
  });
}

ImportDockingFix.$inject = [
  'eventBus'
];


// helpers //////////////////////

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

/***/ }),

/***/ "./lib/features/modeling/behavior/LabelBehavior.js":
/*!*********************************************************!*\
  !*** ./lib/features/modeling/behavior/LabelBehavior.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LabelBehavior),
/* harmony export */   "getReferencePointDelta": () => (/* binding */ getReferencePointDelta),
/* harmony export */   "getReferencePoint": () => (/* binding */ getReferencePoint),
/* harmony export */   "asEdges": () => (/* binding */ asEdges)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/LabelUtil */ "./lib/util/LabelUtil.js");
/* harmony import */ var _label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../label-editing/LabelUtil */ "./lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _util_LabelLayoutUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/LabelLayoutUtil */ "./lib/features/modeling/behavior/util/LabelLayoutUtil.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");
/* harmony import */ var diagram_js_lib_util_AttachUtil__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! diagram-js/lib/util/AttachUtil */ "./node_modules/diagram-js/lib/util/AttachUtil.js");
/* harmony import */ var diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! diagram-js/lib/layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var diagram_js_lib_util_PositionUtil__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! diagram-js/lib/util/PositionUtil */ "./node_modules/diagram-js/lib/util/PositionUtil.js");
/* harmony import */ var _util_GeometricUtil__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./util/GeometricUtil */ "./lib/features/modeling/behavior/util/GeometricUtil.js");
























var DEFAULT_LABEL_DIMENSIONS = {
  width: 90,
  height: 20
};

var NAME_PROPERTY = 'name';

/**
 * A component that makes sure that external labels are added
 * together with respective elements and properly updated (DI wise)
 * during move.
 *
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 * @param {PostitFactory} postitFactory
 * @param {TextRenderer} textRenderer
 */
function LabelBehavior(
    eventBus, modeling, postitFactory,
    textRenderer) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  // update label if name property was updated
  this.postExecute('element.updateProperties', function(e) {
    var context = e.context,
        element = context.element,
        properties = context.properties;

    if (NAME_PROPERTY in properties) {
      modeling.updateLabel(element, properties[NAME_PROPERTY]);
    }
  });

  // create label shape after shape/connection was created
  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {
    var context = e.context,
        hints = context.hints || {};

    if (hints.createElementsBehavior === false) {
      return;
    }

    var element = context.shape || context.connection,
        businessObject = element.businessObject;

    if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.isLabel)(element) || !(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.isLabelExternal)(element)) {
      return;
    }

    // only create label if attribute available
    if (!(0,_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.getLabel)(element)) {
      return;
    }

    var labelCenter = (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.getExternalLabelMid)(element);

    // we don't care about x and y
    var labelDimensions = textRenderer.getExternalLabelBounds(
      DEFAULT_LABEL_DIMENSIONS,
      (0,_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.getLabel)(element)
    );

    modeling.createLabel(element, labelCenter, {
      id: businessObject.id + '_label',
      businessObject: businessObject,
      width: labelDimensions.width,
      height: labelDimensions.height
    });
  });

  // update label after label shape was deleted
  this.postExecute('shape.delete', function(event) {
    var context = event.context,
        labelTarget = context.labelTarget,
        hints = context.hints || {};

    // check if label
    if (labelTarget && hints.unsetLabel !== false) {
      modeling.updateLabel(labelTarget, null, null, { removeShape: false });
    }
  });

  // update di information on label creation
  this.postExecute([ 'label.create' ], function(event) {

    var context = event.context,
        element = context.shape,
        businessObject,
        di;

    // we want to trigger on real labels only
    if (!element.labelTarget) {
      return;
    }

    // we want to trigger on board elements only
    if (!(0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.is)(element.labelTarget || element, 'postit:BoardElement')) {
      return;
    }

    businessObject = element.businessObject,
    di = businessObject.di;


    if (!di.label) {
      di.label = postitFactory.create('postitDi:PostitLabel', {
        bounds: postitFactory.create('dc:Bounds')
      });
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_5__.assign)(di.label.bounds, {
      x: element.x,
      y: element.y,
      width: element.width,
      height: element.height
    });
  });

  function getVisibleLabelAdjustment(event) {

    var context = event.context,
        connection = context.connection,
        label = connection.label,
        hints = (0,min_dash__WEBPACK_IMPORTED_MODULE_5__.assign)({}, context.hints),
        newWaypoints = context.newWaypoints || connection.waypoints,
        oldWaypoints = context.oldWaypoints;


    if (typeof hints.startChanged === 'undefined') {
      hints.startChanged = !!hints.connectionStart;
    }

    if (typeof hints.endChanged === 'undefined') {
      hints.endChanged = !!hints.connectionEnd;
    }

    return (0,_util_LabelLayoutUtil__WEBPACK_IMPORTED_MODULE_6__.getLabelAdjustment)(label, newWaypoints, oldWaypoints, hints);
  }

  this.postExecute([
    'connection.layout',
    'connection.updateWaypoints'
  ], function(event) {
    var context = event.context,
        hints = context.hints || {};

    if (hints.labelBehavior === false) {
      return;
    }

    var connection = context.connection,
        label = connection.label,
        labelAdjustment;

    // handle missing label as well as the case
    // that the label parent does not exist (yet),
    // because it is being pasted / created via multi element create
    //
    // Cf. https://github.com/bpmn-io/bpmn-js/pull/1227
    if (!label || !label.parent) {
      return;
    }

    labelAdjustment = getVisibleLabelAdjustment(event);

    modeling.moveShape(label, labelAdjustment);
  });


  // keep label position on shape replace
  this.postExecute([ 'shape.replace' ], function(event) {
    var context = event.context,
        newShape = context.newShape,
        oldShape = context.oldShape;

    var businessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.getBusinessObject)(newShape);

    if (businessObject
      && (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.isLabelExternal)(businessObject)
      && oldShape.label
      && newShape.label) {
      newShape.label.x = oldShape.label.x;
      newShape.label.y = oldShape.label.y;
    }
  });


  // move external label after resizing
  this.postExecute('shape.resize', function(event) {

    var context = event.context,
        shape = context.shape,
        newBounds = context.newBounds,
        oldBounds = context.oldBounds;

    if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.hasExternalLabel)(shape)) {

      var label = shape.label,
          labelMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_7__.getMid)(label),
          edges = asEdges(oldBounds);

      // get nearest border point to label as reference point
      var referencePoint = getReferencePoint(labelMid, edges);

      var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);

      modeling.moveShape(label, delta);

    }

  });

}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(LabelBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

LabelBehavior.$inject = [
  'eventBus',
  'modeling',
  'postitFactory',
  'textRenderer'
];

// helpers //////////////////////

/**
 * Calculates a reference point delta relative to a new position
 * of a certain element's bounds
 *
 * @param {Point} point
 * @param {Bounds} oldBounds
 * @param {Bounds} newBounds
 *
 * @return {Delta} delta
 */
function getReferencePointDelta(referencePoint, oldBounds, newBounds) {

  var newReferencePoint = (0,diagram_js_lib_util_AttachUtil__WEBPACK_IMPORTED_MODULE_8__.getNewAttachPoint)(referencePoint, oldBounds, newBounds);

  return (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_7__.roundPoint)((0,diagram_js_lib_util_PositionUtil__WEBPACK_IMPORTED_MODULE_9__.delta)(newReferencePoint, referencePoint));
}

/**
 * Generates the nearest point (reference point) for a given point
 * onto given set of lines
 *
 * @param {Array<Point, Point>} lines
 * @param {Point} point
 *
 * @param {Point}
 */
function getReferencePoint(point, lines) {

  if (!lines.length) {
    return;
  }

  var nearestLine = getNearestLine(point, lines);

  return (0,_util_GeometricUtil__WEBPACK_IMPORTED_MODULE_10__.perpendicularFoot)(point, nearestLine);
}

/**
 * Convert the given bounds to a lines array containing all edges
 *
 * @param {Bounds|Point} bounds
 *
 * @return Array<Point>
 */
function asEdges(bounds) {
  return [
    [ // top
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      }
    ],
    [ // right
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [ // bottom
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [ // left
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      }
    ]
  ];
}

/**
 * Returns the nearest line for a given point by distance
 * @param {Point} point
 * @param Array<Point> lines
 *
 * @return Array<Point>
 */
function getNearestLine(point, lines) {

  var distances = lines.map(function(l) {
    return {
      line: l,
      distance: (0,_util_GeometricUtil__WEBPACK_IMPORTED_MODULE_10__.getDistancePointLine)(point, l)
    };
  });

  var sorted = (0,min_dash__WEBPACK_IMPORTED_MODULE_5__.sortBy)(distances, 'distance');

  return sorted[0].line;
}


/***/ }),

/***/ "./lib/features/modeling/behavior/ReplaceElementBehaviour.js":
/*!*******************************************************************!*\
  !*** ./lib/features/modeling/behavior/ReplaceElementBehaviour.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReplaceElementBehaviour)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");







/**
 * postit-specific replace behavior.
 */
function ReplaceElementBehaviour(
    postitReplace,
    postitRules,
    elementRegistry,
    injector,
    modeling,
    selection
) {
  injector.invoke(diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default, this);

  this._postitReplace = postitReplace;
  this._elementRegistry = elementRegistry;
  this._selection = selection;

  // replace elements on move
  this.postExecuted([ 'elements.move' ], 500, function(event) {
    var context = event.context,
        target = context.newParent,
        newHost = context.newHost,
        elements = [];

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(context.closure.topLevel, function(topLevelElements) {
      elements = elements.concat(topLevelElements);
    });

    // set target to host if attaching
    if (elements.length === 1 && newHost) {
      target = newHost;
    }

    var canReplace = postitRules.canReplace(elements, target);

    if (canReplace) {
      this.replaceElements(elements, canReplace.replacements, newHost);
    }
  }, this);

  // update attachments on host replace
  this.postExecute([ 'shape.replace' ], 1500, function(e) {
    var context = e.context,
        oldShape = context.oldShape,
        newShape = context.newShape,
        attachers = oldShape.attachers,
        canReplace;

    if (attachers && attachers.length) {
      canReplace = postitRules.canReplace(attachers, newShape);

      this.replaceElements(attachers, canReplace.replacements);
    }

  }, this);

  // keep ID on shape replace
  this.postExecuted([ 'shape.replace' ], 1500, function(e) {
    var context = e.context,
        oldShape = context.oldShape,
        newShape = context.newShape;

    modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);
    modeling.updateProperties(newShape, { id: oldShape.id });
  });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(ReplaceElementBehaviour, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

ReplaceElementBehaviour.prototype.replaceElements = function(elements, newElements) {
  var elementRegistry = this._elementRegistry,
      postitReplace = this._postitReplace,
      selection = this._selection;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(newElements, function(replacement) {
    var newElement = {
      type: replacement.newElementType
    };

    var oldElement = elementRegistry.get(replacement.oldElementId);

    var idx = elements.indexOf(oldElement);

    elements[idx] = postitReplace.replaceElement(oldElement, newElement, { select: false });
  });

  if (newElements) {
    selection.select(elements);
  }
};

ReplaceElementBehaviour.$inject = [
  'postitReplace',
  'postitRules',
  'elementRegistry',
  'injector',
  'modeling',
  'selection'
];


/***/ }),

/***/ "./lib/features/modeling/behavior/UnclaimIdBehavior.js":
/*!*************************************************************!*\
  !*** ./lib/features/modeling/behavior/UnclaimIdBehavior.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UnclaimIdBehavior)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/LabelUtil */ "./lib/util/LabelUtil.js");







/**
 * Unclaims model IDs on element deletion.
 *
 * @param {Canvas} canvas
 * @param {Injector} injector
 * @param {Moddle} moddle
 * @param {Modeling} modeling
 */
function UnclaimIdBehavior(canvas, injector, moddle, modeling) {
  injector.invoke(diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default, this);

  this.preExecute('shape.delete', function(event) {
    var context = event.context,
        shape = context.shape,
        shapeBo = shape.businessObject;

    if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.isLabel)(shape)) {
      return;
    }

    modeling.unclaimId(shapeBo.id, shapeBo);
  });

  this.preExecute('canvas.updateRoot', function() {
    var rootElement = canvas.getRootElement(),
        rootElementBo = rootElement.businessObject;

    moddle.ids.unclaim(rootElementBo.id);
  });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(UnclaimIdBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

UnclaimIdBehavior.$inject = [ 'canvas', 'injector', 'moddle', 'modeling' ];

/***/ }),

/***/ "./lib/features/modeling/behavior/index.js":
/*!*************************************************!*\
  !*** ./lib/features/modeling/behavior/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AdaptiveLabelPositioningBehavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AdaptiveLabelPositioningBehavior */ "./lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js");
/* harmony import */ var _AppendBehavior__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AppendBehavior */ "./lib/features/modeling/behavior/AppendBehavior.js");
/* harmony import */ var _FixHoverBehavior__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FixHoverBehavior */ "./lib/features/modeling/behavior/FixHoverBehavior.js");
/* harmony import */ var _ImportDockingFix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ImportDockingFix */ "./lib/features/modeling/behavior/ImportDockingFix.js");
/* harmony import */ var _LabelBehavior__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LabelBehavior */ "./lib/features/modeling/behavior/LabelBehavior.js");
/* harmony import */ var _ReplaceElementBehaviour__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ReplaceElementBehaviour */ "./lib/features/modeling/behavior/ReplaceElementBehaviour.js");
/* harmony import */ var _UnclaimIdBehavior__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UnclaimIdBehavior */ "./lib/features/modeling/behavior/UnclaimIdBehavior.js");
/* harmony import */ var _CreateBoardElementBehavior__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CreateBoardElementBehavior */ "./lib/features/modeling/behavior/CreateBoardElementBehavior.js");
/* harmony import */ var _EmptyTextBoxBehavior__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EmptyTextBoxBehavior */ "./lib/features/modeling/behavior/EmptyTextBoxBehavior.js");










/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [
    'adaptiveLabelPositioningBehavior',
    'appendBehavior',
    'fixHoverBehavior',
    'importDockingFix',
    'labelBehavior',
    'replaceElementBehaviour',
    'unclaimIdBehavior',
    'createBoardElementBehavior',
    'emptyTextBoxBehavior'
  ],
  adaptiveLabelPositioningBehavior: [ 'type', _AdaptiveLabelPositioningBehavior__WEBPACK_IMPORTED_MODULE_0__.default ],
  appendBehavior: [ 'type', _AppendBehavior__WEBPACK_IMPORTED_MODULE_1__.default ],
  fixHoverBehavior: [ 'type', _FixHoverBehavior__WEBPACK_IMPORTED_MODULE_2__.default ],
  importDockingFix: [ 'type', _ImportDockingFix__WEBPACK_IMPORTED_MODULE_3__.default ],
  labelBehavior: [ 'type', _LabelBehavior__WEBPACK_IMPORTED_MODULE_4__.default ],
  replaceElementBehaviour: [ 'type', _ReplaceElementBehaviour__WEBPACK_IMPORTED_MODULE_5__.default ],
  unclaimIdBehavior: [ 'type', _UnclaimIdBehavior__WEBPACK_IMPORTED_MODULE_6__.default ],
  createBoardElementBehavior: [ 'type', _CreateBoardElementBehavior__WEBPACK_IMPORTED_MODULE_7__.default ],
  emptyTextBoxBehavior: [ 'type', _EmptyTextBoxBehavior__WEBPACK_IMPORTED_MODULE_8__.default ]
});


/***/ }),

/***/ "./lib/features/modeling/behavior/util/GeometricUtil.js":
/*!**************************************************************!*\
  !*** ./lib/features/modeling/behavior/util/GeometricUtil.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "vectorLength": () => (/* binding */ vectorLength),
/* harmony export */   "getAngle": () => (/* binding */ getAngle),
/* harmony export */   "rotateVector": () => (/* binding */ rotateVector),
/* harmony export */   "perpendicularFoot": () => (/* binding */ perpendicularFoot),
/* harmony export */   "getDistancePointLine": () => (/* binding */ getDistancePointLine),
/* harmony export */   "getDistancePointPoint": () => (/* binding */ getDistancePointPoint)
/* harmony export */ });
/**
 * Returns the length of a vector
 *
 * @param {Vector}
 * @return {Float}
 */
function vectorLength(v) {
  return Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));
}


/**
 * Calculates the angle between a line a the yAxis
 *
 * @param {Array}
 * @return {Float}
 */
function getAngle(line) {

  // return value is between 0, 180 and -180, -0
  // @janstuemmel: maybe replace return a/b with b/a
  return Math.atan((line[1].y - line[0].y) / (line[1].x - line[0].x));
}


/**
 * Rotates a vector by a given angle
 *
 * @param {Vector}
 * @param {Float} Angle in radians
 * @return {Vector}
 */
function rotateVector(vector, angle) {
  return (!angle) ? vector : {
    x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,
    y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y
  };
}


/**
 * Solves a 2D equation system
 * a + r*b = c, where a,b,c are 2D vectors
 *
 * @param {Vector}
 * @param {Vector}
 * @param {Vector}
 * @return {Float}
 */
function solveLambaSystem(a, b, c) {

  // the 2d system
  var system = [
    { n: a[0] - c[0], lambda: b[0] },
    { n: a[1] - c[1], lambda: b[1] }
  ];

  // solve
  var n = system[0].n * b[0] + system[1].n * b[1],
      l = system[0].lambda * b[0] + system[1].lambda * b[1];

  return -n/l;
}


/**
 * Position of perpendicular foot
 *
 * @param {Point}
 * @param [ {Point}, {Point} ] line defined through two points
 * @return {Point} the perpendicular foot position
 */
function perpendicularFoot(point, line) {

  var a = line[0], b = line[1];

  // relative position of b from a
  var bd = { x: b.x - a.x, y: b.y - a.y };

  // solve equation system to the parametrized vectors param real value
  var r = solveLambaSystem([ a.x, a.y ], [ bd.x, bd.y ], [ point.x, point.y ]);

  return { x: a.x + r*bd.x, y: a.y + r*bd.y };
}


/**
 * Calculates the distance between a point and a line
 *
 * @param {Point}
 * @param [ {Point}, {Point} ] line defined through two points
 * @return {Float} distance
 */
function getDistancePointLine(point, line) {

  var pfPoint = perpendicularFoot(point, line);

  // distance vector
  var connectionVector = {
    x: pfPoint.x - point.x,
    y: pfPoint.y - point.y
  };

  return vectorLength(connectionVector);
}


/**
 * Calculates the distance between two points
 *
 * @param {Point}
 * @param {Point}
 * @return {Float} distance
 */
function getDistancePointPoint(point1, point2) {

  return vectorLength({
    x: point1.x - point2.x,
    y: point1.y - point2.y
  });
}

/***/ }),

/***/ "./lib/features/modeling/behavior/util/LabelLayoutUtil.js":
/*!****************************************************************!*\
  !*** ./lib/features/modeling/behavior/util/LabelLayoutUtil.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "findNewLabelLineStartIndex": () => (/* binding */ findNewLabelLineStartIndex),
/* harmony export */   "getLabelAdjustment": () => (/* binding */ getLabelAdjustment)
/* harmony export */ });
/* harmony import */ var _GeometricUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometricUtil */ "./lib/features/modeling/behavior/util/GeometricUtil.js");
/* harmony import */ var _LineAttachmentUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineAttachmentUtil */ "./lib/features/modeling/behavior/util/LineAttachmentUtil.js");
/* harmony import */ var diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");







function findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {

  var index = attachment.segmentIndex;

  var offset = newWaypoints.length - oldWaypoints.length;

  // segmentMove happened
  if (hints.segmentMove) {

    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,
        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;

    // if label was on moved segment return new segment index
    if (index === oldSegmentStartIndex) {
      return newSegmentStartIndex;
    }

    // label is after new segment index
    if (index >= newSegmentStartIndex) {
      return (index+offset < newSegmentStartIndex) ? newSegmentStartIndex : index+offset;
    }

    // if label is before new segment index
    return index;
  }

  // bendpointMove happened
  if (hints.bendpointMove) {

    var insert = hints.bendpointMove.insert,
        bendpointIndex = hints.bendpointMove.bendpointIndex,
        newIndex;

    // waypoints length didnt change
    if (offset === 0) {
      return index;
    }

    // label behind new/removed bendpoint
    if (index >= bendpointIndex) {
      newIndex = insert ? index + 1 : index - 1;
    }

    // label before new/removed bendpoint
    if (index < bendpointIndex) {

      newIndex = index;

      // decide label should take right or left segment
      if (insert && attachment.type !== 'bendpoint' && bendpointIndex-1 === index) {

        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);

        if (rel < attachment.relativeLocation) {
          newIndex++;
        }
      }
    }

    return newIndex;
  }

  // start/end changed
  if (offset === 0) {
    return index;
  }

  if (hints.connectionStart) {
    return (index === 0) ? 0 : null;
  }

  if (hints.connectionEnd) {
    return (index === oldWaypoints.length - 2) ? newWaypoints.length - 2 : null;
  }

  // if nothing fits, return null
  return null;
}


/**
 * Calculate the required adjustment (move delta) for the given label
 * after the connection waypoints got updated.
 *
 * @param {djs.model.Label} label
 * @param {Array<Point>} newWaypoints
 * @param {Array<Point>} oldWaypoints
 * @param {Object} hints
 *
 * @return {Point} delta
 */
function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {

  var x = 0,
      y = 0;

  var labelPosition = getLabelMid(label);

  // get closest attachment
  var attachment = (0,_LineAttachmentUtil__WEBPACK_IMPORTED_MODULE_0__.getAttachment)(labelPosition, oldWaypoints),
      oldLabelLineIndex = attachment.segmentIndex,
      newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);

  if (newLabelLineIndex === null) {
    return { x: x, y: y };
  }

  // should never happen
  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored
  if (newLabelLineIndex < 0 ||
      newLabelLineIndex > newWaypoints.length - 2) {
    return { x: x, y: y };
  }

  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),
      newLabelLine = getLine(newWaypoints, newLabelLineIndex),
      oldFoot = attachment.position;

  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),
      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);

  // special rule if label on bendpoint
  if (attachment.type === 'bendpoint') {

    var offset = newWaypoints.length - oldWaypoints.length,
        oldBendpointIndex = attachment.bendpointIndex,
        oldBendpoint = oldWaypoints[oldBendpointIndex];

    // bendpoint position hasn't changed, return same position
    if (newWaypoints.indexOf(oldBendpoint) !== -1) {
      return { x: x, y: y };
    }

    // new bendpoint and old bendpoint have same index, then just return the offset
    if (offset === 0) {
      var newBendpoint = newWaypoints[oldBendpointIndex];

      return {
        x: newBendpoint.x - attachment.position.x,
        y: newBendpoint.y - attachment.position.y
      };
    }

    // if bendpoints get removed
    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {
      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);
    }
  }

  var newFoot = {
    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,
    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y
  };

  // the rotated vector to label
  var newLabelVector = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.rotateVector)({
    x: labelPosition.x - oldFoot.x,
    y: labelPosition.y - oldFoot.y
  }, angleDelta);

  // the new relative position
  x = newFoot.x + newLabelVector.x - labelPosition.x;
  y = newFoot.y + newLabelVector.y - labelPosition.y;

  return (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_2__.roundPoint)({
    x: x,
    y: y
  });
}


// HELPERS //////////////////////

function relativePositionMidWaypoint(waypoints, idx) {

  var distanceSegment1 = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getDistancePointPoint)(waypoints[idx-1], waypoints[idx]),
      distanceSegment2 = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getDistancePointPoint)(waypoints[idx], waypoints[idx+1]);

  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);

  return relativePosition;
}

function getLabelMid(label) {
  return {
    x: label.x + label.width / 2,
    y: label.y + label.height / 2
  };
}

function getAngleDelta(l1, l2) {
  var a1 = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getAngle)(l1),
      a2 = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getAngle)(l2);
  return a2 - a1;
}

function getLine(waypoints, idx) {
  return [ waypoints[idx], waypoints[idx+1] ];
}

function getRelativeFootPosition(line, foot) {

  var length = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getDistancePointPoint)(line[0], line[1]),
      lengthToFoot = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getDistancePointPoint)(line[0], foot);

  return length === 0 ? 0 : lengthToFoot / length;
}


/***/ }),

/***/ "./lib/features/modeling/behavior/util/LineAttachmentUtil.js":
/*!*******************************************************************!*\
  !*** ./lib/features/modeling/behavior/util/LineAttachmentUtil.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAttachment": () => (/* binding */ getAttachment)
/* harmony export */ });
var sqrt = Math.sqrt,
    min = Math.min,
    max = Math.max,
    abs = Math.abs;

/**
 * Calculate the square (power to two) of a number.
 *
 * @param {Number} n
 *
 * @return {Number}
 */
function sq(n) {
  return Math.pow(n, 2);
}

/**
 * Get distance between two points.
 *
 * @param {Point} p1
 * @param {Point} p2
 *
 * @return {Number}
 */
function getDistance(p1, p2) {
  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));
}

/**
 * Return the attachment of the given point on the specified line.
 *
 * The attachment is either a bendpoint (attached to the given point)
 * or segment (attached to a location on a line segment) attachment:
 *
 * ```javascript
 * var pointAttachment = {
 *   type: 'bendpoint',
 *   bendpointIndex: 3,
 *   position: { x: 10, y: 10 } // the attach point on the line
 * };
 *
 * var segmentAttachment = {
 *   type: 'segment',
 *   segmentIndex: 2,
 *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)
 *   position: { x: 10, y: 10 } // the attach point on the line
 * };
 * ```
 *
 * @param {Point} point
 * @param {Array<Point>} line
 *
 * @return {Object} attachment
 */
function getAttachment(point, line) {

  var idx = 0,
      segmentStart,
      segmentEnd,
      segmentStartDistance,
      segmentEndDistance,
      attachmentPosition,
      minDistance,
      intersections,
      attachment,
      attachmentDistance,
      closestAttachmentDistance,
      closestAttachment;

  for (idx = 0; idx < line.length - 1; idx++) {

    segmentStart = line[idx];
    segmentEnd = line[idx + 1];

    if (pointsEqual(segmentStart, segmentEnd)) {
      intersections = [ segmentStart ];
    } else {
      segmentStartDistance = getDistance(point, segmentStart);
      segmentEndDistance = getDistance(point, segmentEnd);

      minDistance = min(segmentStartDistance, segmentEndDistance);

      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);
    }

    if (intersections.length < 1) {
      throw new Error('expected between [1, 2] circle -> line intersections');
    }

    // one intersection -> bendpoint attachment
    if (intersections.length === 1) {
      attachment = {
        type: 'bendpoint',
        position: intersections[0],
        segmentIndex: idx,
        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1
      };
    }

    // two intersections -> segment attachment
    if (intersections.length === 2) {

      attachmentPosition = mid(intersections[0], intersections[1]);

      attachment = {
        type: 'segment',
        position: attachmentPosition,
        segmentIndex: idx,
        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)
      };
    }

    attachmentDistance = getDistance(attachment.position, point);

    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {
      closestAttachment = attachment;
      closestAttachmentDistance = attachmentDistance;
    }
  }

  return closestAttachment;
}

/**
 * Gets the intersection between a circle and a line segment.
 *
 * @param {Point} s1 segment start
 * @param {Point} s2 segment end
 * @param {Point} cc circle center
 * @param {Number} cr circle radius
 *
 * @return {Array<Point>} intersections
 */
function getCircleSegmentIntersections(s1, s2, cc, cr) {

  var baX = s2.x - s1.x;
  var baY = s2.y - s1.y;
  var caX = cc.x - s1.x;
  var caY = cc.y - s1.y;

  var a = baX * baX + baY * baY;
  var bBy2 = baX * caX + baY * caY;
  var c = caX * caX + caY * caY - cr * cr;

  var pBy2 = bBy2 / a;
  var q = c / a;

  var disc = pBy2 * pBy2 - q;

  // check against negative value to work around
  // negative, very close to zero results (-4e-15)
  // being produced in some environments
  if (disc < 0 && disc > -0.000001) {
    disc = 0;
  }

  if (disc < 0) {
    return [];
  }

  // if disc == 0 ... dealt with later
  var tmpSqrt = sqrt(disc);
  var abScalingFactor1 = -pBy2 + tmpSqrt;
  var abScalingFactor2 = -pBy2 - tmpSqrt;

  var i1 = {
    x: s1.x - baX * abScalingFactor1,
    y: s1.y - baY * abScalingFactor1
  };

  if (disc === 0) { // abScalingFactor1 == abScalingFactor2
    return [ i1 ];
  }

  var i2 = {
    x: s1.x - baX * abScalingFactor2,
    y: s1.y - baY * abScalingFactor2
  };

  // return only points on line segment
  return [ i1, i2 ].filter(function(p) {
    return isPointInSegment(p, s1, s2);
  });
}


function isPointInSegment(p, segmentStart, segmentEnd) {
  return (
    fenced(p.x, segmentStart.x, segmentEnd.x) &&
    fenced(p.y, segmentStart.y, segmentEnd.y)
  );
}

function fenced(n, rangeStart, rangeEnd) {

  // use matching threshold to work around
  // precision errors in intersection computation

  return (
    n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD &&
    n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD
  );
}

/**
 * Calculate mid of two points.
 *
 * @param {Point} p1
 * @param {Point} p2
 *
 * @return {Point}
 */
function mid(p1, p2) {

  return {
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2
  };
}

var EQUAL_THRESHOLD = 0.1;

function pointsEqual(p1, p2) {

  return (
    abs(p1.x - p2.x) <= EQUAL_THRESHOLD &&
    abs(p1.y - p2.y) <= EQUAL_THRESHOLD
  );
}


/***/ }),

/***/ "./lib/features/modeling/behavior/util/LineIntersect.js":
/*!**************************************************************!*\
  !*** ./lib/features/modeling/behavior/util/LineIntersect.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lineIntersect)
/* harmony export */ });
/**
 * Returns the intersection between two line segments a and b.
 *
 * @param {Point} l1s
 * @param {Point} l1e
 * @param {Point} l2s
 * @param {Point} l2e
 *
 * @return {Point}
 */
function lineIntersect(l1s, l1e, l2s, l2e) {

  // if the lines intersect, the result contains the x and y of the
  // intersection (treating the lines as infinite) and booleans for
  // whether line segment 1 or line segment 2 contain the point
  var denominator, a, b, c, numerator;

  denominator = ((l2e.y - l2s.y) * (l1e.x - l1s.x)) - ((l2e.x - l2s.x) * (l1e.y - l1s.y));

  if (denominator == 0) {
    return null;
  }

  a = l1s.y - l2s.y;
  b = l1s.x - l2s.x;
  numerator = ((l2e.x - l2s.x) * a) - ((l2e.y - l2s.y) * b);

  c = numerator / denominator;

  // if we cast these lines infinitely in
  // both directions, they intersect here
  return {
    x: Math.round(l1s.x + (c * (l1e.x - l1s.x))),
    y: Math.round(l1s.y + (c * (l1e.y - l1s.y)))
  };
}

/***/ }),

/***/ "./lib/features/modeling/cmd/IdClaimHandler.js":
/*!*****************************************************!*\
  !*** ./lib/features/modeling/cmd/IdClaimHandler.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IdClaimHandler)
/* harmony export */ });
function IdClaimHandler(moddle) {
  this._moddle = moddle;
}

IdClaimHandler.$inject = [ 'moddle' ];


IdClaimHandler.prototype.execute = function(context) {
  var ids = this._moddle.ids,
      id = context.id,
      element = context.element,
      claiming = context.claiming;

  if (claiming) {
    ids.claim(id, element);
  } else {
    ids.unclaim(id);
  }
};

/**
 * Command revert implementation.
 */
IdClaimHandler.prototype.revert = function(context) {
  var ids = this._moddle.ids,
      id = context.id,
      element = context.element,
      claiming = context.claiming;

  if (claiming) {
    ids.unclaim(id);
  } else {
    ids.claim(id, element);
  }
};



/***/ }),

/***/ "./lib/features/modeling/cmd/SetColorHandler.js":
/*!******************************************************!*\
  !*** ./lib/features/modeling/cmd/SetColorHandler.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SetColorHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ColorUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/ColorUtil */ "./lib/util/ColorUtil.js");





var DEFAULT_COLOR = _util_ColorUtil__WEBPACK_IMPORTED_MODULE_0__.default.YELLOW;


function SetColorHandler(commandStack) {
  this._commandStack = commandStack;
}

SetColorHandler.$inject = [
  'commandStack'
];


SetColorHandler.prototype.postExecute = function(context) {
  var elements = context.elements,
      color = context.color || DEFAULT_COLOR;

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(elements, function(element) {

    self._commandStack.execute('element.updateProperties', {
      element: element,
      properties: {
        color: color
      }
    });
  });

};


/***/ }),

/***/ "./lib/features/modeling/cmd/UpdateCanvasRootHandler.js":
/*!**************************************************************!*\
  !*** ./lib/features/modeling/cmd/UpdateCanvasRootHandler.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpdateCanvasRootHandler)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");



function UpdateCanvasRootHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}

UpdateCanvasRootHandler.$inject = [
  'canvas',
  'modeling'
];


UpdateCanvasRootHandler.prototype.execute = function(context) {

  var canvas = this._canvas;

  var newRoot = context.newRoot,
      newRootBusinessObject = newRoot.businessObject,
      oldRoot = canvas.getRootElement(),
      oldRootBusinessObject = oldRoot.businessObject,
      postitDefinitions = oldRootBusinessObject.$parent,
      diPlane = oldRootBusinessObject.di;

  // (1) replace process old <> new root
  canvas.setRootElement(newRoot, true);

  // (2) update root elements
  (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(postitDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = postitDefinitions;

  (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_0__.remove)(postitDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = null;

  // (3) wire di
  oldRootBusinessObject.di = null;

  diPlane.boardElement = newRootBusinessObject;
  newRootBusinessObject.di = diPlane;

  context.oldRoot = oldRoot;

  // TODO(nikku): return changed elements?
  // return [ newRoot, oldRoot ];
};


UpdateCanvasRootHandler.prototype.revert = function(context) {

  var canvas = this._canvas;

  var newRoot = context.newRoot,
      newRootBusinessObject = newRoot.businessObject,
      oldRoot = context.oldRoot,
      oldRootBusinessObject = oldRoot.businessObject,
      postitDefinitions = newRootBusinessObject.$parent,
      diPlane = newRootBusinessObject.di;

  // (1) replace process old <> new root
  canvas.setRootElement(oldRoot, true);

  // (2) update root elements
  (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_0__.remove)(postitDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = null;

  (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(postitDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = postitDefinitions;

  // (3) wire di
  newRootBusinessObject.di = null;

  diPlane.boardElement = oldRootBusinessObject;
  oldRootBusinessObject.di = diPlane;

  // TODO(nikku): return changed elements?
  // return [ newRoot, oldRoot ];
};

/***/ }),

/***/ "./lib/features/modeling/cmd/UpdatePropertiesHandler.js":
/*!**************************************************************!*\
  !*** ./lib/features/modeling/cmd/UpdatePropertiesHandler.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpdatePropertiesHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");




var ID = 'id',
    DI = 'di';

var NULL_DIMENSIONS = {
  width: 0,
  height: 0
};

/**
 * A handler that implements a postit elements property update.
 *
 * This should be used to set simple properties on elements with
 * an underlying XML business object.
 *
 * Use respective diagram-js provided handlers if you would
 * like to perform automated modeling.
 */
function UpdatePropertiesHandler(
    elementRegistry, moddle, translate,
    modeling, textRenderer) {

  this._elementRegistry = elementRegistry;
  this._moddle = moddle;
  this._translate = translate;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
}

UpdatePropertiesHandler.$inject = [
  'elementRegistry',
  'moddle',
  'translate',
  'modeling',
  'textRenderer'
];


// api //////////////////////

/**
 * Updates a board element with a list of new properties
 *
 * @param {Object} context
 * @param {djs.model.Base} context.element the element to update
 * @param {Object} context.properties a list of properties to set on the element's
 *                                    businessObject (the XML model element)
 *
 * @return {Array<djs.model.Base>} the updated element
 */
UpdatePropertiesHandler.prototype.execute = function(context) {

  var element = context.element,
      changed = [ element ],
      translate = this._translate;

  if (!element) {
    throw new Error(translate('element required'));
  }

  var elementRegistry = this._elementRegistry,
      ids = this._moddle.ids;

  var businessObject = element.businessObject,
      properties = unwrapBusinessObjects(context.properties),
      oldProperties = context.oldProperties || getProperties(businessObject, properties);

  if (isIdChange(properties, businessObject)) {
    ids.unclaim(businessObject[ID]);

    elementRegistry.updateId(element, properties[ID]);

    ids.claim(properties[ID], businessObject);
  }

  // update properties
  setProperties(businessObject, properties);

  // store old values
  context.oldProperties = oldProperties;
  context.changed = changed;

  // indicate changed on objects affected by the update
  return changed;
};


UpdatePropertiesHandler.prototype.postExecute = function(context) {
  var element = context.element,
      label = element.label;

  var text = label && (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.getBusinessObject)(label).name;

  if (!text) {
    return;
  }

  // get layouted text bounds and resize external
  // external label accordingly
  var newLabelBounds = this._textRenderer.getExternalLabelBounds(label, text);

  this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS);
};

/**
 * Reverts the update on a board elements properties.
 *
 * @param  {Object} context
 *
 * @return {djs.model.Base} the updated element
 */
UpdatePropertiesHandler.prototype.revert = function(context) {

  var element = context.element,
      properties = context.properties,
      oldProperties = context.oldProperties,
      businessObject = element.businessObject,
      elementRegistry = this._elementRegistry,
      ids = this._moddle.ids;

  // update properties
  setProperties(businessObject, oldProperties);

  if (isIdChange(properties, businessObject)) {
    ids.unclaim(properties[ID]);

    elementRegistry.updateId(element, oldProperties[ID]);

    ids.claim(oldProperties[ID], businessObject);
  }

  return context.changed;
};


function isIdChange(properties, businessObject) {
  return ID in properties && properties[ID] !== businessObject[ID];
}


function getProperties(businessObject, properties) {
  var propertyNames = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.keys)(properties);

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.reduce)(propertyNames, function(result, key) {

    // handle DI separately
    if (key !== DI) {
      result[key] = businessObject.get(key);
    } else {
      result[key] = getDiProperties(businessObject.di, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.keys)(properties.di));
    }

    return result;
  }, {});
}


function getDiProperties(di, propertyNames) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.reduce)(propertyNames, function(result, key) {
    result[key] = di.get(key);

    return result;
  }, {});
}


function setProperties(businessObject, properties) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(properties, function(value, key) {

    if (key !== DI) {
      businessObject.set(key, value);
    } else {

      // only update, if businessObject.di exists
      if (businessObject.di) {
        setDiProperties(businessObject.di, value);
      }
    }
  });
}


function setDiProperties(di, properties) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(properties, function(value, key) {
    di.set(key, value);
  });
}


var referencePropertyNames = [ 'default' ];

/**
 * Make sure we unwrap the actual business object
 * behind diagram element that may have been
 * passed as arguments.
 *
 * @param  {Object} properties
 *
 * @return {Object} unwrappedProps
 */
function unwrapBusinessObjects(properties) {

  var unwrappedProps = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({}, properties);

  referencePropertyNames.forEach(function(name) {
    if (name in properties) {
      unwrappedProps[name] = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.getBusinessObject)(unwrappedProps[name]);
    }
  });

  return unwrappedProps;
}

/***/ }),

/***/ "./lib/features/modeling/index.js":
/*!****************************************!*\
  !*** ./lib/features/modeling/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./behavior */ "./lib/features/modeling/behavior/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules */ "./lib/features/rules/index.js");
/* harmony import */ var _di_ordering__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../di-ordering */ "./lib/features/di-ordering/index.js");
/* harmony import */ var _ordering__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ordering */ "./lib/features/ordering/index.js");
/* harmony import */ var _replace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../replace */ "./lib/features/replace/index.js");
/* harmony import */ var diagram_js_lib_command__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! diagram-js/lib/command */ "./node_modules/diagram-js/lib/command/index.js");
/* harmony import */ var diagram_js_lib_features_tooltips__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! diagram-js/lib/features/tooltips */ "./node_modules/diagram-js/lib/features/tooltips/index.js");
/* harmony import */ var diagram_js_lib_features_label_support__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! diagram-js/lib/features/label-support */ "./node_modules/diagram-js/lib/features/label-support/index.js");
/* harmony import */ var diagram_js_lib_features_attach_support__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! diagram-js/lib/features/attach-support */ "./node_modules/diagram-js/lib/features/attach-support/index.js");
/* harmony import */ var diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! diagram-js/lib/features/selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var diagram_js_lib_features_change_support__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! diagram-js/lib/features/change-support */ "./node_modules/diagram-js/lib/features/change-support/index.js");
/* harmony import */ var diagram_js_lib_features_space_tool__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! diagram-js/lib/features/space-tool */ "./node_modules/diagram-js/lib/features/space-tool/index.js");
/* harmony import */ var _PostitFactory__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./PostitFactory */ "./lib/features/modeling/PostitFactory.js");
/* harmony import */ var _PostitUpdater__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./PostitUpdater */ "./lib/features/modeling/PostitUpdater.js");
/* harmony import */ var _ElementFactory__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ElementFactory */ "./lib/features/modeling/ElementFactory.js");
/* harmony import */ var _Modeling__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Modeling */ "./lib/features/modeling/Modeling.js");
/* harmony import */ var diagram_js_lib_layout_BaseLayouter__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! diagram-js/lib/layout/BaseLayouter */ "./node_modules/diagram-js/lib/layout/BaseLayouter.js");
/* harmony import */ var diagram_js_lib_layout_CroppingConnectionDocking__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! diagram-js/lib/layout/CroppingConnectionDocking */ "./node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js");






















/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [
    'modeling',
    'postitUpdater'
  ],
  __depends__: [
    _behavior__WEBPACK_IMPORTED_MODULE_0__.default,
    _rules__WEBPACK_IMPORTED_MODULE_1__.default,
    _di_ordering__WEBPACK_IMPORTED_MODULE_2__.default,
    _ordering__WEBPACK_IMPORTED_MODULE_3__.default,
    _replace__WEBPACK_IMPORTED_MODULE_4__.default,
    diagram_js_lib_command__WEBPACK_IMPORTED_MODULE_5__.default,
    diagram_js_lib_features_tooltips__WEBPACK_IMPORTED_MODULE_6__.default,
    diagram_js_lib_features_label_support__WEBPACK_IMPORTED_MODULE_7__.default,
    diagram_js_lib_features_attach_support__WEBPACK_IMPORTED_MODULE_8__.default,
    diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_9__.default,
    diagram_js_lib_features_change_support__WEBPACK_IMPORTED_MODULE_10__.default,
    diagram_js_lib_features_space_tool__WEBPACK_IMPORTED_MODULE_11__.default
  ],
  postitFactory: [ 'type', _PostitFactory__WEBPACK_IMPORTED_MODULE_12__.default ],
  postitUpdater: [ 'type', _PostitUpdater__WEBPACK_IMPORTED_MODULE_13__.default ],
  elementFactory: [ 'type', _ElementFactory__WEBPACK_IMPORTED_MODULE_14__.default ],
  modeling: [ 'type', _Modeling__WEBPACK_IMPORTED_MODULE_15__.default ],
  layouter: [ 'type', diagram_js_lib_layout_BaseLayouter__WEBPACK_IMPORTED_MODULE_16__.default ],
  connectionDocking: [ 'type', diagram_js_lib_layout_CroppingConnectionDocking__WEBPACK_IMPORTED_MODULE_17__.default ]
});

/***/ }),

/***/ "./lib/features/modeling/util/ModelingUtil.js":
/*!****************************************************!*\
  !*** ./lib/features/modeling/util/ModelingUtil.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isAny": () => (/* binding */ isAny),
/* harmony export */   "getParent": () => (/* binding */ getParent)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");





/**
 * Return true if element has any of the given types.
 *
 * @param {djs.model.Base} element
 * @param {Array<String>} types
 *
 * @return {Boolean}
 */
function isAny(element, types) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.some)(types, function(t) {
    return (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__.is)(element, t);
  });
}


/**
 * Return the parent of the element with any of the given types.
 *
 * @param {djs.model.Base} element
 * @param {String|Array<String>} anyType
 *
 * @return {djs.model.Base}
 */
function getParent(element, anyType) {

  if (typeof anyType === 'string') {
    anyType = [ anyType ];
  }

  while ((element = element.parent)) {
    if (isAny(element, anyType)) {
      return element;
    }
  }

  return null;
}

/***/ }),

/***/ "./lib/features/ordering/PostitOrderingProvider.js":
/*!*********************************************************!*\
  !*** ./lib/features/ordering/PostitOrderingProvider.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitOrderingProvider)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_features_ordering_OrderingProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/ordering/OrderingProvider */ "./node_modules/diagram-js/lib/features/ordering/OrderingProvider.js");
/* harmony import */ var _modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modeling/util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");









/**
 * a simple ordering provider that makes sure:
 *
 * (0) labels and groups are rendered always on top
 * (1) elements are ordered by a {level} property
 */
function PostitOrderingProvider(eventBus, canvas, translate) {

  diagram_js_lib_features_ordering_OrderingProvider__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  var orders = [
    { type: 'postit:BoardElement', order: { level: 5 } }
  ];

  function computeOrder(element) {
    if (element.labelTarget) {
      return { level: 10 };
    }

    var entry = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.find)(orders, function(o) {
      return (0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_3__.isAny)(element, [ o.type ]);
    });

    return entry && entry.order || { level: 1 };
  }

  function getOrder(element) {

    var order = element.order;

    if (!order) {
      element.order = order = computeOrder(element);
    }

    return order;
  }

  function findActualParent(element, newParent, containers) {

    var actualParent = newParent;

    while (actualParent) {

      if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_3__.isAny)(actualParent, containers)) {
        break;
      }

      actualParent = actualParent.parent;
    }

    if (!actualParent) {
      throw new Error(translate('no parent for {element} in {parent}', {
        element: element.id,
        parent: newParent.id
      }));
    }

    return actualParent;
  }

  this.getOrdering = function(element, newParent) {

    // render labels always on top
    if (element.labelTarget) {
      return {
        parent: canvas.getRootElement(),
        index: -1
      };
    }

    var elementOrder = getOrder(element);


    if (elementOrder.containers) {
      newParent = findActualParent(element, newParent, elementOrder.containers);
    }


    var currentIndex = newParent.children.indexOf(element);

    var insertIndex = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.findIndex)(newParent.children, function(child) {

      // do not compare with labels, they are created
      // in the wrong order (right after elements) during import and
      // mess up the positioning.
      if (!element.labelTarget && child.labelTarget) {
        return false;
      }

      return elementOrder.level < getOrder(child).level;
    });


    // if the element is already in the child list at
    // a smaller index, we need to adjust the insert index.
    // this takes into account that the element is being removed
    // before being re-inserted
    if (insertIndex !== -1) {
      if (currentIndex !== -1 && currentIndex < insertIndex) {
        insertIndex -= 1;
      }
    }

    return {
      index: insertIndex,
      parent: newParent
    };
  };
}

PostitOrderingProvider.$inject = [ 'eventBus', 'canvas', 'translate' ];

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitOrderingProvider, diagram_js_lib_features_ordering_OrderingProvider__WEBPACK_IMPORTED_MODULE_1__.default);

/***/ }),

/***/ "./lib/features/ordering/index.js":
/*!****************************************!*\
  !*** ./lib/features/ordering/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/i18n/translate */ "./node_modules/diagram-js/lib/i18n/translate/index.js");
/* harmony import */ var _PostitOrderingProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitOrderingProvider */ "./lib/features/ordering/PostitOrderingProvider.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'postitOrderingProvider' ],
  postitOrderingProvider: [ 'type', _PostitOrderingProvider__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./lib/features/palette/PaletteProvider.js":
/*!*************************************************!*\
  !*** ./lib/features/palette/PaletteProvider.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PaletteProvider)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ColorUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ColorUtil */ "./lib/util/ColorUtil.js");





/**
 * A palette provider for postit elements.
 */
function PaletteProvider(
    palette, create, elementFactory,
    spaceTool, lassoTool, handTool, translate) {

  this._palette = palette;
  this._create = create;
  this._elementFactory = elementFactory;
  this._spaceTool = spaceTool;
  this._lassoTool = lassoTool;
  this._handTool = handTool;
  this._translate = translate;

  palette.registerProvider(this);
}

PaletteProvider.$inject = [
  'palette',
  'create',
  'elementFactory',
  'spaceTool',
  'lassoTool',
  'handTool',
  'translate'
];


PaletteProvider.prototype.getPaletteEntries = function(element) {

  var actions = {},
      create = this._create,
      elementFactory = this._elementFactory,
      spaceTool = this._spaceTool,
      lassoTool = this._lassoTool,
      handTool = this._handTool,
      translate = this._translate;

  function createAction(type, group, className, title, options) {

    function createListener(event) {
      var shape = elementFactory.createShape((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({ type: type }, options));
      create.start(event, shape);
    }

    var shortType = type.replace(/^postit:/, '');

    return {
      group: group,
      className: className,
      title: title || translate('Create {type}', { type: shortType }),
      action: {
        dragstart: createListener,
        click: createListener
      }
    };
  }

  function createImage(event) {
    var shape = elementFactory.createShape({
      type: 'postit:Image'
    });

    create.start(event, shape, {
      hints: { selectImage: true }
    });
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(actions, {
    'hand-tool': {
      group: 'tools',
      className: 'bpmn-icon-hand-tool',
      title: translate('Activate the hand tool'),
      action: {
        click: function(event) {
          handTool.activateHand(event);
        }
      }
    },
    'lasso-tool': {
      group: 'tools',
      className: 'bpmn-icon-lasso-tool',
      title: translate('Activate the lasso tool'),
      action: {
        click: function(event) {
          lassoTool.activateSelection(event);
        }
      }
    },
    'space-tool': {
      group: 'tools',
      className: 'bpmn-icon-space-tool',
      title: translate('Activate the create/remove space tool'),
      action: {
        click: function(event) {
          spaceTool.activateSelection(event);
        }
      }
    },
    'tool-separator': {
      group: 'tools',
      separator: true
    },
    'create.square-postit': createAction(
      'postit:SquarePostit', 'postits', 'pjs-postit-square',
      translate('Create Square Postit'), { color: _util_ColorUtil__WEBPACK_IMPORTED_MODULE_1__.default.YELLOW }
    ),
    'create.circle-postit': createAction(
      'postit:CirclePostit', 'postits', 'pjs-postit-circle',
      translate('Create Circle Postit'), { color: _util_ColorUtil__WEBPACK_IMPORTED_MODULE_1__.default.PINK }
    ),
    'postit-separator': {
      group: 'postits',
      separator: true
    },
    'create.image': {
      group: 'artifact',
      className: 'pjs-image',
      title: translate('Create Image'),
      action: {
        click: createImage,
        dragstart: createImage
      }
    },
    'create.text-box': createAction(
      'postit:TextBox', 'artifact', 'pjs-text-box',
      translate('Create Text')
    ),
    'create.group': createAction(
      'postit:Group', 'artifact', 'pjs-group',
      translate('Create Group')
    )
  });

  return actions;
};


/***/ }),

/***/ "./lib/features/palette/index.js":
/*!***************************************!*\
  !*** ./lib/features/palette/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/palette */ "./node_modules/diagram-js/lib/features/palette/index.js");
/* harmony import */ var diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/create */ "./node_modules/diagram-js/lib/features/create/index.js");
/* harmony import */ var diagram_js_lib_features_space_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/features/space-tool */ "./node_modules/diagram-js/lib/features/space-tool/index.js");
/* harmony import */ var diagram_js_lib_features_lasso_tool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/features/lasso-tool */ "./node_modules/diagram-js/lib/features/lasso-tool/index.js");
/* harmony import */ var diagram_js_lib_features_hand_tool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/features/hand-tool */ "./node_modules/diagram-js/lib/features/hand-tool/index.js");
/* harmony import */ var diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! diagram-js/lib/i18n/translate */ "./node_modules/diagram-js/lib/i18n/translate/index.js");
/* harmony import */ var _PaletteProvider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PaletteProvider */ "./lib/features/palette/PaletteProvider.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_palette__WEBPACK_IMPORTED_MODULE_0__.default,
    diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_1__.default,
    diagram_js_lib_features_space_tool__WEBPACK_IMPORTED_MODULE_2__.default,
    diagram_js_lib_features_lasso_tool__WEBPACK_IMPORTED_MODULE_3__.default,
    diagram_js_lib_features_hand_tool__WEBPACK_IMPORTED_MODULE_4__.default,
    diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_5__.default
  ],
  __init__: [ 'paletteProvider' ],
  paletteProvider: [ 'type', _PaletteProvider__WEBPACK_IMPORTED_MODULE_6__.default ]
});


/***/ }),

/***/ "./lib/features/popup-menu/ReplaceMenuProvider.js":
/*!********************************************************!*\
  !*** ./lib/features/popup-menu/ReplaceMenuProvider.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReplaceMenuProvider)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * This module is an element agnostic replace menu provider for the popup menu.
 */
function ReplaceMenuProvider(
    popupMenu, modeling, moddle,
    postitReplace, rules, translate) {

  this._popupMenu = popupMenu;
  this._modeling = modeling;
  this._moddle = moddle;
  this._postitReplace = postitReplace;
  this._rules = rules;
  this._translate = translate;

  this.register();
}

ReplaceMenuProvider.$inject = [
  'popupMenu',
  'modeling',
  'moddle',
  'postitReplace',
  'rules',
  'translate'
];


/**
 * Register replace menu provider in the popup menu
 */
ReplaceMenuProvider.prototype.register = function() {
  this._popupMenu.registerProvider('postit-replace', this);
};


/**
 * Get all entries from replaceOptions for the given element and apply filters
 * on them. Get for example only elements, which are different from the current one.
 *
 * @param {djs.model.Base} element
 *
 * @return {Array<Object>} a list of menu entry items
 */
ReplaceMenuProvider.prototype.getEntries = function(element) {

  var rules = this._rules;

  var entries = [];

  if (!rules.allowed('shape.replace', { element: element })) {
    return [];
  }

  return entries;
};


/**
 * Get a list of header items for the given element. This includes buttons
 * for multi instance markers and for the ad hoc marker.
 *
 * @param {djs.model.Base} element
 *
 * @return {Array<Object>} a list of menu entry items
 */
ReplaceMenuProvider.prototype.getHeaderEntries = function(element) {

  var headerEntries = [];

  return headerEntries;
};


/**
 * Creates an array of menu entry objects for a given element and filters the replaceOptions
 * according to a filter function.
 *
 * @param  {djs.model.Base} element
 * @param  {Object} replaceOptions
 *
 * @return {Array<Object>} a list of menu items
 */
ReplaceMenuProvider.prototype._createEntries = function(element, replaceOptions) {
  var menuEntries = [];

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(replaceOptions, function(definition) {
    var entry = self._createMenuEntry(definition, element);

    menuEntries.push(entry);
  });

  return menuEntries;
};


/**
 * Creates and returns a single menu entry item.
 *
 * @param  {Object} definition a single replace options definition object
 * @param  {djs.model.Base} element
 * @param  {Function} [action] an action callback function which gets called when
 *                             the menu entry is being triggered.
 *
 * @return {Object} menu entry item
 */
ReplaceMenuProvider.prototype._createMenuEntry = function(definition, element, action) {
  var translate = this._translate;
  var replaceElement = this._postitReplace.replaceElement;

  var replaceAction = function() {
    return replaceElement(element, definition.target);
  };

  action = action || replaceAction;

  var menuEntry = {
    label: translate(definition.label),
    className: definition.className,
    id: definition.actionName,
    action: action
  };

  return menuEntry;
};


/***/ }),

/***/ "./lib/features/popup-menu/index.js":
/*!******************************************!*\
  !*** ./lib/features/popup-menu/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_popup_menu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/popup-menu */ "./node_modules/diagram-js/lib/features/popup-menu/index.js");
/* harmony import */ var _replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../replace */ "./lib/features/replace/index.js");
/* harmony import */ var _ReplaceMenuProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReplaceMenuProvider */ "./lib/features/popup-menu/ReplaceMenuProvider.js");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_popup_menu__WEBPACK_IMPORTED_MODULE_0__.default,
    _replace__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [ 'replaceMenuProvider' ],
  replaceMenuProvider: [ 'type', _ReplaceMenuProvider__WEBPACK_IMPORTED_MODULE_2__.default ]
});

/***/ }),

/***/ "./lib/features/replace-preview/PostitReplacePreview.js":
/*!**************************************************************!*\
  !*** ./lib/features/replace-preview/PostitReplacePreview.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitReplacePreview)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var css_escape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! css.escape */ "./node_modules/css.escape/css.escape.js");
/* harmony import */ var css_escape__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(css_escape__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");












var LOW_PRIORITY = 250;


function PostitReplacePreview(
    eventBus, elementRegistry, elementFactory,
    canvas, previewSupport) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_2__.default.call(this, eventBus);

  /**
   * Replace the visuals of all elements in the context which can be replaced
   *
   * @param  {Object} context
   */
  function replaceVisual(context) {

    var replacements = context.canExecute.replacements;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(replacements, function(replacement) {

      var id = replacement.oldElementId;

      var newElement = {
        type: replacement.newElementType
      };

      // if the visual of the element is already replaced
      if (context.visualReplacements[id]) {
        return;
      }

      var element = elementRegistry.get(id);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)(newElement, { x: element.x, y: element.y });

      // create a temporary shape
      var tempShape = elementFactory.createShape(newElement);

      canvas.addShape(tempShape, element.parent);

      // select the original SVG element related to the element and hide it
      var gfx = (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.query)('[data-element-id="' + css_escape__WEBPACK_IMPORTED_MODULE_1___default()(element.id) + '"]', context.dragGroup);

      if (gfx) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_5__.attr)(gfx, { display: 'none' });
      }

      // clone the gfx of the temporary shape and add it to the drag group
      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);

      context.visualReplacements[id] = dragger;

      canvas.removeShape(tempShape);
    });
  }

  /**
   * Restore the original visuals of the previously replaced elements
   *
   * @param  {Object} context
   */
  function restoreVisual(context) {

    var visualReplacements = context.visualReplacements;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(visualReplacements, function(dragger, id) {

      var originalGfx = (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.query)('[data-element-id="' + css_escape__WEBPACK_IMPORTED_MODULE_1___default()(id) + '"]', context.dragGroup);

      if (originalGfx) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_5__.attr)(originalGfx, { display: 'inline' });
      }

      dragger.remove();

      if (visualReplacements[id]) {
        delete visualReplacements[id];
      }
    });
  }

  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {

    var context = event.context,
        canExecute = context.canExecute;

    if (!context.visualReplacements) {
      context.visualReplacements = {};
    }

    if (canExecute && canExecute.replacements) {
      replaceVisual(context);
    } else {
      restoreVisual(context);
    }
  });
}

PostitReplacePreview.$inject = [
  'eventBus',
  'elementRegistry',
  'elementFactory',
  'canvas',
  'previewSupport'
];

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitReplacePreview, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_2__.default);

/***/ }),

/***/ "./lib/features/replace-preview/index.js":
/*!***********************************************!*\
  !*** ./lib/features/replace-preview/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_preview_support__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/preview-support */ "./node_modules/diagram-js/lib/features/preview-support/index.js");
/* harmony import */ var _PostitReplacePreview__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitReplacePreview */ "./lib/features/replace-preview/PostitReplacePreview.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_preview_support__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'postitReplacePreview' ],
  postitReplacePreview: [ 'type', _PostitReplacePreview__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./lib/features/replace/PostitReplace.js":
/*!***********************************************!*\
  !*** ./lib/features/replace/PostitReplace.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitReplace)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _copy_paste_ModdleCopy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../copy-paste/ModdleCopy */ "./lib/features/copy-paste/ModdleCopy.js");




function copyProperties(source, target, properties) {
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(properties)) {
    properties = [ properties ];
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(properties, function(property) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(source[property])) {
      target[property] = source[property];
    }
  });
}

var CUSTOM_PROPERTIES = [
  'cancelActivity',
  'instantiate',
  'eventGatewayType',
  'triggeredByEvent',
  'isInterrupting'
];



/**
 * This module takes care of replacing postit elements
 */
function PostitReplace(
    postitFactory,
    elementFactory,
    moddleCopy,
    modeling,
    replace,
    selection
) {

  /**
   * Prepares a new business object for the replacement element
   * and triggers the replace operation.
   *
   * @param  {djs.model.Base} element
   * @param  {Object} target
   * @param  {Object} [hints]
   *
   * @return {djs.model.Base} the newly created element
   */
  function replaceElement(element, target, hints) {

    hints = hints || {};

    var type = target.type,
        oldBusinessObject = element.businessObject;

    var newBusinessObject = postitFactory.create(type);

    var newElement = {
      type: type,
      businessObject: newBusinessObject
    };

    var elementProps = (0,_copy_paste_ModdleCopy__WEBPACK_IMPORTED_MODULE_1__.getPropertyNames)(oldBusinessObject.$descriptor),
        newElementProps = (0,_copy_paste_ModdleCopy__WEBPACK_IMPORTED_MODULE_1__.getPropertyNames)(newBusinessObject.$descriptor, true),
        copyProps = intersection(elementProps, newElementProps);

    // initialize special properties defined in target definition
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(newBusinessObject, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.pick)(target, CUSTOM_PROPERTIES));

    var properties = copyProps;

    newBusinessObject = moddleCopy.copyElement(
      oldBusinessObject,
      newBusinessObject,
      properties
    );

    newBusinessObject.name = oldBusinessObject.name;

    newElement.di = {};

    // fill and stroke will be set to DI
    copyProperties(oldBusinessObject.di, newElement.di, [
      'fill',
      'stroke'
    ]);

    newElement = replace.replaceElement(element, newElement, hints);

    if (hints.select !== false) {
      selection.select(newElement);
    }

    return newElement;
  }

  this.replaceElement = replaceElement;
}

PostitReplace.$inject = [
  'postitFactory',
  'elementFactory',
  'moddleCopy',
  'modeling',
  'replace',
  'selection'
];

/**
 * Compute intersection between two arrays.
 */
function intersection(a1, a2) {
  return a1.filter(function(el) {
    return a2.indexOf(el) !== -1;
  });
}


/***/ }),

/***/ "./lib/features/replace/index.js":
/*!***************************************!*\
  !*** ./lib/features/replace/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copy_paste__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../copy-paste */ "./lib/features/copy-paste/index.js");
/* harmony import */ var diagram_js_lib_features_replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/replace */ "./node_modules/diagram-js/lib/features/replace/index.js");
/* harmony import */ var diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/features/selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _PostitReplace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PostitReplace */ "./lib/features/replace/PostitReplace.js");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _copy_paste__WEBPACK_IMPORTED_MODULE_0__.default,
    diagram_js_lib_features_replace__WEBPACK_IMPORTED_MODULE_1__.default,
    diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_2__.default
  ],
  postitReplace: [ 'type', _PostitReplace__WEBPACK_IMPORTED_MODULE_3__.default ]
});


/***/ }),

/***/ "./lib/features/rules/PostitRules.js":
/*!*******************************************!*\
  !*** ./lib/features/rules/PostitRules.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitRules)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/LabelUtil */ "./lib/util/LabelUtil.js");
/* harmony import */ var diagram_js_lib_features_rules_RuleProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/rules/RuleProvider */ "./node_modules/diagram-js/lib/features/rules/RuleProvider.js");
/* harmony import */ var _modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../modeling/util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");












/**
 * Postit specific modeling rule
 */
function PostitRules(eventBus) {
  diagram_js_lib_features_rules_RuleProvider__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitRules, diagram_js_lib_features_rules_RuleProvider__WEBPACK_IMPORTED_MODULE_1__.default);

PostitRules.$inject = [ 'eventBus' ];

PostitRules.prototype.init = function() {

  this.addRule('shape.resize', function(context) {

    var shape = context.shape,
        newBounds = context.newBounds;

    return canResize(shape, newBounds);
  });

  this.addRule('elements.create', function(context) {
    var elements = context.elements,
        position = context.position,
        target = context.target;

    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.every)(elements, function(element) {
      if (element.host) {
        return canAttach(element, element.host, null, position);
      }

      return canCreate(element, target, null, position);
    });
  });

  this.addRule('elements.move', function(context) {

    var target = context.target,
        shapes = context.shapes,
        position = context.position;

    return canAttach(shapes, target, null, position) ||
           canMove(shapes, target, position);
  });

  this.addRule('shape.create', function(context) {
    return canCreate(
      context.shape,
      context.target,
      context.source,
      context.position
    );
  });

  this.addRule('shape.attach', function(context) {

    return canAttach(
      context.shape,
      context.target,
      null,
      context.position
    );
  });

  this.addRule('element.copy', function(context) {
    var element = context.element,
        elements = context.elements;

    return canCopy(elements, element);
  });
};

PostitRules.prototype.canMove = canMove;

PostitRules.prototype.canAttach = canAttach;

PostitRules.prototype.canDrop = canDrop;

PostitRules.prototype.canCreate = canCreate;

PostitRules.prototype.canReplace = canReplace;

PostitRules.prototype.canResize = canResize;

PostitRules.prototype.canCopy = canCopy;

/**
 * Utility functions for rule checking
 */

function isSame(a, b) {
  return a === b;
}

function getParents(element) {

  var parents = [];

  while (element) {
    element = element.parent;

    if (element) {
      parents.push(element);
    }
  }

  return parents;
}

function isParent(possibleParent, element) {
  var allParents = getParents(element);
  return allParents.indexOf(possibleParent) !== -1;
}

function isGroup(element) {
  return (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(element, 'postit:Group') && !element.labelTarget;
}

/**
 * Can an element be dropped into the target element
 *
 * @return {Boolean}
 */
function canDrop(element, target) {

  // can move labels
  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.isLabel)(element) || isGroup(element)) {
    return true;
  }

  // drop board elements onto boards
  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(element, 'postit:BoardElement') && (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(target, 'postit:PostitBoard')) {
    return true;
  }

  return false;
}

function canReplace(elements, target) {

  if (!target) {
    return false;
  }

  return true;
}


function canAttach(elements, target) {

  if (!Array.isArray(elements)) {
    elements = [ elements ];
  }

  // only (re-)attach one element at a time
  if (elements.length !== 1) {
    return false;
  }

  var element = elements[0];

  // do not attach labels
  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.isLabel)(element)) {
    return false;
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(target, 'postit:BoardElement')) {
    return false;
  }

  return 'attach';
}


function canMove(elements, target) {

  // allow default move check to start move operation
  if (!target) {
    return true;
  }

  return elements.every(function(element) {
    return canDrop(element, target);
  });
}

function canCreate(shape, target, source, position) {

  if (!target) {
    return false;
  }

  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.isLabel)(shape) || isGroup(shape)) {
    return true;
  }

  if (isSame(source, target)) {
    return false;
  }

  // ensure we do not drop the element
  // into source
  if (source && isParent(source, target)) {
    return false;
  }

  return canDrop(shape, target, position);
}

function canResize(shape, newBounds) {

  if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_5__.isAny)(shape, [ 'postit:Postit', 'postit:TextBox' ])) {
    return !newBounds || (newBounds.width >= 50 && newBounds.height >= 50);
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(shape, 'postit:Group')) {
    return true;
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(shape, 'postit:Image')) {
    return true;
  }

  return false;
}

function canCopy(elements, element) {
  return true;
}


/***/ }),

/***/ "./lib/features/rules/index.js":
/*!*************************************!*\
  !*** ./lib/features/rules/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_rules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _PostitRules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitRules */ "./lib/features/rules/PostitRules.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_rules__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'postitRules' ],
  postitRules: [ 'type', _PostitRules__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./lib/features/snapping/PostitCreateMoveSnapping.js":
/*!***********************************************************!*\
  !*** ./lib/features/snapping/PostitCreateMoveSnapping.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitCreateMoveSnapping)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/snapping/CreateMoveSnapping */ "./node_modules/diagram-js/lib/features/snapping/CreateMoveSnapping.js");




/**
 * Snap during create and move.
 *
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */
function PostitCreateMoveSnapping(injector) {
  injector.invoke(diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default, this);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitCreateMoveSnapping, diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default);

PostitCreateMoveSnapping.$inject = [
  'injector'
];

PostitCreateMoveSnapping.prototype.initSnap = function(event) {
  return diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default.prototype.initSnap.call(this, event);
};

PostitCreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  return diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);
};

PostitCreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default.prototype.getSnapTargets.call(this, shape, target);
};


/***/ }),

/***/ "./lib/features/snapping/index.js":
/*!****************************************!*\
  !*** ./lib/features/snapping/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PostitCreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitCreateMoveSnapping */ "./lib/features/snapping/PostitCreateMoveSnapping.js");
/* harmony import */ var diagram_js_lib_features_snapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/snapping */ "./node_modules/diagram-js/lib/features/snapping/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [ diagram_js_lib_features_snapping__WEBPACK_IMPORTED_MODULE_0__.default ],
  __init__: [
    'createMoveSnapping'
  ],
  createMoveSnapping: [ 'type', _PostitCreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./lib/import/Importer.js":
/*!********************************!*\
  !*** ./lib/import/Importer.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "importPostitDiagram": () => (/* binding */ importPostitDiagram)
/* harmony export */ });
/* harmony import */ var _PostitTreeWalker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PostitTreeWalker */ "./lib/import/PostitTreeWalker.js");


/**
 * The importPostitDiagram result.
 *
 * @typedef {Object} importPostitDiagramResult
 *
 * @property {Array<string>} warnings
 */

/**
* The importPostitDiagram error.
*
* @typedef {Error} importPostitDiagramError
*
* @property {Array<string>} warnings
*/

/**
 * Import the definitions into a diagram.
 *
 * Errors and warnings are reported through the specified callback.
 *
 * @param  {djs.Diagram} diagram
 * @param  {ModdleElement<Definitions>} definitions
 * @param  {ModdleElement<PotitRootBoard>} [rootBoard] the diagram to be rendered
 * (if not provided, the first one will be rendered)
 *
 * Returns {Promise<importPostitDiagramResult, importPostitDiagramError>}
 */
function importPostitDiagram(diagram, definitions, rootBoard) {

  var importer,
      eventBus,
      translate;

  var error,
      warnings = [];

  /**
   * Walk the diagram semantically, importing (=drawing)
   * all elements you encounter.
   *
   * @param {ModdleElement<Definitions>} definitions
   * @param {ModdleElement<PostitRootBoard>} rootBoard
   */
  function render(definitions, rootBoard) {

    var visitor = {

      root: function(element) {
        return importer.add(element);
      },

      element: function(element, parentShape) {
        return importer.add(element, parentShape);
      },

      error: function(message, context) {
        warnings.push({ message: message, context: context });
      }
    };

    var walker = new _PostitTreeWalker__WEBPACK_IMPORTED_MODULE_0__.default(visitor, translate);

    // traverse xml document model,
    // starting at definitions
    walker.handleDefinitions(definitions, rootBoard);
  }

  return new Promise(function(resolve, reject) {
    try {
      importer = diagram.get('postitImporter');
      eventBus = diagram.get('eventBus');
      translate = diagram.get('translate');

      eventBus.fire('import.render.start', { definitions: definitions });

      render(definitions, rootBoard);

      eventBus.fire('import.render.complete', {
        error: error,
        warnings: warnings
      });

      return resolve({ warnings: warnings });
    } catch (e) {
      return reject(e);
    }
  });
}

/***/ }),

/***/ "./lib/import/PostitImporter.js":
/*!**************************************!*\
  !*** ./lib/import/PostitImporter.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitImporter)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/LabelUtil */ "./lib/util/LabelUtil.js");
/* harmony import */ var _features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../features/label-editing/LabelUtil */ "./lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Util */ "./lib/import/Util.js");











function elementData(semantic, attrs) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
    id: semantic.id,
    type: semantic.$type,
    businessObject: semantic
  }, attrs);
}

function notYetDrawn(translate, semantic, refSemantic, property) {
  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {
    element: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(refSemantic),
    referenced: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(semantic),
    property: property
  }));
}


/**
 * An importer that adds postit elements to the canvas
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {ElementFactory} elementFactory
 * @param {ElementRegistry} elementRegistry
 * @param {Function} translate
 * @param {TextRenderer} textRenderer
 */
function PostitImporter(
    eventBus, canvas, elementFactory,
    elementRegistry, translate, textRenderer) {

  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementFactory = elementFactory;
  this._elementRegistry = elementRegistry;
  this._translate = translate;
  this._textRenderer = textRenderer;
}

PostitImporter.$inject = [
  'eventBus',
  'canvas',
  'elementFactory',
  'elementRegistry',
  'translate',
  'textRenderer'
];


/**
 * Add postit element (semantic) to the canvas onto the
 * specified parent shape.
 */
PostitImporter.prototype.add = function(semantic, parentElement) {

  var di = semantic.di,
      element,
      translate = this._translate,
      hidden;

  var parentIndex;

  // ROOT ELEMENT
  // handle the special case that we deal with a
  // invisible root element
  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(di, 'postitDi:PostitPlane')) {

    // add a virtual element (not being drawn)
    element = this._elementFactory.createRoot(elementData(semantic));

    this._canvas.setRootElement(element);
  }

  // SHAPE
  else if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(di, 'postitDi:PostitShape')) {

    var isFrame = isFrameElement(semantic);

    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);

    var bounds = semantic.di.bounds;

    element = this._elementFactory.createShape(elementData(semantic, {
      hidden: hidden,
      x: Math.round(bounds.x),
      y: Math.round(bounds.y),
      width: Math.round(bounds.width),
      height: Math.round(bounds.height),
      isFrame: isFrame
    }));

    this._canvas.addShape(element, parentElement, parentIndex);
  }

  else {
    throw new Error(translate('unknown di {di} for element {semantic}', {
      di: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(di),
      semantic: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(semantic)
    }));
  }

  // (optional) LABEL
  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.isLabelExternal)(semantic) && (0,_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.getLabel)(element)) {
    this.addLabel(semantic, element);
  }


  this._eventBus.fire('boardElement.added', { element: element });

  return element;
};


/**
 * Attach the boundary element to the given host
 *
 * @param {ModdleElement} boundarySemantic
 * @param {djs.model.Base} boundaryElement
 */
PostitImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {
  var translate = this._translate;
  var hostSemantic = boundarySemantic.attachedToRef;

  if (!hostSemantic) {
    throw new Error(translate('missing {semantic}#attachedToRef', {
      semantic: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(boundarySemantic)
    }));
  }

  var host = this._elementRegistry.get(hostSemantic.id),
      attachers = host && host.attachers;

  if (!host) {
    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');
  }

  // wire element.host <> host.attachers
  boundaryElement.host = host;

  if (!attachers) {
    host.attachers = attachers = [];
  }

  if (attachers.indexOf(boundaryElement) === -1) {
    attachers.push(boundaryElement);
  }
};


/**
 * add label for an element
 */
PostitImporter.prototype.addLabel = function(semantic, element) {
  var bounds,
      text,
      label;

  bounds = (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.getExternalLabelBounds)(semantic, element);

  text = (0,_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.getLabel)(element);

  if (text) {

    // get corrected bounds from actual layouted text
    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);
  }

  label = this._elementFactory.createLabel(elementData(semantic, {
    id: semantic.id + '_label',
    labelTarget: element,
    type: 'label',
    hidden: element.hidden || !(0,_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.getLabel)(element),
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  }));

  return this._canvas.addShape(label, element.parent);
};

/**
 * Return the drawn connection end based on the given side.
 *
 * @throws {Error} if the end is not yet drawn
 */
PostitImporter.prototype._getEnd = function(semantic, side) {

  var element,
      refSemantic,
      translate = this._translate;

  refSemantic = semantic[side + 'Ref'];


  element = refSemantic && this._getElement(refSemantic);

  if (element) {
    return element;
  }

  if (refSemantic) {
    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');
  } else {
    throw new Error(translate('{semantic}#{side} Ref not specified', {
      semantic: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(semantic),
      side: side
    }));
  }
};

PostitImporter.prototype._getSource = function(semantic) {
  return this._getEnd(semantic, 'source');
};

PostitImporter.prototype._getTarget = function(semantic) {
  return this._getEnd(semantic, 'target');
};


PostitImporter.prototype._getElement = function(semantic) {
  return this._elementRegistry.get(semantic.id);
};


// helpers //////////

function isFrameElement(semantic) {
  return (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(semantic, 'postit:Group');
}

/***/ }),

/***/ "./lib/import/PostitTreeWalker.js":
/*!****************************************!*\
  !*** ./lib/import/PostitTreeWalker.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitTreeWalker)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! object-refs */ "./node_modules/object-refs/index.js");
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_refs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Util */ "./lib/import/Util.js");






var diRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_0___default())(
  { name: 'boardElement', enumerable: true },
  { name: 'di', configurable: true }
);

/**
 * Returns true if an element has the given meta-model type
 *
 * @param  {ModdleElement}  element
 * @param  {String}         type
 *
 * @return {Boolean}
 */
function is(element, type) {
  return element.$instanceOf(type);
}


/**
 * Find a suitable display candidate for definitions where the DI does not
 * correctly specify one.
 */
function findDisplayCandidate(definitions) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(definitions.rootElements, function(e) {
    return is(e, 'postit:PostitBoard');
  });
}


function PostitTreeWalker(handler, translate) {

  // list of containers already walked
  var handledElements = {};

  // list of elements to handle deferred to ensure
  // prerequisites are drawn
  var deferred = [];

  // Helpers //////////////////////

  function visitRoot(element, diagram) {
    return handler.root(element, diagram);
  }

  function visit(element, ctx) {

    var gfx = element.gfx;

    // avoid multiple rendering of elements
    if (gfx) {
      throw new Error(
        translate('already rendered {element}', { element: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(element) })
      );
    }

    // call handler
    return handler.element(element, ctx);
  }

  function visitIfDi(element, ctx) {

    try {
      var gfx = element.di && visit(element, ctx);

      handled(element);

      return gfx;
    } catch (e) {
      logError(e.message, { element: element, error: e });

      console.error(translate('failed to import {element}', { element: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(element) }));
      console.error(e);
    }
  }

  function logError(message, context) {
    handler.error(message, context);
  }

  function handled(element) {
    handledElements[element.id] = element;
  }

  // DI handling //////////////////////

  function registerDi(di) {
    var boardElement = di.boardElement;

    if (boardElement) {
      if (boardElement.di) {
        logError(
          translate('multiple DI elements defined for {element}', {
            element: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(boardElement)
          }),
          { element: boardElement }
        );
      } else {
        diRefs.bind(boardElement, 'di');
        boardElement.di = di;
      }
    } else {
      logError(
        translate('no boardElement referenced in {element}', {
          element: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(di)
        }),
        { element: di }
      );
    }
  }

  function handleBoard(diagram) {
    handlePlane(diagram.plane);
  }

  function handlePlane(plane) {
    registerDi(plane);

    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(plane.planeElement, handlePlaneElement);
  }

  function handlePlaneElement(planeElement) {
    registerDi(planeElement);
  }


  // Semantic handling //////////////////////

  /**
   * Handle definitions and return the rendered board (if any)
   *
   * @param {ModdleElement} definitions to walk and import
   * @param {ModdleElement} [rootBoard] specific board to import and display
   *
   * @throws {Error} if no diagram to display could be found
   */
  function handleDefinitions(definitions, rootBoard) {

    // make sure we walk the correct boardElement

    var rootBoards = definitions.rootBoards;

    if (rootBoard && rootBoards.indexOf(rootBoard) === -1) {
      throw new Error(translate('rootBoard not part of postit:Definitions'));
    }

    if (!rootBoard && rootBoards && rootBoards.length) {
      rootBoard = rootBoards[0];
    }

    // no root board -> nothing to import
    if (!rootBoard) {
      throw new Error(translate('no rootBoard to display'));
    }

    // load DI from selected root board only
    handleBoard(rootBoard);

    var plane = rootBoard.plane;

    if (!plane) {
      throw new Error(translate(
        'no plane for {element}',
        { element: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(rootBoard) }
      ));
    }

    var rootElement = plane.boardElement;

    // ensure we default to a suitable display candidate (board),
    // even if non is specified in DI
    if (!rootElement) {
      rootElement = findDisplayCandidate(definitions);

      if (!rootElement) {
        throw new Error(translate('no board to display'));
      } else {

        logError(
          translate('correcting missing boardElement on {plane} to {rootElement}', {
            plane: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(plane),
            rootElement: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(rootElement)
          })
        );

        // correct DI on the fly
        plane.boardElement = rootElement;
        registerDi(plane);
      }
    }


    var ctx = visitRoot(rootElement, plane);

    if (is(rootElement, 'postit:PostitBoard')) {
      handlePostitBoard(rootElement, ctx);
    }

    // handle all deferred elements
    handleDeferred(deferred);
  }

  function handleBoardElements(boardElements, context) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(boardElements, function(element) {
      visitIfDi(element, context);
    });
  }

  function handlePostitBoard(board, context) {
    handleBoardElements(board.boardElements, context);

    // log board handled
    handled(board);
  }

  function handleDeferred() {

    var fn;

    // drain deferred until empty
    while (deferred.length) {
      fn = deferred.shift();

      fn();
    }
  }




  // API //////////////////////

  return {
    handleDeferred: handleDeferred,
    handleDefinitions: handleDefinitions,
    registerDi: registerDi
  };
}

/***/ }),

/***/ "./lib/import/Util.js":
/*!****************************!*\
  !*** ./lib/import/Util.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "elementToString": () => (/* binding */ elementToString)
/* harmony export */ });
function elementToString(e) {
  if (!e) {
    return '<null>';
  }

  return '<' + e.$type + (e.id ? ' id="' + e.id : '') + '" />';
}

/***/ }),

/***/ "./lib/import/index.js":
/*!*****************************!*\
  !*** ./lib/import/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/i18n/translate */ "./node_modules/diagram-js/lib/i18n/translate/index.js");
/* harmony import */ var _PostitImporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitImporter */ "./lib/import/PostitImporter.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  postitImporter: [ 'type', _PostitImporter__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Modeler = __webpack_require__(/*! ./Modeler */ "./lib/Modeler.js");

module.exports = Modeler;


/***/ }),

/***/ "./lib/moddle/Moddle.js":
/*!******************************!*\
  !*** ./lib/moddle/Moddle.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitModdle)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var moddle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moddle */ "./node_modules/moddle/dist/index.esm.js");
/* harmony import */ var moddle_xml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moddle-xml */ "./node_modules/moddle-xml/dist/index.esm.js");






/**
 * A sub class of {@link Moddle} with support for import and export of Postit-js xml files.
 *
 * @class PostitModdle
 *
 * @extends Moddle
 *
 * @param {Object|Array} packages to use for instantiating the model
 * @param {Object} [options] additional options to pass over
 */
function PostitModdle(packages, options) {
  moddle__WEBPACK_IMPORTED_MODULE_0__.Moddle.call(this, packages, options);
}

PostitModdle.prototype = Object.create(moddle__WEBPACK_IMPORTED_MODULE_0__.Moddle.prototype);

/**
 * The fromXML result.
 *
 * @typedef {Object} ParseResult
 *
 * @property {ModdleElement} rootElement
 * @property {Array<Object>} references
 * @property {Array<Error>} warnings
 * @property {Object} elementsById - a mapping containing each ID -> ModdleElement
 */

/**
 * The fromXML error.
 *
 * @typedef {Error} ParseError
 *
 * @property {Array<Error>} warnings
 */

/**
 * Instantiates a Postit model tree from a given xml string.
 *
 * @param {String}   xmlStr
 * @param {String}   [typeName='postit:Definitions'] name of the root element
 * @param {Object}   [options]  options to pass to the underlying reader
 *
 * @returns {Promise<ParseResult, ParseError>}
 */
PostitModdle.prototype.fromXML = function(xmlStr, typeName, options) {
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isString)(typeName)) {
    options = typeName;
    typeName = 'postit:Definitions';
  }

  var reader = new moddle_xml__WEBPACK_IMPORTED_MODULE_2__.Reader((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({ model: this, lax: true }, options));
  var rootHandler = reader.handler(typeName);

  return reader.fromXML(xmlStr, rootHandler);
};

/**
 * The toXML result.
 *
 * @typedef {Object} SerializationResult
 *
 * @property {String} xml
 */

/**
 * Serializes a Postit object tree to XML.
 *
 * @param {String}   element    the root element, typically an instance of `postit:Definitions`
 * @param {Object}   [options]  to pass to the underlying writer
 *
 * @returns {Promise<SerializationResult, Error>}
 */
PostitModdle.prototype.toXML = function(element, options) {
  var writer = new moddle_xml__WEBPACK_IMPORTED_MODULE_2__.Writer(options);

  return new Promise(function(resolve, reject) {
    try {
      var result = writer.toXML(element);

      return resolve({
        xml: result
      });
    } catch (err) {
      return reject(err);
    }
  });
};


/***/ }),

/***/ "./lib/moddle/index.js":
/*!*****************************!*\
  !*** ./lib/moddle/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _Moddle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Moddle */ "./lib/moddle/Moddle.js");
/* harmony import */ var _resources_postit_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resources/postit.json */ "./lib/moddle/resources/postit.json");
/* harmony import */ var _resources_postitDi_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources/postitDi.json */ "./lib/moddle/resources/postitDi.json");
/* harmony import */ var _resources_dc_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resources/dc.json */ "./lib/moddle/resources/dc.json");









var packages = {
  postit: _resources_postit_json__WEBPACK_IMPORTED_MODULE_0__,
  postitDi: _resources_postitDi_json__WEBPACK_IMPORTED_MODULE_1__,
  dc: _resources_dc_json__WEBPACK_IMPORTED_MODULE_2__,
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(additionalPackages, options) {
  var pks = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)({}, packages, additionalPackages);

  return new _Moddle__WEBPACK_IMPORTED_MODULE_4__.default(pks, options);
}


/***/ }),

/***/ "./lib/moddle/resources/dc.json":
/*!**************************************!*\
  !*** ./lib/moddle/resources/dc.json ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"dc","uri":"http://www.omg.org/spec/DD/20100524/DC","prefix":"dc","types":[{"name":"Boolean"},{"name":"Integer"},{"name":"Real"},{"name":"String"},{"name":"Font","properties":[{"name":"name","type":"String","isAttr":true},{"name":"size","type":"Real","isAttr":true},{"name":"isBold","type":"Boolean","isAttr":true},{"name":"isItalic","type":"Boolean","isAttr":true},{"name":"isUnderline","type":"Boolean","isAttr":true},{"name":"isStrikeThrough","type":"Boolean","isAttr":true}]},{"name":"Point","properties":[{"name":"x","type":"Real","default":"0","isAttr":true},{"name":"y","type":"Real","default":"0","isAttr":true}]},{"name":"Bounds","properties":[{"name":"x","type":"Real","default":"0","isAttr":true},{"name":"y","type":"Real","default":"0","isAttr":true},{"name":"width","type":"Real","isAttr":true},{"name":"height","type":"Real","isAttr":true}]}],"associations":[]}');

/***/ }),

/***/ "./lib/moddle/resources/postit.json":
/*!******************************************!*\
  !*** ./lib/moddle/resources/postit.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"Postit","uri":"http://some-company/schema/postit","prefix":"postit","xml":{"tagAlias":"lowerCase"},"types":[{"name":"BoardElement","isAbstract":true,"properties":[{"name":"name","isAttr":true,"type":"String"},{"name":"id","isAttr":true,"type":"String","isId":true}]},{"name":"PostitBoard","superClass":["RootElement"],"properties":[{"name":"boardElements","isMany":true,"type":"BoardElement"}]},{"name":"Postit","superClass":["BoardElement"],"properties":[{"name":"color","isAttr":true,"type":"String"}]},{"name":"SquarePostit","superClass":["Postit"]},{"name":"CirclePostit","superClass":["Postit"]},{"name":"TextBox","superClass":["BoardElement"]},{"name":"Group","superClass":["BoardElement"]},{"name":"Image","superClass":["BoardElement"],"properties":[{"name":"source","isAttr":true,"type":"String"}]},{"name":"RootElement","isAbstract":true,"superClass":["BoardElement"]},{"name":"Definitions","superClass":["BoardElement"],"properties":[{"name":"targetNamespace","isAttr":true,"type":"String"},{"name":"expressionLanguage","default":"http://www.w3.org/1999/XPath","isAttr":true,"type":"String"},{"name":"typeLanguage","default":"http://www.w3.org/2001/XMLSchema","isAttr":true,"type":"String"},{"name":"rootElements","type":"RootElement","isMany":true},{"name":"rootBoards","isMany":true,"type":"postitDi:PostitRootBoard"},{"name":"exporter","isAttr":true,"type":"String"},{"name":"exporterVersion","isAttr":true,"type":"String"}]}]}');

/***/ }),

/***/ "./lib/moddle/resources/postitDi.json":
/*!********************************************!*\
  !*** ./lib/moddle/resources/postitDi.json ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"POSTITDI","uri":"http://some-company/schema/postitdi","prefix":"postitDi","xml":{"tagAlias":"lowerCase"},"types":[{"name":"PostitRootBoard","properties":[{"name":"plane","type":"PostitPlane","redefines":"Board#rootElement"},{"name":"labelStyle","type":"PostitLabelStyle","isMany":true}],"superClass":["Board"]},{"name":"PostitPlane","properties":[{"name":"boardElement","isAttr":true,"isReference":true,"type":"postit:BoardElement","redefines":"BoardElement#modelElement"}],"superClass":["Plane"]},{"name":"PostitShape","properties":[{"name":"boardElement","isAttr":true,"isReference":true,"type":"postit:BoardElement","redefines":"BoardElement#modelElement"},{"name":"label","type":"PostitLabel"}],"superClass":["LabeledShape"]},{"name":"PostitLabel","properties":[{"name":"labelStyle","type":"PostitLabelStyle","isAttr":true,"isReference":true,"redefines":"BoardElement#style"}],"superClass":["Label"]},{"name":"PostitLabelStyle","properties":[{"name":"font","type":"dc:Font"}],"superClass":["Style"]},{"name":"BoardElement","isAbstract":true,"properties":[{"name":"id","isAttr":true,"isId":true,"type":"String"},{"name":"owningBoard","type":"Board","isReadOnly":true,"isVirtual":true,"isReference":true},{"name":"owningElement","type":"BoardElement","isReadOnly":true,"isVirtual":true,"isReference":true},{"name":"modelElement","isReadOnly":true,"isVirtual":true,"isReference":true,"type":"Element"},{"name":"style","type":"Style","isReadOnly":true,"isVirtual":true,"isReference":true}]},{"name":"Node","isAbstract":true,"superClass":["BoardElement"]},{"name":"Board","isAbstract":true,"properties":[{"name":"id","isAttr":true,"isId":true,"type":"String"},{"name":"rootElement","type":"BoardElement","isReadOnly":true,"isVirtual":true},{"name":"name","isAttr":true,"type":"String"},{"name":"resolution","isAttr":true,"type":"Real"},{"name":"ownedStyle","type":"Style","isReadOnly":true,"isMany":true,"isVirtual":true}]},{"name":"Shape","isAbstract":true,"superClass":["Node"],"properties":[{"name":"bounds","type":"dc:Bounds"}]},{"name":"Plane","isAbstract":true,"superClass":["Node"],"properties":[{"name":"planeElement","type":"BoardElement","subsettedProperty":"BoardElement-ownedElement","isMany":true}]},{"name":"LabeledEdge","isAbstract":true,"superClass":["Edge"],"properties":[{"name":"ownedLabel","type":"Label","isReadOnly":true,"subsettedProperty":"BoardElement-ownedElement","isMany":true,"isVirtual":true}]},{"name":"LabeledShape","isAbstract":true,"superClass":["Shape"],"properties":[{"name":"ownedLabel","type":"Label","isReadOnly":true,"subsettedProperty":"BoardElement-ownedElement","isMany":true,"isVirtual":true}]},{"name":"Label","isAbstract":true,"superClass":["Node"],"properties":[{"name":"bounds","type":"dc:Bounds"}]},{"name":"Style","isAbstract":true,"properties":[{"name":"id","isAttr":true,"isId":true,"type":"String"}]},{"name":"Extension","properties":[{"name":"values","isMany":true,"type":"Element"}]}],"enumerations":[],"associations":[]}');

/***/ }),

/***/ "./lib/util/ColorUtil.js":
/*!*******************************!*\
  !*** ./lib/util/ColorUtil.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  YELLOW: '#FFFF88',
  GREEN: '#7EC845',
  PINK: '#F46F60',
  ICE_BLUE: '#B8D6F7',
  BLUE: '#23BFE7',
  ORANGE: '#FF9D48',
  BLACK: 'black'
});


/***/ }),

/***/ "./lib/util/FileUtil.js":
/*!******************************!*\
  !*** ./lib/util/FileUtil.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fileToDataURL": () => (/* binding */ fileToDataURL),
/* harmony export */   "imageProcessor": () => (/* binding */ imageProcessor),
/* harmony export */   "fileReader": () => (/* binding */ fileReader)
/* harmony export */ });
function fileToDataURL(file) {
  return new Promise((resolve, reject) => {
    try {
      var reader = new FileReader();
      reader.onloadend = function() {
        resolve(reader.result);
      };
      reader.readAsDataURL(file);
    } catch (e) {
      reject(e);
    }
  });
}


async function imageProcessor(ev, file) {
  const base64file = await fileToDataURL(file);

  // createImage(ev, base64file);
  return base64file; // passing any errors through
}

async function fileReader(ev, files) {
  let uploadResult = [];
  let errors;
  let fileItems = files;
  if (ev && (ev.dataTransfer.items || ev.dataTransfer.files)) {
    fileItems = ev.dataTransfer.items || ev.dataTransfer.files;
  }
  try {
    if (fileItems) {
      for (var i = 0; i < fileItems.length; i++) {
        if (ev && ev.dataTransfer.items) {
          if (fileItems[i].kind === 'file') {
            var file = fileItems[i].getAsFile();
            uploadResult.push(await imageProcessor(ev, file));
          }
        } else {
          uploadResult.push(await imageProcessor(ev, fileItems[i]));
        }
      }
    }
  } catch (e) {
    errors = e;
    uploadResult = null;
  }
  return { uploadResult, errors };
}



/***/ }),

/***/ "./lib/util/LabelUtil.js":
/*!*******************************!*\
  !*** ./lib/util/LabelUtil.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_LABEL_SIZE": () => (/* binding */ DEFAULT_LABEL_SIZE),
/* harmony export */   "FLOW_LABEL_INDENT": () => (/* binding */ FLOW_LABEL_INDENT),
/* harmony export */   "isLabelExternal": () => (/* binding */ isLabelExternal),
/* harmony export */   "hasExternalLabel": () => (/* binding */ hasExternalLabel),
/* harmony export */   "getWaypointsMid": () => (/* binding */ getWaypointsMid),
/* harmony export */   "getExternalLabelMid": () => (/* binding */ getExternalLabelMid),
/* harmony export */   "getExternalLabelBounds": () => (/* binding */ getExternalLabelBounds),
/* harmony export */   "isLabel": () => (/* binding */ isLabel)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelUtil */ "./lib/util/ModelUtil.js");





var DEFAULT_LABEL_SIZE = {
  width: 90,
  height: 20
};

var FLOW_LABEL_INDENT = 15;


/**
 * Returns true if the given semantic has an external label
 *
 * @param {BoardElement} semantic
 * @return {Boolean} true if has label
 */
function isLabelExternal(semantic) {
  return (0,_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.is)(semantic, 'postit:Group');
}

/**
 * Returns true if the given element has an external label
 *
 * @param {djs.model.shape} element
 * @return {Boolean} true if has label
 */
function hasExternalLabel(element) {
  return isLabel(element.label);
}


/**
 * Get the middle of a number of waypoints
 *
 * @param  {Array<Point>} waypoints
 * @return {Point} the mid point
 */
function getWaypointsMid(waypoints) {

  var mid = waypoints.length / 2 - 1;

  var first = waypoints[Math.floor(mid)];
  var second = waypoints[Math.ceil(mid + 0.01)];

  return {
    x: first.x + (second.x - first.x) / 2,
    y: first.y + (second.y - first.y) / 2
  };
}


function getExternalLabelMid(element) {

  if ((0,_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.is)(element, 'postit:Group')) {
    return {
      x: element.x + element.width / 2,
      y: element.y + DEFAULT_LABEL_SIZE.height / 2
    };
  } else {
    return {
      x: element.x + element.width / 2,
      y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2
    };
  }
}


/**
 * Returns the bounds of an elements label, parsed from the elements DI or
 * generated from its bounds.
 *
 * @param {BoardElement} semantic
 * @param {djs.model.Base} element
 */
function getExternalLabelBounds(semantic, element) {

  var mid,
      size,
      bounds,
      di = semantic.di,
      label = di.label;

  if (label && label.bounds) {
    bounds = label.bounds;

    size = {
      width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),
      height: bounds.height
    };

    mid = {
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2
    };
  } else {

    mid = getExternalLabelMid(element);

    size = DEFAULT_LABEL_SIZE;
  }

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({
    x: mid.x - size.width / 2,
    y: mid.y - size.height / 2
  }, size);
}

function isLabel(element) {
  return element && !!element.labelTarget;
}


/***/ }),

/***/ "./lib/util/ModelUtil.js":
/*!*******************************!*\
  !*** ./lib/util/ModelUtil.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "is": () => (/* binding */ is),
/* harmony export */   "getBusinessObject": () => (/* binding */ getBusinessObject)
/* harmony export */ });
/**
 * Is an element of the given postit type?
 *
 * @param  {djs.model.Base|ModdleElement} element
 * @param  {String} type
 *
 * @return {Boolean}
 */
function is(element, type) {
  var bo = getBusinessObject(element);

  return bo && (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);
}


/**
 * Return the business object for a given element.
 *
 * @param  {djs.model.Base|ModdleElement} element
 *
 * @return {ModdleElement}
 */
function getBusinessObject(element) {
  return (element && element.businessObject) || element;
}

/***/ }),

/***/ "./lib/util/ScreenUtil.js":
/*!********************************!*\
  !*** ./lib/util/ScreenUtil.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getMousePosition": () => (/* binding */ getMousePosition)
/* harmony export */ });
function getMousePosition(event) {
  event = event || window.event;

  var pageX = event.pageX;
  var pageY = event.pageY;

  // IE 8
  if (pageX === undefined) {
    pageX = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
    pageY = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
  }

  return { pageX, pageY };
}



/***/ }),

/***/ "./node_modules/css.escape/css.escape.js":
/*!***********************************************!*\
  !*** ./node_modules/css.escape/css.escape.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
;(function(root, factory) {
	// https://github.com/umdjs/umd/blob/master/returnExports.js
	if (true) {
		// For Node.js.
		module.exports = factory(root);
	} else {}
}(typeof __webpack_require__.g != 'undefined' ? __webpack_require__.g : this, function(root) {

	if (root.CSS && root.CSS.escape) {
		return root.CSS.escape;
	}

	// https://drafts.csswg.org/cssom/#serialize-an-identifier
	var cssEscape = function(value) {
		if (arguments.length == 0) {
			throw new TypeError('`CSS.escape` requires an argument.');
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = '';
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: theres no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += '\uFFFD';
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, []
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), []
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += '\\' + codeUnit.toString(16) + ' ';
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, []
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += '\\' + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), []
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += '\\' + string.charAt(index);

		}
		return result;
	};

	if (!root.CSS) {
		root.CSS = {};
	}

	root.CSS.escape = cssEscape;
	return cssEscape;

}));


/***/ }),

/***/ "./node_modules/diagram-js-direct-editing/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/diagram-js-direct-editing/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_interaction_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/interaction-events */ "./node_modules/diagram-js/lib/features/interaction-events/index.js");
/* harmony import */ var _lib_DirectEditing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/DirectEditing */ "./node_modules/diagram-js-direct-editing/lib/DirectEditing.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_interaction_events__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [ 'directEditing' ],
  directEditing: [ 'type', _lib_DirectEditing__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js-direct-editing/lib/DirectEditing.js":
/*!*********************************************************************!*\
  !*** ./node_modules/diagram-js-direct-editing/lib/DirectEditing.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DirectEditing)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _TextBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextBox */ "./node_modules/diagram-js-direct-editing/lib/TextBox.js");





/**
 * A direct editing component that allows users
 * to edit an elements text directly in the diagram
 *
 * @param {EventBus} eventBus the event bus
 */
function DirectEditing(eventBus, canvas) {

  this._eventBus = eventBus;

  this._providers = [];
  this._textbox = new _TextBox__WEBPACK_IMPORTED_MODULE_0__.default({
    container: canvas.getContainer(),
    keyHandler: (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.bind)(this._handleKey, this),
    resizeHandler: (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.bind)(this._handleResize, this)
  });
}

DirectEditing.$inject = [ 'eventBus', 'canvas' ];


/**
 * Register a direct editing provider

 * @param {Object} provider the provider, must expose an #activate(element) method that returns
 *                          an activation context ({ bounds: {x, y, width, height }, text }) if
 *                          direct editing is available for the given element.
 *                          Additionally the provider must expose a #update(element, value) method
 *                          to receive direct editing updates.
 */
DirectEditing.prototype.registerProvider = function(provider) {
  this._providers.push(provider);
};


/**
 * Returns true if direct editing is currently active
 *
 * @return {Boolean}
 */
DirectEditing.prototype.isActive = function() {
  return !!this._active;
};


/**
 * Cancel direct editing, if it is currently active
 */
DirectEditing.prototype.cancel = function() {
  if (!this._active) {
    return;
  }

  this._fire('cancel');
  this.close();
};


DirectEditing.prototype._fire = function(event, context) {
  this._eventBus.fire('directEditing.' + event, context || { active: this._active });
};

DirectEditing.prototype.close = function() {
  this._textbox.destroy();

  this._fire('deactivate');

  this._active = null;

  this.resizable = undefined;
};


DirectEditing.prototype.complete = function() {

  var active = this._active;

  if (!active) {
    return;
  }

  var containerBounds,
      previousBounds = active.context.bounds,
      newBounds = this.$textbox.getBoundingClientRect(),
      newText = this.getValue(),
      previousText = active.context.text;

  if (
    newText !== previousText ||
    newBounds.height !== previousBounds.height ||
    newBounds.width !== previousBounds.width
  ) {
    containerBounds = this._textbox.container.getBoundingClientRect();

    active.provider.update(active.element, newText, active.context.text, {
      x: newBounds.left - containerBounds.left,
      y: newBounds.top - containerBounds.top,
      width: newBounds.width,
      height: newBounds.height
    });
  }

  this._fire('complete');

  this.close();
};


DirectEditing.prototype.getValue = function() {
  return this._textbox.getValue();
};


DirectEditing.prototype._handleKey = function(e) {

  // stop bubble
  e.stopPropagation();

  var key = e.keyCode || e.charCode;

  // ESC
  if (key === 27) {
    e.preventDefault();
    return this.cancel();
  }

  // Enter
  if (key === 13 && !e.shiftKey) {
    e.preventDefault();
    return this.complete();
  }
};


DirectEditing.prototype._handleResize = function(event) {
  this._fire('resize', event);
};


/**
 * Activate direct editing on the given element
 *
 * @param {Object} ElementDescriptor the descriptor for a shape or connection
 * @return {Boolean} true if the activation was possible
 */
DirectEditing.prototype.activate = function(element) {
  if (this.isActive()) {
    this.cancel();
  }

  // the direct editing context
  var context;

  var provider = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(this._providers, function(p) {
    return (context = p.activate(element)) ? p : null;
  });

  // check if activation took place
  if (context) {
    this.$textbox = this._textbox.create(
      context.bounds,
      context.style,
      context.text,
      context.options
    );

    this._active = {
      element: element,
      context: context,
      provider: provider
    };

    if (context.options && context.options.resizable) {
      this.resizable = true;
    }

    this._fire('activate');
  }

  return !!context;
};


/***/ }),

/***/ "./node_modules/diagram-js-direct-editing/lib/TextBox.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js-direct-editing/lib/TextBox.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextBox)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");




var min = Math.min,
    max = Math.max;

function preventDefault(e) {
  e.preventDefault();
}

function stopPropagation(e) {
  e.stopPropagation();
}

function isTextNode(node) {
  return node.nodeType === Node.TEXT_NODE;
}

function toArray(nodeList) {
  return [].slice.call(nodeList);
}

/**
 * Initializes a container for a content editable div.
 *
 * Structure:
 *
 * container
 *   parent
 *     content
 *     resize-handle
 *
 * @param {object} options
 * @param {DOMElement} options.container The DOM element to append the contentContainer to
 * @param {Function} options.keyHandler Handler for key events
 * @param {Function} options.resizeHandler Handler for resize events
 */
function TextBox(options) {
  this.container = options.container;

  this.parent = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(
    '<div class="djs-direct-editing-parent">' +
      '<div class="djs-direct-editing-content" contenteditable="true"></div>' +
    '</div>'
  );

  this.content = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.query)('[contenteditable]', this.parent);

  this.keyHandler = options.keyHandler || function() {};
  this.resizeHandler = options.resizeHandler || function() {};

  this.autoResize = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.bind)(this.autoResize, this);
  this.handlePaste = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.bind)(this.handlePaste, this);
}


/**
 * Create a text box with the given position, size, style and text content
 *
 * @param {Object} bounds
 * @param {Number} bounds.x absolute x position
 * @param {Number} bounds.y absolute y position
 * @param {Number} [bounds.width] fixed width value
 * @param {Number} [bounds.height] fixed height value
 * @param {Number} [bounds.maxWidth] maximum width value
 * @param {Number} [bounds.maxHeight] maximum height value
 * @param {Number} [bounds.minWidth] minimum width value
 * @param {Number} [bounds.minHeight] minimum height value
 * @param {Object} [style]
 * @param {String} value text content
 *
 * @return {DOMElement} The created content DOM element
 */
TextBox.prototype.create = function(bounds, style, value, options) {
  var self = this;

  var parent = this.parent,
      content = this.content,
      container = this.container;

  options = this.options = options || {};

  style = this.style = style || {};

  var parentStyle = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.pick)(style, [
    'width',
    'height',
    'maxWidth',
    'maxHeight',
    'minWidth',
    'minHeight',
    'left',
    'top',
    'backgroundColor',
    'position',
    'overflow',
    'border',
    'wordWrap',
    'textAlign',
    'outline',
    'transform'
  ]);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(parent.style, {
    width: bounds.width + 'px',
    height: bounds.height + 'px',
    maxWidth: bounds.maxWidth + 'px',
    maxHeight: bounds.maxHeight + 'px',
    minWidth: bounds.minWidth + 'px',
    minHeight: bounds.minHeight + 'px',
    left: bounds.x + 'px',
    top: bounds.y + 'px',
    backgroundColor: '#ffffff',
    position: 'absolute',
    overflow: 'visible',
    border: '1px solid #ccc',
    boxSizing: 'border-box',
    wordWrap: 'normal',
    textAlign: 'center',
    outline: 'none'
  }, parentStyle);

  var contentStyle = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.pick)(style, [
    'fontFamily',
    'fontSize',
    'fontWeight',
    'lineHeight',
    'padding',
    'paddingTop',
    'paddingRight',
    'paddingBottom',
    'paddingLeft'
  ]);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(content.style, {
    boxSizing: 'border-box',
    width: '100%',
    outline: 'none',
    wordWrap: 'break-word'
  }, contentStyle);

  if (options.centerVertically) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(content.style, {
      position: 'absolute',
      top: '50%',
      transform: 'translate(0, -50%)'
    }, contentStyle);
  }

  content.innerText = value;

  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(content, 'keydown', this.keyHandler);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(content, 'mousedown', stopPropagation);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(content, 'paste', self.handlePaste);

  if (options.autoResize) {
    min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(content, 'input', this.autoResize);
  }

  if (options.resizable) {
    this.resizable(style);
  }

  container.appendChild(parent);

  // set selection to end of text
  this.setSelection(content.lastChild, content.lastChild && content.lastChild.length);

  return parent;
};

/**
 * Intercept paste events to remove formatting from pasted text.
 */
TextBox.prototype.handlePaste = function(e) {
  var options = this.options,
      style = this.style;

  e.preventDefault();

  var text;

  if (e.clipboardData) {

    // Chrome, Firefox, Safari
    text = e.clipboardData.getData('text/plain');
  } else {

    // Internet Explorer
    text = window.clipboardData.getData('Text');
  }

  this.insertText(text);

  if (options.autoResize) {
    var hasResized = this.autoResize(style);

    if (hasResized) {
      this.resizeHandler(hasResized);
    }
  }
};

TextBox.prototype.insertText = function(text) {

  // insertText command not supported by Internet Explorer
  var success = document.execCommand('insertText', false, text);

  if (success) {
    return;
  }

  this._insertTextIE(text);
};

TextBox.prototype._insertTextIE = function(text) {

  // Internet Explorer
  var range = this.getSelection(),
      startContainer = range.startContainer,
      endContainer = range.endContainer,
      startOffset = range.startOffset,
      endOffset = range.endOffset,
      commonAncestorContainer = range.commonAncestorContainer;

  var childNodesArray = toArray(commonAncestorContainer.childNodes);

  var container,
      offset;

  if (isTextNode(commonAncestorContainer)) {
    var containerTextContent = startContainer.textContent;

    startContainer.textContent =
      containerTextContent.substring(0, startOffset)
      + text
      + containerTextContent.substring(endOffset);

    container = startContainer;
    offset = startOffset + text.length;

  } else if (startContainer === this.content && endContainer === this.content) {
    var textNode = document.createTextNode(text);

    this.content.insertBefore(textNode, childNodesArray[startOffset]);

    container = textNode;
    offset = textNode.textContent.length;
  } else {
    var startContainerChildIndex = childNodesArray.indexOf(startContainer),
        endContainerChildIndex = childNodesArray.indexOf(endContainer);

    childNodesArray.forEach(function(childNode, index) {

      if (index === startContainerChildIndex) {
        childNode.textContent =
          startContainer.textContent.substring(0, startOffset) +
          text +
          endContainer.textContent.substring(endOffset);
      } else if (index > startContainerChildIndex && index <= endContainerChildIndex) {
        (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.remove)(childNode);
      }
    });

    container = startContainer;
    offset = startOffset + text.length;
  }

  if (container && offset !== undefined) {

    // is necessary in Internet Explorer
    setTimeout(function() {
      self.setSelection(container, offset);
    });
  }
};

/**
 * Automatically resize element vertically to fit its content.
 */
TextBox.prototype.autoResize = function() {
  var parent = this.parent,
      content = this.content;

  var fontSize = parseInt(this.style.fontSize) || 12;

  if (content.scrollHeight > parent.offsetHeight ||
      content.scrollHeight < parent.offsetHeight - fontSize) {
    var bounds = parent.getBoundingClientRect();

    var height = content.scrollHeight;
    parent.style.height = height + 'px';

    this.resizeHandler({
      width: bounds.width,
      height: bounds.height,
      dx: 0,
      dy: height - bounds.height
    });
  }
};

/**
 * Make an element resizable by adding a resize handle.
 */
TextBox.prototype.resizable = function() {
  var self = this;

  var parent = this.parent,
      resizeHandle = this.resizeHandle;

  var minWidth = parseInt(this.style.minWidth) || 0,
      minHeight = parseInt(this.style.minHeight) || 0,
      maxWidth = parseInt(this.style.maxWidth) || Infinity,
      maxHeight = parseInt(this.style.maxHeight) || Infinity;

  if (!resizeHandle) {
    resizeHandle = this.resizeHandle = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(
      '<div class="djs-direct-editing-resize-handle"></div>'
    );

    var startX, startY, startWidth, startHeight;

    var onMouseDown = function(e) {
      preventDefault(e);
      stopPropagation(e);

      startX = e.clientX;
      startY = e.clientY;

      var bounds = parent.getBoundingClientRect();

      startWidth = bounds.width;
      startHeight = bounds.height;

      min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(document, 'mousemove', onMouseMove);
      min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(document, 'mouseup', onMouseUp);
    };

    var onMouseMove = function(e) {
      preventDefault(e);
      stopPropagation(e);

      var newWidth = min(max(startWidth + e.clientX - startX, minWidth), maxWidth);
      var newHeight = min(max(startHeight + e.clientY - startY, minHeight), maxHeight);

      parent.style.width = newWidth + 'px';
      parent.style.height = newHeight + 'px';

      self.resizeHandler({
        width: startWidth,
        height: startHeight,
        dx: e.clientX - startX,
        dy: e.clientY - startY
      });
    };

    var onMouseUp = function(e) {
      preventDefault(e);
      stopPropagation(e);

      min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(document,'mousemove', onMouseMove, false);
      min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(document, 'mouseup', onMouseUp, false);
    };

    min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(resizeHandle, 'mousedown', onMouseDown);
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(resizeHandle.style, {
    position: 'absolute',
    bottom: '0px',
    right: '0px',
    cursor: 'nwse-resize',
    width: '0',
    height: '0',
    borderTop: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent',
    borderRight: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
    borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
    borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent'
  });

  parent.appendChild(resizeHandle);
};


/**
 * Clear content and style of the textbox, unbind listeners and
 * reset CSS style.
 */
TextBox.prototype.destroy = function() {
  var parent = this.parent,
      content = this.content,
      resizeHandle = this.resizeHandle;

  // clear content
  content.innerText = '';

  // clear styles
  parent.removeAttribute('style');
  content.removeAttribute('style');

  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(content, 'keydown', this.keyHandler);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(content, 'mousedown', stopPropagation);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(content, 'input', this.autoResize);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(content, 'paste', this.handlePaste);

  if (resizeHandle) {
    resizeHandle.removeAttribute('style');

    (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.remove)(resizeHandle);
  }

  (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.remove)(parent);
};


TextBox.prototype.getValue = function() {
  return this.content.innerText.trim();
};


TextBox.prototype.getSelection = function() {
  var selection = window.getSelection(),
      range = selection.getRangeAt(0);

  return range;
};


TextBox.prototype.setSelection = function(container, offset) {
  var range = document.createRange();

  if (container === null) {
    range.selectNodeContents(this.content);
  } else {
    range.setStart(container, offset);
    range.setEnd(container, offset);
  }

  var selection = window.getSelection();

  selection.removeAllRanges();
  selection.addRange(range);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/Diagram.js":
/*!************************************************!*\
  !*** ./node_modules/diagram-js/lib/Diagram.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Diagram)
/* harmony export */ });
/* harmony import */ var didi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! didi */ "./node_modules/didi/dist/index.esm.js");
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ "./node_modules/diagram-js/lib/core/index.js");





/**
 * Bootstrap an injector from a list of modules, instantiating a number of default components
 *
 * @ignore
 * @param {Array<didi.Module>} bootstrapModules
 *
 * @return {didi.Injector} a injector to use to access the components
 */
function bootstrap(bootstrapModules) {

  var modules = [],
      components = [];

  function hasModule(m) {
    return modules.indexOf(m) >= 0;
  }

  function addModule(m) {
    modules.push(m);
  }

  function visit(m) {
    if (hasModule(m)) {
      return;
    }

    (m.__depends__ || []).forEach(visit);

    if (hasModule(m)) {
      return;
    }

    addModule(m);

    (m.__init__ || []).forEach(function(c) {
      components.push(c);
    });
  }

  bootstrapModules.forEach(visit);

  var injector = new didi__WEBPACK_IMPORTED_MODULE_0__.Injector(modules);

  components.forEach(function(c) {

    try {

      // eagerly resolve component (fn or string)
      injector[typeof c === 'string' ? 'get' : 'invoke'](c);
    } catch (e) {
      console.error('Failed to instantiate component');
      console.error(e.stack);

      throw e;
    }
  });

  return injector;
}

/**
 * Creates an injector from passed options.
 *
 * @ignore
 * @param  {Object} options
 * @return {didi.Injector}
 */
function createInjector(options) {

  options = options || {};

  var configModule = {
    'config': ['value', options]
  };

  var modules = [ configModule, _core__WEBPACK_IMPORTED_MODULE_1__.default ].concat(options.modules || []);

  return bootstrap(modules);
}


/**
 * The main diagram-js entry point that bootstraps the diagram with the given
 * configuration.
 *
 * To register extensions with the diagram, pass them as Array<didi.Module> to the constructor.
 *
 * @class djs.Diagram
 * @memberOf djs
 * @constructor
 *
 * @example
 *
 * <caption>Creating a plug-in that logs whenever a shape is added to the canvas.</caption>
 *
 * // plug-in implemenentation
 * function MyLoggingPlugin(eventBus) {
 *   eventBus.on('shape.added', function(event) {
 *     console.log('shape ', event.shape, ' was added to the diagram');
 *   });
 * }
 *
 * // export as module
 * export default {
 *   __init__: [ 'myLoggingPlugin' ],
 *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]
 * };
 *
 *
 * // instantiate the diagram with the new plug-in
 *
 * import MyLoggingModule from 'path-to-my-logging-plugin';
 *
 * var diagram = new Diagram({
 *   modules: [
 *     MyLoggingModule
 *   ]
 * });
 *
 * diagram.invoke([ 'canvas', function(canvas) {
 *   // add shape to drawing canvas
 *   canvas.addShape({ x: 10, y: 10 });
 * });
 *
 * // 'shape ... was added to the diagram' logged to console
 *
 * @param {Object} options
 * @param {Array<didi.Module>} [options.modules] external modules to instantiate with the diagram
 * @param {didi.Injector} [injector] an (optional) injector to bootstrap the diagram with
 */
function Diagram(options, injector) {

  // create injector unless explicitly specified
  this.injector = injector = injector || createInjector(options);

  // API

  /**
   * Resolves a diagram service
   *
   * @method Diagram#get
   *
   * @param {string} name the name of the diagram service to be retrieved
   * @param {boolean} [strict=true] if false, resolve missing services to null
   */
  this.get = injector.get;

  /**
   * Executes a function into which diagram services are injected
   *
   * @method Diagram#invoke
   *
   * @param {Function|Object[]} fn the function to resolve
   * @param {Object} locals a number of locals to use to resolve certain dependencies
   */
  this.invoke = injector.invoke;

  // init

  // indicate via event


  /**
   * An event indicating that all plug-ins are loaded.
   *
   * Use this event to fire other events to interested plug-ins
   *
   * @memberOf Diagram
   *
   * @event diagram.init
   *
   * @example
   *
   * eventBus.on('diagram.init', function() {
   *   eventBus.fire('my-custom-event', { foo: 'BAR' });
   * });
   *
   * @type {Object}
   */
  this.get('eventBus').fire('diagram.init');
}


/**
 * Destroys the diagram
 *
 * @method  Diagram#destroy
 */
Diagram.prototype.destroy = function() {
  this.get('eventBus').fire('diagram.destroy');
};

/**
 * Clear the diagram, removing all contents.
 */
Diagram.prototype.clear = function() {
  this.get('eventBus').fire('diagram.clear');
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/command/CommandInterceptor.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/command/CommandInterceptor.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CommandInterceptor)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



var DEFAULT_PRIORITY = 1000;

/**
 * A utility that can be used to plug-in into the command execution for
 * extension and/or validation.
 *
 * @param {EventBus} eventBus
 *
 * @example
 *
 * import inherits from 'inherits';
 *
 * import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';
 *
 * function CommandLogger(eventBus) {
 *   CommandInterceptor.call(this, eventBus);
 *
 *   this.preExecute(function(event) {
 *     console.log('command pre-execute', event);
 *   });
 * }
 *
 * inherits(CommandLogger, CommandInterceptor);
 *
 */
function CommandInterceptor(eventBus) {
  this._eventBus = eventBus;
}

CommandInterceptor.$inject = [ 'eventBus' ];

function unwrapEvent(fn, that) {
  return function(event) {
    return fn.call(that || null, event.context, event.command, event);
  };
}

/**
 * Register an interceptor for a command execution
 *
 * @param {string|Array<string>} [events] list of commands to register on
 * @param {string} [hook] command hook, i.e. preExecute, executed to listen on
 * @param {number} [priority] the priority on which to hook into the execution
 * @param {Function} handlerFn interceptor to be invoked with (event)
 * @param {boolean} unwrap if true, unwrap the event and pass (context, command, event) to the
 *                          listener instead
 * @param {Object} [that] Pass context (`this`) to the handler function
 */
CommandInterceptor.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(hook) || (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(hook)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = hook;
    hook = null;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(priority)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = DEFAULT_PRIORITY;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(unwrap)) {
    that = unwrap;
    unwrap = false;
  }

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(handlerFn)) {
    throw new Error('handlerFn must be a function');
  }

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(events)) {
    events = [ events ];
  }

  var eventBus = this._eventBus;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(events, function(event) {

    // concat commandStack(.event)?(.hook)?
    var fullEvent = [ 'commandStack', event, hook ].filter(function(e) { return e; }).join('.');

    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
  });
};


var hooks = [
  'canExecute',
  'preExecute',
  'preExecuted',
  'execute',
  'executed',
  'postExecute',
  'postExecuted',
  'revert',
  'reverted'
];

/*
 * Install hook shortcuts
 *
 * This will generate the CommandInterceptor#(preExecute|...|reverted) methods
 * which will in term forward to CommandInterceptor#on.
 */
(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(hooks, function(hook) {

  /**
   * {canExecute|preExecute|preExecuted|execute|executed|postExecute|postExecuted|revert|reverted}
   *
   * A named hook for plugging into the command execution
   *
   * @param {string|Array<string>} [events] list of commands to register on
   * @param {number} [priority] the priority on which to hook into the execution
   * @param {Function} handlerFn interceptor to be invoked with (event)
   * @param {boolean} [unwrap=false] if true, unwrap the event and pass (context, command, event) to the
   *                          listener instead
   * @param {Object} [that] Pass context (`this`) to the handler function
   */
  CommandInterceptor.prototype[hook] = function(events, priority, handlerFn, unwrap, that) {

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(events) || (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(events)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = events;
      events = null;
    }

    this.on(events, hook, priority, handlerFn, unwrap, that);
  };
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/command/CommandStack.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/command/CommandStack.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CommandStack)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A service that offers un- and redoable execution of commands.
 *
 * The command stack is responsible for executing modeling actions
 * in a un- and redoable manner. To do this it delegates the actual
 * command execution to {@link CommandHandler}s.
 *
 * Command handlers provide {@link CommandHandler#execute(ctx)} and
 * {@link CommandHandler#revert(ctx)} methods to un- and redo a command
 * identified by a command context.
 *
 *
 * ## Life-Cycle events
 *
 * In the process the command stack fires a number of life-cycle events
 * that other components to participate in the command execution.
 *
 *    * preExecute
 *    * preExecuted
 *    * execute
 *    * executed
 *    * postExecute
 *    * postExecuted
 *    * revert
 *    * reverted
 *
 * A special event is used for validating, whether a command can be
 * performed prior to its execution.
 *
 *    * canExecute
 *
 * Each of the events is fired as `commandStack.{eventName}` and
 * `commandStack.{commandName}.{eventName}`, respectively. This gives
 * components fine grained control on where to hook into.
 *
 * The event object fired transports `command`, the name of the
 * command and `context`, the command context.
 *
 *
 * ## Creating Command Handlers
 *
 * Command handlers should provide the {@link CommandHandler#execute(ctx)}
 * and {@link CommandHandler#revert(ctx)} methods to implement
 * redoing and undoing of a command.
 *
 * A command handler _must_ ensure undo is performed properly in order
 * not to break the undo chain. It must also return the shapes that
 * got changed during the `execute` and `revert` operations.
 *
 * Command handlers may execute other modeling operations (and thus
 * commands) in their `preExecute` and `postExecute` phases. The command
 * stack will properly group all commands together into a logical unit
 * that may be re- and undone atomically.
 *
 * Command handlers must not execute other commands from within their
 * core implementation (`execute`, `revert`).
 *
 *
 * ## Change Tracking
 *
 * During the execution of the CommandStack it will keep track of all
 * elements that have been touched during the command's execution.
 *
 * At the end of the CommandStack execution it will notify interested
 * components via an 'elements.changed' event with all the dirty
 * elements.
 *
 * The event can be picked up by components that are interested in the fact
 * that elements have been changed. One use case for this is updating
 * their graphical representation after moving / resizing or deletion.
 *
 * @see CommandHandler
 *
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */
function CommandStack(eventBus, injector) {

  /**
   * A map of all registered command handlers.
   *
   * @type {Object}
   */
  this._handlerMap = {};

  /**
   * A stack containing all re/undoable actions on the diagram
   *
   * @type {Array<Object>}
   */
  this._stack = [];

  /**
   * The current index on the stack
   *
   * @type {number}
   */
  this._stackIdx = -1;

  /**
   * Current active commandStack execution
   *
   * @type {Object}
   * @property {Object[]} actions
   * @property {Object[]} dirty
   * @property { 'undo' | 'redo' | 'clear' | 'execute' | null } trigger the cause of the current excecution
   */
  this._currentExecution = {
    actions: [],
    dirty: [],
    trigger: null
  };


  this._injector = injector;
  this._eventBus = eventBus;

  this._uid = 1;

  eventBus.on([
    'diagram.destroy',
    'diagram.clear'
  ], function() {
    this.clear(false);
  }, this);
}

CommandStack.$inject = [ 'eventBus', 'injector' ];


/**
 * Execute a command
 *
 * @param {string} command the command to execute
 * @param {Object} context the environment to execute the command in
 */
CommandStack.prototype.execute = function(command, context) {
  if (!command) {
    throw new Error('command required');
  }

  this._currentExecution.trigger = 'execute';

  var action = { command: command, context: context };

  this._pushAction(action);
  this._internalExecute(action);
  this._popAction(action);
};


/**
 * Ask whether a given command can be executed.
 *
 * Implementors may hook into the mechanism on two ways:
 *
 *   * in event listeners:
 *
 *     Users may prevent the execution via an event listener.
 *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.
 *
 *   * in command handlers:
 *
 *     If the method {@link CommandHandler#canExecute} is implemented in a handler
 *     it will be called to figure out whether the execution is allowed.
 *
 * @param  {string} command the command to execute
 * @param  {Object} context the environment to execute the command in
 *
 * @return {boolean} true if the command can be executed
 */
CommandStack.prototype.canExecute = function(command, context) {

  var action = { command: command, context: context };

  var handler = this._getHandler(command);

  var result = this._fire(command, 'canExecute', action);

  // handler#canExecute will only be called if no listener
  // decided on a result already
  if (result === undefined) {
    if (!handler) {
      return false;
    }

    if (handler.canExecute) {
      result = handler.canExecute(context);
    }
  }

  return result;
};


/**
 * Clear the command stack, erasing all undo / redo history
 */
CommandStack.prototype.clear = function(emit) {
  this._stack.length = 0;
  this._stackIdx = -1;

  if (emit !== false) {
    this._fire('changed', { trigger: 'clear' });
  }
};


/**
 * Undo last command(s)
 */
CommandStack.prototype.undo = function() {
  var action = this._getUndoAction(),
      next;

  if (action) {
    this._currentExecution.trigger = 'undo';

    this._pushAction(action);

    while (action) {
      this._internalUndo(action);
      next = this._getUndoAction();

      if (!next || next.id !== action.id) {
        break;
      }

      action = next;
    }

    this._popAction();
  }
};


/**
 * Redo last command(s)
 */
CommandStack.prototype.redo = function() {
  var action = this._getRedoAction(),
      next;

  if (action) {
    this._currentExecution.trigger = 'redo';

    this._pushAction(action);

    while (action) {
      this._internalExecute(action, true);
      next = this._getRedoAction();

      if (!next || next.id !== action.id) {
        break;
      }

      action = next;
    }

    this._popAction();
  }
};


/**
 * Register a handler instance with the command stack
 *
 * @param {string} command
 * @param {CommandHandler} handler
 */
CommandStack.prototype.register = function(command, handler) {
  this._setHandler(command, handler);
};


/**
 * Register a handler type with the command stack
 * by instantiating it and injecting its dependencies.
 *
 * @param {string} command
 * @param {Function} a constructor for a {@link CommandHandler}
 */
CommandStack.prototype.registerHandler = function(command, handlerCls) {

  if (!command || !handlerCls) {
    throw new Error('command and handlerCls must be defined');
  }

  var handler = this._injector.instantiate(handlerCls);
  this.register(command, handler);
};

CommandStack.prototype.canUndo = function() {
  return !!this._getUndoAction();
};

CommandStack.prototype.canRedo = function() {
  return !!this._getRedoAction();
};

// stack access  //////////////////////

CommandStack.prototype._getRedoAction = function() {
  return this._stack[this._stackIdx + 1];
};


CommandStack.prototype._getUndoAction = function() {
  return this._stack[this._stackIdx];
};


// internal functionality //////////////////////

CommandStack.prototype._internalUndo = function(action) {
  var self = this;

  var command = action.command,
      context = action.context;

  var handler = this._getHandler(command);

  // guard against illegal nested command stack invocations
  this._atomicDo(function() {
    self._fire(command, 'revert', action);

    if (handler.revert) {
      self._markDirty(handler.revert(context));
    }

    self._revertedAction(action);

    self._fire(command, 'reverted', action);
  });
};


CommandStack.prototype._fire = function(command, qualifier, event) {
  if (arguments.length < 3) {
    event = qualifier;
    qualifier = null;
  }

  var names = qualifier ? [ command + '.' + qualifier, qualifier ] : [ command ],
      i, name, result;

  event = this._eventBus.createEvent(event);

  for (i = 0; (name = names[i]); i++) {
    result = this._eventBus.fire('commandStack.' + name, event);

    if (event.cancelBubble) {
      break;
    }
  }

  return result;
};

CommandStack.prototype._createId = function() {
  return this._uid++;
};

CommandStack.prototype._atomicDo = function(fn) {

  var execution = this._currentExecution;

  execution.atomic = true;

  try {
    fn();
  } finally {
    execution.atomic = false;
  }
};

CommandStack.prototype._internalExecute = function(action, redo) {
  var self = this;

  var command = action.command,
      context = action.context;

  var handler = this._getHandler(command);

  if (!handler) {
    throw new Error('no command handler registered for <' + command + '>');
  }

  this._pushAction(action);

  if (!redo) {
    this._fire(command, 'preExecute', action);

    if (handler.preExecute) {
      handler.preExecute(context);
    }

    this._fire(command, 'preExecuted', action);
  }

  // guard against illegal nested command stack invocations
  this._atomicDo(function() {

    self._fire(command, 'execute', action);

    if (handler.execute) {

      // actual execute + mark return results as dirty
      self._markDirty(handler.execute(context));
    }

    // log to stack
    self._executedAction(action, redo);

    self._fire(command, 'executed', action);
  });

  if (!redo) {
    this._fire(command, 'postExecute', action);

    if (handler.postExecute) {
      handler.postExecute(context);
    }

    this._fire(command, 'postExecuted', action);
  }

  this._popAction(action);
};


CommandStack.prototype._pushAction = function(action) {

  var execution = this._currentExecution,
      actions = execution.actions;

  var baseAction = actions[0];

  if (execution.atomic) {
    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');
  }

  if (!action.id) {
    action.id = (baseAction && baseAction.id) || this._createId();
  }

  actions.push(action);
};


CommandStack.prototype._popAction = function() {
  var execution = this._currentExecution,
      trigger = execution.trigger,
      actions = execution.actions,
      dirty = execution.dirty;

  actions.pop();

  if (!actions.length) {
    this._eventBus.fire('elements.changed', { elements: (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.uniqueBy)('id', dirty.reverse()) });

    dirty.length = 0;

    this._fire('changed', { trigger: trigger });

    execution.trigger = null;
  }
};


CommandStack.prototype._markDirty = function(elements) {
  var execution = this._currentExecution;

  if (!elements) {
    return;
  }

  elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements) ? elements : [ elements ];

  execution.dirty = execution.dirty.concat(elements);
};


CommandStack.prototype._executedAction = function(action, redo) {
  var stackIdx = ++this._stackIdx;

  if (!redo) {
    this._stack.splice(stackIdx, this._stack.length, action);
  }
};


CommandStack.prototype._revertedAction = function(action) {
  this._stackIdx--;
};


CommandStack.prototype._getHandler = function(command) {
  return this._handlerMap[command];
};

CommandStack.prototype._setHandler = function(command, handler) {
  if (!command || !handler) {
    throw new Error('command and handler required');
  }

  if (this._handlerMap[command]) {
    throw new Error('overriding handler for command <' + command + '>');
  }

  this._handlerMap[command] = handler;
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/command/index.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/command/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CommandStack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CommandStack */ "./node_modules/diagram-js/lib/command/CommandStack.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  commandStack: [ 'type', _CommandStack__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/Canvas.js":
/*!****************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/Canvas.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Canvas)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");











function round(number, resolution) {
  return Math.round(number * resolution) / resolution;
}

function ensurePx(number) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(number) ? number + 'px' : number;
}

/**
 * Creates a HTML container element for a SVG element with
 * the given configuration
 *
 * @param  {Object} options
 * @return {HTMLElement} the container element
 */
function createContainer(options) {

  options = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, { width: '100%', height: '100%' }, options);

  var container = options.container || document.body;

  // create a <div> around the svg element with the respective size
  // this way we can always get the correct container size
  // (this is impossible for <svg> elements at the moment)
  var parent = document.createElement('div');
  parent.setAttribute('class', 'djs-container');

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(parent.style, {
    position: 'relative',
    overflow: 'hidden',
    width: ensurePx(options.width),
    height: ensurePx(options.height)
  });

  container.appendChild(parent);

  return parent;
}

function createGroup(parent, cls, childIndex) {
  var group = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(group).add(cls);

  var index = childIndex !== undefined ? childIndex : parent.childNodes.length - 1;

  // must ensure second argument is node or _null_
  // cf. https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore
  parent.insertBefore(group, parent.childNodes[index] || null);

  return group;
}

var BASE_LAYER = 'base';


var REQUIRED_MODEL_ATTRS = {
  shape: [ 'x', 'y', 'width', 'height' ],
  connection: [ 'waypoints' ]
};

/**
 * The main drawing canvas.
 *
 * @class
 * @constructor
 *
 * @emits Canvas#canvas.init
 *
 * @param {Object} config
 * @param {EventBus} eventBus
 * @param {GraphicsFactory} graphicsFactory
 * @param {ElementRegistry} elementRegistry
 */
function Canvas(config, eventBus, graphicsFactory, elementRegistry) {

  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;

  this._init(config || {});
}

Canvas.$inject = [
  'config.canvas',
  'eventBus',
  'graphicsFactory',
  'elementRegistry'
];


Canvas.prototype._init = function(config) {

  var eventBus = this._eventBus;

  // Creates a <svg> element that is wrapped into a <div>.
  // This way we are always able to correctly figure out the size of the svg element
  // by querying the parent node.
  //
  // (It is not possible to get the size of a svg element cross browser @ 2014-04-01)
  //
  // <div class="djs-container" style="width: {desired-width}, height: {desired-height}">
  //   <svg width="100%" height="100%">
  //    ...
  //   </svg>
  // </div>

  // html container
  var container = this._container = createContainer(config);

  var svg = this._svg = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('svg');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(svg, { width: '100%', height: '100%' });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(container, svg);

  var viewport = this._viewport = createGroup(svg, 'viewport');

  this._layers = {};

  // debounce canvas.viewbox.changed events
  // for smoother diagram interaction
  if (config.deferUpdate !== false) {
    this._viewboxChanged = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.debounce)((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(this._viewboxChanged, this), 300);
  }

  eventBus.on('diagram.init', function() {

    /**
     * An event indicating that the canvas is ready to be drawn on.
     *
     * @memberOf Canvas
     *
     * @event canvas.init
     *
     * @type {Object}
     * @property {SVGElement} svg the created svg element
     * @property {SVGElement} viewport the direct parent of diagram elements and shapes
     */
    eventBus.fire('canvas.init', {
      svg: svg,
      viewport: viewport
    });

  }, this);

  // reset viewbox on shape changes to
  // recompute the viewbox
  eventBus.on([
    'shape.added',
    'connection.added',
    'shape.removed',
    'connection.removed',
    'elements.changed'
  ], function() {
    delete this._cachedViewbox;
  }, this);

  eventBus.on('diagram.destroy', 500, this._destroy, this);
  eventBus.on('diagram.clear', 500, this._clear, this);
};

Canvas.prototype._destroy = function(emit) {
  this._eventBus.fire('canvas.destroy', {
    svg: this._svg,
    viewport: this._viewport
  });

  var parent = this._container.parentNode;

  if (parent) {
    parent.removeChild(this._container);
  }

  delete this._svg;
  delete this._container;
  delete this._layers;
  delete this._rootElement;
  delete this._viewport;
};

Canvas.prototype._clear = function() {

  var self = this;

  var allElements = this._elementRegistry.getAll();

  // remove all elements
  allElements.forEach(function(element) {
    var type = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getType)(element);

    if (type === 'root') {
      self.setRootElement(null, true);
    } else {
      self._removeElement(element, type);
    }
  });

  // force recomputation of view box
  delete this._cachedViewbox;
};

/**
 * Returns the default layer on which
 * all elements are drawn.
 *
 * @returns {SVGElement}
 */
Canvas.prototype.getDefaultLayer = function() {
  return this.getLayer(BASE_LAYER, 0);
};

/**
 * Returns a layer that is used to draw elements
 * or annotations on it.
 *
 * Non-existing layers retrieved through this method
 * will be created. During creation, the optional index
 * may be used to create layers below or above existing layers.
 * A layer with a certain index is always created above all
 * existing layers with the same index.
 *
 * @param {string} name
 * @param {number} index
 *
 * @returns {SVGElement}
 */
Canvas.prototype.getLayer = function(name, index) {

  if (!name) {
    throw new Error('must specify a name');
  }

  var layer = this._layers[name];

  if (!layer) {
    layer = this._layers[name] = this._createLayer(name, index);
  }

  // throw an error if layer creation / retrival is
  // requested on different index
  if (typeof index !== 'undefined' && layer.index !== index) {
    throw new Error('layer <' + name + '> already created at index <' + index + '>');
  }

  return layer.group;
};

/**
 * Creates a given layer and returns it.
 *
 * @param {string} name
 * @param {number} [index=0]
 *
 * @return {Object} layer descriptor with { index, group: SVGGroup }
 */
Canvas.prototype._createLayer = function(name, index) {

  if (!index) {
    index = 0;
  }

  var childIndex = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(this._layers, function(childIndex, layer) {
    if (index >= layer.index) {
      childIndex++;
    }

    return childIndex;
  }, 0);

  return {
    group: createGroup(this._viewport, 'layer-' + name, childIndex),
    index: index
  };

};

/**
 * Returns the html element that encloses the
 * drawing canvas.
 *
 * @return {DOMNode}
 */
Canvas.prototype.getContainer = function() {
  return this._container;
};


// markers //////////////////////

Canvas.prototype._updateMarker = function(element, marker, add) {
  var container;

  if (!element.id) {
    element = this._elementRegistry.get(element);
  }

  // we need to access all
  container = this._elementRegistry._elements[element.id];

  if (!container) {
    return;
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)([ container.gfx, container.secondaryGfx ], function(gfx) {
    if (gfx) {

      // invoke either addClass or removeClass based on mode
      if (add) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).add(marker);
      } else {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).remove(marker);
      }
    }
  });

  /**
   * An event indicating that a marker has been updated for an element
   *
   * @event element.marker.update
   * @type {Object}
   * @property {djs.model.Element} element the shape
   * @property {Object} gfx the graphical representation of the shape
   * @property {string} marker
   * @property {boolean} add true if the marker was added, false if it got removed
   */
  this._eventBus.fire('element.marker.update', { element: element, gfx: container.gfx, marker: marker, add: !!add });
};


/**
 * Adds a marker to an element (basically a css class).
 *
 * Fires the element.marker.update event, making it possible to
 * integrate extension into the marker life-cycle, too.
 *
 * @example
 * canvas.addMarker('foo', 'some-marker');
 *
 * var fooGfx = canvas.getGraphics('foo');
 *
 * fooGfx; // <g class="... some-marker"> ... </g>
 *
 * @param {string|djs.model.Base} element
 * @param {string} marker
 */
Canvas.prototype.addMarker = function(element, marker) {
  this._updateMarker(element, marker, true);
};


/**
 * Remove a marker from an element.
 *
 * Fires the element.marker.update event, making it possible to
 * integrate extension into the marker life-cycle, too.
 *
 * @param  {string|djs.model.Base} element
 * @param  {string} marker
 */
Canvas.prototype.removeMarker = function(element, marker) {
  this._updateMarker(element, marker, false);
};

/**
 * Check the existence of a marker on element.
 *
 * @param  {string|djs.model.Base} element
 * @param  {string} marker
 */
Canvas.prototype.hasMarker = function(element, marker) {
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }

  var gfx = this.getGraphics(element);

  return (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).has(marker);
};

/**
 * Toggles a marker on an element.
 *
 * Fires the element.marker.update event, making it possible to
 * integrate extension into the marker life-cycle, too.
 *
 * @param  {string|djs.model.Base} element
 * @param  {string} marker
 */
Canvas.prototype.toggleMarker = function(element, marker) {
  if (this.hasMarker(element, marker)) {
    this.removeMarker(element, marker);
  } else {
    this.addMarker(element, marker);
  }
};

Canvas.prototype.getRootElement = function() {
  if (!this._rootElement) {
    this.setRootElement({ id: '__implicitroot', children: [] });
  }

  return this._rootElement;
};



// root element handling //////////////////////

/**
 * Sets a given element as the new root element for the canvas
 * and returns the new root element.
 *
 * @param {Object|djs.model.Root} element
 * @param {boolean} [override] whether to override the current root element, if any
 *
 * @return {Object|djs.model.Root} new root element
 */
Canvas.prototype.setRootElement = function(element, override) {

  if (element) {
    this._ensureValid('root', element);
  }

  var currentRoot = this._rootElement,
      elementRegistry = this._elementRegistry,
      eventBus = this._eventBus;

  if (currentRoot) {
    if (!override) {
      throw new Error('rootElement already set, need to specify override');
    }

    // simulate element remove event sequence
    eventBus.fire('root.remove', { element: currentRoot });
    eventBus.fire('root.removed', { element: currentRoot });

    elementRegistry.remove(currentRoot);
  }

  if (element) {
    var gfx = this.getDefaultLayer();

    // resemble element add event sequence
    eventBus.fire('root.add', { element: element });

    elementRegistry.add(element, gfx, this._svg);

    eventBus.fire('root.added', { element: element, gfx: gfx });
  }

  this._rootElement = element;

  return element;
};



// add functionality //////////////////////

Canvas.prototype._ensureValid = function(type, element) {
  if (!element.id) {
    throw new Error('element must have an id');
  }

  if (this._elementRegistry.get(element.id)) {
    throw new Error('element with id ' + element.id + ' already exists');
  }

  var requiredAttrs = REQUIRED_MODEL_ATTRS[type];

  var valid = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.every)(requiredAttrs, function(attr) {
    return typeof element[attr] !== 'undefined';
  });

  if (!valid) {
    throw new Error(
      'must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);
  }
};

Canvas.prototype._setParent = function(element, parent, parentIndex) {
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_3__.add)(parent.children, element, parentIndex);
  element.parent = parent;
};

/**
 * Adds an element to the canvas.
 *
 * This wires the parent <-> child relationship between the element and
 * a explicitly specified parent or an implicit root element.
 *
 * During add it emits the events
 *
 *  * <{type}.add> (element, parent)
 *  * <{type}.added> (element, gfx)
 *
 * Extensions may hook into these events to perform their magic.
 *
 * @param {string} type
 * @param {Object|djs.model.Base} element
 * @param {Object|djs.model.Base} [parent]
 * @param {number} [parentIndex]
 *
 * @return {Object|djs.model.Base} the added element
 */
Canvas.prototype._addElement = function(type, element, parent, parentIndex) {

  parent = parent || this.getRootElement();

  var eventBus = this._eventBus,
      graphicsFactory = this._graphicsFactory;

  this._ensureValid(type, element);

  eventBus.fire(type + '.add', { element: element, parent: parent });

  this._setParent(element, parent, parentIndex);

  // create graphics
  var gfx = graphicsFactory.create(type, element, parentIndex);

  this._elementRegistry.add(element, gfx);

  // update its visual
  graphicsFactory.update(type, element, gfx);

  eventBus.fire(type + '.added', { element: element, gfx: gfx });

  return element;
};

/**
 * Adds a shape to the canvas
 *
 * @param {Object|djs.model.Shape} shape to add to the diagram
 * @param {djs.model.Base} [parent]
 * @param {number} [parentIndex]
 *
 * @return {djs.model.Shape} the added shape
 */
Canvas.prototype.addShape = function(shape, parent, parentIndex) {
  return this._addElement('shape', shape, parent, parentIndex);
};

/**
 * Adds a connection to the canvas
 *
 * @param {Object|djs.model.Connection} connection to add to the diagram
 * @param {djs.model.Base} [parent]
 * @param {number} [parentIndex]
 *
 * @return {djs.model.Connection} the added connection
 */
Canvas.prototype.addConnection = function(connection, parent, parentIndex) {
  return this._addElement('connection', connection, parent, parentIndex);
};


/**
 * Internal remove element
 */
Canvas.prototype._removeElement = function(element, type) {

  var elementRegistry = this._elementRegistry,
      graphicsFactory = this._graphicsFactory,
      eventBus = this._eventBus;

  element = elementRegistry.get(element.id || element);

  if (!element) {

    // element was removed already
    return;
  }

  eventBus.fire(type + '.remove', { element: element });

  graphicsFactory.remove(element);

  // unset parent <-> child relationship
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_3__.remove)(element.parent && element.parent.children, element);
  element.parent = null;

  eventBus.fire(type + '.removed', { element: element });

  elementRegistry.remove(element);

  return element;
};


/**
 * Removes a shape from the canvas
 *
 * @param {string|djs.model.Shape} shape or shape id to be removed
 *
 * @return {djs.model.Shape} the removed shape
 */
Canvas.prototype.removeShape = function(shape) {

  /**
   * An event indicating that a shape is about to be removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event shape.remove
   * @type {Object}
   * @property {djs.model.Shape} element the shape descriptor
   * @property {Object} gfx the graphical representation of the shape
   */

  /**
   * An event indicating that a shape has been removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event shape.removed
   * @type {Object}
   * @property {djs.model.Shape} element the shape descriptor
   * @property {Object} gfx the graphical representation of the shape
   */
  return this._removeElement(shape, 'shape');
};


/**
 * Removes a connection from the canvas
 *
 * @param {string|djs.model.Connection} connection or connection id to be removed
 *
 * @return {djs.model.Connection} the removed connection
 */
Canvas.prototype.removeConnection = function(connection) {

  /**
   * An event indicating that a connection is about to be removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event connection.remove
   * @type {Object}
   * @property {djs.model.Connection} element the connection descriptor
   * @property {Object} gfx the graphical representation of the connection
   */

  /**
   * An event indicating that a connection has been removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event connection.removed
   * @type {Object}
   * @property {djs.model.Connection} element the connection descriptor
   * @property {Object} gfx the graphical representation of the connection
   */
  return this._removeElement(connection, 'connection');
};


/**
 * Return the graphical object underlaying a certain diagram element
 *
 * @param {string|djs.model.Base} element descriptor of the element
 * @param {boolean} [secondary=false] whether to return the secondary connected element
 *
 * @return {SVGElement}
 */
Canvas.prototype.getGraphics = function(element, secondary) {
  return this._elementRegistry.getGraphics(element, secondary);
};


/**
 * Perform a viewbox update via a given change function.
 *
 * @param {Function} changeFn
 */
Canvas.prototype._changeViewbox = function(changeFn) {

  // notify others of the upcoming viewbox change
  this._eventBus.fire('canvas.viewbox.changing');

  // perform actual change
  changeFn.apply(this);

  // reset the cached viewbox so that
  // a new get operation on viewbox or zoom
  // triggers a viewbox re-computation
  this._cachedViewbox = null;

  // notify others of the change; this step
  // may or may not be debounced
  this._viewboxChanged();
};

Canvas.prototype._viewboxChanged = function() {
  this._eventBus.fire('canvas.viewbox.changed', { viewbox: this.viewbox() });
};


/**
 * Gets or sets the view box of the canvas, i.e. the
 * area that is currently displayed.
 *
 * The getter may return a cached viewbox (if it is currently
 * changing). To force a recomputation, pass `false` as the first argument.
 *
 * @example
 *
 * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })
 *
 * // sets the visible area of the diagram to (100|100) -> (600|100)
 * // and and scales it according to the diagram width
 *
 * var viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.
 *
 * console.log(viewbox);
 * // {
 * //   inner: Dimensions,
 * //   outer: Dimensions,
 * //   scale,
 * //   x, y,
 * //   width, height
 * // }
 *
 * // if the current diagram is zoomed and scrolled, you may reset it to the
 * // default zoom via this method, too:
 *
 * var zoomedAndScrolledViewbox = canvas.viewbox();
 *
 * canvas.viewbox({
 *   x: 0,
 *   y: 0,
 *   width: zoomedAndScrolledViewbox.outer.width,
 *   height: zoomedAndScrolledViewbox.outer.height
 * });
 *
 * @param  {Object} [box] the new view box to set
 * @param  {number} box.x the top left X coordinate of the canvas visible in view box
 * @param  {number} box.y the top left Y coordinate of the canvas visible in view box
 * @param  {number} box.width the visible width
 * @param  {number} box.height
 *
 * @return {Object} the current view box
 */
Canvas.prototype.viewbox = function(box) {

  if (box === undefined && this._cachedViewbox) {
    return this._cachedViewbox;
  }

  var viewport = this._viewport,
      innerBox,
      outerBox = this.getSize(),
      matrix,
      transform,
      scale,
      x, y;

  if (!box) {

    // compute the inner box based on the
    // diagrams default layer. This allows us to exclude
    // external components, such as overlays
    innerBox = this.getDefaultLayer().getBBox();

    transform = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.transform)(viewport);
    matrix = transform ? transform.matrix : (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.createMatrix)();
    scale = round(matrix.a, 1000);

    x = round(-matrix.e || 0, 1000);
    y = round(-matrix.f || 0, 1000);

    box = this._cachedViewbox = {
      x: x ? x / scale : 0,
      y: y ? y / scale : 0,
      width: outerBox.width / scale,
      height: outerBox.height / scale,
      scale: scale,
      inner: {
        width: innerBox.width,
        height: innerBox.height,
        x: innerBox.x,
        y: innerBox.y
      },
      outer: outerBox
    };

    return box;
  } else {

    this._changeViewbox(function() {
      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);

      var matrix = this._svg.createSVGMatrix()
        .scale(scale)
        .translate(-box.x, -box.y);

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.transform)(viewport, matrix);
    });
  }

  return box;
};


/**
 * Gets or sets the scroll of the canvas.
 *
 * @param {Object} [delta] the new scroll to apply.
 *
 * @param {number} [delta.dx]
 * @param {number} [delta.dy]
 */
Canvas.prototype.scroll = function(delta) {

  var node = this._viewport;
  var matrix = node.getCTM();

  if (delta) {
    this._changeViewbox(function() {
      delta = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({ dx: 0, dy: 0 }, delta || {});

      matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);

      setCTM(node, matrix);
    });
  }

  return { x: matrix.e, y: matrix.f };
};


/**
 * Gets or sets the current zoom of the canvas, optionally zooming
 * to the specified position.
 *
 * The getter may return a cached zoom level. Call it with `false` as
 * the first argument to force recomputation of the current level.
 *
 * @param {string|number} [newScale] the new zoom level, either a number, i.e. 0.9,
 *                                   or `fit-viewport` to adjust the size to fit the current viewport
 * @param {string|Point} [center] the reference point { x: .., y: ..} to zoom to, 'auto' to zoom into mid or null
 *
 * @return {number} the current scale
 */
Canvas.prototype.zoom = function(newScale, center) {

  if (!newScale) {
    return this.viewbox(newScale).scale;
  }

  if (newScale === 'fit-viewport') {
    return this._fitViewport(center);
  }

  var outer,
      matrix;

  this._changeViewbox(function() {

    if (typeof center !== 'object') {
      outer = this.viewbox().outer;

      center = {
        x: outer.width / 2,
        y: outer.height / 2
      };
    }

    matrix = this._setZoom(newScale, center);
  });

  return round(matrix.a, 1000);
};

function setCTM(node, m) {
  var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';
  node.setAttribute('transform', mstr);
}

Canvas.prototype._fitViewport = function(center) {

  var vbox = this.viewbox(),
      outer = vbox.outer,
      inner = vbox.inner,
      newScale,
      newViewbox;

  // display the complete diagram without zooming in.
  // instead of relying on internal zoom, we perform a
  // hard reset on the canvas viewbox to realize this
  //
  // if diagram does not need to be zoomed in, we focus it around
  // the diagram origin instead

  if (inner.x >= 0 &&
      inner.y >= 0 &&
      inner.x + inner.width <= outer.width &&
      inner.y + inner.height <= outer.height &&
      !center) {

    newViewbox = {
      x: 0,
      y: 0,
      width: Math.max(inner.width + inner.x, outer.width),
      height: Math.max(inner.height + inner.y, outer.height)
    };
  } else {

    newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);
    newViewbox = {
      x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),
      y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),
      width: outer.width / newScale,
      height: outer.height / newScale
    };
  }

  this.viewbox(newViewbox);

  return this.viewbox(false).scale;
};


Canvas.prototype._setZoom = function(scale, center) {

  var svg = this._svg,
      viewport = this._viewport;

  var matrix = svg.createSVGMatrix();
  var point = svg.createSVGPoint();

  var centerPoint,
      originalPoint,
      currentMatrix,
      scaleMatrix,
      newMatrix;

  currentMatrix = viewport.getCTM();

  var currentScale = currentMatrix.a;

  if (center) {
    centerPoint = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(point, center);

    // revert applied viewport transformations
    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());

    // create scale matrix
    scaleMatrix = matrix
      .translate(originalPoint.x, originalPoint.y)
      .scale(1 / currentScale * scale)
      .translate(-originalPoint.x, -originalPoint.y);

    newMatrix = currentMatrix.multiply(scaleMatrix);
  } else {
    newMatrix = matrix.scale(scale);
  }

  setCTM(this._viewport, newMatrix);

  return newMatrix;
};


/**
 * Returns the size of the canvas
 *
 * @return {Dimensions}
 */
Canvas.prototype.getSize = function() {
  return {
    width: this._container.clientWidth,
    height: this._container.clientHeight
  };
};


/**
 * Return the absolute bounding box for the given element
 *
 * The absolute bounding box may be used to display overlays in the
 * callers (browser) coordinate system rather than the zoomed in/out
 * canvas coordinates.
 *
 * @param  {ElementDescriptor} element
 * @return {Bounds} the absolute bounding box
 */
Canvas.prototype.getAbsoluteBBox = function(element) {
  var vbox = this.viewbox();
  var bbox;

  // connection
  // use svg bbox
  if (element.waypoints) {
    var gfx = this.getGraphics(element);

    bbox = gfx.getBBox();
  }

  // shapes
  // use data
  else {
    bbox = element;
  }

  var x = bbox.x * vbox.scale - vbox.x * vbox.scale;
  var y = bbox.y * vbox.scale - vbox.y * vbox.scale;

  var width = bbox.width * vbox.scale;
  var height = bbox.height * vbox.scale;

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
};

/**
 * Fires an event in order other modules can react to the
 * canvas resizing
 */
Canvas.prototype.resized = function() {

  // force recomputation of view box
  delete this._cachedViewbox;

  this._eventBus.fire('canvas.resized');
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/ElementFactory.js":
/*!************************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/ElementFactory.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementFactory)
/* harmony export */ });
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model */ "./node_modules/diagram-js/lib/model/index.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");




/**
 * A factory for diagram-js shapes
 */
function ElementFactory() {
  this._uid = 12;
}


ElementFactory.prototype.createRoot = function(attrs) {
  return this.create('root', attrs);
};

ElementFactory.prototype.createLabel = function(attrs) {
  return this.create('label', attrs);
};

ElementFactory.prototype.createShape = function(attrs) {
  return this.create('shape', attrs);
};

ElementFactory.prototype.createConnection = function(attrs) {
  return this.create('connection', attrs);
};

/**
 * Create a model element with the given type and
 * a number of pre-set attributes.
 *
 * @param  {string} type
 * @param  {Object} attrs
 * @return {djs.model.Base} the newly created model instance
 */
ElementFactory.prototype.create = function(type, attrs) {

  attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, attrs || {});

  if (!attrs.id) {
    attrs.id = type + '_' + (this._uid++);
  }

  return (0,_model__WEBPACK_IMPORTED_MODULE_1__.create)(type, attrs);
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/core/ElementRegistry.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/ElementRegistry.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementRegistry)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
var ELEMENT_ID = 'data-element-id';




/**
 * @class
 *
 * A registry that keeps track of all shapes in the diagram.
 */
function ElementRegistry(eventBus) {
  this._elements = {};

  this._eventBus = eventBus;
}

ElementRegistry.$inject = [ 'eventBus' ];

/**
 * Register a pair of (element, gfx, (secondaryGfx)).
 *
 * @param {djs.model.Base} element
 * @param {SVGElement} gfx
 * @param {SVGElement} [secondaryGfx] optional other element to register, too
 */
ElementRegistry.prototype.add = function(element, gfx, secondaryGfx) {

  var id = element.id;

  this._validateId(id);

  // associate dom node with element
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(gfx, ELEMENT_ID, id);

  if (secondaryGfx) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(secondaryGfx, ELEMENT_ID, id);
  }

  this._elements[id] = { element: element, gfx: gfx, secondaryGfx: secondaryGfx };
};

/**
 * Removes an element from the registry.
 *
 * @param {djs.model.Base} element
 */
ElementRegistry.prototype.remove = function(element) {
  var elements = this._elements,
      id = element.id || element,
      container = id && elements[id];

  if (container) {

    // unset element id on gfx
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(container.gfx, ELEMENT_ID, '');

    if (container.secondaryGfx) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(container.secondaryGfx, ELEMENT_ID, '');
    }

    delete elements[id];
  }
};

/**
 * Update the id of an element
 *
 * @param {djs.model.Base} element
 * @param {string} newId
 */
ElementRegistry.prototype.updateId = function(element, newId) {

  this._validateId(newId);

  if (typeof element === 'string') {
    element = this.get(element);
  }

  this._eventBus.fire('element.updateId', {
    element: element,
    newId: newId
  });

  var gfx = this.getGraphics(element),
      secondaryGfx = this.getGraphics(element, true);

  this.remove(element);

  element.id = newId;

  this.add(element, gfx, secondaryGfx);
};

/**
 * Return the model element for a given id or graphics.
 *
 * @example
 *
 * elementRegistry.get('SomeElementId_1');
 * elementRegistry.get(gfx);
 *
 *
 * @param {string|SVGElement} filter for selecting the element
 *
 * @return {djs.model.Base}
 */
ElementRegistry.prototype.get = function(filter) {
  var id;

  if (typeof filter === 'string') {
    id = filter;
  } else {
    id = filter && (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(filter, ELEMENT_ID);
  }

  var container = this._elements[id];
  return container && container.element;
};

/**
 * Return all elements that match a given filter function.
 *
 * @param {Function} fn
 *
 * @return {Array<djs.model.Base>}
 */
ElementRegistry.prototype.filter = function(fn) {

  var filtered = [];

  this.forEach(function(element, gfx) {
    if (fn(element, gfx)) {
      filtered.push(element);
    }
  });

  return filtered;
};

/**
 * Return the first element that satisfies the provided testing function.
 *
 * @param {Function} fn
 *
 * @return {djs.model.Base}
 */
ElementRegistry.prototype.find = function(fn) {
  var map = this._elements,
      keys = Object.keys(map);

  for (var i = 0; i < keys.length; i++) {
    var id = keys[i],
        container = map[id],
        element = container.element,
        gfx = container.gfx;

    if (fn(element, gfx)) {
      return element;
    }
  }
};

/**
 * Return all rendered model elements.
 *
 * @return {Array<djs.model.Base>}
 */
ElementRegistry.prototype.getAll = function() {
  return this.filter(function(e) { return e; });
};

/**
 * Iterate over all diagram elements.
 *
 * @param {Function} fn
 */
ElementRegistry.prototype.forEach = function(fn) {

  var map = this._elements;

  Object.keys(map).forEach(function(id) {
    var container = map[id],
        element = container.element,
        gfx = container.gfx;

    return fn(element, gfx);
  });
};

/**
 * Return the graphical representation of an element or its id.
 *
 * @example
 * elementRegistry.getGraphics('SomeElementId_1');
 * elementRegistry.getGraphics(rootElement); // <g ...>
 *
 * elementRegistry.getGraphics(rootElement, true); // <svg ...>
 *
 *
 * @param {string|djs.model.Base} filter
 * @param {boolean} [secondary=false] whether to return the secondary connected element
 *
 * @return {SVGElement}
 */
ElementRegistry.prototype.getGraphics = function(filter, secondary) {
  var id = filter.id || filter;

  var container = this._elements[id];
  return container && (secondary ? container.secondaryGfx : container.gfx);
};

/**
 * Validate the suitability of the given id and signals a problem
 * with an exception.
 *
 * @param {string} id
 *
 * @throws {Error} if id is empty or already assigned
 */
ElementRegistry.prototype._validateId = function(id) {
  if (!id) {
    throw new Error('element must have an id');
  }

  if (this._elements[id]) {
    throw new Error('element with id ' + id + ' already added');
  }
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/EventBus.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/EventBus.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventBus)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var FN_REF = '__fn';

var DEFAULT_PRIORITY = 1000;

var slice = Array.prototype.slice;

/**
 * A general purpose event bus.
 *
 * This component is used to communicate across a diagram instance.
 * Other parts of a diagram can use it to listen to and broadcast events.
 *
 *
 * ## Registering for Events
 *
 * The event bus provides the {@link EventBus#on} and {@link EventBus#once}
 * methods to register for events. {@link EventBus#off} can be used to
 * remove event registrations. Listeners receive an instance of {@link Event}
 * as the first argument. It allows them to hook into the event execution.
 *
 * ```javascript
 *
 * // listen for event
 * eventBus.on('foo', function(event) {
 *
 *   // access event type
 *   event.type; // 'foo'
 *
 *   // stop propagation to other listeners
 *   event.stopPropagation();
 *
 *   // prevent event default
 *   event.preventDefault();
 * });
 *
 * // listen for event with custom payload
 * eventBus.on('bar', function(event, payload) {
 *   console.log(payload);
 * });
 *
 * // listen for event returning value
 * eventBus.on('foobar', function(event) {
 *
 *   // stop event propagation + prevent default
 *   return false;
 *
 *   // stop event propagation + return custom result
 *   return {
 *     complex: 'listening result'
 *   };
 * });
 *
 *
 * // listen with custom priority (default=1000, higher is better)
 * eventBus.on('priorityfoo', 1500, function(event) {
 *   console.log('invoked first!');
 * });
 *
 *
 * // listen for event and pass the context (`this`)
 * eventBus.on('foobar', function(event) {
 *   this.foo();
 * }, this);
 * ```
 *
 *
 * ## Emitting Events
 *
 * Events can be emitted via the event bus using {@link EventBus#fire}.
 *
 * ```javascript
 *
 * // false indicates that the default action
 * // was prevented by listeners
 * if (eventBus.fire('foo') === false) {
 *   console.log('default has been prevented!');
 * };
 *
 *
 * // custom args + return value listener
 * eventBus.on('sum', function(event, a, b) {
 *   return a + b;
 * });
 *
 * // you can pass custom arguments + retrieve result values.
 * var sum = eventBus.fire('sum', 1, 2);
 * console.log(sum); // 3
 * ```
 */
function EventBus() {
  this._listeners = {};

  // cleanup on destroy on lowest priority to allow
  // message passing until the bitter end
  this.on('diagram.destroy', 1, this._destroy, this);
}


/**
 * Register an event listener for events with the given name.
 *
 * The callback will be invoked with `event, ...additionalArguments`
 * that have been passed to {@link EventBus#fire}.
 *
 * Returning false from a listener will prevent the events default action
 * (if any is specified). To stop an event from being processed further in
 * other listeners execute {@link Event#stopPropagation}.
 *
 * Returning anything but `undefined` from a listener will stop the listener propagation.
 *
 * @param {string|Array<string>} events
 * @param {number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback
 * @param {Object} [that] Pass context (`this`) to the callback
 */
EventBus.prototype.on = function(events, priority, callback, that) {

  events = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(events) ? events : [ events ];

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY;
  }

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(priority)) {
    throw new Error('priority must be a number');
  }

  var actualCallback = callback;

  if (that) {
    actualCallback = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(callback, that);

    // make sure we remember and are able to remove
    // bound callbacks via {@link #off} using the original
    // callback
    actualCallback[FN_REF] = callback[FN_REF] || callback;
  }

  var self = this;

  events.forEach(function(e) {
    self._addListener(e, {
      priority: priority,
      callback: actualCallback,
      next: null
    });
  });
};


/**
 * Register an event listener that is executed only once.
 *
 * @param {string} event the event name to register for
 * @param {number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback the callback to execute
 * @param {Object} [that] Pass context (`this`) to the callback
 */
EventBus.prototype.once = function(event, priority, callback, that) {
  var self = this;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY;
  }

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(priority)) {
    throw new Error('priority must be a number');
  }

  function wrappedCallback() {
    wrappedCallback.__isTomb = true;

    var result = callback.apply(that, arguments);

    self.off(event, wrappedCallback);

    return result;
  }

  // make sure we remember and are able to remove
  // bound callbacks via {@link #off} using the original
  // callback
  wrappedCallback[FN_REF] = callback;

  this.on(event, priority, wrappedCallback);
};


/**
 * Removes event listeners by event and callback.
 *
 * If no callback is given, all listeners for a given event name are being removed.
 *
 * @param {string|Array<string>} events
 * @param {Function} [callback]
 */
EventBus.prototype.off = function(events, callback) {

  events = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(events) ? events : [ events ];

  var self = this;

  events.forEach(function(event) {
    self._removeListener(event, callback);
  });

};


/**
 * Create an EventBus event.
 *
 * @param {Object} data
 *
 * @return {Object} event, recognized by the eventBus
 */
EventBus.prototype.createEvent = function(data) {
  var event = new InternalEvent();

  event.init(data);

  return event;
};


/**
 * Fires a named event.
 *
 * @example
 *
 * // fire event by name
 * events.fire('foo');
 *
 * // fire event object with nested type
 * var event = { type: 'foo' };
 * events.fire(event);
 *
 * // fire event with explicit type
 * var event = { x: 10, y: 20 };
 * events.fire('element.moved', event);
 *
 * // pass additional arguments to the event
 * events.on('foo', function(event, bar) {
 *   alert(bar);
 * });
 *
 * events.fire({ type: 'foo' }, 'I am bar!');
 *
 * @param {string} [name] the optional event name
 * @param {Object} [event] the event object
 * @param {...Object} additional arguments to be passed to the callback functions
 *
 * @return {boolean} the events return value, if specified or false if the
 *                   default action was prevented by listeners
 */
EventBus.prototype.fire = function(type, data) {
  var event,
      firstListener,
      returnValue,
      args;

  args = slice.call(arguments);

  if (typeof type === 'object') {
    data = type;
    type = data.type;
  }

  if (!type) {
    throw new Error('no event type specified');
  }

  firstListener = this._listeners[type];

  if (!firstListener) {
    return;
  }

  // we make sure we fire instances of our home made
  // events here. We wrap them only once, though
  if (data instanceof InternalEvent) {

    // we are fine, we alread have an event
    event = data;
  } else {
    event = this.createEvent(data);
  }

  // ensure we pass the event as the first parameter
  args[0] = event;

  // original event type (in case we delegate)
  var originalType = event.type;

  // update event type before delegation
  if (type !== originalType) {
    event.type = type;
  }

  try {
    returnValue = this._invokeListeners(event, args, firstListener);
  } finally {

    // reset event type after delegation
    if (type !== originalType) {
      event.type = originalType;
    }
  }

  // set the return value to false if the event default
  // got prevented and no other return value exists
  if (returnValue === undefined && event.defaultPrevented) {
    returnValue = false;
  }

  return returnValue;
};


EventBus.prototype.handleError = function(error) {
  return this.fire('error', { error: error }) === false;
};


EventBus.prototype._destroy = function() {
  this._listeners = {};
};

EventBus.prototype._invokeListeners = function(event, args, listener) {

  var returnValue;

  while (listener) {

    // handle stopped propagation
    if (event.cancelBubble) {
      break;
    }

    returnValue = this._invokeListener(event, args, listener);

    listener = listener.next;
  }

  return returnValue;
};

EventBus.prototype._invokeListener = function(event, args, listener) {

  var returnValue;

  if (listener.callback.__isTomb) {
    return returnValue;
  }

  try {

    // returning false prevents the default action
    returnValue = invokeFunction(listener.callback, args);

    // stop propagation on return value
    if (returnValue !== undefined) {
      event.returnValue = returnValue;
      event.stopPropagation();
    }

    // prevent default on return false
    if (returnValue === false) {
      event.preventDefault();
    }
  } catch (e) {
    if (!this.handleError(e)) {
      console.error('unhandled error in event listener');
      console.error(e.stack);

      throw e;
    }
  }

  return returnValue;
};

/*
 * Add new listener with a certain priority to the list
 * of listeners (for the given event).
 *
 * The semantics of listener registration / listener execution are
 * first register, first serve: New listeners will always be inserted
 * after existing listeners with the same priority.
 *
 * Example: Inserting two listeners with priority 1000 and 1300
 *
 *    * before: [ 1500, 1500, 1000, 1000 ]
 *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]
 *
 * @param {string} event
 * @param {Object} listener { priority, callback }
 */
EventBus.prototype._addListener = function(event, newListener) {

  var listener = this._getListeners(event),
      previousListener;

  // no prior listeners
  if (!listener) {
    this._setListeners(event, newListener);

    return;
  }

  // ensure we order listeners by priority from
  // 0 (high) to n > 0 (low)
  while (listener) {

    if (listener.priority < newListener.priority) {

      newListener.next = listener;

      if (previousListener) {
        previousListener.next = newListener;
      } else {
        this._setListeners(event, newListener);
      }

      return;
    }

    previousListener = listener;
    listener = listener.next;
  }

  // add new listener to back
  previousListener.next = newListener;
};


EventBus.prototype._getListeners = function(name) {
  return this._listeners[name];
};

EventBus.prototype._setListeners = function(name, listener) {
  this._listeners[name] = listener;
};

EventBus.prototype._removeListener = function(event, callback) {

  var listener = this._getListeners(event),
      nextListener,
      previousListener,
      listenerCallback;

  if (!callback) {

    // clear listeners
    this._setListeners(event, null);

    return;
  }

  while (listener) {

    nextListener = listener.next;

    listenerCallback = listener.callback;

    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
      if (previousListener) {
        previousListener.next = nextListener;
      } else {

        // new first listener
        this._setListeners(event, nextListener);
      }
    }

    previousListener = listener;
    listener = nextListener;
  }
};

/**
 * A event that is emitted via the event bus.
 */
function InternalEvent() { }

InternalEvent.prototype.stopPropagation = function() {
  this.cancelBubble = true;
};

InternalEvent.prototype.preventDefault = function() {
  this.defaultPrevented = true;
};

InternalEvent.prototype.init = function(data) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(this, data || {});
};


/**
 * Invoke function. Be fast...
 *
 * @param {Function} fn
 * @param {Array<Object>} args
 *
 * @return {Any}
 */
function invokeFunction(fn, args) {
  return fn.apply(null, args);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/GraphicsFactory.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/GraphicsFactory.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GraphicsFactory)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/GraphicsUtil */ "./node_modules/diagram-js/lib/util/GraphicsUtil.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");












/**
 * A factory that creates graphical elements
 *
 * @param {EventBus} eventBus
 * @param {ElementRegistry} elementRegistry
 */
function GraphicsFactory(eventBus, elementRegistry) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
}

GraphicsFactory.$inject = [ 'eventBus' , 'elementRegistry' ];


GraphicsFactory.prototype._getChildrenContainer = function(element) {

  var gfx = this._elementRegistry.getGraphics(element);

  var childrenGfx;

  // root element
  if (!element.parent) {
    childrenGfx = gfx;
  } else {
    childrenGfx = (0,_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_0__.getChildren)(gfx);
    if (!childrenGfx) {
      childrenGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(childrenGfx).add('djs-children');

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(gfx.parentNode, childrenGfx);
    }
  }

  return childrenGfx;
};

/**
 * Clears the graphical representation of the element and returns the
 * cleared visual (the <g class="djs-visual" /> element).
 */
GraphicsFactory.prototype._clear = function(gfx) {
  var visual = (0,_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_0__.getVisual)(gfx);

  (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.clear)(visual);

  return visual;
};

/**
 * Creates a gfx container for shapes and connections
 *
 * The layout is as follows:
 *
 * <g class="djs-group">
 *
 *   <!-- the gfx -->
 *   <g class="djs-element djs-(shape|connection|frame)">
 *     <g class="djs-visual">
 *       <!-- the renderer draws in here -->
 *     </g>
 *
 *     <!-- extensions (overlays, click box, ...) goes here
 *   </g>
 *
 *   <!-- the gfx child nodes -->
 *   <g class="djs-children"></g>
 * </g>
 *
 * @param {string} type the type of the element, i.e. shape | connection
 * @param {SVGElement} [childrenGfx]
 * @param {number} [parentIndex] position to create container in parent
 * @param {boolean} [isFrame] is frame element
 *
 * @return {SVGElement}
 */
GraphicsFactory.prototype._createContainer = function(
    type, childrenGfx, parentIndex, isFrame
) {
  var outerGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(outerGfx).add('djs-group');

  // insert node at position
  if (typeof parentIndex !== 'undefined') {
    prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);
  } else {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(childrenGfx, outerGfx);
  }

  var gfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).add('djs-element');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).add('djs-' + type);

  if (isFrame) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).add('djs-frame');
  }

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(outerGfx, gfx);

  // create visual
  var visual = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(visual).add('djs-visual');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(gfx, visual);

  return gfx;
};

GraphicsFactory.prototype.create = function(type, element, parentIndex) {
  var childrenGfx = this._getChildrenContainer(element.parent);
  return this._createContainer(type, childrenGfx, parentIndex, (0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.isFrameElement)(element));
};

GraphicsFactory.prototype.updateContainments = function(elements) {

  var self = this,
      elementRegistry = this._elementRegistry,
      parents;

  parents = (0,min_dash__WEBPACK_IMPORTED_MODULE_4__.reduce)(elements, function(map, e) {

    if (e.parent) {
      map[e.parent.id] = e.parent;
    }

    return map;
  }, {});

  // update all parents of changed and reorganized their children
  // in the correct order (as indicated in our model)
  (0,min_dash__WEBPACK_IMPORTED_MODULE_4__.forEach)(parents, function(parent) {

    var children = parent.children;

    if (!children) {
      return;
    }

    var childrenGfx = self._getChildrenContainer(parent);

    (0,min_dash__WEBPACK_IMPORTED_MODULE_4__.forEach)(children.slice().reverse(), function(child) {
      var childGfx = elementRegistry.getGraphics(child);

      prependTo(childGfx.parentNode, childrenGfx);
    });
  });
};

GraphicsFactory.prototype.drawShape = function(visual, element) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.shape', { gfx: visual, element: element });
};

GraphicsFactory.prototype.getShapePath = function(element) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.getShapePath', element);
};

GraphicsFactory.prototype.drawConnection = function(visual, element) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.connection', { gfx: visual, element: element });
};

GraphicsFactory.prototype.getConnectionPath = function(waypoints) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.getConnectionPath', waypoints);
};

GraphicsFactory.prototype.update = function(type, element, gfx) {

  // do NOT update root element
  if (!element.parent) {
    return;
  }

  var visual = this._clear(gfx);

  // redraw
  if (type === 'shape') {
    this.drawShape(visual, element);

    // update positioning
    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__.translate)(gfx, element.x, element.y);
  } else
  if (type === 'connection') {
    this.drawConnection(visual, element);
  } else {
    throw new Error('unknown type: ' + type);
  }

  if (element.hidden) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(gfx, 'display', 'none');
  } else {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(gfx, 'display', 'block');
  }
};

GraphicsFactory.prototype.remove = function(element) {
  var gfx = this._elementRegistry.getGraphics(element);

  // remove
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(gfx.parentNode);
};


// helpers //////////

function prependTo(newNode, parentNode, siblingNode) {
  var node = siblingNode || parentNode.firstChild;

  // do not prepend node to itself to prevent IE from crashing
  // https://github.com/bpmn-io/bpmn-js/issues/746
  if (newNode === node) {
    return;
  }

  parentNode.insertBefore(newNode, node);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/index.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../draw */ "./node_modules/diagram-js/lib/draw/index.js");
/* harmony import */ var _Canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Canvas */ "./node_modules/diagram-js/lib/core/Canvas.js");
/* harmony import */ var _ElementRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ElementRegistry */ "./node_modules/diagram-js/lib/core/ElementRegistry.js");
/* harmony import */ var _ElementFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ElementFactory */ "./node_modules/diagram-js/lib/core/ElementFactory.js");
/* harmony import */ var _EventBus__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EventBus */ "./node_modules/diagram-js/lib/core/EventBus.js");
/* harmony import */ var _GraphicsFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GraphicsFactory */ "./node_modules/diagram-js/lib/core/GraphicsFactory.js");








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [ _draw__WEBPACK_IMPORTED_MODULE_0__.default ],
  __init__: [ 'canvas' ],
  canvas: [ 'type', _Canvas__WEBPACK_IMPORTED_MODULE_1__.default ],
  elementRegistry: [ 'type', _ElementRegistry__WEBPACK_IMPORTED_MODULE_2__.default ],
  elementFactory: [ 'type', _ElementFactory__WEBPACK_IMPORTED_MODULE_3__.default ],
  eventBus: [ 'type', _EventBus__WEBPACK_IMPORTED_MODULE_4__.default ],
  graphicsFactory: [ 'type', _GraphicsFactory__WEBPACK_IMPORTED_MODULE_5__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/BaseRenderer.js":
/*!**********************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/BaseRenderer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseRenderer)
/* harmony export */ });
var DEFAULT_RENDER_PRIORITY = 1000;

/**
 * The base implementation of shape and connection renderers.
 *
 * @param {EventBus} eventBus
 * @param {number} [renderPriority=1000]
 */
function BaseRenderer(eventBus, renderPriority) {
  var self = this;

  renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY;

  eventBus.on([ 'render.shape', 'render.connection' ], renderPriority, function(evt, context) {
    var type = evt.type,
        element = context.element,
        visuals = context.gfx;

    if (self.canRender(element)) {
      if (type === 'render.shape') {
        return self.drawShape(visuals, element);
      } else {
        return self.drawConnection(visuals, element);
      }
    }
  });

  eventBus.on([ 'render.getShapePath', 'render.getConnectionPath'], renderPriority, function(evt, element) {
    if (self.canRender(element)) {
      if (evt.type === 'render.getShapePath') {
        return self.getShapePath(element);
      } else {
        return self.getConnectionPath(element);
      }
    }
  });
}

/**
 * Should check whether *this* renderer can render
 * the element/connection.
 *
 * @param {element} element
 *
 * @returns {boolean}
 */
BaseRenderer.prototype.canRender = function() {};

/**
 * Provides the shape's snap svg element to be drawn on the `canvas`.
 *
 * @param {djs.Graphics} visuals
 * @param {Shape} shape
 *
 * @returns {Snap.svg} [returns a Snap.svg paper element ]
 */
BaseRenderer.prototype.drawShape = function() {};

/**
 * Provides the shape's snap svg element to be drawn on the `canvas`.
 *
 * @param {djs.Graphics} visuals
 * @param {Connection} connection
 *
 * @returns {Snap.svg} [returns a Snap.svg paper element ]
 */
BaseRenderer.prototype.drawConnection = function() {};

/**
 * Gets the SVG path of a shape that represents it's visual bounds.
 *
 * @param {Shape} shape
 *
 * @return {string} svg path
 */
BaseRenderer.prototype.getShapePath = function() {};

/**
 * Gets the SVG path of a connection that represents it's visual bounds.
 *
 * @param {Connection} connection
 *
 * @return {string} svg path
 */
BaseRenderer.prototype.getConnectionPath = function() {};


/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/DefaultRenderer.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/DefaultRenderer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DefaultRenderer)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseRenderer */ "./node_modules/diagram-js/lib/draw/BaseRenderer.js");
/* harmony import */ var _util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/RenderUtil */ "./node_modules/diagram-js/lib/util/RenderUtil.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");










// apply default renderer with lowest possible priority
// so that it only kicks in if noone else could render
var DEFAULT_RENDER_PRIORITY = 1;

/**
 * The default renderer used for shapes and connections.
 *
 * @param {EventBus} eventBus
 * @param {Styles} styles
 */
function DefaultRenderer(eventBus, styles) {

  //
  _BaseRenderer__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus, DEFAULT_RENDER_PRIORITY);

  this.CONNECTION_STYLE = styles.style([ 'no-fill' ], { strokeWidth: 5, stroke: 'fuchsia' });
  this.SHAPE_STYLE = styles.style({ fill: 'white', stroke: 'fuchsia', strokeWidth: 2 });
  this.FRAME_STYLE = styles.style([ 'no-fill' ], { stroke: 'fuchsia', strokeDasharray: 4, strokeWidth: 2 });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(DefaultRenderer, _BaseRenderer__WEBPACK_IMPORTED_MODULE_1__.default);


DefaultRenderer.prototype.canRender = function() {
  return true;
};

DefaultRenderer.prototype.drawShape = function drawShape(visuals, element) {
  var rect = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('rect');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(rect, {
    x: 0,
    y: 0,
    width: element.width || 0,
    height: element.height || 0
  });

  if ((0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.isFrameElement)(element)) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(rect, this.FRAME_STYLE);
  } else {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(rect, this.SHAPE_STYLE);
  }

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(visuals, rect);

  return rect;
};

DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection) {

  var line = (0,_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__.createLine)(connection.waypoints, this.CONNECTION_STYLE);
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(visuals, line);

  return line;
};

DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {

  var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;

  var shapePath = [
    ['M', x, y],
    ['l', width, 0],
    ['l', 0, height],
    ['l', -width, 0],
    ['z']
  ];

  return (0,_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__.componentsToPath)(shapePath);
};

DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {
  var waypoints = connection.waypoints;

  var idx, point, connectionPath = [];

  for (idx = 0; (point = waypoints[idx]); idx++) {

    // take invisible docking into account
    // when creating the path
    point = point.original || point;

    connectionPath.push([ idx === 0 ? 'M' : 'L', point.x, point.y ]);
  }

  return (0,_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__.componentsToPath)(connectionPath);
};


DefaultRenderer.$inject = [ 'eventBus', 'styles' ];


/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/Styles.js":
/*!****************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/Styles.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Styles)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A component that manages shape styles
 */
function Styles() {

  var defaultTraits = {

    'no-fill': {
      fill: 'none'
    },
    'no-border': {
      strokeOpacity: 0.0
    },
    'no-events': {
      pointerEvents: 'none'
    }
  };

  var self = this;

  /**
   * Builds a style definition from a className, a list of traits and an object of additional attributes.
   *
   * @param  {string} className
   * @param  {Array<string>} traits
   * @param  {Object} additionalAttrs
   *
   * @return {Object} the style defintion
   */
  this.cls = function(className, traits, additionalAttrs) {
    var attrs = this.style(traits, additionalAttrs);

    return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(attrs, { 'class': className });
  };

  /**
   * Builds a style definition from a list of traits and an object of additional attributes.
   *
   * @param  {Array<string>} traits
   * @param  {Object} additionalAttrs
   *
   * @return {Object} the style defintion
   */
  this.style = function(traits, additionalAttrs) {

    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(traits) && !additionalAttrs) {
      additionalAttrs = traits;
      traits = [];
    }

    var attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(traits, function(attrs, t) {
      return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(attrs, defaultTraits[t] || {});
    }, {});

    return additionalAttrs ? (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(attrs, additionalAttrs) : attrs;
  };

  this.computeStyle = function(custom, traits, defaultStyles) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(traits)) {
      defaultStyles = traits;
      traits = [];
    }

    return self.style(traits || [], (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, defaultStyles, custom || {}));
  };
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/index.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DefaultRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultRenderer */ "./node_modules/diagram-js/lib/draw/DefaultRenderer.js");
/* harmony import */ var _Styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Styles */ "./node_modules/diagram-js/lib/draw/Styles.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'defaultRenderer' ],
  defaultRenderer: [ 'type', _DefaultRenderer__WEBPACK_IMPORTED_MODULE_0__.default ],
  styles: [ 'type', _Styles__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/align-elements/AlignElements.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/align-elements/AlignElements.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AlignElements)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


function last(arr) {
  return arr && arr[arr.length - 1];
}

function sortTopOrMiddle(element) {
  return element.y;
}

function sortLeftOrCenter(element) {
  return element.x;
}

/**
 * Sorting functions for different types of alignment
 *
 * @type {Object}
 *
 * @return {Function}
 */
var ALIGNMENT_SORTING = {
  left: sortLeftOrCenter,
  center: sortLeftOrCenter,
  right: function(element) {
    return element.x + element.width;
  },
  top: sortTopOrMiddle,
  middle: sortTopOrMiddle,
  bottom: function(element) {
    return element.y + element.height;
  }
};


function AlignElements(modeling) {
  this._modeling = modeling;
}

AlignElements.$inject = [ 'modeling' ];


/**
 * Get the relevant "axis" and "dimension" related to the current type of alignment
 *
 * @param  {string} type left|right|center|top|bottom|middle
 *
 * @return {Object} { axis, dimension }
 */
AlignElements.prototype._getOrientationDetails = function(type) {
  var vertical = [ 'top', 'bottom', 'middle' ],
      axis = 'x',
      dimension = 'width';

  if (vertical.indexOf(type) !== -1) {
    axis = 'y';
    dimension = 'height';
  }

  return {
    axis: axis,
    dimension: dimension
  };
};

AlignElements.prototype._isType = function(type, types) {
  return types.indexOf(type) !== -1;
};

/**
 * Get a point on the relevant axis where elements should align to
 *
 * @param  {string} type left|right|center|top|bottom|middle
 * @param  {Array} sortedElements
 *
 * @return {Object}
 */
AlignElements.prototype._alignmentPosition = function(type, sortedElements) {
  var orientation = this._getOrientationDetails(type),
      axis = orientation.axis,
      dimension = orientation.dimension,
      alignment = {},
      centers = {},
      hasSharedCenters = false,
      centeredElements,
      firstElement,
      lastElement;

  function getMiddleOrTop(first, last) {
    return Math.round((first[axis] + last[axis] + last[dimension]) / 2);
  }

  if (this._isType(type, [ 'left', 'top' ])) {
    alignment[type] = sortedElements[0][axis];

  } else if (this._isType(type, [ 'right', 'bottom' ])) {
    lastElement = last(sortedElements);

    alignment[type] = lastElement[axis] + lastElement[dimension];

  } else if (this._isType(type, [ 'center', 'middle' ])) {

    // check if there is a center shared by more than one shape
    // if not, just take the middle of the range
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(sortedElements, function(element) {
      var center = element[axis] + Math.round(element[dimension] / 2);

      if (centers[center]) {
        centers[center].elements.push(element);
      } else {
        centers[center] = {
          elements: [ element ],
          center: center
        };
      }
    });

    centeredElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(centers, function(center) {
      if (center.elements.length > 1) {
        hasSharedCenters = true;
      }

      return center.elements.length;
    });

    if (hasSharedCenters) {
      alignment[type] = last(centeredElements).center;

      return alignment;
    }

    firstElement = sortedElements[0];

    sortedElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(sortedElements, function(element) {
      return element[axis] + element[dimension];
    });

    lastElement = last(sortedElements);

    alignment[type] = getMiddleOrTop(firstElement, lastElement);
  }

  return alignment;
};

/**
 * Executes the alignment of a selection of elements
 *
 * @param  {Array} elements [description]
 * @param  {string} type left|right|center|top|bottom|middle
 */
AlignElements.prototype.trigger = function(elements, type) {
  var modeling = this._modeling;

  var filteredElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.filter)(elements, function(element) {
    return !(element.waypoints || element.host || element.labelTarget);
  });

  if (filteredElements.length < 2) {
    return;
  }

  var sortFn = ALIGNMENT_SORTING[type];

  var sortedElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(filteredElements, sortFn);

  var alignment = this._alignmentPosition(type, sortedElements);

  modeling.alignElements(sortedElements, alignment);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/align-elements/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/align-elements/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AlignElements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignElements */ "./node_modules/diagram-js/lib/features/align-elements/AlignElements.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'alignElements' ],
  alignElements: [ 'type', _AlignElements__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/attach-support/AttachSupport.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/attach-support/AttachSupport.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AttachSupport)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Removal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Removal */ "./node_modules/diagram-js/lib/util/Removal.js");
/* harmony import */ var _util_AttachUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/AttachUtil */ "./node_modules/diagram-js/lib/util/AttachUtil.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");










var LOW_PRIORITY = 251,
    HIGH_PRIORITY = 1401;

var MARKER_ATTACH = 'attach-ok';


/**
 * Adds the notion of attached elements to the modeler.
 *
 * Optionally depends on `diagram-js/lib/features/move` to render
 * the attached elements during move preview.
 *
 * Optionally depends on `diagram-js/lib/features/label-support`
 * to render attached labels during move preview.
 *
 * @param {didi.Injector} injector
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {Rules} rules
 * @param {Modeling} modeling
 */
function AttachSupport(injector, eventBus, canvas, rules, modeling) {

  _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  var movePreview = injector.get('movePreview', false);


  // remove all the attached elements from the shapes to be validated
  // add all the attached shapes to the overall list of moved shapes
  eventBus.on('shape.move.start', HIGH_PRIORITY, function(e) {

    var context = e.context,
        shapes = context.shapes,
        validatedShapes = context.validatedShapes;

    context.shapes = addAttached(shapes);

    context.validatedShapes = removeAttached(validatedShapes);
  });

  // add attachers to the visual's group
  movePreview && eventBus.on('shape.move.start', LOW_PRIORITY, function(e) {

    var context = e.context,
        shapes = context.shapes,
        attachers = getAttachers(shapes);

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attachers, function(attacher) {
      movePreview.makeDraggable(context, attacher, true);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attacher.labels, function(label) {
        movePreview.makeDraggable(context, label, true);
      });
    });
  });

  // add attach-ok marker to current host
  movePreview && eventBus.on('shape.move.start', function(event) {
    var context = event.context,
        shapes = context.shapes;

    if (shapes.length !== 1) {
      return;
    }

    var shape = shapes[0];

    var host = shape.host;

    if (host) {
      canvas.addMarker(host, MARKER_ATTACH);

      eventBus.once([
        'shape.move.out',
        'shape.move.cleanup'
      ], function() {
        canvas.removeMarker(host, MARKER_ATTACH);
      });
    }
  });

  // add all attachers to move closure
  this.preExecuted('elements.move', HIGH_PRIORITY, function(e) {
    var context = e.context,
        closure = context.closure,
        shapes = context.shapes,
        attachers = getAttachers(shapes);

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attachers, function(attacher) {
      closure.add(attacher, closure.topLevel[attacher.host.id]);
    });
  });

  // perform the attaching after shapes are done moving
  this.postExecuted('elements.move', function(e) {

    var context = e.context,
        shapes = context.shapes,
        newHost = context.newHost,
        attachers;

    // only single elements can be attached
    // multiply elements can be detached
    if (newHost && shapes.length !== 1) {
      return;
    }

    if (newHost) {
      attachers = shapes;
    } else {

      // find attachers moved without host
      attachers = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(shapes, function(shape) {
        var host = shape.host;

        return isAttacher(shape) && !includes(shapes, host);
      });
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attachers, function(attacher) {
      modeling.updateAttachment(attacher, newHost);
    });
  });

  // ensure invalid attachment connections are removed
  this.postExecuted('elements.move', function(e) {

    var shapes = e.context.shapes;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(shapes, function(shape) {

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(shape.attachers, function(attacher) {

        // remove invalid outgoing connections
        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attacher.outgoing.slice(), function(connection) {
          var allowed = rules.allowed('connection.reconnect', {
            connection: connection,
            source: connection.source,
            target: connection.target
          });

          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });

        // remove invalid incoming connections
        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attacher.incoming.slice(), function(connection) {
          var allowed = rules.allowed('connection.reconnect', {
            connection: connection,
            source: connection.source,
            target: connection.target
          });

          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
      });
    });
  });

  this.postExecute('shape.create', function(e) {
    var context = e.context,
        shape = context.shape,
        host = context.host;

    if (host) {
      modeling.updateAttachment(shape, host);
    }
  });

  // update attachments if the host is replaced
  this.postExecute('shape.replace', function(e) {

    var context = e.context,
        oldShape = context.oldShape,
        newShape = context.newShape;

    // move the attachers to the new host
    (0,_util_Removal__WEBPACK_IMPORTED_MODULE_3__.saveClear)(oldShape.attachers, function(attacher) {
      var allowed = rules.allowed('elements.move', {
        target: newShape,
        shapes: [attacher]
      });

      if (allowed === 'attach') {
        modeling.updateAttachment(attacher, newShape);
      } else {
        modeling.removeShape(attacher);
      }
    });

    // move attachers if new host has different size
    if (newShape.attachers.length) {

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(newShape.attachers, function(attacher) {
        var delta = (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_4__.getNewAttachShapeDelta)(attacher, oldShape, newShape);
        modeling.moveShape(attacher, delta, attacher.parent);
      });
    }

  });

  // move shape on host resize
  this.postExecute('shape.resize', function(event) {
    var context = event.context,
        shape = context.shape,
        oldBounds = context.oldBounds,
        newBounds = context.newBounds,
        attachers = shape.attachers,
        hints = context.hints || {};

    if (hints.attachSupport === false) {
      return;
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attachers, function(attacher) {
      var delta = (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_4__.getNewAttachShapeDelta)(attacher, oldBounds, newBounds);

      modeling.moveShape(attacher, delta, attacher.parent);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attacher.labels, function(label) {
        modeling.moveShape(label, delta, label.parent);
      });
    });
  });

  // remove attachments
  this.preExecute('shape.delete', function(event) {

    var shape = event.context.shape;

    (0,_util_Removal__WEBPACK_IMPORTED_MODULE_3__.saveClear)(shape.attachers, function(attacher) {
      modeling.removeShape(attacher);
    });

    if (shape.host) {
      modeling.updateAttachment(shape, null);
    }
  });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(AttachSupport, _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

AttachSupport.$inject = [
  'injector',
  'eventBus',
  'canvas',
  'rules',
  'modeling'
];


/**
 * Return attachers of the given shapes
 *
 * @param {Array<djs.model.Base>} shapes
 * @return {Array<djs.model.Base>}
 */
function getAttachers(shapes) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.flatten)((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.map)(shapes, function(s) {
    return s.attachers || [];
  }));
}

/**
 * Return a combined list of elements and
 * attachers.
 *
 * @param {Array<djs.model.Base>} elements
 * @return {Array<djs.model.Base>} filtered
 */
function addAttached(elements) {
  var attachers = getAttachers(elements);

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.unionBy)('id', elements, attachers);
}

/**
 * Return a filtered list of elements that do not
 * contain attached elements with hosts being part
 * of the selection.
 *
 * @param  {Array<djs.model.Base>} elements
 *
 * @return {Array<djs.model.Base>} filtered
 */
function removeAttached(elements) {

  var ids = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.groupBy)(elements, 'id');

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(elements, function(element) {
    while (element) {

      // host in selection
      if (element.host && ids[element.host.id]) {
        return false;
      }

      element = element.parent;
    }

    return true;
  });
}

function isAttacher(shape) {
  return !!shape.host;
}

function includes(array, item) {
  return array.indexOf(item) !== -1;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/attach-support/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/attach-support/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _AttachSupport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AttachSupport */ "./node_modules/diagram-js/lib/features/attach-support/AttachSupport.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _rules__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'attachSupport' ],
  attachSupport: [ 'type', _AttachSupport__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js":
/*!************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AutoScroll)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");





/**
 * Initiates canvas scrolling if current cursor point is close to a border.
 * Cancelled when current point moves back inside the scrolling borders
 * or cancelled manually.
 *
 * Default options :
 *   scrollThresholdIn: [ 20, 20, 20, 20 ],
 *   scrollThresholdOut: [ 0, 0, 0, 0 ],
 *   scrollRepeatTimeout: 15,
 *   scrollStep: 10
 *
 * Threshold order:
 *   [ left, top, right, bottom ]
 */
function AutoScroll(config, eventBus, canvas) {

  this._canvas = canvas;

  this._opts = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
    scrollThresholdIn: [ 20, 20, 20, 20 ],
    scrollThresholdOut: [ 0, 0, 0, 0 ],
    scrollRepeatTimeout: 15,
    scrollStep: 10
  }, config);

  var self = this;

  eventBus.on('drag.move', function(e) {
    var point = self._toBorderPoint(e);

    self.startScroll(point);
  });

  eventBus.on([ 'drag.cleanup' ], function() {
    self.stopScroll();
  });
}

AutoScroll.$inject = [
  'config.autoScroll',
  'eventBus',
  'canvas'
];


/**
 * Starts scrolling loop.
 * Point is given in global scale in canvas container box plane.
 *
 * @param  {Object} point { x: X, y: Y }
 */
AutoScroll.prototype.startScroll = function(point) {

  var canvas = this._canvas;
  var opts = this._opts;
  var self = this;

  var clientRect = canvas.getContainer().getBoundingClientRect();

  var diff = [
    point.x,
    point.y,
    clientRect.width - point.x,
    clientRect.height - point.y
  ];

  this.stopScroll();

  var dx = 0,
      dy = 0;

  for (var i = 0; i < 4; i++) {
    if (between(diff[i], opts.scrollThresholdOut[i], opts.scrollThresholdIn[i])) {
      if (i === 0) {
        dx = opts.scrollStep;
      } else if (i == 1) {
        dy = opts.scrollStep;
      } else if (i == 2) {
        dx = -opts.scrollStep;
      } else if (i == 3) {
        dy = -opts.scrollStep;
      }
    }
  }

  if (dx !== 0 || dy !== 0) {
    canvas.scroll({ dx: dx, dy: dy });

    this._scrolling = setTimeout(function() {
      self.startScroll(point);
    }, opts.scrollRepeatTimeout);
  }
};

function between(val, start, end) {
  if (start < val && val < end) {
    return true;
  }

  return false;
}


/**
 * Stops scrolling loop.
 */
AutoScroll.prototype.stopScroll = function() {
  clearTimeout(this._scrolling);
};


/**
 * Overrides defaults options.
 *
 * @param  {Object} options
 */
AutoScroll.prototype.setOptions = function(options) {
  this._opts = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, this._opts, options);
};


/**
 * Converts event to a point in canvas container plane in global scale.
 *
 * @param  {Event} event
 * @return {Point}
 */
AutoScroll.prototype._toBorderPoint = function(event) {
  var clientRect = this._canvas._container.getBoundingClientRect();

  var globalPosition = (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.toPoint)(event.originalEvent);

  return {
    x: globalPosition.x - clientRect.left,
    y: globalPosition.y - clientRect.top
  };
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/auto-scroll/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/auto-scroll/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _AutoScroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AutoScroll */ "./node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _dragging__WEBPACK_IMPORTED_MODULE_0__.default,
  ],
  __init__: [ 'autoScroll' ],
  autoScroll: [ 'type', _AutoScroll__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BendpointMove),
/* harmony export */   "isReverse": () => (/* binding */ isReverse)
/* harmony export */ });
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");


var round = Math.round;

var RECONNECT_START = 'reconnectStart',
    RECONNECT_END = 'reconnectEnd',
    UPDATE_WAYPOINTS = 'updateWaypoints';


/**
 * Move bendpoints through drag and drop to add/remove bendpoints or reconnect connection.
 */
function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {
  this._injector = injector;

  this.start = function(event, connection, bendpointIndex, insert) {
    var gfx = canvas.getGraphics(connection),
        source = connection.source,
        target = connection.target,
        waypoints = connection.waypoints,
        type;

    if (!insert && bendpointIndex === 0) {
      type = RECONNECT_START;
    } else
    if (!insert && bendpointIndex === waypoints.length - 1) {
      type = RECONNECT_END;
    } else {
      type = UPDATE_WAYPOINTS;
    }

    var command = type === UPDATE_WAYPOINTS ? 'connection.updateWaypoints' : 'connection.reconnect';

    var allowed = rules.allowed(command, {
      connection: connection,
      source: source,
      target: target
    });

    if (allowed === false) {
      allowed = rules.allowed(command, {
        connection: connection,
        source: target,
        target: source
      });
    }

    if (allowed === false) {
      return;
    }

    dragging.init(event, 'bendpoint.move', {
      data: {
        connection: connection,
        connectionGfx: gfx,
        context: {
          allowed: allowed,
          bendpointIndex: bendpointIndex,
          connection: connection,
          source: source,
          target: target,
          insert: insert,
          type: type
        }
      }
    });
  };

  eventBus.on('bendpoint.move.hover', function(event) {
    var context = event.context,
        connection = context.connection,
        source = connection.source,
        target = connection.target,
        hover = event.hover,
        type = context.type;

    // cache hover state
    context.hover = hover;

    var allowed;

    if (!hover) {
      return;
    }

    var command = type === UPDATE_WAYPOINTS ? 'connection.updateWaypoints' : 'connection.reconnect';

    allowed = context.allowed = rules.allowed(command, {
      connection: connection,
      source: type === RECONNECT_START ? hover : source,
      target: type === RECONNECT_END ? hover : target
    });

    if (allowed) {
      context.source = type === RECONNECT_START ? hover : source;
      context.target = type === RECONNECT_END ? hover : target;

      return;
    }

    if (allowed === false) {
      allowed = context.allowed = rules.allowed(command, {
        connection: connection,
        source: type === RECONNECT_END ? hover : target,
        target: type === RECONNECT_START ? hover : source
      });
    }

    if (allowed) {
      context.source = type === RECONNECT_END ? hover : target;
      context.target = type === RECONNECT_START ? hover : source;
    }
  });

  eventBus.on([ 'bendpoint.move.out', 'bendpoint.move.cleanup' ], function(event) {
    var context = event.context,
        type = context.type;

    context.hover = null;
    context.source = null;
    context.target = null;

    if (type !== UPDATE_WAYPOINTS) {
      context.allowed = false;
    }
  });

  eventBus.on('bendpoint.move.end', function(event) {
    var context = event.context,
        allowed = context.allowed,
        bendpointIndex = context.bendpointIndex,
        connection = context.connection,
        insert = context.insert,
        newWaypoints = connection.waypoints.slice(),
        source = context.source,
        target = context.target,
        type = context.type,
        hints = context.hints || {};

    // ensure integer values (important if zoom level was > 1 during move)
    var docking = {
      x: round(event.x),
      y: round(event.y)
    };

    if (!allowed) {
      return false;
    }

    if (type === UPDATE_WAYPOINTS) {
      if (insert) {

        // insert new bendpoint
        newWaypoints.splice(bendpointIndex, 0, docking);
      } else {

        // swap previous waypoint with moved one
        newWaypoints[bendpointIndex] = docking;
      }

      // pass hints about actual moved bendpoint
      // useful for connection/label layout
      hints.bendpointMove = {
        insert: insert,
        bendpointIndex: bendpointIndex
      };

      newWaypoints = this.cropWaypoints(connection, newWaypoints);

      modeling.updateWaypoints(connection, (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.filterRedundantWaypoints)(newWaypoints), hints);
    } else {
      if (type === RECONNECT_START) {
        hints.docking = 'source';

        if (isReverse(context)) {
          hints.docking = 'target';

          hints.newWaypoints = newWaypoints.reverse();
        }
      } else if (type === RECONNECT_END) {
        hints.docking = 'target';

        if (isReverse(context)) {
          hints.docking = 'source';

          hints.newWaypoints = newWaypoints.reverse();
        }
      }

      modeling.reconnect(connection, source, target, docking, hints);
    }
  }, this);
}

BendpointMove.$inject = [
  'injector',
  'eventBus',
  'canvas',
  'dragging',
  'rules',
  'modeling'
];

BendpointMove.prototype.cropWaypoints = function(connection, newWaypoints) {
  var connectionDocking = this._injector.get('connectionDocking', false);

  if (!connectionDocking) {
    return newWaypoints;
  }

  var waypoints = connection.waypoints;

  connection.waypoints = newWaypoints;

  connection.waypoints = connectionDocking.getCroppedWaypoints(connection);

  newWaypoints = connection.waypoints;

  connection.waypoints = waypoints;

  return newWaypoints;
};


// helpers //////////

function isReverse(context) {
  var hover = context.hover,
      source = context.source,
      target = context.target,
      type = context.type;

  if (type === RECONNECT_START) {
    return hover && target && hover === target && source !== target;
  }

  if (type === RECONNECT_END) {
    return hover && source && hover === source && source !== target;
  }
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/BendpointMovePreview.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/BendpointMovePreview.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BendpointMovePreview)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _BendpointUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BendpointUtil */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var _BendpointMove__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BendpointMove */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js");








var RECONNECT_START = 'reconnectStart',
    RECONNECT_END = 'reconnectEnd',
    UPDATE_WAYPOINTS = 'updateWaypoints';

var MARKER_OK = 'connect-ok',
    MARKER_NOT_OK = 'connect-not-ok',
    MARKER_CONNECT_HOVER = 'connect-hover',
    MARKER_CONNECT_UPDATING = 'djs-updating',
    MARKER_ELEMENT_HIDDEN = 'djs-element-hidden';

var HIGH_PRIORITY = 1100;

/**
 * Preview connection while moving bendpoints.
 */
function BendpointMovePreview(bendpointMove, injector, eventBus, canvas) {
  this._injector = injector;

  var connectionPreview = injector.get('connectionPreview', false);

  eventBus.on('bendpoint.move.start', function(event) {
    var context = event.context,
        bendpointIndex = context.bendpointIndex,
        connection = context.connection,
        insert = context.insert,
        waypoints = connection.waypoints,
        newWaypoints = waypoints.slice();

    context.waypoints = waypoints;

    if (insert) {

      // insert placeholder for new bendpoint
      newWaypoints.splice(bendpointIndex, 0, { x: event.x, y: event.y });
    }

    connection.waypoints = newWaypoints;

    // add dragger gfx
    var draggerGfx = context.draggerGfx = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_0__.addBendpoint)(canvas.getLayer('overlays'));

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(draggerGfx).add('djs-dragging');

    canvas.addMarker(connection, MARKER_ELEMENT_HIDDEN);
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
  });

  eventBus.on('bendpoint.move.hover', function(event) {
    var context = event.context,
        allowed = context.allowed,
        hover = context.hover,
        type = context.type;

    if (hover) {
      canvas.addMarker(hover, MARKER_CONNECT_HOVER);

      if (type === UPDATE_WAYPOINTS) {
        return;
      }

      if (allowed) {
        canvas.removeMarker(hover, MARKER_NOT_OK);
        canvas.addMarker(hover, MARKER_OK);
      } else if (allowed === false) {
        canvas.removeMarker(hover, MARKER_OK);
        canvas.addMarker(hover, MARKER_NOT_OK);
      }
    }
  });

  eventBus.on([
    'bendpoint.move.out',
    'bendpoint.move.cleanup'
  ], HIGH_PRIORITY, function(event) {
    var context = event.context,
        hover = context.hover,
        target = context.target;

    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);
    }
  });

  eventBus.on('bendpoint.move.move', function(event) {
    var context = event.context,
        allowed = context.allowed,
        bendpointIndex = context.bendpointIndex,
        draggerGfx = context.draggerGfx,
        hover = context.hover,
        type = context.type,
        connection = context.connection,
        source = connection.source,
        target = connection.target,
        newWaypoints = connection.waypoints.slice(),
        bendpoint = { x: event.x, y: event.y },
        hints = context.hints || {},
        drawPreviewHints = {};

    if (connectionPreview) {
      if (hints.connectionStart) {
        drawPreviewHints.connectionStart = hints.connectionStart;
      }

      if (hints.connectionEnd) {
        drawPreviewHints.connectionEnd = hints.connectionEnd;
      }


      if (type === RECONNECT_START) {
        if ((0,_BendpointMove__WEBPACK_IMPORTED_MODULE_2__.isReverse)(context)) {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;

          drawPreviewHints.source = target;
          drawPreviewHints.target = hover || source;

          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;

          drawPreviewHints.source = hover || source;
          drawPreviewHints.target = target;
        }
      } else if (type === RECONNECT_END) {
        if ((0,_BendpointMove__WEBPACK_IMPORTED_MODULE_2__.isReverse)(context)) {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;

          drawPreviewHints.source = hover || target;
          drawPreviewHints.target = source;

          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;

          drawPreviewHints.source = source;
          drawPreviewHints.target = hover || target;
        }

      } else {
        drawPreviewHints.noCropping = true;
        drawPreviewHints.noLayout = true;
        newWaypoints[ bendpointIndex ] = bendpoint;
      }

      if (type === UPDATE_WAYPOINTS) {
        newWaypoints = bendpointMove.cropWaypoints(connection, newWaypoints);
      }

      drawPreviewHints.waypoints = newWaypoints;

      connectionPreview.drawPreview(context, allowed, drawPreviewHints);
    }

    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__.translate)(draggerGfx, event.x, event.y);
  }, this);

  eventBus.on([
    'bendpoint.move.end',
    'bendpoint.move.cancel'
  ], HIGH_PRIORITY, function(event) {
    var context = event.context,
        connection = context.connection,
        draggerGfx = context.draggerGfx,
        hover = context.hover,
        target = context.target,
        waypoints = context.waypoints;

    connection.waypoints = waypoints;

    // remove dragger gfx
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(draggerGfx);

    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
    canvas.removeMarker(connection, MARKER_ELEMENT_HIDDEN);

    if (hover) {
      canvas.removeMarker(hover, MARKER_OK);
      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);
    }

    if (connectionPreview) {
      connectionPreview.cleanUp(context);
    }
  });
}

BendpointMovePreview.$inject = [
  'bendpointMove',
  'injector',
  'eventBus',
  'canvas'
];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BendpointSnapping)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _snapping_SnapUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../snapping/SnapUtil */ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js");




var abs= Math.abs,
    round = Math.round;

var TOLERANCE = 10;


function BendpointSnapping(eventBus) {

  function snapTo(values, value) {

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(values)) {
      var i = values.length;

      while (i--) if (abs(values[i] - value) <= TOLERANCE) {
        return values[i];
      }
    } else {
      values = +values;
      var rem = value % values;

      if (rem < TOLERANCE) {
        return value - rem;
      }

      if (rem > values - TOLERANCE) {
        return value - rem + values;
      }
    }

    return value;
  }

  function mid(element) {
    if (element.width) {
      return {
        x: round(element.width / 2 + element.x),
        y: round(element.height / 2 + element.y)
      };
    }
  }

  // connection segment snapping //////////////////////

  function getConnectionSegmentSnaps(context) {

    var snapPoints = context.snapPoints,
        connection = context.connection,
        waypoints = connection.waypoints,
        segmentStart = context.segmentStart,
        segmentStartIndex = context.segmentStartIndex,
        segmentEnd = context.segmentEnd,
        segmentEndIndex = context.segmentEndIndex,
        axis = context.axis;

    if (snapPoints) {
      return snapPoints;
    }

    var referenceWaypoints = [
      waypoints[segmentStartIndex - 1],
      segmentStart,
      segmentEnd,
      waypoints[segmentEndIndex + 1]
    ];

    if (segmentStartIndex < 2) {
      referenceWaypoints.unshift(mid(connection.source));
    }

    if (segmentEndIndex > waypoints.length - 3) {
      referenceWaypoints.unshift(mid(connection.target));
    }

    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(referenceWaypoints, function(p) {

      // we snap on existing bendpoints only,
      // not placeholders that are inserted during add
      if (p) {
        p = p.original || p;

        if (axis === 'y') {
          snapPoints.horizontal.push(p.y);
        }

        if (axis === 'x') {
          snapPoints.vertical.push(p.x);
        }
      }
    });

    return snapPoints;
  }

  eventBus.on('connectionSegment.move.move', 1500, function(event) {
    var context = event.context,
        snapPoints = getConnectionSegmentSnaps(context),
        x = event.x,
        y = event.y,
        sx, sy;

    if (!snapPoints) {
      return;
    }

    // snap
    sx = snapTo(snapPoints.vertical, x);
    sy = snapTo(snapPoints.horizontal, y);


    // correction x/y
    var cx = (x - sx),
        cy = (y - sy);

    // update delta
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(event, {
      dx: event.dx - cx,
      dy: event.dy - cy,
      x: sx,
      y: sy
    });

    // only set snapped if actually snapped
    if (cx || snapPoints.vertical.indexOf(x) !== -1) {
      (0,_snapping_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'x', sx);
    }

    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {
      (0,_snapping_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'y', sy);
    }
  });


  // bendpoint snapping //////////////////////

  function getBendpointSnaps(context) {

    var snapPoints = context.snapPoints,
        waypoints = context.connection.waypoints,
        bendpointIndex = context.bendpointIndex;

    if (snapPoints) {
      return snapPoints;
    }

    var referenceWaypoints = [ waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1] ];

    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(referenceWaypoints, function(p) {

      // we snap on existing bendpoints only,
      // not placeholders that are inserted during add
      if (p) {
        p = p.original || p;

        snapPoints.horizontal.push(p.y);
        snapPoints.vertical.push(p.x);
      }
    });

    return snapPoints;
  }


  eventBus.on([ 'bendpoint.move.move', 'bendpoint.move.end' ], 1500, function(event) {

    var context = event.context,
        snapPoints = getBendpointSnaps(context),
        hover = context.hover,
        hoverMid = hover && mid(hover),
        x = event.x,
        y = event.y,
        sx, sy;

    if (!snapPoints) {
      return;
    }

    // snap to hover mid
    sx = snapTo(hoverMid ? snapPoints.vertical.concat([ hoverMid.x ]) : snapPoints.vertical, x);
    sy = snapTo(hoverMid ? snapPoints.horizontal.concat([ hoverMid.y ]) : snapPoints.horizontal, y);

    // correction x/y
    var cx = (x - sx),
        cy = (y - sy);

    // update delta
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(event, {
      dx: event.dx - cx,
      dy: event.dy - cy,
      x: event.x - cx,
      y: event.y - cy
    });

    // only set snapped if actually snapped
    if (cx || snapPoints.vertical.indexOf(x) !== -1) {
      (0,_snapping_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'x', sx);
    }

    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {
      (0,_snapping_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'y', sy);
    }
  });
}


BendpointSnapping.$inject = [ 'eventBus' ];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BENDPOINT_CLS": () => (/* binding */ BENDPOINT_CLS),
/* harmony export */   "SEGMENT_DRAGGER_CLS": () => (/* binding */ SEGMENT_DRAGGER_CLS),
/* harmony export */   "toCanvasCoordinates": () => (/* binding */ toCanvasCoordinates),
/* harmony export */   "getConnectionIntersection": () => (/* binding */ getConnectionIntersection),
/* harmony export */   "addBendpoint": () => (/* binding */ addBendpoint),
/* harmony export */   "addSegmentDragger": () => (/* binding */ addSegmentDragger),
/* harmony export */   "calculateSegmentMoveRegion": () => (/* binding */ calculateSegmentMoveRegion)
/* harmony export */ });
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");
/* harmony import */ var _util_Geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Geometry */ "./node_modules/diagram-js/lib/util/Geometry.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var _util_LineIntersection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/LineIntersection */ "./node_modules/diagram-js/lib/util/LineIntersection.js");










var BENDPOINT_CLS = 'djs-bendpoint';
var SEGMENT_DRAGGER_CLS = 'djs-segment-dragger';

function toCanvasCoordinates(canvas, event) {

  var position = (0,_util_Event__WEBPACK_IMPORTED_MODULE_0__.toPoint)(event),
      clientRect = canvas._container.getBoundingClientRect(),
      offset;

  // canvas relative position

  offset = {
    x: clientRect.left,
    y: clientRect.top
  };

  // update actual event payload with canvas relative measures

  var viewbox = canvas.viewbox();

  return {
    x: viewbox.x + (position.x - offset.x) / viewbox.scale,
    y: viewbox.y + (position.y - offset.y) / viewbox.scale
  };
}

function getConnectionIntersection(canvas, waypoints, event) {
  var localPosition = toCanvasCoordinates(canvas, event),
      intersection = (0,_util_LineIntersection__WEBPACK_IMPORTED_MODULE_1__.getApproxIntersection)(waypoints, localPosition);

  return intersection;
}

function addBendpoint(parentGfx, cls) {
  var groupGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('g');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(groupGfx).add(BENDPOINT_CLS);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(parentGfx, groupGfx);

  var visual = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('circle');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(visual, {
    cx: 0,
    cy: 0,
    r: 4
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(visual).add('djs-visual');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(groupGfx, visual);

  var hit = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('circle');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(hit, {
    cx: 0,
    cy: 0,
    r: 10
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(hit).add('djs-hit');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(groupGfx, hit);

  if (cls) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(groupGfx).add(cls);
  }

  return groupGfx;
}

function createParallelDragger(parentGfx, segmentStart, segmentEnd, alignment) {
  var draggerGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('g');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(parentGfx, draggerGfx);

  var width = 14,
      height = 3,
      padding = 11,
      hitWidth = calculateHitWidth(segmentStart, segmentEnd, alignment),
      hitHeight = height + padding;

  var visual = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('rect');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(visual, {
    x: -width / 2,
    y: -height / 2,
    width: width,
    height: height
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(visual).add('djs-visual');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(draggerGfx, visual);

  var hit = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('rect');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(hit, {
    x: -hitWidth / 2,
    y: -hitHeight / 2,
    width: hitWidth,
    height: hitHeight
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(hit).add('djs-hit');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(draggerGfx, hit);

  (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__.rotate)(draggerGfx, alignment === 'v' ? 90 : 0, 0, 0);

  return draggerGfx;
}


function addSegmentDragger(parentGfx, segmentStart, segmentEnd) {

  var groupGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('g'),
      mid = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_4__.getMidPoint)(segmentStart, segmentEnd),
      alignment = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_4__.pointsAligned)(segmentStart, segmentEnd);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(parentGfx, groupGfx);

  createParallelDragger(groupGfx, segmentStart, segmentEnd, alignment);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(groupGfx).add(SEGMENT_DRAGGER_CLS);
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(groupGfx).add(alignment === 'h' ? 'horizontal' : 'vertical');

  (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__.translate)(groupGfx, mid.x, mid.y);

  return groupGfx;
}

/**
 * Calculates region for segment move which is 2/3 of the full segment length
 * @param {number} segmentLength
 *
 * @return {number}
 */
function calculateSegmentMoveRegion(segmentLength) {
  return Math.abs(Math.round(segmentLength * 2 / 3));
}

// helper //////////

function calculateHitWidth(segmentStart, segmentEnd, alignment) {
  var segmentLengthXAxis = segmentEnd.x - segmentStart.x,
      segmentLengthYAxis = segmentEnd.y - segmentStart.y;

  return alignment === 'h' ?
    calculateSegmentMoveRegion(segmentLengthXAxis) :
    calculateSegmentMoveRegion(segmentLengthYAxis);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js":
/*!***********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Bendpoints)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _BendpointUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BendpointUtil */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js");
/* harmony import */ var _util_EscapeUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/EscapeUtil */ "./node_modules/css.escape/css.escape.js");
/* harmony import */ var _util_EscapeUtil__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_util_EscapeUtil__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _util_Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Geometry */ "./node_modules/diagram-js/lib/util/Geometry.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");

















/**
 * A service that adds editable bendpoints to connections.
 */
function Bendpoints(
    eventBus, canvas, interactionEvents,
    bendpointMove, connectionSegmentMove) {

  /**
   * Returns true if intersection point is inside middle region of segment, adjusted by
   * optional threshold
   */
  function isIntersectionMiddle(intersection, waypoints, treshold) {
    var idx = intersection.index,
        p = intersection.point,
        p0, p1, mid, aligned, xDelta, yDelta;

    if (idx <= 0 || intersection.bendpoint) {
      return false;
    }

    p0 = waypoints[idx - 1];
    p1 = waypoints[idx];
    mid = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.getMidPoint)(p0, p1),
    aligned = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.pointsAligned)(p0, p1);
    xDelta = Math.abs(p.x - mid.x);
    yDelta = Math.abs(p.y - mid.y);

    return aligned && xDelta <= treshold && yDelta <= treshold;
  }

  /**
   * Calculates the threshold from a connection's middle which fits the two-third-region
   */
  function calculateIntersectionThreshold(connection, intersection) {
    var waypoints = connection.waypoints,
        relevantSegment, alignment, segmentLength, threshold;

    if (intersection.index <= 0 || intersection.bendpoint) {
      return null;
    }

    // segment relative to connection intersection
    relevantSegment = {
      start: waypoints[intersection.index - 1],
      end: waypoints[intersection.index]
    };

    alignment = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.pointsAligned)(relevantSegment.start, relevantSegment.end);

    if (!alignment) {
      return null;
    }

    if (alignment === 'h') {
      segmentLength = relevantSegment.end.x - relevantSegment.start.x;
    } else {
      segmentLength = relevantSegment.end.y - relevantSegment.start.y;
    }

    // calculate threshold relative to 2/3 of segment length
    threshold = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.calculateSegmentMoveRegion)(segmentLength) / 2;

    return threshold;
  }

  function activateBendpointMove(event, connection) {
    var waypoints = connection.waypoints,
        intersection = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.getConnectionIntersection)(canvas, waypoints, event),
        threshold;

    if (!intersection) {
      return;
    }

    threshold = calculateIntersectionThreshold(connection, intersection);

    if (isIntersectionMiddle(intersection, waypoints, threshold)) {
      connectionSegmentMove.start(event, connection, intersection.index);
    } else {
      bendpointMove.start(event, connection, intersection.index, !intersection.bendpoint);
    }

    // we've handled the event
    return true;
  }

  function bindInteractionEvents(node, eventName, element) {

    min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(node, eventName, function(event) {
      interactionEvents.triggerMouseEvent(eventName, event, element);
      event.stopPropagation();
    });
  }

  function getBendpointsContainer(element, create) {

    var layer = canvas.getLayer('overlays'),
        gfx = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)('.djs-bendpoints[data-element-id="' + _util_EscapeUtil__WEBPACK_IMPORTED_MODULE_3___default()(element.id) + '"]', layer);

    if (!gfx && create) {
      gfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.create)('g');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.attr)(gfx, { 'data-element-id': element.id });
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.classes)(gfx).add('djs-bendpoints');

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.append)(layer, gfx);

      bindInteractionEvents(gfx, 'mousedown', element);
      bindInteractionEvents(gfx, 'click', element);
      bindInteractionEvents(gfx, 'dblclick', element);
    }

    return gfx;
  }

  function getSegmentDragger(idx, parentGfx) {
    return (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)(
      '.djs-segment-dragger[data-segment-idx="' + idx + '"]',
      parentGfx
    );
  }

  function createBendpoints(gfx, connection) {
    connection.waypoints.forEach(function(p, idx) {
      var bendpoint = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.addBendpoint)(gfx);

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.append)(gfx, bendpoint);

      (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__.translate)(bendpoint, p.x, p.y);
    });

    // add floating bendpoint
    (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.addBendpoint)(gfx, 'floating');
  }

  function createSegmentDraggers(gfx, connection) {

    var waypoints = connection.waypoints;

    var segmentStart,
        segmentEnd,
        segmentDraggerGfx;

    for (var i = 1; i < waypoints.length; i++) {

      segmentStart = waypoints[i - 1];
      segmentEnd = waypoints[i];

      if ((0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.pointsAligned)(segmentStart, segmentEnd)) {
        segmentDraggerGfx = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.addSegmentDragger)(gfx, segmentStart, segmentEnd);

        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.attr)(segmentDraggerGfx, { 'data-segment-idx': i });

        bindInteractionEvents(segmentDraggerGfx, 'mousemove', connection);
      }
    }
  }

  function clearBendpoints(gfx) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_6__.forEach)((0,min_dom__WEBPACK_IMPORTED_MODULE_2__.queryAll)('.' + _BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.BENDPOINT_CLS, gfx), function(node) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.remove)(node);
    });
  }

  function clearSegmentDraggers(gfx) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_6__.forEach)((0,min_dom__WEBPACK_IMPORTED_MODULE_2__.queryAll)('.' + _BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.SEGMENT_DRAGGER_CLS, gfx), function(node) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.remove)(node);
    });
  }

  function addHandles(connection) {

    var gfx = getBendpointsContainer(connection);

    if (!gfx) {
      gfx = getBendpointsContainer(connection, true);

      createBendpoints(gfx, connection);
      createSegmentDraggers(gfx, connection);
    }

    return gfx;
  }

  function updateHandles(connection) {

    var gfx = getBendpointsContainer(connection);

    if (gfx) {
      clearSegmentDraggers(gfx);
      clearBendpoints(gfx);
      createSegmentDraggers(gfx, connection);
      createBendpoints(gfx, connection);
    }
  }

  function updateFloatingBendpointPosition(parentGfx, intersection) {
    var floating = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)('.floating', parentGfx),
        point = intersection.point;

    if (!floating) {
      return;
    }

    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__.translate)(floating, point.x, point.y);

  }

  function updateSegmentDraggerPosition(parentGfx, intersection, waypoints) {

    var draggerGfx = getSegmentDragger(intersection.index, parentGfx),
        segmentStart = waypoints[intersection.index - 1],
        segmentEnd = waypoints[intersection.index],
        point = intersection.point,
        mid = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.getMidPoint)(segmentStart, segmentEnd),
        alignment = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.pointsAligned)(segmentStart, segmentEnd),
        draggerVisual, relativePosition;

    if (!draggerGfx) {
      return;
    }

    draggerVisual = getDraggerVisual(draggerGfx);

    relativePosition = {
      x: point.x - mid.x,
      y: point.y - mid.y
    };

    if (alignment === 'v') {

      // rotate position
      relativePosition = {
        x: relativePosition.y,
        y: relativePosition.x
      };
    }

    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__.translate)(draggerVisual, relativePosition.x, relativePosition.y);
  }

  eventBus.on('connection.changed', function(event) {
    updateHandles(event.element);
  });

  eventBus.on('connection.remove', function(event) {
    var gfx = getBendpointsContainer(event.element);

    if (gfx) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.remove)(gfx);
    }
  });

  eventBus.on('element.marker.update', function(event) {

    var element = event.element,
        bendpointsGfx;

    if (!element.waypoints) {
      return;
    }

    bendpointsGfx = addHandles(element);

    if (event.add) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.classes)(bendpointsGfx).add(event.marker);
    } else {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.classes)(bendpointsGfx).remove(event.marker);
    }
  });

  eventBus.on('element.mousemove', function(event) {

    var element = event.element,
        waypoints = element.waypoints,
        bendpointsGfx,
        intersection;

    if (waypoints) {
      bendpointsGfx = getBendpointsContainer(element, true);

      intersection = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.getConnectionIntersection)(canvas, waypoints, event.originalEvent);

      if (!intersection) {
        return;
      }

      updateFloatingBendpointPosition(bendpointsGfx, intersection);

      if (!intersection.bendpoint) {
        updateSegmentDraggerPosition(bendpointsGfx, intersection, waypoints);
      }

    }
  });

  eventBus.on('element.mousedown', function(event) {

    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_7__.isPrimaryButton)(event)) {
      return;
    }

    var originalEvent = event.originalEvent,
        element = event.element;

    if (!element.waypoints) {
      return;
    }

    return activateBendpointMove(originalEvent, element);
  });

  eventBus.on('selection.changed', function(event) {
    var newSelection = event.newSelection,
        primary = newSelection[0];

    if (primary && primary.waypoints) {
      addHandles(primary);
    }
  });

  eventBus.on('element.hover', function(event) {
    var element = event.element;

    if (element.waypoints) {
      addHandles(element);
      interactionEvents.registerEvent(event.gfx, 'mousemove', 'element.mousemove');
    }
  });

  eventBus.on('element.out', function(event) {
    interactionEvents.unregisterEvent(event.gfx, 'mousemove', 'element.mousemove');
  });

  // update bendpoint container data attribute on element ID change
  eventBus.on('element.updateId', function(context) {
    var element = context.element,
        newId = context.newId;

    if (element.waypoints) {
      var bendpointContainer = getBendpointsContainer(element);

      if (bendpointContainer) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.attr)(bendpointContainer, { 'data-element-id': newId });
      }
    }
  });

  // API

  this.addHandles = addHandles;
  this.updateHandles = updateHandles;
  this.getBendpointsContainer = getBendpointsContainer;
  this.getSegmentDragger = getSegmentDragger;
}

Bendpoints.$inject = [
  'eventBus',
  'canvas',
  'interactionEvents',
  'bendpointMove',
  'connectionSegmentMove'
];



// helper /////////////

function getDraggerVisual(draggerGfx) {
  return (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)('.djs-visual', draggerGfx);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ConnectionSegmentMove)
/* harmony export */ });
/* harmony import */ var _util_Geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Geometry */ "./node_modules/diagram-js/lib/util/Geometry.js");
/* harmony import */ var _BendpointUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BendpointUtil */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");






var MARKER_CONNECT_HOVER = 'connect-hover',
    MARKER_CONNECT_UPDATING = 'djs-updating';






function axisAdd(point, axis, delta) {
  return axisSet(point, axis, point[axis] + delta);
}

function axisSet(point, axis, value) {
  return {
    x: (axis === 'x' ? value : point.x),
    y: (axis === 'y' ? value : point.y)
  };
}

function axisFenced(position, segmentStart, segmentEnd, axis) {

  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),
      minValue = Math.min(segmentStart[axis], segmentEnd[axis]);

  var padding = 20;

  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);

  return axisSet(segmentStart, axis, fencedValue);
}

function flipAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/**
 * Get the docking point on the given element.
 *
 * Compute a reasonable docking, if non exists.
 *
 * @param  {Point} point
 * @param  {djs.model.Shape} referenceElement
 * @param  {string} moveAxis (x|y)
 *
 * @return {Point}
 */
function getDocking(point, referenceElement, moveAxis) {

  var referenceMid,
      inverseAxis;

  if (point.original) {
    return point.original;
  } else {
    referenceMid = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.getMid)(referenceElement);
    inverseAxis = flipAxis(moveAxis);

    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);
  }
}

/**
 * A component that implements moving of bendpoints
 */
function ConnectionSegmentMove(
    injector, eventBus, canvas,
    dragging, graphicsFactory, modeling) {

  // optional connection docking integration
  var connectionDocking = injector.get('connectionDocking', false);


  // API

  this.start = function(event, connection, idx) {

    var context,
        gfx = canvas.getGraphics(connection),
        segmentStartIndex = idx - 1,
        segmentEndIndex = idx,
        waypoints = connection.waypoints,
        segmentStart = waypoints[segmentStartIndex],
        segmentEnd = waypoints[segmentEndIndex],
        intersection = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.getConnectionIntersection)(canvas, waypoints, event),
        direction, axis, dragPosition;

    direction = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_2__.pointsAligned)(segmentStart, segmentEnd);

    // do not move diagonal connection
    if (!direction) {
      return;
    }

    // the axis where we are going to move things
    axis = direction === 'v' ? 'x' : 'y';

    if (segmentStartIndex === 0) {
      segmentStart = getDocking(segmentStart, connection.source, axis);
    }

    if (segmentEndIndex === waypoints.length - 1) {
      segmentEnd = getDocking(segmentEnd, connection.target, axis);
    }

    if (intersection) {
      dragPosition = intersection.point;
    } else {

      // set to segment center as default
      dragPosition = {
        x: (segmentStart.x + segmentEnd.x) / 2,
        y: (segmentStart.y + segmentEnd.y) / 2
      };
    }

    context = {
      connection: connection,
      segmentStartIndex: segmentStartIndex,
      segmentEndIndex: segmentEndIndex,
      segmentStart: segmentStart,
      segmentEnd: segmentEnd,
      axis: axis,
      dragPosition: dragPosition
    };

    dragging.init(event, dragPosition, 'connectionSegment.move', {
      cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',
      data: {
        connection: connection,
        connectionGfx: gfx,
        context: context
      }
    });
  };

  /**
   * Crop connection if connection cropping is provided.
   *
   * @param {Connection} connection
   * @param {Array<Point>} newWaypoints
   *
   * @return {Array<Point>} cropped connection waypoints
   */
  function cropConnection(connection, newWaypoints) {

    // crop connection, if docking service is provided only
    if (!connectionDocking) {
      return newWaypoints;
    }

    var oldWaypoints = connection.waypoints,
        croppedWaypoints;

    // temporary set new waypoints
    connection.waypoints = newWaypoints;

    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);

    // restore old waypoints
    connection.waypoints = oldWaypoints;

    return croppedWaypoints;
  }

  // DRAGGING IMPLEMENTATION

  function redrawConnection(data) {
    graphicsFactory.update('connection', data.connection, data.connectionGfx);
  }

  function updateDragger(context, segmentOffset, event) {

    var newWaypoints = context.newWaypoints,
        segmentStartIndex = context.segmentStartIndex + segmentOffset,
        segmentStart = newWaypoints[segmentStartIndex],
        segmentEndIndex = context.segmentEndIndex + segmentOffset,
        segmentEnd = newWaypoints[segmentEndIndex],
        axis = flipAxis(context.axis);

    // make sure the dragger does not move
    // outside the connection
    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);

    // update dragger
    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__.translate)(context.draggerGfx, draggerPosition.x, draggerPosition.y);
  }

  /**
   * Filter waypoints for redundant ones (i.e. on the same axis).
   * Returns the filtered waypoints and the offset related to the segment move.
   *
   * @param {Array<Point>} waypoints
   * @param {Integer} segmentStartIndex of moved segment start
   *
   * @return {Object} { filteredWaypoints, segmentOffset }
   */
  function filterRedundantWaypoints(waypoints, segmentStartIndex) {

    var segmentOffset = 0;

    var filteredWaypoints = waypoints.filter(function(r, idx) {
      if ((0,_util_Geometry__WEBPACK_IMPORTED_MODULE_2__.pointsOnLine)(waypoints[idx - 1], waypoints[idx + 1], r)) {

        // remove point and increment offset
        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;
        return false;
      }

      // dont remove point
      return true;
    });

    return {
      waypoints: filteredWaypoints,
      segmentOffset: segmentOffset
    };
  }

  eventBus.on('connectionSegment.move.start', function(event) {

    var context = event.context,
        connection = event.connection,
        layer = canvas.getLayer('overlays');

    context.originalWaypoints = connection.waypoints.slice();

    // add dragger gfx
    context.draggerGfx = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.addSegmentDragger)(layer, context.segmentStart, context.segmentEnd);
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.classes)(context.draggerGfx).add('djs-dragging');

    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
  });

  eventBus.on('connectionSegment.move.move', function(event) {

    var context = event.context,
        connection = context.connection,
        segmentStartIndex = context.segmentStartIndex,
        segmentEndIndex = context.segmentEndIndex,
        segmentStart = context.segmentStart,
        segmentEnd = context.segmentEnd,
        axis = context.axis;

    var newWaypoints = context.originalWaypoints.slice(),
        newSegmentStart = axisAdd(segmentStart, axis, event['d' + axis]),
        newSegmentEnd = axisAdd(segmentEnd, axis, event['d' + axis]);

    // original waypoint count and added / removed
    // from start waypoint delta. We use the later
    // to retrieve the updated segmentStartIndex / segmentEndIndex
    var waypointCount = newWaypoints.length,
        segmentOffset = 0;

    // move segment start / end by axis delta
    newWaypoints[segmentStartIndex] = newSegmentStart;
    newWaypoints[segmentEndIndex] = newSegmentEnd;

    var sourceToSegmentOrientation,
        targetToSegmentOrientation;

    // handle first segment
    if (segmentStartIndex < 2) {
      sourceToSegmentOrientation = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.getOrientation)(connection.source, newSegmentStart);

      // first bendpoint, remove first segment if intersecting
      if (segmentStartIndex === 1) {

        if (sourceToSegmentOrientation === 'intersect') {
          newWaypoints.shift();
          newWaypoints[0] = newSegmentStart;
          segmentOffset--;
        }
      }

      // docking point, add segment if not intersecting anymore
      else {
        if (sourceToSegmentOrientation !== 'intersect') {
          newWaypoints.unshift(segmentStart);
          segmentOffset++;
        }
      }
    }

    // handle last segment
    if (segmentEndIndex > waypointCount - 3) {
      targetToSegmentOrientation = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.getOrientation)(connection.target, newSegmentEnd);

      // last bendpoint, remove last segment if intersecting
      if (segmentEndIndex === waypointCount - 2) {

        if (targetToSegmentOrientation === 'intersect') {
          newWaypoints.pop();
          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;
        }
      }

      // last bendpoint, remove last segment if intersecting
      else {
        if (targetToSegmentOrientation !== 'intersect') {
          newWaypoints.push(segmentEnd);
        }
      }
    }

    // update connection waypoints
    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);

    // update dragger position
    updateDragger(context, segmentOffset, event);

    // save segmentOffset in context
    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;

    // redraw connection
    redrawConnection(event);
  });

  eventBus.on('connectionSegment.move.hover', function(event) {

    event.context.hover = event.hover;
    canvas.addMarker(event.hover, MARKER_CONNECT_HOVER);
  });

  eventBus.on([
    'connectionSegment.move.out',
    'connectionSegment.move.cleanup'
  ], function(event) {

    // remove connect marker
    // if it was added
    var hover = event.context.hover;

    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
    }
  });

  eventBus.on('connectionSegment.move.cleanup', function(event) {

    var context = event.context,
        connection = context.connection;

    // remove dragger gfx
    if (context.draggerGfx) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.remove)(context.draggerGfx);
    }

    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
  });

  eventBus.on([
    'connectionSegment.move.cancel',
    'connectionSegment.move.end'
  ], function(event) {
    var context = event.context,
        connection = context.connection;

    connection.waypoints = context.originalWaypoints;

    redrawConnection(event);
  });

  eventBus.on('connectionSegment.move.end', function(event) {

    var context = event.context,
        connection = context.connection,
        newWaypoints = context.newWaypoints,
        newSegmentStartIndex = context.newSegmentStartIndex;

    // ensure we have actual pixel values bendpoint
    // coordinates (important when zoom level was > 1 during move)
    newWaypoints = newWaypoints.map(function(p) {
      return {
        original: p.original,
        x: Math.round(p.x),
        y: Math.round(p.y)
      };
    });

    // apply filter redunant waypoints
    var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);

    // get filtered waypoints
    var filteredWaypoints = filtered.waypoints,
        croppedWaypoints = cropConnection(connection, filteredWaypoints),
        segmentOffset = filtered.segmentOffset;

    var hints = {
      segmentMove: {
        segmentStartIndex: context.segmentStartIndex,
        newSegmentStartIndex: newSegmentStartIndex + segmentOffset
      }
    };

    modeling.updateWaypoints(connection, croppedWaypoints, hints);
  });
}

ConnectionSegmentMove.$inject = [
  'injector',
  'eventBus',
  'canvas',
  'dragging',
  'graphicsFactory',
  'modeling'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _Bendpoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bendpoints */ "./node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js");
/* harmony import */ var _BendpointMove__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BendpointMove */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js");
/* harmony import */ var _BendpointMovePreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BendpointMovePreview */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointMovePreview.js");
/* harmony import */ var _ConnectionSegmentMove__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ConnectionSegmentMove */ "./node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js");
/* harmony import */ var _BendpointSnapping__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BendpointSnapping */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js");










/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _dragging__WEBPACK_IMPORTED_MODULE_0__.default,
    _rules__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [ 'bendpoints', 'bendpointSnapping', 'bendpointMovePreview' ],
  bendpoints: [ 'type', _Bendpoints__WEBPACK_IMPORTED_MODULE_2__.default ],
  bendpointMove: [ 'type', _BendpointMove__WEBPACK_IMPORTED_MODULE_3__.default ],
  bendpointMovePreview: [ 'type', _BendpointMovePreview__WEBPACK_IMPORTED_MODULE_4__.default ],
  connectionSegmentMove: [ 'type', _ConnectionSegmentMove__WEBPACK_IMPORTED_MODULE_5__.default ],
  bendpointSnapping: [ 'type', _BendpointSnapping__WEBPACK_IMPORTED_MODULE_6__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/change-support/ChangeSupport.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/change-support/ChangeSupport.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ChangeSupport)
/* harmony export */ });
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");


/**
 * Adds change support to the diagram, including
 *
 * <ul>
 *   <li>redrawing shapes and connections on change</li>
 * </ul>
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {ElementRegistry} elementRegistry
 * @param {GraphicsFactory} graphicsFactory
 */
function ChangeSupport(
    eventBus, canvas, elementRegistry,
    graphicsFactory) {


  // redraw shapes / connections on change

  eventBus.on('element.changed', function(event) {

    var element = event.element;

    // element might have been deleted and replaced by new element with same ID
    // thus check for parent of element except for root element
    if (element.parent || element === canvas.getRootElement()) {
      event.gfx = elementRegistry.getGraphics(element);
    }

    // shape + gfx may have been deleted
    if (!event.gfx) {
      return;
    }

    eventBus.fire((0,_util_Elements__WEBPACK_IMPORTED_MODULE_0__.getType)(element) + '.changed', event);
  });

  eventBus.on('elements.changed', function(event) {

    var elements = event.elements;

    elements.forEach(function(e) {
      eventBus.fire('element.changed', { element: e });
    });

    graphicsFactory.updateContainments(elements);
  });

  eventBus.on('shape.changed', function(event) {
    graphicsFactory.update('shape', event.element, event.gfx);
  });

  eventBus.on('connection.changed', function(event) {
    graphicsFactory.update('connection', event.element, event.gfx);
  });
}

ChangeSupport.$inject = [
  'eventBus',
  'canvas',
  'elementRegistry',
  'graphicsFactory'
];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/change-support/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/change-support/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ChangeSupport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChangeSupport */ "./node_modules/diagram-js/lib/features/change-support/ChangeSupport.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'changeSupport'],
  changeSupport: [ 'type', _ChangeSupport__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/clipboard/Clipboard.js":
/*!*********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/clipboard/Clipboard.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Clipboard)
/* harmony export */ });
/**
 * A clip board stub
 */
function Clipboard() {}


Clipboard.prototype.get = function() {
  return this._data;
};

Clipboard.prototype.set = function(data) {
  this._data = data;
};

Clipboard.prototype.clear = function() {
  var data = this._data;

  delete this._data;

  return data;
};

Clipboard.prototype.isEmpty = function() {
  return !this._data;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/clipboard/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/clipboard/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Clipboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clipboard */ "./node_modules/diagram-js/lib/features/clipboard/Clipboard.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  clipboard: [ 'type', _Clipboard__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/connect/Connect.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/connect/Connect.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Connect),
/* harmony export */   "isReverse": () => (/* binding */ isReverse)
/* harmony export */ });
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");





function Connect(eventBus, dragging, modeling, rules) {

  // rules

  function canConnect(source, target) {
    return rules.allowed('connection.create', {
      source: source,
      target: target
    });
  }

  function canConnectReverse(source, target) {
    return canConnect(target, source);
  }


  // event handlers

  eventBus.on('connect.hover', function(event) {
    var context = event.context,
        start = context.start,
        hover = event.hover,
        canExecute;

    // cache hover state
    context.hover = hover;

    canExecute = context.canExecute = canConnect(start, hover);

    // ignore hover
    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNil)(canExecute)) {
      return;
    }

    if (canExecute !== false) {
      context.source = start;
      context.target = hover;

      return;
    }

    canExecute = context.canExecute = canConnectReverse(start, hover);

    // ignore hover
    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNil)(canExecute)) {
      return;
    }

    if (canExecute !== false) {
      context.source = hover;
      context.target = start;
    }
  });

  eventBus.on([ 'connect.out', 'connect.cleanup' ], function(event) {
    var context = event.context;

    context.hover = null;
    context.source = null;
    context.target = null;

    context.canExecute = false;
  });

  eventBus.on('connect.end', function(event) {
    var context = event.context,
        canExecute = context.canExecute,
        connectionStart = context.connectionStart,
        connectionEnd = {
          x: event.x,
          y: event.y
        },
        source = context.source,
        target = context.target;

    if (!canExecute) {
      return false;
    }

    var attrs = null,
        hints = {
          connectionStart: isReverse(context) ? connectionEnd : connectionStart,
          connectionEnd: isReverse(context) ? connectionStart : connectionEnd
        };

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(canExecute)) {
      attrs = canExecute;
    }

    modeling.connect(source, target, attrs, hints);
  });


  // API

  /**
   * Start connect operation.
   *
   * @param {DOMEvent} event
   * @param {djs.model.Base} start
   * @param {Point} [connectionStart]
   * @param {boolean} [autoActivate=false]
   */
  this.start = function(event, start, connectionStart, autoActivate) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(connectionStart)) {
      autoActivate = connectionStart;
      connectionStart = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(start);
    }

    dragging.init(event, 'connect', {
      autoActivate: autoActivate,
      data: {
        shape: start,
        context: {
          start: start,
          connectionStart: connectionStart
        }
      }
    });
  };
}

Connect.$inject = [
  'eventBus',
  'dragging',
  'modeling',
  'rules'
];


// helpers //////////

function isReverse(context) {
  var hover = context.hover,
      source = context.source,
      target = context.target;

  return hover && source && hover === source && source !== target;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/connect/ConnectPreview.js":
/*!************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/connect/ConnectPreview.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ConnectPreview)
/* harmony export */ });
/* harmony import */ var _Connect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Connect */ "./node_modules/diagram-js/lib/features/connect/Connect.js");


var HIGH_PRIORITY = 1100,
    LOW_PRIORITY = 900;

var MARKER_OK = 'connect-ok',
    MARKER_NOT_OK = 'connect-not-ok';

/**
 * Shows connection preview during connect.
 *
 * @param {didi.Injector} injector
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function ConnectPreview(injector, eventBus, canvas) {
  var connectionPreview = injector.get('connectionPreview', false);

  connectionPreview && eventBus.on('connect.move', function(event) {
    var context = event.context,
        canConnect = context.canExecute,
        hover = context.hover,
        source = context.source,
        start = context.start,
        startPosition = context.startPosition,
        connectionStart = context.connectionStart,
        connectionEnd = context.connectionEnd,
        target = context.target;

    if (!connectionStart) {
      connectionStart = (0,_Connect__WEBPACK_IMPORTED_MODULE_0__.isReverse)(context) ? {
        x: event.x,
        y: event.y
      } : startPosition;
    }

    if (!connectionEnd) {
      connectionEnd = (0,_Connect__WEBPACK_IMPORTED_MODULE_0__.isReverse)(context) ? startPosition : {
        x: event.x,
        y: event.y
      };
    }

    connectionPreview.drawPreview(context, canConnect, {
      source: source || start,
      target: target || hover,
      connectionStart: connectionStart,
      connectionEnd: connectionEnd
    });
  });

  eventBus.on('connect.hover', LOW_PRIORITY, function(event) {
    var context = event.context,
        hover = event.hover,
        canExecute = context.canExecute;

    // ignore hover
    if (canExecute === null) {
      return;
    }

    canvas.addMarker(hover, canExecute ? MARKER_OK : MARKER_NOT_OK);
  });

  eventBus.on([
    'connect.out',
    'connect.cleanup'
  ], HIGH_PRIORITY, function(event) {
    var hover = event.hover;

    if (hover) {
      canvas.removeMarker(hover, MARKER_OK);
      canvas.removeMarker(hover, MARKER_NOT_OK);
    }
  });

  connectionPreview && eventBus.on('connect.cleanup', function(event) {
    connectionPreview.cleanUp(event.context);
  });
}

ConnectPreview.$inject = [
  'injector',
  'eventBus',
  'canvas'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/connect/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/connect/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _Connect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Connect */ "./node_modules/diagram-js/lib/features/connect/Connect.js");
/* harmony import */ var _ConnectPreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ConnectPreview */ "./node_modules/diagram-js/lib/features/connect/ConnectPreview.js");







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _selection__WEBPACK_IMPORTED_MODULE_0__.default,
    _rules__WEBPACK_IMPORTED_MODULE_1__.default,
    _dragging__WEBPACK_IMPORTED_MODULE_2__.default
  ],
  __init__: [
    'connectPreview'
  ],
  connect: [ 'type', _Connect__WEBPACK_IMPORTED_MODULE_3__.default ],
  connectPreview: [ 'type', _ConnectPreview__WEBPACK_IMPORTED_MODULE_4__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/connection-preview/ConnectionPreview.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/connection-preview/ConnectionPreview.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ConnectionPreview)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");







var MARKER_CONNECTION_PREVIEW = 'djs-connection-preview';

/**
 * Draws connection preview. Optionally, this can use layouter and connection docking to draw
 * better looking previews.
 *
 * @param {didi.Injector} injector
 * @param {Canvas} canvas
 * @param {GraphicsFactory} graphicsFactory
 * @param {ElementFactory} elementFactory
 */
function ConnectionPreview(
    injector,
    canvas,
    graphicsFactory,
    elementFactory
) {
  this._canvas = canvas;
  this._graphicsFactory = graphicsFactory;
  this._elementFactory = elementFactory;

  // optional components
  this._connectionDocking = injector.get('connectionDocking', false);
  this._layouter = injector.get('layouter', false);
}

ConnectionPreview.$inject = [
  'injector',
  'canvas',
  'graphicsFactory',
  'elementFactory'
];

/**
 * Draw connection preview.
 *
 * Provide at least one of <source, connectionStart> and <target, connectionEnd> to create a preview.
 * In the clean up stage, call `connectionPreview#cleanUp` with the context to remove preview.
 *
 * @param {Object} context
 * @param {Object|boolean} canConnect
 * @param {Object} hints
 * @param {djs.model.shape} [hints.source] source element
 * @param {djs.model.shape} [hints.target] target element
 * @param {Point} [hints.connectionStart] connection preview start
 * @param {Point} [hints.connectionEnd] connection preview end
 * @param {Array<Point>} [hints.waypoints] provided waypoints for preview
 * @param {boolean} [hints.noLayout] true if preview should not be laid out
 * @param {boolean} [hints.noCropping] true if preview should not be cropped
 * @param {boolean} [hints.noNoop] true if simple connection should not be drawn
 */
ConnectionPreview.prototype.drawPreview = function(context, canConnect, hints) {

  hints = hints || {};

  var connectionPreviewGfx = context.connectionPreviewGfx,
      getConnection = context.getConnection,
      source = hints.source,
      target = hints.target,
      waypoints = hints.waypoints,
      connectionStart = hints.connectionStart,
      connectionEnd = hints.connectionEnd,
      noLayout = hints.noLayout,
      noCropping = hints.noCropping,
      noNoop = hints.noNoop,
      connection;

  var self = this;

  if (!connectionPreviewGfx) {
    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();
  }

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.clear)(connectionPreviewGfx);

  if (!getConnection) {
    getConnection = context.getConnection = cacheReturnValues(function(canConnect, source, target) {
      return self.getConnection(canConnect, source, target);
    });
  }

  if (canConnect) {
    connection = getConnection(canConnect, source, target);
  }

  if (!connection) {
    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);
    return;
  }

  connection.waypoints = waypoints || [];

  // optional layout
  if (this._layouter && !noLayout) {
    connection.waypoints = this._layouter.layoutConnection(connection, {
      source: source,
      target: target,
      connectionStart: connectionStart,
      connectionEnd: connectionEnd,
      waypoints: hints.waypoints || connection.waypoints
    });
  }

  // fallback if no waypoints were provided nor created with layouter
  if (!connection.waypoints || !connection.waypoints.length) {
    connection.waypoints = [
      source ? (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(source) : connectionStart,
      target ? (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(target) : connectionEnd
    ];
  }

  // optional cropping
  if (this._connectionDocking && (source || target) && !noCropping) {
    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);
  }

  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection);
};

/**
 * Draw simple connection between source and target or provided points.
 *
 * @param {SVGElement} connectionPreviewGfx container for the connection
 * @param {Object} hints
 * @param {djs.model.shape} [hints.source] source element
 * @param {djs.model.shape} [hints.target] target element
 * @param {Point} [hints.connectionStart] required if source is not provided
 * @param {Point} [hints.connectionEnd] required if target is not provided
 */
ConnectionPreview.prototype.drawNoopPreview = function(connectionPreviewGfx, hints) {
  var source = hints.source,
      target = hints.target,
      start = hints.connectionStart || (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(source),
      end = hints.connectionEnd || (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(target);

  var waypoints = this.cropWaypoints(start, end, source, target);

  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(connectionPreviewGfx, connection);
};

/**
 * Return cropped waypoints.
 *
 * @param {Point} start
 * @param {Point} end
 * @param {djs.model.shape} source
 * @param {djs.model.shape} target
 *
 * @returns {Array}
 */
ConnectionPreview.prototype.cropWaypoints = function(start, end, source, target) {
  var graphicsFactory = this._graphicsFactory,
      sourcePath = source && graphicsFactory.getShapePath(source),
      targetPath = target && graphicsFactory.getShapePath(target),
      connectionPath = graphicsFactory.getConnectionPath({ waypoints: [ start, end ] });

  start = (source && (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getElementLineIntersection)(sourcePath, connectionPath, true)) || start;
  end = (target && (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getElementLineIntersection)(targetPath, connectionPath, false)) || end;

  return [ start, end ];
};

/**
 * Remove connection preview container if it exists.
 *
 * @param {Object} [context]
 * @param {SVGElement} [context.connectionPreviewGfx] preview container
 */
ConnectionPreview.prototype.cleanUp = function(context) {
  if (context && context.connectionPreviewGfx) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.remove)(context.connectionPreviewGfx);
  }
};

/**
 * Get connection that connects source and target.
 *
 * @param {Object|boolean} canConnect
 *
 * @returns {djs.model.connection}
 */
ConnectionPreview.prototype.getConnection = function(canConnect) {
  var attrs = ensureConnectionAttrs(canConnect);

  return this._elementFactory.createConnection(attrs);
};


/**
 * Add and return preview graphics.
 *
 * @returns {SVGElement}
 */
ConnectionPreview.prototype.createConnectionPreviewGfx = function() {
  var gfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('g');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(gfx, {
    pointerEvents: 'none'
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.classes)(gfx).add(MARKER_CONNECTION_PREVIEW);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(this._canvas.getDefaultLayer(), gfx);

  return gfx;
};

/**
 * Create and return simple connection.
 *
 * @param {Point} start
 * @param {Point} end
 *
 * @returns {SVGElement}
 */
ConnectionPreview.prototype.createNoopConnection = function(start, end) {
  var connection = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('polyline');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(connection, {
    'stroke': '#333',
    'strokeDasharray': [ 1 ],
    'strokeWidth': 2,
    'pointer-events': 'none'
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(connection, { 'points': [ start.x, start.y, end.x, end.y ] });

  return connection;
};

// helpers //////////

/**
 * Returns function that returns cached return values referenced by stringified first argument.
 *
 * @param {Function} fn
 *
 * @return {Function}
 */
function cacheReturnValues(fn) {
  var returnValues = {};

  /**
   * Return cached return value referenced by stringified first argument.
   *
   * @returns {*}
   */
  return function(firstArgument) {
    var key = JSON.stringify(firstArgument);

    var returnValue = returnValues[key];

    if (!returnValue) {
      returnValue = returnValues[key] = fn.apply(null, arguments);
    }

    return returnValue;
  };
}

/**
 * Ensure connection attributes is object.
 *
 * @param {Object|boolean} canConnect
 *
 * @returns {Object}
 */
function ensureConnectionAttrs(canConnect) {
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isObject)(canConnect)) {
    return canConnect;
  } else {
    return {};
  }
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/connection-preview/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/connection-preview/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ConnectionPreview__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConnectionPreview */ "./node_modules/diagram-js/lib/features/connection-preview/ConnectionPreview.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'connectionPreview' ],
  connectionPreview: [ 'type', _ConnectionPreview__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/context-pad/ContextPad.js":
/*!************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/context-pad/ContextPad.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ContextPad)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");




var entrySelector = '.entry';

var DEFAULT_PRIORITY = 1000;


/**
 * A context pad that displays element specific, contextual actions next
 * to a diagram element.
 *
 * @param {Object} config
 * @param {boolean|Object} [config.scale={ min: 1.0, max: 1.5 }]
 * @param {number} [config.scale.min]
 * @param {number} [config.scale.max]
 * @param {EventBus} eventBus
 * @param {Overlays} overlays
 */
function ContextPad(config, eventBus, overlays) {

  this._eventBus = eventBus;
  this._overlays = overlays;

  var scale = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isDefined)(config && config.scale) ? config.scale : {
    min: 1,
    max: 1.5
  };

  this._overlaysConfig = {
    position: {
      right: -9,
      top: -6
    },
    scale: scale
  };

  this._current = null;

  this._init();
}

ContextPad.$inject = [
  'config.contextPad',
  'eventBus',
  'overlays'
];


/**
 * Registers events needed for interaction with other components
 */
ContextPad.prototype._init = function() {

  var eventBus = this._eventBus;

  var self = this;

  eventBus.on('selection.changed', function(e) {

    var selection = e.newSelection;

    if (selection.length === 1) {
      self.open(selection[0]);
    } else {
      self.close();
    }
  });

  eventBus.on('elements.delete', function(event) {
    var elements = event.elements;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(e) {
      if (self.isOpen(e)) {
        self.close();
      }
    });
  });

  eventBus.on('element.changed', function(event) {
    var element = event.element,
        current = self._current;

    // force reopen if element for which we are currently opened changed
    if (current && current.element === element) {
      self.open(element, true);
    }
  });
};


/**
 * Register a provider with the context pad
 *
 * @param  {number} [priority=1000]
 * @param  {ContextPadProvider} provider
 *
 * @example
 * const contextPadProvider = {
  *   getContextPadEntries: function(element) {
  *     return function(entries) {
  *       return {
  *         ...entries,
  *         'entry-1': {
  *           label: 'My Entry',
  *           action: function() { alert("I have been clicked!"); }
  *         }
  *       };
  *     }
  *   }
  * };
  *
 * contextPad.registerProvider(800, contextPadProvider);
 */
ContextPad.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY;
  }

  this._eventBus.on('contextPad.getProviders', priority, function(event) {
    event.providers.push(provider);
  });
};


/**
 * Returns the context pad entries for a given element
 *
 * @param {djs.element.Base} element
 *
 * @return {Array<ContextPadEntryDescriptor>} list of entries
 */
ContextPad.prototype.getEntries = function(element) {
  var providers = this._getProviders();

  var entries = {};

  // loop through all providers and their entries.
  // group entries by id so that overriding an entry is possible
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(providers, function(provider) {
    var entriesOrUpdater = provider.getContextPadEntries(element);

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });

  return entries;
};


/**
 * Trigger an action available on the opened context pad
 *
 * @param  {string} action
 * @param  {Event} event
 * @param  {boolean} [autoActivate=false]
 */
ContextPad.prototype.trigger = function(action, event, autoActivate) {

  var element = this._current.element,
      entries = this._current.entries,
      entry,
      handler,
      originalEvent,
      button = event.delegateTarget || event.target;

  if (!button) {
    return event.preventDefault();
  }

  entry = entries[(0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(button, 'data-action')];
  handler = entry.action;

  originalEvent = event.originalEvent || event;

  // simple action (via callback function)
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(handler)) {
    if (action === 'click') {
      return handler(originalEvent, element, autoActivate);
    }
  } else {
    if (handler[action]) {
      return handler[action](originalEvent, element, autoActivate);
    }
  }

  // silence other actions
  event.preventDefault();
};


/**
 * Open the context pad for the given element
 *
 * @param {djs.model.Base} element
 * @param {boolean} force if true, force reopening the context pad
 */
ContextPad.prototype.open = function(element, force) {
  if (!force && this.isOpen(element)) {
    return;
  }

  this.close();
  this._updateAndOpen(element);
};

ContextPad.prototype._getProviders = function() {

  var event = this._eventBus.createEvent({
    type: 'contextPad.getProviders',
    providers: []
  });

  this._eventBus.fire(event);

  return event.providers;
};

ContextPad.prototype._updateAndOpen = function(element) {

  var entries = this.getEntries(element),
      pad = this.getPad(element),
      html = pad.html;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(entries, function(entry, id) {
    var grouping = entry.group || 'default',
        control = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)(entry.html || '<div class="entry" draggable="true"></div>'),
        container;

    (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(control, 'data-action', id);

    container = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.query)('[data-group=' + grouping + ']', html);
    if (!container) {
      container = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div class="group" data-group="' + grouping + '"></div>');
      html.appendChild(container);
    }

    container.appendChild(control);

    if (entry.className) {
      addClasses(control, entry.className);
    }

    if (entry.title) {
      (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(control, 'title', entry.title);
    }

    if (entry.imageUrl) {
      control.appendChild((0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<img src="' + entry.imageUrl + '">'));
    }
  });

  (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(html).add('open');

  this._current = {
    element: element,
    pad: pad,
    entries: entries
  };

  this._eventBus.fire('contextPad.open', { current: this._current });
};


ContextPad.prototype.getPad = function(element) {
  if (this.isOpen()) {
    return this._current.pad;
  }

  var self = this;

  var overlays = this._overlays;

  var html = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div class="djs-context-pad"></div>');

  var overlaysConfig = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
    html: html
  }, this._overlaysConfig);

  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(html, entrySelector, 'click', function(event) {
    self.trigger('click', event);
  });

  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(html, entrySelector, 'dragstart', function(event) {
    self.trigger('dragstart', event);
  });

  // stop propagation of mouse events
  min_dom__WEBPACK_IMPORTED_MODULE_1__.event.bind(html, 'mousedown', function(event) {
    event.stopPropagation();
  });

  this._overlayId = overlays.add(element, 'context-pad', overlaysConfig);

  var pad = overlays.get(this._overlayId);

  this._eventBus.fire('contextPad.create', { element: element, pad: pad });

  return pad;
};


/**
 * Close the context pad
 */
ContextPad.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }

  this._overlays.remove(this._overlayId);

  this._overlayId = null;

  this._eventBus.fire('contextPad.close', { current: this._current });

  this._current = null;
};

/**
 * Check if pad is open. If element is given, will check
 * if pad is opened with given element.
 *
 * @param {Element} element
 * @return {boolean}
 */
ContextPad.prototype.isOpen = function(element) {
  return !!this._current && (!element ? true : this._current.element === element);
};




// helpers //////////////////////

function addClasses(element, classNames) {

  var classes = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(element);

  var actualClassNames = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(classNames) ? classNames : classNames.split(/\s+/g);
  actualClassNames.forEach(function(cls) {
    classes.add(cls);
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/context-pad/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/context-pad/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interaction_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interaction-events */ "./node_modules/diagram-js/lib/features/interaction-events/index.js");
/* harmony import */ var _overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../overlays */ "./node_modules/diagram-js/lib/features/overlays/index.js");
/* harmony import */ var _ContextPad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ContextPad */ "./node_modules/diagram-js/lib/features/context-pad/ContextPad.js");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _interaction_events__WEBPACK_IMPORTED_MODULE_0__.default,
    _overlays__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  contextPad: [ 'type', _ContextPad__WEBPACK_IMPORTED_MODULE_2__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CopyPaste)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");






/**
 * @typedef {Function} <copyPaste.canCopyElements> listener
 *
 * @param {Object} context
 * @param {Array<djs.model.Base>} context.elements
 *
 * @returns {Array<djs.model.Base>|boolean} - Return elements to be copied or false to disallow
 * copying.
 */

/**
 * @typedef {Function} <copyPaste.copyElement> listener
 *
 * @param {Object} context
 * @param {Object} context.descriptor
 * @param {djs.model.Base} context.element
 * @param {Array<djs.model.Base>} context.elements
 */

/**
 * @typedef {Function} <copyPaste.elementsCopied> listener
 *
 * @param {Object} context
 * @param {Object} context.elements
 * @param {Object} context.tree
 */

/**
 * @typedef {Function} <copyPaste.pasteElement> listener
 *
 * @param {Object} context
 * @param {Object} context.cache - Already created elements.
 * @param {Object} context.descriptor
 */

/**
 * @typedef {Function} <copyPaste.pasteElements> listener
 *
 * @param {Object} context
 * @param {Object} context.hints - Add hints before pasting.
 */

/**
 * Copy and paste elements.
 *
 * @param {Canvas} canvas
 * @param {Create} create
 * @param {Clipboard} clipboard
 * @param {ElementFactory} elementFactory
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 * @param {Mouse} mouse
 * @param {Rules} rules
 */
function CopyPaste(
    canvas,
    create,
    clipboard,
    elementFactory,
    eventBus,
    modeling,
    mouse,
    rules
) {

  this._canvas = canvas;
  this._create = create;
  this._clipboard = clipboard;
  this._elementFactory = elementFactory;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._mouse = mouse;
  this._rules = rules;

  eventBus.on('copyPaste.copyElement', function(context) {
    var descriptor = context.descriptor,
        element = context.element,
        elements = context.elements;

    // default priority (priority = 1)
    descriptor.priority = 1;

    descriptor.id = element.id;

    var parentCopied = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, function(e) {
      return e === element.parent;
    });

    // do NOT reference parent if parent wasn't copied
    if (parentCopied) {
      descriptor.parent = element.parent.id;
    }

    // attachers (priority = 2)
    if (isAttacher(element)) {
      descriptor.priority = 2;

      descriptor.host = element.host.id;
    }

    // connections (priority = 3)
    if (isConnection(element)) {
      descriptor.priority = 3;

      descriptor.source = element.source.id;
      descriptor.target = element.target.id;

      descriptor.waypoints = copyWaypoints(element);
    }

    // labels (priority = 4)
    if (isLabel(element)) {
      descriptor.priority = 4;

      descriptor.labelTarget = element.labelTarget.id;
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)([ 'x', 'y', 'width', 'height' ], function(property) {
      if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element[ property ])) {
        descriptor[ property ] = element[ property ];
      }
    });

    descriptor.hidden = element.hidden;
    descriptor.collapsed = element.collapsed;

  });

  eventBus.on('copyPaste.pasteElements', function(context) {
    var hints = context.hints;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(hints, {
      createElementsBehavior: false
    });
  });
}

CopyPaste.$inject = [
  'canvas',
  'create',
  'clipboard',
  'elementFactory',
  'eventBus',
  'modeling',
  'mouse',
  'rules'
];


/**
 * Copy elements.
 *
 * @param {Array<djs.model.Base>} elements
 *
 * @returns {Object}
 */
CopyPaste.prototype.copy = function(elements) {
  var allowed,
      tree;

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements)) {
    elements = elements ? [ elements ] : [];
  }

  allowed = this._eventBus.fire('copyPaste.canCopyElements', {
    elements: elements
  });

  if (allowed === false) {
    tree = {};
  } else {
    tree = this.createTree((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(allowed) ? allowed : elements);
  }

  // we set an empty tree, selection of elements
  // to copy was empty.
  this._clipboard.set(tree);

  this._eventBus.fire('copyPaste.elementsCopied', {
    elements: elements,
    tree: tree
  });

  return tree;
};

/**
 * Paste elements.
 *
 * @param {Object} [context]
 * @param {djs.model.base} [context.element] - Parent.
 * @param {Point} [context.point] - Position.
 * @param {Object} [context.hints] - Hints.
 */
CopyPaste.prototype.paste = function(context) {
  var tree = this._clipboard.get();

  if (this._clipboard.isEmpty()) {
    return;
  }

  var hints = context && context.hints || {};

  this._eventBus.fire('copyPaste.pasteElements', {
    hints: hints
  });

  var elements = this._createElements(tree);

  // paste directly
  if (context && context.element && context.point) {
    return this._paste(elements, context.element, context.point, hints);
  }

  this._create.start(this._mouse.getLastMoveEvent(), elements, {
    hints: hints || {}
  });
};

/**
 * Paste elements directly.
 *
 * @param {Array<djs.model.Base>} elements
 * @param {djs.model.base} target
 * @param {Point} position
 * @param {Object} [hints]
 */
CopyPaste.prototype._paste = function(elements, target, position, hints) {

  // make sure each element has x and y
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.x)) {
      element.x = 0;
    }

    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.y)) {
      element.y = 0;
    }
  });

  var bbox = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.getBBox)(elements);

  // center elements around cursor
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    if (isConnection(element)) {
      element.waypoints = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(element.waypoints, function(waypoint) {
        return {
          x: waypoint.x - bbox.x - bbox.width / 2,
          y: waypoint.y - bbox.y - bbox.height / 2
        };
      });
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(element, {
      x: element.x - bbox.x - bbox.width / 2,
      y: element.y - bbox.y - bbox.height / 2
    });
  });

  return this._modeling.createElements(elements, position, target, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, hints));
};

/**
 * Create elements from tree.
 */
CopyPaste.prototype._createElements = function(tree) {
  var self = this;

  var eventBus = this._eventBus;

  var cache = {};

  var elements = [];

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(tree, function(branch, depth) {

    depth = parseInt(depth, 10);

    // sort by priority
    branch = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(branch, 'priority');

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(branch, function(descriptor) {

      // remove priority
      var attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(descriptor, [ 'priority' ]));

      if (cache[ descriptor.parent ]) {
        attrs.parent = cache[ descriptor.parent ];
      } else {
        delete attrs.parent;
      }

      eventBus.fire('copyPaste.pasteElement', {
        cache: cache,
        descriptor: attrs
      });

      var element;

      if (isConnection(attrs)) {
        attrs.source = cache[ descriptor.source ];
        attrs.target = cache[ descriptor.target ];

        element = cache[ descriptor.id ] = self.createConnection(attrs);

        elements.push(element);

        return;
      }

      if (isLabel(attrs)) {
        attrs.labelTarget = cache[ attrs.labelTarget ];

        element = cache[ descriptor.id ] = self.createLabel(attrs);

        elements.push(element);

        return;
      }

      if (attrs.host) {
        attrs.host = cache[ attrs.host ];
      }

      element = cache[ descriptor.id ] = self.createShape(attrs);

      elements.push(element);
    });

  });

  return elements;
};

CopyPaste.prototype.createConnection = function(attrs) {
  var connection = this._elementFactory.createConnection((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(attrs, [ 'id' ]));

  return connection;
};

CopyPaste.prototype.createLabel = function(attrs) {
  var label = this._elementFactory.createLabel((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(attrs, [ 'id' ]));

  return label;
};

CopyPaste.prototype.createShape = function(attrs) {
  var shape = this._elementFactory.createShape((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(attrs, [ 'id' ]));

  return shape;
};

/**
 * Check wether element has relations to other elements e.g. attachers, labels and connections.
 *
 * @param  {Object} element
 * @param  {Array<djs.model.Base>} elements
 *
 * @returns {boolean}
 */
CopyPaste.prototype.hasRelations = function(element, elements) {
  var labelTarget,
      source,
      target;

  if (isConnection(element)) {
    source = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.matchPattern)({ id: element.source.id }));
    target = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.matchPattern)({ id: element.target.id }));

    if (!source || !target) {
      return false;
    }
  }

  if (isLabel(element)) {
    labelTarget = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.matchPattern)({ id: element.labelTarget.id }));

    if (!labelTarget) {
      return false;
    }
  }

  return true;
};

/**
 * Create a tree-like structure from elements.
 *
 * @example
 * tree: {
  *  0: [
  *    { id: 'Shape_1', priority: 1, ... },
  *    { id: 'Shape_2', priority: 1, ... },
  *    { id: 'Connection_1', source: 'Shape_1', target: 'Shape_2', priority: 3, ... },
  *    ...
  *  ],
  *  1: [
  *    { id: 'Shape_3', parent: 'Shape1', priority: 1, ... },
  *    ...
  *  ]
  * };
  *
  * @param  {Array<djs.model.base>} elements
  *
  * @return {Object}
  */
CopyPaste.prototype.createTree = function(elements) {
  var rules = this._rules,
      self = this;

  var tree = {},
      elementsData = [];

  var parents = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.getParents)(elements);

  function canCopy(element, elements) {
    return rules.allowed('element.copy', {
      element: element,
      elements: elements
    });
  }

  function addElementData(element, depth) {

    // (1) check wether element has already been added
    var foundElementData = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elementsData, function(elementsData) {
      return element === elementsData.element;
    });

    // (2) add element if not already added
    if (!foundElementData) {
      elementsData.push({
        element: element,
        depth: depth
      });

      return;
    }

    // (3) update depth
    if (foundElementData.depth < depth) {
      elementsData = removeElementData(foundElementData, elementsData);

      elementsData.push({
        element: foundElementData.element,
        depth: depth
      });
    }
  }

  function removeElementData(elementData, elementsData) {
    var index = elementsData.indexOf(elementData);

    if (index !== -1) {
      elementsData.splice(index, 1);
    }

    return elementsData;
  }

  // (1) add elements
  (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.eachElement)(parents, function(element, _index, depth) {

    // do NOT add external labels directly
    if (isLabel(element)) {
      return;
    }

    // always copy external labels
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(element.labels, function(label) {
      addElementData(label, depth);
    });

    function addRelatedElements(elements) {
      elements && elements.length && (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {

        // add external labels
        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(element.labels, function(label) {
          addElementData(label, depth);
        });

        addElementData(element, depth);
      });
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)([ element.attachers, element.incoming, element.outgoing ], addRelatedElements);

    addElementData(element, depth);

    return element.children;
  });

  elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(elementsData, function(elementData) {
    return elementData.element;
  });

  // (2) copy elements
  elementsData = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(elementsData, function(elementData) {
    elementData.descriptor = {};

    self._eventBus.fire('copyPaste.copyElement', {
      descriptor: elementData.descriptor,
      element: elementData.element,
      elements: elements
    });

    return elementData;
  });

  // (3) sort elements by priority
  elementsData = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(elementsData, function(elementData) {
    return elementData.descriptor.priority;
  });

  elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(elementsData, function(elementData) {
    return elementData.element;
  });

  // (4) create tree
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elementsData, function(elementData) {
    var depth = elementData.depth;

    if (!self.hasRelations(elementData.element, elements)) {
      removeElement(elementData.element, elements);

      return;
    }

    if (!canCopy(elementData.element, elements)) {
      removeElement(elementData.element, elements);

      return;
    }

    if (!tree[depth]) {
      tree[depth] = [];
    }

    tree[depth].push(elementData.descriptor);
  });

  return tree;
};

// helpers //////////

function isAttacher(element) {
  return !!element.host;
}

function isConnection(element) {
  return !!element.waypoints;
}

function isLabel(element) {
  return !!element.labelTarget;
}

function copyWaypoints(element) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(element.waypoints, function(waypoint) {

    waypoint = copyWaypoint(waypoint);

    if (waypoint.original) {
      waypoint.original = copyWaypoint(waypoint.original);
    }

    return waypoint;
  });
}

function copyWaypoint(waypoint) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, waypoint);
}

function removeElement(element, elements) {
  var index = elements.indexOf(element);

  if (index === -1) {
    return elements;
  }

  return elements.splice(index, 1);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/copy-paste/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/copy-paste/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clipboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clipboard */ "./node_modules/diagram-js/lib/features/clipboard/index.js");
/* harmony import */ var _create__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../create */ "./node_modules/diagram-js/lib/features/create/index.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mouse */ "./node_modules/diagram-js/lib/features/mouse/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _CopyPaste__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CopyPaste */ "./node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js");








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _clipboard__WEBPACK_IMPORTED_MODULE_0__.default,
    _create__WEBPACK_IMPORTED_MODULE_1__.default,
    _mouse__WEBPACK_IMPORTED_MODULE_2__.default,
    _rules__WEBPACK_IMPORTED_MODULE_3__.default
  ],
  __init__: [ 'copyPaste' ],
  copyPaste: [ 'type', _CopyPaste__WEBPACK_IMPORTED_MODULE_4__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/create/Create.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/create/Create.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Create)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
var MARKER_OK = 'drop-ok',
    MARKER_NOT_OK = 'drop-not-ok',
    MARKER_ATTACH = 'attach-ok',
    MARKER_NEW_PARENT = 'new-parent';





var PREFIX = 'create';

var HIGH_PRIORITY = 2000;


/**
 * Create new elements through drag and drop.
 *
 * @param {Canvas} canvas
 * @param {Dragging} dragging
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 * @param {Rules} rules
 */
function Create(
    canvas,
    dragging,
    eventBus,
    modeling,
    rules
) {

  // rules //////////

  /**
   * Check wether elements can be created.
   *
   * @param {Array<djs.model.Base>} elements
   * @param {djs.model.Base} target
   * @param {Point} position
   * @param {djs.model.Base} [source]
   *
   * @returns {boolean|null|Object}
   */
  function canCreate(elements, target, position, source, hints) {
    if (!target) {
      return false;
    }

    // ignore child elements and external labels
    elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.filter)(elements, function(element) {
      var labelTarget = element.labelTarget;

      return !element.parent && !(isLabel(element) && elements.indexOf(labelTarget) !== -1);
    });

    var shape = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, function(element) {
      return !isConnection(element);
    });

    var attach = false,
        connect = false,
        create = false;

    // (1) attaching single shapes
    if (isSingleShape(elements)) {
      attach = rules.allowed('shape.attach', {
        position: position,
        shape: shape,
        target: target
      });
    }

    if (!attach) {

      // (2) creating elements
      if (isSingleShape(elements)) {
        create = rules.allowed('shape.create', {
          position: position,
          shape: shape,
          source: source,
          target: target
        });
      } else {
        create = rules.allowed('elements.create', {
          elements: elements,
          position: position,
          target: target
        });
      }

    }

    var connectionTarget = hints.connectionTarget;

    // (3) appending single shapes
    if (create || attach) {
      if (shape && source) {
        connect = rules.allowed('connection.create', {
          source: connectionTarget === source ? shape : source,
          target: connectionTarget === source ? source : shape,
          hints: {
            targetParent: target,
            targetAttach: attach
          }
        });
      }

      return {
        attach: attach,
        connect: connect
      };
    }

    // ignore wether or not elements can be created
    if (create === null || attach === null) {
      return null;
    }

    return false;
  }

  function setMarker(element, marker) {
    [ MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT ].forEach(function(m) {

      if (m === marker) {
        canvas.addMarker(element, m);
      } else {
        canvas.removeMarker(element, m);
      }
    });
  }

  // event handling //////////

  eventBus.on([ 'create.move', 'create.hover' ], function(event) {
    var context = event.context,
        elements = context.elements,
        hover = event.hover,
        source = context.source,
        hints = context.hints || {};

    if (!hover) {
      context.canExecute = false;
      context.target = null;

      return;
    }

    ensureConstraints(event);

    var position = {
      x: event.x,
      y: event.y
    };

    var canExecute = context.canExecute = hover && canCreate(elements, hover, position, source, hints);

    if (hover && canExecute !== null) {
      context.target = hover;

      if (canExecute && canExecute.attach) {
        setMarker(hover, MARKER_ATTACH);
      } else {
        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);
      }
    }
  });

  eventBus.on([ 'create.end', 'create.out', 'create.cleanup' ], function(event) {
    var hover = event.hover;

    if (hover) {
      setMarker(hover, null);
    }
  });

  eventBus.on('create.end', function(event) {
    var context = event.context,
        source = context.source,
        shape = context.shape,
        elements = context.elements,
        target = context.target,
        canExecute = context.canExecute,
        attach = canExecute && canExecute.attach,
        connect = canExecute && canExecute.connect,
        hints = context.hints || {};

    if (canExecute === false || !target) {
      return false;
    }

    ensureConstraints(event);

    var position = {
      x: event.x,
      y: event.y
    };

    if (connect) {
      shape = modeling.appendShape(source, shape, position, target, {
        attach: attach,
        connection: connect === true ? {} : connect,
        connectionTarget: hints.connectionTarget
      });
    } else {
      elements = modeling.createElements(elements, position, target, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, hints, {
        attach: attach
      }));

      // update shape
      shape = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, function(element) {
        return !isConnection(element);
      });
    }

    // update elements and shape
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(context, {
      elements: elements,
      shape: shape
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(event, {
      elements: elements,
      shape: shape
    });
  });

  function cancel() {
    var context = dragging.context();

    if (context && context.prefix === PREFIX) {
      dragging.cancel();
    }
  }

  // cancel on <elements.changed> that is not result of <drag.end>
  eventBus.on('create.init', function() {
    eventBus.on('elements.changed', cancel);

    eventBus.once([ 'create.cancel', 'create.end' ], HIGH_PRIORITY, function() {
      eventBus.off('elements.changed', cancel);
    });
  });

  // API //////////

  this.start = function(event, elements, context) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements)) {
      elements = [ elements ];
    }

    var shape = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, function(element) {
      return !isConnection(element);
    });

    if (!shape) {

      // at least one shape is required
      return;
    }

    context = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
      elements: elements,
      hints: {},
      shape: shape
    }, context || {});

    // make sure each element has x and y
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
      if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.x)) {
        element.x = 0;
      }

      if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.y)) {
        element.y = 0;
      }
    });

    var bbox = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.getBBox)(elements);

    // center elements around cursor
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
      if (isConnection(element)) {
        element.waypoints = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(element.waypoints, function(waypoint) {
          return {
            x: waypoint.x - bbox.x - bbox.width / 2,
            y: waypoint.y - bbox.y - bbox.height / 2
          };
        });
      }

      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(element, {
        x: element.x - bbox.x - bbox.width / 2,
        y: element.y - bbox.y - bbox.height / 2
      });
    });

    dragging.init(event, PREFIX, {
      cursor: 'grabbing',
      autoActivate: true,
      data: {
        shape: shape,
        elements: elements,
        context: context
      }
    });
  };
}

Create.$inject = [
  'canvas',
  'dragging',
  'eventBus',
  'modeling',
  'rules'
];

// helpers //////////

function ensureConstraints(event) {
  var context = event.context,
      createConstraints = context.createConstraints;

  if (!createConstraints) {
    return;
  }

  if (createConstraints.left) {
    event.x = Math.max(event.x, createConstraints.left);
  }

  if (createConstraints.right) {
    event.x = Math.min(event.x, createConstraints.right);
  }

  if (createConstraints.top) {
    event.y = Math.max(event.y, createConstraints.top);
  }

  if (createConstraints.bottom) {
    event.y = Math.min(event.y, createConstraints.bottom);
  }
}

function isConnection(element) {
  return !!element.waypoints;
}

function isSingleShape(elements) {
  return elements && elements.length === 1 && !isConnection(elements[0]);
}

function isLabel(element) {
  return !!element.labelTarget;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/create/CreatePreview.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/create/CreatePreview.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreatePreview)
/* harmony export */ });
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var _util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/GraphicsUtil */ "./node_modules/diagram-js/lib/util/GraphicsUtil.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");






var LOW_PRIORITY = 750;


function CreatePreview(
    canvas,
    eventBus,
    graphicsFactory,
    previewSupport,
    styles
) {
  function createDragGroup(elements) {
    var dragGroup = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('g');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(dragGroup, styles.cls('djs-drag-group', [ 'no-events' ]));

    var childrenGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('g');

    elements.forEach(function(element) {

      // create graphics
      var gfx;

      if (element.hidden) {
        return;
      }

      if (element.waypoints) {
        gfx = graphicsFactory._createContainer('connection', childrenGfx);

        graphicsFactory.drawConnection((0,_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_1__.getVisual)(gfx), element);
      } else {
        gfx = graphicsFactory._createContainer('shape', childrenGfx);

        graphicsFactory.drawShape((0,_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_1__.getVisual)(gfx), element);

        (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__.translate)(gfx, element.x, element.y);
      }

      // add preview
      previewSupport.addDragger(element, dragGroup, gfx);
    });

    return dragGroup;
  }

  eventBus.on('create.move', LOW_PRIORITY, function(event) {

    var hover = event.hover,
        context = event.context,
        elements = context.elements,
        dragGroup = context.dragGroup;

    // lazily create previews
    if (!dragGroup) {
      dragGroup = context.dragGroup = createDragGroup(elements);
    }

    var defaultLayer;

    if (hover) {
      if (!dragGroup.parentNode) {
        defaultLayer = canvas.getDefaultLayer();

        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(defaultLayer, dragGroup);
      }

      (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__.translate)(dragGroup, event.x, event.y);
    } else {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.remove)(dragGroup);
    }
  });

  eventBus.on('create.cleanup', function(event) {
    var context = event.context,
        dragGroup = context.dragGroup;

    if (dragGroup) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.remove)(dragGroup);
    }
  });
}

CreatePreview.$inject = [
  'canvas',
  'eventBus',
  'graphicsFactory',
  'previewSupport',
  'styles'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/create/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/create/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _preview_support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../preview-support */ "./node_modules/diagram-js/lib/features/preview-support/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _Create__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Create */ "./node_modules/diagram-js/lib/features/create/Create.js");
/* harmony import */ var _CreatePreview__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CreatePreview */ "./node_modules/diagram-js/lib/features/create/CreatePreview.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _dragging__WEBPACK_IMPORTED_MODULE_0__.default,
    _preview_support__WEBPACK_IMPORTED_MODULE_1__.default,
    _rules__WEBPACK_IMPORTED_MODULE_2__.default,
    _selection__WEBPACK_IMPORTED_MODULE_3__.default
  ],
  __init__: [
    'create',
    'createPreview'
  ],
  create: [ 'type', _Create__WEBPACK_IMPORTED_MODULE_4__.default ],
  createPreview: [ 'type', _CreatePreview__WEBPACK_IMPORTED_MODULE_5__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/dragging/Dragging.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/dragging/Dragging.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Dragging)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");
/* harmony import */ var _util_Cursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Cursor */ "./node_modules/diagram-js/lib/util/Cursor.js");
/* harmony import */ var _util_ClickTrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/ClickTrap */ "./node_modules/diagram-js/lib/util/ClickTrap.js");
/* harmony import */ var _util_PositionUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/PositionUtil */ "./node_modules/diagram-js/lib/util/PositionUtil.js");
var round = Math.round;













var DRAG_ACTIVE_CLS = 'djs-drag-active';


function preventDefault(event) {
  event.preventDefault();
}

function isTouchEvent(event) {

  // check for TouchEvent being available first
  // (i.e. not available on desktop Firefox)
  return typeof TouchEvent !== 'undefined' && event instanceof TouchEvent;
}

function getLength(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}

/**
 * A helper that fires canvas localized drag events and realizes
 * the general "drag-and-drop" look and feel.
 *
 * Calling {@link Dragging#activate} activates dragging on a canvas.
 *
 * It provides the following:
 *
 *   * emits life cycle events, namespaced with a prefix assigned
 *     during dragging activation
 *   * sets and restores the cursor
 *   * sets and restores the selection if elements still exist
 *   * ensures there can be only one drag operation active at a time
 *
 * Dragging may be canceled manually by calling {@link Dragging#cancel}
 * or by pressing ESC.
 *
 *
 * ## Life-cycle events
 *
 * Dragging can be in three different states, off, initialized
 * and active.
 *
 * (1) off: no dragging operation is in progress
 * (2) initialized: a new drag operation got initialized but not yet
 *                  started (i.e. because of no initial move)
 * (3) started: dragging is in progress
 *
 * Eventually dragging will be off again after a drag operation has
 * been ended or canceled via user click or ESC key press.
 *
 * To indicate transitions between these states dragging emits generic
 * life-cycle events with the `drag.` prefix _and_ events namespaced
 * to a prefix choosen by a user during drag initialization.
 *
 * The following events are emitted (appropriately prefixed) via
 * the {@link EventBus}.
 *
 * * `init`
 * * `start`
 * * `move`
 * * `end`
 * * `ended` (dragging already in off state)
 * * `cancel` (only if previously started)
 * * `canceled` (dragging already in off state, only if previously started)
 * * `cleanup`
 *
 *
 * @example
 *
 * function MyDragComponent(eventBus, dragging) {
 *
 *   eventBus.on('mydrag.start', function(event) {
 *     console.log('yes, we start dragging');
 *   });
 *
 *   eventBus.on('mydrag.move', function(event) {
 *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);
 *
 *     // local drag data is passed with the event
 *     event.context.foo; // "BAR"
 *
 *     // the original mouse event, too
 *     event.originalEvent; // MouseEvent(...)
 *   });
 *
 *   eventBus.on('element.click', function(event) {
 *     dragging.init(event, 'mydrag', {
 *       cursor: 'grabbing',
 *       data: {
 *         context: {
 *           foo: "BAR"
 *         }
 *       }
 *     });
 *   });
 * }
 */
function Dragging(eventBus, canvas, selection, elementRegistry) {

  var defaultOptions = {
    threshold: 5,
    trapClick: true
  };

  // the currently active drag operation
  // dragging is active as soon as this context exists.
  //
  // it is visually _active_ only when a context.active flag is set to true.
  var context;

  /* convert a global event into local coordinates */
  function toLocalPoint(globalPosition) {

    var viewbox = canvas.viewbox();

    var clientRect = canvas._container.getBoundingClientRect();

    return {
      x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,
      y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale
    };
  }

  // helpers

  function fire(type, dragContext) {
    dragContext = dragContext || context;

    var event = eventBus.createEvent(
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(
        {},
        dragContext.payload,
        dragContext.data,
        { isTouch: dragContext.isTouch }
      )
    );

    // default integration
    if (eventBus.fire('drag.' + type, event) === false) {
      return false;
    }

    return eventBus.fire(dragContext.prefix + '.' + type, event);
  }

  function restoreSelection(previousSelection) {
    var existingSelection = previousSelection.filter(function(element) {
      return elementRegistry.get(element.id);
    });

    existingSelection.length && selection.select(existingSelection);
  }

  // event listeners

  function move(event, activate) {
    var payload = context.payload,
        displacement = context.displacement;

    var globalStart = context.globalStart,
        globalCurrent = (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.toPoint)(event),
        globalDelta = (0,_util_PositionUtil__WEBPACK_IMPORTED_MODULE_2__.delta)(globalCurrent, globalStart);

    var localStart = context.localStart,
        localCurrent = toLocalPoint(globalCurrent),
        localDelta = (0,_util_PositionUtil__WEBPACK_IMPORTED_MODULE_2__.delta)(localCurrent, localStart);


    // activate context explicitly or once threshold is reached
    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {

      // fire start event with original
      // starting coordinates

      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(payload, {
        x: round(localStart.x + displacement.x),
        y: round(localStart.y + displacement.y),
        dx: 0,
        dy: 0
      }, { originalEvent: event });

      if (false === fire('start')) {
        return cancel();
      }

      context.active = true;

      // unset selection and remember old selection
      // the previous (old) selection will always passed
      // with the event via the event.previousSelection property
      if (!context.keepSelection) {
        payload.previousSelection = selection.get();
        selection.select(null);
      }

      // allow custom cursor
      if (context.cursor) {
        (0,_util_Cursor__WEBPACK_IMPORTED_MODULE_3__.set)(context.cursor);
      }

      // indicate dragging via marker on root element
      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    }

    (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.stopPropagation)(event);

    if (context.active) {

      // update payload with actual coordinates
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(payload, {
        x: round(localCurrent.x + displacement.x),
        y: round(localCurrent.y + displacement.y),
        dx: round(localDelta.x),
        dy: round(localDelta.y)
      }, { originalEvent: event });

      // emit move event
      fire('move');
    }
  }

  function end(event) {
    var previousContext,
        returnValue = true;

    if (context.active) {

      if (event) {
        context.payload.originalEvent = event;

        // suppress original event (click, ...)
        // because we just ended a drag operation
        (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.stopPropagation)(event);
      }

      // implementations may stop restoring the
      // original state (selections, ...) by preventing the
      // end events default action
      returnValue = fire('end');
    }

    if (returnValue === false) {
      fire('rejected');
    }

    previousContext = cleanup(returnValue !== true);

    // last event to be fired when all drag operations are done
    // at this point in time no drag operation is in progress anymore
    fire('ended', previousContext);
  }


  // cancel active drag operation if the user presses
  // the ESC key on the keyboard

  function checkCancel(event) {

    if (event.which === 27) {
      preventDefault(event);

      cancel();
    }
  }


  // prevent ghost click that might occur after a finished
  // drag and drop session

  function trapClickAndEnd(event) {

    var untrap;

    // trap the click in case we are part of an active
    // drag operation. This will effectively prevent
    // the ghost click that cannot be canceled otherwise.
    if (context.active) {

      untrap = (0,_util_ClickTrap__WEBPACK_IMPORTED_MODULE_4__.install)(eventBus);

      // remove trap after minimal delay
      setTimeout(untrap, 400);

      // prevent default action (click)
      preventDefault(event);
    }

    end(event);
  }

  function trapTouch(event) {
    move(event);
  }

  // update the drag events hover (djs.model.Base) and hoverGfx (Snap<SVGElement>)
  // properties during hover and out and fire {prefix}.hover and {prefix}.out properties
  // respectively

  function hover(event) {
    var payload = context.payload;

    payload.hoverGfx = event.gfx;
    payload.hover = event.element;

    fire('hover');
  }

  function out(event) {
    fire('out');

    var payload = context.payload;

    payload.hoverGfx = null;
    payload.hover = null;
  }


  // life-cycle methods

  function cancel(restore) {
    var previousContext;

    if (!context) {
      return;
    }

    var wasActive = context.active;

    if (wasActive) {
      fire('cancel');
    }

    previousContext = cleanup(restore);

    if (wasActive) {

      // last event to be fired when all drag operations are done
      // at this point in time no drag operation is in progress anymore
      fire('canceled', previousContext);
    }
  }

  function cleanup(restore) {
    var previousContext,
        endDrag;

    fire('cleanup');

    // reset cursor
    (0,_util_Cursor__WEBPACK_IMPORTED_MODULE_3__.unset)();

    if (context.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }

    // reset dom listeners
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'mousemove', move);

    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'dragstart', preventDefault);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'selectstart', preventDefault);

    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'mousedown', endDrag, true);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'mouseup', endDrag, true);

    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'keyup', checkCancel);

    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'touchstart', trapTouch, true);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'touchcancel', cancel, true);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'touchmove', move, true);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'touchend', end, true);

    eventBus.off('element.hover', hover);
    eventBus.off('element.out', out);

    // remove drag marker on root element
    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);

    // restore selection, unless it has changed
    var previousSelection = context.payload.previousSelection;

    if (restore !== false && previousSelection && !selection.get().length) {
      restoreSelection(previousSelection);
    }

    previousContext = context;

    context = null;

    return previousContext;
  }

  /**
   * Initialize a drag operation.
   *
   * If `localPosition` is given, drag events will be emitted
   * relative to it.
   *
   * @param {MouseEvent|TouchEvent} [event]
   * @param {Point} [localPosition] actual diagram local position this drag operation should start at
   * @param {string} prefix
   * @param {Object} [options]
   */
  function init(event, relativeTo, prefix, options) {

    // only one drag operation may be active, at a time
    if (context) {
      cancel(false);
    }

    if (typeof relativeTo === 'string') {
      options = prefix;
      prefix = relativeTo;
      relativeTo = null;
    }

    options = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, defaultOptions, options || {});

    var data = options.data || {},
        originalEvent,
        globalStart,
        localStart,
        endDrag,
        isTouch;

    if (options.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }

    if (event) {
      originalEvent = (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.getOriginal)(event) || event;
      globalStart = (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.toPoint)(event);

      (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.stopPropagation)(event);

      // prevent default browser dragging behavior
      if (originalEvent.type === 'dragstart') {
        preventDefault(originalEvent);
      }
    } else {
      originalEvent = null;
      globalStart = { x: 0, y: 0 };
    }

    localStart = toLocalPoint(globalStart);

    if (!relativeTo) {
      relativeTo = localStart;
    }

    isTouch = isTouchEvent(originalEvent);

    context = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
      prefix: prefix,
      data: data,
      payload: {},
      globalStart: globalStart,
      displacement: (0,_util_PositionUtil__WEBPACK_IMPORTED_MODULE_2__.delta)(relativeTo, localStart),
      localStart: localStart,
      isTouch: isTouch
    }, options);

    // skip dom registration if trigger
    // is set to manual (during testing)
    if (!options.manual) {

      // add dom listeners

      if (isTouch) {
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'touchstart', trapTouch, true);
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'touchcancel', cancel, true);
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'touchmove', move, true);
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'touchend', end, true);
      } else {

        // assume we use the mouse to interact per default
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'mousemove', move);

        // prevent default browser drag and text selection behavior
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'dragstart', preventDefault);
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'selectstart', preventDefault);

        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'mousedown', endDrag, true);
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'mouseup', endDrag, true);
      }

      min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'keyup', checkCancel);

      eventBus.on('element.hover', hover);
      eventBus.on('element.out', out);
    }

    fire('init');

    if (options.autoActivate) {
      move(event, true);
    }
  }

  // cancel on diagram destruction
  eventBus.on('diagram.destroy', cancel);


  // API

  this.init = init;
  this.move = move;
  this.hover = hover;
  this.out = out;
  this.end = end;

  this.cancel = cancel;

  // for introspection

  this.context = function() {
    return context;
  };

  this.setOptions = function(options) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(defaultOptions, options);
  };
}

Dragging.$inject = [
  'eventBus',
  'canvas',
  'selection',
  'elementRegistry'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/dragging/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/dragging/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _hover_fix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../hover-fix */ "./node_modules/diagram-js/lib/features/hover-fix/index.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _Dragging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dragging */ "./node_modules/diagram-js/lib/features/dragging/Dragging.js");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _hover_fix__WEBPACK_IMPORTED_MODULE_0__.default,
    _selection__WEBPACK_IMPORTED_MODULE_1__.default,
  ],
  dragging: [ 'type', _Dragging__WEBPACK_IMPORTED_MODULE_2__.default ],
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/editor-actions/EditorActions.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/editor-actions/EditorActions.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EditorActions)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var NOT_REGISTERED_ERROR = 'is not a registered action',
    IS_REGISTERED_ERROR = 'is already registered';


/**
 * An interface that provides access to modeling actions by decoupling
 * the one who requests the action to be triggered and the trigger itself.
 *
 * It's possible to add new actions by registering them with registerAction
 * and likewise unregister existing ones with unregisterAction.
 *
 *
 * ## Life-Cycle and configuration
 *
 * The editor actions will wait for diagram initialization before
 * registering default actions _and_ firing an `editorActions.init` event.
 *
 * Interested parties may listen to the `editorActions.init` event with
 * low priority to check, which actions got registered. Other components
 * may use the event to register their own actions via `registerAction`.
 *
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */
function EditorActions(eventBus, injector) {

  // initialize actions
  this._actions = {};

  var self = this;

  eventBus.on('diagram.init', function() {

    // all diagram modules got loaded; check which ones
    // are available and register the respective default actions
    self._registerDefaultActions(injector);

    // ask interested parties to register available editor
    // actions on diagram initialization
    eventBus.fire('editorActions.init', {
      editorActions: self
    });
  });

}

EditorActions.$inject = [
  'eventBus',
  'injector'
];

/**
 * Register default actions.
 *
 * @param {Injector} injector
 */
EditorActions.prototype._registerDefaultActions = function(injector) {

  // (1) retrieve optional components to integrate with

  var commandStack = injector.get('commandStack', false);
  var modeling = injector.get('modeling', false);
  var selection = injector.get('selection', false);
  var zoomScroll = injector.get('zoomScroll', false);
  var copyPaste = injector.get('copyPaste', false);
  var canvas = injector.get('canvas', false);
  var rules = injector.get('rules', false);
  var keyboardMove = injector.get('keyboardMove', false);
  var keyboardMoveSelection = injector.get('keyboardMoveSelection', false);

  // (2) check components and register actions

  if (commandStack) {
    this.register('undo', function() {
      commandStack.undo();
    });

    this.register('redo', function() {
      commandStack.redo();
    });
  }

  if (copyPaste && selection) {
    this.register('copy', function() {
      var selectedElements = selection.get();

      copyPaste.copy(selectedElements);
    });
  }

  if (copyPaste) {
    this.register('paste', function() {
      copyPaste.paste();
    });
  }

  if (zoomScroll) {
    this.register('stepZoom', function(opts) {
      zoomScroll.stepZoom(opts.value);
    });
  }

  if (canvas) {
    this.register('zoom', function(opts) {
      canvas.zoom(opts.value);
    });
  }

  if (modeling && selection && rules) {
    this.register('removeSelection', function() {

      var selectedElements = selection.get();

      if (!selectedElements.length) {
        return;
      }

      var allowed = rules.allowed('elements.delete', { elements: selectedElements }),
          removableElements;

      if (allowed === false) {
        return;
      }
      else if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(allowed)) {
        removableElements = allowed;
      }
      else {
        removableElements = selectedElements;
      }

      if (removableElements.length) {
        modeling.removeElements(removableElements.slice());
      }
    });
  }

  if (keyboardMove) {
    this.register('moveCanvas', function(opts) {
      keyboardMove.moveCanvas(opts);
    });
  }

  if (keyboardMoveSelection) {
    this.register('moveSelection', function(opts) {
      keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
    });
  }

};


/**
 * Triggers a registered action
 *
 * @param  {string} action
 * @param  {Object} opts
 *
 * @return {Unknown} Returns what the registered listener returns
 */
EditorActions.prototype.trigger = function(action, opts) {
  if (!this._actions[action]) {
    throw error(action, NOT_REGISTERED_ERROR);
  }

  return this._actions[action](opts);
};


/**
 * Registers a collections of actions.
 * The key of the object will be the name of the action.
 *
 * @example
 * 
 * var actions = {
 *   spaceTool: function() {
 *     spaceTool.activateSelection();
 *   },
 *   lassoTool: function() {
 *     lassoTool.activateSelection();
 *   }
 * ];
 *
 * editorActions.register(actions);
 *
 * editorActions.isRegistered('spaceTool'); // true
 * 
 *
 * @param  {Object} actions
 */
EditorActions.prototype.register = function(actions, listener) {
  var self = this;

  if (typeof actions === 'string') {
    return this._registerAction(actions, listener);
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(actions, function(listener, action) {
    self._registerAction(action, listener);
  });
};

/**
 * Registers a listener to an action key
 *
 * @param  {string} action
 * @param  {Function} listener
 */
EditorActions.prototype._registerAction = function(action, listener) {
  if (this.isRegistered(action)) {
    throw error(action, IS_REGISTERED_ERROR);
  }

  this._actions[action] = listener;
};

/**
 * Unregister an existing action
 *
 * @param {string} action
 */
EditorActions.prototype.unregister = function(action) {
  if (!this.isRegistered(action)) {
    throw error(action, NOT_REGISTERED_ERROR);
  }

  this._actions[action] = undefined;
};

/**
 * Returns the number of actions that are currently registered
 *
 * @return {number}
 */
EditorActions.prototype.getActions = function() {
  return Object.keys(this._actions);
};

/**
 * Checks wether the given action is registered
 *
 * @param {string} action
 *
 * @return {boolean}
 */
EditorActions.prototype.isRegistered = function(action) {
  return !!this._actions[action];
};


function error(action, message) {
  return new Error(action + ' ' + message);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/editor-actions/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/editor-actions/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _EditorActions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorActions */ "./node_modules/diagram-js/lib/features/editor-actions/EditorActions.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'editorActions' ],
  editorActions: [ 'type', _EditorActions__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/hand-tool/HandTool.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/hand-tool/HandTool.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HandTool)
/* harmony export */ });
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var _features_keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../features/keyboard/KeyboardUtil */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js");




var HIGH_PRIORITY = 1500;
var HAND_CURSOR = 'grab';


function HandTool(
    eventBus, canvas, dragging,
    injector, toolManager, mouse) {

  this._dragging = dragging;
  this._mouse = mouse;

  var self = this,
      keyboard = injector.get('keyboard', false);

  toolManager.registerTool('hand', {
    tool: 'hand',
    dragging: 'hand.move'
  });

  eventBus.on('element.mousedown', HIGH_PRIORITY, function(event) {

    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.hasPrimaryModifier)(event)) {
      return;
    }

    self.activateMove(event.originalEvent, true);

    return false;
  });

  keyboard && keyboard.addListener(HIGH_PRIORITY, function(e) {
    if (!isSpace(e.keyEvent) || self.isActive()) {
      return;
    }

    var mouseEvent = self._mouse.getLastMoveEvent();

    self.activateMove(mouseEvent, !!mouseEvent);
  }, 'keyboard.keydown');

  keyboard && keyboard.addListener(HIGH_PRIORITY, function(e) {
    if (!isSpace(e.keyEvent) || !self.isActive()) {
      return;
    }

    self.toggle();
  }, 'keyboard.keyup');

  eventBus.on('hand.end', function(event) {
    var target = event.originalEvent.target;

    // only reactive on diagram click
    // on some occasions, event.hover is not set and we have to check if the target is an svg
    if (!event.hover && !(target instanceof SVGElement)) {
      return false;
    }

    eventBus.once('hand.ended', function() {
      self.activateMove(event.originalEvent, { reactivate: true });
    });

  });

  eventBus.on('hand.move.move', function(event) {
    var scale = canvas.viewbox().scale;

    canvas.scroll({
      dx: event.dx * scale,
      dy: event.dy * scale
    });
  });

  eventBus.on('hand.move.end', function(event) {
    var context = event.context,
        reactivate = context.reactivate;

    // Don't reactivate if the user is using the keyboard keybinding
    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.hasPrimaryModifier)(event) && reactivate) {

      eventBus.once('hand.move.ended', function(event) {
        self.activateHand(event.originalEvent, true, true);
      });

    }

    return false;
  });

}

HandTool.$inject = [
  'eventBus',
  'canvas',
  'dragging',
  'injector',
  'toolManager',
  'mouse'
];


HandTool.prototype.activateMove = function(event, autoActivate, context) {
  if (typeof autoActivate === 'object') {
    context = autoActivate;
    autoActivate = false;
  }

  this._dragging.init(event, 'hand.move', {
    autoActivate: autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: context || {}
    }
  });
};

HandTool.prototype.activateHand = function(event, autoActivate, reactivate) {
  this._dragging.init(event, 'hand', {
    trapClick: false,
    autoActivate: autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: {
        reactivate: reactivate
      }
    }
  });
};

HandTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }

  var mouseEvent = this._mouse.getLastMoveEvent();

  this.activateHand(mouseEvent, !!mouseEvent);
};

HandTool.prototype.isActive = function() {
  var context = this._dragging.context();

  if (context) {
    return /^(hand|hand\.move)$/.test(context.prefix);
  }

  return false;
};

// helpers //////////

function isSpace(keyEvent) {
  return (0,_features_keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_1__.isKey)(' ', keyEvent);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/hand-tool/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/hand-tool/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tool_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tool-manager */ "./node_modules/diagram-js/lib/features/tool-manager/index.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mouse */ "./node_modules/diagram-js/lib/features/mouse/index.js");
/* harmony import */ var _HandTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HandTool */ "./node_modules/diagram-js/lib/features/hand-tool/HandTool.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _tool_manager__WEBPACK_IMPORTED_MODULE_0__.default,
    _mouse__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [ 'handTool' ],
  handTool: [ 'type', _HandTool__WEBPACK_IMPORTED_MODULE_2__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/hover-fix/HoverFix.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/hover-fix/HoverFix.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HoverFix)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");




var HIGH_PRIORITY = 1500;


/**
 * Browsers may swallow certain events (hover, out ...) if users are to
 * fast with the mouse.
 *
 * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event
 *
 * The fix implemented in this component ensure that we
 *
 * 1) have a hover state after a successful drag.move event
 * 2) have an out event when dragging leaves an element
 *
 * @param {ElementRegistry} elementRegistry
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */
function HoverFix(elementRegistry, eventBus, injector) {

  var self = this;

  var dragging = injector.get('dragging', false);

  /**
   * Make sure we are god damn hovering!
   *
   * @param {Event} dragging event
   */
  function ensureHover(event) {

    if (event.hover) {
      return;
    }

    var originalEvent = event.originalEvent;

    var gfx = self._findTargetGfx(originalEvent);

    var element = gfx && elementRegistry.get(gfx);

    if (gfx && element) {

      // 1) cancel current mousemove
      event.stopPropagation();

      // 2) emit fake hover for new target
      dragging.hover({ element: element, gfx: gfx });

      // 3) re-trigger move event
      dragging.move(originalEvent);
    }
  }


  if (dragging) {

    /**
     * We wait for a specific sequence of events before
     * emitting a fake drag.hover event.
     *
     * Event Sequence:
     *
     * drag.start
     * drag.move >> ensure we are hovering
     */
    eventBus.on('drag.start', function(event) {

      eventBus.once('drag.move', HIGH_PRIORITY, function(event) {

        ensureHover(event);

      });

    });
  }


  /**
   * We make sure that element.out is always fired, even if the
   * browser swallows an element.out event.
   *
   * Event sequence:
   *
   * element.hover
   * (element.out >> sometimes swallowed)
   * element.hover >> ensure we fired element.out
   */
  (function() {
    var hoverGfx;
    var hover;

    eventBus.on('element.hover', function(event) {

      // (1) remember current hover element
      hoverGfx = event.gfx;
      hover = event.element;
    });

    eventBus.on('element.hover', HIGH_PRIORITY, function(event) {

      // (3) am I on an element still?
      if (hover) {

        // (4) that is a problem, gotta "simulate the out"
        eventBus.fire('element.out', {
          element: hover,
          gfx: hoverGfx
        });
      }

    });

    eventBus.on('element.out', function() {

      // (2) unset hover state if we correctly outed us *GG*
      hoverGfx = null;
      hover = null;
    });

  })();

  this._findTargetGfx = function(event) {
    var position,
        target;

    if (!(event instanceof MouseEvent)) {
      return;
    }

    position = (0,_util_Event__WEBPACK_IMPORTED_MODULE_0__.toPoint)(event);

    // damn expensive operation, ouch!
    target = document.elementFromPoint(position.x, position.y);

    return getGfx(target);
  };

}

HoverFix.$inject = [
  'elementRegistry',
  'eventBus',
  'injector'
];


// helpers /////////////////////

function getGfx(target) {
  return (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.closest)(target, 'svg, .djs-element', true);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/hover-fix/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/hover-fix/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _HoverFix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HoverFix */ "./node_modules/diagram-js/lib/features/hover-fix/HoverFix.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [
    'hoverFix'
  ],
  hoverFix: [ 'type', _HoverFix__WEBPACK_IMPORTED_MODULE_0__.default ],
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ InteractionEvents)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/RenderUtil */ "./node_modules/diagram-js/lib/util/RenderUtil.js");










function allowAll(event) { return true; }

function allowPrimaryAndAuxiliary(event) {
  return (0,_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.isPrimaryButton)(event) || (0,_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.isAuxiliaryButton)(event);
}

var LOW_PRIORITY = 500;


/**
 * A plugin that provides interaction events for diagram elements.
 *
 * It emits the following events:
 *
 *   * element.click
 *   * element.contextmenu
 *   * element.dblclick
 *   * element.hover
 *   * element.mousedown
 *   * element.mousemove
 *   * element.mouseup
 *   * element.out
 *
 * Each event is a tuple { element, gfx, originalEvent }.
 *
 * Canceling the event via Event#preventDefault()
 * prevents the original DOM operation.
 *
 * @param {EventBus} eventBus
 */
function InteractionEvents(eventBus, elementRegistry, styles) {

  var self = this;

  /**
   * Fire an interaction event.
   *
   * @param {string} type local event name, e.g. element.click.
   * @param {DOMEvent} event native event
   * @param {djs.model.Base} [element] the diagram element to emit the event on;
   *                                   defaults to the event target
   */
  function fire(type, event, element) {

    if (isIgnored(type, event)) {
      return;
    }

    var target, gfx, returnValue;

    if (!element) {
      target = event.delegateTarget || event.target;

      if (target) {
        gfx = target;
        element = elementRegistry.get(gfx);
      }
    } else {
      gfx = elementRegistry.getGraphics(element);
    }

    if (!gfx || !element) {
      return;
    }

    returnValue = eventBus.fire(type, {
      element: element,
      gfx: gfx,
      originalEvent: event
    });

    if (returnValue === false) {
      event.stopPropagation();
      event.preventDefault();
    }
  }

  // TODO(nikku): document this
  var handlers = {};

  function mouseHandler(localEventName) {
    return handlers[localEventName];
  }

  function isIgnored(localEventName, event) {

    var filter = ignoredFilters[localEventName] || _util_Mouse__WEBPACK_IMPORTED_MODULE_0__.isPrimaryButton;

    // only react on left mouse button interactions
    // except for interaction events that are enabled
    // for secundary mouse button
    return !filter(event);
  }

  var bindings = {
    click: 'element.click',
    contextmenu: 'element.contextmenu',
    dblclick: 'element.dblclick',
    mousedown: 'element.mousedown',
    mousemove: 'element.mousemove',
    mouseover: 'element.hover',
    mouseout: 'element.out',
    mouseup: 'element.mouseup',
  };

  var ignoredFilters = {
    'element.contextmenu': allowAll,
    'element.mousedown': allowPrimaryAndAuxiliary,
    'element.mouseup': allowPrimaryAndAuxiliary,
    'element.click': allowPrimaryAndAuxiliary,
    'element.dblclick': allowPrimaryAndAuxiliary
  };


  // manual event trigger //////////

  /**
   * Trigger an interaction event (based on a native dom event)
   * on the target shape or connection.
   *
   * @param {string} eventName the name of the triggered DOM event
   * @param {MouseEvent} event
   * @param {djs.model.Base} targetElement
   */
  function triggerMouseEvent(eventName, event, targetElement) {

    // i.e. element.mousedown...
    var localEventName = bindings[eventName];

    if (!localEventName) {
      throw new Error('unmapped DOM event name <' + eventName + '>');
    }

    return fire(localEventName, event, targetElement);
  }


  var ELEMENT_SELECTOR = 'svg, .djs-element';

  // event handling ///////

  function registerEvent(node, event, localEvent, ignoredFilter) {

    var handler = handlers[localEvent] = function(event) {
      fire(localEvent, event);
    };

    if (ignoredFilter) {
      ignoredFilters[localEvent] = ignoredFilter;
    }

    handler.$delegate = min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(node, ELEMENT_SELECTOR, event, handler);
  }

  function unregisterEvent(node, event, localEvent) {

    var handler = mouseHandler(localEvent);

    if (!handler) {
      return;
    }

    min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.unbind(node, event, handler.$delegate);
  }

  function registerEvents(svg) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(bindings, function(val, key) {
      registerEvent(svg, key, val);
    });
  }

  function unregisterEvents(svg) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(bindings, function(val, key) {
      unregisterEvent(svg, key, val);
    });
  }

  eventBus.on('canvas.destroy', function(event) {
    unregisterEvents(event.svg);
  });

  eventBus.on('canvas.init', function(event) {
    registerEvents(event.svg);
  });


  // hit box updating ////////////////

  eventBus.on([ 'shape.added', 'connection.added' ], function(event) {
    var element = event.element,
        gfx = event.gfx;

    eventBus.fire('interactionEvents.createHit', { element: element, gfx: gfx });
  });

  // Update djs-hit on change.
  // A low priortity is necessary, because djs-hit of labels has to be updated
  // after the label bounds have been updated in the renderer.
  eventBus.on([
    'shape.changed',
    'connection.changed'
  ], LOW_PRIORITY, function(event) {

    var element = event.element,
        gfx = event.gfx;

    eventBus.fire('interactionEvents.updateHit', { element: element, gfx: gfx });
  });

  eventBus.on('interactionEvents.createHit', LOW_PRIORITY, function(event) {
    var element = event.element,
        gfx = event.gfx;

    self.createDefaultHit(element, gfx);
  });

  eventBus.on('interactionEvents.updateHit', function(event) {
    var element = event.element,
        gfx = event.gfx;

    self.updateDefaultHit(element, gfx);
  });


  // hit styles ////////////

  var STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-stroke');

  var CLICK_STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-click-stroke');

  var ALL_HIT_STYLE = createHitStyle('djs-hit djs-hit-all');

  var HIT_TYPES = {
    'all': ALL_HIT_STYLE,
    'click-stroke': CLICK_STROKE_HIT_STYLE,
    'stroke': STROKE_HIT_STYLE
  };

  function createHitStyle(classNames, attrs) {

    attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
      stroke: 'white',
      strokeWidth: 15
    }, attrs || {});

    return styles.cls(classNames, [ 'no-fill', 'no-border' ], attrs);
  }


  // style helpers ///////////////

  function applyStyle(hit, type) {

    var attrs = HIT_TYPES[type];

    if (!attrs) {
      throw new Error('invalid hit type <' + type + '>');
    }

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(hit, attrs);

    return hit;
  }

  function appendHit(gfx, hit) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(gfx, hit);
  }


  // API

  /**
   * Remove hints on the given graphics.
   *
   * @param {SVGElement} gfx
   */
  this.removeHits = function(gfx) {
    var hits = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.queryAll)('.djs-hit', gfx);

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(hits, tiny_svg__WEBPACK_IMPORTED_MODULE_3__.remove);
  };

  /**
   * Create default hit for the given element.
   *
   * @param {djs.model.Base} element
   * @param {SVGElement} gfx
   *
   * @return {SVGElement} created hit
   */
  this.createDefaultHit = function(element, gfx) {
    var waypoints = element.waypoints,
        isFrame = element.isFrame,
        boxType;

    if (waypoints) {
      return this.createWaypointsHit(gfx, waypoints);
    } else {

      boxType = isFrame ? 'stroke' : 'all';

      return this.createBoxHit(gfx, boxType, {
        width: element.width,
        height: element.height
      });
    }
  };

  /**
   * Create hits for the given waypoints.
   *
   * @param {SVGElement} gfx
   * @param {Array<Point>} waypoints
   *
   * @return {SVGElement}
   */
  this.createWaypointsHit = function(gfx, waypoints) {

    var hit = (0,_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__.createLine)(waypoints);

    applyStyle(hit, 'stroke');

    appendHit(gfx, hit);

    return hit;
  };

  /**
   * Create hits for a box.
   *
   * @param {SVGElement} gfx
   * @param {string} hitType
   * @param {Object} attrs
   *
   * @return {SVGElement}
   */
  this.createBoxHit = function(gfx, type, attrs) {

    attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
      x: 0,
      y: 0
    }, attrs);

    var hit = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('rect');

    applyStyle(hit, type);

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(hit, attrs);

    appendHit(gfx, hit);

    return hit;
  };

  /**
   * Update default hit of the element.
   *
   * @param  {djs.model.Base} element
   * @param  {SVGElement} gfx
   *
   * @return {SVGElement} updated hit
   */
  this.updateDefaultHit = function(element, gfx) {

    var hit = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.query)('.djs-hit', gfx);

    if (!hit) {
      return;
    }

    if (element.waypoints) {
      (0,_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__.updateLine)(hit, element.waypoints);
    } else {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(hit, {
        width: element.width,
        height: element.height
      });
    }

    return hit;
  };

  this.fire = fire;

  this.triggerMouseEvent = triggerMouseEvent;

  this.mouseHandler = mouseHandler;

  this.registerEvent = registerEvent;
  this.unregisterEvent = unregisterEvent;
}


InteractionEvents.$inject = [
  'eventBus',
  'elementRegistry',
  'styles'
];


/**
 * An event indicating that the mouse hovered over an element
 *
 * @event element.hover
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has left an element
 *
 * @event element.out
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has clicked an element
 *
 * @event element.click
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has double clicked an element
 *
 * @event element.dblclick
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has gone down on an element.
 *
 * @event element.mousedown
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has gone up on an element.
 *
 * @event element.mouseup
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the context menu action is triggered
 * via mouse or touch controls.
 *
 * @event element.contextmenu
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/interaction-events/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/interaction-events/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _InteractionEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InteractionEvents */ "./node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'interactionEvents' ],
  interactionEvents: [ 'type', _InteractionEvents__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard-move-selection/KeyboardMoveSelection.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard-move-selection/KeyboardMoveSelection.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ KeyboardMoveSelection)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



var DEFAULT_CONFIG = {
  moveSpeed: 1,
  moveSpeedAccelerated: 10
};

var HIGHER_PRIORITY = 1500;

var LEFT = 'left';
var UP = 'up';
var RIGHT = 'right';
var DOWN = 'down';

var KEY_TO_DIRECTION = {
  ArrowLeft: LEFT,
  Left: LEFT,
  ArrowUp: UP,
  Up: UP,
  ArrowRight: RIGHT,
  Right: RIGHT,
  ArrowDown: DOWN,
  Down: DOWN
};

var DIRECTIONS_DELTA = {
  left: function(speed) {
    return {
      x: -speed,
      y: 0
    };
  },
  up: function(speed) {
    return {
      x: 0,
      y: -speed
    };
  },
  right: function(speed) {
    return {
      x: speed,
      y: 0
    };
  },
  down: function(speed) {
    return {
      x: 0,
      y: speed
    };
  }
};


/**
 * Enables to move selection with keyboard arrows.
 * Use with Shift for modified speed (default=1, with Shift=10).
 * Pressed Cmd/Ctrl turns the feature off.
 *
 * @param {Object} config
 * @param {number} [config.moveSpeed=1]
 * @param {number} [config.moveSpeedAccelerated=10]
 * @param {Keyboard} keyboard
 * @param {Modeling} modeling
 * @param {Selection} selection
 */
function KeyboardMoveSelection(
    config,
    keyboard,
    modeling,
    rules,
    selection
) {

  var self = this;

  this._config = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, DEFAULT_CONFIG, config || {});

  keyboard.addListener(HIGHER_PRIORITY, function(event) {

    var keyEvent = event.keyEvent;

    var direction = KEY_TO_DIRECTION[keyEvent.key];

    if (!direction) {
      return;
    }

    if (keyboard.isCmd(keyEvent)) {
      return;
    }

    var accelerated = keyboard.isShift(keyEvent);

    self.moveSelection(direction, accelerated);

    return true;
  });


  /**
   * Move selected elements in the given direction,
   * optionally specifying accelerated movement.
   *
   * @param {string} direction
   * @param {boolean} [accelerated=false]
   */
  this.moveSelection = function(direction, accelerated) {

    var selectedElements = selection.get();

    if (!selectedElements.length) {
      return;
    }

    var speed = this._config[
      accelerated ?
        'moveSpeedAccelerated' :
        'moveSpeed'
    ];

    var delta = DIRECTIONS_DELTA[direction](speed);

    var canMove = rules.allowed('elements.move', {
      shapes: selectedElements
    });

    if (canMove) {
      modeling.moveElements(selectedElements, delta);
    }
  };

}

KeyboardMoveSelection.$inject = [
  'config.keyboardMoveSelection',
  'keyboard',
  'modeling',
  'rules',
  'selection'
];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard-move-selection/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard-move-selection/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../keyboard */ "./node_modules/diagram-js/lib/features/keyboard/index.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _KeyboardMoveSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KeyboardMoveSelection */ "./node_modules/diagram-js/lib/features/keyboard-move-selection/KeyboardMoveSelection.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _keyboard__WEBPACK_IMPORTED_MODULE_0__.default,
    _selection__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [
    'keyboardMoveSelection'
  ],
  keyboardMoveSelection: [ 'type', _KeyboardMoveSelection__WEBPACK_IMPORTED_MODULE_2__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard/Keyboard.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard/Keyboard.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Keyboard)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _KeyboardUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KeyboardUtil */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js");






var KEYDOWN_EVENT = 'keyboard.keydown',
    KEYUP_EVENT = 'keyboard.keyup';

var DEFAULT_PRIORITY = 1000;


/**
 * A keyboard abstraction that may be activated and
 * deactivated by users at will, consuming key events
 * and triggering diagram actions.
 *
 * For keys pressed down, keyboard fires `keyboard.keydown` event.
 * The event context contains one field which is `KeyboardEvent` event.
 *
 * The implementation fires the following key events that allow
 * other components to hook into key handling:
 *
 *  - keyboard.bind
 *  - keyboard.unbind
 *  - keyboard.init
 *  - keyboard.destroy
 *
 * All events contain one field which is node.
 *
 * A default binding for the keyboard may be specified via the
 * `keyboard.bindTo` configuration option.
 *
 * @param {Config} config
 * @param {EventBus} eventBus
 */
function Keyboard(config, eventBus) {
  var self = this;

  this._config = config || {};
  this._eventBus = eventBus;

  this._keydownHandler = this._keydownHandler.bind(this);
  this._keyupHandler = this._keyupHandler.bind(this);

  // properly clean dom registrations
  eventBus.on('diagram.destroy', function() {
    self._fire('destroy');

    self.unbind();
  });

  eventBus.on('diagram.init', function() {
    self._fire('init');
  });

  eventBus.on('attach', function() {
    if (config && config.bindTo) {
      self.bind(config.bindTo);
    }
  });

  eventBus.on('detach', function() {
    self.unbind();
  });
}

Keyboard.$inject = [
  'config.keyboard',
  'eventBus'
];

Keyboard.prototype._keydownHandler = function(event) {
  this._keyHandler(event, KEYDOWN_EVENT);
};

Keyboard.prototype._keyupHandler = function(event) {
  this._keyHandler(event, KEYUP_EVENT);
};

Keyboard.prototype._keyHandler = function(event, type) {
  var target = event.target,
      eventBusResult;

  if (isInput(target)) {
    return;
  }

  var context = {
    keyEvent: event
  };

  eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);

  if (eventBusResult) {
    event.preventDefault();
  }
};

Keyboard.prototype.bind = function(node) {

  // make sure that the keyboard is only bound once to the DOM
  this.unbind();

  this._node = node;

  // bind key events
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(node, 'keydown', this._keydownHandler, true);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(node, 'keyup', this._keyupHandler, true);

  this._fire('bind');
};

Keyboard.prototype.getBinding = function() {
  return this._node;
};

Keyboard.prototype.unbind = function() {
  var node = this._node;

  if (node) {
    this._fire('unbind');

    // unbind key events
    min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(node, 'keydown', this._keydownHandler, true);
    min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(node, 'keyup', this._keyupHandler, true);
  }

  this._node = null;
};

Keyboard.prototype._fire = function(event) {
  this._eventBus.fire('keyboard.' + event, { node: this._node });
};

/**
 * Add a listener function that is notified with `KeyboardEvent` whenever
 * the keyboard is bound and the user presses a key. If no priority is
 * provided, the default value of 1000 is used.
 *
 * @param {number} [priority]
 * @param {Function} listener
 * @param {string} type
 */
Keyboard.prototype.addListener = function(priority, listener, type) {
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isFunction)(priority)) {
    type = listener;
    listener = priority;
    priority = DEFAULT_PRIORITY;
  }

  this._eventBus.on(type || KEYDOWN_EVENT, priority, listener);
};

Keyboard.prototype.removeListener = function(listener, type) {
  this._eventBus.off(type || KEYDOWN_EVENT, listener);
};

Keyboard.prototype.hasModifier = _KeyboardUtil__WEBPACK_IMPORTED_MODULE_2__.hasModifier;
Keyboard.prototype.isCmd = _KeyboardUtil__WEBPACK_IMPORTED_MODULE_2__.isCmd;
Keyboard.prototype.isShift = _KeyboardUtil__WEBPACK_IMPORTED_MODULE_2__.isShift;
Keyboard.prototype.isKey = _KeyboardUtil__WEBPACK_IMPORTED_MODULE_2__.isKey;



// helpers ///////

function isInput(target) {
  return target && ((0,min_dom__WEBPACK_IMPORTED_MODULE_0__.matches)(target, 'input, textarea') || target.contentEditable === 'true');
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard/KeyboardBindings.js":
/*!***************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard/KeyboardBindings.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KEYCODE_C": () => (/* binding */ KEYCODE_C),
/* harmony export */   "KEYCODE_V": () => (/* binding */ KEYCODE_V),
/* harmony export */   "KEYCODE_Y": () => (/* binding */ KEYCODE_Y),
/* harmony export */   "KEYCODE_Z": () => (/* binding */ KEYCODE_Z),
/* harmony export */   "KEYS_COPY": () => (/* binding */ KEYS_COPY),
/* harmony export */   "KEYS_PASTE": () => (/* binding */ KEYS_PASTE),
/* harmony export */   "KEYS_REDO": () => (/* binding */ KEYS_REDO),
/* harmony export */   "KEYS_UNDO": () => (/* binding */ KEYS_UNDO),
/* harmony export */   "default": () => (/* binding */ KeyboardBindings)
/* harmony export */ });
/* harmony import */ var _KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KeyboardUtil */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js");


var LOW_PRIORITY = 500;

var KEYCODE_C = 67;
var KEYCODE_V = 86;
var KEYCODE_Y = 89;
var KEYCODE_Z = 90;

var KEYS_COPY = ['c', 'C', KEYCODE_C ];
var KEYS_PASTE = [ 'v', 'V', KEYCODE_V ];
var KEYS_REDO = [ 'y', 'Y', KEYCODE_Y ];
var KEYS_UNDO = [ 'z', 'Z', KEYCODE_Z ];


/**
 * Adds default keyboard bindings.
 *
 * This does not pull in any features will bind only actions that
 * have previously been registered against the editorActions component.
 *
 * @param {EventBus} eventBus
 * @param {Keyboard} keyboard
 */
function KeyboardBindings(eventBus, keyboard) {

  var self = this;

  eventBus.on('editorActions.init', LOW_PRIORITY, function(event) {

    var editorActions = event.editorActions;

    self.registerBindings(keyboard, editorActions);
  });
}

KeyboardBindings.$inject = [
  'eventBus',
  'keyboard'
];


/**
 * Register available keyboard bindings.
 *
 * @param {Keyboard} keyboard
 * @param {EditorActions} editorActions
 */
KeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {

  /**
   * Add keyboard binding if respective editor action
   * is registered.
   *
   * @param {string} action name
   * @param {Function} fn that implements the key binding
   */
  function addListener(action, fn) {

    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  }


  // undo
  // (CTRL|CMD) + Z
  addListener('undo', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event) && !(0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isShift)(event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(KEYS_UNDO, event)) {
      editorActions.trigger('undo');

      return true;
    }
  });

  // redo
  // CTRL + Y
  // CMD + SHIFT + Z
  addListener('redo', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event) && ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(KEYS_REDO, event) || ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(KEYS_UNDO, event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isShift)(event)))) {
      editorActions.trigger('redo');

      return true;
    }
  });

  // copy
  // CTRL/CMD + C
  addListener('copy', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(KEYS_COPY, event)) {
      editorActions.trigger('copy');

      return true;
    }
  });

  // paste
  // CTRL/CMD + V
  addListener('paste', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(KEYS_PASTE, event)) {
      editorActions.trigger('paste');

      return true;
    }
  });

  // zoom in one step
  // CTRL/CMD + +
  addListener('stepZoom', function(context) {

    var event = context.keyEvent;

    // quirk: it has to be triggered by `=` as well to work on international keyboard layout
    // cf: https://github.com/bpmn-io/bpmn-js/issues/1362#issuecomment-722989754
    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)([ '+', 'Add', '=' ], event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event)) {
      editorActions.trigger('stepZoom', { value: 1 });

      return true;
    }
  });

  // zoom out one step
  // CTRL + -
  addListener('stepZoom', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)([ '-', 'Subtract' ], event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event)) {
      editorActions.trigger('stepZoom', { value: -1 });

      return true;
    }
  });

  // zoom to the default level
  // CTRL + 0
  addListener('zoom', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)('0', event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event)) {
      editorActions.trigger('zoom', { value: 1 });

      return true;
    }
  });

  // delete selected element
  // DEL
  addListener('removeSelection', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(['Backspace', 'Delete', 'Del' ], event)) {
      editorActions.trigger('removeSelection');

      return true;
    }
  });
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js":
/*!***********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasModifier": () => (/* binding */ hasModifier),
/* harmony export */   "isCmd": () => (/* binding */ isCmd),
/* harmony export */   "isKey": () => (/* binding */ isKey),
/* harmony export */   "isShift": () => (/* binding */ isShift)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * Returns true if event was triggered with any modifier
 * @param {KeyboardEvent} event
 */
function hasModifier(event) {
  return (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey);
}

/**
 * @param {KeyboardEvent} event
 */
function isCmd(event) {

  // ensure we don't react to AltGr
  // (mapped to CTRL + ALT)
  if (event.altKey) {
    return false;
  }

  return event.ctrlKey || event.metaKey;
}

/**
 * Checks if key pressed is one of provided keys.
 *
 * @param {string|Array<string>} keys
 * @param {KeyboardEvent} event
 */
function isKey(keys, event) {
  keys = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(keys) ? keys : [ keys ];

  return keys.indexOf(event.key) !== -1 || keys.indexOf(event.keyCode) !== -1;
}

/**
 * @param {KeyboardEvent} event
 */
function isShift(event) {
  return event.shiftKey;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Keyboard */ "./node_modules/diagram-js/lib/features/keyboard/Keyboard.js");
/* harmony import */ var _KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyboardBindings */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardBindings.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'keyboard', 'keyboardBindings' ],
  keyboard: [ 'type', _Keyboard__WEBPACK_IMPORTED_MODULE_0__.default ],
  keyboardBindings: [ 'type', _KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/label-support/LabelSupport.js":
/*!****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/label-support/LabelSupport.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LabelSupport)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");
/* harmony import */ var _util_Removal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Removal */ "./node_modules/diagram-js/lib/util/Removal.js");
/* harmony import */ var _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");




var LOW_PRIORITY = 250,
    HIGH_PRIORITY = 1400;








/**
 * A handler that makes sure labels are properly moved with
 * their label targets.
 *
 * @param {didi.Injector} injector
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 */
function LabelSupport(injector, eventBus, modeling) {

  _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  var movePreview = injector.get('movePreview', false);

  // remove labels from the collection that are being
  // moved with other elements anyway
  eventBus.on('shape.move.start', HIGH_PRIORITY, function(e) {

    var context = e.context,
        shapes = context.shapes,
        validatedShapes = context.validatedShapes;

    context.shapes = removeLabels(shapes);
    context.validatedShapes = removeLabels(validatedShapes);
  });

  // add labels to visual's group
  movePreview && eventBus.on('shape.move.start', LOW_PRIORITY, function(e) {

    var context = e.context,
        shapes = context.shapes;

    var labels = [];

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(shapes, function(element) {

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(element.labels, function(label) {

        if (!label.hidden && context.shapes.indexOf(label) === -1) {
          labels.push(label);
        }

        if (element.labelTarget) {
          labels.push(element);
        }
      });
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(labels, function(label) {
      movePreview.makeDraggable(context, label, true);
    });

  });

  // add all labels to move closure
  this.preExecuted('elements.move', HIGH_PRIORITY, function(e) {
    var context = e.context,
        closure = context.closure,
        enclosedElements = closure.enclosedElements;

    var enclosedLabels = [];

    // find labels that are not part of
    // move closure yet and add them
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(enclosedElements, function(element) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(element.labels, function(label) {

        if (!enclosedElements[label.id]) {
          enclosedLabels.push(label);
        }
      });
    });

    closure.addAll(enclosedLabels);
  });


  this.preExecute([
    'connection.delete',
    'shape.delete'
  ], function(e) {

    var context = e.context,
        element = context.connection || context.shape;

    (0,_util_Removal__WEBPACK_IMPORTED_MODULE_3__.saveClear)(element.labels, function(label) {
      modeling.removeShape(label, { nested: true });
    });
  });


  this.execute('shape.delete', function(e) {

    var context = e.context,
        shape = context.shape,
        labelTarget = shape.labelTarget;

    // unset labelTarget
    if (labelTarget) {
      context.labelTargetIndex = (0,_util_Collections__WEBPACK_IMPORTED_MODULE_4__.indexOf)(labelTarget.labels, shape);
      context.labelTarget = labelTarget;

      shape.labelTarget = null;
    }
  });

  this.revert('shape.delete', function(e) {

    var context = e.context,
        shape = context.shape,
        labelTarget = context.labelTarget,
        labelTargetIndex = context.labelTargetIndex;

    // restore labelTarget
    if (labelTarget) {
      (0,_util_Collections__WEBPACK_IMPORTED_MODULE_4__.add)(labelTarget.labels, shape, labelTargetIndex);

      shape.labelTarget = labelTarget;
    }
  });

}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(LabelSupport, _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

LabelSupport.$inject = [
  'injector',
  'eventBus',
  'modeling'
];


/**
 * Return a filtered list of elements that do not
 * contain attached elements with hosts being part
 * of the selection.
 *
 * @param  {Array<djs.model.Base>} elements
 *
 * @return {Array<djs.model.Base>} filtered
 */
function removeLabels(elements) {

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(elements, function(element) {

    // filter out labels that are move together
    // with their label targets
    return elements.indexOf(element.labelTarget) === -1;
  });
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/label-support/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/label-support/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _LabelSupport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LabelSupport */ "./node_modules/diagram-js/lib/features/label-support/LabelSupport.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'labelSupport'],
  labelSupport: [ 'type', _LabelSupport__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LassoTool)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");








var LASSO_TOOL_CURSOR = 'crosshair';


function LassoTool(
    eventBus, canvas, dragging,
    elementRegistry, selection, toolManager,
    mouse) {

  this._selection = selection;
  this._dragging = dragging;
  this._mouse = mouse;

  var self = this;

  // lasso visuals implementation

  /**
  * A helper that realizes the selection box visual
  */
  var visuals = {

    create: function(context) {
      var container = canvas.getDefaultLayer(),
          frame;

      frame = context.frame = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('rect');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(frame, {
        class: 'djs-lasso-overlay',
        width:  1,
        height: 1,
        x: 0,
        y: 0
      });

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(container, frame);
    },

    update: function(context) {
      var frame = context.frame,
          bbox = context.bbox;

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(frame, {
        x: bbox.x,
        y: bbox.y,
        width: bbox.width,
        height: bbox.height
      });
    },

    remove: function(context) {

      if (context.frame) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.remove)(context.frame);
      }
    }
  };

  toolManager.registerTool('lasso', {
    tool: 'lasso.selection',
    dragging: 'lasso'
  });

  eventBus.on('lasso.selection.end', function(event) {
    var target = event.originalEvent.target;

    // only reactive on diagram click
    // on some occasions, event.hover is not set and we have to check if the target is an svg
    if (!event.hover && !(target instanceof SVGElement)) {
      return;
    }

    eventBus.once('lasso.selection.ended', function() {
      self.activateLasso(event.originalEvent, true);
    });
  });

  // lasso interaction implementation

  eventBus.on('lasso.end', function(event) {

    var bbox = toBBox(event);

    var elements = elementRegistry.filter(function(element) {
      return element;
    });

    self.select(elements, bbox);
  });

  eventBus.on('lasso.start', function(event) {

    var context = event.context;

    context.bbox = toBBox(event);
    visuals.create(context);
  });

  eventBus.on('lasso.move', function(event) {

    var context = event.context;

    context.bbox = toBBox(event);
    visuals.update(context);
  });

  eventBus.on('lasso.cleanup', function(event) {

    var context = event.context;

    visuals.remove(context);
  });


  // event integration

  eventBus.on('element.mousedown', 1500, function(event) {

    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.hasSecondaryModifier)(event)) {
      return;
    }

    self.activateLasso(event.originalEvent);

    // we've handled the event
    return true;
  });
}

LassoTool.$inject = [
  'eventBus',
  'canvas',
  'dragging',
  'elementRegistry',
  'selection',
  'toolManager',
  'mouse'
];


LassoTool.prototype.activateLasso = function(event, autoActivate) {

  this._dragging.init(event, 'lasso', {
    autoActivate: autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    }
  });
};

LassoTool.prototype.activateSelection = function(event, autoActivate) {

  this._dragging.init(event, 'lasso.selection', {
    trapClick: false,
    autoActivate: autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    }
  });
};

LassoTool.prototype.select = function(elements, bbox) {
  var selectedElements = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getEnclosedElements)(elements, bbox);

  this._selection.select((0,min_dash__WEBPACK_IMPORTED_MODULE_3__.values)(selectedElements));
};

LassoTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }

  var mouseEvent = this._mouse.getLastMoveEvent();

  this.activateSelection(mouseEvent, !!mouseEvent);
};

LassoTool.prototype.isActive = function() {
  var context = this._dragging.context();

  return context && /^lasso/.test(context.prefix);
};



function toBBox(event) {

  var start = {

    x: event.x - event.dx,
    y: event.y - event.dy
  };

  var end = {
    x: event.x,
    y: event.y
  };

  var bbox;

  if ((start.x <= end.x && start.y < end.y) ||
      (start.x < end.x && start.y <= end.y)) {

    bbox = {
      x: start.x,
      y: start.y,
      width:  end.x - start.x,
      height: end.y - start.y
    };
  } else if ((start.x >= end.x && start.y < end.y) ||
             (start.x > end.x && start.y <= end.y)) {

    bbox = {
      x: end.x,
      y: start.y,
      width:  start.x - end.x,
      height: end.y - start.y
    };
  } else if ((start.x <= end.x && start.y > end.y) ||
             (start.x < end.x && start.y >= end.y)) {

    bbox = {
      x: start.x,
      y: end.y,
      width:  end.x - start.x,
      height: start.y - end.y
    };
  } else if ((start.x >= end.x && start.y > end.y) ||
             (start.x > end.x && start.y >= end.y)) {

    bbox = {
      x: end.x,
      y: end.y,
      width:  start.x - end.x,
      height: start.y - end.y
    };
  } else {

    bbox = {
      x: end.x,
      y: end.y,
      width:  0,
      height: 0
    };
  }
  return bbox;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/lasso-tool/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/lasso-tool/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tool_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tool-manager */ "./node_modules/diagram-js/lib/features/tool-manager/index.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mouse */ "./node_modules/diagram-js/lib/features/mouse/index.js");
/* harmony import */ var _LassoTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LassoTool */ "./node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _tool_manager__WEBPACK_IMPORTED_MODULE_0__.default,
    _mouse__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [ 'lassoTool' ],
  lassoTool: [ 'type', _LassoTool__WEBPACK_IMPORTED_MODULE_2__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/Modeling.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/Modeling.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Modeling)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../model */ "./node_modules/diagram-js/lib/model/index.js");
/* harmony import */ var _cmd_AlignElementsHandler__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./cmd/AlignElementsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/AlignElementsHandler.js");
/* harmony import */ var _cmd_AppendShapeHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cmd/AppendShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js");
/* harmony import */ var _cmd_CreateConnectionHandler__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cmd/CreateConnectionHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js");
/* harmony import */ var _cmd_CreateElementsHandler__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./cmd/CreateElementsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateElementsHandler.js");
/* harmony import */ var _cmd_CreateLabelHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cmd/CreateLabelHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js");
/* harmony import */ var _cmd_CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cmd/CreateShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js");
/* harmony import */ var _cmd_DeleteConnectionHandler__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cmd/DeleteConnectionHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js");
/* harmony import */ var _cmd_DeleteElementsHandler__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./cmd/DeleteElementsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js");
/* harmony import */ var _cmd_DeleteShapeHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cmd/DeleteShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js");
/* harmony import */ var _cmd_DistributeElementsHandler__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cmd/DistributeElementsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js");
/* harmony import */ var _cmd_LayoutConnectionHandler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./cmd/LayoutConnectionHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js");
/* harmony import */ var _cmd_MoveConnectionHandler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./cmd/MoveConnectionHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js");
/* harmony import */ var _cmd_MoveElementsHandler__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./cmd/MoveElementsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveElementsHandler.js");
/* harmony import */ var _cmd_MoveShapeHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cmd/MoveShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js");
/* harmony import */ var _cmd_ReconnectConnectionHandler__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./cmd/ReconnectConnectionHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js");
/* harmony import */ var _cmd_ReplaceShapeHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cmd/ReplaceShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js");
/* harmony import */ var _cmd_ResizeShapeHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cmd/ResizeShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js");
/* harmony import */ var _cmd_SpaceToolHandler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cmd/SpaceToolHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js");
/* harmony import */ var _cmd_ToggleShapeCollapseHandler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cmd/ToggleShapeCollapseHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js");
/* harmony import */ var _cmd_UpdateAttachmentHandler__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./cmd/UpdateAttachmentHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/UpdateAttachmentHandler.js");
/* harmony import */ var _cmd_UpdateWaypointsHandler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./cmd/UpdateWaypointsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js");



























/**
 * The basic modeling entry point.
 *
 * @param {EventBus} eventBus
 * @param {ElementFactory} elementFactory
 * @param {CommandStack} commandStack
 */
function Modeling(eventBus, elementFactory, commandStack) {
  this._eventBus = eventBus;
  this._elementFactory = elementFactory;
  this._commandStack = commandStack;

  var self = this;

  eventBus.on('diagram.init', function() {

    // register modeling handlers
    self.registerHandlers(commandStack);
  });
}

Modeling.$inject = [ 'eventBus', 'elementFactory', 'commandStack' ];


Modeling.prototype.getHandlers = function() {
  return {
    'shape.append': _cmd_AppendShapeHandler__WEBPACK_IMPORTED_MODULE_0__.default,
    'shape.create': _cmd_CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__.default,
    'shape.delete': _cmd_DeleteShapeHandler__WEBPACK_IMPORTED_MODULE_2__.default,
    'shape.move': _cmd_MoveShapeHandler__WEBPACK_IMPORTED_MODULE_3__.default,
    'shape.resize': _cmd_ResizeShapeHandler__WEBPACK_IMPORTED_MODULE_4__.default,
    'shape.replace': _cmd_ReplaceShapeHandler__WEBPACK_IMPORTED_MODULE_5__.default,
    'shape.toggleCollapse': _cmd_ToggleShapeCollapseHandler__WEBPACK_IMPORTED_MODULE_6__.default,

    'spaceTool': _cmd_SpaceToolHandler__WEBPACK_IMPORTED_MODULE_7__.default,

    'label.create': _cmd_CreateLabelHandler__WEBPACK_IMPORTED_MODULE_8__.default,

    'connection.create': _cmd_CreateConnectionHandler__WEBPACK_IMPORTED_MODULE_9__.default,
    'connection.delete': _cmd_DeleteConnectionHandler__WEBPACK_IMPORTED_MODULE_10__.default,
    'connection.move': _cmd_MoveConnectionHandler__WEBPACK_IMPORTED_MODULE_11__.default,
    'connection.layout': _cmd_LayoutConnectionHandler__WEBPACK_IMPORTED_MODULE_12__.default,

    'connection.updateWaypoints': _cmd_UpdateWaypointsHandler__WEBPACK_IMPORTED_MODULE_13__.default,

    'connection.reconnect': _cmd_ReconnectConnectionHandler__WEBPACK_IMPORTED_MODULE_14__.default,

    'elements.create': _cmd_CreateElementsHandler__WEBPACK_IMPORTED_MODULE_15__.default,
    'elements.move': _cmd_MoveElementsHandler__WEBPACK_IMPORTED_MODULE_16__.default,
    'elements.delete': _cmd_DeleteElementsHandler__WEBPACK_IMPORTED_MODULE_17__.default,

    'elements.distribute': _cmd_DistributeElementsHandler__WEBPACK_IMPORTED_MODULE_18__.default,
    'elements.align': _cmd_AlignElementsHandler__WEBPACK_IMPORTED_MODULE_19__.default,

    'element.updateAttachment': _cmd_UpdateAttachmentHandler__WEBPACK_IMPORTED_MODULE_20__.default
  };
};

/**
 * Register handlers with the command stack
 *
 * @param {CommandStack} commandStack
 */
Modeling.prototype.registerHandlers = function(commandStack) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_21__.forEach)(this.getHandlers(), function(handler, id) {
    commandStack.registerHandler(id, handler);
  });
};


// modeling helpers //////////////////////

Modeling.prototype.moveShape = function(shape, delta, newParent, newParentIndex, hints) {

  if (typeof newParentIndex === 'object') {
    hints = newParentIndex;
    newParentIndex = null;
  }

  var context = {
    shape: shape,
    delta:  delta,
    newParent: newParent,
    newParentIndex: newParentIndex,
    hints: hints || {}
  };

  this._commandStack.execute('shape.move', context);
};


/**
 * Update the attachment of the given shape.
 *
 * @param {djs.mode.Base} shape
 * @param {djs.model.Base} [newHost]
 */
Modeling.prototype.updateAttachment = function(shape, newHost) {
  var context = {
    shape: shape,
    newHost: newHost
  };

  this._commandStack.execute('element.updateAttachment', context);
};


/**
 * Move a number of shapes to a new target, either setting it as
 * the new parent or attaching it.
 *
 * @param {Array<djs.mode.Base>} shapes
 * @param {Point} delta
 * @param {djs.model.Base} [target]
 * @param {Object} [hints]
 * @param {boolean} [hints.attach=false]
 */
Modeling.prototype.moveElements = function(shapes, delta, target, hints) {

  hints = hints || {};

  var attach = hints.attach;

  var newParent = target,
      newHost;

  if (attach === true) {
    newHost = target;
    newParent = target.parent;
  } else

  if (attach === false) {
    newHost = null;
  }

  var context = {
    shapes: shapes,
    delta: delta,
    newParent: newParent,
    newHost: newHost,
    hints: hints
  };

  this._commandStack.execute('elements.move', context);
};


Modeling.prototype.moveConnection = function(connection, delta, newParent, newParentIndex, hints) {

  if (typeof newParentIndex === 'object') {
    hints = newParentIndex;
    newParentIndex = undefined;
  }

  var context = {
    connection: connection,
    delta: delta,
    newParent: newParent,
    newParentIndex: newParentIndex,
    hints: hints || {}
  };

  this._commandStack.execute('connection.move', context);
};


Modeling.prototype.layoutConnection = function(connection, hints) {
  var context = {
    connection: connection,
    hints: hints || {}
  };

  this._commandStack.execute('connection.layout', context);
};


/**
 * Create connection.
 *
 * @param {djs.model.Base} source
 * @param {djs.model.Base} target
 * @param {number} [parentIndex]
 * @param {Object|djs.model.Connection} connection
 * @param {djs.model.Base} parent
 * @param {Object} hints
 *
 * @return {djs.model.Connection} the created connection.
 */
Modeling.prototype.createConnection = function(source, target, parentIndex, connection, parent, hints) {

  if (typeof parentIndex === 'object') {
    hints = parent;
    parent = connection;
    connection = parentIndex;
    parentIndex = undefined;
  }

  connection = this._create('connection', connection);

  var context = {
    source: source,
    target: target,
    parent: parent,
    parentIndex: parentIndex,
    connection: connection,
    hints: hints
  };

  this._commandStack.execute('connection.create', context);

  return context.connection;
};


/**
 * Create a shape at the specified position.
 *
 * @param {djs.model.Shape|Object} shape
 * @param {Point} position
 * @param {djs.model.Shape|djs.model.Root} target
 * @param {number} [parentIndex] position in parents children list
 * @param {Object} [hints]
 * @param {boolean} [hints.attach] whether to attach to target or become a child
 *
 * @return {djs.model.Shape} the created shape
 */
Modeling.prototype.createShape = function(shape, position, target, parentIndex, hints) {

  if (typeof parentIndex !== 'number') {
    hints = parentIndex;
    parentIndex = undefined;
  }

  hints = hints || {};

  var attach = hints.attach,
      parent,
      host;

  shape = this._create('shape', shape);

  if (attach) {
    parent = target.parent;
    host = target;
  } else {
    parent = target;
  }

  var context = {
    position: position,
    shape: shape,
    parent: parent,
    parentIndex: parentIndex,
    host: host,
    hints: hints
  };

  this._commandStack.execute('shape.create', context);

  return context.shape;
};


Modeling.prototype.createElements = function(elements, position, parent, parentIndex, hints) {
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_21__.isArray)(elements)) {
    elements = [ elements ];
  }

  if (typeof parentIndex !== 'number') {
    hints = parentIndex;
    parentIndex = undefined;
  }

  hints = hints || {};

  var context = {
    position: position,
    elements: elements,
    parent: parent,
    parentIndex: parentIndex,
    hints: hints
  };

  this._commandStack.execute('elements.create', context);

  return context.elements;
};


Modeling.prototype.createLabel = function(labelTarget, position, label, parent) {

  label = this._create('label', label);

  var context = {
    labelTarget: labelTarget,
    position: position,
    parent: parent || labelTarget.parent,
    shape: label
  };

  this._commandStack.execute('label.create', context);

  return context.shape;
};


/**
 * Append shape to given source, drawing a connection
 * between source and the newly created shape.
 *
 * @param {djs.model.Shape} source
 * @param {djs.model.Shape|Object} shape
 * @param {Point} position
 * @param {djs.model.Shape} target
 * @param {Object} [hints]
 * @param {boolean} [hints.attach]
 * @param {djs.model.Connection|Object} [hints.connection]
 * @param {djs.model.Base} [hints.connectionParent]
 *
 * @return {djs.model.Shape} the newly created shape
 */
Modeling.prototype.appendShape = function(source, shape, position, target, hints) {

  hints = hints || {};

  shape = this._create('shape', shape);

  var context = {
    source: source,
    position: position,
    target: target,
    shape: shape,
    connection: hints.connection,
    connectionParent: hints.connectionParent,
    hints: hints
  };

  this._commandStack.execute('shape.append', context);

  return context.shape;
};


Modeling.prototype.removeElements = function(elements) {
  var context = {
    elements: elements
  };

  this._commandStack.execute('elements.delete', context);
};


Modeling.prototype.distributeElements = function(groups, axis, dimension) {
  var context = {
    groups: groups,
    axis: axis,
    dimension: dimension
  };

  this._commandStack.execute('elements.distribute', context);
};


Modeling.prototype.removeShape = function(shape, hints) {
  var context = {
    shape: shape,
    hints: hints || {}
  };

  this._commandStack.execute('shape.delete', context);
};


Modeling.prototype.removeConnection = function(connection, hints) {
  var context = {
    connection: connection,
    hints: hints || {}
  };

  this._commandStack.execute('connection.delete', context);
};

Modeling.prototype.replaceShape = function(oldShape, newShape, hints) {
  var context = {
    oldShape: oldShape,
    newData: newShape,
    hints: hints || {}
  };

  this._commandStack.execute('shape.replace', context);

  return context.newShape;
};

Modeling.prototype.alignElements = function(elements, alignment) {
  var context = {
    elements: elements,
    alignment: alignment
  };

  this._commandStack.execute('elements.align', context);
};

Modeling.prototype.resizeShape = function(shape, newBounds, minBounds, hints) {
  var context = {
    shape: shape,
    newBounds: newBounds,
    minBounds: minBounds,
    hints: hints
  };

  this._commandStack.execute('shape.resize', context);
};

Modeling.prototype.createSpace = function(movingShapes, resizingShapes, delta, direction, start) {
  var context = {
    delta: delta,
    direction: direction,
    movingShapes: movingShapes,
    resizingShapes: resizingShapes,
    start: start
  };

  this._commandStack.execute('spaceTool', context);
};

Modeling.prototype.updateWaypoints = function(connection, newWaypoints, hints) {
  var context = {
    connection: connection,
    newWaypoints: newWaypoints,
    hints: hints || {}
  };

  this._commandStack.execute('connection.updateWaypoints', context);
};

Modeling.prototype.reconnect = function(connection, source, target, dockingOrPoints, hints) {
  var context = {
    connection: connection,
    newSource: source,
    newTarget: target,
    dockingOrPoints: dockingOrPoints,
    hints: hints || {}
  };

  this._commandStack.execute('connection.reconnect', context);
};

Modeling.prototype.reconnectStart = function(connection, newSource, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }

  this.reconnect(connection, newSource, connection.target, dockingOrPoints, (0,min_dash__WEBPACK_IMPORTED_MODULE_21__.assign)(hints, {
    docking: 'source'
  }));
};

Modeling.prototype.reconnectEnd = function(connection, newTarget, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }

  this.reconnect(connection, connection.source, newTarget, dockingOrPoints, (0,min_dash__WEBPACK_IMPORTED_MODULE_21__.assign)(hints, {
    docking: 'target'
  }));
};

Modeling.prototype.connect = function(source, target, attrs, hints) {
  return this.createConnection(source, target, attrs || {}, source.parent, hints);
};

Modeling.prototype._create = function(type, attrs) {
  if (attrs instanceof _model__WEBPACK_IMPORTED_MODULE_22__.Base) {
    return attrs;
  } else {
    return this._elementFactory.create(type, attrs);
  }
};

Modeling.prototype.toggleCollapse = function(shape, hints) {
  var context = {
    shape: shape,
    hints: hints || {}
  };

  this._commandStack.execute('shape.toggleCollapse', context);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/AlignElementsHandler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/AlignElementsHandler.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AlignElements)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * A handler that align elements in a certain way.
 *
 */
function AlignElements(modeling, canvas) {
  this._modeling = modeling;
  this._canvas = canvas;
}

AlignElements.$inject = [ 'modeling', 'canvas' ];


AlignElements.prototype.preExecute = function(context) {
  var modeling = this._modeling;

  var elements = context.elements,
      alignment = context.alignment;


  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    var delta = {
      x: 0,
      y: 0
    };

    if (alignment.left) {
      delta.x = alignment.left - element.x;

    } else if (alignment.right) {
      delta.x = (alignment.right - element.width) - element.x;

    } else if (alignment.center) {
      delta.x = (alignment.center - Math.round(element.width / 2)) - element.x;

    } else if (alignment.top) {
      delta.y = alignment.top - element.y;

    } else if (alignment.bottom) {
      delta.y = (alignment.bottom - element.height) - element.y;

    } else if (alignment.middle) {
      delta.y = (alignment.middle - Math.round(element.height / 2)) - element.y;
    }

    modeling.moveElements([ element ], delta, element.parent);
  });
};

AlignElements.prototype.postExecute = function(context) {

};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AppendShapeHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A handler that implements reversible appending of shapes
 * to a source shape.
 *
 * @param {canvas} Canvas
 * @param {elementFactory} ElementFactory
 * @param {modeling} Modeling
 */
function AppendShapeHandler(modeling) {
  this._modeling = modeling;
}

AppendShapeHandler.$inject = [ 'modeling' ];


// api //////////////////////


/**
 * Creates a new shape
 *
 * @param {Object} context
 * @param {ElementDescriptor} context.shape the new shape
 * @param {ElementDescriptor} context.source the source object
 * @param {ElementDescriptor} context.parent the parent object
 * @param {Point} context.position position of the new element
 */
AppendShapeHandler.prototype.preExecute = function(context) {

  var source = context.source;

  if (!source) {
    throw new Error('source required');
  }

  var target = context.target || source.parent,
      shape = context.shape,
      hints = context.hints || {};

  shape = context.shape =
    this._modeling.createShape(
      shape,
      context.position,
      target, { attach: hints.attach });

  context.shape = shape;
};

AppendShapeHandler.prototype.postExecute = function(context) {
  var hints = context.hints || {};

  if (!existsConnection(context.source, context.shape)) {

    // create connection
    if (hints.connectionTarget === context.source) {
      this._modeling.connect(context.shape, context.source, context.connection);
    } else {
      this._modeling.connect(context.source, context.shape, context.connection);
    }
  }
};


function existsConnection(source, target) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.some)(source.outgoing, function(c) {
    return c.target === target;
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateConnectionHandler)
/* harmony export */ });
function CreateConnectionHandler(canvas, layouter) {
  this._canvas = canvas;
  this._layouter = layouter;
}

CreateConnectionHandler.$inject = [ 'canvas', 'layouter' ];


// api //////////////////////


/**
 * Appends a shape to a target shape
 *
 * @param {Object} context
 * @param {djs.element.Base} context.source the source object
 * @param {djs.element.Base} context.target the parent object
 * @param {Point} context.position position of the new element
 */
CreateConnectionHandler.prototype.execute = function(context) {

  var connection = context.connection,
      source = context.source,
      target = context.target,
      parent = context.parent,
      parentIndex = context.parentIndex,
      hints = context.hints;

  if (!source || !target) {
    throw new Error('source and target required');
  }

  if (!parent) {
    throw new Error('parent required');
  }

  connection.source = source;
  connection.target = target;

  if (!connection.waypoints) {
    connection.waypoints = this._layouter.layoutConnection(connection, hints);
  }

  // add connection
  this._canvas.addConnection(connection, parent, parentIndex);

  return connection;
};

CreateConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;

  this._canvas.removeConnection(connection);

  connection.source = null;
  connection.target = null;

  return connection;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateElementsHandler.js":
/*!************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/CreateElementsHandler.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateElementsHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");




var round = Math.round;

function CreateElementsHandler(modeling) {
  this._modeling = modeling;
}

CreateElementsHandler.$inject = [
  'modeling'
];

CreateElementsHandler.prototype.preExecute = function(context) {
  var elements = context.elements,
      parent = context.parent,
      parentIndex = context.parentIndex,
      position = context.position,
      hints = context.hints;

  var modeling = this._modeling;

  // make sure each element has x and y
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.x)) {
      element.x = 0;
    }

    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.y)) {
      element.y = 0;
    }
  });

  var bbox = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.getBBox)(elements);

  // center elements around position
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    if (isConnection(element)) {
      element.waypoints = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(element.waypoints, function(waypoint) {
        return {
          x: round(waypoint.x - bbox.x - bbox.width / 2 + position.x),
          y: round(waypoint.y - bbox.y - bbox.height / 2 + position.y)
        };
      });
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(element, {
      x: round(element.x - bbox.x - bbox.width / 2 + position.x),
      y: round(element.y - bbox.y - bbox.height / 2 + position.y)
    });
  });

  var parents = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.getParents)(elements);

  var cache = {};

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    if (isConnection(element)) {
      cache[ element.id ] = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(parentIndex) ?
        modeling.createConnection(
          cache[ element.source.id ],
          cache[ element.target.id ],
          parentIndex,
          element,
          element.parent || parent,
          hints
        ) :
        modeling.createConnection(
          cache[ element.source.id ],
          cache[ element.target.id ],
          element,
          element.parent || parent,
          hints
        );

      return;
    }

    var createShapeHints = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, hints);

    if (parents.indexOf(element) === -1) {
      createShapeHints.autoResize = false;
    }

    cache[ element.id ] = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(parentIndex) ?
      modeling.createShape(
        element,
        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.pick)(element, [ 'x', 'y', 'width', 'height' ]),
        element.parent || parent,
        parentIndex,
        createShapeHints
      ) :
      modeling.createShape(
        element,
        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.pick)(element, [ 'x', 'y', 'width', 'height' ]),
        element.parent || parent,
        createShapeHints
      );
  });

  context.elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.values)(cache);
};

// helpers //////////

function isConnection(element) {
  return !!element.waypoints;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateLabelHandler)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CreateShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js");





/**
 * A handler that attaches a label to a given target shape.
 *
 * @param {Canvas} canvas
 */
function CreateLabelHandler(canvas) {
  _CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__.default.call(this, canvas);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(CreateLabelHandler, _CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__.default);

CreateLabelHandler.$inject = [ 'canvas' ];


// api //////////////////////


var originalExecute = _CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__.default.prototype.execute;

/**
 * Appends a label to a target shape.
 *
 * @method CreateLabelHandler#execute
 *
 * @param {Object} context
 * @param {ElementDescriptor} context.target the element the label is attached to
 * @param {ElementDescriptor} context.parent the parent object
 * @param {Point} context.position position of the new element
 */
CreateLabelHandler.prototype.execute = function(context) {

  var label = context.shape;

  ensureValidDimensions(label);

  label.labelTarget = context.labelTarget;

  return originalExecute.call(this, context);
};

var originalRevert = _CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__.default.prototype.revert;

/**
 * Undo append by removing the shape
 */
CreateLabelHandler.prototype.revert = function(context) {
  context.shape.labelTarget = null;

  return originalRevert.call(this, context);
};


// helpers //////////////////////

function ensureValidDimensions(label) {

  // make sure a label has valid { width, height } dimensions
  [ 'width', 'height' ].forEach(function(prop) {
    if (typeof label[prop] === 'undefined') {
      label[prop] = 0;
    }
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateShapeHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var round = Math.round;


/**
 * A handler that implements reversible addition of shapes.
 *
 * @param {canvas} Canvas
 */
function CreateShapeHandler(canvas) {
  this._canvas = canvas;
}

CreateShapeHandler.$inject = [ 'canvas' ];


// api //////////////////////


/**
 * Appends a shape to a target shape
 *
 * @param {Object} context
 * @param {djs.model.Base} context.parent the parent object
 * @param {Point} context.position position of the new element
 */
CreateShapeHandler.prototype.execute = function(context) {

  var shape = context.shape,
      positionOrBounds = context.position,
      parent = context.parent,
      parentIndex = context.parentIndex;

  if (!parent) {
    throw new Error('parent required');
  }

  if (!positionOrBounds) {
    throw new Error('position required');
  }

  // (1) add at event center position _or_ at given bounds
  if (positionOrBounds.width !== undefined) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(shape, positionOrBounds);
  } else {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(shape, {
      x: positionOrBounds.x - round(shape.width / 2),
      y: positionOrBounds.y - round(shape.height / 2)
    });
  }

  // (2) add to canvas
  this._canvas.addShape(shape, parent, parentIndex);

  return shape;
};


/**
 * Undo append by removing the shape
 */
CreateShapeHandler.prototype.revert = function(context) {

  var shape = context.shape;

  // (3) remove form canvas
  this._canvas.removeShape(shape);

  return shape;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DeleteConnectionHandler)
/* harmony export */ });
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");



/**
 * A handler that implements reversible deletion of Connections.
 */
function DeleteConnectionHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}

DeleteConnectionHandler.$inject = [
  'canvas',
  'modeling'
];


DeleteConnectionHandler.prototype.execute = function(context) {

  var connection = context.connection,
      parent = connection.parent;

  context.parent = parent;

  // remember containment
  context.parentIndex = (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.indexOf)(parent.children, connection);

  context.source = connection.source;
  context.target = connection.target;

  this._canvas.removeConnection(connection);

  connection.source = null;
  connection.target = null;

  return connection;
};

/**
 * Command revert implementation.
 */
DeleteConnectionHandler.prototype.revert = function(context) {

  var connection = context.connection,
      parent = context.parent,
      parentIndex = context.parentIndex;

  connection.source = context.source;
  connection.target = context.target;

  // restore containment
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(parent.children, connection, parentIndex);

  this._canvas.addConnection(connection, parent);

  return connection;
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js":
/*!************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DeleteElementsHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



function DeleteElementsHandler(modeling, elementRegistry) {
  this._modeling = modeling;
  this._elementRegistry = elementRegistry;
}

DeleteElementsHandler.$inject = [
  'modeling',
  'elementRegistry'
];


DeleteElementsHandler.prototype.postExecute = function(context) {

  var modeling = this._modeling,
      elementRegistry = this._elementRegistry,
      elements = context.elements;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {

    // element may have been removed with previous
    // remove operations already (e.g. in case of nesting)
    if (!elementRegistry.get(element.id)) {
      return;
    }

    if (element.waypoints) {
      modeling.removeConnection(element);
    } else {
      modeling.removeShape(element);
    }
  });
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DeleteShapeHandler)
/* harmony export */ });
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");
/* harmony import */ var _util_Removal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Removal */ "./node_modules/diagram-js/lib/util/Removal.js");





/**
 * A handler that implements reversible deletion of shapes.
 *
 */
function DeleteShapeHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}

DeleteShapeHandler.$inject = [ 'canvas', 'modeling' ];


/**
 * - Remove connections
 * - Remove all direct children
 */
DeleteShapeHandler.prototype.preExecute = function(context) {

  var modeling = this._modeling;

  var shape = context.shape;

  // remove connections
  (0,_util_Removal__WEBPACK_IMPORTED_MODULE_0__.saveClear)(shape.incoming, function(connection) {

    // To make sure that the connection isn't removed twice
    // For example if a container is removed
    modeling.removeConnection(connection, { nested: true });
  });

  (0,_util_Removal__WEBPACK_IMPORTED_MODULE_0__.saveClear)(shape.outgoing, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });

  // remove child shapes and connections
  (0,_util_Removal__WEBPACK_IMPORTED_MODULE_0__.saveClear)(shape.children, function(child) {
    if (isConnection(child)) {
      modeling.removeConnection(child, { nested: true });
    } else {
      modeling.removeShape(child, { nested: true });
    }
  });
};

/**
 * Remove shape and remember the parent
 */
DeleteShapeHandler.prototype.execute = function(context) {
  var canvas = this._canvas;

  var shape = context.shape,
      oldParent = shape.parent;

  context.oldParent = oldParent;

  // remove containment
  context.oldParentIndex = (0,_util_Collections__WEBPACK_IMPORTED_MODULE_1__.indexOf)(oldParent.children, shape);

  // remove shape
  canvas.removeShape(shape);

  return shape;
};


/**
 * Command revert implementation
 */
DeleteShapeHandler.prototype.revert = function(context) {

  var canvas = this._canvas;

  var shape = context.shape,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex;

  // restore containment
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_1__.add)(oldParent.children, shape, oldParentIndex);

  canvas.addShape(shape, oldParent);

  return shape;
};

function isConnection(element) {
  return element.waypoints;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DistributeElements)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A handler that distributes elements evenly.
 */
function DistributeElements(modeling) {
  this._modeling = modeling;
}

DistributeElements.$inject = [ 'modeling' ];

var OFF_AXIS = {
  x: 'y',
  y: 'x'
};

DistributeElements.prototype.preExecute = function(context) {
  var modeling = this._modeling;

  var groups = context.groups,
      axis = context.axis,
      dimension = context.dimension;

  function updateRange(group, element) {
    group.range.min = Math.min(element[axis], group.range.min);
    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);
  }

  function center(element) {
    return element[axis] + element[dimension] / 2;
  }

  function lastIdx(arr) {
    return arr.length - 1;
  }

  function rangeDiff(range) {
    return range.max - range.min;
  }

  function centerElement(refCenter, element) {
    var delta = { y: 0 };

    delta[axis] = refCenter - center(element);

    if (delta[axis]) {

      delta[OFF_AXIS[axis]] = 0;

      modeling.moveElements([ element ], delta, element.parent);
    }
  }

  var firstGroup = groups[0],
      lastGroupIdx = lastIdx(groups),
      lastGroup = groups[ lastGroupIdx ];

  var margin,
      spaceInBetween,
      groupsSize = 0; // the size of each range

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(groups, function(group, idx) {
    var sortedElements,
        refElem,
        refCenter;

    if (group.elements.length < 2) {
      if (idx && idx !== groups.length - 1) {
        updateRange(group, group.elements[0]);

        groupsSize += rangeDiff(group.range);
      }
      return;
    }

    sortedElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(group.elements, axis);

    refElem = sortedElements[0];

    if (idx === lastGroupIdx) {
      refElem = sortedElements[lastIdx(sortedElements)];
    }

    refCenter = center(refElem);

    // wanna update the ranges after the shapes have been centered
    group.range = null;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(sortedElements, function(element) {

      centerElement(refCenter, element);

      if (group.range === null) {
        group.range = {
          min: element[axis],
          max: element[axis] + element[dimension]
        };

        return;
      }

      // update group's range after centering the range elements
      updateRange(group, element);
    });

    if (idx && idx !== groups.length - 1) {
      groupsSize += rangeDiff(group.range);
    }
  });

  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);

  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));

  if (margin < groups.length - 1) {
    return;
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(groups, function(group, groupIdx) {
    var delta = {},
        prevGroup;

    if (group === firstGroup || group === lastGroup) {
      return;
    }

    prevGroup = groups[groupIdx - 1];

    group.range.max = 0;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(group.elements, function(element, idx) {
      delta[OFF_AXIS[axis]] = 0;
      delta[axis] = (prevGroup.range.max - element[axis]) + margin;

      if (group.range.min !== element[axis]) {
        delta[axis] += element[axis] - group.range.min;
      }

      if (delta[axis]) {
        modeling.moveElements([ element ], delta, element.parent);
      }

      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);
    });
  });
};

DistributeElements.prototype.postExecute = function(context) {

};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LayoutConnectionHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A handler that implements reversible moving of shapes.
 */
function LayoutConnectionHandler(layouter, canvas) {
  this._layouter = layouter;
  this._canvas = canvas;
}

LayoutConnectionHandler.$inject = [ 'layouter', 'canvas' ];

LayoutConnectionHandler.prototype.execute = function(context) {

  var connection = context.connection;

  var oldWaypoints = connection.waypoints;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(context, {
    oldWaypoints: oldWaypoints
  });

  connection.waypoints = this._layouter.layoutConnection(connection, context.hints);

  return connection;
};

LayoutConnectionHandler.prototype.revert = function(context) {

  var connection = context.connection;

  connection.waypoints = context.oldWaypoints;

  return connection;
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js":
/*!************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveConnectionHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");






/**
 * A handler that implements reversible moving of connections.
 *
 * The handler differs from the layout connection handler in a sense
 * that it preserves the connection layout.
 */
function MoveConnectionHandler() { }


MoveConnectionHandler.prototype.execute = function(context) {

  var connection = context.connection,
      delta = context.delta;

  var newParent = context.newParent || connection.parent,
      newParentIndex = context.newParentIndex,
      oldParent = connection.parent;

  // save old parent in context
  context.oldParent = oldParent;
  context.oldParentIndex = (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.remove)(oldParent.children, connection);

  // add to new parent at position
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(newParent.children, connection, newParentIndex);

  // update parent
  connection.parent = newParent;

  // update waypoint positions
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(connection.waypoints, function(p) {
    p.x += delta.x;
    p.y += delta.y;

    if (p.original) {
      p.original.x += delta.x;
      p.original.y += delta.y;
    }
  });

  return connection;
};

MoveConnectionHandler.prototype.revert = function(context) {

  var connection = context.connection,
      newParent = connection.parent,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex,
      delta = context.delta;

  // remove from newParent
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.remove)(newParent.children, connection);

  // restore previous location in old parent
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(oldParent.children, connection, oldParentIndex);

  // restore parent
  connection.parent = oldParent;

  // revert to old waypoint positions
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(connection.waypoints, function(p) {
    p.x -= delta.x;
    p.y -= delta.y;

    if (p.original) {
      p.original.x -= delta.x;
      p.original.y -= delta.y;
    }
  });

  return connection;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveElementsHandler.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/MoveElementsHandler.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveElementsHandler)
/* harmony export */ });
/* harmony import */ var _helper_MoveHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper/MoveHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js");



/**
 * A handler that implements reversible moving of shapes.
 */
function MoveElementsHandler(modeling) {
  this._helper = new _helper_MoveHelper__WEBPACK_IMPORTED_MODULE_0__.default(modeling);
}

MoveElementsHandler.$inject = [ 'modeling' ];

MoveElementsHandler.prototype.preExecute = function(context) {
  context.closure = this._helper.getClosure(context.shapes);
};

MoveElementsHandler.prototype.postExecute = function(context) {

  var hints = context.hints,
      primaryShape;

  if (hints && hints.primaryShape) {
    primaryShape = hints.primaryShape;
    hints.oldParent = primaryShape.parent;
  }

  this._helper.moveClosure(
    context.closure,
    context.delta,
    context.newParent,
    context.newHost,
    primaryShape
  );
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveShapeHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _helper_MoveHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper/MoveHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js");
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");
/* harmony import */ var _helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helper/AnchorsHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js");









/**
 * A handler that implements reversible moving of shapes.
 */
function MoveShapeHandler(modeling) {
  this._modeling = modeling;

  this._helper = new _helper_MoveHelper__WEBPACK_IMPORTED_MODULE_0__.default(modeling);
}

MoveShapeHandler.$inject = [ 'modeling' ];


MoveShapeHandler.prototype.execute = function(context) {

  var shape = context.shape,
      delta = context.delta,
      newParent = context.newParent || shape.parent,
      newParentIndex = context.newParentIndex,
      oldParent = shape.parent;

  context.oldBounds = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.pick)(shape, [ 'x', 'y', 'width', 'height']);

  // save old parent in context
  context.oldParent = oldParent;
  context.oldParentIndex = (0,_util_Collections__WEBPACK_IMPORTED_MODULE_2__.remove)(oldParent.children, shape);

  // add to new parent at position
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_2__.add)(newParent.children, shape, newParentIndex);

  // update shape parent + position
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(shape, {
    parent: newParent,
    x: shape.x + delta.x,
    y: shape.y + delta.y
  });

  return shape;
};

MoveShapeHandler.prototype.postExecute = function(context) {

  var shape = context.shape,
      delta = context.delta,
      hints = context.hints;

  var modeling = this._modeling;

  if (hints.layout !== false) {

    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(shape.incoming, function(c) {
      modeling.layoutConnection(c, {
        connectionEnd: (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_3__.getMovedTargetAnchor)(c, shape, delta)
      });
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(shape.outgoing, function(c) {
      modeling.layoutConnection(c, {
        connectionStart: (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_3__.getMovedSourceAnchor)(c, shape, delta)
      });
    });
  }

  if (hints.recurse !== false) {
    this.moveChildren(context);
  }
};

MoveShapeHandler.prototype.revert = function(context) {

  var shape = context.shape,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex,
      delta = context.delta;

  // restore previous location in old parent
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_2__.add)(oldParent.children, shape, oldParentIndex);

  // revert to old position and parent
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(shape, {
    parent: oldParent,
    x: shape.x - delta.x,
    y: shape.y - delta.y
  });

  return shape;
};

MoveShapeHandler.prototype.moveChildren = function(context) {

  var delta = context.delta,
      shape = context.shape;

  this._helper.moveRecursive(shape.children, delta, null);
};

MoveShapeHandler.prototype.getNewParent = function(context) {
  return context.newParent || context.shape.parent;
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReconnectConnectionHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * Reconnect connection handler
 */
function ReconnectConnectionHandler(modeling) {
  this._modeling = modeling;
}

ReconnectConnectionHandler.$inject = [ 'modeling' ];

ReconnectConnectionHandler.prototype.execute = function(context) {
  var newSource = context.newSource,
      newTarget = context.newTarget,
      connection = context.connection,
      dockingOrPoints = context.dockingOrPoints;

  if (!newSource && !newTarget) {
    throw new Error('newSource or newTarget required');
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(dockingOrPoints)) {
    context.oldWaypoints = connection.waypoints;
    connection.waypoints = dockingOrPoints;
  }

  if (newSource) {
    context.oldSource = connection.source;
    connection.source = newSource;
  }

  if (newTarget) {
    context.oldTarget = connection.target;
    connection.target = newTarget;
  }

  return connection;
};

ReconnectConnectionHandler.prototype.postExecute = function(context) {
  var connection = context.connection,
      newSource = context.newSource,
      newTarget = context.newTarget,
      dockingOrPoints = context.dockingOrPoints,
      hints = context.hints || {};

  var layoutConnectionHints = {};

  if (hints.connectionStart) {
    layoutConnectionHints.connectionStart = hints.connectionStart;
  }

  if (hints.connectionEnd) {
    layoutConnectionHints.connectionEnd = hints.connectionEnd;
  }

  if (hints.layoutConnection === false) {
    return;
  }

  if (newSource && (!newTarget || hints.docking === 'source')) {
    layoutConnectionHints.connectionStart = layoutConnectionHints.connectionStart
      || getDocking((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(dockingOrPoints) ? dockingOrPoints[ 0 ] : dockingOrPoints);
  }

  if (newTarget && (!newSource || hints.docking === 'target')) {
    layoutConnectionHints.connectionEnd = layoutConnectionHints.connectionEnd
      || getDocking((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(dockingOrPoints) ? dockingOrPoints[ dockingOrPoints.length - 1 ] : dockingOrPoints);
  }

  if (hints.newWaypoints) {
    layoutConnectionHints.waypoints = hints.newWaypoints;
  }

  this._modeling.layoutConnection(connection, layoutConnectionHints);
};

ReconnectConnectionHandler.prototype.revert = function(context) {
  var oldSource = context.oldSource,
      oldTarget = context.oldTarget,
      oldWaypoints = context.oldWaypoints,
      connection = context.connection;

  if (oldSource) {
    connection.source = oldSource;
  }

  if (oldTarget) {
    connection.target = oldTarget;
  }

  if (oldWaypoints) {
    connection.waypoints = oldWaypoints;
  }

  return connection;
};



// helpers //////////

function getDocking(point) {
  return point.original || point;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReplaceShapeHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper/AnchorsHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js");




/**
 * Replace shape by adding new shape and removing old shape. Incoming and outgoing connections will
 * be kept if possible.
 *
 * @class
 * @constructor
 *
 * @param {Modeling} modeling
 * @param {Rules} rules
 */
function ReplaceShapeHandler(modeling, rules) {
  this._modeling = modeling;
  this._rules = rules;
}

ReplaceShapeHandler.$inject = [ 'modeling', 'rules' ];


/**
 * Add new shape.
 *
 * @param {Object} context
 * @param {djs.model.Shape} context.oldShape
 * @param {Object} context.newData
 * @param {string} context.newData.type
 * @param {number} context.newData.x
 * @param {number} context.newData.y
 * @param {Object} [hints]
 */
ReplaceShapeHandler.prototype.preExecute = function(context) {
  var self = this,
      modeling = this._modeling,
      rules = this._rules;

  var oldShape = context.oldShape,
      newData = context.newData,
      hints = context.hints || {},
      newShape;

  function canReconnect(source, target, connection) {
    return rules.allowed('connection.reconnect', {
      connection: connection,
      source: source,
      target: target
    });
  }

  // (1) add new shape at given position
  var position = {
    x: newData.x,
    y: newData.y
  };

  var oldBounds = {
    x: oldShape.x,
    y: oldShape.y,
    width: oldShape.width,
    height: oldShape.height
  };

  newShape = context.newShape =
    context.newShape ||
    self.createShape(newData, position, oldShape.parent, hints);

  // (2) update host
  if (oldShape.host) {
    modeling.updateAttachment(newShape, oldShape.host);
  }

  // (3) adopt all children from old shape
  var children;

  if (hints.moveChildren !== false) {
    children = oldShape.children.slice();

    modeling.moveElements(children, { x: 0, y: 0 }, newShape, hints);
  }

  // (4) reconnect connections to new shape if possible
  var incoming = oldShape.incoming.slice(),
      outgoing = oldShape.outgoing.slice();

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(incoming, function(connection) {
    var source = connection.source,
        allowed = canReconnect(source, newShape, connection);

    if (allowed) {
      self.reconnectEnd(
        connection, newShape,
        (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getResizedTargetAnchor)(connection, newShape, oldBounds),
        hints
      );
    }
  });

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(outgoing, function(connection) {
    var target = connection.target,
        allowed = canReconnect(newShape, target, connection);

    if (allowed) {
      self.reconnectStart(
        connection, newShape,
        (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getResizedSourceAnchor)(connection, newShape, oldBounds),
        hints
      );
    }
  });
};


/**
 * Remove old shape.
 */
ReplaceShapeHandler.prototype.postExecute = function(context) {
  var oldShape = context.oldShape;

  this._modeling.removeShape(oldShape);
};


ReplaceShapeHandler.prototype.execute = function(context) {};


ReplaceShapeHandler.prototype.revert = function(context) {};


ReplaceShapeHandler.prototype.createShape = function(shape, position, target, hints) {
  return this._modeling.createShape(shape, position, target, hints);
};


ReplaceShapeHandler.prototype.reconnectStart = function(connection, newSource, dockingPoint, hints) {
  this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);
};


ReplaceShapeHandler.prototype.reconnectEnd = function(connection, newTarget, dockingPoint, hints) {
  this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResizeShapeHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper/AnchorsHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js");





/**
 * A handler that implements reversible resizing of shapes.
 *
 * @param {Modeling} modeling
 */
function ResizeShapeHandler(modeling) {
  this._modeling = modeling;
}

ResizeShapeHandler.$inject = [ 'modeling' ];

/**
 * {
 *   shape: {....}
 *   newBounds: {
 *     width:  20,
 *     height: 40,
 *     x:       5,
 *     y:      10
 *   }
 *
 * }
 */
ResizeShapeHandler.prototype.execute = function(context) {
  var shape = context.shape,
      newBounds = context.newBounds,
      minBounds = context.minBounds;

  if (newBounds.x === undefined || newBounds.y === undefined ||
      newBounds.width === undefined || newBounds.height === undefined) {
    throw new Error('newBounds must have {x, y, width, height} properties');
  }

  if (minBounds && (newBounds.width < minBounds.width
    || newBounds.height < minBounds.height)) {
    throw new Error('width and height cannot be less than minimum height and width');
  } else if (!minBounds
    && newBounds.width < 10 || newBounds.height < 10) {
    throw new Error('width and height cannot be less than 10px');
  }

  // save old bbox in context
  context.oldBounds = {
    width:  shape.width,
    height: shape.height,
    x:      shape.x,
    y:      shape.y
  };

  // update shape
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(shape, {
    width:  newBounds.width,
    height: newBounds.height,
    x:      newBounds.x,
    y:      newBounds.y
  });

  return shape;
};

ResizeShapeHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling;

  var shape = context.shape,
      oldBounds = context.oldBounds,
      hints = context.hints || {};

  if (hints.layout === false) {
    return;
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.incoming, function(c) {
    modeling.layoutConnection(c, {
      connectionEnd: (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getResizedTargetAnchor)(c, shape, oldBounds)
    });
  });

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.outgoing, function(c) {
    modeling.layoutConnection(c, {
      connectionStart: (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getResizedSourceAnchor)(c, shape, oldBounds)
    });
  });

};

ResizeShapeHandler.prototype.revert = function(context) {

  var shape = context.shape,
      oldBounds = context.oldBounds;

  // restore previous bbox
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(shape, {
    width:  oldBounds.width,
    height: oldBounds.height,
    x:      oldBounds.x,
    y:      oldBounds.y
  });

  return shape;
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpaceToolHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _space_tool_SpaceUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../space-tool/SpaceUtil */ "./node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js");
/* harmony import */ var _helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper/AnchorsHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js");







/**
 * Add or remove space by moving and resizing shapes and updating connection waypoints.
 */
function SpaceToolHandler(modeling) {
  this._modeling = modeling;
}

SpaceToolHandler.$inject = [ 'modeling' ];

SpaceToolHandler.prototype.preExecute = function(context) {
  var delta = context.delta,
      direction = context.direction,
      movingShapes = context.movingShapes,
      resizingShapes = context.resizingShapes,
      start = context.start,
      oldBounds = {};

  // (1) move shapes
  this.moveShapes(movingShapes, delta);

  // (2a) save old bounds of resized shapes
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(resizingShapes, function(shape) {
    oldBounds[shape.id] = getBounds(shape);
  });

  // (2b) resize shapes
  this.resizeShapes(resizingShapes, delta, direction);

  // (3) update connection waypoints
  this.updateConnectionWaypoints(
    (0,_space_tool_SpaceUtil__WEBPACK_IMPORTED_MODULE_1__.getWaypointsUpdatingConnections)(movingShapes, resizingShapes),
    delta,
    direction,
    start,
    movingShapes,
    resizingShapes,
    oldBounds
  );
};

SpaceToolHandler.prototype.execute = function() {};
SpaceToolHandler.prototype.revert = function() {};

SpaceToolHandler.prototype.moveShapes = function(shapes, delta) {
  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shapes, function(element) {
    self._modeling.moveShape(element, delta, null, {
      autoResize: false,
      layout: false,
      recurse: false
    });
  });
};

SpaceToolHandler.prototype.resizeShapes = function(shapes, delta, direction) {
  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shapes, function(shape) {
    var newBounds = (0,_space_tool_SpaceUtil__WEBPACK_IMPORTED_MODULE_1__.resizeBounds)(shape, direction, delta);

    self._modeling.resizeShape(shape, newBounds, null, {
      attachSupport: false,
      autoResize: false,
      layout: false
    });
  });
};

/**
 * Update connections waypoints according to the rules:
 *   1. Both source and target are moved/resized => move waypoints by the delta
 *   2. Only one of source and target is moved/resized => re-layout connection with moved start/end
 */
SpaceToolHandler.prototype.updateConnectionWaypoints = function(
    connections,
    delta,
    direction,
    start,
    movingShapes,
    resizingShapes,
    oldBounds
) {
  var self = this,
      affectedShapes = movingShapes.concat(resizingShapes);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(connections, function(connection) {
    var source = connection.source,
        target = connection.target,
        waypoints = copyWaypoints(connection),
        axis = getAxisFromDirection(direction),
        layoutHints = {
          labelBehavior: false
        };

    if (includes(affectedShapes, source) && includes(affectedShapes, target)) {

      // move waypoints
      waypoints = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(waypoints, function(waypoint) {
        if (shouldMoveWaypoint(waypoint, start, direction)) {

          // move waypoint
          waypoint[ axis ] = waypoint[ axis ] + delta[ axis ];
        }

        if (waypoint.original && shouldMoveWaypoint(waypoint.original, start, direction)) {

          // move waypoint original
          waypoint.original[ axis ] = waypoint.original[ axis ] + delta[ axis ];
        }

        return waypoint;
      });

      self._modeling.updateWaypoints(connection, waypoints, {
        labelBehavior: false
      });
    } else if (includes(affectedShapes, source) || includes(affectedShapes, target)) {

      // re-layout connection with moved start/end
      if (includes(movingShapes, source)) {
        layoutHints.connectionStart = (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_2__.getMovedSourceAnchor)(connection, source, delta);
      } else if (includes(movingShapes, target)) {
        layoutHints.connectionEnd = (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_2__.getMovedTargetAnchor)(connection, target, delta);
      } else if (includes(resizingShapes, source)) {
        layoutHints.connectionStart = (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_2__.getResizedSourceAnchor)(
          connection, source, oldBounds[source.id]
        );
      } else if (includes(resizingShapes, target)) {
        layoutHints.connectionEnd = (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_2__.getResizedTargetAnchor)(
          connection, target, oldBounds[target.id]
        );
      }

      self._modeling.layoutConnection(connection, layoutHints);
    }
  });
};


// helpers //////////

function copyWaypoint(waypoint) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, waypoint);
}

function copyWaypoints(connection) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(connection.waypoints, function(waypoint) {

    waypoint = copyWaypoint(waypoint);

    if (waypoint.original) {
      waypoint.original = copyWaypoint(waypoint.original);
    }

    return waypoint;
  });
}

function getAxisFromDirection(direction) {
  switch (direction) {
  case 'n':
    return 'y';
  case 'w':
    return 'x';
  case 's':
    return 'y';
  case 'e':
    return 'x';
  }
}

function shouldMoveWaypoint(waypoint, start, direction) {
  var relevantAxis = getAxisFromDirection(direction);

  if (/e|s/.test(direction)) {
    return waypoint[ relevantAxis ] > start;
  } else if (/n|w/.test(direction)) {
    return waypoint[ relevantAxis ] < start;
  }
}

function includes(array, item) {
  return array.indexOf(item) !== -1;
}

function getBounds(shape) {
  return {
    x: shape.x,
    y: shape.y,
    height: shape.height,
    width: shape.width
  };
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ToggleShapeCollapseHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * A handler that toggles the collapsed state of an element
 * and the visibility of all its children.
 *
 * @param {Modeling} modeling
 */
function ToggleShapeCollapseHandler(modeling) {
  this._modeling = modeling;
}

ToggleShapeCollapseHandler.$inject = [ 'modeling' ];


ToggleShapeCollapseHandler.prototype.execute = function(context) {

  var shape = context.shape,
      children = shape.children;

  // recursively remember previous visibility of children
  context.oldChildrenVisibility = getElementsVisibilityRecursive(children);

  // toggle state
  shape.collapsed = !shape.collapsed;

  // recursively hide/show children
  var result = setHiddenRecursive(children, shape.collapsed);

  return [shape].concat(result);
};


ToggleShapeCollapseHandler.prototype.revert = function(context) {

  var shape = context.shape,
      oldChildrenVisibility = context.oldChildrenVisibility;

  var children = shape.children;

  // recursively set old visability of children
  var result = restoreVisibilityRecursive(children, oldChildrenVisibility);

  // retoggle state
  shape.collapsed = !shape.collapsed;

  return [shape].concat(result);
};


// helpers //////////////////////

/**
 * Return a map { elementId -> hiddenState}.
 *
 * @param {Array<djs.model.Shape>} elements
 *
 * @return {Object}
 */
function getElementsVisibilityRecursive(elements) {

  var result = {};

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    result[element.id] = element.hidden;

    if (element.children) {
      result = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, result, getElementsVisibilityRecursive(element.children));
    }
  });

  return result;
}


function setHiddenRecursive(elements, newHidden) {
  var result = [];
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    element.hidden = newHidden;

    result = result.concat(element);

    if (element.children) {
      result = result.concat(setHiddenRecursive(element.children, element.collapsed || newHidden));
    }
  });

  return result;
}

function restoreVisibilityRecursive(elements, lastState) {
  var result = [];
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    element.hidden = lastState[element.id];

    result = result.concat(element);

    if (element.children) {
      result = result.concat(restoreVisibilityRecursive(element.children, lastState));
    }
  });

  return result;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/UpdateAttachmentHandler.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/UpdateAttachmentHandler.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpdateAttachmentHandler)
/* harmony export */ });
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");


/**
 * A handler that implements reversible attaching/detaching of shapes.
 */
function UpdateAttachmentHandler(modeling) {
  this._modeling = modeling;
}

UpdateAttachmentHandler.$inject = [ 'modeling' ];


UpdateAttachmentHandler.prototype.execute = function(context) {
  var shape = context.shape,
      newHost = context.newHost,
      oldHost = shape.host;

  // (0) detach from old host
  context.oldHost = oldHost;
  context.attacherIdx = removeAttacher(oldHost, shape);

  // (1) attach to new host
  addAttacher(newHost, shape);

  // (2) update host
  shape.host = newHost;

  return shape;
};

UpdateAttachmentHandler.prototype.revert = function(context) {
  var shape = context.shape,
      newHost = context.newHost,
      oldHost = context.oldHost,
      attacherIdx = context.attacherIdx;

  // (2) update host
  shape.host = oldHost;

  // (1) attach to new host
  removeAttacher(newHost, shape);

  // (0) detach from old host
  addAttacher(oldHost, shape, attacherIdx);

  return shape;
};


function removeAttacher(host, attacher) {

  // remove attacher from host
  return (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.remove)(host && host.attachers, attacher);
}

function addAttacher(host, attacher, idx) {

  if (!host) {
    return;
  }

  var attachers = host.attachers;

  if (!attachers) {
    host.attachers = attachers = [];
  }

  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(attachers, attacher, idx);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpdateWaypointsHandler)
/* harmony export */ });
function UpdateWaypointsHandler() { }

UpdateWaypointsHandler.prototype.execute = function(context) {

  var connection = context.connection,
      newWaypoints = context.newWaypoints;

  context.oldWaypoints = connection.waypoints;

  connection.waypoints = newWaypoints;

  return connection;
};

UpdateWaypointsHandler.prototype.revert = function(context) {

  var connection = context.connection,
      oldWaypoints = context.oldWaypoints;

  connection.waypoints = oldWaypoints;

  return connection;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getResizedSourceAnchor": () => (/* binding */ getResizedSourceAnchor),
/* harmony export */   "getResizedTargetAnchor": () => (/* binding */ getResizedTargetAnchor),
/* harmony export */   "getMovedSourceAnchor": () => (/* binding */ getMovedSourceAnchor),
/* harmony export */   "getMovedTargetAnchor": () => (/* binding */ getMovedTargetAnchor)
/* harmony export */ });
/* harmony import */ var _util_AttachUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../util/AttachUtil */ "./node_modules/diagram-js/lib/util/AttachUtil.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");







function getResizedSourceAnchor(connection, shape, oldBounds) {

  var waypoints = safeGetWaypoints(connection),
      waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),
      oldAnchor = waypoints[0];

  // new anchor is the last waypoint enclosed be resized source
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[ waypointsInsideNewBounds.length - 1 ];
  }

  return (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_0__.getNewAttachPoint)(oldAnchor.original || oldAnchor, oldBounds, shape);
}


function getResizedTargetAnchor(connection, shape, oldBounds) {

  var waypoints = safeGetWaypoints(connection),
      waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),
      oldAnchor = waypoints[waypoints.length - 1];

  // new anchor is the first waypoint enclosed be resized target
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[ 0 ];
  }

  return (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_0__.getNewAttachPoint)(oldAnchor.original || oldAnchor, oldBounds, shape);
}


function getMovedSourceAnchor(connection, source, moveDelta) {

  var waypoints = safeGetWaypoints(connection),
      oldBounds = subtract(source, moveDelta),
      oldAnchor = waypoints[ 0 ];

  return (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_0__.getNewAttachPoint)(oldAnchor.original || oldAnchor, oldBounds, source);
}


function getMovedTargetAnchor(connection, target, moveDelta) {

  var waypoints = safeGetWaypoints(connection),
      oldBounds = subtract(target, moveDelta),
      oldAnchor = waypoints[ waypoints.length - 1 ];

  return (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_0__.getNewAttachPoint)(oldAnchor.original || oldAnchor, oldBounds, target);
}


// helpers //////////////////////

function subtract(bounds, delta) {
  return {
    x: bounds.x - delta.x,
    y: bounds.y - delta.y,
    width: bounds.width,
    height: bounds.height
  };
}


/**
 * Return waypoints of given connection; throw if non exists (should not happen!!).
 *
 * @param {Connection} connection
 *
 * @return {Array<Point>}
 */
function safeGetWaypoints(connection) {

  var waypoints = connection.waypoints;

  if (!waypoints.length) {
    throw new Error('connection#' + connection.id + ': no waypoints');
  }

  return waypoints;
}

function getWaypointsInsideBounds(waypoints, bounds) {
  var originalWaypoints = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.map)(waypoints, getOriginal);

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.filter)(originalWaypoints, function(waypoint) {
    return isInsideBounds(waypoint, bounds);
  });
}

/**
 * Checks if point is inside bounds, incl. edges.
 *
 * @param {Point} point
 * @param {Bounds} bounds
 */
function isInsideBounds(point, bounds) {
  return (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_2__.getOrientation)(bounds, point, 1) === 'intersect';
}

function getOriginal(point) {
  return point.original || point;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveClosure.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveClosure.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveClosure)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");





function MoveClosure() {

  this.allShapes = {};
  this.allConnections = {};

  this.enclosedElements = {};
  this.enclosedConnections = {};

  this.topLevel = {};
}


MoveClosure.prototype.add = function(element, isTopLevel) {
  return this.addAll([ element ], isTopLevel);
};


MoveClosure.prototype.addAll = function(elements, isTopLevel) {

  var newClosure = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_0__.getClosure)(elements, !!isTopLevel, this);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(this, newClosure);

  return this;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js":
/*!********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveHelper)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnchorsHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js");
/* harmony import */ var _MoveClosure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MoveClosure */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveClosure.js");







/**
 * A helper that is able to carry out serialized move
 * operations on multiple elements.
 *
 * @param {Modeling} modeling
 */
function MoveHelper(modeling) {
  this._modeling = modeling;
}

/**
 * Move the specified elements and all children by the given delta.
 *
 * This moves all enclosed connections, too and layouts all affected
 * external connections.
 *
 * @param  {Array<djs.model.Base>} elements
 * @param  {Point} delta
 * @param  {djs.model.Base} newParent applied to the first level of shapes
 *
 * @return {Array<djs.model.Base>} list of touched elements
 */
MoveHelper.prototype.moveRecursive = function(elements, delta, newParent) {
  if (!elements) {
    return [];
  } else {
    return this.moveClosure(this.getClosure(elements), delta, newParent);
  }
};

/**
 * Move the given closure of elmements.
 *
 * @param {Object} closure
 * @param {Point} delta
 * @param {djs.model.Base} [newParent]
 * @param {djs.model.Base} [newHost]
 */
MoveHelper.prototype.moveClosure = function(closure, delta, newParent, newHost, primaryShape) {
  var modeling = this._modeling;

  var allShapes = closure.allShapes,
      allConnections = closure.allConnections,
      enclosedConnections = closure.enclosedConnections,
      topLevel = closure.topLevel,
      keepParent = false;

  if (primaryShape && primaryShape.parent === newParent) {
    keepParent = true;
  }

  // move all shapes
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(allShapes, function(shape) {

    // move the element according to the given delta
    modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {
      recurse: false,
      layout: false
    });
  });

  // move all child connections / layout external connections
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(allConnections, function(c) {

    var sourceMoved = !!allShapes[c.source.id],
        targetMoved = !!allShapes[c.target.id];

    if (enclosedConnections[c.id] && sourceMoved && targetMoved) {
      modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);
    } else {
      modeling.layoutConnection(c, {
        connectionStart: sourceMoved && (0,_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getMovedSourceAnchor)(c, c.source, delta),
        connectionEnd: targetMoved && (0,_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getMovedTargetAnchor)(c, c.target, delta)
      });
    }
  });
};

/**
 * Returns the closure for the selected elements
 *
 * @param  {Array<djs.model.Base>} elements
 * @return {MoveClosure} closure
 */
MoveHelper.prototype.getClosure = function(elements) {
  return new _MoveClosure__WEBPACK_IMPORTED_MODULE_2__.default().addAll(elements, true);
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/mouse/Mouse.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/mouse/Mouse.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Mouse),
/* harmony export */   "createMoveEvent": () => (/* binding */ createMoveEvent)
/* harmony export */ });
function Mouse(eventBus) {
  var self = this;

  this._lastMoveEvent = null;

  function setLastMoveEvent(mousemoveEvent) {
    self._lastMoveEvent = mousemoveEvent;
  }

  eventBus.on('canvas.init', function(context) {
    var svg = self._svg = context.svg;

    svg.addEventListener('mousemove', setLastMoveEvent);
  });

  eventBus.on('canvas.destroy', function() {
    self._lastMouseEvent = null;

    self._svg.removeEventListener('mousemove', setLastMoveEvent);
  });
}

Mouse.$inject = [ 'eventBus' ];

Mouse.prototype.getLastMoveEvent = function() {
  return this._lastMoveEvent || createMoveEvent(0, 0);
};

// helpers //////////

function createMoveEvent(x, y) {
  var event = document.createEvent('MouseEvent');

  var screenX = x,
      screenY = y,
      clientX = x,
      clientY = y;

  if (event.initMouseEvent) {
    event.initMouseEvent(
      'mousemove',
      true,
      true,
      window,
      0,
      screenX,
      screenY,
      clientX,
      clientY,
      false,
      false,
      false,
      false,
      0,
      null
    );
  }

  return event;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/mouse/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/mouse/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mouse */ "./node_modules/diagram-js/lib/features/mouse/Mouse.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'mouse' ],
  mouse: [ 'type', _Mouse__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/move/Move.js":
/*!***********************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/move/Move.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveEvents)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");


var LOW_PRIORITY = 500,
    MEDIUM_PRIORITY = 1250,
    HIGH_PRIORITY = 1500;





var round = Math.round;

function mid(element) {
  return {
    x: element.x + round(element.width / 2),
    y: element.y + round(element.height / 2)
  };
}

/**
 * A plugin that makes shapes draggable / droppable.
 *
 * @param {EventBus} eventBus
 * @param {Dragging} dragging
 * @param {Modeling} modeling
 * @param {Selection} selection
 * @param {Rules} rules
 */
function MoveEvents(
    eventBus, dragging, modeling,
    selection, rules) {

  // rules

  function canMove(shapes, delta, position, target) {

    return rules.allowed('elements.move', {
      shapes: shapes,
      delta: delta,
      position: position,
      target: target
    });
  }


  // move events

  // assign a high priority to this handler to setup the environment
  // others may hook up later, e.g. at default priority and modify
  // the move environment.
  //
  // This sets up the context with
  //
  // * shape: the primary shape being moved
  // * shapes: a list of shapes to be moved
  // * validatedShapes: a list of shapes that are being checked
  //                    against the rules before and during move
  //
  eventBus.on('shape.move.start', HIGH_PRIORITY, function(event) {

    var context = event.context,
        shape = event.shape,
        shapes = selection.get().slice();

    // move only single shape if the dragged element
    // is not part of the current selection
    if (shapes.indexOf(shape) === -1) {
      shapes = [ shape ];
    }

    // ensure we remove nested elements in the collection
    // and add attachers for a proper dragger
    shapes = removeNested(shapes);

    // attach shapes to drag context
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(context, {
      shapes: shapes,
      validatedShapes: shapes,
      shape: shape
    });
  });


  // assign a high priority to this handler to setup the environment
  // others may hook up later, e.g. at default priority and modify
  // the move environment
  //
  eventBus.on('shape.move.start', MEDIUM_PRIORITY, function(event) {

    var context = event.context,
        validatedShapes = context.validatedShapes,
        canExecute;

    canExecute = context.canExecute = canMove(validatedShapes);

    // check if we can move the elements
    if (!canExecute) {
      return false;
    }
  });

  // assign a low priority to this handler
  // to let others modify the move event before we update
  // the context
  //
  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {

    var context = event.context,
        validatedShapes = context.validatedShapes,
        hover = event.hover,
        delta = { x: event.dx, y: event.dy },
        position = { x: event.x, y: event.y },
        canExecute;

    // check if we can move the elements
    canExecute = canMove(validatedShapes, delta, position, hover);

    context.delta = delta;
    context.canExecute = canExecute;

    // simply ignore move over
    if (canExecute === null) {
      context.target = null;

      return;
    }

    context.target = hover;
  });

  eventBus.on('shape.move.end', function(event) {

    var context = event.context;

    var delta = context.delta,
        canExecute = context.canExecute,
        isAttach = canExecute === 'attach',
        shapes = context.shapes;

    if (canExecute === false) {
      return false;
    }

    // ensure we have actual pixel values deltas
    // (important when zoom level was > 1 during move)
    delta.x = round(delta.x);
    delta.y = round(delta.y);

    if (delta.x === 0 && delta.y === 0) {

      // didn't move
      return;
    }

    modeling.moveElements(shapes, delta, context.target, {
      primaryShape: context.shape,
      attach: isAttach
    });
  });


  // move activation

  eventBus.on('element.mousedown', function(event) {

    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.isPrimaryButton)(event)) {
      return;
    }

    var originalEvent = (0,_util_Event__WEBPACK_IMPORTED_MODULE_2__.getOriginal)(event);

    if (!originalEvent) {
      throw new Error('must supply DOM mousedown event');
    }

    return start(originalEvent, event.element);
  });

  /**
   * Start move.
   *
   * @param {MouseEvent} event
   * @param {djs.model.Shape} shape
   * @param {boolean} [activate]
   * @param {Object} [context]
   */
  function start(event, element, activate, context) {
    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(activate)) {
      context = activate;
      activate = false;
    }

    // do not move connections or the root element
    if (element.waypoints || !element.parent) {
      return;
    }

    var referencePoint = mid(element);

    dragging.init(event, referencePoint, 'shape.move', {
      cursor: 'grabbing',
      autoActivate: activate,
      data: {
        shape: element,
        context: context || {}
      }
    });

    // we've handled the event
    return true;
  }

  // API

  this.start = start;
}

MoveEvents.$inject = [
  'eventBus',
  'dragging',
  'modeling',
  'selection',
  'rules'
];


/**
 * Return a filtered list of elements that do not contain
 * those nested into others.
 *
 * @param  {Array<djs.model.Base>} elements
 *
 * @return {Array<djs.model.Base>} filtered
 */
function removeNested(elements) {

  var ids = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.groupBy)(elements, 'id');

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.filter)(elements, function(element) {
    while ((element = element.parent)) {

      // parent in selection
      if (ids[element.id]) {
        return false;
      }
    }

    return true;
  });
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/move/MovePreview.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/move/MovePreview.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MovePreview)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");








var LOW_PRIORITY = 499;

var MARKER_DRAGGING = 'djs-dragging',
    MARKER_OK = 'drop-ok',
    MARKER_NOT_OK = 'drop-not-ok',
    MARKER_NEW_PARENT = 'new-parent',
    MARKER_ATTACH = 'attach-ok';


/**
 * Provides previews for moving shapes when moving.
 *
 * @param {EventBus} eventBus
 * @param {ElementRegistry} elementRegistry
 * @param {Canvas} canvas
 * @param {Styles} styles
 */
function MovePreview(
    eventBus, canvas, styles, previewSupport) {

  function getVisualDragShapes(shapes) {
    var elements = getAllDraggedElements(shapes);

    var filteredElements = removeEdges(elements);

    return filteredElements;
  }

  function getAllDraggedElements(shapes) {
    var allShapes = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_0__.selfAndAllChildren)(shapes, true);

    var allConnections = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.map)(allShapes, function(shape) {
      return (shape.incoming || []).concat(shape.outgoing || []);
    });

    return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.flatten)(allShapes.concat(allConnections));
  }

  /**
   * Sets drop marker on an element.
   */
  function setMarker(element, marker) {

    [ MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT ].forEach(function(m) {

      if (m === marker) {
        canvas.addMarker(element, m);
      } else {
        canvas.removeMarker(element, m);
      }
    });
  }

  /**
   * Make an element draggable.
   *
   * @param {Object} context
   * @param {djs.model.Base} element
   * @param {boolean} addMarker
   */
  function makeDraggable(context, element, addMarker) {

    previewSupport.addDragger(element, context.dragGroup);

    if (addMarker) {
      canvas.addMarker(element, MARKER_DRAGGING);
    }

    if (context.allDraggedElements) {
      context.allDraggedElements.push(element);
    } else {
      context.allDraggedElements = [ element ];
    }
  }

  // assign a low priority to this handler
  // to let others modify the move context before
  // we draw things
  eventBus.on('shape.move.start', LOW_PRIORITY, function(event) {
    var context = event.context,
        dragShapes = context.shapes,
        allDraggedElements = context.allDraggedElements;

    var visuallyDraggedShapes = getVisualDragShapes(dragShapes);

    if (!context.dragGroup) {
      var dragGroup = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('g');

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(dragGroup, styles.cls('djs-drag-group', [ 'no-events' ]));

      var defaultLayer = canvas.getDefaultLayer();

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(defaultLayer, dragGroup);

      context.dragGroup = dragGroup;
    }

    // add previews
    visuallyDraggedShapes.forEach(function(shape) {
      previewSupport.addDragger(shape, context.dragGroup);
    });

    // cache all dragged elements / gfx
    // so that we can quickly undo their state changes later
    if (!allDraggedElements) {
      allDraggedElements = getAllDraggedElements(dragShapes);
    } else {
      allDraggedElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.flatten)([
        allDraggedElements,
        getAllDraggedElements(dragShapes)
      ]);
    }

    // add dragging marker
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(allDraggedElements, function(e) {
      canvas.addMarker(e, MARKER_DRAGGING);
    });

    context.allDraggedElements = allDraggedElements;

    // determine, if any of the dragged elements have different parents
    context.differentParents = haveDifferentParents(dragShapes);
  });

  // update previews
  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {

    var context = event.context,
        dragGroup = context.dragGroup,
        target = context.target,
        parent = context.shape.parent,
        canExecute = context.canExecute;

    if (target) {
      if (canExecute === 'attach') {
        setMarker(target, MARKER_ATTACH);
      } else if (context.canExecute && target && target.id !== parent.id) {
        setMarker(target, MARKER_NEW_PARENT);
      } else {
        setMarker(target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);
      }
    }

    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__.translate)(dragGroup, event.dx, event.dy);
  });

  eventBus.on([ 'shape.move.out', 'shape.move.cleanup' ], function(event) {
    var context = event.context,
        target = context.target;

    if (target) {
      setMarker(target, null);
    }
  });

  // remove previews
  eventBus.on('shape.move.cleanup', function(event) {

    var context = event.context,
        allDraggedElements = context.allDraggedElements,
        dragGroup = context.dragGroup;


    // remove dragging marker
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(allDraggedElements, function(e) {
      canvas.removeMarker(e, MARKER_DRAGGING);
    });

    if (dragGroup) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.remove)(dragGroup);
    }
  });


  // API //////////////////////

  /**
   * Make an element draggable.
   *
   * @param {Object} context
   * @param {djs.model.Base} element
   * @param {boolean} addMarker
   */
  this.makeDraggable = makeDraggable;
}

MovePreview.$inject = [
  'eventBus',
  'canvas',
  'styles',
  'previewSupport'
];


// helpers //////////////////////

/**
 * returns elements minus all connections
 * where source or target is not elements
 */
function removeEdges(elements) {

  var filteredElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.filter)(elements, function(element) {

    if (!isConnection(element)) {
      return true;
    } else {

      return (
        (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(elements, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.matchPattern)({ id: element.source.id })) &&
        (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(elements, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.matchPattern)({ id: element.target.id }))
      );
    }
  });

  return filteredElements;
}

function haveDifferentParents(elements) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.size)((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.groupBy)(elements, function(e) { return e.parent && e.parent.id; })) !== 1;
}

/**
 * Checks if an element is a connection.
 */
function isConnection(element) {
  return element.waypoints;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/move/index.js":
/*!************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/move/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interaction_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interaction-events */ "./node_modules/diagram-js/lib/features/interaction-events/index.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _outline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../outline */ "./node_modules/diagram-js/lib/features/outline/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _preview_support__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../preview-support */ "./node_modules/diagram-js/lib/features/preview-support/index.js");
/* harmony import */ var _Move__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Move */ "./node_modules/diagram-js/lib/features/move/Move.js");
/* harmony import */ var _MovePreview__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MovePreview */ "./node_modules/diagram-js/lib/features/move/MovePreview.js");










/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _interaction_events__WEBPACK_IMPORTED_MODULE_0__.default,
    _selection__WEBPACK_IMPORTED_MODULE_1__.default,
    _outline__WEBPACK_IMPORTED_MODULE_2__.default,
    _rules__WEBPACK_IMPORTED_MODULE_3__.default,
    _dragging__WEBPACK_IMPORTED_MODULE_4__.default,
    _preview_support__WEBPACK_IMPORTED_MODULE_5__.default
  ],
  __init__: [
    'move',
    'movePreview'
  ],
  move: [ 'type', _Move__WEBPACK_IMPORTED_MODULE_6__.default ],
  movePreview: [ 'type', _MovePreview__WEBPACK_IMPORTED_MODULE_7__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/ordering/OrderingProvider.js":
/*!***************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/ordering/OrderingProvider.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OrderingProvider)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");





/**
 * An abstract provider that allows modelers to implement a custom
 * ordering of diagram elements on the canvas.
 *
 * It makes sure that the order is always preserved during element
 * creation and move operations.
 *
 * In order to use this behavior, inherit from it and override
 * the method {@link OrderingProvider#getOrdering}.
 *
 * @example
 *
 * ```javascript
 * function CustomOrderingProvider(eventBus) {
 *   OrderingProvider.call(this, eventBus);
 *
 *   this.getOrdering = function(element, newParent) {
 *     // always insert elements at the front
 *     // when moving
 *     return {
 *       index: 0,
 *       parent: newParent
 *     };
 *   };
 * }
 * ```
 *
 * @param {EventBus} eventBus
 */
function OrderingProvider(eventBus) {

  _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);


  var self = this;

  this.preExecute([ 'shape.create', 'connection.create' ], function(event) {

    var context = event.context,
        element = context.shape || context.connection,
        parent = context.parent;

    var ordering = self.getOrdering(element, parent);

    if (ordering) {

      if (ordering.parent !== undefined) {
        context.parent = ordering.parent;
      }

      context.parentIndex = ordering.index;
    }
  });

  this.preExecute([ 'shape.move', 'connection.move' ], function(event) {

    var context = event.context,
        element = context.shape || context.connection,
        parent = context.newParent || element.parent;

    var ordering = self.getOrdering(element, parent);

    if (ordering) {

      if (ordering.parent !== undefined) {
        context.newParent = ordering.parent;
      }

      context.newParentIndex = ordering.index;
    }
  });
}

/**
 * Return a custom ordering of the element, both in terms
 * of parent element and index in the new parent.
 *
 * Implementors of this method must return an object with
 * `parent` _and_ `index` in it.
 *
 * @param {djs.model.Base} element
 * @param {djs.model.Shape} newParent
 *
 * @return {Object} ordering descriptor
 */
OrderingProvider.prototype.getOrdering = function(element, newParent) {
  return null;
};

inherits__WEBPACK_IMPORTED_MODULE_0___default()(OrderingProvider, _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/outline/Outline.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/outline/Outline.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Outline)
/* harmony export */ });
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var LOW_PRIORITY = 500;








/**
 * @class
 *
 * A plugin that adds an outline to shapes and connections that may be activated and styled
 * via CSS classes.
 *
 * @param {EventBus} eventBus
 * @param {Styles} styles
 * @param {ElementRegistry} elementRegistry
 */
function Outline(eventBus, styles, elementRegistry) {

  this.offset = 6;

  var OUTLINE_STYLE = styles.cls('djs-outline', [ 'no-fill' ]);

  var self = this;

  function createOutline(gfx, bounds) {
    var outline = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('rect');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(outline, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({
      x: 10,
      y: 10,
      width: 100,
      height: 100
    }, OUTLINE_STYLE));

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(gfx, outline);

    return outline;
  }

  // A low priortity is necessary, because outlines of labels have to be updated
  // after the label bounds have been updated in the renderer.
  eventBus.on([ 'shape.added', 'shape.changed' ], LOW_PRIORITY, function(event) {
    var element = event.element,
        gfx = event.gfx;

    var outline = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)('.djs-outline', gfx);

    if (!outline) {
      outline = createOutline(gfx, element);
    }

    self.updateShapeOutline(outline, element);
  });

  eventBus.on([ 'connection.added', 'connection.changed' ], function(event) {
    var element = event.element,
        gfx = event.gfx;

    var outline = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)('.djs-outline', gfx);

    if (!outline) {
      outline = createOutline(gfx, element);
    }

    self.updateConnectionOutline(outline, element);
  });
}


/**
 * Updates the outline of a shape respecting the dimension of the
 * element and an outline offset.
 *
 * @param  {SVGElement} outline
 * @param  {djs.model.Base} element
 */
Outline.prototype.updateShapeOutline = function(outline, element) {

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(outline, {
    x: -this.offset,
    y: -this.offset,
    width: element.width + this.offset * 2,
    height: element.height + this.offset * 2
  });

};


/**
 * Updates the outline of a connection respecting the bounding box of
 * the connection and an outline offset.
 *
 * @param  {SVGElement} outline
 * @param  {djs.model.Base} element
 */
Outline.prototype.updateConnectionOutline = function(outline, connection) {

  var bbox = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.getBBox)(connection);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(outline, {
    x: bbox.x - this.offset,
    y: bbox.y - this.offset,
    width: bbox.width + this.offset * 2,
    height: bbox.height + this.offset * 2
  });

};


Outline.$inject = ['eventBus', 'styles', 'elementRegistry'];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/outline/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/outline/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Outline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Outline */ "./node_modules/diagram-js/lib/features/outline/Outline.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'outline' ],
  outline: [ 'type', _Outline__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/overlays/Overlays.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/overlays/Overlays.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Overlays)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var _util_IdGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/IdGenerator */ "./node_modules/diagram-js/lib/util/IdGenerator.js");








// document wide unique overlay ids
var ids = new _util_IdGenerator__WEBPACK_IMPORTED_MODULE_0__.default('ov');

var LOW_PRIORITY = 500;


/**
 * A service that allows users to attach overlays to diagram elements.
 *
 * The overlay service will take care of overlay positioning during updates.
 *
 * @example
 *
 * // add a pink badge on the top left of the shape
 * overlays.add(someShape, {
 *   position: {
 *     top: -5,
 *     left: -5
 *   },
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
 *
 * // or add via shape id
 *
 * overlays.add('some-element-id', {
 *   position: {
 *     top: -5,
 *     left: -5
 *   }
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
 *
 * // or add with optional type
 *
 * overlays.add(someShape, 'badge', {
 *   position: {
 *     top: -5,
 *     left: -5
 *   }
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
 *
 *
 * // remove an overlay
 *
 * var id = overlays.add(...);
 * overlays.remove(id);
 *
 *
 * You may configure overlay defaults during tool by providing a `config` module
 * with `overlays.defaults` as an entry:
 *
 * {
 *   overlays: {
 *     defaults: {
 *       show: {
 *         minZoom: 0.7,
 *         maxZoom: 5.0
 *       },
 *       scale: {
 *         min: 1
 *       }
 *     }
 * }
 *
 * @param {Object} config
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {ElementRegistry} elementRegistry
 */
function Overlays(config, eventBus, canvas, elementRegistry) {

  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementRegistry = elementRegistry;

  this._ids = ids;

  this._overlayDefaults = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({

    // no show constraints
    show: null,

    // always scale
    scale: true
  }, config && config.defaults);

  /**
   * Mapping overlayId -> overlay
   */
  this._overlays = {};

  /**
   * Mapping elementId -> overlay container
   */
  this._overlayContainers = [];

  // root html element for all overlays
  this._overlayRoot = createRoot(canvas.getContainer());

  this._init();
}


Overlays.$inject = [
  'config.overlays',
  'eventBus',
  'canvas',
  'elementRegistry'
];


/**
 * Returns the overlay with the specified id or a list of overlays
 * for an element with a given type.
 *
 * @example
 *
 * // return the single overlay with the given id
 * overlays.get('some-id');
 *
 * // return all overlays for the shape
 * overlays.get({ element: someShape });
 *
 * // return all overlays on shape with type 'badge'
 * overlays.get({ element: someShape, type: 'badge' });
 *
 * // shape can also be specified as id
 * overlays.get({ element: 'element-id', type: 'badge' });
 *
 *
 * @param {Object} search
 * @param {string} [search.id]
 * @param {string|djs.model.Base} [search.element]
 * @param {string} [search.type]
 *
 * @return {Object|Array<Object>} the overlay(s)
 */
Overlays.prototype.get = function(search) {

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isString)(search)) {
    search = { id: search };
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isString)(search.element)) {
    search.element = this._elementRegistry.get(search.element);
  }

  if (search.element) {
    var container = this._getOverlayContainer(search.element, true);

    // return a list of overlays when searching by element (+type)
    if (container) {
      return search.type ? (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.filter)(container.overlays, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.matchPattern)({ type: search.type })) : container.overlays.slice();
    } else {
      return [];
    }
  } else
  if (search.type) {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.filter)(this._overlays, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.matchPattern)({ type: search.type }));
  } else {

    // return single element when searching by id
    return search.id ? this._overlays[search.id] : null;
  }
};

/**
 * Adds a HTML overlay to an element.
 *
 * @param {string|djs.model.Base}   element   attach overlay to this shape
 * @param {string}                  [type]    optional type to assign to the overlay
 * @param {Object}                  overlay   the overlay configuration
 *
 * @param {string|DOMElement}       overlay.html                 html element to use as an overlay
 * @param {Object}                  [overlay.show]               show configuration
 * @param {number}                  [overlay.show.minZoom]       minimal zoom level to show the overlay
 * @param {number}                  [overlay.show.maxZoom]       maximum zoom level to show the overlay
 * @param {Object}                  overlay.position             where to attach the overlay
 * @param {number}                  [overlay.position.left]      relative to element bbox left attachment
 * @param {number}                  [overlay.position.top]       relative to element bbox top attachment
 * @param {number}                  [overlay.position.bottom]    relative to element bbox bottom attachment
 * @param {number}                  [overlay.position.right]     relative to element bbox right attachment
 * @param {boolean|Object}          [overlay.scale=true]         false to preserve the same size regardless of
 *                                                               diagram zoom
 * @param {number}                  [overlay.scale.min]
 * @param {number}                  [overlay.scale.max]
 *
 * @return {string}                 id that may be used to reference the overlay for update or removal
 */
Overlays.prototype.add = function(element, type, overlay) {

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isObject)(type)) {
    overlay = type;
    type = null;
  }

  if (!element.id) {
    element = this._elementRegistry.get(element);
  }

  if (!overlay.position) {
    throw new Error('must specifiy overlay position');
  }

  if (!overlay.html) {
    throw new Error('must specifiy overlay html');
  }

  if (!element) {
    throw new Error('invalid element specified');
  }

  var id = this._ids.next();

  overlay = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({}, this._overlayDefaults, overlay, {
    id: id,
    type: type,
    element: element,
    html: overlay.html
  });

  this._addOverlay(overlay);

  return id;
};


/**
 * Remove an overlay with the given id or all overlays matching the given filter.
 *
 * @see Overlays#get for filter options.
 *
 * @param {string} [id]
 * @param {Object} [filter]
 */
Overlays.prototype.remove = function(filter) {

  var overlays = this.get(filter) || [];

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isArray)(overlays)) {
    overlays = [ overlays ];
  }

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(overlays, function(overlay) {

    var container = self._getOverlayContainer(overlay.element, true);

    if (overlay) {
      (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.remove)(overlay.html);
      (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.remove)(overlay.htmlContainer);

      delete overlay.htmlContainer;
      delete overlay.element;

      delete self._overlays[overlay.id];
    }

    if (container) {
      var idx = container.overlays.indexOf(overlay);
      if (idx !== -1) {
        container.overlays.splice(idx, 1);
      }
    }
  });

};


Overlays.prototype.show = function() {
  setVisible(this._overlayRoot);
};


Overlays.prototype.hide = function() {
  setVisible(this._overlayRoot, false);
};

Overlays.prototype.clear = function() {
  this._overlays = {};

  this._overlayContainers = [];

  (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.clear)(this._overlayRoot);
};

Overlays.prototype._updateOverlayContainer = function(container) {
  var element = container.element,
      html = container.html;

  // update container left,top according to the elements x,y coordinates
  // this ensures we can attach child elements relative to this container

  var x = element.x,
      y = element.y;

  if (element.waypoints) {
    var bbox = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.getBBox)(element);
    x = bbox.x;
    y = bbox.y;
  }

  setPosition(html, x, y);

  (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.attr)(container.html, 'data-container-id', element.id);
};


Overlays.prototype._updateOverlay = function(overlay) {

  var position = overlay.position,
      htmlContainer = overlay.htmlContainer,
      element = overlay.element;

  // update overlay html relative to shape because
  // it is already positioned on the element

  // update relative
  var left = position.left,
      top = position.top;

  if (position.right !== undefined) {

    var width;

    if (element.waypoints) {
      width = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.getBBox)(element).width;
    } else {
      width = element.width;
    }

    left = position.right * -1 + width;
  }

  if (position.bottom !== undefined) {

    var height;

    if (element.waypoints) {
      height = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.getBBox)(element).height;
    } else {
      height = element.height;
    }

    top = position.bottom * -1 + height;
  }

  setPosition(htmlContainer, left || 0, top || 0);
};


Overlays.prototype._createOverlayContainer = function(element) {
  var html = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.domify)('<div class="djs-overlays" style="position: absolute" />');

  this._overlayRoot.appendChild(html);

  var container = {
    html: html,
    element: element,
    overlays: []
  };

  this._updateOverlayContainer(container);

  this._overlayContainers.push(container);

  return container;
};


Overlays.prototype._updateRoot = function(viewbox) {
  var scale = viewbox.scale || 1;

  var matrix = 'matrix(' +
  [
    scale,
    0,
    0,
    scale,
    -1 * viewbox.x * scale,
    -1 * viewbox.y * scale
  ].join(',') +
  ')';

  setTransform(this._overlayRoot, matrix);
};


Overlays.prototype._getOverlayContainer = function(element, raw) {
  var container = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(this._overlayContainers, function(c) {
    return c.element === element;
  });


  if (!container && !raw) {
    return this._createOverlayContainer(element);
  }

  return container;
};


Overlays.prototype._addOverlay = function(overlay) {

  var id = overlay.id,
      element = overlay.element,
      html = overlay.html,
      htmlContainer,
      overlayContainer;

  // unwrap jquery (for those who need it)
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }

  // create proper html elements from
  // overlay HTML strings
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isString)(html)) {
    html = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.domify)(html);
  }

  overlayContainer = this._getOverlayContainer(element);

  htmlContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.domify)('<div class="djs-overlay" data-overlay-id="' + id + '" style="position: absolute">');

  htmlContainer.appendChild(html);

  if (overlay.type) {
    (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.classes)(htmlContainer).add('djs-overlay-' + overlay.type);
  }

  overlay.htmlContainer = htmlContainer;

  overlayContainer.overlays.push(overlay);
  overlayContainer.html.appendChild(htmlContainer);

  this._overlays[id] = overlay;

  this._updateOverlay(overlay);
  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
};


Overlays.prototype._updateOverlayVisibilty = function(overlay, viewbox) {
  var show = overlay.show,
      minZoom = show && show.minZoom,
      maxZoom = show && show.maxZoom,
      htmlContainer = overlay.htmlContainer,
      visible = true;

  if (show) {
    if (
      ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isDefined)(minZoom) && minZoom > viewbox.scale) ||
      ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isDefined)(maxZoom) && maxZoom < viewbox.scale)
    ) {
      visible = false;
    }

    setVisible(htmlContainer, visible);
  }

  this._updateOverlayScale(overlay, viewbox);
};


Overlays.prototype._updateOverlayScale = function(overlay, viewbox) {
  var shouldScale = overlay.scale,
      minScale,
      maxScale,
      htmlContainer = overlay.htmlContainer;

  var scale, transform = '';

  if (shouldScale !== true) {

    if (shouldScale === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = shouldScale.min;
      maxScale = shouldScale.max;
    }

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isDefined)(minScale) && viewbox.scale < minScale) {
      scale = (1 / viewbox.scale || 1) * minScale;
    }

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isDefined)(maxScale) && viewbox.scale > maxScale) {
      scale = (1 / viewbox.scale || 1) * maxScale;
    }
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isDefined)(scale)) {
    transform = 'scale(' + scale + ',' + scale + ')';
  }

  setTransform(htmlContainer, transform);
};


Overlays.prototype._updateOverlaysVisibilty = function(viewbox) {

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(this._overlays, function(overlay) {
    self._updateOverlayVisibilty(overlay, viewbox);
  });
};


Overlays.prototype._init = function() {

  var eventBus = this._eventBus;

  var self = this;


  // scroll/zoom integration

  function updateViewbox(viewbox) {
    self._updateRoot(viewbox);
    self._updateOverlaysVisibilty(viewbox);

    self.show();
  }

  eventBus.on('canvas.viewbox.changing', function(event) {
    self.hide();
  });

  eventBus.on('canvas.viewbox.changed', function(event) {
    updateViewbox(event.viewbox);
  });


  // remove integration

  eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {
    var element = e.element;
    var overlays = self.get({ element: element });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(overlays, function(o) {
      self.remove(o.id);
    });

    var container = self._getOverlayContainer(element);

    if (container) {
      (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.remove)(container.html);
      var i = self._overlayContainers.indexOf(container);
      if (i !== -1) {
        self._overlayContainers.splice(i, 1);
      }
    }
  });


  // move integration

  eventBus.on('element.changed', LOW_PRIORITY, function(e) {
    var element = e.element;

    var container = self._getOverlayContainer(element, true);

    if (container) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(container.overlays, function(overlay) {
        self._updateOverlay(overlay);
      });

      self._updateOverlayContainer(container);
    }
  });


  // marker integration, simply add them on the overlays as classes, too.

  eventBus.on('element.marker.update', function(e) {
    var container = self._getOverlayContainer(e.element, true);
    if (container) {
      (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.classes)(container.html)[e.add ? 'add' : 'remove'](e.marker);
    }
  });


  // clear overlays with diagram

  eventBus.on('diagram.clear', this.clear, this);
};



// helpers /////////////////////////////

function createRoot(parentNode) {
  var root = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.domify)(
    '<div class="djs-overlay-container" style="position: absolute; width: 0; height: 0;" />'
  );

  parentNode.insertBefore(root, parentNode.firstChild);

  return root;
}

function setPosition(el, x, y) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(el.style, { left: x + 'px', top: y + 'px' });
}

function setVisible(el, visible) {
  el.style.display = visible === false ? 'none' : '';
}

function setTransform(el, transform) {

  el.style['transform-origin'] = 'top left';

  [ '', '-ms-', '-webkit-' ].forEach(function(prefix) {
    el.style[prefix + 'transform'] = transform;
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/overlays/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/overlays/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Overlays__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Overlays */ "./node_modules/diagram-js/lib/features/overlays/Overlays.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'overlays' ],
  overlays: [ 'type', _Overlays__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/palette/Palette.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/palette/Palette.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Palette)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");





var TOGGLE_SELECTOR = '.djs-palette-toggle',
    ENTRY_SELECTOR = '.entry',
    ELEMENT_SELECTOR = TOGGLE_SELECTOR + ', ' + ENTRY_SELECTOR;

var PALETTE_OPEN_CLS = 'open',
    PALETTE_TWO_COLUMN_CLS = 'two-column';

var DEFAULT_PRIORITY = 1000;


/**
 * A palette containing modeling elements.
 */
function Palette(eventBus, canvas) {

  this._eventBus = eventBus;
  this._canvas = canvas;

  var self = this;

  eventBus.on('tool-manager.update', function(event) {
    var tool = event.tool;

    self.updateToolHighlight(tool);
  });

  eventBus.on('i18n.changed', function() {
    self._update();
  });

  eventBus.on('diagram.init', function() {

    self._diagramInitialized = true;

    self._rebuild();
  });
}

Palette.$inject = [ 'eventBus', 'canvas' ];


/**
 * Register a provider with the palette
 *
 * @param  {number} [priority=1000]
 * @param  {PaletteProvider} provider
 *
 * @example
 * const paletteProvider = {
 *   getPaletteEntries: function() {
 *     return function(entries) {
 *       return {
 *         ...entries,
 *         'entry-1': {
 *           label: 'My Entry',
 *           action: function() { alert("I have been clicked!"); }
 *         }
 *       };
 *     }
 *   }
 * };
 *
 * palette.registerProvider(800, paletteProvider);
 */
Palette.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY;
  }

  this._eventBus.on('palette.getProviders', priority, function(event) {
    event.providers.push(provider);
  });

  this._rebuild();
};


/**
 * Returns the palette entries
 *
 * @return {Object<string, PaletteEntryDescriptor>} map of entries
 */
Palette.prototype.getEntries = function() {
  var providers = this._getProviders();

  return providers.reduce(addPaletteEntries, {});
};

Palette.prototype._rebuild = function() {

  if (!this._diagramInitialized) {
    return;
  }

  var providers = this._getProviders();

  if (!providers.length) {
    return;
  }

  if (!this._container) {
    this._init();
  }

  this._update();
};

/**
 * Initialize
 */
Palette.prototype._init = function() {

  var self = this;

  var eventBus = this._eventBus;

  var parentContainer = this._getParentContainer();

  var container = this._container = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(Palette.HTML_MARKUP);

  parentContainer.appendChild(container);

  min_dom__WEBPACK_IMPORTED_MODULE_0__.delegate.bind(container, ELEMENT_SELECTOR, 'click', function(event) {

    var target = event.delegateTarget;

    if ((0,min_dom__WEBPACK_IMPORTED_MODULE_0__.matches)(target, TOGGLE_SELECTOR)) {
      return self.toggle();
    }

    self.trigger('click', event);
  });

  // prevent drag propagation
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(container, 'mousedown', function(event) {
    event.stopPropagation();
  });

  // prevent drag propagation
  min_dom__WEBPACK_IMPORTED_MODULE_0__.delegate.bind(container, ENTRY_SELECTOR, 'dragstart', function(event) {
    self.trigger('dragstart', event);
  });

  eventBus.on('canvas.resized', this._layoutChanged, this);

  eventBus.fire('palette.create', {
    container: container
  });
};

Palette.prototype._getProviders = function(id) {

  var event = this._eventBus.createEvent({
    type: 'palette.getProviders',
    providers: []
  });

  this._eventBus.fire(event);

  return event.providers;
};

/**
 * Update palette state.
 *
 * @param  {Object} [state] { open, twoColumn }
 */
Palette.prototype._toggleState = function(state) {

  state = state || {};

  var parent = this._getParentContainer(),
      container = this._container;

  var eventBus = this._eventBus;

  var twoColumn;

  var cls = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(container);

  if ('twoColumn' in state) {
    twoColumn = state.twoColumn;
  } else {
    twoColumn = this._needsCollapse(parent.clientHeight, this._entries || {});
  }

  // always update two column
  cls.toggle(PALETTE_TWO_COLUMN_CLS, twoColumn);

  if ('open' in state) {
    cls.toggle(PALETTE_OPEN_CLS, state.open);
  }

  eventBus.fire('palette.changed', {
    twoColumn: twoColumn,
    open: this.isOpen()
  });
};

Palette.prototype._update = function() {

  var entriesContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.djs-palette-entries', this._container),
      entries = this._entries = this.getEntries();

  (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.clear)(entriesContainer);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(entries, function(entry, id) {

    var grouping = entry.group || 'default';

    var container = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.query)('[data-group=' + grouping + ']', entriesContainer);
    if (!container) {
      container = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)('<div class="group" data-group="' + grouping + '"></div>');
      entriesContainer.appendChild(container);
    }

    var html = entry.html || (
      entry.separator ?
        '<hr class="separator" />' :
        '<div class="entry" draggable="true"></div>');


    var control = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(html);
    container.appendChild(control);

    if (!entry.separator) {
      (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.attr)(control, 'data-action', id);

      if (entry.title) {
        (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.attr)(control, 'title', entry.title);
      }

      if (entry.className) {
        addClasses(control, entry.className);
      }

      if (entry.imageUrl) {
        control.appendChild((0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)('<img src="' + entry.imageUrl + '">'));
      }
    }
  });

  // open after update
  this.open();
};


/**
 * Trigger an action available on the palette
 *
 * @param  {string} action
 * @param  {Event} event
 */
Palette.prototype.trigger = function(action, event, autoActivate) {
  var entries = this._entries,
      entry,
      handler,
      originalEvent,
      button = event.delegateTarget || event.target;

  if (!button) {
    return event.preventDefault();
  }

  entry = entries[(0,min_dom__WEBPACK_IMPORTED_MODULE_0__.attr)(button, 'data-action')];

  // when user clicks on the palette and not on an action
  if (!entry) {
    return;
  }

  handler = entry.action;

  originalEvent = event.originalEvent || event;

  // simple action (via callback function)
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
    if (action === 'click') {
      handler(originalEvent, autoActivate);
    }
  } else {
    if (handler[action]) {
      handler[action](originalEvent, autoActivate);
    }
  }

  // silence other actions
  event.preventDefault();
};

Palette.prototype._layoutChanged = function() {
  this._toggleState({});
};

/**
 * Do we need to collapse to two columns?
 *
 * @param {number} availableHeight
 * @param {Object} entries
 *
 * @return {boolean}
 */
Palette.prototype._needsCollapse = function(availableHeight, entries) {

  // top margin + bottom toggle + bottom margin
  // implementors must override this method if they
  // change the palette styles
  var margin = 20 + 10 + 20;

  var entriesHeight = Object.keys(entries).length * 46;

  return availableHeight < entriesHeight + margin;
};

/**
 * Close the palette
 */
Palette.prototype.close = function() {

  this._toggleState({
    open: false,
    twoColumn: false
  });
};


/**
 * Open the palette
 */
Palette.prototype.open = function() {
  this._toggleState({ open: true });
};


Palette.prototype.toggle = function(open) {
  if (this.isOpen()) {
    this.close();
  } else {
    this.open();
  }
};

Palette.prototype.isActiveTool = function(tool) {
  return tool && this._activeTool === tool;
};

Palette.prototype.updateToolHighlight = function(name) {
  var entriesContainer,
      toolsContainer;

  if (!this._toolsContainer) {
    entriesContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.djs-palette-entries', this._container);

    this._toolsContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.query)('[data-group=tools]', entriesContainer);
  }

  toolsContainer = this._toolsContainer;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(toolsContainer.children, function(tool) {
    var actionName = tool.getAttribute('data-action');

    if (!actionName) {
      return;
    }

    var toolClasses = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(tool);

    actionName = actionName.replace('-tool', '');

    if (toolClasses.contains('entry') && actionName === name) {
      toolClasses.add('highlighted-entry');
    } else {
      toolClasses.remove('highlighted-entry');
    }
  });
};


/**
 * Return true if the palette is opened.
 *
 * @example
 *
 * palette.open();
 *
 * if (palette.isOpen()) {
 *   // yes, we are open
 * }
 *
 * @return {boolean} true if palette is opened
 */
Palette.prototype.isOpen = function() {
  return (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(this._container).has(PALETTE_OPEN_CLS);
};

/**
 * Get container the palette lives in.
 *
 * @return {Element}
 */
Palette.prototype._getParentContainer = function() {
  return this._canvas.getContainer();
};


/* markup definition */

Palette.HTML_MARKUP =
  '<div class="djs-palette">' +
    '<div class="djs-palette-entries"></div>' +
    '<div class="djs-palette-toggle"></div>' +
  '</div>';


// helpers //////////////////////

function addClasses(element, classNames) {

  var classes = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(element);

  var actualClassNames = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isArray)(classNames) ? classNames : classNames.split(/\s+/g);
  actualClassNames.forEach(function(cls) {
    classes.add(cls);
  });
}

function addPaletteEntries(entries, provider) {

  var entriesOrUpdater = provider.getPaletteEntries();

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isFunction)(entriesOrUpdater)) {
    return entriesOrUpdater(entries);
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(entriesOrUpdater, function(entry, id) {
    entries[id] = entry;
  });

  return entries;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/palette/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/palette/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Palette */ "./node_modules/diagram-js/lib/features/palette/Palette.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'palette' ],
  palette: [ 'type', _Palette__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PopupMenu)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");




var DATA_REF = 'data-id';

var CLOSE_EVENTS = [
  'contextPad.close',
  'canvas.viewbox.changing',
  'commandStack.changed'
];

var DEFAULT_PRIORITY = 1000;


/**
 * A popup menu that can be used to display a list of actions anywhere in the canvas.
 *
 * @param {Object} config
 * @param {boolean|Object} [config.scale={ min: 1.0, max: 1.5 }]
 * @param {number} [config.scale.min]
 * @param {number} [config.scale.max]
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 *
 * @class
 * @constructor
 */
function PopupMenu(config, eventBus, canvas) {

  var scale = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isDefined)(config && config.scale) ? config.scale : {
    min: 1,
    max: 1.5
  };

  this._config = {
    scale: scale
  };

  this._eventBus = eventBus;
  this._canvas = canvas;
  this._providers = {};
  this._current = {};
}

PopupMenu.$inject = [
  'config.popupMenu',
  'eventBus',
  'canvas'
];

/**
 * Registers a popup menu provider
 *
 * @param  {string} id
 * @param {number} [priority=1000]
 * @param  {Object} provider
 *
 * @example
 * const popupMenuProvider = {
 *   getPopupMenuEntries: function(element) {
 *     return {
 *       'entry-1': {
 *         label: 'My Entry',
 *         action: function() { alert("I have been clicked!"); }
 *       }
 *     }
 *   }
 * };
 *
 * popupMenu.registerProvider('myMenuID', popupMenuProvider);
 */
PopupMenu.prototype.registerProvider = function(id, priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY;
  }

  this._eventBus.on('popupMenu.getProviders.' + id, priority, function(event) {
    event.providers.push(provider);
  });
};

/**
 * Determine if the popup menu has entries.
 *
 * @return {boolean} true if empty
 */
PopupMenu.prototype.isEmpty = function(element, providerId) {
  if (!element) {
    throw new Error('element parameter is missing');
  }

  if (!providerId) {
    throw new Error('providerId parameter is missing');
  }

  var providers = this._getProviders(providerId);

  if (!providers) {
    return true;
  }

  var entries = this._getEntries(element, providers),
      headerEntries = this._getHeaderEntries(element, providers);

  var hasEntries = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.size)(entries) > 0,
      hasHeaderEntries = headerEntries && (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.size)(headerEntries) > 0;

  return !hasEntries && !hasHeaderEntries;
};


/**
 * Create entries and open popup menu at given position
 *
 * @param  {Object} element
 * @param  {string} id provider id
 * @param  {Object} position
 *
 * @return {Object} popup menu instance
 */
PopupMenu.prototype.open = function(element, id, position) {

  var providers = this._getProviders(id);

  if (!element) {
    throw new Error('Element is missing');
  }

  if (!providers || !providers.length) {
    throw new Error('No registered providers for: ' + id);
  }

  if (!position) {
    throw new Error('the position argument is missing');
  }

  if (this.isOpen()) {
    this.close();
  }

  this._emit('open');

  var current = this._current = {
    className: id,
    element: element,
    position: position
  };

  var entries = this._getEntries(element, providers),
      headerEntries = this._getHeaderEntries(element, providers);

  current.entries = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, entries, headerEntries);

  current.container = this._createContainer();

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.size)(headerEntries)) {
    current.container.appendChild(
      this._createEntries(headerEntries, 'djs-popup-header')
    );
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.size)(entries)) {
    current.container.appendChild(
      this._createEntries(entries, 'djs-popup-body')
    );
  }

  var canvas = this._canvas,
      parent = canvas.getContainer();

  this._attachContainer(current.container, parent, position.cursor);
  this._bindAutoClose();
};


/**
 * Removes the popup menu and unbinds the event handlers.
 */
PopupMenu.prototype.close = function() {

  if (!this.isOpen()) {
    return;
  }

  this._emit('close');

  this._unbindAutoClose();
  (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.remove)(this._current.container);
  this._current.container = null;
};


/**
 * Determine if an open popup menu exist.
 *
 * @return {boolean} true if open
 */
PopupMenu.prototype.isOpen = function() {
  return !!this._current.container;
};


/**
 * Trigger an action associated with an entry.
 *
 * @param {Object} event
 *
 * @return the result of the action callback, if any
 */
PopupMenu.prototype.trigger = function(event) {

  // silence other actions
  event.preventDefault();

  var element = event.delegateTarget || event.target,
      entryId = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(element, DATA_REF);

  var entry = this._getEntry(entryId);

  if (entry.action) {
    return entry.action.call(null, event, entry);
  }
};

PopupMenu.prototype._getProviders = function(id) {

  var event = this._eventBus.createEvent({
    type: 'popupMenu.getProviders.' + id,
    providers: []
  });

  this._eventBus.fire(event);

  return event.providers;
};

PopupMenu.prototype._getEntries = function(element, providers) {

  var entries = {};

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(providers, function(provider) {

    // handle legacy method
    if (!provider.getPopupMenuEntries) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(provider.getEntries(element), function(entry) {
        var id = entry.id;

        if (!id) {
          throw new Error('every entry must have the id property set');
        }

        entries[id] = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(entry, [ 'id' ]);
      });

      return;
    }

    var entriesOrUpdater = provider.getPopupMenuEntries(element);

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });

  return entries;
};

PopupMenu.prototype._getHeaderEntries = function(element, providers) {

  var entries = {};

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(providers, function(provider) {

    // handle legacy method
    if (!provider.getPopupMenuHeaderEntries) {
      if (!provider.getHeaderEntries) {
        return;
      }

      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(provider.getHeaderEntries(element), function(entry) {
        var id = entry.id;

        if (!id) {
          throw new Error('every entry must have the id property set');
        }

        entries[id] = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(entry, [ 'id' ]);
      });

      return;
    }

    var entriesOrUpdater = provider.getPopupMenuHeaderEntries(element);

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });

  return entries;


};

/**
 * Gets an entry instance (either entry or headerEntry) by id.
 *
 * @param  {string} entryId
 *
 * @return {Object} entry instance
 */
PopupMenu.prototype._getEntry = function(entryId) {

  var entry = this._current.entries[entryId];

  if (!entry) {
    throw new Error('entry not found');
  }

  return entry;
};

PopupMenu.prototype._emit = function(eventName) {
  this._eventBus.fire('popupMenu.' + eventName);
};

/**
 * Creates the popup menu container.
 *
 * @return {Object} a DOM container
 */
PopupMenu.prototype._createContainer = function() {
  var container = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div class="djs-popup">'),
      position = this._current.position,
      className = this._current.className;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(container.style, {
    position: 'absolute',
    left: position.x + 'px',
    top: position.y + 'px',
    visibility: 'hidden'
  });

  (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(container).add(className);

  return container;
};


/**
 * Attaches the container to the DOM.
 *
 * @param {Object} container
 * @param {Object} parent
 */
PopupMenu.prototype._attachContainer = function(container, parent, cursor) {
  var self = this;

  // Event handler
  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(container, '.entry' ,'click', function(event) {
    self.trigger(event);
  });

  this._updateScale(container);

  // Attach to DOM
  parent.appendChild(container);

  if (cursor) {
    this._assureIsInbounds(container, cursor);
  }
};


/**
 * Updates popup style.transform with respect to the config and zoom level.
 *
 * @method _updateScale
 *
 * @param {Object} container
 */
PopupMenu.prototype._updateScale = function(container) {
  var zoom = this._canvas.zoom();

  var scaleConfig = this._config.scale,
      minScale,
      maxScale,
      scale = zoom;

  if (scaleConfig !== true) {

    if (scaleConfig === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = scaleConfig.min;
      maxScale = scaleConfig.max;
    }

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isDefined)(minScale) && zoom < minScale) {
      scale = minScale;
    }

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isDefined)(maxScale) && zoom > maxScale) {
      scale = maxScale;
    }

  }

  setTransform(container, 'scale(' + scale + ')');
};


/**
 * Make sure that the menu is always fully shown
 *
 * @method function
 *
 * @param  {Object} container
 * @param  {Position} cursor {x, y}
 */
PopupMenu.prototype._assureIsInbounds = function(container, cursor) {
  var canvas = this._canvas,
      clientRect = canvas._container.getBoundingClientRect();

  var containerX = container.offsetLeft,
      containerY = container.offsetTop,
      containerWidth = container.scrollWidth,
      containerHeight = container.scrollHeight,
      overAxis = {},
      left, top;

  var cursorPosition = {
    x: cursor.x - clientRect.left,
    y: cursor.y - clientRect.top
  };

  if (containerX + containerWidth > clientRect.width) {
    overAxis.x = true;
  }

  if (containerY + containerHeight > clientRect.height) {
    overAxis.y = true;
  }

  if (overAxis.x && overAxis.y) {
    left = cursorPosition.x - containerWidth + 'px';
    top = cursorPosition.y - containerHeight + 'px';
  } else if (overAxis.x) {
    left = cursorPosition.x - containerWidth + 'px';
    top = cursorPosition.y + 'px';
  } else if (overAxis.y && cursorPosition.y < containerHeight) {
    left = cursorPosition.x + 'px';
    top = 10 + 'px';
  } else if (overAxis.y) {
    left = cursorPosition.x + 'px';
    top = cursorPosition.y - containerHeight + 'px';
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(container.style, { left: left, top: top }, { visibility: 'visible', 'z-index': 1000 });
};


/**
 * Creates a list of entries and returns them as a DOM container.
 *
 * @param {Array<Object>} entries an array of entry objects
 * @param {string} className the class name of the entry container
 *
 * @return {Object} a DOM container
 */
PopupMenu.prototype._createEntries = function(entries, className) {

  var entriesContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div>'),
      self = this;

  (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(entriesContainer).add(className);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(entries, function(entry, id) {
    var entryContainer = self._createEntry(entry, id);
    entriesContainer.appendChild(entryContainer);
  });

  return entriesContainer;
};


/**
 * Creates a single entry and returns it as a DOM container.
 *
 * @param  {Object} entry
 *
 * @return {Object} a DOM container
 */
PopupMenu.prototype._createEntry = function(entry, id) {

  var entryContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div>'),
      entryClasses = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(entryContainer);

  entryClasses.add('entry');

  if (entry.className) {
    entry.className.split(' ').forEach(function(className) {
      entryClasses.add(className);
    });
  }

  (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(entryContainer, DATA_REF, id);

  if (entry.label) {
    var label = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<span>');
    label.textContent = entry.label;
    entryContainer.appendChild(label);
  }

  if (entry.imageUrl) {
    entryContainer.appendChild((0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<img src="' + entry.imageUrl + '" />'));
  }

  if (entry.active === true) {
    entryClasses.add('active');
  }

  if (entry.disabled === true) {
    entryClasses.add('disabled');
  }

  if (entry.title) {
    entryContainer.title = entry.title;
  }

  return entryContainer;
};


/**
 * Set up listener to close popup automatically on certain events.
 */
PopupMenu.prototype._bindAutoClose = function() {
  this._eventBus.once(CLOSE_EVENTS, this.close, this);
};


/**
 * Remove the auto-closing listener.
 */
PopupMenu.prototype._unbindAutoClose = function() {
  this._eventBus.off(CLOSE_EVENTS, this.close, this);
};



// helpers /////////////////////////////

function setTransform(element, transform) {
  element.style['transform-origin'] = 'top left';

  [ '', '-ms-', '-webkit-' ].forEach(function(prefix) {
    element.style[prefix + 'transform'] = transform;
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/popup-menu/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/popup-menu/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PopupMenu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PopupMenu */ "./node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'popupMenu' ],
  popupMenu: [ 'type', _PopupMenu__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js":
/*!********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PreviewSupport)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/GraphicsUtil */ "./node_modules/diagram-js/lib/util/GraphicsUtil.js");








var MARKER_TYPES = [
  'marker-start',
  'marker-mid',
  'marker-end'
];

var NODES_CAN_HAVE_MARKER = [
  'circle',
  'ellipse',
  'line',
  'path',
  'polygon',
  'polyline',
  'rect'
];


/**
 * Adds support for previews of moving/resizing elements.
 */
function PreviewSupport(elementRegistry, eventBus, canvas, styles) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  this._styles = styles;

  this._clonedMarkers = {};

  var self = this;

  eventBus.on('drag.cleanup', function() {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(self._clonedMarkers, function(clonedMarker) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(clonedMarker);
    });

    self._clonedMarkers = {};
  });
}

PreviewSupport.$inject = [
  'elementRegistry',
  'eventBus',
  'canvas',
  'styles'
];


/**
 * Returns graphics of an element.
 *
 * @param {djs.model.Base} element
 *
 * @return {SVGElement}
 */
PreviewSupport.prototype.getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};

/**
 * Adds a move preview of a given shape to a given svg group.
 *
 * @param {djs.model.Base} element
 * @param {SVGElement} group
 * @param {SVGElement} [gfx]
 *
 * @return {SVGElement} dragger
 */
PreviewSupport.prototype.addDragger = function(element, group, gfx) {
  gfx = gfx || this.getGfx(element);

  var dragger = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.clone)(gfx);
  var bbox = gfx.getBoundingClientRect();

  this._cloneMarkers((0,_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_2__.getVisual)(dragger));

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(dragger, this._styles.cls('djs-dragger', [], {
    x: bbox.top,
    y: bbox.left
  }));

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(group, dragger);

  return dragger;
};

/**
 * Adds a resize preview of a given shape to a given svg group.
 *
 * @param {djs.model.Base} element
 * @param {SVGElement} group
 *
 * @return {SVGElement} frame
 */
PreviewSupport.prototype.addFrame = function(shape, group) {

  var frame = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('rect', {
    class: 'djs-resize-overlay',
    width:  shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(group, frame);

  return frame;
};

/**
 * Clone all markers referenced by a node and its child nodes.
 *
 * @param {SVGElement} gfx
 */
PreviewSupport.prototype._cloneMarkers = function(gfx) {
  var self = this;

  if (gfx.childNodes) {

    // TODO: use forEach once we drop PhantomJS
    for (var i = 0; i < gfx.childNodes.length; i++) {

      // recursively clone markers of child nodes
      self._cloneMarkers(gfx.childNodes[ i ]);
    }
  }

  if (!canHaveMarker(gfx)) {
    return;
  }

  MARKER_TYPES.forEach(function(markerType) {
    if ((0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(gfx, markerType)) {
      var marker = getMarker(gfx, markerType, self._canvas.getContainer());

      self._cloneMarker(gfx, marker, markerType);
    }
  });
};

/**
 * Clone marker referenced by an element.
 *
 * @param {SVGElement} gfx
 * @param {SVGElement} marker
 * @param {string} markerType
 */
PreviewSupport.prototype._cloneMarker = function(gfx, marker, markerType) {
  var markerId = marker.id;

  var clonedMarker = this._clonedMarkers[ markerId ];

  if (!clonedMarker) {
    clonedMarker = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.clone)(marker);

    var clonedMarkerId = markerId + '-clone';

    clonedMarker.id = clonedMarkerId;

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(clonedMarker)
      .add('djs-dragger')
      .add('djs-dragger-marker');

    this._clonedMarkers[ markerId ] = clonedMarker;

    var defs = (0,min_dom__WEBPACK_IMPORTED_MODULE_3__.query)('defs', this._canvas._svg);

    if (!defs) {
      defs = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('defs');

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(this._canvas._svg, defs);
    }

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(defs, clonedMarker);
  }

  var reference = idToReference(this._clonedMarkers[ markerId ].id);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(gfx, markerType, reference);
};

// helpers //////////

/**
 * Get marker of given type referenced by node.
 *
 * @param {Node} node
 * @param {string} markerType
 * @param {Node} [parentNode]
 *
 * @param {Node}
 */
function getMarker(node, markerType, parentNode) {
  var id = referenceToId((0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(node, markerType));

  return (0,min_dom__WEBPACK_IMPORTED_MODULE_3__.query)('marker#' + id, parentNode || document);
}

/**
 * Get ID of fragment within current document from its functional IRI reference.
 * References may use single or double quotes.
 *
 * @param {string} reference
 *
 * @returns {string}
 */
function referenceToId(reference) {
  return reference.match(/url\(['"]?#([^'"]*)['"]?\)/)[1];
}

/**
 * Get functional IRI reference for given ID of fragment within current document.
 *
 * @param {string} id
 *
 * @returns {string}
 */
function idToReference(id) {
  return 'url(#' + id + ')';
}

/**
 * Check wether node type can have marker attributes.
 *
 * @param {Node} node
 *
 * @returns {boolean}
 */
function canHaveMarker(node) {
  return NODES_CAN_HAVE_MARKER.indexOf(node.nodeName) !== -1;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/preview-support/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/preview-support/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PreviewSupport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PreviewSupport */ "./node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'previewSupport' ],
  previewSupport: [ 'type', _PreviewSupport__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/replace/Replace.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/replace/Replace.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Replace)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var round = Math.round;

/**
 * Service that allow replacing of elements.
 */
function Replace(modeling) {

  this._modeling = modeling;
}

Replace.$inject = [ 'modeling' ];

/**
 * @param {Element} oldElement - Element to be replaced
 * @param {Object}  newElementData - Containing information about the new element,
 *                                   for example the new bounds and type.
 * @param {Object}  options - Custom options that will be attached to the context. It can be used to inject data
 *                            that is needed in the command chain. For example it could be used in
 *                            eventbus.on('commandStack.shape.replace.postExecute') to change shape attributes after
 *                            shape creation.
 */
Replace.prototype.replaceElement = function(oldElement, newElementData, options) {

  if (oldElement.waypoints) {

    // TODO(nikku): we do not replace connections, yet
    return null;
  }

  var modeling = this._modeling;

  var width = newElementData.width || oldElement.width,
      height = newElementData.height || oldElement.height,
      x = newElementData.x || oldElement.x,
      y = newElementData.y || oldElement.y,
      centerX = round(x + width / 2),
      centerY = round(y + height / 2);

  // modeling API requires center coordinates,
  // account for that when handling shape bounds

  return modeling.replaceShape(
    oldElement,
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(
      {},
      newElementData,
      {
        x: centerX,
        y: centerY,
        width: width,
        height: height
      }
    ),
    options
  );
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/replace/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/replace/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Replace */ "./node_modules/diagram-js/lib/features/replace/Replace.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'replace' ],
  replace: [ 'type', _Replace__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/resize/Resize.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/resize/Resize.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Resize),
/* harmony export */   "getReferencePoint": () => (/* binding */ getReferencePoint)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _ResizeUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeUtil */ "./node_modules/diagram-js/lib/features/resize/ResizeUtil.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");






var DEFAULT_MIN_WIDTH = 10;


/**
 * A component that provides resizing of shapes on the canvas.
 *
 * The following components are part of shape resize:
 *
 *  * adding resize handles,
 *  * creating a visual during resize
 *  * checking resize rules
 *  * committing a change once finished
 *
 *
 * ## Customizing
 *
 * It's possible to customize the resizing behaviour by intercepting 'resize.start'
 * and providing the following parameters through the 'context':
 *
 *   * minDimensions ({ width, height }): minimum shape dimensions
 *
 *   * childrenBoxPadding ({ left, top, bottom, right } || number):
 *     gap between the minimum bounding box and the container
 *
 * f.ex:
 *
 * ```javascript
 * eventBus.on('resize.start', 1500, function(event) {
 *   var context = event.context,
 *
 *  context.minDimensions = { width: 140, height: 120 };
 *
 *  // Passing general padding
 *  context.childrenBoxPadding = 30;
 *
 *  // Passing padding to a specific side
 *  context.childrenBoxPadding.left = 20;
 * });
 * ```
 */
function Resize(eventBus, rules, modeling, dragging) {

  this._dragging = dragging;
  this._rules = rules;

  var self = this;


  /**
   * Handle resize move by specified delta.
   *
   * @param {Object} context
   * @param {Point} delta
   */
  function handleMove(context, delta) {

    var shape = context.shape,
        direction = context.direction,
        resizeConstraints = context.resizeConstraints,
        newBounds;

    context.delta = delta;

    newBounds = (0,_ResizeUtil__WEBPACK_IMPORTED_MODULE_0__.resizeBounds)(shape, direction, delta);

    // ensure constraints during resize
    context.newBounds = (0,_ResizeUtil__WEBPACK_IMPORTED_MODULE_0__.ensureConstraints)(newBounds, resizeConstraints);

    // update + cache executable state
    context.canExecute = self.canResize(context);
  }

  /**
   * Handle resize start.
   *
   * @param  {Object} context
   */
  function handleStart(context) {

    var resizeConstraints = context.resizeConstraints,

        // evaluate minBounds for backwards compatibility
        minBounds = context.minBounds;

    if (resizeConstraints !== undefined) {
      return;
    }

    if (minBounds === undefined) {
      minBounds = self.computeMinResizeBox(context);
    }

    context.resizeConstraints = {
      min: (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(minBounds)
    };
  }

  /**
   * Handle resize end.
   *
   * @param  {Object} context
   */
  function handleEnd(context) {
    var shape = context.shape,
        canExecute = context.canExecute,
        newBounds = context.newBounds;

    if (canExecute) {

      // ensure we have actual pixel values for new bounds
      // (important when zoom level was > 1 during move)
      newBounds = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.roundBounds)(newBounds);

      if (!boundsChanged(shape, newBounds)) {

        // no resize necessary
        return;
      }

      // perform the actual resize
      modeling.resizeShape(shape, newBounds);
    }
  }


  eventBus.on('resize.start', function(event) {
    handleStart(event.context);
  });

  eventBus.on('resize.move', function(event) {
    var delta = {
      x: event.dx,
      y: event.dy
    };

    handleMove(event.context, delta);
  });

  eventBus.on('resize.end', function(event) {
    handleEnd(event.context);
  });

}


Resize.prototype.canResize = function(context) {
  var rules = this._rules;

  var ctx = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.pick)(context, [ 'newBounds', 'shape', 'delta', 'direction' ]);

  return rules.allowed('shape.resize', ctx);
};

/**
 * Activate a resize operation.
 *
 * You may specify additional contextual information and must specify a
 * resize direction during activation of the resize event.
 *
 * @param {MouseEvent} event
 * @param {djs.model.Shape} shape
 * @param {Object|string} contextOrDirection
 */
Resize.prototype.activate = function(event, shape, contextOrDirection) {
  var dragging = this._dragging,
      context,
      direction;

  if (typeof contextOrDirection === 'string') {
    contextOrDirection = {
      direction: contextOrDirection
    };
  }

  context = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ shape: shape }, contextOrDirection);

  direction = context.direction;

  if (!direction) {
    throw new Error('must provide a direction (n|w|s|e|nw|se|ne|sw)');
  }

  dragging.init(event, getReferencePoint(shape, direction), 'resize', {
    autoActivate: true,
    cursor: getCursor(direction),
    data: {
      shape: shape,
      context: context
    }
  });
};

Resize.prototype.computeMinResizeBox = function(context) {
  var shape = context.shape,
      direction = context.direction,
      minDimensions,
      childrenBounds;

  minDimensions = context.minDimensions || {
    width: DEFAULT_MIN_WIDTH,
    height: DEFAULT_MIN_WIDTH
  };

  // get children bounds
  childrenBounds = (0,_ResizeUtil__WEBPACK_IMPORTED_MODULE_0__.computeChildrenBBox)(shape, context.childrenBoxPadding);

  // get correct minimum bounds from given resize direction
  // basically ensures that the minBounds is max(childrenBounds, minDimensions)
  return (0,_ResizeUtil__WEBPACK_IMPORTED_MODULE_0__.getMinResizeBounds)(direction, shape, minDimensions, childrenBounds);
};


Resize.$inject = [
  'eventBus',
  'rules',
  'modeling',
  'dragging'
];

// helpers //////////

function boundsChanged(shape, newBounds) {
  return shape.x !== newBounds.x ||
    shape.y !== newBounds.y ||
    shape.width !== newBounds.width ||
    shape.height !== newBounds.height;
}

function getReferencePoint(shape, direction) {
  var mid = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(shape),
      trbl = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(shape);

  var referencePoint = {
    x: mid.x,
    y: mid.y
  };

  if (direction.indexOf('n') !== -1) {
    referencePoint.y = trbl.top;
  } else if (direction.indexOf('s') !== -1) {
    referencePoint.y = trbl.bottom;
  }

  if (direction.indexOf('e') !== -1) {
    referencePoint.x = trbl.right;
  } else if (direction.indexOf('w') !== -1) {
    referencePoint.x = trbl.left;
  }

  return referencePoint;
}

function getCursor(direction) {
  var prefix = 'resize-';

  if (direction === 'n' || direction === 's') {
    return prefix + 'ns';
  } else if (direction === 'e' || direction === 'w') {
    return prefix + 'ew';
  } else if (direction === 'nw' || direction === 'se') {
    return prefix + 'nwse';
  } else {
    return prefix + 'nesw';
  }
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/resize/ResizeHandles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/resize/ResizeHandles.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResizeHandles)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var _Resize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Resize */ "./node_modules/diagram-js/lib/features/resize/Resize.js");












var HANDLE_OFFSET = -6,
    HANDLE_SIZE = 4,
    HANDLE_HIT_SIZE = 20;

var CLS_RESIZER = 'djs-resizer';

var directions = [ 'n', 'w', 's', 'e', 'nw', 'ne', 'se', 'sw' ];


/**
 * This component is responsible for adding resize handles.
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {Selection} selection
 * @param {Resize} resize
 */
function ResizeHandles(eventBus, canvas, selection, resize) {

  this._resize = resize;
  this._canvas = canvas;

  var self = this;

  eventBus.on('selection.changed', function(e) {
    var newSelection = e.newSelection;

    // remove old selection markers
    self.removeResizers();

    // add new selection markers ONLY if single selection
    if (newSelection.length === 1) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(newSelection, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(self.addResizer, self));
    }
  });

  eventBus.on('shape.changed', function(e) {
    var shape = e.element;

    if (selection.isSelected(shape)) {
      self.removeResizers();

      self.addResizer(shape);
    }
  });
}


ResizeHandles.prototype.makeDraggable = function(element, gfx, direction) {
  var resize = this._resize;

  function startResize(event) {

    // only trigger on left mouse button
    if ((0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.isPrimaryButton)(event)) {
      resize.activate(event, element, direction);
    }
  }

  min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(gfx, 'mousedown', startResize);
  min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(gfx, 'touchstart', startResize);
};


ResizeHandles.prototype._createResizer = function(element, x, y, direction) {
  var resizersParent = this._getResizersParent();

  var offset = getHandleOffset(direction);

  var group = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('g');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(group).add(CLS_RESIZER);
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(group).add(CLS_RESIZER + '-' + element.id);
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(group).add(CLS_RESIZER + '-' + direction);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(resizersParent, group);

  var visual = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('rect');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(visual, {
    x: -HANDLE_SIZE / 2 + offset.x,
    y: -HANDLE_SIZE / 2 + offset.y,
    width: HANDLE_SIZE,
    height: HANDLE_SIZE
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(visual).add(CLS_RESIZER + '-visual');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(group, visual);

  var hit = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('rect');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(hit, {
    x: -HANDLE_HIT_SIZE / 2 + offset.x,
    y: -HANDLE_HIT_SIZE / 2 + offset.y,
    width: HANDLE_HIT_SIZE,
    height: HANDLE_HIT_SIZE
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(hit).add(CLS_RESIZER + '-hit');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(group, hit);

  (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_4__.transform)(group, x, y);

  return group;
};

ResizeHandles.prototype.createResizer = function(element, direction) {
  var point = (0,_Resize__WEBPACK_IMPORTED_MODULE_5__.getReferencePoint)(element, direction);

  var resizer = this._createResizer(element, point.x, point.y, direction);

  this.makeDraggable(element, resizer, direction);
};

// resize handles implementation ///////////////////////////////

/**
 * Add resizers for a given element.
 *
 * @param {djs.model.Shape} shape
 */
ResizeHandles.prototype.addResizer = function(shape) {
  var self = this;

  var resize = this._resize;

  if (!resize.canResize({ shape: shape })) {
    return;
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(directions, function(direction) {
    self.createResizer(shape, direction);
  });
};

/**
 * Remove all resizers
 */
ResizeHandles.prototype.removeResizers = function() {
  var resizersParent = this._getResizersParent();

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.clear)(resizersParent);
};

ResizeHandles.prototype._getResizersParent = function() {
  return this._canvas.getLayer('resizers');
};

ResizeHandles.$inject = [
  'eventBus',
  'canvas',
  'selection',
  'resize'
];

// helpers //////////

function getHandleOffset(direction) {
  var offset = {
    x: 0,
    y: 0
  };

  if (direction.indexOf('e') !== -1) {
    offset.x = -HANDLE_OFFSET;
  } else if (direction.indexOf('w') !== -1) {
    offset.x = HANDLE_OFFSET;
  }

  if (direction.indexOf('s') !== -1) {
    offset.y = -HANDLE_OFFSET;
  } else if (direction.indexOf('n') !== -1) {
    offset.y = HANDLE_OFFSET;
  }

  return offset;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/resize/ResizePreview.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/resize/ResizePreview.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResizePreview)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
var MARKER_RESIZING = 'djs-resizing',
    MARKER_RESIZE_NOT_OK = 'resize-not-ok';

var LOW_PRIORITY = 500;




/**
 * Provides previews for resizing shapes when resizing.
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {PreviewSupport} previewSupport
 */
function ResizePreview(eventBus, canvas, previewSupport) {

  /**
   * Update resizer frame.
   *
   * @param {Object} context
   */
  function updateFrame(context) {

    var shape = context.shape,
        bounds = context.newBounds,
        frame = context.frame;

    if (!frame) {
      frame = context.frame = previewSupport.addFrame(shape, canvas.getDefaultLayer());

      canvas.addMarker(shape, MARKER_RESIZING);
    }

    if (bounds.width > 5) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(frame, { x: bounds.x, width: bounds.width });
    }

    if (bounds.height > 5) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(frame, { y: bounds.y, height: bounds.height });
    }

    if (context.canExecute) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.classes)(frame).remove(MARKER_RESIZE_NOT_OK);
    } else {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.classes)(frame).add(MARKER_RESIZE_NOT_OK);
    }
  }

  /**
   * Remove resizer frame.
   *
   * @param {Object} context
   */
  function removeFrame(context) {
    var shape = context.shape,
        frame = context.frame;

    if (frame) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.remove)(context.frame);
    }

    canvas.removeMarker(shape, MARKER_RESIZING);
  }

  // add and update previews
  eventBus.on('resize.move', LOW_PRIORITY, function(event) {
    updateFrame(event.context);
  });

  // remove previews
  eventBus.on('resize.cleanup', function(event) {
    removeFrame(event.context);
  });

}

ResizePreview.$inject = [
  'eventBus',
  'canvas',
  'previewSupport'
];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/resize/ResizeUtil.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/resize/ResizeUtil.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "substractTRBL": () => (/* binding */ substractTRBL),
/* harmony export */   "resizeBounds": () => (/* binding */ resizeBounds),
/* harmony export */   "resizeTRBL": () => (/* binding */ resizeTRBL),
/* harmony export */   "reattachPoint": () => (/* binding */ reattachPoint),
/* harmony export */   "ensureConstraints": () => (/* binding */ ensureConstraints),
/* harmony export */   "getMinResizeBounds": () => (/* binding */ getMinResizeBounds),
/* harmony export */   "addPadding": () => (/* binding */ addPadding),
/* harmony export */   "computeChildrenBBox": () => (/* binding */ computeChildrenBBox)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");


var max = Math.max,
    min = Math.min;

var DEFAULT_CHILD_BOX_PADDING = 20;






/**
 * Substract a TRBL from another
 *
 * @param  {TRBL} trblA
 * @param  {TRBL} trblB
 *
 * @return {TRBL}
 */
function substractTRBL(trblA, trblB) {
  return {
    top: trblA.top - trblB.top,
    right: trblA.right - trblB.right,
    bottom: trblA.bottom - trblB.bottom,
    left: trblA.left - trblB.left
  };
}

/**
 * Resize the given bounds by the specified delta from a given anchor point.
 *
 * @param {Bounds} bounds the bounding box that should be resized
 * @param {string} direction in which the element is resized (nw, ne, se, sw)
 * @param {Point} delta of the resize operation
 *
 * @return {Bounds} resized bounding box
 */
function resizeBounds(bounds, direction, delta) {
  var dx = delta.x,
      dy = delta.y;

  var newBounds = {
    x: bounds.x,
    y: bounds.y,
    width: bounds.width,
    height: bounds.height
  };

  if (direction.indexOf('n') !== -1) {
    newBounds.y = bounds.y + dy;
    newBounds.height = bounds.height - dy;
  } else if (direction.indexOf('s') !== -1) {
    newBounds.height = bounds.height + dy;
  }

  if (direction.indexOf('e') !== -1) {
    newBounds.width = bounds.width + dx;
  } else if (direction.indexOf('w') !== -1) {
    newBounds.x = bounds.x + dx;
    newBounds.width = bounds.width - dx;
  }

  return newBounds;
}


/**
 * Resize the given bounds by applying the passed
 * { top, right, bottom, left } delta.
 *
 * @param {Bounds} bounds
 * @param {TRBL} trblResize
 *
 * @return {Bounds}
 */
function resizeTRBL(bounds, resize) {
  return {
    x: bounds.x + (resize.left || 0),
    y: bounds.y + (resize.top || 0),
    width: bounds.width - (resize.left || 0) + (resize.right || 0),
    height: bounds.height - (resize.top || 0) + (resize.bottom || 0)
  };
}


function reattachPoint(bounds, newBounds, point) {

  var sx = bounds.width / newBounds.width,
      sy = bounds.height / newBounds.height;

  return {
    x: Math.round((newBounds.x + newBounds.width / 2)) - Math.floor(((bounds.x + bounds.width / 2) - point.x) / sx),
    y: Math.round((newBounds.y + newBounds.height / 2)) - Math.floor(((bounds.y + bounds.height / 2) - point.y) / sy)
  };
}


function applyConstraints(attr, trbl, resizeConstraints) {

  var value = trbl[attr],
      minValue = resizeConstraints.min && resizeConstraints.min[attr],
      maxValue = resizeConstraints.max && resizeConstraints.max[attr];

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(minValue)) {
    value = (/top|left/.test(attr) ? min : max)(value, minValue);
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(maxValue)) {
    value = (/top|left/.test(attr) ? max : min)(value, maxValue);
  }

  return value;
}

function ensureConstraints(currentBounds, resizeConstraints) {

  if (!resizeConstraints) {
    return currentBounds;
  }

  var currentTrbl = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(currentBounds);

  return (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asBounds)({
    top: applyConstraints('top', currentTrbl, resizeConstraints),
    right: applyConstraints('right', currentTrbl, resizeConstraints),
    bottom: applyConstraints('bottom', currentTrbl, resizeConstraints),
    left: applyConstraints('left', currentTrbl, resizeConstraints)
  });
}


function getMinResizeBounds(direction, currentBounds, minDimensions, childrenBounds) {

  var currentBox = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(currentBounds);

  var minBox = {
    top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,
    left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,
    bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,
    right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right
  };

  var childrenBox = childrenBounds ? (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(childrenBounds) : minBox;

  var combinedBox = {
    top: min(minBox.top, childrenBox.top),
    left: min(minBox.left, childrenBox.left),
    bottom: max(minBox.bottom, childrenBox.bottom),
    right: max(minBox.right, childrenBox.right)
  };

  return (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asBounds)(combinedBox);
}

function asPadding(mayBePadding, defaultValue) {
  if (typeof mayBePadding !== 'undefined') {
    return mayBePadding;
  } else {
    return DEFAULT_CHILD_BOX_PADDING;
  }
}

function addPadding(bbox, padding) {
  var left, right, top, bottom;

  if (typeof padding === 'object') {
    left = asPadding(padding.left);
    right = asPadding(padding.right);
    top = asPadding(padding.top);
    bottom = asPadding(padding.bottom);
  } else {
    left = right = top = bottom = asPadding(padding);
  }

  return {
    x: bbox.x - left,
    y: bbox.y - top,
    width: bbox.width + left + right,
    height: bbox.height + top + bottom
  };
}


/**
 * Is the given element part of the resize
 * targets min boundary box?
 *
 * This is the default implementation which excludes
 * connections and labels.
 *
 * @param {djs.model.Base} element
 */
function isBBoxChild(element) {

  // exclude connections
  if (element.waypoints) {
    return false;
  }

  // exclude labels
  if (element.type === 'label') {
    return false;
  }

  return true;
}

/**
 * Return children bounding computed from a shapes children
 * or a list of prefiltered children.
 *
 * @param  {djs.model.Shape|Array<djs.model.Shape>} shapeOrChildren
 * @param  {number|Object} padding
 *
 * @return {Bounds}
 */
function computeChildrenBBox(shapeOrChildren, padding) {

  var elements;

  // compute based on shape
  if (shapeOrChildren.length === undefined) {

    // grab all the children that are part of the
    // parents children box
    elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.filter)(shapeOrChildren.children, isBBoxChild);

  } else {
    elements = shapeOrChildren;
  }

  if (elements.length) {
    return addPadding((0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getBBox)(elements), padding);
  }
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/resize/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/resize/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _preview_support__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../preview-support */ "./node_modules/diagram-js/lib/features/preview-support/index.js");
/* harmony import */ var _Resize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Resize */ "./node_modules/diagram-js/lib/features/resize/Resize.js");
/* harmony import */ var _ResizePreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ResizePreview */ "./node_modules/diagram-js/lib/features/resize/ResizePreview.js");
/* harmony import */ var _ResizeHandles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ResizeHandles */ "./node_modules/diagram-js/lib/features/resize/ResizeHandles.js");








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _rules__WEBPACK_IMPORTED_MODULE_0__.default,
    _dragging__WEBPACK_IMPORTED_MODULE_1__.default,
    _preview_support__WEBPACK_IMPORTED_MODULE_2__.default
  ],
  __init__: [
    'resize',
    'resizePreview',
    'resizeHandles'
  ],
  resize: [ 'type', _Resize__WEBPACK_IMPORTED_MODULE_3__.default ],
  resizePreview: [ 'type', _ResizePreview__WEBPACK_IMPORTED_MODULE_4__.default ],
  resizeHandles: [ 'type', _ResizeHandles__WEBPACK_IMPORTED_MODULE_5__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/rules/RuleProvider.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/rules/RuleProvider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RuleProvider)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");




/**
 * A basic provider that may be extended to implement modeling rules.
 *
 * Extensions should implement the init method to actually add their custom
 * modeling checks. Checks may be added via the #addRule(action, fn) method.
 *
 * @param {EventBus} eventBus
 */
function RuleProvider(eventBus) {
  _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  this.init();
}

RuleProvider.$inject = [ 'eventBus' ];

inherits__WEBPACK_IMPORTED_MODULE_0___default()(RuleProvider, _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);


/**
 * Adds a modeling rule for the given action, implemented through
 * a callback function.
 *
 * The function will receive the modeling specific action context
 * to perform its check. It must return `false` to disallow the
 * action from happening or `true` to allow the action.
 *
 * A rule provider may pass over the evaluation to lower priority
 * rules by returning return nothing (or <code>undefined</code>).
 *
 * @example
 *
 * ResizableRules.prototype.init = function() {
 *
 *   \/**
 *    * Return `true`, `false` or nothing to denote
 *    * _allowed_, _not allowed_ and _continue evaluating_.
 *    *\/
 *   this.addRule('shape.resize', function(context) {
 *
 *     var shape = context.shape;
 *
 *     if (!context.newBounds) {
 *       // check general resizability
 *       if (!shape.resizable) {
 *         return false;
 *       }
 *
 *       // not returning anything (read: undefined)
 *       // will continue the evaluation of other rules
 *       // (with lower priority)
 *       return;
 *     } else {
 *       // element must have minimum size of 10*10 points
 *       return context.newBounds.width > 10 && context.newBounds.height > 10;
 *     }
 *   });
 * };
 *
 * @param {string|Array<string>} actions the identifier for the modeling action to check
 * @param {number} [priority] the priority at which this rule is being applied
 * @param {Function} fn the callback function that performs the actual check
 */
RuleProvider.prototype.addRule = function(actions, priority, fn) {

  var self = this;

  if (typeof actions === 'string') {
    actions = [ actions ];
  }

  actions.forEach(function(action) {

    self.canExecute(action, priority, function(context, action, event) {
      return fn(context);
    }, true);
  });
};

/**
 * Implement this method to add new rules during provider initialization.
 */
RuleProvider.prototype.init = function() {};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/rules/Rules.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/rules/Rules.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Rules)
/* harmony export */ });
/**
 * A service that provides rules for certain diagram actions.
 *
 * The default implementation will hook into the {@link CommandStack}
 * to perform the actual rule evaluation. Make sure to provide the
 * `commandStack` service with this module if you plan to use it.
 *
 * Together with this implementation you may use the {@link RuleProvider}
 * to implement your own rule checkers.
 *
 * This module is ment to be easily replaced, thus the tiny foot print.
 *
 * @param {Injector} injector
 */
function Rules(injector) {
  this._commandStack = injector.get('commandStack', false);
}

Rules.$inject = [ 'injector' ];


/**
 * Returns whether or not a given modeling action can be executed
 * in the specified context.
 *
 * This implementation will respond with allow unless anyone
 * objects.
 *
 * @param {string} action the action to be checked
 * @param {Object} [context] the context to check the action in
 *
 * @return {boolean} returns true, false or null depending on whether the
 *                   operation is allowed, not allowed or should be ignored.
 */
Rules.prototype.allowed = function(action, context) {
  var allowed = true;

  var commandStack = this._commandStack;

  if (commandStack) {
    allowed = commandStack.canExecute(action, context);
  }

  // map undefined to true, i.e. no rules
  return allowed === undefined ? true : allowed;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/rules/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/rules/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Rules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rules */ "./node_modules/diagram-js/lib/features/rules/Rules.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'rules' ],
  rules: [ 'type', _Rules__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/Selection.js":
/*!*********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/Selection.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Selection)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A service that offers the current selection in a diagram.
 * Offers the api to control the selection, too.
 *
 * @class
 *
 * @param {EventBus} eventBus the event bus
 */
function Selection(eventBus) {

  this._eventBus = eventBus;

  this._selectedElements = [];

  var self = this;

  eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {
    var element = e.element;
    self.deselect(element);
  });

  eventBus.on([ 'diagram.clear' ], function(e) {
    self.select(null);
  });
}

Selection.$inject = [ 'eventBus' ];


Selection.prototype.deselect = function(element) {
  var selectedElements = this._selectedElements;

  var idx = selectedElements.indexOf(element);

  if (idx !== -1) {
    var oldSelection = selectedElements.slice();

    selectedElements.splice(idx, 1);

    this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });
  }
};


Selection.prototype.get = function() {
  return this._selectedElements;
};

Selection.prototype.isSelected = function(element) {
  return this._selectedElements.indexOf(element) !== -1;
};


/**
 * This method selects one or more elements on the diagram.
 *
 * By passing an additional add parameter you can decide whether or not the element(s)
 * should be added to the already existing selection or not.
 *
 * @method Selection#select
 *
 * @param  {Object|Object[]} elements element or array of elements to be selected
 * @param  {boolean} [add] whether the element(s) should be appended to the current selection, defaults to false
 */
Selection.prototype.select = function(elements, add) {
  var selectedElements = this._selectedElements,
      oldSelection = selectedElements.slice();

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements)) {
    elements = elements ? [ elements ] : [];
  }

  // selection may be cleared by passing an empty array or null
  // to the method
  if (add) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
      if (selectedElements.indexOf(element) !== -1) {

        // already selected
        return;
      } else {
        selectedElements.push(element);
      }
    });
  } else {
    this._selectedElements = selectedElements = elements.slice();
  }

  this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/SelectionBehavior.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/SelectionBehavior.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectionBehavior)
/* harmony export */ });
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");





function SelectionBehavior(eventBus, selection, canvas, elementRegistry) {

  // Select elements on create
  eventBus.on('create.end', 500, function(event) {
    var context = event.context,
        canExecute = context.canExecute,
        elements = context.elements,
        hints = context.hints || {},
        autoSelect = hints.autoSelect;

    if (canExecute) {
      if (autoSelect === false) {

        // Select no elements
        return;
      }

      if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(autoSelect)) {
        selection.select(autoSelect);
      } else {

        // Select all elements by default
        selection.select(elements.filter(isShown));
      }
    }
  });

  // Select connection targets on connect
  eventBus.on('connect.end', 500, function(event) {
    var context = event.context,
        canExecute = context.canExecute,
        hover = context.hover;

    if (canExecute && hover) {
      selection.select(hover);
    }
  });

  // Select shapes on move
  eventBus.on('shape.move.end', 500, function(event) {
    var previousSelection = event.previousSelection || [];

    var shape = elementRegistry.get(event.context.shape.id);

    // Always select main shape on move
    var isSelected = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(previousSelection, function(selectedShape) {
      return shape.id === selectedShape.id;
    });

    if (!isSelected) {
      selection.select(shape);
    }
  });

  // Select elements on click
  eventBus.on('element.click', function(event) {

    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.isPrimaryButton)(event)) {
      return;
    }

    var element = event.element;

    if (element === canvas.getRootElement()) {
      element = null;
    }

    var isSelected = selection.isSelected(element),
        isMultiSelect = selection.get().length > 1;

    // Add to selection if CTRL or SHIFT pressed
    var add = (0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.hasPrimaryModifier)(event) || (0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.hasSecondaryModifier)(event);

    if (isSelected && isMultiSelect) {
      if (add) {

        // Deselect element
        return selection.deselect(element);
      } else {

        // Select element only
        return selection.select(element);
      }
    } else if (!isSelected) {

      // Select element
      selection.select(element, add);
    } else {

      // Deselect element
      selection.deselect(element);
    }
  });
}

SelectionBehavior.$inject = [
  'eventBus',
  'selection',
  'canvas',
  'elementRegistry'
];


function isShown(element) {
  return !element.hidden;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/SelectionVisuals.js":
/*!****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/SelectionVisuals.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectionVisuals)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var MARKER_HOVER = 'hover',
    MARKER_SELECTED = 'selected';


/**
 * A plugin that adds a visible selection UI to shapes and connections
 * by appending the <code>hover</code> and <code>selected</code> classes to them.
 *
 * @class
 *
 * Makes elements selectable, too.
 *
 * @param {EventBus} events
 * @param {SelectionService} selection
 * @param {Canvas} canvas
 */
function SelectionVisuals(events, canvas, selection, styles) {

  this._multiSelectionBox = null;

  function addMarker(e, cls) {
    canvas.addMarker(e, cls);
  }

  function removeMarker(e, cls) {
    canvas.removeMarker(e, cls);
  }

  events.on('element.hover', function(event) {
    addMarker(event.element, MARKER_HOVER);
  });

  events.on('element.out', function(event) {
    removeMarker(event.element, MARKER_HOVER);
  });

  events.on('selection.changed', function(event) {

    function deselect(s) {
      removeMarker(s, MARKER_SELECTED);
    }

    function select(s) {
      addMarker(s, MARKER_SELECTED);
    }

    var oldSelection = event.oldSelection,
        newSelection = event.newSelection;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(oldSelection, function(e) {
      if (newSelection.indexOf(e) === -1) {
        deselect(e);
      }
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(newSelection, function(e) {
      if (oldSelection.indexOf(e) === -1) {
        select(e);
      }
    });
  });
}

SelectionVisuals.$inject = [
  'eventBus',
  'canvas',
  'selection',
  'styles'
];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interaction_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interaction-events */ "./node_modules/diagram-js/lib/features/interaction-events/index.js");
/* harmony import */ var _outline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../outline */ "./node_modules/diagram-js/lib/features/outline/index.js");
/* harmony import */ var _Selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Selection */ "./node_modules/diagram-js/lib/features/selection/Selection.js");
/* harmony import */ var _SelectionVisuals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SelectionVisuals */ "./node_modules/diagram-js/lib/features/selection/SelectionVisuals.js");
/* harmony import */ var _SelectionBehavior__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SelectionBehavior */ "./node_modules/diagram-js/lib/features/selection/SelectionBehavior.js");








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'selectionVisuals', 'selectionBehavior' ],
  __depends__: [
    _interaction_events__WEBPACK_IMPORTED_MODULE_0__.default,
    _outline__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  selection: [ 'type', _Selection__WEBPACK_IMPORTED_MODULE_2__.default ],
  selectionVisuals: [ 'type', _SelectionVisuals__WEBPACK_IMPORTED_MODULE_3__.default ],
  selectionBehavior: [ 'type', _SelectionBehavior__WEBPACK_IMPORTED_MODULE_4__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/CreateMoveSnapping.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/CreateMoveSnapping.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateMoveSnapping)
/* harmony export */ });
/* harmony import */ var _SnapContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SnapContext */ "./node_modules/diagram-js/lib/features/snapping/SnapContext.js");
/* harmony import */ var _SnapUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SnapUtil */ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js");
/* harmony import */ var _keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../keyboard/KeyboardUtil */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");








var HIGHER_PRIORITY = 1250;


/**
 * Snap during create and move.
 *
 * @param {EventBus} elementRegistry
 * @param {EventBus} eventBus
 * @param {Snapping} snapping
 */
function CreateMoveSnapping(elementRegistry, eventBus, snapping) {
  var self = this;

  this._elementRegistry = elementRegistry;

  eventBus.on([
    'create.start',
    'shape.move.start'
  ], function(event) {
    self.initSnap(event);
  });

  eventBus.on([
    'create.move',
    'create.end',
    'shape.move.move',
    'shape.move.end'
  ], HIGHER_PRIORITY, function(event) {
    var context = event.context,
        shape = context.shape,
        snapContext = context.snapContext,
        target = context.target;

    if (event.originalEvent && (0,_keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event.originalEvent)) {
      return;
    }

    if ((0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.isSnapped)(event) || !target) {
      return;
    }

    var snapPoints = snapContext.pointsForTarget(target);

    if (!snapPoints.initialized) {
      snapPoints = self.addSnapTargetPoints(snapPoints, shape, target);

      snapPoints.initialized = true;
    }

    snapping.snap(event, snapPoints);
  });

  eventBus.on([
    'create.cleanup',
    'shape.move.cleanup'
  ], function() {
    snapping.hide();
  });
}

CreateMoveSnapping.$inject = [
  'elementRegistry',
  'eventBus',
  'snapping'
];

CreateMoveSnapping.prototype.initSnap = function(event) {
  var elementRegistry = this._elementRegistry;

  var context = event.context,
      shape = context.shape,
      snapContext = context.snapContext;

  if (!snapContext) {
    snapContext = context.snapContext = new _SnapContext__WEBPACK_IMPORTED_MODULE_2__.default();
  }

  var shapeMid;

  if (elementRegistry.get(shape.id)) {

    // move
    shapeMid = (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(shape, event);
  } else {

    // create
    shapeMid = {
      x: event.x + (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(shape).x,
      y: event.y + (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(shape).y
    };
  }

  var shapeTopLeft = {
        x: shapeMid.x - shape.width / 2,
        y: shapeMid.y - shape.height / 2
      },
      shapeBottomRight = {
        x: shapeMid.x + shape.width / 2,
        y: shapeMid.y + shape.height / 2
      };

  snapContext.setSnapOrigin('mid', {
    x: shapeMid.x - event.x,
    y: shapeMid.y - event.y
  });

  // snap labels to mid only
  if (isLabel(shape)) {
    return snapContext;
  }

  snapContext.setSnapOrigin('top-left', {
    x: shapeTopLeft.x - event.x,
    y: shapeTopLeft.y - event.y
  });

  snapContext.setSnapOrigin('bottom-right', {
    x: shapeBottomRight.x - event.x,
    y: shapeBottomRight.y - event.y
  });

  return snapContext;
};

CreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  var snapTargets = this.getSnapTargets(shape, target);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(snapTargets, function(snapTarget) {

    // handle labels
    if (isLabel(snapTarget)) {

      if (isLabel(shape)) {
        snapPoints.add('mid', (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(snapTarget));
      }

      return;
    }

    // handle connections
    if (isConnection(snapTarget)) {

      // ignore single segment connections
      if (snapTarget.waypoints.length < 3) {
        return;
      }

      // ignore first and last waypoint
      var waypoints = snapTarget.waypoints.slice(1, -1);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(waypoints, function(waypoint) {
        snapPoints.add('mid', waypoint);
      });

      return;
    }

    // handle shapes
    snapPoints.add('mid', (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(snapTarget));
  });

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(shape.x) || !(0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(shape.y)) {
    return snapPoints;
  }

  // snap to original position when moving
  if (this._elementRegistry.get(shape.id)) {
    snapPoints.add('mid', (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(shape));
  }

  return snapPoints;
};

CreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.getChildren)(target).filter(function(child) {
    return !isHidden(child);
  });
};

// helpers //////////

function isConnection(element) {
  return !!element.waypoints;
}

function isHidden(element) {
  return !!element.hidden;
}

function isLabel(element) {
  return !!element.labelTarget;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/ResizeSnapping.js":
/*!*************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/ResizeSnapping.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResizeSnapping)
/* harmony export */ });
/* harmony import */ var _SnapContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SnapContext */ "./node_modules/diagram-js/lib/features/snapping/SnapContext.js");
/* harmony import */ var _SnapUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SnapUtil */ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js");
/* harmony import */ var _keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../keyboard/KeyboardUtil */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");










var HIGHER_PRIORITY = 1250;


/**
 * Snap during resize.
 *
 * @param {EventBus} eventBus
 * @param {Snapping} snapping
 */
function ResizeSnapping(eventBus, snapping) {
  var self = this;

  eventBus.on([ 'resize.start' ], function(event) {
    self.initSnap(event);
  });

  eventBus.on([
    'resize.move',
    'resize.end',
  ], HIGHER_PRIORITY, function(event) {
    var context = event.context,
        shape = context.shape,
        parent = shape.parent,
        direction = context.direction,
        snapContext = context.snapContext;

    if (event.originalEvent && (0,_keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event.originalEvent)) {
      return;
    }

    if ((0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.isSnapped)(event)) {
      return;
    }

    var snapPoints = snapContext.pointsForTarget(parent);

    if (!snapPoints.initialized) {
      snapPoints = self.addSnapTargetPoints(snapPoints, shape, parent, direction);

      snapPoints.initialized = true;
    }

    if (isHorizontal(direction)) {
      (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'x', event.x);
    }

    if (isVertical(direction)) {
      (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'y', event.y);
    }

    snapping.snap(event, snapPoints);
  });

  eventBus.on([ 'resize.cleanup' ], function() {
    snapping.hide();
  });
}

ResizeSnapping.prototype.initSnap = function(event) {
  var context = event.context,
      shape = context.shape,
      direction = context.direction,
      snapContext = context.snapContext;

  if (!snapContext) {
    snapContext = context.snapContext = new _SnapContext__WEBPACK_IMPORTED_MODULE_2__.default();
  }

  var snapOrigin = getSnapOrigin(shape, direction);

  snapContext.setSnapOrigin('corner', {
    x: snapOrigin.x - event.x,
    y: snapOrigin.y - event.y
  });

  return snapContext;
};

ResizeSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target, direction) {
  var snapTargets = this.getSnapTargets(shape, target);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(snapTargets, function(snapTarget) {
    snapPoints.add('corner', (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.bottomRight)(snapTarget));
    snapPoints.add('corner', (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.topLeft)(snapTarget));
  });

  snapPoints.add('corner', getSnapOrigin(shape, direction));

  return snapPoints;
};

ResizeSnapping.$inject = [
  'eventBus',
  'snapping'
];

ResizeSnapping.prototype.getSnapTargets = function(shape, target) {
  return (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.getChildren)(target).filter(function(child) {
    return !isAttached(child, shape)
      && !isConnection(child)
      && !isHidden(child)
      && !isLabel(child);
  });
};

// helpers //////////

function getSnapOrigin(shape, direction) {
  var mid = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_4__.getMid)(shape),
      trbl = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_4__.asTRBL)(shape);

  var snapOrigin = {
    x: mid.x,
    y: mid.y
  };

  if (direction.indexOf('n') !== -1) {
    snapOrigin.y = trbl.top;
  } else if (direction.indexOf('s') !== -1) {
    snapOrigin.y = trbl.bottom;
  }

  if (direction.indexOf('e') !== -1) {
    snapOrigin.x = trbl.right;
  } else if (direction.indexOf('w') !== -1) {
    snapOrigin.x = trbl.left;
  }

  return snapOrigin;
}

function isAttached(element, host) {
  return element.host === host;
}

function isConnection(element) {
  return !!element.waypoints;
}

function isHidden(element) {
  return !!element.hidden;
}

function isLabel(element) {
  return !!element.labelTarget;
}

function isHorizontal(direction) {
  return direction === 'n' || direction === 's';
}

function isVertical(direction) {
  return direction === 'e' || direction === 'w';
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/SnapContext.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/SnapContext.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SnapContext),
/* harmony export */   "SnapPoints": () => (/* binding */ SnapPoints)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _SnapUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SnapUtil */ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js");





/**
 * A snap context, containing the (possibly incomplete)
 * mappings of drop targets (to identify the snapping)
 * to computed snap points.
 */
function SnapContext() {

  /**
   * Map<String, SnapPoints> mapping drop targets to
   * a list of possible snappings.
   *
   * @type {Object}
   */
  this._targets = {};

  /**
   * Map<String, Point> initial positioning of element
   * regarding various snap directions.
   *
   * @type {Object}
   */
  this._snapOrigins = {};

  /**
   * List of snap locations
   *
   * @type {Array<string>}
   */
  this._snapLocations = [];

  /**
   * Map<String, Array<Point>> of default snapping locations
   *
   * @type {Object}
   */
  this._defaultSnaps = {};
}


SnapContext.prototype.getSnapOrigin = function(snapLocation) {
  return this._snapOrigins[snapLocation];
};


SnapContext.prototype.setSnapOrigin = function(snapLocation, initialValue) {
  this._snapOrigins[snapLocation] = initialValue;

  if (this._snapLocations.indexOf(snapLocation) === -1) {
    this._snapLocations.push(snapLocation);
  }
};


SnapContext.prototype.addDefaultSnap = function(type, point) {

  var snapValues = this._defaultSnaps[type];

  if (!snapValues) {
    snapValues = this._defaultSnaps[type] = [];
  }

  snapValues.push(point);
};

/**
 * Return a number of initialized snaps, i.e. snap locations such as
 * top-left, mid, bottom-right and so forth.
 *
 * @return {Array<string>} snapLocations
 */
SnapContext.prototype.getSnapLocations = function() {
  return this._snapLocations;
};

/**
 * Set the snap locations for this context.
 *
 * The order of locations determines precedence.
 *
 * @param {Array<string>} snapLocations
 */
SnapContext.prototype.setSnapLocations = function(snapLocations) {
  this._snapLocations = snapLocations;
};

/**
 * Get snap points for a given target
 *
 * @param {Element|string} target
 */
SnapContext.prototype.pointsForTarget = function(target) {

  var targetId = target.id || target;

  var snapPoints = this._targets[targetId];

  if (!snapPoints) {
    snapPoints = this._targets[targetId] = new SnapPoints();
    snapPoints.initDefaults(this._defaultSnaps);
  }

  return snapPoints;
};


/**
 * Creates the snap points and initializes them with the
 * given default values.
 *
 * @param {Object<string, Array<Point>>} [defaultPoints]
 */
function SnapPoints(defaultSnaps) {

  /**
   * Map<String, Map<(x|y), Array<number>>> mapping snap locations,
   * i.e. top-left, bottom-right, center to actual snap values.
   *
   * @type {Object}
   */
  this._snapValues = {};
}

SnapPoints.prototype.add = function(snapLocation, point) {

  var snapValues = this._snapValues[snapLocation];

  if (!snapValues) {
    snapValues = this._snapValues[snapLocation] = { x: [], y: [] };
  }

  if (snapValues.x.indexOf(point.x) === -1) {
    snapValues.x.push(point.x);
  }

  if (snapValues.y.indexOf(point.y) === -1) {
    snapValues.y.push(point.y);
  }
};


SnapPoints.prototype.snap = function(point, snapLocation, axis, tolerance) {
  var snappingValues = this._snapValues[snapLocation];

  return snappingValues && (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_0__.snapTo)(point[axis], snappingValues[axis], tolerance);
};

/**
 * Initialize a number of default snapping points.
 *
 * @param  {Object} defaultSnaps
 */
SnapPoints.prototype.initDefaults = function(defaultSnaps) {

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(defaultSnaps || {}, function(snapPoints, snapLocation) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(snapPoints, function(point) {
      self.add(snapLocation, point);
    });
  });
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/SnapUtil.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "snapTo": () => (/* binding */ snapTo),
/* harmony export */   "topLeft": () => (/* binding */ topLeft),
/* harmony export */   "topRight": () => (/* binding */ topRight),
/* harmony export */   "bottomLeft": () => (/* binding */ bottomLeft),
/* harmony export */   "bottomRight": () => (/* binding */ bottomRight),
/* harmony export */   "mid": () => (/* binding */ mid),
/* harmony export */   "isSnapped": () => (/* binding */ isSnapped),
/* harmony export */   "setSnapped": () => (/* binding */ setSnapped),
/* harmony export */   "getChildren": () => (/* binding */ getChildren)
/* harmony export */ });
var abs = Math.abs,
    round = Math.round;


/**
 * Snap value to a collection of reference values.
 *
 * @param  {number} value
 * @param  {Array<number>} values
 * @param  {number} [tolerance=10]
 *
 * @return {number} the value we snapped to or null, if none snapped
 */
function snapTo(value, values, tolerance) {
  tolerance = tolerance === undefined ? 10 : tolerance;

  var idx, snapValue;

  for (idx = 0; idx < values.length; idx++) {
    snapValue = values[idx];

    if (abs(snapValue - value) <= tolerance) {
      return snapValue;
    }
  }
}


function topLeft(bounds) {
  return {
    x: bounds.x,
    y: bounds.y
  };
}

function topRight(bounds) {
  return {
    x: bounds.x + bounds.width,
    y: bounds.y
  };
}

function bottomLeft(bounds) {
  return {
    x: bounds.x,
    y: bounds.y + bounds.height
  };
}

function bottomRight(bounds) {
  return {
    x: bounds.x + bounds.width,
    y: bounds.y + bounds.height
  };
}

function mid(bounds, defaultValue) {

  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {
    return defaultValue;
  }

  return {
    x: round(bounds.x + bounds.width / 2),
    y: round(bounds.y + bounds.height / 2)
  };
}


/**
 * Retrieve the snap state of the given event.
 *
 * @param  {Event} event
 * @param  {string} axis
 *
 * @return {boolean} the snapped state
 *
 */
function isSnapped(event, axis) {
  var snapped = event.snapped;

  if (!snapped) {
    return false;
  }

  if (typeof axis === 'string') {
    return snapped[axis];
  }

  return snapped.x && snapped.y;
}


/**
 * Set the given event as snapped.
 *
 * This method may change the x and/or y position of the shape
 * from the given event!
 *
 * @param {Event} event
 * @param {string} axis
 * @param {number|boolean} value
 *
 * @return {number} old value
 */
function setSnapped(event, axis, value) {
  if (typeof axis !== 'string') {
    throw new Error('axis must be in [x, y]');
  }

  if (typeof value !== 'number' && value !== false) {
    throw new Error('value must be Number or false');
  }

  var delta,
      previousValue = event[axis];

  var snapped = event.snapped = (event.snapped || {});


  if (value === false) {
    snapped[axis] = false;
  } else {
    snapped[axis] = true;

    delta = value - previousValue;

    event[axis] += delta;
    event['d' + axis] += delta;
  }

  return previousValue;
}

/**
 * Get children of a shape.
 *
 * @param {djs.model.Shape} parent
 *
 * @returns {Array<djs.model.Shape|djs.model.Connection>}
 */
function getChildren(parent) {
  return parent.children || [];
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/Snapping.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/Snapping.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SNAP_LINE_HIDE_DELAY": () => (/* binding */ SNAP_LINE_HIDE_DELAY),
/* harmony export */   "default": () => (/* binding */ Snapping)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _SnapUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SnapUtil */ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");






var SNAP_TOLERANCE = 7;

var SNAP_LINE_HIDE_DELAY = 1000;


/**
 * Generic snapping feature.
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function Snapping(canvas) {
  this._canvas = canvas;

  // delay hide by 1000 seconds since last snap
  this._asyncHide = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.debounce)((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(this.hide, this), SNAP_LINE_HIDE_DELAY);
}

Snapping.$inject = [ 'canvas' ];

/**
 * Snap an event to given snap points.
 *
 * @param {Event} event
 * @param {SnapPoints} snapPoints
 */
Snapping.prototype.snap = function(event, snapPoints) {
  var context = event.context,
      snapContext = context.snapContext,
      snapLocations = snapContext.getSnapLocations();

  var snapping = {
    x: (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.isSnapped)(event, 'x'),
    y: (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.isSnapped)(event, 'y')
  };

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(snapLocations, function(location) {
    var snapOrigin = snapContext.getSnapOrigin(location);

    var snapCurrent = {
      x: event.x + snapOrigin.x,
      y: event.y + snapOrigin.y
    };

    // snap both axis if not snapped already
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)([ 'x', 'y' ], function(axis) {
      var locationSnapping;

      if (!snapping[axis]) {
        locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);

        if (locationSnapping !== undefined) {
          snapping[axis] = {
            value: locationSnapping,
            originValue: locationSnapping - snapOrigin[axis]
          };
        }
      }
    });

    // no need to continue snapping
    if (snapping.x && snapping.y) {
      return false;
    }
  });

  // show snap lines
  this.showSnapLine('vertical', snapping.x && snapping.x.value);
  this.showSnapLine('horizontal', snapping.y && snapping.y.value);

  // snap event
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)([ 'x', 'y' ], function(axis) {
    var axisSnapping = snapping[axis];

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(axisSnapping)) {
      (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, axis, axisSnapping.originValue);
    }
  });
};

Snapping.prototype._createLine = function(orientation) {
  var root = this._canvas.getLayer('snap');

  var line = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('path');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(line, { d: 'M0,0 L0,0' });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(line).add('djs-snap-line');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(root, line);

  return {
    update: function(position) {

      if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(position)) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(line, { display: 'none' });
      } else {
        if (orientation === 'horizontal') {
          (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(line, {
            d: 'M-100000,' + position + ' L+100000,' + position,
            display: ''
          });
        } else {
          (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(line, {
            d: 'M ' + position + ',-100000 L ' + position + ', +100000',
            display: ''
          });
        }
      }
    }
  };
};

Snapping.prototype._createSnapLines = function() {
  this._snapLines = {
    horizontal: this._createLine('horizontal'),
    vertical: this._createLine('vertical')
  };
};

Snapping.prototype.showSnapLine = function(orientation, position) {

  var line = this.getSnapLine(orientation);

  if (line) {
    line.update(position);
  }

  this._asyncHide();
};

Snapping.prototype.getSnapLine = function(orientation) {
  if (!this._snapLines) {
    this._createSnapLines();
  }

  return this._snapLines[orientation];
};

Snapping.prototype.hide = function() {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(this._snapLines, function(snapLine) {
    snapLine.update();
  });
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreateMoveSnapping */ "./node_modules/diagram-js/lib/features/snapping/CreateMoveSnapping.js");
/* harmony import */ var _ResizeSnapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResizeSnapping */ "./node_modules/diagram-js/lib/features/snapping/ResizeSnapping.js");
/* harmony import */ var _Snapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Snapping */ "./node_modules/diagram-js/lib/features/snapping/Snapping.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [
    'createMoveSnapping',
    'resizeSnapping',
    'snapping'
  ],
  createMoveSnapping: [ 'type', _CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_0__.default ],
  resizeSnapping: [ 'type', _ResizeSnapping__WEBPACK_IMPORTED_MODULE_1__.default ],
  snapping: [ 'type', _Snapping__WEBPACK_IMPORTED_MODULE_2__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/space-tool/SpaceTool.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/space-tool/SpaceTool.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpaceTool)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var _SpaceUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SpaceUtil */ "./node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var _util_Cursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Cursor */ "./node_modules/diagram-js/lib/util/Cursor.js");














var abs = Math.abs,
    round = Math.round;

var AXIS_TO_DIMENSION = {
  x: 'width',
  y: 'height'
};

var CURSOR_CROSSHAIR = 'crosshair';

var DIRECTION_TO_TRBL = {
  n: 'top',
  w: 'left',
  s: 'bottom',
  e: 'right'
};

var HIGH_PRIORITY = 1500;

var DIRECTION_TO_OPPOSITE = {
  n: 's',
  w: 'e',
  s: 'n',
  e: 'w'
};

var PADDING = 20;


/**
 * Add or remove space by moving and resizing elements.
 *
 * @param {Canvas} canvas
 * @param {Dragging} dragging
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 * @param {Rules} rules
 * @param {ToolManager} toolManager
 * @param {Mouse} mouse
 */
function SpaceTool(
    canvas, dragging, eventBus,
    modeling, rules, toolManager,
    mouse) {

  this._canvas = canvas;
  this._dragging = dragging;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._rules = rules;
  this._toolManager = toolManager;
  this._mouse = mouse;

  var self = this;

  toolManager.registerTool('space', {
    tool: 'spaceTool.selection',
    dragging: 'spaceTool'
  });

  eventBus.on('spaceTool.selection.end', function(event) {
    eventBus.once('spaceTool.selection.ended', function() {
      self.activateMakeSpace(event.originalEvent);
    });
  });

  eventBus.on('spaceTool.move', HIGH_PRIORITY , function(event) {
    var context = event.context,
        initialized = context.initialized;

    if (!initialized) {
      initialized = context.initialized = self.init(event, context);
    }

    if (initialized) {
      ensureConstraints(event);
    }
  });

  eventBus.on('spaceTool.end', function(event) {
    var context = event.context,
        axis = context.axis,
        direction = context.direction,
        movingShapes = context.movingShapes,
        resizingShapes = context.resizingShapes,
        start = context.start;

    if (!context.initialized) {
      return;
    }

    ensureConstraints(event);

    var delta = {
      x: 0,
      y: 0
    };

    delta[ axis ] = round(event[ 'd' + axis ]);

    self.makeSpace(movingShapes, resizingShapes, delta, direction, start);

    eventBus.once('spaceTool.ended', function(event) {

      // activate space tool selection after make space
      self.activateSelection(event.originalEvent, true, true);
    });
  });
}

SpaceTool.$inject = [
  'canvas',
  'dragging',
  'eventBus',
  'modeling',
  'rules',
  'toolManager',
  'mouse'
];

/**
 * Activate space tool selection.
 *
 * @param {Object} event
 * @param {boolean} autoActivate
 */
SpaceTool.prototype.activateSelection = function(event, autoActivate, reactivate) {
  this._dragging.init(event, 'spaceTool.selection', {
    autoActivate: autoActivate,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {
        reactivate: reactivate
      }
    },
    trapClick: false
  });
};

/**
 * Activate space tool make space.
 *
 * @param  {MouseEvent} event
 */
SpaceTool.prototype.activateMakeSpace = function(event) {
  this._dragging.init(event, 'spaceTool', {
    autoActivate: true,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {}
    }
  });
};

/**
 * Make space.
 *
 * @param  {Array<djs.model.Shape>} movingShapes
 * @param  {Array<djs.model.Shape>} resizingShapes
 * @param  {Object} delta
 * @param  {number} delta.x
 * @param  {number} delta.y
 * @param  {string} direction
 * @param  {number} start
 */
SpaceTool.prototype.makeSpace = function(movingShapes, resizingShapes, delta, direction, start) {
  return this._modeling.createSpace(movingShapes, resizingShapes, delta, direction, start);
};

/**
 * Initialize make space and return true if that was successful.
 *
 * @param {Object} event
 * @param {Object} context
 *
 * @return {boolean}
 */
SpaceTool.prototype.init = function(event, context) {
  var axis = abs(event.dx) > abs(event.dy) ? 'x' : 'y',
      delta = event[ 'd' + axis ],
      start = event[ axis ] - delta;

  if (abs(delta) < 5) {
    return false;
  }

  // invert delta to remove space when moving left
  if (delta < 0) {
    delta *= -1;
  }

  // invert delta to add/remove space when removing/adding space if modifier key is pressed
  if ((0,_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.hasPrimaryModifier)(event)) {
    delta *= -1;
  }

  var direction = (0,_SpaceUtil__WEBPACK_IMPORTED_MODULE_1__.getDirection)(axis, delta);

  var root = this._canvas.getRootElement();

  var children = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.selfAndAllChildren)(root, true);

  var elements = this.calculateAdjustments(children, axis, delta, start);

  var minDimensions = this._eventBus.fire('spaceTool.getMinDimensions', {
    axis: axis,
    direction: direction,
    shapes: elements.resizingShapes,
    start: start
  });

  var spaceToolConstraints = getSpaceToolConstraints(elements, axis, direction, start, minDimensions);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)(
    context,
    elements,
    {
      axis: axis,
      direction: direction,
      spaceToolConstraints: spaceToolConstraints,
      start: start
    }
  );

  (0,_util_Cursor__WEBPACK_IMPORTED_MODULE_4__.set)('resize-' + (axis === 'x' ? 'ew' : 'ns'));

  return true;
};

/**
 * Get elements to be moved and resized.
 *
 * @param  {Array<djs.model.Shape>} elements
 * @param  {string} axis
 * @param  {number} delta
 * @param  {number} start
 *
 * @return {Object}
 */
SpaceTool.prototype.calculateAdjustments = function(elements, axis, delta, start) {
  var rules = this._rules;

  var movingShapes = [],
      resizingShapes = [];

  (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(elements, function(element) {
    if (!element.parent || isConnection(element)) {
      return;
    }

    var shapeStart = element[ axis ],
        shapeEnd = shapeStart + element[ AXIS_TO_DIMENSION[ axis ] ];

    // shape to be moved
    if ((delta > 0 && shapeStart > start) || (delta < 0 && shapeEnd < start)) {
      return movingShapes.push(element);
    }

    // shape to be resized
    if (shapeStart < start &&
      shapeEnd > start &&
      rules.allowed('shape.resize', { shape: element })
    ) {

      return resizingShapes.push(element);
    }
  });

  return {
    movingShapes: movingShapes,
    resizingShapes: resizingShapes
  };
};

SpaceTool.prototype.toggle = function() {

  if (this.isActive()) {
    return this._dragging.cancel();
  }

  var mouseEvent = this._mouse.getLastMoveEvent();

  this.activateSelection(mouseEvent, !!mouseEvent);
};

SpaceTool.prototype.isActive = function() {
  var context = this._dragging.context();

  return context && /^spaceTool/.test(context.prefix);
};

// helpers //////////

function addPadding(trbl) {
  return {
    top: trbl.top - PADDING,
    right: trbl.right + PADDING,
    bottom: trbl.bottom + PADDING,
    left: trbl.left - PADDING
  };
}

function ensureConstraints(event) {
  var context = event.context,
      spaceToolConstraints = context.spaceToolConstraints;

  if (!spaceToolConstraints) {
    return;
  }

  var x, y;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(spaceToolConstraints.left)) {
    x = Math.max(event.x, spaceToolConstraints.left);

    event.dx = event.dx + x - event.x;
    event.x = x;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(spaceToolConstraints.right)) {
    x = Math.min(event.x, spaceToolConstraints.right);

    event.dx = event.dx + x - event.x;
    event.x = x;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(spaceToolConstraints.top)) {
    y = Math.max(event.y, spaceToolConstraints.top);

    event.dy = event.dy + y - event.y;
    event.y = y;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(spaceToolConstraints.bottom)) {
    y = Math.min(event.y, spaceToolConstraints.bottom);

    event.dy = event.dy + y - event.y;
    event.y = y;
  }
}

function getSpaceToolConstraints(elements, axis, direction, start, minDimensions) {
  var movingShapes = elements.movingShapes,
      resizingShapes = elements.resizingShapes;

  if (!resizingShapes.length) {
    return;
  }

  var spaceToolConstraints = {},
      min,
      max;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(resizingShapes, function(resizingShape) {
    var resizingShapeBBox = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_5__.asTRBL)(resizingShape);

    // find children that are not moving or resizing
    var nonMovingResizingChildren = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.filter)(resizingShape.children, function(child) {
      return !isConnection(child) &&
        !isLabel(child) &&
        !includes(movingShapes, child) &&
        !includes(resizingShapes, child);
    });

    // find children that are moving
    var movingChildren = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.filter)(resizingShape.children, function(child) {
      return !isConnection(child) && !isLabel(child) && includes(movingShapes, child);
    });

    var minOrMax,
        nonMovingResizingChildrenBBox,
        movingChildrenBBox;

    if (nonMovingResizingChildren.length) {
      nonMovingResizingChildrenBBox = addPadding((0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_5__.asTRBL)((0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getBBox)(nonMovingResizingChildren)));

      minOrMax = start -
        resizingShapeBBox[ DIRECTION_TO_TRBL[ direction ] ] +
        nonMovingResizingChildrenBBox[ DIRECTION_TO_TRBL[ direction ] ];

      if (direction === 'n') {
        spaceToolConstraints.bottom = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 'w') {
        spaceToolConstraints.right = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 's') {
        spaceToolConstraints.top = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      } else if (direction === 'e') {
        spaceToolConstraints.left = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      }
    }

    if (movingChildren.length) {
      movingChildrenBBox = addPadding((0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_5__.asTRBL)((0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getBBox)(movingChildren)));

      minOrMax = start -
        movingChildrenBBox[ DIRECTION_TO_TRBL[ DIRECTION_TO_OPPOSITE[ direction ] ] ] +
        resizingShapeBBox[ DIRECTION_TO_TRBL[ DIRECTION_TO_OPPOSITE[ direction ] ] ];

      if (direction === 'n') {
        spaceToolConstraints.bottom = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 'w') {
        spaceToolConstraints.right = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 's') {
        spaceToolConstraints.top = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      } else if (direction === 'e') {
        spaceToolConstraints.left = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      }
    }

    var resizingShapeMinDimensions = minDimensions && minDimensions[ resizingShape.id ];

    if (resizingShapeMinDimensions) {
      if (direction === 'n') {
        minOrMax = start +
          resizingShape[ AXIS_TO_DIMENSION [ axis ] ] -
          resizingShapeMinDimensions[ AXIS_TO_DIMENSION[ axis ] ];

        spaceToolConstraints.bottom = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 'w') {
        minOrMax = start +
          resizingShape[ AXIS_TO_DIMENSION [ axis ] ] -
          resizingShapeMinDimensions[ AXIS_TO_DIMENSION[ axis ] ];

        spaceToolConstraints.right = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 's') {
        minOrMax = start -
          resizingShape[ AXIS_TO_DIMENSION [ axis ] ] +
          resizingShapeMinDimensions[ AXIS_TO_DIMENSION[ axis ] ];

        spaceToolConstraints.top = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      } else if (direction === 'e') {
        minOrMax = start -
          resizingShape[ AXIS_TO_DIMENSION [ axis ] ] +
          resizingShapeMinDimensions[ AXIS_TO_DIMENSION[ axis ] ];

        spaceToolConstraints.left = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      }
    }
  });

  return spaceToolConstraints;
}

function includes(array, item) {
  return array.indexOf(item) !== -1;
}

function isConnection(element) {
  return !!element.waypoints;
}

function isLabel(element) {
  return !!element.labelTarget;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/space-tool/SpaceToolPreview.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/space-tool/SpaceToolPreview.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpaceToolPreview)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");


var MARKER_DRAGGING = 'djs-dragging',
    MARKER_RESIZING = 'djs-resizing';

var LOW_PRIORITY = 250;





var max = Math.max;


/**
 * Provides previews for selecting/moving/resizing shapes when creating/removing space.
 *
 * @param {EventBus} eventBus
 * @param {ElementRegistry} elementRegistry
 * @param {Canvas} canvas
 * @param {Styles} styles
 */
function SpaceToolPreview(
    eventBus, elementRegistry, canvas,
    styles, previewSupport) {

  function addPreviewGfx(collection, dragGroup) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(collection, function(element) {
      previewSupport.addDragger(element, dragGroup);

      canvas.addMarker(element, MARKER_DRAGGING);
    });
  }

  // add crosshair
  eventBus.on('spaceTool.selection.start', function(event) {
    var space = canvas.getLayer('space'),
        context = event.context;

    var orientation = {
      x: 'M 0,-10000 L 0,10000',
      y: 'M -10000,0 L 10000,0'
    };

    var crosshairGroup = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(crosshairGroup, styles.cls('djs-crosshair-group', [ 'no-events' ]));

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(space, crosshairGroup);

    // horizontal path
    var pathX = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('path');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(pathX, 'd', orientation.x);
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(pathX).add('djs-crosshair');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(crosshairGroup, pathX);

    // vertical path
    var pathY = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('path');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(pathY, 'd', orientation.y);
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(pathY).add('djs-crosshair');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(crosshairGroup, pathY);

    context.crosshairGroup = crosshairGroup;
  });

  // update crosshair
  eventBus.on('spaceTool.selection.move', function(event) {
    var crosshairGroup = event.context.crosshairGroup;

    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__.translate)(crosshairGroup, event.x, event.y);
  });

  // remove crosshair
  eventBus.on('spaceTool.selection.cleanup', function(event) {
    var context = event.context,
        crosshairGroup = context.crosshairGroup;

    if (crosshairGroup) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(crosshairGroup);
    }
  });

  // add and update move/resize previews
  eventBus.on('spaceTool.move', LOW_PRIORITY, function(event) {

    var context = event.context,
        line = context.line,
        axis = context.axis,
        movingShapes = context.movingShapes,
        resizingShapes = context.resizingShapes;

    if (!context.initialized) {
      return;
    }

    if (!context.dragGroup) {
      var spaceLayer = canvas.getLayer('space');

      line = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('path');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(line, 'd', 'M0,0 L0,0');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(line).add('djs-crosshair');

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(spaceLayer, line);

      context.line = line;

      var dragGroup = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(dragGroup, styles.cls('djs-drag-group', [ 'no-events' ]));

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(canvas.getDefaultLayer(), dragGroup);

      // shapes
      addPreviewGfx(movingShapes, dragGroup);

      // connections
      var movingConnections = context.movingConnections = elementRegistry.filter(function(element) {
        var sourceIsMoving = false;

        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(movingShapes, function(shape) {
          (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsMoving = true;
            }
          });
        });

        var targetIsMoving = false;

        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(movingShapes, function(shape) {
          (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsMoving = true;
            }
          });
        });

        var sourceIsResizing = false;

        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(resizingShapes, function(shape) {
          (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsResizing = true;
            }
          });
        });

        var targetIsResizing = false;

        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(resizingShapes, function(shape) {
          (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsResizing = true;
            }
          });
        });

        return isConnection(element)
          && (sourceIsMoving || sourceIsResizing)
          && (targetIsMoving || targetIsResizing);
      });


      addPreviewGfx(movingConnections, dragGroup);

      context.dragGroup = dragGroup;
    }

    if (!context.frameGroup) {
      var frameGroup = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(frameGroup, styles.cls('djs-frame-group', [ 'no-events' ]));

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(canvas.getDefaultLayer(), frameGroup);

      var frames = [];

      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(resizingShapes, function(shape) {
        var frame = previewSupport.addFrame(shape, frameGroup);

        var initialBounds = frame.getBBox();

        frames.push({
          element: frame,
          initialBounds: initialBounds
        });

        canvas.addMarker(shape, MARKER_RESIZING);
      });

      context.frameGroup = frameGroup;
      context.frames = frames;
    }

    var orientation = {
      x: 'M' + event.x + ', -10000 L' + event.x + ', 10000',
      y: 'M -10000, ' + event.y + ' L 10000, ' + event.y
    };

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(line, { d: orientation[ axis ] });

    var opposite = { x: 'y', y: 'x' };
    var delta = { x: event.dx, y: event.dy };
    delta[ opposite[ context.axis ] ] = 0;

    // update move previews
    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__.translate)(context.dragGroup, delta.x, delta.y);

    // update resize previews
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(context.frames, function(frame) {
      var element = frame.element,
          initialBounds = frame.initialBounds,
          width,
          height;

      if (context.direction === 'e') {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(element, {
          width: max(initialBounds.width + delta.x, 5)
        });
      } else {
        width = max(initialBounds.width - delta.x, 5);

        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(element, {
          width: width,
          x: initialBounds.x + initialBounds.width - width
        });
      }

      if (context.direction === 's') {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(element, {
          height: max(initialBounds.height + delta.y, 5)
        });
      } else {
        height = max(initialBounds.height - delta.y, 5);

        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(element, {
          height: height,
          y: initialBounds.y + initialBounds.height - height
        });
      }
    });

  });

  // remove move/resize previews
  eventBus.on('spaceTool.cleanup', function(event) {

    var context = event.context,
        movingShapes = context.movingShapes,
        movingConnections = context.movingConnections,
        resizingShapes = context.resizingShapes,
        line = context.line,
        dragGroup = context.dragGroup,
        frameGroup = context.frameGroup;

    // moving shapes
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(movingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_DRAGGING);
    });

    // moving connections
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(movingConnections, function(connection) {
      canvas.removeMarker(connection, MARKER_DRAGGING);
    });

    if (dragGroup) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(line);
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(dragGroup);
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(resizingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_RESIZING);
    });

    if (frameGroup) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(frameGroup);
    }
  });
}

SpaceToolPreview.$inject = [
  'eventBus',
  'elementRegistry',
  'canvas',
  'styles',
  'previewSupport'
];


// helpers //////////////////////

/**
 * Checks if an element is a connection.
 */
function isConnection(element) {
  return element.waypoints;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDirection": () => (/* binding */ getDirection),
/* harmony export */   "getWaypointsUpdatingConnections": () => (/* binding */ getWaypointsUpdatingConnections),
/* harmony export */   "resizeBounds": () => (/* binding */ resizeBounds)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * Return direction given axis and delta.
 *
 * @param {string} axis
 * @param {number} delta
 *
 * @return {string}
 */
function getDirection(axis, delta) {

  if (axis === 'x') {
    if (delta > 0) {
      return 'e';
    }

    if (delta < 0) {
      return 'w';
    }
  }

  if (axis === 'y') {
    if (delta > 0) {
      return 's';
    }

    if (delta < 0) {
      return 'n';
    }
  }

  return null;
}

/**
 * Returns connections whose waypoints are to be updated. Waypoints are to be updated if start
 * or end is to be moved or resized.
 *
 * @param {Array<djs.model.Shape} movingShapes
 * @param {Array<djs.model.Shape} resizingShapes
 *
 * @returns {Array<djs.model.Connection>}
 */
function getWaypointsUpdatingConnections(movingShapes, resizingShapes) {
  var waypointsUpdatingConnections = [];

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(movingShapes.concat(resizingShapes), function(shape) {
    var incoming = shape.incoming,
        outgoing = shape.outgoing;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(incoming.concat(outgoing), function(connection) {
      var source = connection.source,
          target = connection.target;

      if (includes(movingShapes, source) ||
        includes(movingShapes, target) ||
        includes(resizingShapes, source) ||
        includes(resizingShapes, target)) {

        if (!includes(waypointsUpdatingConnections, connection)) {
          waypointsUpdatingConnections.push(connection);
        }
      }
    });
  });

  return waypointsUpdatingConnections;
}

function includes(array, item) {
  return array.indexOf(item) !== -1;
}

/**
 * Resize bounds.
 *
 * @param {Object} bounds
 * @param {number} bounds.x
 * @param {number} bounds.y
 * @param {number} bounds.width
 * @param {number} bounds.height
 * @param {string} direction
 * @param {Object} delta
 * @param {number} delta.x
 * @param {number} delta.y
 *
 * @return {Object}
 */
function resizeBounds(bounds, direction, delta) {
  var x = bounds.x,
      y = bounds.y,
      width = bounds.width,
      height = bounds.height,
      dx = delta.x,
      dy = delta.y;

  switch (direction) {
  case 'n':
    return {
      x: x,
      y: y + dy,
      width: width,
      height: height - dy
    };
  case 's':
    return {
      x: x,
      y: y,
      width: width,
      height: height + dy
    };
  case 'w':
    return {
      x: x + dx,
      y: y,
      width: width - dx,
      height: height
    };
  case 'e':
    return {
      x: x,
      y: y,
      width: width + dx,
      height: height
    };
  default:
    throw new Error('unknown direction: ' + direction);
  }
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/space-tool/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/space-tool/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _tool_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tool-manager */ "./node_modules/diagram-js/lib/features/tool-manager/index.js");
/* harmony import */ var _preview_support__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../preview-support */ "./node_modules/diagram-js/lib/features/preview-support/index.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mouse */ "./node_modules/diagram-js/lib/features/mouse/index.js");
/* harmony import */ var _SpaceTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SpaceTool */ "./node_modules/diagram-js/lib/features/space-tool/SpaceTool.js");
/* harmony import */ var _SpaceToolPreview__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SpaceToolPreview */ "./node_modules/diagram-js/lib/features/space-tool/SpaceToolPreview.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: ['spaceToolPreview'],
  __depends__: [
    _dragging__WEBPACK_IMPORTED_MODULE_0__.default,
    _rules__WEBPACK_IMPORTED_MODULE_1__.default,
    _tool_manager__WEBPACK_IMPORTED_MODULE_2__.default,
    _preview_support__WEBPACK_IMPORTED_MODULE_3__.default,
    _mouse__WEBPACK_IMPORTED_MODULE_4__.default
  ],
  spaceTool: ['type', _SpaceTool__WEBPACK_IMPORTED_MODULE_5__.default ],
  spaceToolPreview: ['type', _SpaceToolPreview__WEBPACK_IMPORTED_MODULE_6__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/tool-manager/ToolManager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/tool-manager/ToolManager.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ToolManager)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");




var LOW_PRIORITY = 250;

/**
 * The tool manager acts as middle-man between the available tool's and the Palette,
 * it takes care of making sure that the correct active state is set.
 *
 * @param  {Object}    eventBus
 * @param  {Object}    dragging
 */
function ToolManager(eventBus, dragging) {
  this._eventBus = eventBus;
  this._dragging = dragging;

  this._tools = [];
  this._active = null;
}

ToolManager.$inject = [ 'eventBus', 'dragging' ];

ToolManager.prototype.registerTool = function(name, events) {
  var tools = this._tools;

  if (!events) {
    throw new Error('A tool has to be registered with it\'s "events"');
  }

  tools.push(name);

  this.bindEvents(name, events);
};

ToolManager.prototype.isActive = function(tool) {
  return tool && this._active === tool;
};

ToolManager.prototype.length = function(tool) {
  return this._tools.length;
};

ToolManager.prototype.setActive = function(tool) {
  var eventBus = this._eventBus;

  if (this._active !== tool) {
    this._active = tool;

    eventBus.fire('tool-manager.update', { tool: tool });
  }
};

ToolManager.prototype.bindEvents = function(name, events) {
  var eventBus = this._eventBus,
      dragging = this._dragging;

  var eventsToRegister = [];

  eventBus.on(events.tool + '.init', function(event) {
    var context = event.context;

    // Active tools that want to reactivate themselves must do this explicitly
    if (!context.reactivate && this.isActive(name)) {
      this.setActive(null);

      dragging.cancel();
      return;
    }

    this.setActive(name);

  }, this);

  // Todo[ricardo]: add test cases
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(events, function(event) {
    eventsToRegister.push(event + '.ended');
    eventsToRegister.push(event + '.canceled');
  });

  eventBus.on(eventsToRegister, LOW_PRIORITY, function(event) {

    // We defer the de-activation of the tool to the .activate phase,
    // so we're able to check if we want to toggle off the current
    // active tool or switch to a new one
    if (!this._active) {
      return;
    }

    if (isPaletteClick(event)) {
      return;
    }

    this.setActive(null);
  }, this);

};


// helpers ///////////////

/**
 * Check if a given event is a palette click event.
 *
 * @param {EventBus.Event} event
 *
 * @return {boolean}
 */
function isPaletteClick(event) {
  var target = event.originalEvent && event.originalEvent.target;

  return target && (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.closest)(target, '.group[data-group="tools"]');
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/tool-manager/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/tool-manager/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _ToolManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ToolManager */ "./node_modules/diagram-js/lib/features/tool-manager/ToolManager.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _dragging__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'toolManager' ],
  toolManager: [ 'type', _ToolManager__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/tooltips/Tooltips.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/tooltips/Tooltips.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tooltips)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_IdGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/IdGenerator */ "./node_modules/diagram-js/lib/util/IdGenerator.js");






// document wide unique tooltip ids
var ids = new _util_IdGenerator__WEBPACK_IMPORTED_MODULE_0__.default('tt');


function createRoot(parentNode) {
  var root = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)(
    '<div class="djs-tooltip-container" style="position: absolute; width: 0; height: 0;" />'
  );

  parentNode.insertBefore(root, parentNode.firstChild);

  return root;
}


function setPosition(el, x, y) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(el.style, { left: x + 'px', top: y + 'px' });
}

function setVisible(el, visible) {
  el.style.display = visible === false ? 'none' : '';
}


var tooltipClass = 'djs-tooltip',
    tooltipSelector = '.' + tooltipClass;

/**
 * A service that allows users to render tool tips on the diagram.
 *
 * The tooltip service will take care of updating the tooltip positioning
 * during navigation + zooming.
 *
 * @example
 *
 * ```javascript
 *
 * // add a pink badge on the top left of the shape
 * tooltips.add({
 *   position: {
 *     x: 50,
 *     y: 100
 *   },
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
 *
 * // or with optional life span
 * tooltips.add({
 *   position: {
 *     top: -5,
 *     left: -5
 *   },
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>',
 *   ttl: 2000
 * });
 *
 * // remove a tool tip
 * var id = tooltips.add(...);
 * tooltips.remove(id);
 * ```
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function Tooltips(eventBus, canvas) {

  this._eventBus = eventBus;
  this._canvas = canvas;

  this._ids = ids;

  this._tooltipDefaults = {
    show: {
      minZoom: 0.7,
      maxZoom: 5.0
    }
  };

  /**
   * Mapping tooltipId -> tooltip
   */
  this._tooltips = {};

  // root html element for all tooltips
  this._tooltipRoot = createRoot(canvas.getContainer());


  var self = this;

  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(this._tooltipRoot, tooltipSelector, 'mousedown', function(event) {
    event.stopPropagation();
  });

  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(this._tooltipRoot, tooltipSelector, 'mouseover', function(event) {
    self.trigger('mouseover', event);
  });

  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(this._tooltipRoot, tooltipSelector, 'mouseout', function(event) {
    self.trigger('mouseout', event);
  });

  this._init();
}


Tooltips.$inject = [ 'eventBus', 'canvas' ];


/**
 * Adds a HTML tooltip to the diagram
 *
 * @param {Object}               tooltip   the tooltip configuration
 *
 * @param {string|DOMElement}    tooltip.html                 html element to use as an tooltip
 * @param {Object}               [tooltip.show]               show configuration
 * @param {number}               [tooltip.show.minZoom]       minimal zoom level to show the tooltip
 * @param {number}               [tooltip.show.maxZoom]       maximum zoom level to show the tooltip
 * @param {Object}               tooltip.position             where to attach the tooltip
 * @param {number}               [tooltip.position.left]      relative to element bbox left attachment
 * @param {number}               [tooltip.position.top]       relative to element bbox top attachment
 * @param {number}               [tooltip.position.bottom]    relative to element bbox bottom attachment
 * @param {number}               [tooltip.position.right]     relative to element bbox right attachment
 * @param {number}               [tooltip.timeout=-1]
 *
 * @return {string}              id that may be used to reference the tooltip for update or removal
 */
Tooltips.prototype.add = function(tooltip) {

  if (!tooltip.position) {
    throw new Error('must specifiy tooltip position');
  }

  if (!tooltip.html) {
    throw new Error('must specifiy tooltip html');
  }

  var id = this._ids.next();

  tooltip = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, this._tooltipDefaults, tooltip, {
    id: id
  });

  this._addTooltip(tooltip);

  if (tooltip.timeout) {
    this.setTimeout(tooltip);
  }

  return id;
};

Tooltips.prototype.trigger = function(action, event) {

  var node = event.delegateTarget || event.target;

  var tooltip = this.get((0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(node, 'data-tooltip-id'));

  if (!tooltip) {
    return;
  }

  if (action === 'mouseover' && tooltip.timeout) {
    this.clearTimeout(tooltip);
  }

  if (action === 'mouseout' && tooltip.timeout) {

    // cut timeout after mouse out
    tooltip.timeout = 1000;

    this.setTimeout(tooltip);
  }
};

/**
 * Get a tooltip with the given id
 *
 * @param {string} id
 */
Tooltips.prototype.get = function(id) {

  if (typeof id !== 'string') {
    id = id.id;
  }

  return this._tooltips[id];
};

Tooltips.prototype.clearTimeout = function(tooltip) {

  tooltip = this.get(tooltip);

  if (!tooltip) {
    return;
  }

  var removeTimer = tooltip.removeTimer;

  if (removeTimer) {
    clearTimeout(removeTimer);
    tooltip.removeTimer = null;
  }
};

Tooltips.prototype.setTimeout = function(tooltip) {

  tooltip = this.get(tooltip);

  if (!tooltip) {
    return;
  }

  this.clearTimeout(tooltip);

  var self = this;

  tooltip.removeTimer = setTimeout(function() {
    self.remove(tooltip);
  }, tooltip.timeout);
};

/**
 * Remove an tooltip with the given id
 *
 * @param {string} id
 */
Tooltips.prototype.remove = function(id) {

  var tooltip = this.get(id);

  if (tooltip) {
    (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.remove)(tooltip.html);
    (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.remove)(tooltip.htmlContainer);

    delete tooltip.htmlContainer;

    delete this._tooltips[tooltip.id];
  }
};


Tooltips.prototype.show = function() {
  setVisible(this._tooltipRoot);
};


Tooltips.prototype.hide = function() {
  setVisible(this._tooltipRoot, false);
};


Tooltips.prototype._updateRoot = function(viewbox) {
  var a = viewbox.scale || 1;
  var d = viewbox.scale || 1;

  var matrix = 'matrix(' + a + ',0,0,' + d + ',' + (-1 * viewbox.x * a) + ',' + (-1 * viewbox.y * d) + ')';

  this._tooltipRoot.style.transform = matrix;
  this._tooltipRoot.style['-ms-transform'] = matrix;
};


Tooltips.prototype._addTooltip = function(tooltip) {

  var id = tooltip.id,
      html = tooltip.html,
      htmlContainer,
      tooltipRoot = this._tooltipRoot;

  // unwrap jquery (for those who need it)
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }

  // create proper html elements from
  // tooltip HTML strings
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(html)) {
    html = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)(html);
  }

  htmlContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div data-tooltip-id="' + id + '" class="' + tooltipClass + '" style="position: absolute">');

  htmlContainer.appendChild(html);

  if (tooltip.type) {
    (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(htmlContainer).add('djs-tooltip-' + tooltip.type);
  }

  if (tooltip.className) {
    (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(htmlContainer).add(tooltip.className);
  }

  tooltip.htmlContainer = htmlContainer;

  tooltipRoot.appendChild(htmlContainer);

  this._tooltips[id] = tooltip;

  this._updateTooltip(tooltip);
};


Tooltips.prototype._updateTooltip = function(tooltip) {

  var position = tooltip.position,
      htmlContainer = tooltip.htmlContainer;

  // update overlay html based on tooltip x, y

  setPosition(htmlContainer, position.x, position.y);
};


Tooltips.prototype._updateTooltipVisibilty = function(viewbox) {

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(this._tooltips, function(tooltip) {
    var show = tooltip.show,
        htmlContainer = tooltip.htmlContainer,
        visible = true;

    if (show) {
      if (show.minZoom > viewbox.scale ||
          show.maxZoom < viewbox.scale) {
        visible = false;
      }

      setVisible(htmlContainer, visible);
    }
  });
};

Tooltips.prototype._init = function() {

  var self = this;

  // scroll/zoom integration

  function updateViewbox(viewbox) {
    self._updateRoot(viewbox);
    self._updateTooltipVisibilty(viewbox);

    self.show();
  }

  this._eventBus.on('canvas.viewbox.changing', function(event) {
    self.hide();
  });

  this._eventBus.on('canvas.viewbox.changed', function(event) {
    updateViewbox(event.viewbox);
  });
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/tooltips/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/tooltips/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Tooltips__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tooltips */ "./node_modules/diagram-js/lib/features/tooltips/Tooltips.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'tooltips' ],
  tooltips: [ 'type', _Tooltips__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/touch/TouchFix.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/touch/TouchFix.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TouchFix)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");



function TouchFix(canvas, eventBus) {

  var self = this;

  eventBus.on('canvas.init', function(e) {
    self.addBBoxMarker(e.svg);
  });
}

TouchFix.$inject = [ 'canvas', 'eventBus' ];


/**
 * Safari mobile (iOS 7) does not fire touchstart event in <SVG> element
 * if there is no shape between 0,0 and viewport elements origin.
 *
 * So touchstart event is only fired when the <g class="viewport"> element was hit.
 * Putting an element over and below the 'viewport' fixes that behavior.
 */
TouchFix.prototype.addBBoxMarker = function(svg) {

  var markerStyle = {
    fill: 'none',
    class: 'outer-bound-marker'
  };

  var rect1 = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('rect');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(rect1, {
    x: -10000,
    y: 10000,
    width: 10,
    height: 10
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(rect1, markerStyle);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(svg, rect1);

  var rect2 = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('rect');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(rect2, {
    x: 10000,
    y: 10000,
    width: 10,
    height: 10
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(rect2, markerStyle);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(svg, rect2);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/touch/TouchInteractionEvents.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/touch/TouchInteractionEvents.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TouchInteractionEvents)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hammerjs */ "./node_modules/hammerjs/hammer.js");
/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hammerjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");








var MIN_ZOOM = 0.2,
    MAX_ZOOM = 4;

var mouseEvents = [
  'mousedown',
  'mouseup',
  'mouseover',
  'mouseout',
  'click',
  'dblclick'
];

function log() {

  // console.log.apply(console, arguments);
}

function get(service, injector) {
  return injector.get(service, false);
}

function stopEvent(event) {

  event.preventDefault();

  if (typeof event.stopPropagation === 'function') {
    event.stopPropagation();
  } else if (event.srcEvent && typeof event.srcEvent.stopPropagation === 'function') {

    // iPhone & iPad
    event.srcEvent.stopPropagation();
  }

  if (typeof event.stopImmediatePropagation === 'function') {
    event.stopImmediatePropagation();
  }
}


function createTouchRecognizer(node) {

  function stopMouse(event) {

    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(mouseEvents, function(e) {
      min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(node, e, stopEvent, true);
    });
  }

  function allowMouse(event) {
    setTimeout(function() {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(mouseEvents, function(e) {
        min_dom__WEBPACK_IMPORTED_MODULE_2__.event.unbind(node, e, stopEvent, true);
      });
    }, 500);
  }

  min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(node, 'touchstart', stopMouse, true);
  min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(node, 'touchend', allowMouse, true);
  min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(node, 'touchcancel', allowMouse, true);

  // A touch event recognizer that handles
  // touch events only (we know, we can already handle
  // mouse events out of the box)

  var recognizer = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Manager)(node, {
    inputClass: (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().TouchInput),
    recognizers: [],
    domEvents: true
  });


  var tap = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Tap)();
  var pan = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Pan)({ threshold: 10 });
  var press = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Press)();
  var pinch = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Pinch)();

  var doubleTap = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Tap)({ event: 'doubletap', taps: 2 });

  pinch.requireFailure(pan);
  pinch.requireFailure(press);

  recognizer.add([ pan, press, pinch, doubleTap, tap ]);

  recognizer.reset = function(force) {
    var recognizers = this.recognizers,
        session = this.session;

    if (session.stopped) {
      return;
    }

    log('recognizer', 'stop');

    recognizer.stop(force);

    setTimeout(function() {
      var i, r;

      log('recognizer', 'reset');
      for (i = 0; (r = recognizers[i]); i++) {
        r.reset();
        r.state = 8; // FAILED STATE
      }

      session.curRecognizer = null;
    }, 0);
  };

  recognizer.on('hammer.input', function(event) {
    if (event.srcEvent.defaultPrevented) {
      recognizer.reset(true);
    }
  });

  return recognizer;
}

/**
 * A plugin that provides touch events for elements.
 *
 * @param {EventBus} eventBus
 * @param {InteractionEvents} interactionEvents
 */
function TouchInteractionEvents(
    injector, canvas, eventBus,
    elementRegistry, interactionEvents) {

  // optional integrations
  var dragging = get('dragging', injector),
      move = get('move', injector),
      contextPad = get('contextPad', injector),
      palette = get('palette', injector);

  // the touch recognizer
  var recognizer;

  function handler(type) {

    return function(event) {
      log('element', type, event);

      interactionEvents.fire(type, event);
    };
  }

  function getGfx(target) {
    var node = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.closest)(target, 'svg, .djs-element', true);
    return node;
  }

  function initEvents(svg) {

    // touch recognizer
    recognizer = createTouchRecognizer(svg);

    recognizer.on('doubletap', handler('element.dblclick'));

    recognizer.on('tap', handler('element.click'));

    function startGrabCanvas(event) {

      log('canvas', 'grab start');

      var lx = 0, ly = 0;

      function update(e) {

        var dx = e.deltaX - lx,
            dy = e.deltaY - ly;

        canvas.scroll({ dx: dx, dy: dy });

        lx = e.deltaX;
        ly = e.deltaY;
      }

      function end(e) {
        recognizer.off('panmove', update);
        recognizer.off('panend', end);
        recognizer.off('pancancel', end);

        log('canvas', 'grab end');
      }

      recognizer.on('panmove', update);
      recognizer.on('panend', end);
      recognizer.on('pancancel', end);
    }

    function startGrab(event) {

      var gfx = getGfx(event.target),
          element = gfx && elementRegistry.get(gfx);

      // recognizer
      if (move && canvas.getRootElement() !== element) {
        log('element', 'move start', element, event, true);
        return move.start(event, element, true);
      } else {
        startGrabCanvas(event);
      }
    }

    function startZoom(e) {

      log('canvas', 'zoom start');

      var zoom = canvas.zoom(),
          mid = e.center;

      function update(e) {

        var ratio = 1 - (1 - e.scale) / 1.50,
            newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, ratio * zoom));

        canvas.zoom(newZoom, mid);

        stopEvent(e);
      }

      function end(e) {
        recognizer.off('pinchmove', update);
        recognizer.off('pinchend', end);
        recognizer.off('pinchcancel', end);

        recognizer.reset(true);

        log('canvas', 'zoom end');
      }

      recognizer.on('pinchmove', update);
      recognizer.on('pinchend', end);
      recognizer.on('pinchcancel', end);
    }

    recognizer.on('panstart', startGrab);
    recognizer.on('press', startGrab);

    recognizer.on('pinchstart', startZoom);
  }

  if (dragging) {

    // simulate hover during dragging
    eventBus.on('drag.move', function(event) {

      var originalEvent = event.originalEvent;

      if (!originalEvent || originalEvent instanceof MouseEvent) {
        return;
      }

      var position = (0,_util_Event__WEBPACK_IMPORTED_MODULE_3__.toPoint)(originalEvent);

      // this gets really expensive ...
      var node = document.elementFromPoint(position.x, position.y),
          gfx = getGfx(node),
          element = gfx && elementRegistry.get(gfx);

      if (element !== event.hover) {
        if (event.hover) {
          dragging.out(event);
        }

        if (element) {
          dragging.hover({ element: element, gfx: gfx });

          event.hover = element;
          event.hoverGfx = gfx;
        }
      }
    });
  }

  if (contextPad) {

    eventBus.on('contextPad.create', function(event) {
      var node = event.pad.html;

      // touch recognizer
      var padRecognizer = createTouchRecognizer(node);

      padRecognizer.on('panstart', function(event) {
        log('context-pad', 'panstart', event);
        contextPad.trigger('dragstart', event, true);
      });

      padRecognizer.on('press', function(event) {
        log('context-pad', 'press', event);
        contextPad.trigger('dragstart', event, true);
      });

      padRecognizer.on('tap', function(event) {
        log('context-pad', 'tap', event);
        contextPad.trigger('click', event);
      });
    });
  }

  if (palette) {
    eventBus.on('palette.create', function(event) {
      var node = event.container;

      // touch recognizer
      var padRecognizer = createTouchRecognizer(node);

      padRecognizer.on('panstart', function(event) {
        log('palette', 'panstart', event);
        palette.trigger('dragstart', event, true);
      });

      padRecognizer.on('press', function(event) {
        log('palette', 'press', event);
        palette.trigger('dragstart', event, true);
      });

      padRecognizer.on('tap', function(event) {
        log('palette', 'tap', event);
        palette.trigger('click', event);
      });
    });
  }

  eventBus.on('canvas.init', function(event) {
    initEvents(event.svg);
  });
}


TouchInteractionEvents.$inject = [
  'injector',
  'canvas',
  'eventBus',
  'elementRegistry',
  'interactionEvents',
  'touchFix'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/touch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/touch/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interaction_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interaction-events */ "./node_modules/diagram-js/lib/features/interaction-events/index.js");
/* harmony import */ var _TouchInteractionEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TouchInteractionEvents */ "./node_modules/diagram-js/lib/features/touch/TouchInteractionEvents.js");
/* harmony import */ var _TouchFix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TouchFix */ "./node_modules/diagram-js/lib/features/touch/TouchFix.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [ _interaction_events__WEBPACK_IMPORTED_MODULE_0__.default ],
  __init__: [ 'touchInteractionEvents' ],
  touchInteractionEvents: [ 'type', _TouchInteractionEvents__WEBPACK_IMPORTED_MODULE_1__.default ],
  touchFix: [ 'type', _TouchFix__WEBPACK_IMPORTED_MODULE_2__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/i18n/translate/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/i18n/translate/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _translate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./translate */ "./node_modules/diagram-js/lib/i18n/translate/translate.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  translate: [ 'value', _translate__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/i18n/translate/translate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/i18n/translate/translate.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ translate)
/* harmony export */ });
/**
 * A simple translation stub to be used for multi-language support
 * in diagrams. Can be easily replaced with a more sophisticated
 * solution.
 *
 * @example
 *
 * // use it inside any diagram component by injecting `translate`.
 *
 * function MyService(translate) {
 *   alert(translate('HELLO {you}', { you: 'You!' }));
 * }
 *
 * @param {string} template to interpolate
 * @param {Object} [replacements] a map with substitutes
 *
 * @return {string} the translated string
 */
function translate(template, replacements) {

  replacements = replacements || {};

  return template.replace(/{([^}]+)}/g, function(_, key) {
    return replacements[key] || '{' + key + '}';
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/layout/BaseLayouter.js":
/*!************************************************************!*\
  !*** ./node_modules/diagram-js/lib/layout/BaseLayouter.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseLayouter)
/* harmony export */ });
/* harmony import */ var _LayoutUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");



/**
 * A base connection layouter implementation
 * that layouts the connection by directly connecting
 * mid(source) + mid(target).
 */
function BaseLayouter() {}


/**
 * Return the new layouted waypoints for the given connection.
 *
 * The connection passed is still unchanged; you may figure out about
 * the new connection start / end via the layout hints provided.
 *
 * @param {djs.model.Connection} connection
 * @param {Object} [hints]
 * @param {Point} [hints.connectionStart]
 * @param {Point} [hints.connectionEnd]
 * @param {Point} [hints.source]
 * @param {Point} [hints.target]
 *
 * @return {Array<Point>} the layouted connection waypoints
 */
BaseLayouter.prototype.layoutConnection = function(connection, hints) {

  hints = hints || {};

  return [
    hints.connectionStart || (0,_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.getMid)(hints.source || connection.source),
    hints.connectionEnd || (0,_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.getMid)(hints.target || connection.target)
  ];
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js":
/*!*************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CroppingConnectionDocking)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");





function dockingToPoint(docking) {

  // use the dockings actual point and
  // retain the original docking
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({ original: docking.point.original || docking.point }, docking.actual);
}


/**
 * A {@link ConnectionDocking} that crops connection waypoints based on
 * the path(s) of the connection source and target.
 *
 * @param {djs.core.ElementRegistry} elementRegistry
 */
function CroppingConnectionDocking(elementRegistry, graphicsFactory) {
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;
}

CroppingConnectionDocking.$inject = [ 'elementRegistry', 'graphicsFactory' ];


/**
 * @inheritDoc ConnectionDocking#getCroppedWaypoints
 */
CroppingConnectionDocking.prototype.getCroppedWaypoints = function(connection, source, target) {

  source = source || connection.source;
  target = target || connection.target;

  var sourceDocking = this.getDockingPoint(connection, source, true),
      targetDocking = this.getDockingPoint(connection, target);

  var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);

  croppedWaypoints.unshift(dockingToPoint(sourceDocking));
  croppedWaypoints.push(dockingToPoint(targetDocking));

  return croppedWaypoints;
};

/**
 * Return the connection docking point on the specified shape
 *
 * @inheritDoc ConnectionDocking#getDockingPoint
 */
CroppingConnectionDocking.prototype.getDockingPoint = function(connection, shape, dockStart) {

  var waypoints = connection.waypoints,
      dockingIdx,
      dockingPoint,
      croppedPoint;

  dockingIdx = dockStart ? 0 : waypoints.length - 1;
  dockingPoint = waypoints[dockingIdx];

  croppedPoint = this._getIntersection(shape, connection, dockStart);

  return {
    point: dockingPoint,
    actual: croppedPoint || dockingPoint,
    idx: dockingIdx
  };
};


// helpers //////////////////////

CroppingConnectionDocking.prototype._getIntersection = function(shape, connection, takeFirst) {

  var shapePath = this._getShapePath(shape),
      connectionPath = this._getConnectionPath(connection);

  return (0,_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getElementLineIntersection)(shapePath, connectionPath, takeFirst);
};

CroppingConnectionDocking.prototype._getConnectionPath = function(connection) {
  return this._graphicsFactory.getConnectionPath(connection);
};

CroppingConnectionDocking.prototype._getShapePath = function(shape) {
  return this._graphicsFactory.getShapePath(shape);
};

CroppingConnectionDocking.prototype._getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/layout/LayoutUtil.js":
/*!**********************************************************!*\
  !*** ./node_modules/diagram-js/lib/layout/LayoutUtil.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "roundBounds": () => (/* binding */ roundBounds),
/* harmony export */   "roundPoint": () => (/* binding */ roundPoint),
/* harmony export */   "asTRBL": () => (/* binding */ asTRBL),
/* harmony export */   "asBounds": () => (/* binding */ asBounds),
/* harmony export */   "getMid": () => (/* binding */ getMid),
/* harmony export */   "getOrientation": () => (/* binding */ getOrientation),
/* harmony export */   "getElementLineIntersection": () => (/* binding */ getElementLineIntersection),
/* harmony export */   "getIntersections": () => (/* binding */ getIntersections),
/* harmony export */   "filterRedundantWaypoints": () => (/* binding */ filterRedundantWaypoints)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Geometry */ "./node_modules/diagram-js/lib/util/Geometry.js");
/* harmony import */ var path_intersection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path-intersection */ "./node_modules/path-intersection/intersect.js");
/* harmony import */ var path_intersection__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path_intersection__WEBPACK_IMPORTED_MODULE_0__);







function roundBounds(bounds) {
  return {
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  };
}


function roundPoint(point) {

  return {
    x: Math.round(point.x),
    y: Math.round(point.y)
  };
}


/**
 * Convert the given bounds to a { top, left, bottom, right } descriptor.
 *
 * @param {Bounds|Point} bounds
 *
 * @return {Object}
 */
function asTRBL(bounds) {
  return {
    top: bounds.y,
    right: bounds.x + (bounds.width || 0),
    bottom: bounds.y + (bounds.height || 0),
    left: bounds.x
  };
}


/**
 * Convert a { top, left, bottom, right } to an objects bounds.
 *
 * @param {Object} trbl
 *
 * @return {Bounds}
 */
function asBounds(trbl) {
  return {
    x: trbl.left,
    y: trbl.top,
    width: trbl.right - trbl.left,
    height: trbl.bottom - trbl.top
  };
}


/**
 * Get the mid of the given bounds or point.
 *
 * @param {Bounds|Point} bounds
 *
 * @return {Point}
 */
function getMid(bounds) {
  return roundPoint({
    x: bounds.x + (bounds.width || 0) / 2,
    y: bounds.y + (bounds.height || 0) / 2
  });
}


// orientation utils //////////////////////

/**
 * Get orientation of the given rectangle with respect to
 * the reference rectangle.
 *
 * A padding (positive or negative) may be passed to influence
 * horizontal / vertical orientation and intersection.
 *
 * @param {Bounds} rect
 * @param {Bounds} reference
 * @param {Point|number} padding
 *
 * @return {string} the orientation; one of top, top-left, left, ..., bottom, right or intersect.
 */
function getOrientation(rect, reference, padding) {

  padding = padding || 0;

  // make sure we can use an object, too
  // for individual { x, y } padding
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isObject)(padding)) {
    padding = { x: padding, y: padding };
  }


  var rectOrientation = asTRBL(rect),
      referenceOrientation = asTRBL(reference);

  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,
      right = rectOrientation.left - padding.x >= referenceOrientation.right,
      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,
      left = rectOrientation.right + padding.x <= referenceOrientation.left;

  var vertical = top ? 'top' : (bottom ? 'bottom' : null),
      horizontal = left ? 'left' : (right ? 'right' : null);

  if (horizontal && vertical) {
    return vertical + '-' + horizontal;
  } else {
    return horizontal || vertical || 'intersect';
  }
}


// intersection utils //////////////////////

/**
 * Get intersection between an element and a line path.
 *
 * @param {PathDef} elementPath
 * @param {PathDef} linePath
 * @param {boolean} cropStart crop from start or end
 *
 * @return {Point}
 */
function getElementLineIntersection(elementPath, linePath, cropStart) {

  var intersections = getIntersections(elementPath, linePath);

  // recognize intersections
  // only one -> choose
  // two close together -> choose first
  // two or more distinct -> pull out appropriate one
  // none -> ok (fallback to point itself)
  if (intersections.length === 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length === 2 && (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_2__.pointDistance)(intersections[0], intersections[1]) < 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length > 1) {

    // sort by intersections based on connection segment +
    // distance from start
    intersections = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.sortBy)(intersections, function(i) {
      var distance = Math.floor(i.t2 * 100) || 1;

      distance = 100 - distance;

      distance = (distance < 10 ? '0' : '') + distance;

      // create a sort string that makes sure we sort
      // line segment ASC + line segment position DESC (for cropStart)
      // line segment ASC + line segment position ASC (for cropEnd)
      return i.segment2 + '#' + distance;
    });

    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
  }

  return null;
}


function getIntersections(a, b) {
  return path_intersection__WEBPACK_IMPORTED_MODULE_0___default()(a, b);
}


function filterRedundantWaypoints(waypoints) {

  // alter copy of waypoints, not original
  waypoints = waypoints.slice();

  var idx = 0,
      point,
      previousPoint,
      nextPoint;

  while (waypoints[idx]) {
    point = waypoints[idx];
    previousPoint = waypoints[idx - 1];
    nextPoint = waypoints[idx + 1];

    if ((0,_util_Geometry__WEBPACK_IMPORTED_MODULE_2__.pointDistance)(point, nextPoint) === 0 ||
        (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_2__.pointsOnLine)(previousPoint, nextPoint, point)) {

      // remove point, if overlapping with {nextPoint}
      // or on line with {previousPoint} -> {point} -> {nextPoint}
      waypoints.splice(idx, 1);
    } else {
      idx++;
    }
  }

  return waypoints;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/model/index.js":
/*!****************************************************!*\
  !*** ./node_modules/diagram-js/lib/model/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Base": () => (/* binding */ Base),
/* harmony export */   "Shape": () => (/* binding */ Shape),
/* harmony export */   "Root": () => (/* binding */ Root),
/* harmony export */   "Label": () => (/* binding */ Label),
/* harmony export */   "Connection": () => (/* binding */ Connection),
/* harmony export */   "create": () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! object-refs */ "./node_modules/object-refs/index.js");
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(object_refs__WEBPACK_IMPORTED_MODULE_1__);





var parentRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_1___default())({ name: 'children', enumerable: true, collection: true }, { name: 'parent' }),
    labelRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_1___default())({ name: 'labels', enumerable: true, collection: true }, { name: 'labelTarget' }),
    attacherRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_1___default())({ name: 'attachers', collection: true }, { name: 'host' }),
    outgoingRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_1___default())({ name: 'outgoing', collection: true }, { name: 'source' }),
    incomingRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_1___default())({ name: 'incoming', collection: true }, { name: 'target' });

/**
 * @namespace djs.model
 */

/**
 * @memberOf djs.model
 */

/**
 * The basic graphical representation
 *
 * @class
 *
 * @abstract
 */
function Base() {

  /**
   * The object that backs up the shape
   *
   * @name Base#businessObject
   * @type Object
   */
  Object.defineProperty(this, 'businessObject', {
    writable: true
  });


  /**
   * Single label support, will mapped to multi label array
   *
   * @name Base#label
   * @type Object
   */
  Object.defineProperty(this, 'label', {
    get: function() {
      return this.labels[0];
    },
    set: function(newLabel) {

      var label = this.label,
          labels = this.labels;

      if (!newLabel && label) {
        labels.remove(label);
      } else {
        labels.add(newLabel, 0);
      }
    }
  });

  /**
   * The parent shape
   *
   * @name Base#parent
   * @type Shape
   */
  parentRefs.bind(this, 'parent');

  /**
   * The list of labels
   *
   * @name Base#labels
   * @type Label
   */
  labelRefs.bind(this, 'labels');

  /**
   * The list of outgoing connections
   *
   * @name Base#outgoing
   * @type Array<Connection>
   */
  outgoingRefs.bind(this, 'outgoing');

  /**
   * The list of incoming connections
   *
   * @name Base#incoming
   * @type Array<Connection>
   */
  incomingRefs.bind(this, 'incoming');
}


/**
 * A graphical object
 *
 * @class
 * @constructor
 *
 * @extends Base
 */
function Shape() {
  Base.call(this);

  /**
   * Indicates frame shapes
   *
   * @name Shape#isFrame
   * @type boolean
   */

  /**
   * The list of children
   *
   * @name Shape#children
   * @type Array<Base>
   */
  parentRefs.bind(this, 'children');

  /**
   * @name Shape#host
   * @type Shape
   */
  attacherRefs.bind(this, 'host');

  /**
   * @name Shape#attachers
   * @type Shape
   */
  attacherRefs.bind(this, 'attachers');
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Shape, Base);


/**
 * A root graphical object
 *
 * @class
 * @constructor
 *
 * @extends Shape
 */
function Root() {
  Shape.call(this);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Root, Shape);


/**
 * A label for an element
 *
 * @class
 * @constructor
 *
 * @extends Shape
 */
function Label() {
  Shape.call(this);

  /**
   * The labeled element
   *
   * @name Label#labelTarget
   * @type Base
   */
  labelRefs.bind(this, 'labelTarget');
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Label, Shape);


/**
 * A connection between two elements
 *
 * @class
 * @constructor
 *
 * @extends Base
 */
function Connection() {
  Base.call(this);

  /**
   * The element this connection originates from
   *
   * @name Connection#source
   * @type Base
   */
  outgoingRefs.bind(this, 'source');

  /**
   * The element this connection points to
   *
   * @name Connection#target
   * @type Base
   */
  incomingRefs.bind(this, 'target');
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Connection, Base);


var types = {
  connection: Connection,
  shape: Shape,
  label: Label,
  root: Root
};

/**
 * Creates a new model element of the specified type
 *
 * @method create
 *
 * @example
 *
 * var shape1 = Model.create('shape', { x: 10, y: 10, width: 100, height: 100 });
 * var shape2 = Model.create('shape', { x: 210, y: 210, width: 100, height: 100 });
 *
 * var connection = Model.create('connection', { waypoints: [ { x: 110, y: 55 }, {x: 210, y: 55 } ] });
 *
 * @param  {string} type lower-cased model name
 * @param  {Object} attrs attributes to initialize the new model instance with
 *
 * @return {Base} the new model instance
 */
function create(type, attrs) {
  var Type = types[type];
  if (!Type) {
    throw new Error('unknown type: <' + type + '>');
  }
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(new Type(), attrs);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/keyboard-move/KeyboardMove.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/keyboard-move/KeyboardMove.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ KeyboardMove)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



var DEFAULT_CONFIG = {
  moveSpeed: 50,
  moveSpeedAccelerated: 200
};


/**
 * A feature that allows users to move the canvas using the keyboard.
 *
 * @param {Object} config
 * @param {number} [config.moveSpeed=50]
 * @param {number} [config.moveSpeedAccelerated=200]
 * @param {Keyboard} keyboard
 * @param {Canvas} canvas
 */
function KeyboardMove(
    config,
    keyboard,
    canvas
) {

  var self = this;

  this._config = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, DEFAULT_CONFIG, config || {});

  keyboard.addListener(arrowsListener);


  function arrowsListener(context) {

    var event = context.keyEvent,
        config = self._config;

    if (!keyboard.isCmd(event)) {
      return;
    }

    if (keyboard.isKey([
      'ArrowLeft', 'Left',
      'ArrowUp', 'Up',
      'ArrowDown', 'Down',
      'ArrowRight', 'Right'
    ], event)) {

      var speed = (
        keyboard.isShift(event) ?
          config.moveSpeedAccelerated :
          config.moveSpeed
      );

      var direction;

      switch (event.key) {
      case 'ArrowLeft':
      case 'Left':
        direction = 'left';
        break;
      case 'ArrowUp':
      case 'Up':
        direction = 'up';
        break;
      case 'ArrowRight':
      case 'Right':
        direction = 'right';
        break;
      case 'ArrowDown':
      case 'Down':
        direction = 'down';
        break;
      }

      self.moveCanvas({
        speed: speed,
        direction: direction
      });

      return true;
    }
  }

  this.moveCanvas = function(opts) {

    var dx = 0,
        dy = 0,
        speed = opts.speed;

    var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);

    switch (opts.direction) {
    case 'left': // Left
      dx = actualSpeed;
      break;
    case 'up': // Up
      dy = actualSpeed;
      break;
    case 'right': // Right
      dx = -actualSpeed;
      break;
    case 'down': // Down
      dy = -actualSpeed;
      break;
    }

    canvas.scroll({
      dx: dx,
      dy: dy
    });
  };

}


KeyboardMove.$inject = [
  'config.keyboardMove',
  'keyboard',
  'canvas'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/keyboard-move/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/keyboard-move/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _features_keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../features/keyboard */ "./node_modules/diagram-js/lib/features/keyboard/index.js");
/* harmony import */ var _KeyboardMove__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyboardMove */ "./node_modules/diagram-js/lib/navigation/keyboard-move/KeyboardMove.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _features_keyboard__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'keyboardMove' ],
  keyboardMove: [ 'type', _KeyboardMove__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js":
/*!*************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveCanvas)
/* harmony export */ });
/* harmony import */ var _util_Cursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Cursor */ "./node_modules/diagram-js/lib/util/Cursor.js");
/* harmony import */ var _util_ClickTrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/ClickTrap */ "./node_modules/diagram-js/lib/util/ClickTrap.js");
/* harmony import */ var _util_PositionUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/PositionUtil */ "./node_modules/diagram-js/lib/util/PositionUtil.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");











var THRESHOLD = 15;


/**
 * Move the canvas via mouse.
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function MoveCanvas(eventBus, canvas) {

  var context;


  // listen for move on element mouse down;
  // allow others to hook into the event before us though
  // (dragging / element moving will do this)
  eventBus.on('element.mousedown', 500, function(e) {
    return handleStart(e.originalEvent);
  });


  function handleMove(event) {

    var start = context.start,
        button = context.button,
        position = (0,_util_Event__WEBPACK_IMPORTED_MODULE_0__.toPoint)(event),
        delta = (0,_util_PositionUtil__WEBPACK_IMPORTED_MODULE_1__.delta)(position, start);

    if (!context.dragging && length(delta) > THRESHOLD) {
      context.dragging = true;

      if (button === 0) {
        (0,_util_ClickTrap__WEBPACK_IMPORTED_MODULE_2__.install)(eventBus);
      }

      (0,_util_Cursor__WEBPACK_IMPORTED_MODULE_3__.set)('grab');
    }

    if (context.dragging) {

      var lastPosition = context.last || context.start;

      delta = (0,_util_PositionUtil__WEBPACK_IMPORTED_MODULE_1__.delta)(position, lastPosition);

      canvas.scroll({
        dx: delta.x,
        dy: delta.y
      });

      context.last = position;
    }

    // prevent select
    event.preventDefault();
  }


  function handleEnd(event) {
    min_dom__WEBPACK_IMPORTED_MODULE_4__.event.unbind(document, 'mousemove', handleMove);
    min_dom__WEBPACK_IMPORTED_MODULE_4__.event.unbind(document, 'mouseup', handleEnd);

    context = null;

    (0,_util_Cursor__WEBPACK_IMPORTED_MODULE_3__.unset)();
  }

  function handleStart(event) {

    // event is already handled by '.djs-draggable'
    if ((0,min_dom__WEBPACK_IMPORTED_MODULE_4__.closest)(event.target, '.djs-draggable')) {
      return;
    }

    var button = event.button;

    // reject right mouse button or modifier key
    if (button >= 2 || event.ctrlKey || event.shiftKey || event.altKey) {
      return;
    }

    context = {
      button: button,
      start: (0,_util_Event__WEBPACK_IMPORTED_MODULE_0__.toPoint)(event)
    };

    min_dom__WEBPACK_IMPORTED_MODULE_4__.event.bind(document, 'mousemove', handleMove);
    min_dom__WEBPACK_IMPORTED_MODULE_4__.event.bind(document, 'mouseup', handleEnd);

    // we've handled the event
    return true;
  }

  this.isActive = function() {
    return !!context;
  };

}


MoveCanvas.$inject = [
  'eventBus',
  'canvas'
];



// helpers ///////

function length(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/movecanvas/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/movecanvas/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MoveCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MoveCanvas */ "./node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'moveCanvas' ],
  moveCanvas: [ 'type', _MoveCanvas__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/touch/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/touch/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _features_touch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../features/touch */ "./node_modules/diagram-js/lib/features/touch/index.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _features_touch__WEBPACK_IMPORTED_MODULE_0__.default
  ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js":
/*!*************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZoomScroll)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _ZoomUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ZoomUtil */ "./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomUtil.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Math */ "./node_modules/diagram-js/lib/util/Math.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");








var sign = Math.sign || function(n) {
  return n >= 0 ? 1 : -1;
};

var RANGE = { min: 0.2, max: 4 },
    NUM_STEPS = 10;

var DELTA_THRESHOLD = 0.1;

var DEFAULT_SCALE = 0.75;

/**
 * An implementation of zooming and scrolling within the
 * {@link Canvas} via the mouse wheel.
 *
 * Mouse wheel zooming / scrolling may be disabled using
 * the {@link toggle(enabled)} method.
 *
 * @param {Object} [config]
 * @param {boolean} [config.enabled=true] default enabled state
 * @param {number} [config.scale=.75] scroll sensivity
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function ZoomScroll(config, eventBus, canvas) {

  config = config || {};

  this._enabled = false;

  this._canvas = canvas;
  this._container = canvas._container;

  this._handleWheel = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(this._handleWheel, this);

  this._totalDelta = 0;
  this._scale = config.scale || DEFAULT_SCALE;

  var self = this;

  eventBus.on('canvas.init', function(e) {
    self._init(config.enabled !== false);
  });
}

ZoomScroll.$inject = [
  'config.zoomScroll',
  'eventBus',
  'canvas'
];

ZoomScroll.prototype.scroll = function scroll(delta) {
  this._canvas.scroll(delta);
};


ZoomScroll.prototype.reset = function reset() {
  this._canvas.zoom('fit-viewport');
};

/**
 * Zoom depending on delta.
 *
 * @param {number} delta
 * @param {Object} position
 */
ZoomScroll.prototype.zoom = function zoom(delta, position) {

  // zoom with half the step size of stepZoom
  var stepSize = (0,_ZoomUtil__WEBPACK_IMPORTED_MODULE_1__.getStepSize)(RANGE, NUM_STEPS * 2);

  // add until threshold reached
  this._totalDelta += delta;

  if (Math.abs(this._totalDelta) > DELTA_THRESHOLD) {
    this._zoom(delta, position, stepSize);

    // reset
    this._totalDelta = 0;
  }
};


ZoomScroll.prototype._handleWheel = function handleWheel(event) {

  // event is already handled by '.djs-scrollable'
  if ((0,min_dom__WEBPACK_IMPORTED_MODULE_2__.closest)(event.target, '.djs-scrollable', true)) {
    return;
  }

  var element = this._container;

  event.preventDefault();

  // pinch to zoom is mapped to wheel + ctrlKey = true
  // in modern browsers (!)

  var isZoom = event.ctrlKey;

  var isHorizontalScroll = event.shiftKey;

  var factor = -1 * this._scale,
      delta;

  if (isZoom) {
    factor *= event.deltaMode === 0 ? 0.020 : 0.32;
  } else {
    factor *= event.deltaMode === 0 ? 1.0 : 16.0;
  }

  if (isZoom) {
    var elementRect = element.getBoundingClientRect();

    var offset = {
      x: event.clientX - elementRect.left,
      y: event.clientY - elementRect.top
    };

    delta = (
      Math.sqrt(
        Math.pow(event.deltaY, 2) +
        Math.pow(event.deltaX, 2)
      ) * sign(event.deltaY) * factor
    );

    // zoom in relative to diagram {x,y} coordinates
    this.zoom(delta, offset);
  } else {

    if (isHorizontalScroll) {
      delta = {
        dx: factor * event.deltaY,
        dy: 0
      };
    } else {
      delta = {
        dx: factor * event.deltaX,
        dy: factor * event.deltaY
      };
    }

    this.scroll(delta);
  }
};

/**
 * Zoom with fixed step size.
 *
 * @param {number} delta - Zoom delta (1 for zooming in, -1 for out).
 * @param {Object} position
 */
ZoomScroll.prototype.stepZoom = function stepZoom(delta, position) {

  var stepSize = (0,_ZoomUtil__WEBPACK_IMPORTED_MODULE_1__.getStepSize)(RANGE, NUM_STEPS);

  this._zoom(delta, position, stepSize);
};


/**
 * Zoom in/out given a step size.
 *
 * @param {number} delta
 * @param {Object} position
 * @param {number} stepSize
 */
ZoomScroll.prototype._zoom = function(delta, position, stepSize) {
  var canvas = this._canvas;

  var direction = delta > 0 ? 1 : -1;

  var currentLinearZoomLevel = (0,_util_Math__WEBPACK_IMPORTED_MODULE_3__.log10)(canvas.zoom());

  // snap to a proximate zoom step
  var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;

  // increase or decrease one zoom step in the given direction
  newLinearZoomLevel += stepSize * direction;

  // calculate the absolute logarithmic zoom level based on the linear zoom level
  // (e.g. 2 for an absolute x2 zoom)
  var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);

  canvas.zoom((0,_ZoomUtil__WEBPACK_IMPORTED_MODULE_1__.cap)(RANGE, newLogZoomLevel), position);
};


/**
 * Toggle the zoom scroll ability via mouse wheel.
 *
 * @param  {boolean} [newEnabled] new enabled state
 */
ZoomScroll.prototype.toggle = function toggle(newEnabled) {

  var element = this._container;
  var handleWheel = this._handleWheel;

  var oldEnabled = this._enabled;

  if (typeof newEnabled === 'undefined') {
    newEnabled = !oldEnabled;
  }

  // only react on actual changes
  if (oldEnabled !== newEnabled) {

    // add or remove wheel listener based on
    // changed enabled state
    min_dom__WEBPACK_IMPORTED_MODULE_2__.event[newEnabled ? 'bind' : 'unbind'](element, 'wheel', handleWheel, false);
  }

  this._enabled = newEnabled;

  return newEnabled;
};


ZoomScroll.prototype._init = function(newEnabled) {
  this.toggle(newEnabled);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomUtil.js":
/*!***********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomUtil.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getStepSize": () => (/* binding */ getStepSize),
/* harmony export */   "cap": () => (/* binding */ cap)
/* harmony export */ });
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Math */ "./node_modules/diagram-js/lib/util/Math.js");


/**
 * Get step size for given range and number of steps.
 *
 * @param {Object} range
 * @param {number} range.min
 * @param {number} range.max
 */
function getStepSize(range, steps) {

  var minLinearRange = (0,_util_Math__WEBPACK_IMPORTED_MODULE_0__.log10)(range.min),
      maxLinearRange = (0,_util_Math__WEBPACK_IMPORTED_MODULE_0__.log10)(range.max);

  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);

  return absoluteLinearRange / steps;
}

function cap(range, scale) {
  return Math.max(range.min, Math.min(range.max, scale));
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/zoomscroll/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/zoomscroll/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ZoomScroll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ZoomScroll */ "./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'zoomScroll' ],
  zoomScroll: [ 'type', _ZoomScroll__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/AttachUtil.js":
/*!********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/AttachUtil.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNewAttachPoint": () => (/* binding */ getNewAttachPoint),
/* harmony export */   "getNewAttachShapeDelta": () => (/* binding */ getNewAttachShapeDelta)
/* harmony export */ });
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var _PositionUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PositionUtil */ "./node_modules/diagram-js/lib/util/PositionUtil.js");





/**
 * Calculates the absolute point relative to the new element's position
 *
 * @param {point} point [absolute]
 * @param {bounds} oldBounds
 * @param {bounds} newBounds
 *
 * @return {point} point [absolute]
 */
function getNewAttachPoint(point, oldBounds, newBounds) {
  var oldCenter = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.center)(oldBounds),
      newCenter = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.center)(newBounds),
      oldDelta = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.delta)(point, oldCenter);

  var newDelta = {
    x: oldDelta.x * (newBounds.width / oldBounds.width),
    y: oldDelta.y * (newBounds.height / oldBounds.height)
  };

  return (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.roundPoint)({
    x: newCenter.x + newDelta.x,
    y: newCenter.y + newDelta.y
  });
}


/**
 * Calculates the shape's delta relative to a new position
 * of a certain element's bounds
 *
 * @param {djs.model.Shape} point [absolute]
 * @param {bounds} oldBounds
 * @param {bounds} newBounds
 *
 * @return {delta} delta
 */
function getNewAttachShapeDelta(shape, oldBounds, newBounds) {
  var shapeCenter = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.center)(shape),
      oldCenter = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.center)(oldBounds),
      newCenter = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.center)(newBounds),
      shapeDelta = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.delta)(shape, shapeCenter),
      oldCenterDelta = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.delta)(shapeCenter, oldCenter),
      stickyPositionDelta = getStickyPositionDelta(shapeCenter, oldBounds, newBounds);

  if (stickyPositionDelta) {
    return stickyPositionDelta;
  }

  var newCenterDelta = {
    x: oldCenterDelta.x * (newBounds.width / oldBounds.width),
    y: oldCenterDelta.y * (newBounds.height / oldBounds.height)
  };

  var newShapeCenter = {
    x: newCenter.x + newCenterDelta.x,
    y: newCenter.y + newCenterDelta.y
  };

  return (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.roundPoint)({
    x: newShapeCenter.x + shapeDelta.x - shape.x,
    y: newShapeCenter.y + shapeDelta.y - shape.y
  });
}

function getStickyPositionDelta(oldShapeCenter, oldBounds, newBounds) {
  var oldTRBL = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(oldBounds),
      newTRBL = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(newBounds);

  if (isMoved(oldTRBL, newTRBL)) {
    return null;
  }

  var oldOrientation = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getOrientation)(oldBounds, oldShapeCenter),
      stickyPositionDelta,
      newShapeCenter,
      newOrientation;

  if (oldOrientation === 'top') {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.bottom - oldTRBL.bottom
    };
  } else if (oldOrientation === 'bottom') {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.top - oldTRBL.top
    };
  } else if (oldOrientation === 'right') {
    stickyPositionDelta = {
      x: newTRBL.left - oldTRBL.left,
      y: 0
    };
  } else if (oldOrientation === 'left') {
    stickyPositionDelta = {
      x: newTRBL.right - oldTRBL.right,
      y: 0
    };
  } else {

    // fallback to proportional movement for corner-placed attachments
    return null;
  }

  newShapeCenter = {
    x: oldShapeCenter.x + stickyPositionDelta.x,
    y: oldShapeCenter.y + stickyPositionDelta.y
  };

  newOrientation = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getOrientation)(newBounds, newShapeCenter);

  if (newOrientation !== oldOrientation) {

    // fallback to proportional movement if orientation would otherwise change
    return null;
  }

  return stickyPositionDelta;
}

function isMoved(oldTRBL, newTRBL) {
  return isHorizontallyMoved(oldTRBL, newTRBL) || isVerticallyMoved(oldTRBL, newTRBL);
}

function isHorizontallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.right !== newTRBL.right && oldTRBL.left !== newTRBL.left;
}

function isVerticallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.top !== newTRBL.top && oldTRBL.bottom !== newTRBL.bottom;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/ClickTrap.js":
/*!*******************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/ClickTrap.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
var TRAP_PRIORITY = 5000;

/**
 * Installs a click trap that prevents a ghost click following a dragging operation.
 *
 * @return {Function} a function to immediately remove the installed trap.
 */
function install(eventBus, eventName) {

  eventName = eventName || 'element.click';

  function trap() {
    return false;
  }

  eventBus.once(eventName, TRAP_PRIORITY, trap);

  return function() {
    eventBus.off(eventName, trap);
  };
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Collections.js":
/*!*********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Collections.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "indexOf": () => (/* binding */ indexOf)
/* harmony export */ });
/**
 * Failsafe remove an element from a collection
 *
 * @param  {Array<Object>} [collection]
 * @param  {Object} [element]
 *
 * @return {number} the previous index of the element
 */
function remove(collection, element) {

  if (!collection || !element) {
    return -1;
  }

  var idx = collection.indexOf(element);

  if (idx !== -1) {
    collection.splice(idx, 1);
  }

  return idx;
}

/**
 * Fail save add an element to the given connection, ensuring
 * it does not yet exist.
 *
 * @param {Array<Object>} collection
 * @param {Object} element
 * @param {number} idx
 */
function add(collection, element, idx) {

  if (!collection || !element) {
    return;
  }

  if (typeof idx !== 'number') {
    idx = -1;
  }

  var currentIdx = collection.indexOf(element);

  if (currentIdx !== -1) {

    if (currentIdx === idx) {

      // nothing to do, position has not changed
      return;
    } else {

      if (idx !== -1) {

        // remove from current position
        collection.splice(currentIdx, 1);
      } else {

        // already exists in collection
        return;
      }
    }
  }

  if (idx !== -1) {

    // insert at specified position
    collection.splice(idx, 0, element);
  } else {

    // push to end
    collection.push(element);
  }
}


/**
 * Fail save get the index of an element in a collection.
 *
 * @param {Array<Object>} collection
 * @param {Object} element
 *
 * @return {number} the index or -1 if collection or element do
 *                  not exist or the element is not contained.
 */
function indexOf(collection, element) {

  if (!collection || !element) {
    return -1;
  }

  return collection.indexOf(element);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Cursor.js":
/*!****************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Cursor.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "unset": () => (/* binding */ unset),
/* harmony export */   "has": () => (/* binding */ has)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");


var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;


function set(mode) {
  var classes = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(document.body);

  classes.removeMatching(CURSOR_CLS_PATTERN);

  if (mode) {
    classes.add('djs-cursor-' + mode);
  }
}

function unset() {
  set(null);
}

function has(mode) {
  var classes = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(document.body);

  return classes.has('djs-cursor-' + mode);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Elements.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Elements.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getParents": () => (/* binding */ getParents),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "eachElement": () => (/* binding */ eachElement),
/* harmony export */   "selfAndChildren": () => (/* binding */ selfAndChildren),
/* harmony export */   "selfAndDirectChildren": () => (/* binding */ selfAndDirectChildren),
/* harmony export */   "selfAndAllChildren": () => (/* binding */ selfAndAllChildren),
/* harmony export */   "getClosure": () => (/* binding */ getClosure),
/* harmony export */   "getBBox": () => (/* binding */ getBBox),
/* harmony export */   "getEnclosedElements": () => (/* binding */ getEnclosedElements),
/* harmony export */   "getType": () => (/* binding */ getType),
/* harmony export */   "isFrameElement": () => (/* binding */ isFrameElement)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * Get parent elements.
 *
 * @param {Array<djs.model.base>} elements
 *
 * @returns {Array<djs.model.Base>}
 */
function getParents(elements) {

  // find elements that are not children of any other elements
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.filter)(elements, function(element) {
    return !(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, function(e) {
      return e !== element && getParent(element, e);
    });
  });
}


function getParent(element, parent) {
  if (!parent) {
    return;
  }

  if (element === parent) {
    return parent;
  }

  if (!element.parent) {
    return;
  }

  return getParent(element.parent, parent);
}


/**
 * Adds an element to a collection and returns true if the
 * element was added.
 *
 * @param {Array<Object>} elements
 * @param {Object} e
 * @param {boolean} unique
 */
function add(elements, e, unique) {
  var canAdd = !unique || elements.indexOf(e) === -1;

  if (canAdd) {
    elements.push(e);
  }

  return canAdd;
}


/**
 * Iterate over each element in a collection, calling the iterator function `fn`
 * with (element, index, recursionDepth).
 *
 * Recurse into all elements that are returned by `fn`.
 *
 * @param  {Object|Array<Object>} elements
 * @param  {Function} fn iterator function called with (element, index, recursionDepth)
 * @param  {number} [depth] maximum recursion depth
 */
function eachElement(elements, fn, depth) {

  depth = depth || 0;

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements)) {
    elements = [ elements ];
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(s, i) {
    var filter = fn(s, i, depth);

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(filter) && filter.length) {
      eachElement(filter, fn, depth + 1);
    }
  });
}


/**
 * Collects self + child elements up to a given depth from a list of elements.
 *
 * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from
 * @param  {boolean} unique whether to return a unique result set (no duplicates)
 * @param  {number} maxDepth the depth to search through or -1 for infinite
 *
 * @return {Array<djs.model.Base>} found elements
 */
function selfAndChildren(elements, unique, maxDepth) {
  var result = [],
      processedChildren = [];

  eachElement(elements, function(element, i, depth) {
    add(result, element, unique);

    var children = element.children;

    // max traversal depth not reached yet
    if (maxDepth === -1 || depth < maxDepth) {

      // children exist && children not yet processed
      if (children && add(processedChildren, children, unique)) {
        return children;
      }
    }
  });

  return result;
}

/**
 * Return self + direct children for a number of elements
 *
 * @param  {Array<djs.model.Base>} elements to query
 * @param  {boolean} allowDuplicates to allow duplicates in the result set
 *
 * @return {Array<djs.model.Base>} the collected elements
 */
function selfAndDirectChildren(elements, allowDuplicates) {
  return selfAndChildren(elements, !allowDuplicates, 1);
}


/**
 * Return self + ALL children for a number of elements
 *
 * @param  {Array<djs.model.Base>} elements to query
 * @param  {boolean} allowDuplicates to allow duplicates in the result set
 *
 * @return {Array<djs.model.Base>} the collected elements
 */
function selfAndAllChildren(elements, allowDuplicates) {
  return selfAndChildren(elements, !allowDuplicates, -1);
}


/**
 * Gets the the closure for all selected elements,
 * their enclosed children and connections.
 *
 * @param {Array<djs.model.Base>} elements
 * @param {boolean} [isTopLevel=true]
 * @param {Object} [existingClosure]
 *
 * @return {Object} newClosure
 */
function getClosure(elements, isTopLevel, closure) {

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(isTopLevel)) {
    isTopLevel = true;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(isTopLevel)) {
    closure = isTopLevel;
    isTopLevel = true;
  }


  closure = closure || {};

  var allShapes = copyObject(closure.allShapes),
      allConnections = copyObject(closure.allConnections),
      enclosedElements = copyObject(closure.enclosedElements),
      enclosedConnections = copyObject(closure.enclosedConnections);

  var topLevel = copyObject(
    closure.topLevel,
    isTopLevel && (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.groupBy)(elements, function(e) { return e.id; })
  );


  function handleConnection(c) {
    if (topLevel[c.source.id] && topLevel[c.target.id]) {
      topLevel[c.id] = [ c ];
    }

    // not enclosed as a child, but maybe logically
    // (connecting two moved elements?)
    if (allShapes[c.source.id] && allShapes[c.target.id]) {
      enclosedConnections[c.id] = enclosedElements[c.id] = c;
    }

    allConnections[c.id] = c;
  }

  function handleElement(element) {

    enclosedElements[element.id] = element;

    if (element.waypoints) {

      // remember connection
      enclosedConnections[element.id] = allConnections[element.id] = element;
    } else {

      // remember shape
      allShapes[element.id] = element;

      // remember all connections
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(element.incoming, handleConnection);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(element.outgoing, handleConnection);

      // recurse into children
      return element.children;
    }
  }

  eachElement(elements, handleElement);

  return {
    allShapes: allShapes,
    allConnections: allConnections,
    topLevel: topLevel,
    enclosedConnections: enclosedConnections,
    enclosedElements: enclosedElements
  };
}

/**
 * Returns the surrounding bbox for all elements in
 * the array or the element primitive.
 *
 * @param {Array<djs.model.Shape>|djs.model.Shape} elements
 * @param {boolean} stopRecursion
 */
function getBBox(elements, stopRecursion) {

  stopRecursion = !!stopRecursion;
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements)) {
    elements = [elements];
  }

  var minX,
      minY,
      maxX,
      maxY;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {

    // If element is a connection the bbox must be computed first
    var bbox = element;
    if (element.waypoints && !stopRecursion) {
      bbox = getBBox(element.waypoints, true);
    }

    var x = bbox.x,
        y = bbox.y,
        height = bbox.height || 0,
        width = bbox.width || 0;

    if (x < minX || minX === undefined) {
      minX = x;
    }
    if (y < minY || minY === undefined) {
      minY = y;
    }

    if ((x + width) > maxX || maxX === undefined) {
      maxX = x + width;
    }
    if ((y + height) > maxY || maxY === undefined) {
      maxY = y + height;
    }
  });

  return {
    x: minX,
    y: minY,
    height: maxY - minY,
    width: maxX - minX
  };
}


/**
 * Returns all elements that are enclosed from the bounding box.
 *
 *   * If bbox.(width|height) is not specified the method returns
 *     all elements with element.x/y > bbox.x/y
 *   * If only bbox.x or bbox.y is specified, method return all elements with
 *     e.x > bbox.x or e.y > bbox.y
 *
 * @param {Array<djs.model.Shape>} elements List of Elements to search through
 * @param {djs.model.Shape} bbox the enclosing bbox.
 *
 * @return {Array<djs.model.Shape>} enclosed elements
 */
function getEnclosedElements(elements, bbox) {

  var filteredElements = {};

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {

    var e = element;

    if (e.waypoints) {
      e = getBBox(e);
    }

    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.y) && (e.x > bbox.x)) {
      filteredElements[element.id] = element;
    }
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.x) && (e.y > bbox.y)) {
      filteredElements[element.id] = element;
    }
    if (e.x > bbox.x && e.y > bbox.y) {
      if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.width) && (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.height) &&
          e.width + e.x < bbox.width + bbox.x &&
          e.height + e.y < bbox.height + bbox.y) {

        filteredElements[element.id] = element;
      } else if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.width) || !(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.height)) {
        filteredElements[element.id] = element;
      }
    }
  });

  return filteredElements;
}


function getType(element) {

  if ('waypoints' in element) {
    return 'connection';
  }

  if ('x' in element) {
    return 'shape';
  }

  return 'root';
}

function isFrameElement(element) {

  return !!(element && element.isFrame);
}

// helpers ///////////////////////////////

function copyObject(src1, src2) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, src1 || {}, src2 || {});
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Event.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Event.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOriginal": () => (/* binding */ getOriginal),
/* harmony export */   "stopPropagation": () => (/* binding */ stopPropagation),
/* harmony export */   "toPoint": () => (/* binding */ toPoint)
/* harmony export */ });
function __stopPropagation(event) {
  if (!event || typeof event.stopPropagation !== 'function') {
    return;
  }

  event.stopPropagation();
}


function getOriginal(event) {
  return event.originalEvent || event.srcEvent;
}


function stopPropagation(event, immediate) {
  __stopPropagation(event, immediate);
  __stopPropagation(getOriginal(event), immediate);
}


function toPoint(event) {

  if (event.pointers && event.pointers.length) {
    event = event.pointers[0];
  }

  if (event.touches && event.touches.length) {
    event = event.touches[0];
  }

  return event ? {
    x: event.clientX,
    y: event.clientY
  } : null;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Geometry.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Geometry.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pointDistance": () => (/* binding */ pointDistance),
/* harmony export */   "pointsOnLine": () => (/* binding */ pointsOnLine),
/* harmony export */   "pointsAligned": () => (/* binding */ pointsAligned),
/* harmony export */   "pointsAlignedHorizontally": () => (/* binding */ pointsAlignedHorizontally),
/* harmony export */   "pointsAlignedVertically": () => (/* binding */ pointsAlignedVertically),
/* harmony export */   "pointInRect": () => (/* binding */ pointInRect),
/* harmony export */   "getMidPoint": () => (/* binding */ getMidPoint)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * Computes the distance between two points
 *
 * @param  {Point}  p
 * @param  {Point}  q
 *
 * @return {number}  distance
 */
function pointDistance(a, b) {
  if (!a || !b) {
    return -1;
  }

  return Math.sqrt(
    Math.pow(a.x - b.x, 2) +
    Math.pow(a.y - b.y, 2)
  );
}


/**
 * Returns true if the point r is on the line between p and q
 *
 * @param  {Point}  p
 * @param  {Point}  q
 * @param  {Point}  r
 * @param  {number} [accuracy=5] accuracy for points on line check (lower is better)
 *
 * @return {boolean}
 */
function pointsOnLine(p, q, r, accuracy) {

  if (typeof accuracy === 'undefined') {
    accuracy = 5;
  }

  if (!p || !q || !r) {
    return false;
  }

  var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),
      dist = pointDistance(p, q);

  // @see http://stackoverflow.com/a/907491/412190
  return Math.abs(val / dist) <= accuracy;
}


var ALIGNED_THRESHOLD = 2;

/**
 * Check whether two points are horizontally or vertically aligned.
 *
 * @param {Array<Point>|Point}
 * @param {Point}
 *
 * @return {string|boolean}
 */
function pointsAligned(a, b) {
  var points;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(a)) {
    points = a;
  } else {
    points = [ a, b ];
  }

  if (pointsAlignedHorizontally(points)) {
    return 'h';
  }

  if (pointsAlignedVertically(points)) {
    return 'v';
  }

  return false;
}

function pointsAlignedHorizontally(a, b) {
  var points;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(a)) {
    points = a;
  } else {
    points = [ a, b ];
  }

  var firstPoint = points.slice().shift();

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.every)(points, function(point) {
    return Math.abs(firstPoint.y - point.y) <= ALIGNED_THRESHOLD;
  });
}

function pointsAlignedVertically(a, b) {
  var points;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(a)) {
    points = a;
  } else {
    points = [ a, b ];
  }

  var firstPoint = points.slice().shift();

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.every)(points, function(point) {
    return Math.abs(firstPoint.x - point.x) <= ALIGNED_THRESHOLD;
  });
}



/**
 * Returns true if the point p is inside the rectangle rect
 *
 * @param  {Point}  p
 * @param  {Rect} rect
 * @param  {number} tolerance
 *
 * @return {boolean}
 */
function pointInRect(p, rect, tolerance) {
  tolerance = tolerance || 0;

  return p.x > rect.x - tolerance &&
         p.y > rect.y - tolerance &&
         p.x < rect.x + rect.width + tolerance &&
         p.y < rect.y + rect.height + tolerance;
}

/**
 * Returns a point in the middle of points p and q
 *
 * @param  {Point}  p
 * @param  {Point}  q
 *
 * @return {Point} middle point
 */
function getMidPoint(p, q) {
  return {
    x: Math.round(p.x + ((q.x - p.x) / 2.0)),
    y: Math.round(p.y + ((q.y - p.y) / 2.0))
  };
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/GraphicsUtil.js":
/*!**********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/GraphicsUtil.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getVisual": () => (/* binding */ getVisual),
/* harmony export */   "getChildren": () => (/* binding */ getChildren)
/* harmony export */ });
/**
 * SVGs for elements are generated by the {@link GraphicsFactory}.
 *
 * This utility gives quick access to the important semantic
 * parts of an element.
 */

/**
 * Returns the visual part of a diagram element
 *
 * @param {Snap<SVGElement>} gfx
 *
 * @return {Snap<SVGElement>}
 */
function getVisual(gfx) {
  return gfx.childNodes[0];
}

/**
 * Returns the children for a given diagram element.
 *
 * @param {Snap<SVGElement>} gfx
 * @return {Snap<SVGElement>}
 */
function getChildren(gfx) {
  return gfx.parentNode.childNodes[1];
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/IdGenerator.js":
/*!*********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/IdGenerator.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IdGenerator)
/* harmony export */ });
/**
 * Util that provides unique IDs.
 *
 * @class djs.util.IdGenerator
 * @constructor
 * @memberOf djs.util
 *
 * The ids can be customized via a given prefix and contain a random value to avoid collisions.
 *
 * @param {string} prefix a prefix to prepend to generated ids (for better readability)
 */
function IdGenerator(prefix) {

  this._counter = 0;
  this._prefix = (prefix ? prefix + '-' : '') + Math.floor(Math.random() * 1000000000) + '-';
}

/**
 * Returns a next unique ID.
 *
 * @method djs.util.IdGenerator#next
 *
 * @returns {string} the id
 */
IdGenerator.prototype.next = function() {
  return this._prefix + (++this._counter);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/LineIntersection.js":
/*!**************************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/LineIntersection.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getApproxIntersection": () => (/* binding */ getApproxIntersection)
/* harmony export */ });
/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Geometry */ "./node_modules/diagram-js/lib/util/Geometry.js");
/* harmony import */ var path_intersection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path-intersection */ "./node_modules/path-intersection/intersect.js");
/* harmony import */ var path_intersection__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path_intersection__WEBPACK_IMPORTED_MODULE_0__);




var round = Math.round,
    max = Math.max;


function circlePath(center, r) {
  var x = center.x,
      y = center.y;

  return [
    ['M', x, y],
    ['m', 0, -r],
    ['a', r, r, 0, 1, 1, 0, 2 * r],
    ['a', r, r, 0, 1, 1, 0, -2 * r],
    ['z']
  ];
}

function linePath(points) {
  var segments = [];

  points.forEach(function(p, idx) {
    segments.push([ idx === 0 ? 'M' : 'L', p.x, p.y ]);
  });

  return segments;
}


var INTERSECTION_THRESHOLD = 10;

function getBendpointIntersection(waypoints, reference) {

  var i, w;

  for (i = 0; (w = waypoints[i]); i++) {

    if ((0,_Geometry__WEBPACK_IMPORTED_MODULE_1__.pointDistance)(w, reference) <= INTERSECTION_THRESHOLD) {
      return {
        point: waypoints[i],
        bendpoint: true,
        index: i
      };
    }
  }

  return null;
}

function getPathIntersection(waypoints, reference) {

  var intersections = path_intersection__WEBPACK_IMPORTED_MODULE_0___default()(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));

  var a = intersections[0],
      b = intersections[intersections.length - 1],
      idx;

  if (!a) {

    // no intersection
    return null;
  }

  if (a !== b) {

    if (a.segment2 !== b.segment2) {

      // we use the bendpoint in between both segments
      // as the intersection point

      idx = max(a.segment2, b.segment2) - 1;

      return {
        point: waypoints[idx],
        bendpoint: true,
        index: idx
      };
    }

    return {
      point: {
        x: (round(a.x + b.x) / 2),
        y: (round(a.y + b.y) / 2)
      },
      index: a.segment2
    };
  }

  return {
    point: {
      x: round(a.x),
      y: round(a.y)
    },
    index: a.segment2
  };
}

/**
 * Returns the closest point on the connection towards a given reference point.
 *
 * @param  {Array<Point>} waypoints
 * @param  {Point} reference
 *
 * @return {Object} intersection data (segment, point)
 */
function getApproxIntersection(waypoints, reference) {
  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Math.js":
/*!**************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Math.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "log10": () => (/* binding */ log10),
/* harmony export */   "substract": () => (/* reexport safe */ _PositionUtil__WEBPACK_IMPORTED_MODULE_0__.delta)
/* harmony export */ });
/* harmony import */ var _PositionUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PositionUtil */ "./node_modules/diagram-js/lib/util/PositionUtil.js");
/**
 * Get the logarithm of x with base 10
 * @param  {Integer} value
 */
function log10(x) {
  return Math.log(x) / Math.log(10);
}




/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Mouse.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Mouse.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isMac": () => (/* reexport safe */ _Platform__WEBPACK_IMPORTED_MODULE_0__.isMac),
/* harmony export */   "isButton": () => (/* binding */ isButton),
/* harmony export */   "isPrimaryButton": () => (/* binding */ isPrimaryButton),
/* harmony export */   "isAuxiliaryButton": () => (/* binding */ isAuxiliaryButton),
/* harmony export */   "isSecondaryButton": () => (/* binding */ isSecondaryButton),
/* harmony export */   "hasPrimaryModifier": () => (/* binding */ hasPrimaryModifier),
/* harmony export */   "hasSecondaryModifier": () => (/* binding */ hasSecondaryModifier)
/* harmony export */ });
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./node_modules/diagram-js/lib/util/Event.js");
/* harmony import */ var _Platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Platform */ "./node_modules/diagram-js/lib/util/Platform.js");






function isButton(event, button) {
  return ((0,_Event__WEBPACK_IMPORTED_MODULE_1__.getOriginal)(event) || event).button === button;
}

function isPrimaryButton(event) {

  // button === 0 -> left ka primary mouse button
  return isButton(event, 0);
}

function isAuxiliaryButton(event) {

  // button === 1 -> auxiliary ka wheel button
  return isButton(event, 1);
}

function isSecondaryButton(event) {

  // button === 2 -> right ka secondary button
  return isButton(event, 2);
}

function hasPrimaryModifier(event) {
  var originalEvent = (0,_Event__WEBPACK_IMPORTED_MODULE_1__.getOriginal)(event) || event;

  if (!isPrimaryButton(event)) {
    return false;
  }

  // Use cmd as primary modifier key for mac OS
  if ((0,_Platform__WEBPACK_IMPORTED_MODULE_0__.isMac)()) {
    return originalEvent.metaKey;
  } else {
    return originalEvent.ctrlKey;
  }
}


function hasSecondaryModifier(event) {
  var originalEvent = (0,_Event__WEBPACK_IMPORTED_MODULE_1__.getOriginal)(event) || event;

  return isPrimaryButton(event) && originalEvent.shiftKey;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Platform.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Platform.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isMac": () => (/* binding */ isMac)
/* harmony export */ });
function isMac() {
  return (/mac/i).test(navigator.platform);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/PositionUtil.js":
/*!**********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/PositionUtil.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "center": () => (/* binding */ center),
/* harmony export */   "delta": () => (/* binding */ delta)
/* harmony export */ });
function center(bounds) {
  return {
    x: bounds.x + (bounds.width / 2),
    y: bounds.y + (bounds.height / 2)
  };
}


function delta(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Removal.js":
/*!*****************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Removal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "saveClear": () => (/* binding */ saveClear)
/* harmony export */ });
/**
 * Remove from the beginning of a collection until it is empty.
 *
 * This is a null-safe operation that ensures elements
 * are being removed from the given collection until the
 * collection is empty.
 *
 * The implementation deals with the fact that a remove operation
 * may touch, i.e. remove multiple elements in the collection
 * at a time.
 *
 * @param {Array<Object>} [collection]
 * @param {Function} removeFn
 *
 * @return {Array<Object>} the cleared collection
 */
function saveClear(collection, removeFn) {

  if (typeof removeFn !== 'function') {
    throw new Error('removeFn iterator must be a function');
  }

  if (!collection) {
    return;
  }

  var e;

  while ((e = collection[0])) {
    removeFn(e);
  }

  return collection;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/RenderUtil.js":
/*!********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/RenderUtil.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "componentsToPath": () => (/* binding */ componentsToPath),
/* harmony export */   "toSVGPoints": () => (/* binding */ toSVGPoints),
/* harmony export */   "createLine": () => (/* binding */ createLine),
/* harmony export */   "updateLine": () => (/* binding */ updateLine)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");



function componentsToPath(elements) {
  return elements.join(',').replace(/,?([A-z]),?/g, '$1');
}

function toSVGPoints(points) {
  var result = '';

  for (var i = 0, p; (p = points[i]); i++) {
    result += p.x + ',' + p.y + ' ';
  }

  return result;
}

function createLine(points, attrs) {

  var line = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('polyline');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(line, { points: toSVGPoints(points) });

  if (attrs) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(line, attrs);
  }

  return line;
}

function updateLine(gfx, points) {
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(gfx, { points: toSVGPoints(points) });

  return gfx;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js":
/*!**************************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/SvgTransformUtil.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "scale": () => (/* binding */ scale)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");



/**
 * @param {<SVGElement>} element
 * @param {number} x
 * @param {number} y
 * @param {number} angle
 * @param {number} amount
 */
function transform(gfx, x, y, angle, amount) {
  var translate = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  translate.setTranslate(x, y);

  var rotate = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  rotate.setRotate(angle || 0, 0, 0);

  var scale = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  scale.setScale(amount || 1, amount || 1);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.transform)(gfx, [ translate, rotate, scale ]);
}


/**
 * @param {SVGElement} element
 * @param {number} x
 * @param {number} y
 */
function translate(gfx, x, y) {
  var translate = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  translate.setTranslate(x, y);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.transform)(gfx, translate);
}


/**
 * @param {SVGElement} element
 * @param {number} angle
 */
function rotate(gfx, angle) {
  var rotate = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  rotate.setRotate(angle, 0, 0);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.transform)(gfx, rotate);
}


/**
 * @param {SVGElement} element
 * @param {number} amount
 */
function scale(gfx, amount) {
  var scale = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  scale.setScale(amount, amount);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.transform)(gfx, scale);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Text.js":
/*!**************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Text.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Text)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");




var DEFAULT_BOX_PADDING = 0;

var DEFAULT_LABEL_SIZE = {
  width: 150,
  height: 50
};


function parseAlign(align) {

  var parts = align.split('-');

  return {
    horizontal: parts[0] || 'center',
    vertical: parts[1] || 'top'
  };
}

function parsePadding(padding) {

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(padding)) {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({ top: 0, left: 0, right: 0, bottom: 0 }, padding);
  } else {
    return {
      top: padding,
      left: padding,
      right: padding,
      bottom: padding
    };
  }
}

function getTextBBox(text, fakeText) {

  fakeText.textContent = text;

  var textBBox;

  try {
    var bbox,
        emptyLine = text === '';

    // add dummy text, when line is empty to
    // determine correct height
    fakeText.textContent = emptyLine ? 'dummy' : text;

    textBBox = fakeText.getBBox();

    // take text rendering related horizontal
    // padding into account
    bbox = {
      width: textBBox.width + textBBox.x * 2,
      height: textBBox.height
    };

    if (emptyLine) {

      // correct width
      bbox.width = 0;
    }

    return bbox;
  } catch (e) {
    return { width: 0, height: 0 };
  }
}


/**
 * Layout the next line and return the layouted element.
 *
 * Alters the lines passed.
 *
 * @param  {Array<string>} lines
 * @return {Object} the line descriptor, an object { width, height, text }
 */
function layoutNext(lines, maxWidth, fakeText) {

  var originalLine = lines.shift(),
      fitLine = originalLine;

  var textBBox;

  for (;;) {
    textBBox = getTextBBox(fitLine, fakeText);

    textBBox.width = fitLine ? textBBox.width : 0;

    // try to fit
    if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {
      return fit(lines, fitLine, originalLine, textBBox);
    }

    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
  }
}

function fit(lines, fitLine, originalLine, textBBox) {
  if (fitLine.length < originalLine.length) {
    var remainder = originalLine.slice(fitLine.length).trim();

    lines.unshift(remainder);
  }

  return {
    width: textBBox.width,
    height: textBBox.height,
    text: fitLine
  };
}

var SOFT_BREAK = '\u00AD';


/**
 * Shortens a line based on spacing and hyphens.
 * Returns the shortened result on success.
 *
 * @param  {string} line
 * @param  {number} maxLength the maximum characters of the string
 * @return {string} the shortened string
 */
function semanticShorten(line, maxLength) {

  var parts = line.split(/(\s|-|\u00AD)/g),
      part,
      shortenedParts = [],
      length = 0;

  // try to shorten via break chars
  if (parts.length > 1) {

    while ((part = parts.shift())) {
      if (part.length + length < maxLength) {
        shortenedParts.push(part);
        length += part.length;
      } else {

        // remove previous part, too if hyphen does not fit anymore
        if (part === '-' || part === SOFT_BREAK) {
          shortenedParts.pop();
        }

        break;
      }
    }
  }

  var last = shortenedParts[shortenedParts.length - 1];

  // translate trailing soft break to actual hyphen
  if (last && last === SOFT_BREAK) {
    shortenedParts[shortenedParts.length - 1] = '-';
  }

  return shortenedParts.join('');
}


function shortenLine(line, width, maxWidth) {
  var length = Math.max(line.length * (maxWidth / width), 1);

  // try to shorten semantically (i.e. based on spaces and hyphens)
  var shortenedLine = semanticShorten(line, length);

  if (!shortenedLine) {

    // force shorten by cutting the long word
    shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));
  }

  return shortenedLine;
}


function getHelperSvg() {
  var helperSvg = document.getElementById('helper-svg');

  if (!helperSvg) {
    helperSvg = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('svg');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(helperSvg, {
      id: 'helper-svg',
      width: 0,
      height: 0,
      style: 'visibility: hidden; position: fixed'
    });

    document.body.appendChild(helperSvg);
  }

  return helperSvg;
}


/**
 * Creates a new label utility
 *
 * @param {Object} config
 * @param {Dimensions} config.size
 * @param {number} config.padding
 * @param {Object} config.style
 * @param {string} config.align
 */
function Text(config) {

  this._config = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, {
    size: DEFAULT_LABEL_SIZE,
    padding: DEFAULT_BOX_PADDING,
    style: {},
    align: 'center-top'
  }, config || {});
}

/**
 * Returns the layouted text as an SVG element.
 *
 * @param {string} text
 * @param {Object} options
 *
 * @return {SVGElement}
 */
Text.prototype.createText = function(text, options) {
  return this.layoutText(text, options).element;
};

/**
 * Returns a labels layouted dimensions.
 *
 * @param {string} text to layout
 * @param {Object} options
 *
 * @return {Dimensions}
 */
Text.prototype.getDimensions = function(text, options) {
  return this.layoutText(text, options).dimensions;
};

/**
 * Creates and returns a label and its bounding box.
 *
 * @method Text#createText
 *
 * @param {string} text the text to render on the label
 * @param {Object} options
 * @param {string} options.align how to align in the bounding box.
 *                               Any of { 'center-middle', 'center-top' },
 *                               defaults to 'center-top'.
 * @param {string} options.style style to be applied to the text
 * @param {boolean} options.fitBox indicates if box will be recalculated to
 *                                 fit text
 *
 * @return {Object} { element, dimensions }
 */
Text.prototype.layoutText = function(text, options) {
  var box = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, this._config.size, options.box),
      style = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, this._config.style, options.style),
      align = parseAlign(options.align || this._config.align),
      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),
      fitBox = options.fitBox || false;

  var lineHeight = getLineHeight(style);

  // we split text by lines and normalize
  // {soft break} + {line break} => { line break }
  var lines = text.split(/\u00AD?\r?\n/),
      layouted = [];

  var maxWidth = box.width - padding.left - padding.right;

  // ensure correct rendering by attaching helper text node to invisible SVG
  var helperText = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('text');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(helperText, { x: 0, y: 0 });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(helperText, style);

  var helperSvg = getHelperSvg();

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(helperSvg, helperText);

  while (lines.length) {
    layouted.push(layoutNext(lines, maxWidth, helperText));
  }

  if (align.vertical === 'middle') {
    padding.top = padding.bottom = 0;
  }

  var totalHeight = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(layouted, function(sum, line, idx) {
    return sum + (lineHeight || line.height);
  }, 0) + padding.top + padding.bottom;

  var maxLineWidth = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(layouted, function(sum, line, idx) {
    return line.width > sum ? line.width : sum;
  }, 0);

  // the y position of the next line
  var y = padding.top;

  if (align.vertical === 'middle') {
    y += (box.height - totalHeight) / 2;
  }

  // magic number initial offset
  y -= (lineHeight || layouted[0].height) / 4;


  var textElement = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('text');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(textElement, style);

  // layout each line taking into account that parent
  // shape might resize to fit text size
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(layouted, function(line) {

    var x;

    y += (lineHeight || line.height);

    switch (align.horizontal) {
    case 'left':
      x = padding.left;
      break;

    case 'right':
      x = ((fitBox ? maxLineWidth : maxWidth)
        - padding.right - line.width);
      break;

    default:

      // aka center
      x = Math.max((((fitBox ? maxLineWidth : maxWidth)
        - line.width) / 2 + padding.left), 0);
    }

    var tspan = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('tspan');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(tspan, { x: x, y: y });

    tspan.textContent = line.text;

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(textElement, tspan);
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(helperText);

  var dimensions = {
    width: maxLineWidth,
    height: totalHeight
  };

  return {
    dimensions: dimensions,
    element: textElement
  };
};


function getLineHeight(style) {
  if ('fontSize' in style && 'lineHeight' in style) {
    return style.lineHeight * parseInt(style.fontSize, 10);
  }
}

/***/ }),

/***/ "./node_modules/didi/dist/index.esm.js":
/*!*********************************************!*\
  !*** ./node_modules/didi/dist/index.esm.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "annotate": () => (/* binding */ annotate),
/* harmony export */   "parseAnnotations": () => (/* binding */ parseAnnotations),
/* harmony export */   "Module": () => (/* binding */ Module),
/* harmony export */   "Injector": () => (/* binding */ Injector)
/* harmony export */ });
var CLASS_PATTERN = /^class /;

function isClass(fn) {
  return CLASS_PATTERN.test(fn.toString());
}

function isArray(obj) {
  return Object.prototype.toString.call(obj) === '[object Array]';
}

function hasOwnProp(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function annotate() {
  var args = Array.prototype.slice.call(arguments);

  if (args.length === 1 && isArray(args[0])) {
    args = args[0];
  }

  var fn = args.pop();

  fn.$inject = args;

  return fn;
}


// Current limitations:
// - can't put into "function arg" comments
// function /* (no parenthesis like this) */ (){}
// function abc( /* xx (no parenthesis like this) */ a, b) {}
//
// Just put the comment before function or inside:
// /* (((this is fine))) */ function(a, b) {}
// function abc(a) { /* (((this is fine))) */}
//
// - can't reliably auto-annotate constructor; we'll match the
// first constructor(...) pattern found which may be the one
// of a nested class, too.

var CONSTRUCTOR_ARGS = /constructor\s*[^(]*\(\s*([^)]*)\)/m;
var FN_ARGS = /^(?:async )?(?:function\s*)?[^(]*\(\s*([^)]*)\)/m;
var FN_ARG = /\/\*([^*]*)\*\//m;

function parseAnnotations(fn) {

  if (typeof fn !== 'function') {
    throw new Error('Cannot annotate "' + fn + '". Expected a function!');
  }

  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);

  // may parse class without constructor
  if (!match) {
    return [];
  }

  return match[1] && match[1].split(',').map(function(arg) {
    match = arg.match(FN_ARG);
    return match ? match[1].trim() : arg.trim();
  }) || [];
}

function Module() {
  var providers = [];

  this.factory = function(name, factory) {
    providers.push([name, 'factory', factory]);
    return this;
  };

  this.value = function(name, value) {
    providers.push([name, 'value', value]);
    return this;
  };

  this.type = function(name, type) {
    providers.push([name, 'type', type]);
    return this;
  };

  this.forEach = function(iterator) {
    providers.forEach(iterator);
  };

}

function Injector(modules, parent) {
  parent = parent || {
    get: function(name, strict) {
      currentlyResolving.push(name);

      if (strict === false) {
        return null;
      } else {
        throw error('No provider for "' + name + '"!');
      }
    }
  };

  var currentlyResolving = [];
  var providers = this._providers = Object.create(parent._providers || null);
  var instances = this._instances = Object.create(null);

  var self = instances.injector = this;

  var error = function(msg) {
    var stack = currentlyResolving.join(' -> ');
    currentlyResolving.length = 0;
    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);
  };

  /**
   * Return a named service.
   *
   * @param {String} name
   * @param {Boolean} [strict=true] if false, resolve missing services to null
   *
   * @return {Object}
   */
  var get = function(name, strict) {
    if (!providers[name] && name.indexOf('.') !== -1) {
      var parts = name.split('.');
      var pivot = get(parts.shift());

      while (parts.length) {
        pivot = pivot[parts.shift()];
      }

      return pivot;
    }

    if (hasOwnProp(instances, name)) {
      return instances[name];
    }

    if (hasOwnProp(providers, name)) {
      if (currentlyResolving.indexOf(name) !== -1) {
        currentlyResolving.push(name);
        throw error('Cannot resolve circular dependency!');
      }

      currentlyResolving.push(name);
      instances[name] = providers[name][0](providers[name][1]);
      currentlyResolving.pop();

      return instances[name];
    }

    return parent.get(name, strict);
  };

  var fnDef = function(fn, locals) {

    if (typeof locals === 'undefined') {
      locals = {};
    }

    if (typeof fn !== 'function') {
      if (isArray(fn)) {
        fn = annotate(fn.slice());
      } else {
        throw new Error('Cannot invoke "' + fn + '". Expected a function!');
      }
    }

    var inject = fn.$inject || parseAnnotations(fn);
    var dependencies = inject.map(function(dep) {
      if (hasOwnProp(locals, dep)) {
        return locals[dep];
      } else {
        return get(dep);
      }
    });

    return {
      fn: fn,
      dependencies: dependencies
    };
  };

  var instantiate = function(Type) {
    var def = fnDef(Type);

    var fn = def.fn,
        dependencies = def.dependencies;

    // instantiate var args constructor
    var Constructor = Function.prototype.bind.apply(fn, [ null ].concat(dependencies));

    return new Constructor();
  };

  var invoke = function(func, context, locals) {
    var def = fnDef(func, locals);

    var fn = def.fn,
        dependencies = def.dependencies;

    return fn.apply(context, dependencies);
  };


  var createPrivateInjectorFactory = function(privateChildInjector) {
    return annotate(function(key) {
      return privateChildInjector.get(key);
    });
  };

  var createChild = function(modules, forceNewInstances) {
    if (forceNewInstances && forceNewInstances.length) {
      var fromParentModule = Object.create(null);
      var matchedScopes = Object.create(null);

      var privateInjectorsCache = [];
      var privateChildInjectors = [];
      var privateChildFactories = [];

      var provider;
      var cacheIdx;
      var privateChildInjector;
      var privateChildInjectorFactory;
      for (var name in providers) {
        provider = providers[name];

        if (forceNewInstances.indexOf(name) !== -1) {
          if (provider[2] === 'private') {
            cacheIdx = privateInjectorsCache.indexOf(provider[3]);
            if (cacheIdx === -1) {
              privateChildInjector = provider[3].createChild([], forceNewInstances);
              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
              privateInjectorsCache.push(provider[3]);
              privateChildInjectors.push(privateChildInjector);
              privateChildFactories.push(privateChildInjectorFactory);
              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];
            } else {
              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];
            }
          } else {
            fromParentModule[name] = [provider[2], provider[1]];
          }
          matchedScopes[name] = true;
        }

        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {
          /* jshint -W083 */
          forceNewInstances.forEach(function(scope) {
            if (provider[1].$scope.indexOf(scope) !== -1) {
              fromParentModule[name] = [provider[2], provider[1]];
              matchedScopes[scope] = true;
            }
          });
        }
      }

      forceNewInstances.forEach(function(scope) {
        if (!matchedScopes[scope]) {
          throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
        }
      });

      modules.unshift(fromParentModule);
    }

    return new Injector(modules, self);
  };

  var factoryMap = {
    factory: invoke,
    type: instantiate,
    value: function(value) {
      return value;
    }
  };

  modules.forEach(function(module) {

    function arrayUnwrap(type, value) {
      if (type !== 'value' && isArray(value)) {
        value = annotate(value.slice());
      }

      return value;
    }

    // TODO(vojta): handle wrong inputs (modules)
    if (module instanceof Module) {
      module.forEach(function(provider) {
        var name = provider[0];
        var type = provider[1];
        var value = provider[2];

        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
      });
    } else if (typeof module === 'object') {
      if (module.__exports__) {
        var clonedModule = Object.keys(module).reduce(function(m, key) {
          if (key.substring(0, 2) !== '__') {
            m[key] = module[key];
          }
          return m;
        }, Object.create(null));

        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);
        var getFromPrivateInjector = annotate(function(key) {
          return privateInjector.get(key);
        });
        module.__exports__.forEach(function(key) {
          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];
        });
      } else {
        Object.keys(module).forEach(function(name) {
          if (module[name][2] === 'private') {
            providers[name] = module[name];
            return;
          }

          var type = module[name][0];
          var value = module[name][1];

          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
        });
      }
    }
  });

  // public API
  this.get = get;
  this.invoke = invoke;
  this.instantiate = instantiate;
  this.createChild = createChild;
}




/***/ }),

/***/ "./node_modules/hammerjs/hammer.js":
/*!*****************************************!*\
  !*** ./node_modules/hammerjs/hammer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return Hammer;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

})(window, document, 'Hammer');


/***/ }),

/***/ "./node_modules/ids/dist/index.esm.js":
/*!********************************************!*\
  !*** ./node_modules/ids/dist/index.esm.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var hat_1 = createCommonjsModule(function (module) {
var hat = module.exports = function (bits, base) {
    if (!base) base = 16;
    if (bits === undefined) bits = 128;
    if (bits <= 0) return '0';
    
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    }
    
    var rem = digits - Math.floor(digits);
    
    var res = '';
    
    for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    
    if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base)
    }
    else return res;
};

hat.rack = function (bits, base, expandBy) {
    var fn = function (data) {
        var iters = 0;
        do {
            if (iters ++ > 10) {
                if (expandBy) bits += expandBy;
                else throw new Error('too many ID collisions, use more bits')
            }
            
            var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        
        hats[id] = data;
        return id;
    };
    var hats = fn.hats = {};
    
    fn.get = function (id) {
        return fn.hats[id];
    };
    
    fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
    };
    
    fn.bits = bits || 128;
    fn.base = base || 16;
    return fn;
};
});

/**
 * Create a new id generator / cache instance.
 *
 * You may optionally provide a seed that is used internally.
 *
 * @param {Seed} seed
 */

function Ids(seed) {
  if (!(this instanceof Ids)) {
    return new Ids(seed);
  }

  seed = seed || [128, 36, 1];
  this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;
}
/**
 * Generate a next id.
 *
 * @param {Object} [element] element to bind the id to
 *
 * @return {String} id
 */

Ids.prototype.next = function (element) {
  return this._seed(element || true);
};
/**
 * Generate a next id with a given prefix.
 *
 * @param {Object} [element] element to bind the id to
 *
 * @return {String} id
 */


Ids.prototype.nextPrefixed = function (prefix, element) {
  var id;

  do {
    id = prefix + this.next(true);
  } while (this.assigned(id)); // claim {prefix}{random}


  this.claim(id, element); // return

  return id;
};
/**
 * Manually claim an existing id.
 *
 * @param {String} id
 * @param {String} [element] element the id is claimed by
 */


Ids.prototype.claim = function (id, element) {
  this._seed.set(id, element || true);
};
/**
 * Returns true if the given id has already been assigned.
 *
 * @param  {String} id
 * @return {Boolean}
 */


Ids.prototype.assigned = function (id) {
  return this._seed.get(id) || false;
};
/**
 * Unclaim an id.
 *
 * @param  {String} id the id to unclaim
 */


Ids.prototype.unclaim = function (id) {
  delete this._seed.hats[id];
};
/**
 * Clear all claimed ids.
 */


Ids.prototype.clear = function () {
  var hats = this._seed.hats,
      id;

  for (id in hats) {
    this.unclaim(id);
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Ids);
//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/min-dash/dist/index.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/min-dash/dist/index.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assign": () => (/* binding */ assign),
/* harmony export */   "bind": () => (/* binding */ bind),
/* harmony export */   "debounce": () => (/* binding */ debounce),
/* harmony export */   "ensureArray": () => (/* binding */ ensureArray),
/* harmony export */   "every": () => (/* binding */ every),
/* harmony export */   "filter": () => (/* binding */ filter),
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "findIndex": () => (/* binding */ findIndex),
/* harmony export */   "flatten": () => (/* binding */ flatten),
/* harmony export */   "forEach": () => (/* binding */ forEach),
/* harmony export */   "get": () => (/* binding */ get),
/* harmony export */   "groupBy": () => (/* binding */ groupBy),
/* harmony export */   "has": () => (/* binding */ has),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isDefined": () => (/* binding */ isDefined),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isNil": () => (/* binding */ isNil),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined),
/* harmony export */   "keys": () => (/* binding */ keys),
/* harmony export */   "map": () => (/* binding */ map),
/* harmony export */   "matchPattern": () => (/* binding */ matchPattern),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "omit": () => (/* binding */ omit),
/* harmony export */   "pick": () => (/* binding */ pick),
/* harmony export */   "reduce": () => (/* binding */ reduce),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "size": () => (/* binding */ size),
/* harmony export */   "some": () => (/* binding */ some),
/* harmony export */   "sortBy": () => (/* binding */ sortBy),
/* harmony export */   "throttle": () => (/* binding */ throttle),
/* harmony export */   "unionBy": () => (/* binding */ unionBy),
/* harmony export */   "uniqueBy": () => (/* binding */ uniqueBy),
/* harmony export */   "values": () => (/* binding */ values),
/* harmony export */   "without": () => (/* binding */ without)
/* harmony export */ });
/**
 * Flatten array, one level deep.
 *
 * @param {Array<?>} arr
 *
 * @return {Array<?>}
 */
function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

var nativeToString = Object.prototype.toString;
var nativeHasOwnProperty = Object.prototype.hasOwnProperty;
function isUndefined(obj) {
  return obj === undefined;
}
function isDefined(obj) {
  return obj !== undefined;
}
function isNil(obj) {
  return obj == null;
}
function isArray(obj) {
  return nativeToString.call(obj) === '[object Array]';
}
function isObject(obj) {
  return nativeToString.call(obj) === '[object Object]';
}
function isNumber(obj) {
  return nativeToString.call(obj) === '[object Number]';
}
function isFunction(obj) {
  var tag = nativeToString.call(obj);
  return tag === '[object Function]' || tag === '[object AsyncFunction]' || tag === '[object GeneratorFunction]' || tag === '[object AsyncGeneratorFunction]' || tag === '[object Proxy]';
}
function isString(obj) {
  return nativeToString.call(obj) === '[object String]';
}
/**
 * Ensure collection is an array.
 *
 * @param {Object} obj
 */

function ensureArray(obj) {
  if (isArray(obj)) {
    return;
  }

  throw new Error('must supply array');
}
/**
 * Return true, if target owns a property with the given key.
 *
 * @param {Object} target
 * @param {String} key
 *
 * @return {Boolean}
 */

function has(target, key) {
  return nativeHasOwnProperty.call(target, key);
}

/**
 * Find element in collection.
 *
 * @param  {Array|Object} collection
 * @param  {Function|Object} matcher
 *
 * @return {Object}
 */

function find(collection, matcher) {
  matcher = toMatcher(matcher);
  var match;
  forEach(collection, function (val, key) {
    if (matcher(val, key)) {
      match = val;
      return false;
    }
  });
  return match;
}
/**
 * Find element index in collection.
 *
 * @param  {Array|Object} collection
 * @param  {Function} matcher
 *
 * @return {Object}
 */

function findIndex(collection, matcher) {
  matcher = toMatcher(matcher);
  var idx = isArray(collection) ? -1 : undefined;
  forEach(collection, function (val, key) {
    if (matcher(val, key)) {
      idx = key;
      return false;
    }
  });
  return idx;
}
/**
 * Find element in collection.
 *
 * @param  {Array|Object} collection
 * @param  {Function} matcher
 *
 * @return {Array} result
 */

function filter(collection, matcher) {
  var result = [];
  forEach(collection, function (val, key) {
    if (matcher(val, key)) {
      result.push(val);
    }
  });
  return result;
}
/**
 * Iterate over collection; returning something
 * (non-undefined) will stop iteration.
 *
 * @param  {Array|Object} collection
 * @param  {Function} iterator
 *
 * @return {Object} return result that stopped the iteration
 */

function forEach(collection, iterator) {
  var val, result;

  if (isUndefined(collection)) {
    return;
  }

  var convertKey = isArray(collection) ? toNum : identity;

  for (var key in collection) {
    if (has(collection, key)) {
      val = collection[key];
      result = iterator(val, convertKey(key));

      if (result === false) {
        return val;
      }
    }
  }
}
/**
 * Return collection without element.
 *
 * @param  {Array} arr
 * @param  {Function} matcher
 *
 * @return {Array}
 */

function without(arr, matcher) {
  if (isUndefined(arr)) {
    return [];
  }

  ensureArray(arr);
  matcher = toMatcher(matcher);
  return arr.filter(function (el, idx) {
    return !matcher(el, idx);
  });
}
/**
 * Reduce collection, returning a single result.
 *
 * @param  {Object|Array} collection
 * @param  {Function} iterator
 * @param  {Any} result
 *
 * @return {Any} result returned from last iterator
 */

function reduce(collection, iterator, result) {
  forEach(collection, function (value, idx) {
    result = iterator(result, value, idx);
  });
  return result;
}
/**
 * Return true if every element in the collection
 * matches the criteria.
 *
 * @param  {Object|Array} collection
 * @param  {Function} matcher
 *
 * @return {Boolean}
 */

function every(collection, matcher) {
  return !!reduce(collection, function (matches, val, key) {
    return matches && matcher(val, key);
  }, true);
}
/**
 * Return true if some elements in the collection
 * match the criteria.
 *
 * @param  {Object|Array} collection
 * @param  {Function} matcher
 *
 * @return {Boolean}
 */

function some(collection, matcher) {
  return !!find(collection, matcher);
}
/**
 * Transform a collection into another collection
 * by piping each member through the given fn.
 *
 * @param  {Object|Array}   collection
 * @param  {Function} fn
 *
 * @return {Array} transformed collection
 */

function map(collection, fn) {
  var result = [];
  forEach(collection, function (val, key) {
    result.push(fn(val, key));
  });
  return result;
}
/**
 * Get the collections keys.
 *
 * @param  {Object|Array} collection
 *
 * @return {Array}
 */

function keys(collection) {
  return collection && Object.keys(collection) || [];
}
/**
 * Shorthand for `keys(o).length`.
 *
 * @param  {Object|Array} collection
 *
 * @return {Number}
 */

function size(collection) {
  return keys(collection).length;
}
/**
 * Get the values in the collection.
 *
 * @param  {Object|Array} collection
 *
 * @return {Array}
 */

function values(collection) {
  return map(collection, function (val) {
    return val;
  });
}
/**
 * Group collection members by attribute.
 *
 * @param  {Object|Array} collection
 * @param  {Function} extractor
 *
 * @return {Object} map with { attrValue => [ a, b, c ] }
 */

function groupBy(collection, extractor) {
  var grouped = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  extractor = toExtractor(extractor);
  forEach(collection, function (val) {
    var discriminator = extractor(val) || '_';
    var group = grouped[discriminator];

    if (!group) {
      group = grouped[discriminator] = [];
    }

    group.push(val);
  });
  return grouped;
}
function uniqueBy(extractor) {
  extractor = toExtractor(extractor);
  var grouped = {};

  for (var _len = arguments.length, collections = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    collections[_key - 1] = arguments[_key];
  }

  forEach(collections, function (c) {
    return groupBy(c, extractor, grouped);
  });
  var result = map(grouped, function (val, key) {
    return val[0];
  });
  return result;
}
var unionBy = uniqueBy;
/**
 * Sort collection by criteria.
 *
 * @param  {Object|Array} collection
 * @param  {String|Function} extractor
 *
 * @return {Array}
 */

function sortBy(collection, extractor) {
  extractor = toExtractor(extractor);
  var sorted = [];
  forEach(collection, function (value, key) {
    var disc = extractor(value, key);
    var entry = {
      d: disc,
      v: value
    };

    for (var idx = 0; idx < sorted.length; idx++) {
      var d = sorted[idx].d;

      if (disc < d) {
        sorted.splice(idx, 0, entry);
        return;
      }
    } // not inserted, append (!)


    sorted.push(entry);
  });
  return map(sorted, function (e) {
    return e.v;
  });
}
/**
 * Create an object pattern matcher.
 *
 * @example
 *
 * const matcher = matchPattern({ id: 1 });
 *
 * var element = find(elements, matcher);
 *
 * @param  {Object} pattern
 *
 * @return {Function} matcherFn
 */

function matchPattern(pattern) {
  return function (el) {
    return every(pattern, function (val, key) {
      return el[key] === val;
    });
  };
}

function toExtractor(extractor) {
  return isFunction(extractor) ? extractor : function (e) {
    return e[extractor];
  };
}

function toMatcher(matcher) {
  return isFunction(matcher) ? matcher : function (e) {
    return e === matcher;
  };
}

function identity(arg) {
  return arg;
}

function toNum(arg) {
  return Number(arg);
}

/**
 * Debounce fn, calling it only once if
 * the given time elapsed between calls.
 *
 * @param  {Function} fn
 * @param  {Number} timeout
 *
 * @return {Function} debounced function
 */
function debounce(fn, timeout) {
  var timer;
  var lastArgs;
  var lastThis;
  var lastNow;

  function fire() {
    var now = Date.now();
    var scheduledDiff = lastNow + timeout - now;

    if (scheduledDiff > 0) {
      return schedule(scheduledDiff);
    }

    fn.apply(lastThis, lastArgs);
    timer = lastNow = lastArgs = lastThis = undefined;
  }

  function schedule(timeout) {
    timer = setTimeout(fire, timeout);
  }

  return function () {
    lastNow = Date.now();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    lastArgs = args;
    lastThis = this; // ensure an execution is scheduled

    if (!timer) {
      schedule(timeout);
    }
  };
}
/**
 * Throttle fn, calling at most once
 * in the given interval.
 *
 * @param  {Function} fn
 * @param  {Number} interval
 *
 * @return {Function} throttled function
 */

function throttle(fn, interval) {
  var throttling = false;
  return function () {
    if (throttling) {
      return;
    }

    fn.apply(void 0, arguments);
    throttling = true;
    setTimeout(function () {
      throttling = false;
    }, interval);
  };
}
/**
 * Bind function against target <this>.
 *
 * @param  {Function} fn
 * @param  {Object}   target
 *
 * @return {Function} bound function
 */

function bind(fn, target) {
  return fn.bind(target);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * Convenience wrapper for `Object.assign`.
 *
 * @param {Object} target
 * @param {...Object} others
 *
 * @return {Object} the target
 */

function assign(target) {
  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    others[_key - 1] = arguments[_key];
  }

  return _extends.apply(void 0, [target].concat(others));
}
/**
 * Sets a nested property of a given object to the specified value.
 *
 * This mutates the object and returns it.
 *
 * @param {Object} target The target of the set operation.
 * @param {(string|number)[]} path The path to the nested value.
 * @param {any} value The value to set.
 */

function set(target, path, value) {
  var currentTarget = target;
  forEach(path, function (key, idx) {
    if (key === '__proto__') {
      throw new Error('illegal key: __proto__');
    }

    var nextKey = path[idx + 1];
    var nextTarget = currentTarget[key];

    if (isDefined(nextKey) && isNil(nextTarget)) {
      nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];
    }

    if (isUndefined(nextKey)) {
      if (isUndefined(value)) {
        delete currentTarget[key];
      } else {
        currentTarget[key] = value;
      }
    } else {
      currentTarget = nextTarget;
    }
  });
  return target;
}
/**
 * Gets a nested property of a given object.
 *
 * @param {Object} target The target of the get operation.
 * @param {(string|number)[]} path The path to the nested value.
 * @param {any} [defaultValue] The value to return if no value exists.
 */

function get(target, path, defaultValue) {
  var currentTarget = target;
  forEach(path, function (key) {
    // accessing nil property yields <undefined>
    if (isNil(currentTarget)) {
      currentTarget = undefined;
      return false;
    }

    currentTarget = currentTarget[key];
  });
  return isUndefined(currentTarget) ? defaultValue : currentTarget;
}
/**
 * Pick given properties from the target object.
 *
 * @param {Object} target
 * @param {Array} properties
 *
 * @return {Object} target
 */

function pick(target, properties) {
  var result = {};
  var obj = Object(target);
  forEach(properties, function (prop) {
    if (prop in obj) {
      result[prop] = target[prop];
    }
  });
  return result;
}
/**
 * Pick all target properties, excluding the given ones.
 *
 * @param {Object} target
 * @param {Array} properties
 *
 * @return {Object} target
 */

function omit(target, properties) {
  var result = {};
  var obj = Object(target);
  forEach(obj, function (prop, key) {
    if (properties.indexOf(key) === -1) {
      result[key] = prop;
    }
  });
  return result;
}
/**
 * Recursively merge `...sources` into given target.
 *
 * Does support merging objects; does not support merging arrays.
 *
 * @param {Object} target
 * @param {...Object} sources
 *
 * @return {Object} the target
 */

function merge(target) {
  for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    sources[_key2 - 1] = arguments[_key2];
  }

  if (!sources.length) {
    return target;
  }

  forEach(sources, function (source) {
    // skip non-obj sources, i.e. null
    if (!source || !isObject(source)) {
      return;
    }

    forEach(source, function (sourceVal, key) {
      if (key === '__proto__') {
        return;
      }

      var targetVal = target[key];

      if (isObject(sourceVal)) {
        if (!isObject(targetVal)) {
          // override target[key] with object
          targetVal = {};
        }

        target[key] = merge(targetVal, sourceVal);
      } else {
        target[key] = sourceVal;
      }
    });
  });
  return target;
}




/***/ }),

/***/ "./node_modules/min-dom/dist/index.esm.js":
/*!************************************************!*\
  !*** ./node_modules/min-dom/dist/index.esm.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "attr": () => (/* binding */ attr),
/* harmony export */   "classes": () => (/* binding */ classes),
/* harmony export */   "clear": () => (/* binding */ clear),
/* harmony export */   "closest": () => (/* binding */ closest),
/* harmony export */   "delegate": () => (/* binding */ delegate),
/* harmony export */   "domify": () => (/* binding */ domify),
/* harmony export */   "event": () => (/* binding */ componentEvent),
/* harmony export */   "matches": () => (/* binding */ matchesSelector),
/* harmony export */   "query": () => (/* binding */ query),
/* harmony export */   "queryAll": () => (/* binding */ all),
/* harmony export */   "remove": () => (/* binding */ remove)
/* harmony export */ });
/**
 * Set attribute `name` to `val`, or get attr `name`.
 *
 * @param {Element} el
 * @param {String} name
 * @param {String} [val]
 * @api public
 */
function attr(el, name, val) {
  // get
  if (arguments.length == 2) {
    return el.getAttribute(name);
  }

  // remove
  if (val === null) {
    return el.removeAttribute(name);
  }

  // set
  el.setAttribute(name, val);

  return el;
}

var indexOf = [].indexOf;

var indexof = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/**
 * Taken from https://github.com/component/classes
 *
 * Without the component bits.
 */

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

function classes(el) {
  return new ClassList(el);
}

/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function (name) {
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = indexof(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function (name) {
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = indexof(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function (re) {
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function (name, force) {
  // classList
  if (this.list) {
    if ('undefined' !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ('undefined' !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function () {
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has = ClassList.prototype.contains = function (name) {
  return this.list ? this.list.contains(name) : !!~indexof(this.array(), name);
};

/**
 * Remove all children from the given element.
 */
function clear(el) {

  var c;

  while (el.childNodes.length) {
    c = el.childNodes[0];
    el.removeChild(c);
  }

  return el;
}

var proto = typeof Element !== 'undefined' ? Element.prototype : {};
var vendor = proto.matches
  || proto.matchesSelector
  || proto.webkitMatchesSelector
  || proto.mozMatchesSelector
  || proto.msMatchesSelector
  || proto.oMatchesSelector;

var matchesSelector = match;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match(el, selector) {
  if (!el || el.nodeType !== 1) return false;
  if (vendor) return vendor.call(el, selector);
  var nodes = el.parentNode.querySelectorAll(selector);
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] == el) return true;
  }
  return false;
}

/**
 * Closest
 *
 * @param {Element} el
 * @param {String} selector
 * @param {Boolean} checkYourSelf (optional)
 */
function closest (element, selector, checkYourSelf) {
  var currentElem = checkYourSelf ? element : element.parentNode;

  while (currentElem && currentElem.nodeType !== document.DOCUMENT_NODE && currentElem.nodeType !== document.DOCUMENT_FRAGMENT_NODE) {

    if (matchesSelector(currentElem, selector)) {
      return currentElem;
    }

    currentElem = currentElem.parentNode;
  }

  return matchesSelector(currentElem, selector) ? currentElem : null;
}

var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
    prefix = bind !== 'addEventListener' ? 'on' : '';

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

var bind_1 = function(el, type, fn, capture){
  el[bind](prefix + type, fn, capture || false);
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

var unbind_1 = function(el, type, fn, capture){
  el[unbind](prefix + type, fn, capture || false);
  return fn;
};

var componentEvent = {
	bind: bind_1,
	unbind: unbind_1
};

/**
 * Module dependencies.
 */

/**
 * Delegate event `type` to `selector`
 * and invoke `fn(e)`. A callback function
 * is returned which may be passed to `.unbind()`.
 *
 * @param {Element} el
 * @param {String} selector
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

// Some events don't bubble, so we want to bind to the capture phase instead
// when delegating.
var forceCaptureEvents = ['focus', 'blur'];

function bind$1(el, selector, type, fn, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }

  return componentEvent.bind(el, type, function (e) {
    var target = e.target || e.srcElement;
    e.delegateTarget = closest(target, selector, true, el);
    if (e.delegateTarget) {
      fn.call(el, e);
    }
  }, capture);
}

/**
 * Unbind event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */
function unbind$1(el, type, fn, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }

  return componentEvent.unbind(el, type, fn, capture);
}

var delegate = {
  bind: bind$1,
  unbind: unbind$1
};

/**
 * Expose `parse`.
 */

var domify = parse;

/**
 * Tests for browser support.
 */

var innerHTMLBug = false;
var bugTestDiv;
if (typeof document !== 'undefined') {
  bugTestDiv = document.createElement('div');
  // Setup
  bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
  // Make sure that link elements get serialized correctly by innerHTML
  // This requires a wrapper element in IE
  innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;
  bugTestDiv = undefined;
}

/**
 * Wrap map from jquery.
 */

var map = {
  legend: [1, '<fieldset>', '</fieldset>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  // for script/link/style tags to work in IE6-8, you have to wrap
  // in a div with a non-whitespace character in front, ha!
  _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
};

map.td =
map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

map.option =
map.optgroup = [1, '<select multiple="multiple">', '</select>'];

map.thead =
map.tbody =
map.colgroup =
map.caption =
map.tfoot = [1, '<table>', '</table>'];

map.polyline =
map.ellipse =
map.polygon =
map.circle =
map.text =
map.line =
map.path =
map.rect =
map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">','</svg>'];

/**
 * Parse `html` and return a DOM Node instance, which could be a TextNode,
 * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
 * instance, depending on the contents of the `html` string.
 *
 * @param {String} html - HTML string to "domify"
 * @param {Document} doc - The `document` instance to create the Node for
 * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
 * @api private
 */

function parse(html, doc) {
  if ('string' != typeof html) throw new TypeError('String expected');

  // default to the global `document` object
  if (!doc) doc = document;

  // tag name
  var m = /<([\w:]+)/.exec(html);
  if (!m) return doc.createTextNode(html);

  html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

  var tag = m[1];

  // body support
  if (tag == 'body') {
    var el = doc.createElement('html');
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }

  // wrap map
  var wrap = map[tag] || map._default;
  var depth = wrap[0];
  var prefix = wrap[1];
  var suffix = wrap[2];
  var el = doc.createElement('div');
  el.innerHTML = prefix + html + suffix;
  while (depth--) el = el.lastChild;

  // one element
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }

  // several elements
  var fragment = doc.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }

  return fragment;
}

function query(selector, el) {
  el = el || document;

  return el.querySelector(selector);
}

function all(selector, el) {
  el = el || document;

  return el.querySelectorAll(selector);
}

function remove(el) {
  el.parentNode && el.parentNode.removeChild(el);
}




/***/ }),

/***/ "./node_modules/moddle-xml/dist/index.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/moddle-xml/dist/index.esm.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Reader": () => (/* binding */ Reader),
/* harmony export */   "Writer": () => (/* binding */ Writer)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var saxen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! saxen */ "./node_modules/saxen/dist/index.esm.js");
/* harmony import */ var moddle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moddle */ "./node_modules/moddle/dist/index.esm.js");




function hasLowerCaseAlias(pkg) {
  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';
}

var DEFAULT_NS_MAP = {
  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',
  'xml': 'http://www.w3.org/XML/1998/namespace'
};

var XSI_TYPE = 'xsi:type';

function serializeFormat(element) {
  return element.xml && element.xml.serialize;
}

function serializeAsType(element) {
  return serializeFormat(element) === XSI_TYPE;
}

function serializeAsProperty(element) {
  return serializeFormat(element) === 'property';
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function aliasToName(aliasNs, pkg) {

  if (!hasLowerCaseAlias(pkg)) {
    return aliasNs.name;
  }

  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);
}

function prefixedToName(nameNs, pkg) {

  var name = nameNs.name,
      localName = nameNs.localName;

  var typePrefix = pkg.xml && pkg.xml.typePrefix;

  if (typePrefix && localName.indexOf(typePrefix) === 0) {
    return nameNs.prefix + ':' + localName.slice(typePrefix.length);
  } else {
    return name;
  }
}

function normalizeXsiTypeName(name, model) {

  var nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name);
  var pkg = model.getPackage(nameNs.prefix);

  return prefixedToName(nameNs, pkg);
}

function error(message) {
  return new Error(message);
}

/**
 * Get the moddle descriptor for a given instance or type.
 *
 * @param  {ModdleElement|Function} element
 *
 * @return {Object} the moddle descriptor
 */
function getModdleDescriptor(element) {
  return element.$descriptor;
}


/**
 * A parse context.
 *
 * @class
 *
 * @param {Object} options
 * @param {ElementHandler} options.rootHandler the root handler for parsing a document
 * @param {boolean} [options.lax=false] whether or not to ignore invalid elements
 */
function Context(options) {

  /**
   * @property {ElementHandler} rootHandler
   */

  /**
   * @property {Boolean} lax
   */

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(this, options);

  this.elementsById = {};
  this.references = [];
  this.warnings = [];

  /**
   * Add an unresolved reference.
   *
   * @param {Object} reference
   */
  this.addReference = function(reference) {
    this.references.push(reference);
  };

  /**
   * Add a processed element.
   *
   * @param {ModdleElement} element
   */
  this.addElement = function(element) {

    if (!element) {
      throw error('expected element');
    }

    var elementsById = this.elementsById;

    var descriptor = getModdleDescriptor(element);

    var idProperty = descriptor.idProperty,
        id;

    if (idProperty) {
      id = element.get(idProperty.name);

      if (id) {

        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar
        if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(id)) {
          throw new Error('illegal ID <' + id + '>');
        }

        if (elementsById[id]) {
          throw error('duplicate ID <' + id + '>');
        }

        elementsById[id] = element;
      }
    }
  };

  /**
   * Add an import warning.
   *
   * @param {Object} warning
   * @param {String} warning.message
   * @param {Error} [warning.error]
   */
  this.addWarning = function(warning) {
    this.warnings.push(warning);
  };
}

function BaseHandler() {}

BaseHandler.prototype.handleEnd = function() {};
BaseHandler.prototype.handleText = function() {};
BaseHandler.prototype.handleNode = function() {};


/**
 * A simple pass through handler that does nothing except for
 * ignoring all input it receives.
 *
 * This is used to ignore unknown elements and
 * attributes.
 */
function NoopHandler() { }

NoopHandler.prototype = Object.create(BaseHandler.prototype);

NoopHandler.prototype.handleNode = function() {
  return this;
};

function BodyHandler() {}

BodyHandler.prototype = Object.create(BaseHandler.prototype);

BodyHandler.prototype.handleText = function(text) {
  this.body = (this.body || '') + text;
};

function ReferenceHandler(property, context) {
  this.property = property;
  this.context = context;
}

ReferenceHandler.prototype = Object.create(BodyHandler.prototype);

ReferenceHandler.prototype.handleNode = function(node) {

  if (this.element) {
    throw error('expected no sub nodes');
  } else {
    this.element = this.createReference(node);
  }

  return this;
};

ReferenceHandler.prototype.handleEnd = function() {
  this.element.id = this.body;
};

ReferenceHandler.prototype.createReference = function(node) {
  return {
    property: this.property.ns.name,
    id: ''
  };
};

function ValueHandler(propertyDesc, element) {
  this.element = element;
  this.propertyDesc = propertyDesc;
}

ValueHandler.prototype = Object.create(BodyHandler.prototype);

ValueHandler.prototype.handleEnd = function() {

  var value = this.body || '',
      element = this.element,
      propertyDesc = this.propertyDesc;

  value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(propertyDesc.type, value);

  if (propertyDesc.isMany) {
    element.get(propertyDesc.name).push(value);
  } else {
    element.set(propertyDesc.name, value);
  }
};


function BaseElementHandler() {}

BaseElementHandler.prototype = Object.create(BodyHandler.prototype);

BaseElementHandler.prototype.handleNode = function(node) {
  var parser = this,
      element = this.element;

  if (!element) {
    element = this.element = this.createElement(node);

    this.context.addElement(element);
  } else {
    parser = this.handleChild(node);
  }

  return parser;
};

/**
 * @class Reader.ElementHandler
 *
 */
function ElementHandler(model, typeName, context) {
  this.model = model;
  this.type = model.getType(typeName);
  this.context = context;
}

ElementHandler.prototype = Object.create(BaseElementHandler.prototype);

ElementHandler.prototype.addReference = function(reference) {
  this.context.addReference(reference);
};

ElementHandler.prototype.handleText = function(text) {

  var element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;

  if (!bodyProperty) {
    throw error('unexpected body text <' + text + '>');
  }

  BodyHandler.prototype.handleText.call(this, text);
};

ElementHandler.prototype.handleEnd = function() {

  var value = this.body,
      element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;

  if (bodyProperty && value !== undefined) {
    value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(bodyProperty.type, value);
    element.set(bodyProperty.name, value);
  }
};

/**
 * Create an instance of the model from the given node.
 *
 * @param  {Element} node the xml node
 */
ElementHandler.prototype.createElement = function(node) {
  var attributes = node.attributes,
      Type = this.type,
      descriptor = getModdleDescriptor(Type),
      context = this.context,
      instance = new Type({}),
      model = this.model,
      propNameNs;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attributes, function(value, name) {

    var prop = descriptor.propertiesByName[name],
        values;

    if (prop && prop.isReference) {

      if (!prop.isMany) {
        context.addReference({
          element: instance,
          property: prop.ns.name,
          id: value
        });
      } else {

        // IDREFS: parse references as whitespace-separated list
        values = value.split(' ');

        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(values, function(v) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: v
          });
        });
      }

    } else {
      if (prop) {
        value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(prop.type, value);
      } else
      if (name !== 'xmlns') {
        propNameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name, descriptor.ns.prefix);

        // check whether attribute is defined in a well-known namespace
        // if that is the case we emit a warning to indicate potential misuse
        if (model.getPackage(propNameNs.prefix)) {

          context.addWarning({
            message: 'unknown attribute <' + name + '>',
            element: instance,
            property: name,
            value: value
          });
        }
      }

      instance.set(name, value);
    }
  });

  return instance;
};

ElementHandler.prototype.getPropertyForNode = function(node) {

  var name = node.name;
  var nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name);

  var type = this.type,
      model = this.model,
      descriptor = getModdleDescriptor(type);

  var propertyName = nameNs.name,
      property = descriptor.propertiesByName[propertyName],
      elementTypeName,
      elementType;

  // search for properties by name first

  if (property && !property.isAttr) {

    if (serializeAsType(property)) {
      elementTypeName = node.attributes[XSI_TYPE];

      // xsi type is optional, if it does not exists the
      // default type is assumed
      if (elementTypeName) {

        // take possible type prefixes from XML
        // into account, i.e.: xsi:type="t{ActualType}"
        elementTypeName = normalizeXsiTypeName(elementTypeName, model);

        elementType = model.getType(elementTypeName);

        return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, property, {
          effectiveType: getModdleDescriptor(elementType).name
        });
      }
    }

    // search for properties by name first
    return property;
  }

  var pkg = model.getPackage(nameNs.prefix);

  if (pkg) {
    elementTypeName = aliasToName(nameNs, pkg);
    elementType = model.getType(elementTypeName);

    // search for collection members later
    property = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.find)(descriptor.properties, function(p) {
      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);
    });

    if (property) {
      return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, property, {
        effectiveType: getModdleDescriptor(elementType).name
      });
    }
  } else {

    // parse unknown element (maybe extension)
    property = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.find)(descriptor.properties, function(p) {
      return !p.isReference && !p.isAttribute && p.type === 'Element';
    });

    if (property) {
      return property;
    }
  }

  throw error('unrecognized element <' + nameNs.name + '>');
};

ElementHandler.prototype.toString = function() {
  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';
};

ElementHandler.prototype.valueHandler = function(propertyDesc, element) {
  return new ValueHandler(propertyDesc, element);
};

ElementHandler.prototype.referenceHandler = function(propertyDesc) {
  return new ReferenceHandler(propertyDesc, this.context);
};

ElementHandler.prototype.handler = function(type) {
  if (type === 'Element') {
    return new GenericElementHandler(this.model, type, this.context);
  } else {
    return new ElementHandler(this.model, type, this.context);
  }
};

/**
 * Handle the child element parsing
 *
 * @param  {Element} node the xml node
 */
ElementHandler.prototype.handleChild = function(node) {
  var propertyDesc, type, element, childHandler;

  propertyDesc = this.getPropertyForNode(node);
  element = this.element;

  type = propertyDesc.effectiveType || propertyDesc.type;

  if ((0,moddle__WEBPACK_IMPORTED_MODULE_1__.isSimpleType)(type)) {
    return this.valueHandler(propertyDesc, element);
  }

  if (propertyDesc.isReference) {
    childHandler = this.referenceHandler(propertyDesc).handleNode(node);
  } else {
    childHandler = this.handler(type).handleNode(node);
  }

  var newElement = childHandler.element;

  // child handles may decide to skip elements
  // by not returning anything
  if (newElement !== undefined) {

    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(newElement);
    } else {
      element.set(propertyDesc.name, newElement);
    }

    if (propertyDesc.isReference) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(newElement, {
        element: element
      });

      this.context.addReference(newElement);
    } else {

      // establish child -> parent relationship
      newElement.$parent = element;
    }
  }

  return childHandler;
};

/**
 * An element handler that performs special validation
 * to ensure the node it gets initialized with matches
 * the handlers type (namespace wise).
 *
 * @param {Moddle} model
 * @param {String} typeName
 * @param {Context} context
 */
function RootElementHandler(model, typeName, context) {
  ElementHandler.call(this, model, typeName, context);
}

RootElementHandler.prototype = Object.create(ElementHandler.prototype);

RootElementHandler.prototype.createElement = function(node) {

  var name = node.name,
      nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name),
      model = this.model,
      type = this.type,
      pkg = model.getPackage(nameNs.prefix),
      typeName = pkg && aliasToName(nameNs, pkg) || name;

  // verify the correct namespace if we parse
  // the first element in the handler tree
  //
  // this ensures we don't mistakenly import wrong namespace elements
  if (!type.hasType(typeName)) {
    throw error('unexpected element <' + node.originalName + '>');
  }

  return ElementHandler.prototype.createElement.call(this, node);
};


function GenericElementHandler(model, typeName, context) {
  this.model = model;
  this.context = context;
}

GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);

GenericElementHandler.prototype.createElement = function(node) {

  var name = node.name,
      ns = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name),
      prefix = ns.prefix,
      uri = node.ns[prefix + '$uri'],
      attributes = node.attributes;

  return this.model.createAny(name, uri, attributes);
};

GenericElementHandler.prototype.handleChild = function(node) {

  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),
      element = this.element;

  var newElement = handler.element,
      children;

  if (newElement !== undefined) {
    children = element.$children = element.$children || [];
    children.push(newElement);

    // establish child -> parent relationship
    newElement.$parent = element;
  }

  return handler;
};

GenericElementHandler.prototype.handleEnd = function() {
  if (this.body) {
    this.element.$body = this.body;
  }
};

/**
 * A reader for a meta-model
 *
 * @param {Object} options
 * @param {Model} options.model used to read xml files
 * @param {Boolean} options.lax whether to make parse errors warnings
 */
function Reader(options) {

  if (options instanceof moddle__WEBPACK_IMPORTED_MODULE_1__.Moddle) {
    options = {
      model: options
    };
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(this, { lax: false }, options);
}

/**
 * The fromXML result.
 *
 * @typedef {Object} ParseResult
 *
 * @property {ModdleElement} rootElement
 * @property {Array<Object>} references
 * @property {Array<Error>} warnings
 * @property {Object} elementsById - a mapping containing each ID -> ModdleElement
 */

/**
 * The fromXML result.
 *
 * @typedef {Error} ParseError
 *
 * @property {Array<Error>} warnings
 */

/**
 * Parse the given XML into a moddle document tree.
 *
 * @param {String} xml
 * @param {ElementHandler|Object} options or rootHandler
 *
 * @returns {Promise<ParseResult, ParseError>}
 */
Reader.prototype.fromXML = function(xml, options, done) {

  var rootHandler = options.rootHandler;

  if (options instanceof ElementHandler) {

    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)
    rootHandler = options;
    options = {};
  } else {
    if (typeof options === 'string') {

      // rootHandler passed via (xml, 'someString', ...)
      rootHandler = this.handler(options);
      options = {};
    } else if (typeof rootHandler === 'string') {

      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)
      rootHandler = this.handler(rootHandler);
    }
  }

  var model = this.model,
      lax = this.lax;

  var context = new Context((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, options, { rootHandler: rootHandler })),
      parser = new saxen__WEBPACK_IMPORTED_MODULE_0__.Parser({ proxy: true }),
      stack = createStack();

  rootHandler.context = context;

  // push root handler
  stack.push(rootHandler);


  /**
   * Handle error.
   *
   * @param  {Error} err
   * @param  {Function} getContext
   * @param  {boolean} lax
   *
   * @return {boolean} true if handled
   */
  function handleError(err, getContext, lax) {

    var ctx = getContext();

    var line = ctx.line,
        column = ctx.column,
        data = ctx.data;

    // we receive the full context data here,
    // for elements trim down the information
    // to the tag name, only
    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {
      data = data.slice(0, data.indexOf(' ')) + '>';
    }

    var message =
      'unparsable content ' + (data ? data + ' ' : '') + 'detected\n\t' +
        'line: ' + line + '\n\t' +
        'column: ' + column + '\n\t' +
        'nested error: ' + err.message;

    if (lax) {
      context.addWarning({
        message: message,
        error: err
      });

      return true;
    } else {
      throw error(message);
    }
  }

  function handleWarning(err, getContext) {

    // just like handling errors in <lax=true> mode
    return handleError(err, getContext, true);
  }

  /**
   * Resolve collected references on parse end.
   */
  function resolveReferences() {

    var elementsById = context.elementsById;
    var references = context.references;

    var i, r;

    for (i = 0; (r = references[i]); i++) {
      var element = r.element;
      var reference = elementsById[r.id];
      var property = getModdleDescriptor(element).propertiesByName[r.property];

      if (!reference) {
        context.addWarning({
          message: 'unresolved reference <' + r.id + '>',
          element: r.element,
          property: r.property,
          value: r.id
        });
      }

      if (property.isMany) {
        var collection = element.get(property.name),
            idx = collection.indexOf(r);

        // we replace an existing place holder (idx != -1) or
        // append to the collection instead
        if (idx === -1) {
          idx = collection.length;
        }

        if (!reference) {

          // remove unresolvable reference
          collection.splice(idx, 1);
        } else {

          // add or update reference in collection
          collection[idx] = reference;
        }
      } else {
        element.set(property.name, reference);
      }
    }
  }

  function handleClose() {
    stack.pop().handleEnd();
  }

  var PREAMBLE_START_PATTERN = /^<\?xml /i;

  var ENCODING_PATTERN = / encoding="([^"]+)"/i;

  var UTF_8_PATTERN = /^utf-8$/i;

  function handleQuestion(question) {

    if (!PREAMBLE_START_PATTERN.test(question)) {
      return;
    }

    var match = ENCODING_PATTERN.exec(question);
    var encoding = match && match[1];

    if (!encoding || UTF_8_PATTERN.test(encoding)) {
      return;
    }

    context.addWarning({
      message:
        'unsupported document encoding <' + encoding + '>, ' +
        'falling back to UTF-8'
    });
  }

  function handleOpen(node, getContext) {
    var handler = stack.peek();

    try {
      stack.push(handler.handleNode(node));
    } catch (err) {

      if (handleError(err, getContext, lax)) {
        stack.push(new NoopHandler());
      }
    }
  }

  function handleCData(text, getContext) {

    try {
      stack.peek().handleText(text);
    } catch (err) {
      handleWarning(err, getContext);
    }
  }

  function handleText(text, getContext) {

    // strip whitespace only nodes, i.e. before
    // <!CDATA[ ... ]> sections and in between tags
    text = text.trim();

    if (!text) {
      return;
    }

    handleCData(text, getContext);
  }

  var uriMap = model.getPackages().reduce(function(uriMap, p) {
    uriMap[p.uri] = p.prefix;

    return uriMap;
  }, {
    'http://www.w3.org/XML/1998/namespace': 'xml' // add default xml ns
  });
  parser
    .ns(uriMap)
    .on('openTag', function(obj, decodeStr, selfClosing, getContext) {

      // gracefully handle unparsable attributes (attrs=false)
      var attrs = obj.attrs || {};

      var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {
        var value = decodeStr(attrs[key]);

        d[key] = value;

        return d;
      }, {});

      var node = {
        name: obj.name,
        originalName: obj.originalName,
        attributes: decodedAttrs,
        ns: obj.ns
      };

      handleOpen(node, getContext);
    })
    .on('question', handleQuestion)
    .on('closeTag', handleClose)
    .on('cdata', handleCData)
    .on('text', function(text, decodeEntities, getContext) {
      handleText(decodeEntities(text), getContext);
    })
    .on('error', handleError)
    .on('warn', handleWarning);

  // async XML parsing to make sure the execution environment
  // (node or brower) is kept responsive and that certain optimization
  // strategies can kick in.
  return new Promise(function(resolve, reject) {

    var err;

    try {
      parser.parse(xml);

      resolveReferences();
    } catch (e) {
      err = e;
    }

    var rootElement = rootHandler.element;

    if (!err && !rootElement) {
      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');
    }

    var warnings = context.warnings;
    var references = context.references;
    var elementsById = context.elementsById;

    if (err) {
      err.warnings = warnings;

      return reject(err);
    } else {
      return resolve({
        rootElement: rootElement,
        elementsById: elementsById,
        references: references,
        warnings: warnings
      });
    }
  });
};

Reader.prototype.handler = function(name) {
  return new RootElementHandler(this.model, name);
};


// helpers //////////////////////////

function createStack() {
  var stack = [];

  Object.defineProperty(stack, 'peek', {
    value: function() {
      return this[this.length - 1];
    }
  });

  return stack;
}

var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';

var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
var ESCAPE_CHARS = /<|>|&/g;


function Namespaces(parent) {

  var prefixMap = {};
  var uriMap = {};
  var used = {};

  var wellknown = [];
  var custom = [];

  // API

  this.byUri = function(uri) {
    return uriMap[uri] || (
      parent && parent.byUri(uri)
    );
  };

  this.add = function(ns, isWellknown) {

    uriMap[ns.uri] = ns;

    if (isWellknown) {
      wellknown.push(ns);
    } else {
      custom.push(ns);
    }

    this.mapPrefix(ns.prefix, ns.uri);
  };

  this.uriByPrefix = function(prefix) {
    return prefixMap[prefix || 'xmlns'];
  };

  this.mapPrefix = function(prefix, uri) {
    prefixMap[prefix || 'xmlns'] = uri;
  };

  this.getNSKey = function(ns) {
    return (ns.prefix !== undefined) ? (ns.uri + '|' + ns.prefix) : ns.uri;
  };

  this.logUsed = function(ns) {

    var uri = ns.uri;
    var nsKey = this.getNSKey(ns);

    used[nsKey] = this.byUri(uri);

    // Inform parent recursively about the usage of this NS
    if (parent) {
      parent.logUsed(ns);
    }
  };

  this.getUsed = function(ns) {

    function isUsed(ns) {
      var nsKey = self.getNSKey(ns);

      return used[nsKey];
    }

    var self = this;

    var allNs = [].concat(wellknown, custom);

    return allNs.filter(isUsed);
  };

}

function lower(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}

function nameToAlias(name, pkg) {
  if (hasLowerCaseAlias(pkg)) {
    return lower(name);
  } else {
    return name;
  }
}

function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}

function nsName(ns) {
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(ns)) {
    return ns;
  } else {
    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;
  }
}

function getNsAttrs(namespaces) {

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.map)(namespaces.getUsed(), function(ns) {
    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');
    return { name: name, value: ns.uri };
  });

}

function getElementNs(ns, descriptor) {
  if (descriptor.isGeneric) {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: descriptor.ns.localName }, ns);
  } else {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);
  }
}

function getPropertyNs(ns, descriptor) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: descriptor.ns.localName }, ns);
}

function getSerializableProperties(element) {
  var descriptor = element.$descriptor;

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(descriptor.properties, function(p) {
    var name = p.name;

    if (p.isVirtual) {
      return false;
    }

    // do not serialize defaults
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_2__.has)(element, name)) {
      return false;
    }

    var value = element[name];

    // do not serialize default equals
    if (value === p.default) {
      return false;
    }

    // do not serialize null properties
    if (value === null) {
      return false;
    }

    return p.isMany ? value.length : true;
  });
}

var ESCAPE_ATTR_MAP = {
  '\n': '#10',
  '\n\r': '#10',
  '"': '#34',
  '\'': '#39',
  '<': '#60',
  '>': '#62',
  '&': '#38'
};

var ESCAPE_MAP = {
  '<': 'lt',
  '>': 'gt',
  '&': 'amp'
};

function escape(str, charPattern, replaceMap) {

  // ensure we are handling strings here
  str = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(str) ? str : '' + str;

  return str.replace(charPattern, function(s) {
    return '&' + replaceMap[s] + ';';
  });
}

/**
 * Escape a string attribute to not contain any bad values (line breaks, '"', ...)
 *
 * @param {String} str the string to escape
 * @return {String} the escaped string
 */
function escapeAttr(str) {
  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
}

function escapeBody(str) {
  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);
}

function filterAttributes(props) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(props, function(p) { return p.isAttr; });
}

function filterContained(props) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(props, function(p) { return !p.isAttr; });
}


function ReferenceSerializer(tagName) {
  this.tagName = tagName;
}

ReferenceSerializer.prototype.build = function(element) {
  this.element = element;
  return this;
};

ReferenceSerializer.prototype.serializeTo = function(writer) {
  writer
    .appendIndent()
    .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')
    .appendNewLine();
};

function BodySerializer() {}

BodySerializer.prototype.serializeValue =
BodySerializer.prototype.serializeTo = function(writer) {
  writer.append(
    this.escape
      ? escapeBody(this.value)
      : this.value
  );
};

BodySerializer.prototype.build = function(prop, value) {
  this.value = value;

  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {
    this.escape = true;
  }

  return this;
};

function ValueSerializer(tagName) {
  this.tagName = tagName;
}

inherits(ValueSerializer, BodySerializer);

ValueSerializer.prototype.serializeTo = function(writer) {

  writer
    .appendIndent()
    .append('<' + this.tagName + '>');

  this.serializeValue(writer);

  writer
    .append('</' + this.tagName + '>')
    .appendNewLine();
};

function ElementSerializer(parent, propertyDescriptor) {
  this.body = [];
  this.attrs = [];

  this.parent = parent;
  this.propertyDescriptor = propertyDescriptor;
}

ElementSerializer.prototype.build = function(element) {
  this.element = element;

  var elementDescriptor = element.$descriptor,
      propertyDescriptor = this.propertyDescriptor;

  var otherAttrs,
      properties;

  var isGeneric = elementDescriptor.isGeneric;

  if (isGeneric) {
    otherAttrs = this.parseGeneric(element);
  } else {
    otherAttrs = this.parseNsAttributes(element);
  }

  if (propertyDescriptor) {
    this.ns = this.nsPropertyTagName(propertyDescriptor);
  } else {
    this.ns = this.nsTagName(elementDescriptor);
  }

  // compute tag name
  this.tagName = this.addTagName(this.ns);

  if (!isGeneric) {
    properties = getSerializableProperties(element);

    this.parseAttributes(filterAttributes(properties));
    this.parseContainments(filterContained(properties));
  }

  this.parseGenericAttributes(element, otherAttrs);

  return this;
};

ElementSerializer.prototype.nsTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getElementNs(effectiveNs, descriptor);
};

ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getPropertyNs(effectiveNs, descriptor);
};

ElementSerializer.prototype.isLocalNs = function(ns) {
  return ns.uri === this.ns.uri;
};

/**
 * Get the actual ns attribute name for the given element.
 *
 * @param {Object} element
 * @param {Boolean} [element.inherited=false]
 *
 * @return {Object} nsName
 */
ElementSerializer.prototype.nsAttributeName = function(element) {

  var ns;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(element)) {
    ns = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(element);
  } else {
    ns = element.ns;
  }

  // return just local name for inherited attributes
  if (element.inherited) {
    return { localName: ns.localName };
  }

  // parse + log effective ns
  var effectiveNs = this.logNamespaceUsed(ns);

  // LOG ACTUAL namespace use
  this.getNamespaces().logUsed(effectiveNs);

  // strip prefix if same namespace like parent
  if (this.isLocalNs(effectiveNs)) {
    return { localName: ns.localName };
  } else {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: ns.localName }, effectiveNs);
  }
};

ElementSerializer.prototype.parseGeneric = function(element) {

  var self = this,
      body = this.body;

  var attributes = [];

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(element, function(val, key) {

    var nonNsAttr;

    if (key === '$body') {
      body.push(new BodySerializer().build({ type: 'String' }, val));
    } else
    if (key === '$children') {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(val, function(child) {
        body.push(new ElementSerializer(self).build(child));
      });
    } else
    if (key.indexOf('$') !== 0) {
      nonNsAttr = self.parseNsAttribute(element, key, val);

      if (nonNsAttr) {
        attributes.push({ name: key, value: val });
      }
    }
  });

  return attributes;
};

ElementSerializer.prototype.parseNsAttribute = function(element, name, value) {
  var model = element.$model;

  var nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name);

  var ns;

  // parse xmlns:foo="http://foo.bar"
  if (nameNs.prefix === 'xmlns') {
    ns = { prefix: nameNs.localName, uri: value };
  }

  // parse xmlns="http://foo.bar"
  if (!nameNs.prefix && nameNs.localName === 'xmlns') {
    ns = { uri: value };
  }

  if (!ns) {
    return {
      name: name,
      value: value
    };
  }

  if (model && model.getPackage(value)) {

    // register well known namespace
    this.logNamespace(ns, true, true);
  } else {

    // log custom namespace directly as used
    var actualNs = this.logNamespaceUsed(ns, true);

    this.getNamespaces().logUsed(actualNs);
  }
};


/**
 * Parse namespaces and return a list of left over generic attributes
 *
 * @param  {Object} element
 * @return {Array<Object>}
 */
ElementSerializer.prototype.parseNsAttributes = function(element, attrs) {
  var self = this;

  var genericAttrs = element.$attrs;

  var attributes = [];

  // parse namespace attributes first
  // and log them. push non namespace attributes to a list
  // and process them later
  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(genericAttrs, function(value, name) {

    var nonNsAttr = self.parseNsAttribute(element, name, value);

    if (nonNsAttr) {
      attributes.push(nonNsAttr);
    }
  });

  return attributes;
};

ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attributes, function(attr) {

    // do not serialize xsi:type attribute
    // it is set manually based on the actual implementation type
    if (attr.name === XSI_TYPE) {
      return;
    }

    try {
      self.addAttribute(self.nsAttributeName(attr.name), attr.value);
    } catch (e) {
      console.warn(
        'missing namespace information for ',
        attr.name, '=', attr.value, 'on', element,
        e);
    }
  });
};

ElementSerializer.prototype.parseContainments = function(properties) {

  var self = this,
      body = this.body,
      element = this.element;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(properties, function(p) {
    var value = element.get(p.name),
        isReference = p.isReference,
        isMany = p.isMany;

    if (!isMany) {
      value = [ value ];
    }

    if (p.isBody) {
      body.push(new BodySerializer().build(p, value[0]));
    } else
    if ((0,moddle__WEBPACK_IMPORTED_MODULE_1__.isSimpleType)(p.type)) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {
        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));
      });
    } else
    if (isReference) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {
        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));
      });
    } else {

      // allow serialization via type
      // rather than element name
      var asType = serializeAsType(p),
          asProperty = serializeAsProperty(p);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {
        var serializer;

        if (asType) {
          serializer = new TypeSerializer(self, p);
        } else
        if (asProperty) {
          serializer = new ElementSerializer(self, p);
        } else {
          serializer = new ElementSerializer(self);
        }

        body.push(serializer.build(v));
      });
    }
  });
};

ElementSerializer.prototype.getNamespaces = function(local) {

  var namespaces = this.namespaces,
      parent = this.parent,
      parentNamespaces;

  if (!namespaces) {
    parentNamespaces = parent && parent.getNamespaces();

    if (local || !parentNamespaces) {
      this.namespaces = namespaces = new Namespaces(parentNamespaces);
    } else {
      namespaces = parentNamespaces;
    }
  }

  return namespaces;
};

ElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {
  var namespaces = this.getNamespaces(local);

  var nsUri = ns.uri,
      nsPrefix = ns.prefix;

  var existing = namespaces.byUri(nsUri);

  if (nsPrefix !== 'xml' && (!existing || local)) {
    namespaces.add(ns, wellknown);
  }

  namespaces.mapPrefix(nsPrefix, nsUri);

  return ns;
};

ElementSerializer.prototype.logNamespaceUsed = function(ns, local) {
  var element = this.element,
      model = element.$model,
      namespaces = this.getNamespaces(local);

  // ns may be
  //
  //   * prefix only
  //   * prefix:uri
  //   * localName only

  var prefix = ns.prefix,
      uri = ns.uri,
      newPrefix, idx,
      wellknownUri;

  // handle anonymous namespaces (elementForm=unqualified), cf. #23
  if (!prefix && !uri) {
    return { localName: ns.localName };
  }

  wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;

  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);

  if (!uri) {
    throw new Error('no namespace uri given for prefix <' + prefix + '>');
  }

  ns = namespaces.byUri(uri);

  if (!ns) {
    newPrefix = prefix;
    idx = 1;

    // find a prefix that is not mapped yet
    while (namespaces.uriByPrefix(newPrefix)) {
      newPrefix = prefix + '_' + idx++;
    }

    ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);
  }

  if (prefix) {
    namespaces.mapPrefix(prefix, uri);
  }

  return ns;
};

ElementSerializer.prototype.parseAttributes = function(properties) {
  var self = this,
      element = this.element;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(properties, function(p) {

    var value = element.get(p.name);

    if (p.isReference) {

      if (!p.isMany) {
        value = value.id;
      }
      else {
        var values = [];
        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {
          values.push(v.id);
        });

        // IDREFS is a whitespace-separated list of references.
        value = values.join(' ');
      }

    }

    self.addAttribute(self.nsAttributeName(p), value);
  });
};

ElementSerializer.prototype.addTagName = function(nsTagName) {
  var actualNs = this.logNamespaceUsed(nsTagName);

  this.getNamespaces().logUsed(actualNs);

  return nsName(nsTagName);
};

ElementSerializer.prototype.addAttribute = function(name, value) {
  var attrs = this.attrs;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(value)) {
    value = escapeAttr(value);
  }

  attrs.push({ name: name, value: value });
};

ElementSerializer.prototype.serializeAttributes = function(writer) {
  var attrs = this.attrs,
      namespaces = this.namespaces;

  if (namespaces) {
    attrs = getNsAttrs(namespaces).concat(attrs);
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attrs, function(a) {
    writer
      .append(' ')
      .append(nsName(a.name)).append('="').append(a.value).append('"');
  });
};

ElementSerializer.prototype.serializeTo = function(writer) {
  var firstBody = this.body[0],
      indent = firstBody && firstBody.constructor !== BodySerializer;

  writer
    .appendIndent()
    .append('<' + this.tagName);

  this.serializeAttributes(writer);

  writer.append(firstBody ? '>' : ' />');

  if (firstBody) {

    if (indent) {
      writer
        .appendNewLine()
        .indent();
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(this.body, function(b) {
      b.serializeTo(writer);
    });

    if (indent) {
      writer
        .unindent()
        .appendIndent();
    }

    writer.append('</' + this.tagName + '>');
  }

  writer.appendNewLine();
};

/**
 * A serializer for types that handles serialization of data types
 */
function TypeSerializer(parent, propertyDescriptor) {
  ElementSerializer.call(this, parent, propertyDescriptor);
}

inherits(TypeSerializer, ElementSerializer);

TypeSerializer.prototype.parseNsAttributes = function(element) {

  // extracted attributes
  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);

  var descriptor = element.$descriptor;

  // only serialize xsi:type if necessary
  if (descriptor.name === this.propertyDescriptor.type) {
    return attributes;
  }

  var typeNs = this.typeNs = this.nsTagName(descriptor);
  this.getNamespaces().logUsed(this.typeNs);

  // add xsi:type attribute to represent the elements
  // actual type

  var pkg = element.$model.getPackage(typeNs.uri),
      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';

  this.addAttribute(
    this.nsAttributeName(XSI_TYPE),
    (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName
  );

  return attributes;
};

TypeSerializer.prototype.isLocalNs = function(ns) {
  return ns.uri === (this.typeNs || this.ns).uri;
};

function SavingWriter() {
  this.value = '';

  this.write = function(str) {
    this.value += str;
  };
}

function FormatingWriter(out, format) {

  var indent = [''];

  this.append = function(str) {
    out.write(str);

    return this;
  };

  this.appendNewLine = function() {
    if (format) {
      out.write('\n');
    }

    return this;
  };

  this.appendIndent = function() {
    if (format) {
      out.write(indent.join('  '));
    }

    return this;
  };

  this.indent = function() {
    indent.push('');
    return this;
  };

  this.unindent = function() {
    indent.pop();
    return this;
  };
}

/**
 * A writer for meta-model backed document trees
 *
 * @param {Object} options output options to pass into the writer
 */
function Writer(options) {

  options = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ format: false, preamble: true }, options || {});

  function toXML(tree, writer) {
    var internalWriter = writer || new SavingWriter();
    var formatingWriter = new FormatingWriter(internalWriter, options.format);

    if (options.preamble) {
      formatingWriter.append(XML_PREAMBLE);
    }

    new ElementSerializer().build(tree).serializeTo(formatingWriter);

    if (!writer) {
      return internalWriter.value;
    }
  }

  return {
    toXML: toXML
  };
}




/***/ }),

/***/ "./node_modules/moddle/dist/index.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/moddle/dist/index.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Moddle": () => (/* binding */ Moddle),
/* harmony export */   "coerceType": () => (/* binding */ coerceType),
/* harmony export */   "isBuiltInType": () => (/* binding */ isBuiltIn),
/* harmony export */   "isSimpleType": () => (/* binding */ isSimple),
/* harmony export */   "parseNameNS": () => (/* binding */ parseName)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * Moddle base element.
 */
function Base() { }

Base.prototype.get = function(name) {
  return this.$model.properties.get(this, name);
};

Base.prototype.set = function(name, value) {
  this.$model.properties.set(this, name, value);
};

/**
 * A model element factory.
 *
 * @param {Moddle} model
 * @param {Properties} properties
 */
function Factory(model, properties) {
  this.model = model;
  this.properties = properties;
}


Factory.prototype.createType = function(descriptor) {

  var model = this.model;

  var props = this.properties,
      prototype = Object.create(Base.prototype);

  // initialize default values
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(descriptor.properties, function(p) {
    if (!p.isMany && p.default !== undefined) {
      prototype[p.name] = p.default;
    }
  });

  props.defineModel(prototype, model);
  props.defineDescriptor(prototype, descriptor);

  var name = descriptor.ns.name;

  /**
   * The new type constructor
   */
  function ModdleElement(attrs) {
    props.define(this, '$type', { value: name, enumerable: true });
    props.define(this, '$attrs', { value: {} });
    props.define(this, '$parent', { writable: true });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(attrs, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(val, key) {
      this.set(key, val);
    }, this));
  }

  ModdleElement.prototype = prototype;

  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;

  // static links
  props.defineModel(ModdleElement, model);
  props.defineDescriptor(ModdleElement, descriptor);

  return ModdleElement;
};

/**
 * Built-in moddle types
 */
var BUILTINS = {
  String: true,
  Boolean: true,
  Integer: true,
  Real: true,
  Element: true
};

/**
 * Converters for built in types from string representations
 */
var TYPE_CONVERTERS = {
  String: function(s) { return s; },
  Boolean: function(s) { return s === 'true'; },
  Integer: function(s) { return parseInt(s, 10); },
  Real: function(s) { return parseFloat(s, 10); }
};

/**
 * Convert a type to its real representation
 */
function coerceType(type, value) {

  var converter = TYPE_CONVERTERS[type];

  if (converter) {
    return converter(value);
  } else {
    return value;
  }
}

/**
 * Return whether the given type is built-in
 */
function isBuiltIn(type) {
  return !!BUILTINS[type];
}

/**
 * Return whether the given type is simple
 */
function isSimple(type) {
  return !!TYPE_CONVERTERS[type];
}

/**
 * Parses a namespaced attribute name of the form (ns:)localName to an object,
 * given a default prefix to assume in case no explicit namespace is given.
 *
 * @param {String} name
 * @param {String} [defaultPrefix] the default prefix to take, if none is present.
 *
 * @return {Object} the parsed name
 */
function parseName(name, defaultPrefix) {
  var parts = name.split(/:/),
      localName, prefix;

  // no prefix (i.e. only local name)
  if (parts.length === 1) {
    localName = name;
    prefix = defaultPrefix;
  } else
  // prefix + local name
  if (parts.length === 2) {
    localName = parts[1];
    prefix = parts[0];
  } else {
    throw new Error('expected <prefix:localName> or <localName>, got ' + name);
  }

  name = (prefix ? prefix + ':' : '') + localName;

  return {
    name: name,
    prefix: prefix,
    localName: localName
  };
}

/**
 * A utility to build element descriptors.
 */
function DescriptorBuilder(nameNs) {
  this.ns = nameNs;
  this.name = nameNs.name;
  this.allTypes = [];
  this.allTypesByName = {};
  this.properties = [];
  this.propertiesByName = {};
}


DescriptorBuilder.prototype.build = function() {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.pick)(this, [
    'ns',
    'name',
    'allTypes',
    'allTypesByName',
    'properties',
    'propertiesByName',
    'bodyProperty',
    'idProperty'
  ]);
};

/**
 * Add property at given index.
 *
 * @param {Object} p
 * @param {Number} [idx]
 * @param {Boolean} [validate=true]
 */
DescriptorBuilder.prototype.addProperty = function(p, idx, validate) {

  if (typeof idx === 'boolean') {
    validate = idx;
    idx = undefined;
  }

  this.addNamedProperty(p, validate !== false);

  var properties = this.properties;

  if (idx !== undefined) {
    properties.splice(idx, 0, p);
  } else {
    properties.push(p);
  }
};


DescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {
  var oldNameNs = oldProperty.ns;

  var props = this.properties,
      propertiesByName = this.propertiesByName,
      rename = oldProperty.name !== newProperty.name;

  if (oldProperty.isId) {
    if (!newProperty.isId) {
      throw new Error(
        'property <' + newProperty.ns.name + '> must be id property ' +
        'to refine <' + oldProperty.ns.name + '>');
    }

    this.setIdProperty(newProperty, false);
  }

  if (oldProperty.isBody) {

    if (!newProperty.isBody) {
      throw new Error(
        'property <' + newProperty.ns.name + '> must be body property ' +
        'to refine <' + oldProperty.ns.name + '>');
    }

    // TODO: Check compatibility
    this.setBodyProperty(newProperty, false);
  }

  // validate existence and get location of old property
  var idx = props.indexOf(oldProperty);
  if (idx === -1) {
    throw new Error('property <' + oldNameNs.name + '> not found in property list');
  }

  // remove old property
  props.splice(idx, 1);

  // replacing the named property is intentional
  //
  //  * validate only if this is a "rename" operation
  //  * add at specific index unless we "replace"
  //
  this.addProperty(newProperty, replace ? undefined : idx, rename);

  // make new property available under old name
  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
};


DescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {

  var nsPrefix = p.ns.prefix;
  var parts = targetPropertyName.split('#');

  var name = parseName(parts[0], nsPrefix);
  var attrName = parseName(parts[1], name.prefix).name;

  var redefinedProperty = this.propertiesByName[attrName];
  if (!redefinedProperty) {
    throw new Error('refined property <' + attrName + '> not found');
  } else {
    this.replaceProperty(redefinedProperty, p, replace);
  }

  delete p.redefines;
};

DescriptorBuilder.prototype.addNamedProperty = function(p, validate) {
  var ns = p.ns,
      propsByName = this.propertiesByName;

  if (validate) {
    this.assertNotDefined(p, ns.name);
    this.assertNotDefined(p, ns.localName);
  }

  propsByName[ns.name] = propsByName[ns.localName] = p;
};

DescriptorBuilder.prototype.removeNamedProperty = function(p) {
  var ns = p.ns,
      propsByName = this.propertiesByName;

  delete propsByName[ns.name];
  delete propsByName[ns.localName];
};

DescriptorBuilder.prototype.setBodyProperty = function(p, validate) {

  if (validate && this.bodyProperty) {
    throw new Error(
      'body property defined multiple times ' +
      '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');
  }

  this.bodyProperty = p;
};

DescriptorBuilder.prototype.setIdProperty = function(p, validate) {

  if (validate && this.idProperty) {
    throw new Error(
      'id property defined multiple times ' +
      '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');
  }

  this.idProperty = p;
};

DescriptorBuilder.prototype.assertNotDefined = function(p, name) {
  var propertyName = p.name,
      definedProperty = this.propertiesByName[propertyName];

  if (definedProperty) {
    throw new Error(
      'property <' + propertyName + '> already defined; ' +
      'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +
      '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');
  }
};

DescriptorBuilder.prototype.hasProperty = function(name) {
  return this.propertiesByName[name];
};

DescriptorBuilder.prototype.addTrait = function(t, inherited) {

  var typesByName = this.allTypesByName,
      types = this.allTypes;

  var typeName = t.name;

  if (typeName in typesByName) {
    return;
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(t.properties, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(p) {

    // clone property to allow extensions
    p = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, p, {
      name: p.ns.localName,
      inherited: inherited
    });

    Object.defineProperty(p, 'definedBy', {
      value: t
    });

    var replaces = p.replaces,
        redefines = p.redefines;

    // add replace/redefine support
    if (replaces || redefines) {
      this.redefineProperty(p, replaces || redefines, replaces);
    } else {
      if (p.isBody) {
        this.setBodyProperty(p);
      }
      if (p.isId) {
        this.setIdProperty(p);
      }
      this.addProperty(p);
    }
  }, this));

  types.push(t);
  typesByName[typeName] = t;
};

/**
 * A registry of Moddle packages.
 *
 * @param {Array<Package>} packages
 * @param {Properties} properties
 */
function Registry(packages, properties) {
  this.packageMap = {};
  this.typeMap = {};

  this.packages = [];

  this.properties = properties;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(packages, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(this.registerPackage, this));
}


Registry.prototype.getPackage = function(uriOrPrefix) {
  return this.packageMap[uriOrPrefix];
};

Registry.prototype.getPackages = function() {
  return this.packages;
};


Registry.prototype.registerPackage = function(pkg) {

  // copy package
  pkg = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, pkg);

  var pkgMap = this.packageMap;

  ensureAvailable(pkgMap, pkg, 'prefix');
  ensureAvailable(pkgMap, pkg, 'uri');

  // register types
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(pkg.types, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(descriptor) {
    this.registerType(descriptor, pkg);
  }, this));

  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;
  this.packages.push(pkg);
};


/**
 * Register a type from a specific package with us
 */
Registry.prototype.registerType = function(type, pkg) {

  type = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, type, {
    superClass: (type.superClass || []).slice(),
    extends: (type.extends || []).slice(),
    properties: (type.properties || []).slice(),
    meta: (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)((type.meta || {}))
  });

  var ns = parseName(type.name, pkg.prefix),
      name = ns.name,
      propertiesByName = {};

  // parse properties
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.properties, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(p) {

    // namespace property names
    var propertyNs = parseName(p.name, ns.prefix),
        propertyName = propertyNs.name;

    // namespace property types
    if (!isBuiltIn(p.type)) {
      p.type = parseName(p.type, propertyNs.prefix).name;
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(p, {
      ns: propertyNs,
      name: propertyName
    });

    propertiesByName[propertyName] = p;
  }, this));

  // update ns + name
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(type, {
    ns: ns,
    name: name,
    propertiesByName: propertiesByName
  });

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.extends, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(extendsName) {
    var extended = this.typeMap[extendsName];

    extended.traits = extended.traits || [];
    extended.traits.push(name);
  }, this));

  // link to package
  this.definePackage(type, pkg);

  // register
  this.typeMap[name] = type;
};


/**
 * Traverse the type hierarchy from bottom to top,
 * calling iterator with (type, inherited) for all elements in
 * the inheritance chain.
 *
 * @param {Object} nsName
 * @param {Function} iterator
 * @param {Boolean} [trait=false]
 */
Registry.prototype.mapTypes = function(nsName, iterator, trait) {

  var type = isBuiltIn(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];

  var self = this;

  /**
   * Traverse the selected trait.
   *
   * @param {String} cls
   */
  function traverseTrait(cls) {
    return traverseSuper(cls, true);
  }

  /**
   * Traverse the selected super type or trait
   *
   * @param {String} cls
   * @param {Boolean} [trait=false]
   */
  function traverseSuper(cls, trait) {
    var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);
    self.mapTypes(parentNs, iterator, trait);
  }

  if (!type) {
    throw new Error('unknown type <' + nsName.name + '>');
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.superClass, trait ? traverseTrait : traverseSuper);

  // call iterator with (type, inherited=!trait)
  iterator(type, !trait);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.traits, traverseTrait);
};


/**
 * Returns the effective descriptor for a type.
 *
 * @param  {String} type the namespaced name (ns:localName) of the type
 *
 * @return {Descriptor} the resulting effective descriptor
 */
Registry.prototype.getEffectiveDescriptor = function(name) {

  var nsName = parseName(name);

  var builder = new DescriptorBuilder(nsName);

  this.mapTypes(nsName, function(type, inherited) {
    builder.addTrait(type, inherited);
  });

  var descriptor = builder.build();

  // define package link
  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);

  return descriptor;
};


Registry.prototype.definePackage = function(target, pkg) {
  this.properties.define(target, '$pkg', { value: pkg });
};



///////// helpers ////////////////////////////

function ensureAvailable(packageMap, pkg, identifierKey) {

  var value = pkg[identifierKey];

  if (value in packageMap) {
    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');
  }
}

/**
 * A utility that gets and sets properties of model elements.
 *
 * @param {Model} model
 */
function Properties(model) {
  this.model = model;
}


/**
 * Sets a named property on the target element.
 * If the value is undefined, the property gets deleted.
 *
 * @param {Object} target
 * @param {String} name
 * @param {Object} value
 */
Properties.prototype.set = function(target, name, value) {

  var property = this.model.getPropertyDescriptor(target, name);

  var propertyName = property && property.name;

  if (isUndefined(value)) {
    // unset the property, if the specified value is undefined;
    // delete from $attrs (for extensions) or the target itself
    if (property) {
      delete target[propertyName];
    } else {
      delete target.$attrs[name];
    }
  } else {
    // set the property, defining well defined properties on the fly
    // or simply updating them in target.$attrs (for extensions)
    if (property) {
      if (propertyName in target) {
        target[propertyName] = value;
      } else {
        defineProperty(target, property, value);
      }
    } else {
      target.$attrs[name] = value;
    }
  }
};

/**
 * Returns the named property of the given element
 *
 * @param  {Object} target
 * @param  {String} name
 *
 * @return {Object}
 */
Properties.prototype.get = function(target, name) {

  var property = this.model.getPropertyDescriptor(target, name);

  if (!property) {
    return target.$attrs[name];
  }

  var propertyName = property.name;

  // check if access to collection property and lazily initialize it
  if (!target[propertyName] && property.isMany) {
    defineProperty(target, property, []);
  }

  return target[propertyName];
};


/**
 * Define a property on the target element
 *
 * @param  {Object} target
 * @param  {String} name
 * @param  {Object} options
 */
Properties.prototype.define = function(target, name, options) {
  Object.defineProperty(target, name, options);
};


/**
 * Define the descriptor for an element
 */
Properties.prototype.defineDescriptor = function(target, descriptor) {
  this.define(target, '$descriptor', { value: descriptor });
};

/**
 * Define the model for an element
 */
Properties.prototype.defineModel = function(target, model) {
  this.define(target, '$model', { value: model });
};


function isUndefined(val) {
  return typeof val === 'undefined';
}

function defineProperty(target, property, value) {
  Object.defineProperty(target, property.name, {
    enumerable: !property.isReference,
    writable: true,
    value: value,
    configurable: true
  });
}

//// Moddle implementation /////////////////////////////////////////////////

/**
 * @class Moddle
 *
 * A model that can be used to create elements of a specific type.
 *
 * @example
 *
 * var Moddle = require('moddle');
 *
 * var pkg = {
 *   name: 'mypackage',
 *   prefix: 'my',
 *   types: [
 *     { name: 'Root' }
 *   ]
 * };
 *
 * var moddle = new Moddle([pkg]);
 *
 * @param {Array<Package>} packages the packages to contain
 */
function Moddle(packages) {

  this.properties = new Properties(this);

  this.factory = new Factory(this, this.properties);
  this.registry = new Registry(packages, this.properties);

  this.typeCache = {};
}


/**
 * Create an instance of the specified type.
 *
 * @method Moddle#create
 *
 * @example
 *
 * var foo = moddle.create('my:Foo');
 * var bar = moddle.create('my:Bar', { id: 'BAR_1' });
 *
 * @param  {String|Object} descriptor the type descriptor or name know to the model
 * @param  {Object} attrs   a number of attributes to initialize the model instance with
 * @return {Object}         model instance
 */
Moddle.prototype.create = function(descriptor, attrs) {
  var Type = this.getType(descriptor);

  if (!Type) {
    throw new Error('unknown type <' + descriptor + '>');
  }

  return new Type(attrs);
};


/**
 * Returns the type representing a given descriptor
 *
 * @method Moddle#getType
 *
 * @example
 *
 * var Foo = moddle.getType('my:Foo');
 * var foo = new Foo({ 'id' : 'FOO_1' });
 *
 * @param  {String|Object} descriptor the type descriptor or name know to the model
 * @return {Object}         the type representing the descriptor
 */
Moddle.prototype.getType = function(descriptor) {

  var cache = this.typeCache;

  var name = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isString)(descriptor) ? descriptor : descriptor.ns.name;

  var type = cache[name];

  if (!type) {
    descriptor = this.registry.getEffectiveDescriptor(name);
    type = cache[name] = this.factory.createType(descriptor);
  }

  return type;
};


/**
 * Creates an any-element type to be used within model instances.
 *
 * This can be used to create custom elements that lie outside the meta-model.
 * The created element contains all the meta-data required to serialize it
 * as part of meta-model elements.
 *
 * @method Moddle#createAny
 *
 * @example
 *
 * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {
 *   value: 'bar'
 * });
 *
 * var container = moddle.create('my:Container', 'http://my', {
 *   any: [ foo ]
 * });
 *
 * // go ahead and serialize the stuff
 *
 *
 * @param  {String} name  the name of the element
 * @param  {String} nsUri the namespace uri of the element
 * @param  {Object} [properties] a map of properties to initialize the instance with
 * @return {Object} the any type instance
 */
Moddle.prototype.createAny = function(name, nsUri, properties) {

  var nameNs = parseName(name);

  var element = {
    $type: name,
    $instanceOf: function(type) {
      return type === this.$type;
    }
  };

  var descriptor = {
    name: name,
    isGeneric: true,
    ns: {
      prefix: nameNs.prefix,
      localName: nameNs.localName,
      uri: nsUri
    }
  };

  this.properties.defineDescriptor(element, descriptor);
  this.properties.defineModel(element, this);
  this.properties.define(element, '$parent', { enumerable: false, writable: true });

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(properties, function(a, key) {
    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(a) && a.value !== undefined) {
      element[a.name] = a.value;
    } else {
      element[key] = a;
    }
  });

  return element;
};

/**
 * Returns a registered package by uri or prefix
 *
 * @return {Object} the package
 */
Moddle.prototype.getPackage = function(uriOrPrefix) {
  return this.registry.getPackage(uriOrPrefix);
};

/**
 * Returns a snapshot of all known packages
 *
 * @return {Object} the package
 */
Moddle.prototype.getPackages = function() {
  return this.registry.getPackages();
};

/**
 * Returns the descriptor for an element
 */
Moddle.prototype.getElementDescriptor = function(element) {
  return element.$descriptor;
};

/**
 * Returns true if the given descriptor or instance
 * represents the given type.
 *
 * May be applied to this, if element is omitted.
 */
Moddle.prototype.hasType = function(element, type) {
  if (type === undefined) {
    type = element;
    element = this;
  }

  var descriptor = element.$model.getElementDescriptor(element);

  return (type in descriptor.allTypesByName);
};

/**
 * Returns the descriptor of an elements named property
 */
Moddle.prototype.getPropertyDescriptor = function(element, property) {
  return this.getElementDescriptor(element).propertiesByName[property];
};

/**
 * Returns a mapped type's descriptor
 */
Moddle.prototype.getTypeDescriptor = function(type) {
  return this.registry.typeMap[type];
};




/***/ }),

/***/ "./node_modules/object-refs/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-refs/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/refs */ "./node_modules/object-refs/lib/refs.js");

module.exports.Collection = __webpack_require__(/*! ./lib/collection */ "./node_modules/object-refs/lib/collection.js");

/***/ }),

/***/ "./node_modules/object-refs/lib/collection.js":
/*!****************************************************!*\
  !*** ./node_modules/object-refs/lib/collection.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";


/**
 * An empty collection stub. Use {@link RefsCollection.extend} to extend a
 * collection with ref semantics.
 *
 * @class RefsCollection
 */

/**
 * Extends a collection with {@link Refs} aware methods
 *
 * @memberof RefsCollection
 * @static
 *
 * @param  {Array<Object>} collection
 * @param  {Refs} refs instance
 * @param  {Object} property represented by the collection
 * @param  {Object} target object the collection is attached to
 *
 * @return {RefsCollection<Object>} the extended array
 */
function extend(collection, refs, property, target) {

  var inverseProperty = property.inverse;

  /**
   * Removes the given element from the array and returns it.
   *
   * @method RefsCollection#remove
   *
   * @param {Object} element the element to remove
   */
  Object.defineProperty(collection, 'remove', {
    value: function(element) {
      var idx = this.indexOf(element);
      if (idx !== -1) {
        this.splice(idx, 1);

        // unset inverse
        refs.unset(element, inverseProperty, target);
      }

      return element;
    }
  });

  /**
   * Returns true if the collection contains the given element
   *
   * @method RefsCollection#contains
   *
   * @param {Object} element the element to check for
   */
  Object.defineProperty(collection, 'contains', {
    value: function(element) {
      return this.indexOf(element) !== -1;
    }
  });

  /**
   * Adds an element to the array, unless it exists already (set semantics).
   *
   * @method RefsCollection#add
   *
   * @param {Object} element the element to add
   * @param {Number} optional index to add element to
   *                 (possibly moving other elements around)
   */
  Object.defineProperty(collection, 'add', {
    value: function(element, idx) {

      var currentIdx = this.indexOf(element);

      if (typeof idx === 'undefined') {

        if (currentIdx !== -1) {
          // element already in collection (!)
          return;
        }

        // add to end of array, as no idx is specified
        idx = this.length;
      }

      // handle already in collection
      if (currentIdx !== -1) {

        // remove element from currentIdx
        this.splice(currentIdx, 1);
      }

      // add element at idx
      this.splice(idx, 0, element);

      if (currentIdx === -1) {
        // set inverse, unless element was
        // in collection already
        refs.set(element, inverseProperty, target);
      }
    }
  });

  // a simple marker, identifying this element
  // as being a refs collection
  Object.defineProperty(collection, '__refs_collection', {
    value: true
  });

  return collection;
}


function isExtended(collection) {
  return collection.__refs_collection === true;
}

module.exports.extend = extend;

module.exports.isExtended = isExtended;

/***/ }),

/***/ "./node_modules/object-refs/lib/refs.js":
/*!**********************************************!*\
  !*** ./node_modules/object-refs/lib/refs.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Collection = __webpack_require__(/*! ./collection */ "./node_modules/object-refs/lib/collection.js");

function hasOwnProperty(e, property) {
  return Object.prototype.hasOwnProperty.call(e, property.name || property);
}

function defineCollectionProperty(ref, property, target) {

  var collection = Collection.extend(target[property.name] || [], ref, property, target);

  Object.defineProperty(target, property.name, {
    enumerable: property.enumerable,
    value: collection
  });

  if (collection.length) {

    collection.forEach(function(o) {
      ref.set(o, property.inverse, target);
    });
  }
}


function defineProperty(ref, property, target) {

  var inverseProperty = property.inverse;

  var _value = target[property.name];

  Object.defineProperty(target, property.name, {
    configurable: property.configurable,
    enumerable: property.enumerable,

    get: function() {
      return _value;
    },

    set: function(value) {

      // return if we already performed all changes
      if (value === _value) {
        return;
      }

      var old = _value;

      // temporary set null
      _value = null;

      if (old) {
        ref.unset(old, inverseProperty, target);
      }

      // set new value
      _value = value;

      // set inverse value
      ref.set(_value, inverseProperty, target);
    }
  });

}

/**
 * Creates a new references object defining two inversly related
 * attribute descriptors a and b.
 *
 * <p>
 *   When bound to an object using {@link Refs#bind} the references
 *   get activated and ensure that add and remove operations are applied
 *   reversely, too.
 * </p>
 *
 * <p>
 *   For attributes represented as collections {@link Refs} provides the
 *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions
 *   that must be used to properly hook into the inverse change mechanism.
 * </p>
 *
 * @class Refs
 *
 * @classdesc A bi-directional reference between two attributes.
 *
 * @param {Refs.AttributeDescriptor} a property descriptor
 * @param {Refs.AttributeDescriptor} b property descriptor
 *
 * @example
 *
 * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });
 *
 * var car = { name: 'toyota' };
 * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];
 *
 * refs.bind(car, 'wheels');
 *
 * car.wheels // []
 * car.wheels.add(wheels[0]);
 * car.wheels.add(wheels[1]);
 *
 * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]
 *
 * wheels[0].car // { name: 'toyota' };
 * car.wheels.remove(wheels[0]);
 *
 * wheels[0].car // undefined
 */
function Refs(a, b) {

  if (!(this instanceof Refs)) {
    return new Refs(a, b);
  }

  // link
  a.inverse = b;
  b.inverse = a;

  this.props = {};
  this.props[a.name] = a;
  this.props[b.name] = b;
}

/**
 * Binds one side of a bi-directional reference to a
 * target object.
 *
 * @memberOf Refs
 *
 * @param  {Object} target
 * @param  {String} property
 */
Refs.prototype.bind = function(target, property) {
  if (typeof property === 'string') {
    if (!this.props[property]) {
      throw new Error('no property <' + property + '> in ref');
    }
    property = this.props[property];
  }

  if (property.collection) {
    defineCollectionProperty(this, property, target);
  } else {
    defineProperty(this, property, target);
  }
};

Refs.prototype.ensureRefsCollection = function(target, property) {

  var collection = target[property.name];

  if (!Collection.isExtended(collection)) {
    defineCollectionProperty(this, property, target);
  }

  return collection;
};

Refs.prototype.ensureBound = function(target, property) {
  if (!hasOwnProperty(target, property)) {
    this.bind(target, property);
  }
};

Refs.prototype.unset = function(target, property, value) {

  if (target) {
    this.ensureBound(target, property);

    if (property.collection) {
      this.ensureRefsCollection(target, property).remove(value);
    } else {
      target[property.name] = undefined;
    }
  }
};

Refs.prototype.set = function(target, property, value) {

  if (target) {
    this.ensureBound(target, property);

    if (property.collection) {
      this.ensureRefsCollection(target, property).add(value);
    } else {
      target[property.name] = value;
    }
  }
};

module.exports = Refs;


/**
 * An attribute descriptor to be used specify an attribute in a {@link Refs} instance
 *
 * @typedef {Object} Refs.AttributeDescriptor
 * @property {String} name
 * @property {boolean} [collection=false]
 * @property {boolean} [enumerable=false]
 */

/***/ }),

/***/ "./node_modules/path-intersection/intersect.js":
/*!*****************************************************!*\
  !*** ./node_modules/path-intersection/intersect.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * This file contains source code adapted from Snap.svg (licensed Apache-2.0).
 *
 * @see https://github.com/adobe-webplatform/Snap.svg/blob/master/src/path.js
 */

/* eslint no-fallthrough: "off" */

var p2s = /,?([a-z]),?/gi,
    toFloat = parseFloat,
    math = Math,
    PI = math.PI,
    mmin = math.min,
    mmax = math.max,
    pow = math.pow,
    abs = math.abs,
    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?[\s]*,?[\s]*)+)/ig,
    pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)[\s]*,?[\s]*/ig;

var isArray = Array.isArray || function(o) { return o instanceof Array; };

function hasProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}

function clone(obj) {

  if (typeof obj == 'function' || Object(obj) !== obj) {
    return obj;
  }

  var res = new obj.constructor;

  for (var key in obj) {
    if (hasProperty(obj, key)) {
      res[key] = clone(obj[key]);
    }
  }

  return res;
}

function repush(array, item) {
  for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
    return array.push(array.splice(i, 1)[0]);
  }
}

function cacher(f) {

  function newf() {

    var arg = Array.prototype.slice.call(arguments, 0),
        args = arg.join('\u2400'),
        cache = newf.cache = newf.cache || {},
        count = newf.count = newf.count || [];

    if (hasProperty(cache, args)) {
      repush(count, args);
      return cache[args];
    }

    count.length >= 1e3 && delete cache[count.shift()];
    count.push(args);
    cache[args] = f.apply(0, arg);

    return cache[args];
  }
  return newf;
}

function parsePathString(pathString) {

  if (!pathString) {
    return null;
  }

  var pth = paths(pathString);

  if (pth.arr) {
    return clone(pth.arr);
  }

  var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 },
      data = [];

  if (isArray(pathString) && isArray(pathString[0])) { // rough assumption
    data = clone(pathString);
  }

  if (!data.length) {

    String(pathString).replace(pathCommand, function(a, b, c) {
      var params = [],
          name = b.toLowerCase();

      c.replace(pathValues, function(a, b) {
        b && params.push(+b);
      });

      if (name == 'm' && params.length > 2) {
        data.push([b].concat(params.splice(0, 2)));
        name = 'l';
        b = b == 'm' ? 'l' : 'L';
      }

      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    });
  }

  data.toString = paths.toString;
  pth.arr = clone(data);

  return data;
}

function paths(ps) {
  var p = paths.ps = paths.ps || {};

  if (p[ps]) {
    p[ps].sleep = 100;
  } else {
    p[ps] = {
      sleep: 100
    };
  }

  setTimeout(function() {
    for (var key in p) {
      if (hasProperty(p, key) && key != ps) {
        p[key].sleep--;
        !p[key].sleep && delete p[key];
      }
    }
  });

  return p[ps];
}

function rectBBox(x, y, width, height) {

  if (arguments.length === 1) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }

  return {
    x: x,
    y: y,
    width: width,
    height: height,
    x2: x + width,
    y2: y + height
  };
}

function pathToString() {
  return this.join(',').replace(p2s, '$1');
}

function pathClone(pathArray) {
  var res = clone(pathArray);
  res.toString = pathToString;
  return res;
}

function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t,
      t13 = pow(t1, 3),
      t12 = pow(t1, 2),
      t2 = t * t,
      t3 = t2 * t,
      x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
      y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;

  return {
    x: fixError(x),
    y: fixError(y)
  };
}

function bezierBBox(points) {

  var bbox = curveBBox.apply(null, points);

  return rectBBox(
    bbox.x0,
    bbox.y0,
    bbox.x1 - bbox.x0,
    bbox.y1 - bbox.y0
  );
}

function isPointInsideBBox(bbox, x, y) {
  return x >= bbox.x &&
    x <= bbox.x + bbox.width &&
    y >= bbox.y &&
    y <= bbox.y + bbox.height;
}

function isBBoxIntersect(bbox1, bbox2) {
  bbox1 = rectBBox(bbox1);
  bbox2 = rectBBox(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
    || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
    || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
    || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
    || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
    || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
    || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
    || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
    || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
        || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
    && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
        || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
}

function base3(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
      t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
}

function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {

  if (z == null) {
    z = 1;
  }

  z = z > 1 ? 1 : z < 0 ? 0 : z;

  var z2 = z / 2,
      n = 12,
      Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],
      Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
      sum = 0;

  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2,
        xbase = base3(ct, x1, x2, x3, x4),
        ybase = base3(ct, y1, y2, y3, y4),
        comb = xbase * xbase + ybase * ybase;

    sum += Cvalues[i] * math.sqrt(comb);
  }

  return z2 * sum;
}


function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4) {

  if (
    mmax(x1, x2) < mmin(x3, x4) ||
      mmin(x1, x2) > mmax(x3, x4) ||
      mmax(y1, y2) < mmin(y3, y4) ||
      mmin(y1, y2) > mmax(y3, y4)
  ) {
    return;
  }

  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
      denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

  if (!denominator) {
    return;
  }

  var px = fixError(nx / denominator),
      py = fixError(ny / denominator),
      px2 = +px.toFixed(2),
      py2 = +py.toFixed(2);

  if (
    px2 < +mmin(x1, x2).toFixed(2) ||
      px2 > +mmax(x1, x2).toFixed(2) ||
      px2 < +mmin(x3, x4).toFixed(2) ||
      px2 > +mmax(x3, x4).toFixed(2) ||
      py2 < +mmin(y1, y2).toFixed(2) ||
      py2 > +mmax(y1, y2).toFixed(2) ||
      py2 < +mmin(y3, y4).toFixed(2) ||
      py2 > +mmax(y3, y4).toFixed(2)
  ) {
    return;
  }

  return { x: px, y: py };
}

function fixError(number) {
  return Math.round(number * 100000000000) / 100000000000;
}

function findBezierIntersections(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1),
      bbox2 = bezierBBox(bez2);

  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }

  // As an optimization, lines will have only 1 segment

  var l1 = bezlen.apply(0, bez1),
      l2 = bezlen.apply(0, bez2),
      n1 = isLine(bez1) ? 1 : ~~(l1 / 5) || 1,
      n2 = isLine(bez2) ? 1 : ~~(l2 / 5) || 1,
      dots1 = [],
      dots2 = [],
      xy = {},
      res = justCount ? 0 : [];

  for (var i = 0; i < n1 + 1; i++) {
    var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({ x: p.x, y: p.y, t: i / n1 });
  }

  for (i = 0; i < n2 + 1; i++) {
    p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({ x: p.x, y: p.y, t: i / n2 });
  }

  for (i = 0; i < n1; i++) {

    for (var j = 0; j < n2; j++) {
      var di = dots1[i],
          di1 = dots1[i + 1],
          dj = dots2[j],
          dj1 = dots2[j + 1],
          ci = abs(di1.x - di.x) < .01 ? 'y' : 'x',
          cj = abs(dj1.x - dj.x) < .01 ? 'y' : 'x',
          is = intersectLines(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y),
          key;

      if (is) {
        key = is.x.toFixed(9) + '#' + is.y.toFixed(9);

        if (xy[key]) {
          continue;
        }

        xy[key] = true;

        var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
            t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);

        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {

          if (justCount) {
            res++;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1: t1,
              t2: t2
            });
          }
        }
      }
    }
  }

  return res;
}


/**
 * Find or counts the intersections between two SVG paths.
 *
 * Returns a number in counting mode and a list of intersections otherwise.
 *
 * A single intersection entry contains the intersection coordinates (x, y)
 * as well as additional information regarding the intersecting segments
 * on each path (segment1, segment2) and the relative location of the
 * intersection on these segments (t1, t2).
 *
 * The path may be an SVG path string or a list of path components
 * such as `[ [ 'M', 0, 10 ], [ 'L', 20, 0 ] ]`.
 *
 * @example
 *
 * var intersections = findPathIntersections(
 *   'M0,0L100,100',
 *   [ [ 'M', 0, 100 ], [ 'L', 100, 0 ] ]
 * );
 *
 * // intersections = [
 * //   { x: 50, y: 50, segment1: 1, segment2: 1, t1: 0.5, t2: 0.5 }
 * // ]
 *
 * @param {String|Array<PathDef>} path1
 * @param {String|Array<PathDef>} path2
 * @param {Boolean} [justCount=false]
 *
 * @return {Array<Intersection>|Number}
 */
function findPathIntersections(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);

  var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
      res = justCount ? 0 : [];

  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi = path1[i];

    if (pi[0] == 'M') {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {

      if (pi[0] == 'C') {
        bez1 = [x1, y1].concat(pi.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }

      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];

        if (pj[0] == 'M') {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {

          if (pj[0] == 'C') {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }

          var intr = findBezierIntersections(bez1, bez2, justCount);

          if (justCount) {
            res += intr;
          } else {

            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }

            res = res.concat(intr);
          }
        }
      }
    }
  }

  return res;
}


function pathToAbsolute(pathArray) {
  var pth = paths(pathArray);

  if (pth.abs) {
    return pathClone(pth.abs);
  }

  if (!isArray(pathArray) || !isArray(pathArray && pathArray[0])) { // rough assumption
    pathArray = parsePathString(pathArray);
  }

  if (!pathArray || !pathArray.length) {
    return [['M', 0, 0]];
  }

  var res = [],
      x = 0,
      y = 0,
      mx = 0,
      my = 0,
      start = 0,
      pa0;

  if (pathArray[0][0] == 'M') {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ['M', x, y];
  }

  for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];

    if (pa0 != pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();

      switch (r[0]) {
      case 'A':
        r[1] = pa[1];
        r[2] = pa[2];
        r[3] = pa[3];
        r[4] = pa[4];
        r[5] = pa[5];
        r[6] = +pa[6] + x;
        r[7] = +pa[7] + y;
        break;
      case 'V':
        r[1] = +pa[1] + y;
        break;
      case 'H':
        r[1] = +pa[1] + x;
        break;
      case 'M':
        mx = +pa[1] + x;
        my = +pa[2] + y;
      default:
        for (var j = 1, jj = pa.length; j < jj; j++) {
          r[j] = +pa[j] + ((j % 2) ? x : y);
        }
      }
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }
    pa0 = pa0.toUpperCase();

    switch (r[0]) {
    case 'Z':
      x = +mx;
      y = +my;
      break;
    case 'H':
      x = r[1];
      break;
    case 'V':
      y = r[1];
      break;
    case 'M':
      mx = r[r.length - 2];
      my = r[r.length - 1];
    default:
      x = r[r.length - 2];
      y = r[r.length - 1];
    }
  }

  res.toString = pathToString;
  pth.abs = pathClone(res);

  return res;
}

function isLine(bez) {
  return (
    bez[0] === bez[2] &&
    bez[1] === bez[3] &&
    bez[4] === bez[6] &&
    bez[5] === bez[7]
  );
}

function lineToCurve(x1, y1, x2, y2) {
  return [
    x1, y1, x2,
    y2, x2, y2
  ];
}

function qubicToCurve(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3,
      _23 = 2 / 3;

  return [
    _13 * x1 + _23 * ax,
    _13 * y1 + _23 * ay,
    _13 * x2 + _23 * ax,
    _13 * y2 + _23 * ay,
    x2,
    y2
  ];
}

function arcToCurve(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {

  // for more information of where this math came from visit:
  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  var _120 = PI * 120 / 180,
      rad = PI / 180 * (+angle || 0),
      res = [],
      xy,
      rotate = cacher(function(x, y, rad) {
        var X = x * math.cos(rad) - y * math.sin(rad),
            Y = x * math.sin(rad) + y * math.cos(rad);

        return { x: X, y: Y };
      });

  if (!recursive) {
    xy = rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;

    var x = (x1 - x2) / 2,
        y = (y1 - y2) / 2;

    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);

    if (h > 1) {
      h = math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }

    var rx2 = rx * rx,
        ry2 = ry * ry,
        k = (large_arc_flag == sweep_flag ? -1 : 1) *
            math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
        cx = k * rx * y / ry + (x1 + x2) / 2,
        cy = k * -ry * x / rx + (y1 + y2) / 2,
        f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
        f2 = math.asin(((y2 - cy) / ry).toFixed(9));

    f1 = x1 < cx ? PI - f1 : f1;
    f2 = x2 < cx ? PI - f2 : f2;
    f1 < 0 && (f1 = PI * 2 + f1);
    f2 < 0 && (f2 = PI * 2 + f2);

    if (sweep_flag && f1 > f2) {
      f1 = f1 - PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }

  var df = f2 - f1;

  if (abs(df) > _120) {
    var f2old = f2,
        x2old = x2,
        y2old = y2;

    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * math.cos(f2);
    y2 = cy + ry * math.sin(f2);
    res = arcToCurve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }

  df = f2 - f1;

  var c1 = math.cos(f1),
      s1 = math.sin(f1),
      c2 = math.cos(f2),
      s2 = math.sin(f2),
      t = math.tan(df / 4),
      hx = 4 / 3 * rx * t,
      hy = 4 / 3 * ry * t,
      m1 = [x1, y1],
      m2 = [x1 + hx * s1, y1 - hy * c1],
      m3 = [x2 + hx * s2, y2 - hy * c2],
      m4 = [x2, y2];

  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];

  if (recursive) {
    return [m2, m3, m4].concat(res);
  } else {
    res = [m2, m3, m4].concat(res).join().split(',');
    var newres = [];

    for (var i = 0, ii = res.length; i < ii; i++) {
      newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
    }

    return newres;
  }
}

// Returns bounding box of cubic bezier curve.
// Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
// Original version: NISHIO Hirokazu
// Modifications: https://github.com/timo22345
function curveBBox(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [],
      bounds = [[], []],
      a, b, c, t, t1, t2, b2ac, sqrtb2ac;

  for (var i = 0; i < 2; ++i) {

    if (i == 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }

    if (abs(a) < 1e-12) {

      if (abs(b) < 1e-12) {
        continue;
      }

      t = -c / b;

      if (0 < t && t < 1) {
        tvalues.push(t);
      }

      continue;
    }

    b2ac = b * b - 4 * c * a;
    sqrtb2ac = math.sqrt(b2ac);

    if (b2ac < 0) {
      continue;
    }

    t1 = (-b + sqrtb2ac) / (2 * a);

    if (0 < t1 && t1 < 1) {
      tvalues.push(t1);
    }

    t2 = (-b - sqrtb2ac) / (2 * a);

    if (0 < t2 && t2 < 1) {
      tvalues.push(t2);
    }
  }

  var j = tvalues.length,
      jlen = j,
      mt;

  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
    bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
  }

  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;

  return {
    x0: mmin.apply(0, bounds[0]),
    y0: mmin.apply(0, bounds[1]),
    x1: mmax.apply(0, bounds[0]),
    y1: mmax.apply(0, bounds[1])
  };
}

function pathToCurve(path) {

  var pth = paths(path);

  // return cached curve, if existing
  if (pth.curve) {
    return pathClone(pth.curve);
  }

  var curvedPath = pathToAbsolute(path),
      attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
      processPath = function(path, d, pathCommand) {
        var nx, ny;

        if (!path) {
          return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
        }

        !(path[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);

        switch (path[0]) {
        case 'M':
          d.X = path[1];
          d.Y = path[2];
          break;
        case 'A':
          path = ['C'].concat(arcToCurve.apply(0, [d.x, d.y].concat(path.slice(1))));
          break;
        case 'S':
          if (pathCommand == 'C' || pathCommand == 'S') {

            // In 'S' case we have to take into account, if the previous command is C/S.
            nx = d.x * 2 - d.bx;

            // And reflect the previous
            ny = d.y * 2 - d.by;

            // command's control point relative to the current point.
          }
          else {

            // or some else or nothing
            nx = d.x;
            ny = d.y;
          }
          path = ['C', nx, ny].concat(path.slice(1));
          break;
        case 'T':
          if (pathCommand == 'Q' || pathCommand == 'T') {

            // In 'T' case we have to take into account, if the previous command is Q/T.
            d.qx = d.x * 2 - d.qx;

            // And make a reflection similar
            d.qy = d.y * 2 - d.qy;

            // to case 'S'.
          }
          else {

            // or something else or nothing
            d.qx = d.x;
            d.qy = d.y;
          }
          path = ['C'].concat(qubicToCurve(d.x, d.y, d.qx, d.qy, path[1], path[2]));
          break;
        case 'Q':
          d.qx = path[1];
          d.qy = path[2];
          path = ['C'].concat(qubicToCurve(d.x, d.y, path[1], path[2], path[3], path[4]));
          break;
        case 'L':
          path = ['C'].concat(lineToCurve(d.x, d.y, path[1], path[2]));
          break;
        case 'H':
          path = ['C'].concat(lineToCurve(d.x, d.y, path[1], d.y));
          break;
        case 'V':
          path = ['C'].concat(lineToCurve(d.x, d.y, d.x, path[1]));
          break;
        case 'Z':
          path = ['C'].concat(lineToCurve(d.x, d.y, d.X, d.Y));
          break;
        }

        return path;
      },

      fixArc = function(pp, i) {

        if (pp[i].length > 7) {
          pp[i].shift();
          var pi = pp[i];

          while (pi.length) {
            pathCommands[i] = 'A'; // if created multiple C:s, their original seg is saved
            pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
          }

          pp.splice(i, 1);
          ii = curvedPath.length;
        }
      },

      pathCommands = [], // path commands of original path p
      pfirst = '', // temporary holder for original path command
      pathCommand = ''; // holder for previous path command of original path

  for (var i = 0, ii = curvedPath.length; i < ii; i++) {
    curvedPath[i] && (pfirst = curvedPath[i][0]); // save current path command

    if (pfirst != 'C') // C is not saved yet, because it may be result of conversion
    {
      pathCommands[i] = pfirst; // Save current path command
      i && (pathCommand = pathCommands[i - 1]); // Get previous path command pathCommand
    }
    curvedPath[i] = processPath(curvedPath[i], attrs, pathCommand); // Previous path command is inputted to processPath

    if (pathCommands[i] != 'A' && pfirst == 'C') pathCommands[i] = 'C'; // A is the only command
    // which may produce multiple C:s
    // so we have to make sure that C is also C in original path

    fixArc(curvedPath, i); // fixArc adds also the right amount of A:s to pathCommands

    var seg = curvedPath[i],
        seglen = seg.length;

    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
  }

  // cache curve
  pth.curve = pathClone(curvedPath);

  return curvedPath;
}

module.exports = findPathIntersections;


/***/ }),

/***/ "./node_modules/saxen/dist/index.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/saxen/dist/index.esm.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Parser": () => (/* binding */ Parser),
/* harmony export */   "decode": () => (/* binding */ decodeEntities)
/* harmony export */ });
var fromCharCode = String.fromCharCode;

var hasOwnProperty = Object.prototype.hasOwnProperty;

var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;

var ENTITY_MAPPING = {
  'amp': '&',
  'apos': '\'',
  'gt': '>',
  'lt': '<',
  'quot': '"'
};

// map UPPERCASE variants of supported special chars
Object.keys(ENTITY_MAPPING).forEach(function(k) {
  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];
});


function replaceEntities(_, d, x, z) {

  // reserved names, i.e. &nbsp;
  if (z) {
    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {
      return ENTITY_MAPPING[z];
    } else {

      // fall back to original value
      return '&' + z + ';';
    }
  }

  // decimal encoded char
  if (d) {
    return fromCharCode(d);
  }

  // hex encoded char
  return fromCharCode(parseInt(x, 16));
}


/**
 * A basic entity decoder that can decode a minimal
 * sub-set of reserved names (&amp;) as well as
 * hex (&#xaaf;) and decimal (&#1231;) encoded characters.
 *
 * @param {string} str
 *
 * @return {string} decoded string
 */
function decodeEntities(s) {
  if (s.length > 3 && s.indexOf('&') !== -1) {
    return s.replace(ENTITY_PATTERN, replaceEntities);
  }

  return s;
}

var XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';
var XSI_PREFIX = 'xsi';
var XSI_TYPE = 'xsi:type';

var NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';

function error(msg) {
  return new Error(msg);
}

function missingNamespaceForPrefix(prefix) {
  return 'missing namespace for prefix <' + prefix + '>';
}

function getter(getFn) {
  return {
    'get': getFn,
    'enumerable': true
  };
}

function cloneNsMatrix(nsMatrix) {
  var clone = {}, key;
  for (key in nsMatrix) {
    clone[key] = nsMatrix[key];
  }
  return clone;
}

function uriPrefix(prefix) {
  return prefix + '$uri';
}

function buildNsMatrix(nsUriToPrefix) {
  var nsMatrix = {},
      uri,
      prefix;

  for (uri in nsUriToPrefix) {
    prefix = nsUriToPrefix[uri];
    nsMatrix[prefix] = prefix;
    nsMatrix[uriPrefix(prefix)] = uri;
  }

  return nsMatrix;
}

function noopGetContext() {
  return { 'line': 0, 'column': 0 };
}

function throwFunc(err) {
  throw err;
}

/**
 * Creates a new parser with the given options.
 *
 * @constructor
 *
 * @param  {!Object<string, ?>=} options
 */
function Parser(options) {

  if (!this) {
    return new Parser(options);
  }

  var proxy = options && options['proxy'];

  var onText,
      onOpenTag,
      onCloseTag,
      onCDATA,
      onError = throwFunc,
      onWarning,
      onComment,
      onQuestion,
      onAttention;

  var getContext = noopGetContext;

  /**
   * Do we need to parse the current elements attributes for namespaces?
   *
   * @type {boolean}
   */
  var maybeNS = false;

  /**
   * Do we process namespaces at all?
   *
   * @type {boolean}
   */
  var isNamespace = false;

  /**
   * The caught error returned on parse end
   *
   * @type {Error}
   */
  var returnError = null;

  /**
   * Should we stop parsing?
   *
   * @type {boolean}
   */
  var parseStop = false;

  /**
   * A map of { uri: prefix } used by the parser.
   *
   * This map will ensure we can normalize prefixes during processing;
   * for each uri, only one prefix will be exposed to the handlers.
   *
   * @type {!Object<string, string>}}
   */
  var nsUriToPrefix;

  /**
   * Handle parse error.
   *
   * @param  {string|Error} err
   */
  function handleError(err) {
    if (!(err instanceof Error)) {
      err = error(err);
    }

    returnError = err;

    onError(err, getContext);
  }

  /**
   * Handle parse error.
   *
   * @param  {string|Error} err
   */
  function handleWarning(err) {

    if (!onWarning) {
      return;
    }

    if (!(err instanceof Error)) {
      err = error(err);
    }

    onWarning(err, getContext);
  }

  /**
   * Register parse listener.
   *
   * @param  {string}   name
   * @param  {Function} cb
   *
   * @return {Parser}
   */
  this['on'] = function(name, cb) {

    if (typeof cb !== 'function') {
      throw error('required args <name, cb>');
    }

    switch (name) {
    case 'openTag': onOpenTag = cb; break;
    case 'text': onText = cb; break;
    case 'closeTag': onCloseTag = cb; break;
    case 'error': onError = cb; break;
    case 'warn': onWarning = cb; break;
    case 'cdata': onCDATA = cb; break;
    case 'attention': onAttention = cb; break; // <!XXXXX zzzz="eeee">
    case 'question': onQuestion = cb; break; // <? ....  ?>
    case 'comment': onComment = cb; break;
    default:
      throw error('unsupported event: ' + name);
    }

    return this;
  };

  /**
   * Set the namespace to prefix mapping.
   *
   * @example
   *
   * parser.ns({
   *   'http://foo': 'foo',
   *   'http://bar': 'bar'
   * });
   *
   * @param  {!Object<string, string>} nsMap
   *
   * @return {Parser}
   */
  this['ns'] = function(nsMap) {

    if (typeof nsMap === 'undefined') {
      nsMap = {};
    }

    if (typeof nsMap !== 'object') {
      throw error('required args <nsMap={}>');
    }

    var _nsUriToPrefix = {}, k;

    for (k in nsMap) {
      _nsUriToPrefix[k] = nsMap[k];
    }

    // FORCE default mapping for schema instance
    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;

    isNamespace = true;
    nsUriToPrefix = _nsUriToPrefix;

    return this;
  };

  /**
   * Parse xml string.
   *
   * @param  {string} xml
   *
   * @return {Error} returnError, if not thrown
   */
  this['parse'] = function(xml) {
    if (typeof xml !== 'string') {
      throw error('required args <xml=string>');
    }

    returnError = null;

    parse(xml);

    getContext = noopGetContext;
    parseStop = false;

    return returnError;
  };

  /**
   * Stop parsing.
   */
  this['stop'] = function() {
    parseStop = true;
  };

  /**
   * Parse string, invoking configured listeners on element.
   *
   * @param  {string} xml
   */
  function parse(xml) {
    var nsMatrixStack = isNamespace ? [] : null,
        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,
        _nsMatrix,
        nodeStack = [],
        anonymousNsCount = 0,
        tagStart = false,
        tagEnd = false,
        i = 0, j = 0,
        x, y, q, w, v,
        xmlns,
        elementName,
        _elementName,
        elementProxy
        ;

    var attrsString = '',
        attrsStart = 0,
        cachedAttrs // false = parsed with errors, null = needs parsing
        ;

    /**
     * Parse attributes on demand and returns the parsed attributes.
     *
     * Return semantics: (1) `false` on attribute parse error,
     * (2) object hash on extracted attrs.
     *
     * @return {boolean|Object}
     */
    function getAttrs() {
      if (cachedAttrs !== null) {
        return cachedAttrs;
      }

      var nsUri,
          nsUriPrefix,
          nsName,
          defaultAlias = isNamespace && nsMatrix['xmlns'],
          attrList = isNamespace && maybeNS ? [] : null,
          i = attrsStart,
          s = attrsString,
          l = s.length,
          hasNewMatrix,
          newalias,
          value,
          alias,
          name,
          attrs = {},
          seenAttrs = {},
          skipAttr,
          w,
          j;

      parseAttr:
      for (; i < l; i++) {
        skipAttr = false;
        w = s.charCodeAt(i);

        if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \f\n\r\t\v}
          continue;
        }

        // wait for non whitespace character
        if (w < 65 || w > 122 || (w > 90 && w < 97)) {
          if (w !== 95 && w !== 58) { // char 95"_" 58":"
            handleWarning('illegal first char attribute name');
            skipAttr = true;
          }
        }

        // parse attribute name
        for (j = i + 1; j < l; j++) {
          w = s.charCodeAt(j);

          if (
            w > 96 && w < 123 ||
            w > 64 && w < 91 ||
            w > 47 && w < 59 ||
            w === 46 || // '.'
            w === 45 || // '-'
            w === 95 // '_'
          ) {
            continue;
          }

          // unexpected whitespace
          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
            handleWarning('missing attribute value');
            i = j;

            continue parseAttr;
          }

          // expected "="
          if (w === 61) { // "=" == 61
            break;
          }

          handleWarning('illegal attribute name char');
          skipAttr = true;
        }

        name = s.substring(i, j);

        if (name === 'xmlns:xmlns') {
          handleWarning('illegal declaration of xmlns');
          skipAttr = true;
        }

        w = s.charCodeAt(j + 1);

        if (w === 34) { // '"'
          j = s.indexOf('"', i = j + 2);

          if (j === -1) {
            j = s.indexOf('\'', i);

            if (j !== -1) {
              handleWarning('attribute value quote missmatch');
              skipAttr = true;
            }
          }

        } else if (w === 39) { // "'"
          j = s.indexOf('\'', i = j + 2);

          if (j === -1) {
            j = s.indexOf('"', i);

            if (j !== -1) {
              handleWarning('attribute value quote missmatch');
              skipAttr = true;
            }
          }

        } else {
          handleWarning('missing attribute value quotes');
          skipAttr = true;

          // skip to next space
          for (j = j + 1; j < l; j++) {
            w = s.charCodeAt(j + 1);

            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
              break;
            }
          }

        }

        if (j === -1) {
          handleWarning('missing closing quotes');

          j = l;
          skipAttr = true;
        }

        if (!skipAttr) {
          value = s.substring(i, j);
        }

        i = j;

        // ensure SPACE follows attribute
        // skip illegal content otherwise
        // example a="b"c
        for (; j + 1 < l; j++) {
          w = s.charCodeAt(j + 1);

          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
            break;
          }

          // FIRST ILLEGAL CHAR
          if (i === j) {
            handleWarning('illegal character after attribute end');
            skipAttr = true;
          }
        }

        // advance cursor to next attribute
        i = j + 1;

        if (skipAttr) {
          continue parseAttr;
        }

        // check attribute re-declaration
        if (name in seenAttrs) {
          handleWarning('attribute <' + name + '> already defined');
          continue;
        }

        seenAttrs[name] = true;

        if (!isNamespace) {
          attrs[name] = value;
          continue;
        }

        // try to extract namespace information
        if (maybeNS) {
          newalias = (
            name === 'xmlns'
              ? 'xmlns'
              : (name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:')
                ? name.substr(6)
                : null
          );

          // handle xmlns(:alias) assignment
          if (newalias !== null) {
            nsUri = decodeEntities(value);
            nsUriPrefix = uriPrefix(newalias);

            alias = nsUriToPrefix[nsUri];

            if (!alias) {

              // no prefix defined or prefix collision
              if (
                (newalias === 'xmlns') ||
                (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)
              ) {

                // alocate free ns prefix
                do {
                  alias = 'ns' + (anonymousNsCount++);
                } while (typeof nsMatrix[alias] !== 'undefined');
              } else {
                alias = newalias;
              }

              nsUriToPrefix[nsUri] = alias;
            }

            if (nsMatrix[newalias] !== alias) {
              if (!hasNewMatrix) {
                nsMatrix = cloneNsMatrix(nsMatrix);
                hasNewMatrix = true;
              }

              nsMatrix[newalias] = alias;
              if (newalias === 'xmlns') {
                nsMatrix[uriPrefix(alias)] = nsUri;
                defaultAlias = alias;
              }

              nsMatrix[nsUriPrefix] = nsUri;
            }

            // expose xmlns(:asd)="..." in attributes
            attrs[name] = value;
            continue;
          }

          // collect attributes until all namespace
          // declarations are processed
          attrList.push(name, value);
          continue;

        } /** end if (maybeNs) */

        // handle attributes on element without
        // namespace declarations
        w = name.indexOf(':');
        if (w === -1) {
          attrs[name] = value;
          continue;
        }

        // normalize ns attribute name
        if (!(nsName = nsMatrix[name.substring(0, w)])) {
          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
          continue;
        }

        name = defaultAlias === nsName
          ? name.substr(w + 1)
          : nsName + name.substr(w);

        // end: normalize ns attribute name

        // normalize xsi:type ns attribute value
        if (name === XSI_TYPE) {
          w = value.indexOf(':');

          if (w !== -1) {
            nsName = value.substring(0, w);

            // handle default prefixes, i.e. xs:String gracefully
            nsName = nsMatrix[nsName] || nsName;
            value = nsName + value.substring(w);
          } else {
            value = defaultAlias + ':' + value;
          }
        }

        // end: normalize xsi:type ns attribute value

        attrs[name] = value;
      }


      // handle deferred, possibly namespaced attributes
      if (maybeNS) {

        // normalize captured attributes
        for (i = 0, l = attrList.length; i < l; i++) {

          name = attrList[i++];
          value = attrList[i];

          w = name.indexOf(':');

          if (w !== -1) {

            // normalize ns attribute name
            if (!(nsName = nsMatrix[name.substring(0, w)])) {
              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
              continue;
            }

            name = defaultAlias === nsName
              ? name.substr(w + 1)
              : nsName + name.substr(w);

            // end: normalize ns attribute name

            // normalize xsi:type ns attribute value
            if (name === XSI_TYPE) {
              w = value.indexOf(':');

              if (w !== -1) {
                nsName = value.substring(0, w);

                // handle default prefixes, i.e. xs:String gracefully
                nsName = nsMatrix[nsName] || nsName;
                value = nsName + value.substring(w);
              } else {
                value = defaultAlias + ':' + value;
              }
            }

            // end: normalize xsi:type ns attribute value
          }

          attrs[name] = value;
        }

        // end: normalize captured attributes
      }

      return cachedAttrs = attrs;
    }

    /**
     * Extract the parse context { line, column, part }
     * from the current parser position.
     *
     * @return {Object} parse context
     */
    function getParseContext() {
      var splitsRe = /(\r\n|\r|\n)/g;

      var line = 0;
      var column = 0;
      var startOfLine = 0;
      var endOfLine = j;
      var match;
      var data;

      while (i >= startOfLine) {

        match = splitsRe.exec(xml);

        if (!match) {
          break;
        }

        // end of line = (break idx + break chars)
        endOfLine = match[0].length + match.index;

        if (endOfLine > i) {
          break;
        }

        // advance to next line
        line += 1;

        startOfLine = endOfLine;
      }

      // EOF errors
      if (i == -1) {
        column = endOfLine;
        data = xml.substring(j);
      } else

      // start errors
      if (j === 0) {
        data = xml.substring(j, i);
      }

      // other errors
      else {
        column = i - startOfLine;
        data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));
      }

      return {
        'data': data,
        'line': line,
        'column': column
      };
    }

    getContext = getParseContext;


    if (proxy) {
      elementProxy = Object.create({}, {
        'name': getter(function() {
          return elementName;
        }),
        'originalName': getter(function() {
          return _elementName;
        }),
        'attrs': getter(getAttrs),
        'ns': getter(function() {
          return nsMatrix;
        })
      });
    }

    // actual parse logic
    while (j !== -1) {

      if (xml.charCodeAt(j) === 60) { // "<"
        i = j;
      } else {
        i = xml.indexOf('<', j);
      }

      // parse end
      if (i === -1) {
        if (nodeStack.length) {
          return handleError('unexpected end of file');
        }

        if (j === 0) {
          return handleError('missing start tag');
        }

        if (j < xml.length) {
          if (xml.substring(j).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
          }
        }

        return;
      }

      // parse text
      if (j !== i) {

        if (nodeStack.length) {
          if (onText) {
            onText(xml.substring(j, i), decodeEntities, getContext);

            if (parseStop) {
              return;
            }
          }
        } else {
          if (xml.substring(j, i).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);

            if (parseStop) {
              return;
            }
          }
        }
      }

      w = xml.charCodeAt(i+1);

      // parse comments + CDATA
      if (w === 33) { // "!"
        q = xml.charCodeAt(i+2);

        // CDATA section
        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') { // 91 == "["
          j = xml.indexOf(']]>', i);
          if (j === -1) {
            return handleError('unclosed cdata');
          }

          if (onCDATA) {
            onCDATA(xml.substring(i + 9, j), getContext);
            if (parseStop) {
              return;
            }
          }

          j += 3;
          continue;
        }

        // comment
        if (q === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == "-"
          j = xml.indexOf('-->', i);
          if (j === -1) {
            return handleError('unclosed comment');
          }


          if (onComment) {
            onComment(xml.substring(i + 4, j), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }

          j += 3;
          continue;
        }
      }

      // parse question <? ... ?>
      if (w === 63) { // "?"
        j = xml.indexOf('?>', i);
        if (j === -1) {
          return handleError('unclosed question');
        }

        if (onQuestion) {
          onQuestion(xml.substring(i, j + 2), getContext);
          if (parseStop) {
            return;
          }
        }

        j += 2;
        continue;
      }

      // find matching closing tag for attention or standard tags
      // for that we must skip through attribute values
      // (enclosed in single or double quotes)
      for (x = i + 1; ; x++) {
        v = xml.charCodeAt(x);
        if (isNaN(v)) {
          j = -1;
          return handleError('unclosed tag');
        }

        // [10] AttValue ::= '"' ([^<&"] | Reference)* '"' | "'" ([^<&'] | Reference)* "'"
        // skips the quoted string
        // (double quotes) does not appear in a literal enclosed by (double quotes)
        // (single quote) does not appear in a literal enclosed by (single quote)
        if (v === 34) { //  '"'
          q = xml.indexOf('"', x + 1);
          x = q !== -1 ? q : x;
        } else if (v === 39) { // "'"
          q = xml.indexOf("'", x + 1);
          x = q !== -1 ? q : x;
        } else if (v === 62) { // '>'
          j = x;
          break;
        }
      }


      // parse attention <! ...>
      // previously comment and CDATA have already been parsed
      if (w === 33) { // "!"

        if (onAttention) {
          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);
          if (parseStop) {
            return;
          }
        }

        j += 1;
        continue;
      }

      // don't process attributes;
      // there are none
      cachedAttrs = {};

      // if (xml.charCodeAt(i+1) === 47) { // </...
      if (w === 47) { // </...
        tagStart = false;
        tagEnd = true;

        if (!nodeStack.length) {
          return handleError('missing open tag');
        }

        // verify open <-> close tag match
        x = elementName = nodeStack.pop();
        q = i + 2 + x.length;

        if (xml.substring(i + 2, q) !== x) {
          return handleError('closing tag mismatch');
        }

        // verify chars in close tag
        for (; q < j; q++) {
          w = xml.charCodeAt(q);

          if (w === 32 || (w > 8 && w < 14)) { // \f\n\r\t\v space
            continue;
          }

          return handleError('close tag');
        }

      } else {
        if (xml.charCodeAt(j - 1) === 47) { // .../>
          x = elementName = xml.substring(i + 1, j - 1);

          tagStart = true;
          tagEnd = true;

        } else {
          x = elementName = xml.substring(i + 1, j);

          tagStart = true;
          tagEnd = false;
        }

        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95"_" 58":"
          return handleError('illegal first char nodeName');
        }

        for (q = 1, y = x.length; q < y; q++) {
          w = x.charCodeAt(q);

          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {
            continue;
          }

          if (w === 32 || (w < 14 && w > 8)) { // \f\n\r\t\v space
            elementName = x.substring(0, q);

            // maybe there are attributes
            cachedAttrs = null;
            break;
          }

          return handleError('invalid nodeName');
        }

        if (!tagEnd) {
          nodeStack.push(elementName);
        }
      }

      if (isNamespace) {

        _nsMatrix = nsMatrix;

        if (tagStart) {

          // remember old namespace
          // unless we're self-closing
          if (!tagEnd) {
            nsMatrixStack.push(_nsMatrix);
          }

          if (cachedAttrs === null) {

            // quick check, whether there may be namespace
            // declarations on the node; if that is the case
            // we need to eagerly parse the node attributes
            if ((maybeNS = x.indexOf('xmlns', q) !== -1)) {
              attrsStart = q;
              attrsString = x;

              getAttrs();

              maybeNS = false;
            }
          }
        }

        _elementName = elementName;

        w = elementName.indexOf(':');
        if (w !== -1) {
          xmlns = nsMatrix[elementName.substring(0, w)];

          // prefix given; namespace must exist
          if (!xmlns) {
            return handleError('missing namespace on <' + _elementName + '>');
          }

          elementName = elementName.substr(w + 1);
        } else {
          xmlns = nsMatrix['xmlns'];

          // if no default namespace is defined,
          // we'll import the element as anonymous.
          //
          // it is up to users to correct that to the document defined
          // targetNamespace, or whatever their undersanding of the
          // XML spec mandates.
        }

        // adjust namespace prefixs as configured
        if (xmlns) {
          elementName = xmlns + ':' + elementName;
        }

      }

      if (tagStart) {
        attrsStart = q;
        attrsString = x;

        if (onOpenTag) {
          if (proxy) {
            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
          } else {
            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);
          }

          if (parseStop) {
            return;
          }
        }

      }

      if (tagEnd) {

        if (onCloseTag) {
          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);

          if (parseStop) {
            return;
          }
        }

        // restore old namespace
        if (isNamespace) {
          if (!tagStart) {
            nsMatrix = nsMatrixStack.pop();
          } else {
            nsMatrix = _nsMatrix;
          }
        }
      }

      j += 1;
    }
  } /** end parse */

}




/***/ }),

/***/ "./node_modules/tiny-svg/dist/index.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tiny-svg/dist/index.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "append": () => (/* binding */ append),
/* harmony export */   "appendTo": () => (/* binding */ appendTo),
/* harmony export */   "attr": () => (/* binding */ attr),
/* harmony export */   "classes": () => (/* binding */ classes),
/* harmony export */   "clear": () => (/* binding */ clear),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "innerSVG": () => (/* binding */ innerSVG),
/* harmony export */   "prepend": () => (/* binding */ prepend),
/* harmony export */   "prependTo": () => (/* binding */ prependTo),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "replace": () => (/* binding */ replace),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "on": () => (/* binding */ on),
/* harmony export */   "off": () => (/* binding */ off),
/* harmony export */   "createPoint": () => (/* binding */ createPoint),
/* harmony export */   "createMatrix": () => (/* binding */ createMatrix),
/* harmony export */   "createTransform": () => (/* binding */ createTransform),
/* harmony export */   "select": () => (/* binding */ select),
/* harmony export */   "selectAll": () => (/* binding */ selectAll)
/* harmony export */ });
function ensureImported(element, target) {

  if (element.ownerDocument !== target.ownerDocument) {
    try {
      // may fail on webkit
      return target.ownerDocument.importNode(element, true);
    } catch (e) {
      // ignore
    }
  }

  return element;
}

/**
 * appendTo utility
 */

/**
 * Append a node to a target element and return the appended node.
 *
 * @param  {SVGElement} element
 * @param  {SVGElement} target
 *
 * @return {SVGElement} the appended node
 */
function appendTo(element, target) {
  return target.appendChild(ensureImported(element, target));
}

/**
 * append utility
 */

/**
 * Append a node to an element
 *
 * @param  {SVGElement} element
 * @param  {SVGElement} node
 *
 * @return {SVGElement} the element
 */
function append(target, node) {
  appendTo(node, target);
  return target;
}

/**
 * attribute accessor utility
 */

var LENGTH_ATTR = 2;

var CSS_PROPERTIES = {
  'alignment-baseline': 1,
  'baseline-shift': 1,
  'clip': 1,
  'clip-path': 1,
  'clip-rule': 1,
  'color': 1,
  'color-interpolation': 1,
  'color-interpolation-filters': 1,
  'color-profile': 1,
  'color-rendering': 1,
  'cursor': 1,
  'direction': 1,
  'display': 1,
  'dominant-baseline': 1,
  'enable-background': 1,
  'fill': 1,
  'fill-opacity': 1,
  'fill-rule': 1,
  'filter': 1,
  'flood-color': 1,
  'flood-opacity': 1,
  'font': 1,
  'font-family': 1,
  'font-size': LENGTH_ATTR,
  'font-size-adjust': 1,
  'font-stretch': 1,
  'font-style': 1,
  'font-variant': 1,
  'font-weight': 1,
  'glyph-orientation-horizontal': 1,
  'glyph-orientation-vertical': 1,
  'image-rendering': 1,
  'kerning': 1,
  'letter-spacing': 1,
  'lighting-color': 1,
  'marker': 1,
  'marker-end': 1,
  'marker-mid': 1,
  'marker-start': 1,
  'mask': 1,
  'opacity': 1,
  'overflow': 1,
  'pointer-events': 1,
  'shape-rendering': 1,
  'stop-color': 1,
  'stop-opacity': 1,
  'stroke': 1,
  'stroke-dasharray': 1,
  'stroke-dashoffset': 1,
  'stroke-linecap': 1,
  'stroke-linejoin': 1,
  'stroke-miterlimit': 1,
  'stroke-opacity': 1,
  'stroke-width': LENGTH_ATTR,
  'text-anchor': 1,
  'text-decoration': 1,
  'text-rendering': 1,
  'unicode-bidi': 1,
  'visibility': 1,
  'word-spacing': 1,
  'writing-mode': 1
};


function getAttribute(node, name) {
  if (CSS_PROPERTIES[name]) {
    return node.style[name];
  } else {
    return node.getAttributeNS(null, name);
  }
}

function setAttribute(node, name, value) {
  var hyphenated = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();

  var type = CSS_PROPERTIES[hyphenated];

  if (type) {
    // append pixel unit, unless present
    if (type === LENGTH_ATTR && typeof value === 'number') {
      value = String(value) + 'px';
    }

    node.style[hyphenated] = value;
  } else {
    node.setAttributeNS(null, name, value);
  }
}

function setAttributes(node, attrs) {

  var names = Object.keys(attrs), i, name;

  for (i = 0, name; (name = names[i]); i++) {
    setAttribute(node, name, attrs[name]);
  }
}

/**
 * Gets or sets raw attributes on a node.
 *
 * @param  {SVGElement} node
 * @param  {Object} [attrs]
 * @param  {String} [name]
 * @param  {String} [value]
 *
 * @return {String}
 */
function attr(node, name, value) {
  if (typeof name === 'string') {
    if (value !== undefined) {
      setAttribute(node, name, value);
    } else {
      return getAttribute(node, name);
    }
  } else {
    setAttributes(node, name);
  }

  return node;
}

/**
 * Clear utility
 */
function index(arr, obj) {
  if (arr.indexOf) {
    return arr.indexOf(obj);
  }


  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) {
      return i;
    }
  }

  return -1;
}

var re = /\s+/;

var toString = Object.prototype.toString;

function defined(o) {
  return typeof o !== 'undefined';
}

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

function classes(el) {
  return new ClassList(el);
}

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name) {

  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) {
    arr.push(name);
  }

  if (defined(this.el.className.baseVal)) {
    this.el.className.baseVal = arr.join(' ');
  } else {
    this.el.className = arr.join(' ');
  }

  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name) {
  if ('[object RegExp]' === toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) {
    arr.splice(i, 1);
  }
  this.el.className.baseVal = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re) {
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force) {
  // classList
  if (this.list) {
    if (defined(force)) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if (defined(force)) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function() {
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) {
    arr.shift();
  }
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name) {
  return (
    this.list ?
      this.list.contains(name) :
      !! ~index(this.array(), name)
  );
};

function remove(element) {
  var parent = element.parentNode;

  if (parent) {
    parent.removeChild(element);
  }

  return element;
}

/**
 * Clear utility
 */

/**
 * Removes all children from the given element
 *
 * @param  {DOMElement} element
 * @return {DOMElement} the element (for chaining)
 */
function clear(element) {
  var child;

  while ((child = element.firstChild)) {
    remove(child);
  }

  return element;
}

function clone(element) {
  return element.cloneNode(true);
}

var ns = {
  svg: 'http://www.w3.org/2000/svg'
};

/**
 * DOM parsing utility
 */

var SVG_START = '<svg xmlns="' + ns.svg + '"';

function parse(svg) {

  var unwrap = false;

  // ensure we import a valid svg document
  if (svg.substring(0, 4) === '<svg') {
    if (svg.indexOf(ns.svg) === -1) {
      svg = SVG_START + svg.substring(4);
    }
  } else {
    // namespace svg
    svg = SVG_START + '>' + svg + '</svg>';
    unwrap = true;
  }

  var parsed = parseDocument(svg);

  if (!unwrap) {
    return parsed;
  }

  var fragment = document.createDocumentFragment();

  var parent = parsed.firstChild;

  while (parent.firstChild) {
    fragment.appendChild(parent.firstChild);
  }

  return fragment;
}

function parseDocument(svg) {

  var parser;

  // parse
  parser = new DOMParser();
  parser.async = false;

  return parser.parseFromString(svg, 'text/xml');
}

/**
 * Create utility for SVG elements
 */


/**
 * Create a specific type from name or SVG markup.
 *
 * @param {String} name the name or markup of the element
 * @param {Object} [attrs] attributes to set on the element
 *
 * @returns {SVGElement}
 */
function create(name, attrs) {
  var element;

  if (name.charAt(0) === '<') {
    element = parse(name).firstChild;
    element = document.importNode(element, true);
  } else {
    element = document.createElementNS(ns.svg, name);
  }

  if (attrs) {
    attr(element, attrs);
  }

  return element;
}

/**
 * Events handling utility
 */

function on(node, event, listener, useCapture) {
  node.addEventListener(event, listener, useCapture);
}

function off(node, event, listener, useCapture) {
  node.removeEventListener(event, listener, useCapture);
}

/**
 * Geometry helpers
 */

// fake node used to instantiate svg geometry elements
var node = create('svg');

function extend(object, props) {
  var i, k, keys = Object.keys(props);

  for (i = 0; (k = keys[i]); i++) {
    object[k] = props[k];
  }

  return object;
}


function createPoint(x, y) {
  var point = node.createSVGPoint();

  switch (arguments.length) {
  case 0:
    return point;
  case 2:
    x = {
      x: x,
      y: y
    };
    break;
  }

  return extend(point, x);
}

/**
 * Create matrix via args.
 *
 * @example
 *
 * createMatrix({ a: 1, b: 1 });
 * createMatrix();
 * createMatrix(1, 2, 0, 0, 30, 20);
 *
 * @return {SVGMatrix}
 */
function createMatrix(a, b, c, d, e, f) {
  var matrix = node.createSVGMatrix();

  switch (arguments.length) {
  case 0:
    return matrix;
  case 1:
    return extend(matrix, a);
  case 6:
    return extend(matrix, {
      a: a,
      b: b,
      c: c,
      d: d,
      e: e,
      f: f
    });
  }
}

function createTransform(matrix) {
  if (matrix) {
    return node.createSVGTransformFromMatrix(matrix);
  } else {
    return node.createSVGTransform();
  }
}

/**
 * Serialization util
 */

var TEXT_ENTITIES = /([&<>]{1})/g;
var ATTR_ENTITIES = /([\n\r"]{1})/g;

var ENTITY_REPLACEMENT = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '\''
};

function escape(str, pattern) {

  function replaceFn(match, entity) {
    return ENTITY_REPLACEMENT[entity] || entity;
  }

  return str.replace(pattern, replaceFn);
}

function serialize(node, output) {

  var i, len, attrMap, attrNode, childNodes;

  switch (node.nodeType) {
  // TEXT
  case 3:
    // replace special XML characters
    output.push(escape(node.textContent, TEXT_ENTITIES));
    break;

  // ELEMENT
  case 1:
    output.push('<', node.tagName);

    if (node.hasAttributes()) {
      attrMap = node.attributes;
      for (i = 0, len = attrMap.length; i < len; ++i) {
        attrNode = attrMap.item(i);
        output.push(' ', attrNode.name, '="', escape(attrNode.value, ATTR_ENTITIES), '"');
      }
    }

    if (node.hasChildNodes()) {
      output.push('>');
      childNodes = node.childNodes;
      for (i = 0, len = childNodes.length; i < len; ++i) {
        serialize(childNodes.item(i), output);
      }
      output.push('</', node.tagName, '>');
    } else {
      output.push('/>');
    }
    break;

  // COMMENT
  case 8:
    output.push('<!--', escape(node.nodeValue, TEXT_ENTITIES), '-->');
    break;

  // CDATA
  case 4:
    output.push('<![CDATA[', node.nodeValue, ']]>');
    break;

  default:
    throw new Error('unable to handle node ' + node.nodeType);
  }

  return output;
}

/**
 * innerHTML like functionality for SVG elements.
 * based on innerSVG (https://code.google.com/p/innersvg)
 */


function set(element, svg) {

  var parsed = parse(svg);

  // clear element contents
  clear(element);

  if (!svg) {
    return;
  }

  if (!isFragment(parsed)) {
    // extract <svg> from parsed document
    parsed = parsed.documentElement;
  }

  var nodes = slice(parsed.childNodes);

  // import + append each node
  for (var i = 0; i < nodes.length; i++) {
    appendTo(nodes[i], element);
  }

}

function get(element) {
  var child = element.firstChild,
      output = [];

  while (child) {
    serialize(child, output);
    child = child.nextSibling;
  }

  return output.join('');
}

function isFragment(node) {
  return node.nodeName === '#document-fragment';
}

function innerSVG(element, svg) {

  if (svg !== undefined) {

    try {
      set(element, svg);
    } catch (e) {
      throw new Error('error parsing SVG: ' + e.message);
    }

    return element;
  } else {
    return get(element);
  }
}


function slice(arr) {
  return Array.prototype.slice.call(arr);
}

/**
 * Selection utilities
 */

function select(node, selector) {
  return node.querySelector(selector);
}

function selectAll(node, selector) {
  var nodes = node.querySelectorAll(selector);

  return [].map.call(nodes, function(element) {
    return element;
  });
}

/**
 * prependTo utility
 */

/**
 * Prepend a node to a target element and return the prepended node.
 *
 * @param  {SVGElement} node
 * @param  {SVGElement} target
 *
 * @return {SVGElement} the prepended node
 */
function prependTo(node, target) {
  return target.insertBefore(ensureImported(node, target), target.firstChild || null);
}

/**
 * prepend utility
 */

/**
 * Prepend a node to a target element
 *
 * @param  {SVGElement} target
 * @param  {SVGElement} node
 *
 * @return {SVGElement} the target element
 */
function prepend(target, node) {
  prependTo(node, target);
  return target;
}

/**
 * Replace utility
 */

function replace(element, replacement) {
  element.parentNode.replaceChild(ensureImported(replacement, element), element);
  return replacement;
}

/**
 * transform accessor utility
 */

function wrapMatrix(transformList, transform) {
  if (transform instanceof SVGMatrix) {
    return transformList.createSVGTransformFromMatrix(transform);
  }

  return transform;
}


function setTransforms(transformList, transforms) {
  var i, t;

  transformList.clear();

  for (i = 0; (t = transforms[i]); i++) {
    transformList.appendItem(wrapMatrix(transformList, t));
  }
}

/**
 * Get or set the transforms on the given node.
 *
 * @param {SVGElement} node
 * @param  {SVGTransform|SVGMatrix|Array<SVGTransform|SVGMatrix>} [transforms]
 *
 * @return {SVGTransform} the consolidated transform
 */
function transform(node, transforms) {
  var transformList = node.transform.baseVal;

  if (transforms) {

    if (!Array.isArray(transforms)) {
      transforms = [ transforms ];
    }

    setTransforms(transformList, transforms);
  }

  return transformList.consolidate();
}




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL0Jhc2VNb2RlbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvQmFzZVZpZXdlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL01vZGVsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9OYXZpZ2F0ZWRWaWV3ZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9WaWV3ZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9jb3JlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZHJhdy9QYXRoTWFwLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZHJhdy9Qb3N0aXRSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2RyYXcvUG9zdGl0UmVuZGVyZXJVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZHJhdy9UZXh0UmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9kcmF3L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvY2FudmFzLWNyZWF0ZS9DYW52YXNDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9jYW52YXMtY3JlYXRlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvY29udGV4dC1wYWQvQ29udGV4dFBhZFByb3ZpZGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvY29udGV4dC1wYWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9jb3B5LXBhc3RlL01vZGRsZUNvcHkuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9jb3B5LXBhc3RlL1Bvc3RpdENvcHlQYXN0ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL2NvcHktcGFzdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9kaS1vcmRlcmluZy9Qb3N0aXREaU9yZGVyaW5nLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvZGktb3JkZXJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9kcmFnLWRyb3AtaW1hZ2VzL0RyYWdEcm9wSW1hZ2VzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvZHJhZy1kcm9wLWltYWdlcy9GaWxlVXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL2RyYWctZHJvcC1pbWFnZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9lZGl0b3ItYWN0aW9ucy9Qb3N0aXRFZGl0b3JBY3Rpb25zLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvZWRpdG9yLWFjdGlvbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9pbWFnZS1zZWxlY3Rpb24vSW1hZ2VTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9pbWFnZS1zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9rZXlib2FyZC9Qb3N0aXRLZXlib2FyZEJpbmRpbmdzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMva2V5Ym9hcmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL0xhYmVsRWRpdGluZ1ByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL0xhYmVsRWRpdGluZ1Byb3ZpZGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbGFiZWwtZWRpdGluZy9MYWJlbFV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL2NtZC9VcGRhdGVMYWJlbEhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvRWxlbWVudEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9Nb2RlbGluZy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL1Bvc3RpdEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9Qb3N0aXRVcGRhdGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvYmVoYXZpb3IvQWRhcHRpdmVMYWJlbFBvc2l0aW9uaW5nQmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9iZWhhdmlvci9BcHBlbmRCZWhhdmlvci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2JlaGF2aW9yL0NyZWF0ZUJvYXJkRWxlbWVudEJlaGF2aW9yLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvYmVoYXZpb3IvRW1wdHlUZXh0Qm94QmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9iZWhhdmlvci9GaXhIb3ZlckJlaGF2aW9yLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvYmVoYXZpb3IvSW1wb3J0RG9ja2luZ0ZpeC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2JlaGF2aW9yL0xhYmVsQmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9iZWhhdmlvci9SZXBsYWNlRWxlbWVudEJlaGF2aW91ci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2JlaGF2aW9yL1VuY2xhaW1JZEJlaGF2aW9yLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvYmVoYXZpb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9iZWhhdmlvci91dGlsL0dlb21ldHJpY1V0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9iZWhhdmlvci91dGlsL0xhYmVsTGF5b3V0VXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2JlaGF2aW9yL3V0aWwvTGluZUF0dGFjaG1lbnRVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvYmVoYXZpb3IvdXRpbC9MaW5lSW50ZXJzZWN0LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL0lkQ2xhaW1IYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL1NldENvbG9ySGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9VcGRhdGVDYW52YXNSb290SGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9VcGRhdGVQcm9wZXJ0aWVzSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvdXRpbC9Nb2RlbGluZ1V0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9vcmRlcmluZy9Qb3N0aXRPcmRlcmluZ1Byb3ZpZGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvb3JkZXJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9wYWxldHRlL1BhbGV0dGVQcm92aWRlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL3BhbGV0dGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9wb3B1cC1tZW51L1JlcGxhY2VNZW51UHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9wb3B1cC1tZW51L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvcmVwbGFjZS1wcmV2aWV3L1Bvc3RpdFJlcGxhY2VQcmV2aWV3LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvcmVwbGFjZS1wcmV2aWV3L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvcmVwbGFjZS9Qb3N0aXRSZXBsYWNlLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvcmVwbGFjZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL3J1bGVzL1Bvc3RpdFJ1bGVzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvcnVsZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9zbmFwcGluZy9Qb3N0aXRDcmVhdGVNb3ZlU25hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9zbmFwcGluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ltcG9ydC9JbXBvcnRlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ltcG9ydC9Qb3N0aXRJbXBvcnRlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ltcG9ydC9Qb3N0aXRUcmVlV2Fsa2VyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvaW1wb3J0L1V0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9pbXBvcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL21vZGRsZS9Nb2RkbGUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9tb2RkbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi91dGlsL0NvbG9yVXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL3V0aWwvRmlsZVV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi91dGlsL0xhYmVsVXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL3V0aWwvTW9kZWxVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvdXRpbC9TY3JlZW5VdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvY3NzLmVzY2FwZS9jc3MuZXNjYXBlLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy1kaXJlY3QtZWRpdGluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMtZGlyZWN0LWVkaXRpbmcvbGliL0RpcmVjdEVkaXRpbmcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzLWRpcmVjdC1lZGl0aW5nL2xpYi9UZXh0Qm94LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvRGlhZ3JhbS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2NvbW1hbmQvQ29tbWFuZEludGVyY2VwdG9yLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvY29tbWFuZC9Db21tYW5kU3RhY2suanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9jb21tYW5kL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvY29yZS9DYW52YXMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9jb3JlL0VsZW1lbnRGYWN0b3J5LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvY29yZS9FbGVtZW50UmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9jb3JlL0V2ZW50QnVzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvY29yZS9HcmFwaGljc0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9jb3JlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZHJhdy9CYXNlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9kcmF3L0RlZmF1bHRSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2RyYXcvU3R5bGVzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZHJhdy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2FsaWduLWVsZW1lbnRzL0FsaWduRWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9hbGlnbi1lbGVtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2F0dGFjaC1zdXBwb3J0L0F0dGFjaFN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9hdHRhY2gtc3VwcG9ydC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2F1dG8tc2Nyb2xsL0F1dG9TY3JvbGwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9hdXRvLXNjcm9sbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2JlbmRwb2ludHMvQmVuZHBvaW50TW92ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2JlbmRwb2ludHMvQmVuZHBvaW50TW92ZVByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9iZW5kcG9pbnRzL0JlbmRwb2ludFNuYXBwaW5nLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvYmVuZHBvaW50cy9CZW5kcG9pbnRVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvYmVuZHBvaW50cy9CZW5kcG9pbnRzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvYmVuZHBvaW50cy9Db25uZWN0aW9uU2VnbWVudE1vdmUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9iZW5kcG9pbnRzL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY2hhbmdlLXN1cHBvcnQvQ2hhbmdlU3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NoYW5nZS1zdXBwb3J0L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY2xpcGJvYXJkL0NsaXBib2FyZC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NsaXBib2FyZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2Nvbm5lY3QvQ29ubmVjdC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2Nvbm5lY3QvQ29ubmVjdFByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9jb25uZWN0L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY29ubmVjdGlvbi1wcmV2aWV3L0Nvbm5lY3Rpb25QcmV2aWV3LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY29ubmVjdGlvbi1wcmV2aWV3L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY29udGV4dC1wYWQvQ29udGV4dFBhZC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NvbnRleHQtcGFkL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY29weS1wYXN0ZS9Db3B5UGFzdGUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9jb3B5LXBhc3RlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY3JlYXRlL0NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NyZWF0ZS9DcmVhdGVQcmV2aWV3LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY3JlYXRlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvZHJhZ2dpbmcvRHJhZ2dpbmcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9kcmFnZ2luZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2VkaXRvci1hY3Rpb25zL0VkaXRvckFjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9lZGl0b3ItYWN0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2hhbmQtdG9vbC9IYW5kVG9vbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2hhbmQtdG9vbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2hvdmVyLWZpeC9Ib3ZlckZpeC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2hvdmVyLWZpeC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2ludGVyYWN0aW9uLWV2ZW50cy9JbnRlcmFjdGlvbkV2ZW50cy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2ludGVyYWN0aW9uLWV2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2tleWJvYXJkLW1vdmUtc2VsZWN0aW9uL0tleWJvYXJkTW92ZVNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2tleWJvYXJkLW1vdmUtc2VsZWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMva2V5Ym9hcmQvS2V5Ym9hcmQuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9rZXlib2FyZC9LZXlib2FyZEJpbmRpbmdzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMva2V5Ym9hcmQvS2V5Ym9hcmRVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMva2V5Ym9hcmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9sYWJlbC1zdXBwb3J0L0xhYmVsU3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2xhYmVsLXN1cHBvcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9sYXNzby10b29sL0xhc3NvVG9vbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2xhc3NvLXRvb2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9Nb2RlbGluZy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9BbGlnbkVsZW1lbnRzSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9BcHBlbmRTaGFwZUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvQ3JlYXRlQ29ubmVjdGlvbkhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvQ3JlYXRlRWxlbWVudHNIYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL0NyZWF0ZUxhYmVsSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9DcmVhdGVTaGFwZUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvRGVsZXRlQ29ubmVjdGlvbkhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvRGVsZXRlRWxlbWVudHNIYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL0RlbGV0ZVNoYXBlSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9EaXN0cmlidXRlRWxlbWVudHNIYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL0xheW91dENvbm5lY3Rpb25IYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL01vdmVDb25uZWN0aW9uSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9Nb3ZlRWxlbWVudHNIYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL01vdmVTaGFwZUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvUmVjb25uZWN0Q29ubmVjdGlvbkhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvUmVwbGFjZVNoYXBlSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9SZXNpemVTaGFwZUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvU3BhY2VUb29sSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9Ub2dnbGVTaGFwZUNvbGxhcHNlSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9VcGRhdGVBdHRhY2htZW50SGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9VcGRhdGVXYXlwb2ludHNIYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL2hlbHBlci9BbmNob3JzSGVscGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL2hlbHBlci9Nb3ZlQ2xvc3VyZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9oZWxwZXIvTW92ZUhlbHBlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vdXNlL01vdXNlLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW91c2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb3ZlL01vdmUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb3ZlL01vdmVQcmV2aWV3LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW92ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL29yZGVyaW5nL09yZGVyaW5nUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vdXRsaW5lL091dGxpbmUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vdXRsaW5lL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvb3ZlcmxheXMvT3ZlcmxheXMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vdmVybGF5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3BhbGV0dGUvUGFsZXR0ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3BhbGV0dGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9wb3B1cC1tZW51L1BvcHVwTWVudS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3BvcHVwLW1lbnUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9wcmV2aWV3LXN1cHBvcnQvUHJldmlld1N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9wcmV2aWV3LXN1cHBvcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9yZXBsYWNlL1JlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9yZXBsYWNlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcmVzaXplL1Jlc2l6ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3Jlc2l6ZS9SZXNpemVIYW5kbGVzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcmVzaXplL1Jlc2l6ZVByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9yZXNpemUvUmVzaXplVXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3Jlc2l6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3J1bGVzL1J1bGVQcm92aWRlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3J1bGVzL1J1bGVzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcnVsZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zZWxlY3Rpb24vU2VsZWN0aW9uLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uL1NlbGVjdGlvbkJlaGF2aW9yLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uL1NlbGVjdGlvblZpc3VhbHMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zbmFwcGluZy9DcmVhdGVNb3ZlU25hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zbmFwcGluZy9SZXNpemVTbmFwcGluZy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NuYXBwaW5nL1NuYXBDb250ZXh0LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc25hcHBpbmcvU25hcFV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zbmFwcGluZy9TbmFwcGluZy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NuYXBwaW5nL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc3BhY2UtdG9vbC9TcGFjZVRvb2wuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zcGFjZS10b29sL1NwYWNlVG9vbFByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zcGFjZS10b29sL1NwYWNlVXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NwYWNlLXRvb2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy90b29sLW1hbmFnZXIvVG9vbE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy90b29sLW1hbmFnZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy90b29sdGlwcy9Ub29sdGlwcy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3Rvb2x0aXBzL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvdG91Y2gvVG91Y2hGaXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy90b3VjaC9Ub3VjaEludGVyYWN0aW9uRXZlbnRzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvdG91Y2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9pMThuL3RyYW5zbGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2kxOG4vdHJhbnNsYXRlL3RyYW5zbGF0ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2xheW91dC9CYXNlTGF5b3V0ZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9sYXlvdXQvQ3JvcHBpbmdDb25uZWN0aW9uRG9ja2luZy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2xheW91dC9MYXlvdXRVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvbW9kZWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL2tleWJvYXJkLW1vdmUvS2V5Ym9hcmRNb3ZlLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi9rZXlib2FyZC1tb3ZlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi9tb3ZlY2FudmFzL01vdmVDYW52YXMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL21vdmVjYW52YXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL3RvdWNoL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi96b29tc2Nyb2xsL1pvb21TY3JvbGwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL3pvb21zY3JvbGwvWm9vbVV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL3pvb21zY3JvbGwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0F0dGFjaFV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0NsaWNrVHJhcC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvQ29sbGVjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0N1cnNvci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvRWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0V2ZW50LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvdXRpbC9HZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvR3JhcGhpY3NVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvdXRpbC9JZEdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvTGluZUludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvTWF0aC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvTW91c2UuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL1BsYXRmb3JtLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvdXRpbC9Qb3NpdGlvblV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL1JlbW92YWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL1JlbmRlclV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL1N2Z1RyYW5zZm9ybVV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL1RleHQuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWRpL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvaGFtbWVyanMvaGFtbWVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvaWRzL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL21pbi1kYXNoL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvbWluLWRvbS9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL21vZGRsZS14bWwvZGlzdC9pbmRleC5lc20uanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9tb2RkbGUvZGlzdC9pbmRleC5lc20uanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9vYmplY3QtcmVmcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL29iamVjdC1yZWZzL2xpYi9jb2xsZWN0aW9uLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvb2JqZWN0LXJlZnMvbGliL3JlZnMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9wYXRoLWludGVyc2VjdGlvbi9pbnRlcnNlY3QuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9zYXhlbi9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL3Rpbnktc3ZnL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyL3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVmdDOztBQUVWOztBQUVnQjs7O0FBR3RDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsV0FBVztBQUN0QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLG1CQUFtQjtBQUM5QjtBQUNlO0FBQ2YsRUFBRSxxREFBZTs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSwrQ0FBUSxjQUFjLGdEQUFVOzs7QUFHaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlLDZFQUF1Qzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdDQUFHOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTWtCOztBQU1EOztBQUlDOztBQUVlO0FBQ0g7O0FBRUU7O0FBSUw7Ozs7O0FBSzNCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLEdBQUcsc0JBQXNCLEtBQUssY0FBYztBQUM1RTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsV0FBVztBQUN0QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLG1CQUFtQjtBQUM5QjtBQUNlOztBQUVmLFlBQVksZ0RBQU0sR0FBRzs7QUFFckI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBUSxhQUFhLCtDQUFPOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhLGNBQWM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0EsYUFBYSxjQUFjO0FBQzNCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLHNDQUFzQztBQUNqRDtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVzs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBLG1DQUFtQyxxQ0FBcUM7O0FBRXhFLHdCQUF3Qix3QkFBd0I7QUFDaEQsT0FBTztBQUNQOztBQUVBLG1DQUFtQyxvQ0FBb0M7O0FBRXZFO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUEsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQSxLQUFLOztBQUVMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhLGNBQWM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0EsYUFBYSxjQUFjO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLFdBQVcsc0NBQXNDO0FBQ2pEO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLHFCQUFxQjtBQUMzQyxLQUFLOztBQUVMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLGNBQWM7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0EsYUFBYSxjQUFjO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0NBQXNDO0FBQ2pEO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsSUFBSSxxRUFBbUI7O0FBRXZCOztBQUVBLHNCQUFzQixxQkFBcUI7QUFDM0MsS0FBSzs7QUFFTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsc0JBQXNCLFdBQVc7QUFDakMsS0FBSzs7QUFFTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiw4Q0FBUTs7QUFFN0IscUJBQXFCLGtEQUFRO0FBQzdCLHVDQUF1QyxrREFBUTs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUUsb0VBQTRCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLHNFQUE4Qjs7QUFFaEM7QUFDQSxFQUFFLCtDQUFTO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDRCQUE0QjtBQUN2RTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsOENBQVE7QUFDekI7O0FBRUE7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsZ0RBQU0sQ0FBQyw4Q0FBSTtBQUNsQyxZQUFZLGdEQUFNLEdBQUcsbUJBQW1CLHVCQUF1QjtBQUMvRDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFLG9EQUFZOztBQUVkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsK0NBQU07O0FBRXhCLEVBQUUsZ0RBQU07QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0RBQU0sR0FBRzs7QUFFL0IsYUFBYSw0Q0FBTTtBQUNuQjs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFRO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDhDQUFJO0FBQ2I7QUFDQSxHQUFHO0FBQ0g7OztBQUtpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2x0QmU7O0FBRVE7O0FBRVY7QUFDa0I7O0FBRXlCO0FBQ0w7QUFDVjtBQUNVOztBQUVLO0FBQ047QUFDRDtBQUNkO0FBQ1E7QUFDcUI7QUFDM0I7QUFDRjtBQUNNO0FBQ0U7QUFDRTtBQUNiO0FBQ3lDO0FBQ2hDO0FBQ1Q7QUFDSztBQUNQO0FBQ2U7QUFDSjtBQUNUOztBQUVjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmLEVBQUUsc0RBQWdCO0FBQ2xCO0FBQ0EsK0NBQVEsVUFBVSxpREFBVzs7O0FBRzdCLGlCQUFpQiw0Q0FBTTtBQUN2QiwwQkFBMEIscURBQWU7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWEsY0FBYztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxhQUFhLGNBQWM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsRUFBRSw0RUFBa0I7QUFDcEIsRUFBRSx5RUFBZ0I7QUFDbEIsRUFBRSxvRUFBVztBQUNiLEVBQUUseUVBQWdCO0FBQ2xCOztBQUVBOztBQUVBO0FBQ0EsRUFBRSwyRUFBbUI7QUFDckIsRUFBRSx3RUFBZ0I7QUFDbEIsRUFBRSx3RUFBZ0I7QUFDbEIsRUFBRSw2REFBWTtBQUNkLEVBQUUscUVBQWE7QUFDZixFQUFFLGdGQUF1QjtBQUN6QixFQUFFLDJEQUFnQjtBQUNsQixFQUFFLDBEQUFlO0FBQ2pCLEVBQUUsb0VBQVk7QUFDZCxFQUFFLDhEQUFtQjtBQUNyQixFQUFFLCtEQUFvQjtBQUN0QixFQUFFLHdEQUFjO0FBQ2hCLEVBQUUscUZBQTJCO0FBQzdCLEVBQUUsNkRBQWtCO0FBQ3BCLEVBQUUsd0RBQWM7QUFDaEIsRUFBRSxrRUFBVTtBQUNaLEVBQUUsdURBQWE7QUFDZixFQUFFLCtEQUFvQjtBQUN0QixFQUFFLG9FQUFZO0FBQ2QsRUFBRSx3REFBYzs7QUFFaEIsRUFBRSxnRUFBb0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLCtEQUF5QjtBQUMzQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzSWdDOztBQUVGOztBQUUyQztBQUNMO0FBQ0E7OztBQUdwRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDZTtBQUNmLEVBQUUsaURBQVc7QUFDYjs7QUFFQSwrQ0FBUSxrQkFBa0IsNENBQU07OztBQUdoQztBQUNBLEVBQUUsNEVBQWtCO0FBQ3BCLEVBQUUseUVBQWdCO0FBQ2xCLEVBQUUseUVBQWdCO0FBQ2xCOztBQUVBO0FBQ0EsRUFBRSwrREFBeUI7QUFDM0I7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJnQzs7QUFFQTtBQUM0QjtBQUNJO0FBQ0Y7O0FBRXhCOztBQUV2QjtBQUNmLEVBQUUscURBQWU7QUFDakI7O0FBRUEsK0NBQVEsU0FBUyxnREFBVTs7QUFFM0I7QUFDQTtBQUNBLEVBQUUsMENBQVU7QUFDWixFQUFFLGtFQUFlO0FBQ2pCLEVBQUUsc0VBQWU7QUFDakIsRUFBRSxxRUFBYztBQUNoQjs7QUFFQTtBQUNBLHdDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCaUM7QUFDSTs7QUFFckMsaUVBQWU7QUFDZjtBQUNBLElBQUksMENBQVU7QUFDZCxJQUFJLDRDQUFZO0FBQ2hCO0FBQ0EsQ0FBQyxFOzs7Ozs7Ozs7Ozs7Ozs7QUNSRDtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxNQUFNLEtBQUssRUFBRSxLQUFLLE1BQU0sS0FBSyxHQUFHLEtBQUssTUFBTSxLQUFLO0FBQzdFLGFBQWEsS0FBSyxPQUFPLEtBQUssR0FBRyxLQUFLLE9BQU8sS0FBSyxFQUFFLEtBQUs7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBLGdGQUFnRixLQUFLLEdBQUcsS0FBSztBQUM3RixnRkFBZ0YsS0FBSyxHQUFHLEtBQUs7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRyxNQUFNLEtBQUssSUFBSSxLQUFLLFNBQVMsS0FBSyxNQUFNLEtBQUssRUFBRSxLQUFLLElBQUksS0FBSyxHQUFHLEtBQUs7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHLElBQUksS0FBSyxFQUFFLEtBQUssS0FBSyxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRyxJQUFJLEtBQUssRUFBRSxLQUFLLEtBQUssS0FBSyxHQUFHLEtBQUssS0FBSyxLQUFLLEVBQUUsS0FBSztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLFFBQVEsS0FBSyxLQUFLLEtBQUs7QUFDekQsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEMsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEMsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEMsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEMsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEMsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHLElBQUksS0FBSyxHQUFHLEtBQUssTUFBTSxLQUFLLEVBQUUsS0FBSyxNQUFNLEtBQUssRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssR0FBRyxLQUFLLEVBQUUsS0FBSyxHQUFHLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUcsR0FBRyxLQUFLLE1BQU0sS0FBSyxFQUFFLEtBQUssTUFBTSxLQUFLLEVBQUUsS0FBSztBQUNqRSxhQUFhLEtBQUssRUFBRSxLQUFLLE9BQU8sS0FBSyxHQUFHLEtBQUssT0FBTyxLQUFLLEdBQUcsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLLEdBQUcsS0FBSyxJQUFJLEtBQUssTUFBTSxLQUFLLEdBQUcsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLLElBQUksS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRyxJQUFJLEtBQUssR0FBRyxLQUFLLEtBQUssS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLEVBQUUsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsR0FBRyxFQUFFLEdBQUc7QUFDdEIsY0FBYyxLQUFLLEVBQUUsS0FBSyxLQUFLLEtBQUssRUFBRSxLQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssR0FBRyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLLEVBQUUsS0FBSyxHQUFHLEtBQUs7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxNQUFNLEtBQUssRUFBRSxLQUFLLE1BQU0sS0FBSyxHQUFHLEtBQUssTUFBTSxLQUFLO0FBQzNFLFdBQVcsS0FBSyxPQUFPLEtBQUssR0FBRyxLQUFLLE9BQU8sS0FBSyxFQUFFLEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLEVBQUUsS0FBSztBQUN2RSxzQkFBc0IsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLElBQUksS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSztBQUN2RSxzQkFBc0IsS0FBSyxJQUFJLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSxHQUFHLEVBQUUsR0FBRyxJQUFJLEtBQUssR0FBRyxLQUFLLE1BQU0sS0FBSyxFQUFFLEtBQUssTUFBTSxLQUFLLEVBQUUsS0FBSztBQUN6RSxhQUFhLEtBQUssRUFBRSxLQUFLLE9BQU8sS0FBSyxHQUFHLEtBQUssT0FBTyxLQUFLLEdBQUcsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVksR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSxHQUFHLEVBQUUsR0FBRyxJQUFJLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLLE1BQU0sS0FBSztBQUM3RixVQUFVLEtBQUssTUFBTSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxHQUFHLEtBQUssSUFBSSxLQUFLLEVBQUUsS0FBSyxPQUFPLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSztBQUMxRyxVQUFVLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssRUFBRSxLQUFLLE9BQU8sS0FBSyxHQUFHLEtBQUssSUFBSSxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ25HLFdBQVcsS0FBSyxFQUFFLEtBQUssS0FBSyxLQUFLLEdBQUcsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixLQUFLLElBQUksS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLEdBQUcsS0FBSyxPQUFPLEtBQUssRUFBRSxLQUFLLE1BQU0sS0FBSyxFQUFFLEtBQUs7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLEdBQUcsR0FBRyxHQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckIsZUFBZSxLQUFLO0FBQ3BCLGFBQWEsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxHQUFHLEtBQUs7QUFDL0MsZ0JBQWdCLEtBQUs7QUFDckIsYUFBYSxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztBQUNsRCxhQUFhLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLO0FBQy9DLGNBQWMsS0FBSyxFQUFFLEtBQUs7QUFDMUIsYUFBYSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSztBQUM5QyxjQUFjLEtBQUssRUFBRSxLQUFLO0FBQzFCLGFBQWEsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxHQUFHLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsR0FBRyxHQUFHLHFCQUFxQixLQUFLO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSxHQUFHLEVBQUUsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVksR0FBRyxFQUFFLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLEdBQUcsRUFBRSxHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHLE1BQU0sS0FBSyxJQUFJLEtBQUssU0FBUyxLQUFLLE1BQU0sS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLEdBQUcsS0FBSztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ3JCLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FB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QUFDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWGtFOztBQUVuRTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLDRFQUF3QjtBQUNuRSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUFHLGlCQUFpQjs7QUFFdEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBLCtDQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RDs7Ozs7Ozs7Ozs7QUMvVXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVU7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU0sT0FBTyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUs7QUFDM0MsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU0sR0FBRyxLQUFLLEVBQUUsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTyxLQUFLO0FBQ3ZCLFdBQVcsT0FBTyxLQUFLO0FBQ3ZCLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsa0RBQVU7O0FBRXBCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGtEQUFVO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUEsRUFBRSxpREFBTzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBOztBQUVBLFFBQVEsaURBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUEsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGtEQUFVO0FBQzFCLE9BQU87QUFDUDtBQUNBLHFCQUFxQixtREFBVzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxtREFBVzs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTyxJQUFJOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUUsaURBQU8sZUFBZSw4Q0FBSTs7QUFFNUI7QUFDQSxRQUFRLGdEQUFNLEdBQUc7QUFDakI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDOztBQUVBLGFBQWEsWUFBWTtBQUN6QjtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7O0FBRUEsYUFBYSxRQUFROztBQUVyQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFRO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVgsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUVBQW1FO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQyxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUCwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtFQUErRTtBQUMvRTtBQUNBOztBQUVBLGlDQUFpQyxPQUFPO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUU0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6akM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QjtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QjtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7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VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxnQ0FBZ0MsWUFBWTtXQUM1QztXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx3Q0FBd0MseUNBQXlDO1dBQ2pGO1dBQ0E7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRUFBRTtXQUNGO1dBQ0E7V0FDQSxDQUFDLEk7Ozs7O1dDUEQsd0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7O1VDTkE7VUFDQTtVQUNBO1VBQ0EiLCJmaWxlIjoicG9zdGl0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUG9zdEl0TW9kZWxlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJQb3N0SXRNb2RlbGVyXCJdID0gZmFjdG9yeSgpO1xufSkoc2VsZiwgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IElkcyBmcm9tICdpZHMnO1xuXG5pbXBvcnQgQmFzZVZpZXdlciBmcm9tICcuL0Jhc2VWaWV3ZXInO1xuXG5cbi8qKlxuICogQSBiYXNlIG1vZGVsZXIgZm9yIHBvc3RpdC1qcyBib2FyZHMuXG4gKlxuICogSGF2ZSBhIGxvb2sgYXQge0BsaW5rIE1vZGVsZXJ9IGZvciBhIGJ1bmRsZSB0aGF0IGluY2x1ZGVzIGFjdHVhbCBmZWF0dXJlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byBwYXNzIHRvIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gW29wdGlvbnMuY29udGFpbmVyXSB0aGUgY29udGFpbmVyIHRvIHJlbmRlciB0aGUgdmlld2VyIGluLCBkZWZhdWx0cyB0byBib2R5LlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gdGhlIHdpZHRoIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSB0aGUgaGVpZ2h0IG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tb2RkbGVFeHRlbnNpb25zXSBleHRlbnNpb24gcGFja2FnZXMgdG8gcHJvdmlkZVxuICogQHBhcmFtIHtBcnJheTxkaWRpLk1vZHVsZT59IFtvcHRpb25zLm1vZHVsZXNdIGEgbGlzdCBvZiBtb2R1bGVzIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1vZHVsZXNcbiAqIEBwYXJhbSB7QXJyYXk8ZGlkaS5Nb2R1bGU+fSBbb3B0aW9ucy5hZGRpdGlvbmFsTW9kdWxlc10gYSBsaXN0IG9mIG1vZHVsZXMgdG8gdXNlIHdpdGggdGhlIGRlZmF1bHQgbW9kdWxlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCYXNlTW9kZWxlcihvcHRpb25zKSB7XG4gIEJhc2VWaWV3ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAvLyBob29rIElEIGNvbGxlY3Rpb24gaW50byB0aGUgbW9kZWxlclxuICB0aGlzLm9uKCdpbXBvcnQucGFyc2UuY29tcGxldGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghZXZlbnQuZXJyb3IpIHtcbiAgICAgIHRoaXMuX2NvbGxlY3RJZHMoZXZlbnQuZGVmaW5pdGlvbnMsIGV2ZW50LmNvbnRleHQpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5vbignZGlhZ3JhbS5kZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nZXQoJ21vZGRsZScpLmlkcy5jbGVhcigpO1xuICB9LCB0aGlzKTtcbn1cblxuaW5oZXJpdHMoQmFzZU1vZGVsZXIsIEJhc2VWaWV3ZXIpO1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbW9kZGxlIGluc3RhbmNlLCBhdHRhY2hpbmcgaWRzIHRvIGl0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbkJhc2VNb2RlbGVyLnByb3RvdHlwZS5fY3JlYXRlTW9kZGxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgbW9kZGxlID0gQmFzZVZpZXdlci5wcm90b3R5cGUuX2NyZWF0ZU1vZGRsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIC8vIGF0dGFjaCBpZHMgdG8gbW9kZGxlIHRvIGJlIGFibGUgdG8gdHJhY2tcbiAgLy8gYW5kIHZhbGlkYXRlZCBpZHMgaW4gdGhlIFhNTCBkb2N1bWVudFxuICAvLyB0cmVlXG4gIG1vZGRsZS5pZHMgPSBuZXcgSWRzKFsgMzIsIDM2LCAxIF0pO1xuXG4gIHJldHVybiBtb2RkbGU7XG59O1xuXG4vKipcbiAqIENvbGxlY3QgaWRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyc2luZyBvZiB0aGVcbiAqIGRlZmluaXRpb25zIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGRlZmluaXRpb25zXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHRcbiAqL1xuQmFzZU1vZGVsZXIucHJvdG90eXBlLl9jb2xsZWN0SWRzID0gZnVuY3Rpb24oZGVmaW5pdGlvbnMsIGNvbnRleHQpIHtcblxuICB2YXIgbW9kZGxlID0gZGVmaW5pdGlvbnMuJG1vZGVsLFxuICAgICAgaWRzID0gbW9kZGxlLmlkcyxcbiAgICAgIGlkO1xuXG4gIC8vIHJlbW92ZSByZWZlcmVuY2VzIGZyb20gcHJldmlvdXMgaW1wb3J0XG4gIGlkcy5jbGVhcigpO1xuXG4gIGZvciAoaWQgaW4gY29udGV4dC5lbGVtZW50c0J5SWQpIHtcbiAgICBpZHMuY2xhaW0oaWQsIGNvbnRleHQuZWxlbWVudHNCeUlkW2lkXSk7XG4gIH1cbn07XG4iLCIvKipcbiAqIFRoZSBjb2RlIGluIHRoZSA8cHJvamVjdC1sb2dvPjwvcHJvamVjdC1sb2dvPiBhcmVhXG4gKiBtdXN0IG5vdCBiZSBjaGFuZ2VkLlxuICpcbiAqIEBzZWUgaHR0cDovL2JwbW4uaW8vbGljZW5zZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmaW5kLFxuICBpc051bWJlcixcbiAgb21pdFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGRvbWlmeSxcbiAgcXVlcnkgYXMgZG9tUXVlcnksXG4gIHJlbW92ZSBhcyBkb21SZW1vdmVcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIGlubmVyU1ZHXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IERpYWdyYW0gZnJvbSAnZGlhZ3JhbS1qcyc7XG5pbXBvcnQgTW9kZGxlIGZyb20gJy4vbW9kZGxlJztcblxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IHtcbiAgaW1wb3J0UG9zdGl0RGlhZ3JhbVxufSBmcm9tICcuL2ltcG9ydC9JbXBvcnRlcic7XG5cblxuXG5cbi8qKlxuICogQSBiYXNlIHZpZXdlciBmb3IgUG9zdGl0IGJvYXJkcy5cbiAqXG4gKiBIYXZlIGEgbG9vayBhdCB7QGxpbmsgVmlld2VyfSwge0BsaW5rIE5hdmlnYXRlZFZpZXdlcn0gb3Ige0BsaW5rIE1vZGVsZXJ9IGZvclxuICogYnVuZGxlcyB0aGF0IGluY2x1ZGUgYWN0dWFsIGZlYXR1cmVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHZpZXdlclxuICogQHBhcmFtIHtET01FbGVtZW50fSBbb3B0aW9ucy5jb250YWluZXJdIHRoZSBjb250YWluZXIgdG8gcmVuZGVyIHRoZSB2aWV3ZXIgaW4sIGRlZmF1bHRzIHRvIGJvZHkuXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSB0aGUgd2lkdGggb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIHRoZSBoZWlnaHQgb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1vZGRsZUV4dGVuc2lvbnNdIGV4dGVuc2lvbiBwYWNrYWdlcyB0byBwcm92aWRlXG4gKiBAcGFyYW0ge0FycmF5PGRpZGkuTW9kdWxlPn0gW29wdGlvbnMubW9kdWxlc10gYSBsaXN0IG9mIG1vZHVsZXMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgbW9kdWxlc1xuICogQHBhcmFtIHtBcnJheTxkaWRpLk1vZHVsZT59IFtvcHRpb25zLmFkZGl0aW9uYWxNb2R1bGVzXSBhIGxpc3Qgb2YgbW9kdWxlcyB0byB1c2Ugd2l0aCB0aGUgZGVmYXVsdCBtb2R1bGVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJhc2VWaWV3ZXIob3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBhc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fbW9kZGxlID0gdGhpcy5fY3JlYXRlTW9kZGxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lcihvcHRpb25zKTtcblxuICB0aGlzLl9pbml0KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fbW9kZGxlLCBvcHRpb25zKTtcbn1cblxuaW5oZXJpdHMoQmFzZVZpZXdlciwgRGlhZ3JhbSk7XG5cbi8qKlxuKiBUaGUgaW1wb3J0WE1MIHJlc3VsdC5cbipcbiogQHR5cGVkZWYge09iamVjdH0gSW1wb3J0WE1MUmVzdWx0XG4qXG4qIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gd2FybmluZ3NcbiovXG5cbi8qKlxuKiBUaGUgaW1wb3J0WE1MIGVycm9yLlxuKlxuKiBAdHlwZWRlZiB7RXJyb3J9IEltcG9ydFhNTEVycm9yXG4qXG4qIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gd2FybmluZ3NcbiovXG5cblxuLyoqXG4gKiBQYXJzZSBhbmQgcmVuZGVyIGEgUG9zdGl0IGRpYWdyYW0uXG4gKlxuICogT25jZSBmaW5pc2hlZCB0aGUgdmlld2VyIHJlcG9ydHMgYmFjayB0aGUgcmVzdWx0IHRvIHRoZVxuICogcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCAoZXJyLCB3YXJuaW5ncykuXG4gKlxuICogIyMgTGlmZS1DeWNsZSBFdmVudHNcbiAqXG4gKiBEdXJpbmcgaW1wb3J0IHRoZSB2aWV3ZXIgd2lsbCBmaXJlIGxpZmUtY3ljbGUgZXZlbnRzOlxuICpcbiAqICAgKiBpbXBvcnQucGFyc2Uuc3RhcnQgKGFib3V0IHRvIHJlYWQgbW9kZWwgZnJvbSB4bWwpXG4gKiAgICogaW1wb3J0LnBhcnNlLmNvbXBsZXRlIChtb2RlbCByZWFkOyBtYXkgaGF2ZSB3b3JrZWQgb3Igbm90KVxuICogICAqIGltcG9ydC5yZW5kZXIuc3RhcnQgKGdyYXBoaWNhbCBpbXBvcnQgc3RhcnQpXG4gKiAgICogaW1wb3J0LnJlbmRlci5jb21wbGV0ZSAoZ3JhcGhpY2FsIGltcG9ydCBmaW5pc2hlZClcbiAqICAgKiBpbXBvcnQuZG9uZSAoZXZlcnl0aGluZyBkb25lKVxuICpcbiAqIFlvdSBjYW4gdXNlIHRoZXNlIGV2ZW50cyB0byBob29rIGludG8gdGhlIGxpZmUtY3ljbGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHhtbCB0aGUgUG9zdGl0IHhtbFxuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50PFBvc3RpdFJvb3RCb2FyZD58U3RyaW5nfSBbcm9vdEJvYXJkXSBQb3N0aXQgYm9hcmQgb3IgaWQgb2YgYm9hcmQgdG8gcmVuZGVyIChpZiBub3QgcHJvdmlkZWQsIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZW5kZXJlZClcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxJbXBvcnRYTUxSZXN1bHQsIEltcG9ydFhNTEVycm9yPn1cbiAqL1xuQmFzZVZpZXdlci5wcm90b3R5cGUuaW1wb3J0WE1MID0gZnVuY3Rpb24oeG1sLCByb290Qm9hcmQpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgLy8gaG9vayBpbiBwcmUtcGFyc2UgbGlzdGVuZXJzICtcbiAgICAvLyBhbGxvdyB4bWwgbWFuaXB1bGF0aW9uXG4gICAgeG1sID0gc2VsZi5fZW1pdCgnaW1wb3J0LnBhcnNlLnN0YXJ0JywgeyB4bWw6IHhtbCB9KSB8fCB4bWw7XG5cbiAgICBzZWxmLl9tb2RkbGUuZnJvbVhNTCh4bWwsICdwb3N0aXQ6RGVmaW5pdGlvbnMnKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuXG4gICAgICB2YXIgZGVmaW5pdGlvbnMgPSByZXN1bHQucm9vdEVsZW1lbnQ7XG4gICAgICB2YXIgcmVmZXJlbmNlcyA9IHJlc3VsdC5yZWZlcmVuY2VzO1xuICAgICAgdmFyIHBhcnNlV2FybmluZ3MgPSByZXN1bHQud2FybmluZ3M7XG4gICAgICB2YXIgZWxlbWVudHNCeUlkID0gcmVzdWx0LmVsZW1lbnRzQnlJZDtcblxuICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXMsXG4gICAgICAgIGVsZW1lbnRzQnlJZDogZWxlbWVudHNCeUlkLFxuICAgICAgICB3YXJuaW5nczogcGFyc2VXYXJuaW5nc1xuICAgICAgfTtcblxuICAgICAgLy8gaG9vayBpbiBwb3N0IHBhcnNlIGxpc3RlbmVycyArXG4gICAgICAvLyBhbGxvdyBkZWZpbml0aW9ucyBtYW5pcHVsYXRpb25cbiAgICAgIGRlZmluaXRpb25zID0gc2VsZi5fZW1pdCgnaW1wb3J0LnBhcnNlLmNvbXBsZXRlJywge1xuICAgICAgICBkZWZpbml0aW9uczogZGVmaW5pdGlvbnMsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH0pIHx8IGRlZmluaXRpb25zO1xuXG4gICAgICBzZWxmLmltcG9ydERlZmluaXRpb25zKGRlZmluaXRpb25zLCByb290Qm9hcmQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHZhciBhbGxXYXJuaW5ncyA9IFtdLmNvbmNhdChwYXJzZVdhcm5pbmdzLCByZXN1bHQud2FybmluZ3MgfHwgW10pO1xuXG4gICAgICAgIHNlbGYuX2VtaXQoJ2ltcG9ydC5kb25lJywgeyBlcnJvcjogbnVsbCwgd2FybmluZ3M6IGFsbFdhcm5pbmdzIH0pO1xuXG4gICAgICAgIHJldHVybiByZXNvbHZlKHsgd2FybmluZ3M6IGFsbFdhcm5pbmdzIH0pO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIHZhciBhbGxXYXJuaW5ncyA9IFtdLmNvbmNhdChwYXJzZVdhcm5pbmdzLCBlcnIud2FybmluZ3MgfHwgW10pO1xuXG4gICAgICAgIHNlbGYuX2VtaXQoJ2ltcG9ydC5kb25lJywgeyBlcnJvcjogZXJyLCB3YXJuaW5nczogYWxsV2FybmluZ3MgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlamVjdChhZGRXYXJuaW5nc1RvRXJyb3IoZXJyLCBhbGxXYXJuaW5ncykpO1xuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG5cbiAgICAgIHNlbGYuX2VtaXQoJ2ltcG9ydC5wYXJzZS5jb21wbGV0ZScsIHtcbiAgICAgICAgZXJyb3I6IGVyclxuICAgICAgfSk7XG5cbiAgICAgIGVyciA9IGNoZWNrVmFsaWRhdGlvbkVycm9yKGVycik7XG5cbiAgICAgIHNlbGYuX2VtaXQoJ2ltcG9ydC5kb25lJywgeyBlcnJvcjogZXJyLCB3YXJuaW5nczogZXJyLndhcm5pbmdzIH0pO1xuXG4gICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgfSk7XG5cbiAgfSk7XG59O1xuXG4vKipcbiogVGhlIGltcG9ydERlZmluaXRpb25zIHJlc3VsdC5cbipcbiogQHR5cGVkZWYge09iamVjdH0gSW1wb3J0RGVmaW5pdGlvbnNSZXN1bHRcbipcbiogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSB3YXJuaW5nc1xuKi9cblxuLyoqXG4qIFRoZSBpbXBvcnREZWZpbml0aW9ucyBlcnJvci5cbipcbiogQHR5cGVkZWYge0Vycm9yfSBJbXBvcnREZWZpbml0aW9uc0Vycm9yXG4qXG4qIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gd2FybmluZ3NcbiovXG5cbi8qKlxuICogSW1wb3J0IHBhcnNlZCBkZWZpbml0aW9ucyBhbmQgcmVuZGVyIGEgUG9zdGl0IGRpYWdyYW0uXG4gKlxuICogT25jZSBmaW5pc2hlZCB0aGUgdmlld2VyIHJlcG9ydHMgYmFjayB0aGUgcmVzdWx0IHRvIHRoZVxuICogcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCAoZXJyLCB3YXJuaW5ncykuXG4gKlxuICogIyMgTGlmZS1DeWNsZSBFdmVudHNcbiAqXG4gKiBEdXJpbmcgaW1wb3J0IHRoZSB2aWV3ZXIgd2lsbCBmaXJlIGxpZmUtY3ljbGUgZXZlbnRzOlxuICpcbiAqICAgKiBpbXBvcnQucmVuZGVyLnN0YXJ0IChncmFwaGljYWwgaW1wb3J0IHN0YXJ0KVxuICogICAqIGltcG9ydC5yZW5kZXIuY29tcGxldGUgKGdyYXBoaWNhbCBpbXBvcnQgZmluaXNoZWQpXG4gKlxuICogWW91IGNhbiB1c2UgdGhlc2UgZXZlbnRzIHRvIGhvb2sgaW50byB0aGUgbGlmZS1jeWNsZS5cbiAqXG4gKiBAcGFyYW0ge01vZGRsZUVsZW1lbnQ8RGVmaW5pdGlvbnM+fSBkZWZpbml0aW9ucyBwYXJzZWQgUG9zdGl0IGRlZmluaXRpb25zXG4gKiBAcGFyYW0ge01vZGRsZUVsZW1lbnQ8UG9zdGl0Um9vdEJvYXJkPnxTdHJpbmd9IFtyb290Qm9hcmRdIFBvc3RpdCBib2FyZCBvciBpZCBvZiBib2FyZCB0byByZW5kZXIgKGlmIG5vdCBwcm92aWRlZCwgdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJlbmRlcmVkKVxuICpcbiAqIHJldHVybnMge1Byb21pc2U8SW1wb3J0RGVmaW5pdGlvbnNSZXN1bHQsIEltcG9ydERlZmluaXRpb25zRXJyb3I+fVxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5pbXBvcnREZWZpbml0aW9ucyA9IGZ1bmN0aW9uKGRlZmluaXRpb25zLCByb290Qm9hcmQpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgc2VsZi5fc2V0RGVmaW5pdGlvbnMoZGVmaW5pdGlvbnMpO1xuXG4gICAgc2VsZi5vcGVuKHJvb3RCb2FyZCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcblxuICAgICAgdmFyIHdhcm5pbmdzID0gcmVzdWx0Lndhcm5pbmdzO1xuXG4gICAgICByZXR1cm4gcmVzb2x2ZSh7IHdhcm5pbmdzOiB3YXJuaW5ncyB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcblxuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogVGhlIG9wZW4gcmVzdWx0LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wZW5SZXN1bHRcbiAqXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IHdhcm5pbmdzXG4gKi9cblxuLyoqXG4qIFRoZSBvcGVuIGVycm9yLlxuKlxuKiBAdHlwZWRlZiB7RXJyb3J9IE9wZW5FcnJvclxuKlxuKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IHdhcm5pbmdzXG4qL1xuXG4vKipcbiAqIE9wZW4gYm9hcmQgb2YgcHJldmlvdXNseSBpbXBvcnRlZCBYTUwuXG4gKlxuICogT25jZSBmaW5pc2hlZCB0aGUgdmlld2VyIHJlcG9ydHMgYmFjayB0aGUgcmVzdWx0IHRvIHRoZVxuICogcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCAoZXJyLCB3YXJuaW5ncykuXG4gKlxuICogIyMgTGlmZS1DeWNsZSBFdmVudHNcbiAqXG4gKiBEdXJpbmcgc3dpdGNoIHRoZSB2aWV3ZXIgd2lsbCBmaXJlIGxpZmUtY3ljbGUgZXZlbnRzOlxuICpcbiAqICAgKiBpbXBvcnQucmVuZGVyLnN0YXJ0IChncmFwaGljYWwgaW1wb3J0IHN0YXJ0KVxuICogICAqIGltcG9ydC5yZW5kZXIuY29tcGxldGUgKGdyYXBoaWNhbCBpbXBvcnQgZmluaXNoZWQpXG4gKlxuICogWW91IGNhbiB1c2UgdGhlc2UgZXZlbnRzIHRvIGhvb2sgaW50byB0aGUgbGlmZS1jeWNsZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xNb2RkbGVFbGVtZW50PFBvc3RpdFJvb3RCb2FyZD59IFtyb290Qm9hcmRPcklkXSBpZCBvciB0aGUgZGlhZ3JhbSB0byBvcGVuXG4gKlxuICogcmV0dXJucyB7UHJvbWlzZTxPcGVuUmVzdWx0LCBPcGVuRXJyb3I+fVxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24ocm9vdEJvYXJkT3JJZCkge1xuXG4gIHZhciBkZWZpbml0aW9ucyA9IHRoaXMuX2RlZmluaXRpb25zO1xuICB2YXIgcm9vdEJvcmQgPSByb290Qm9hcmRPcklkO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKCFkZWZpbml0aW9ucykge1xuICAgICAgdmFyIGVycjEgPSBuZXcgRXJyb3IoJ25vIFhNTCBpbXBvcnRlZCcpO1xuXG4gICAgICByZXR1cm4gcmVqZWN0KGFkZFdhcm5pbmdzVG9FcnJvcihlcnIxLCBbXSkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygcm9vdEJvYXJkT3JJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvb3RCb3JkID0gZmluZFJvb3RCb2FyZChkZWZpbml0aW9ucywgcm9vdEJvYXJkT3JJZCk7XG5cbiAgICAgIGlmICghcm9vdEJvcmQpIHtcbiAgICAgICAgdmFyIGVycjIgPSBuZXcgRXJyb3IoJ1Bvc3RpdFJvb3RCb2FyZCA8JyArIHJvb3RCb2FyZE9ySWQgKyAnPiBub3QgZm91bmQnKTtcblxuICAgICAgICByZXR1cm4gcmVqZWN0KGFkZFdhcm5pbmdzVG9FcnJvcihlcnIyLCBbXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFyIGV4aXN0aW5nIHJlbmRlcmVkIGRpYWdyYW1cbiAgICAvLyBjYXRjaCBzeW5jaHJvbm91cyBleGNlcHRpb25zIGR1cmluZyAjY2xlYXIoKVxuICAgIHRyeSB7XG4gICAgICBzZWxmLmNsZWFyKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcblxuICAgICAgcmV0dXJuIHJlamVjdChhZGRXYXJuaW5nc1RvRXJyb3IoZXJyb3IsIFtdKSk7XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSBncmFwaGljYWwgaW1wb3J0XG4gICAgaW1wb3J0UG9zdGl0RGlhZ3JhbShzZWxmLCBkZWZpbml0aW9ucywgcm9vdEJvcmQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cbiAgICAgIHZhciB3YXJuaW5ncyA9IHJlc3VsdC53YXJuaW5ncztcblxuICAgICAgcmV0dXJuIHJlc29sdmUoeyB3YXJuaW5nczogd2FybmluZ3MgfSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG5cbiAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRoZSBzYXZlWE1MIHJlc3VsdC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTYXZlWE1MUmVzdWx0XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHhtbFxuICovXG5cbi8qKlxuICogRXhwb3J0IHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIFBvc3RpdCBkaWFncmFtIGFzXG4gKiBhIFBvc3RpdCBYTUwgZG9jdW1lbnQuXG4gKlxuICogIyMgTGlmZS1DeWNsZSBFdmVudHNcbiAqXG4gKiBEdXJpbmcgWE1MIHNhdmluZyB0aGUgdmlld2VyIHdpbGwgZmlyZSBsaWZlLWN5Y2xlIGV2ZW50czpcbiAqXG4gKiAgICogc2F2ZVhNTC5zdGFydCAoYmVmb3JlIHNlcmlhbGl6YXRpb24pXG4gKiAgICogc2F2ZVhNTC5zZXJpYWxpemVkIChhZnRlciB4bWwgZ2VuZXJhdGlvbilcbiAqICAgKiBzYXZlWE1MLmRvbmUgKGV2ZXJ5dGhpbmcgZG9uZSlcbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGVzZSBldmVudHMgdG8gaG9vayBpbnRvIHRoZSBsaWZlLWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gZXhwb3J0IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9ybWF0PWZhbHNlXSBvdXRwdXQgZm9ybWF0dGVkIFhNTFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5wcmVhbWJsZT10cnVlXSBvdXRwdXQgcHJlYW1ibGVcbiAqXG4gKiByZXR1cm5zIHtQcm9taXNlPFNhdmVYTUxSZXN1bHQsIEVycm9yPn1cbiAqL1xuQmFzZVZpZXdlci5wcm90b3R5cGUuc2F2ZVhNTCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGRlZmluaXRpb25zID0gdGhpcy5fZGVmaW5pdGlvbnM7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgaWYgKCFkZWZpbml0aW9ucykge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignbm8gZGVmaW5pdGlvbnMgbG9hZGVkJyk7XG5cbiAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyB0byBmaWRkbGUgYXJvdW5kIHdpdGggZGVmaW5pdGlvbnNcbiAgICBkZWZpbml0aW9ucyA9IHNlbGYuX2VtaXQoJ3NhdmVYTUwuc3RhcnQnLCB7XG4gICAgICBkZWZpbml0aW9uczogZGVmaW5pdGlvbnNcbiAgICB9KSB8fCBkZWZpbml0aW9ucztcblxuICAgIHNlbGYuX21vZGRsZS50b1hNTChkZWZpbml0aW9ucywgb3B0aW9ucykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcblxuICAgICAgdmFyIHhtbCA9IHJlc3VsdC54bWw7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHhtbCA9IHNlbGYuX2VtaXQoJ3NhdmVYTUwuc2VyaWFsaXplZCcsIHtcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB4bWw6IHhtbFxuICAgICAgICB9KSB8fCB4bWw7XG5cbiAgICAgICAgc2VsZi5fZW1pdCgnc2F2ZVhNTC5kb25lJywge1xuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIHhtbDogeG1sXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdlcnJvciBpbiBzYXZlWE1MIGxpZmUtY3ljbGUgbGlzdGVuZXInLCBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc29sdmUoeyB4bWw6IHhtbCB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcblxuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogVGhlIHNhdmVTVkcgcmVzdWx0LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNhdmVTVkdSZXN1bHRcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3ZnXG4gKi9cblxuLyoqXG4gKiBFeHBvcnQgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgUG9zdGl0IGRpYWdyYW0gYXNcbiAqIGFuIFNWRyBpbWFnZS5cbiAqXG4gKiAjIyBMaWZlLUN5Y2xlIEV2ZW50c1xuICpcbiAqIER1cmluZyBTVkcgc2F2aW5nIHRoZSB2aWV3ZXIgd2lsbCBmaXJlIGxpZmUtY3ljbGUgZXZlbnRzOlxuICpcbiAqICAgKiBzYXZlU1ZHLnN0YXJ0IChiZWZvcmUgc2VyaWFsaXphdGlvbilcbiAqICAgKiBzYXZlU1ZHLmRvbmUgKGV2ZXJ5dGhpbmcgZG9uZSlcbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGVzZSBldmVudHMgdG8gaG9vayBpbnRvIHRoZSBsaWZlLWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqXG4gKiByZXR1cm5zIHtQcm9taXNlPFNhdmVTVkdSZXN1bHQsIEVycm9yPn1cbiAqL1xuQmFzZVZpZXdlci5wcm90b3R5cGUuc2F2ZVNWRyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgc2VsZi5fZW1pdCgnc2F2ZVNWRy5zdGFydCcpO1xuXG4gICAgdmFyIHN2ZywgZXJyO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBjYW52YXMgPSBzZWxmLmdldCgnY2FudmFzJyk7XG5cbiAgICAgIHZhciBjb250ZW50Tm9kZSA9IGNhbnZhcy5nZXREZWZhdWx0TGF5ZXIoKSxcbiAgICAgICAgICBkZWZzTm9kZSA9IGRvbVF1ZXJ5KCdkZWZzJywgY2FudmFzLl9zdmcpO1xuXG4gICAgICB2YXIgY29udGVudHMgPSBpbm5lclNWRyhjb250ZW50Tm9kZSksXG4gICAgICAgICAgZGVmcyA9IGRlZnNOb2RlID8gJzxkZWZzPicgKyBpbm5lclNWRyhkZWZzTm9kZSkgKyAnPC9kZWZzPicgOiAnJztcblxuICAgICAgdmFyIGJib3ggPSBjb250ZW50Tm9kZS5nZXRCQm94KCk7XG5cbiAgICAgIHN2ZyA9XG4gICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJ1dGYtOFwiPz5cXG4nICtcbiAgICAgICAgJzwhLS0gY3JlYXRlZCB3aXRoIGRpYWdyYW0tanMgLyBodHRwOi8vYnBtbi5pbyAtLT5cXG4nICtcbiAgICAgICAgJzwhRE9DVFlQRSBzdmcgUFVCTElDIFwiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU5cIiBcImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZFwiPlxcbicgK1xuICAgICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgJyArXG4gICAgICAgICAgICAgJ3dpZHRoPVwiJyArIGJib3gud2lkdGggKyAnXCIgaGVpZ2h0PVwiJyArIGJib3guaGVpZ2h0ICsgJ1wiICcgK1xuICAgICAgICAgICAgICd2aWV3Qm94PVwiJyArIGJib3gueCArICcgJyArIGJib3gueSArICcgJyArIGJib3gud2lkdGggKyAnICcgKyBiYm94LmhlaWdodCArICdcIiB2ZXJzaW9uPVwiMS4xXCI+JyArXG4gICAgICAgICAgZGVmcyArIGNvbnRlbnRzICtcbiAgICAgICAgJzwvc3ZnPic7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG5cbiAgICBzZWxmLl9lbWl0KCdzYXZlU1ZHLmRvbmUnLCB7XG4gICAgICBlcnJvcjogZXJyLFxuICAgICAgc3ZnOiBzdmdcbiAgICB9KTtcblxuICAgIGlmICghZXJyKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSh7IHN2Zzogc3ZnIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCBhIG5hbWVkIGRpYWdyYW0gc2VydmljZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBlbGVtZW50UmVnaXN0cnkgPSB2aWV3ZXIuZ2V0KCdlbGVtZW50UmVnaXN0cnknKTtcbiAqIHZhciBzdGFydEV2ZW50U2hhcGUgPSBlbGVtZW50UmVnaXN0cnkuZ2V0KCdTdGFydEV2ZW50XzEnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGlhZ3JhbSBzZXJ2aWNlIGluc3RhbmNlXG4gKlxuICogQG1ldGhvZCBCYXNlVmlld2VyI2dldFxuICovXG5cbi8qKlxuICogSW52b2tlIGEgZnVuY3Rpb24gaW4gdGhlIGNvbnRleHQgb2YgdGhpcyB2aWV3ZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2aWV3ZXIuaW52b2tlKGZ1bmN0aW9uKGVsZW1lbnRSZWdpc3RyeSkge1xuICogICB2YXIgc3RhcnRFdmVudFNoYXBlID0gZWxlbWVudFJlZ2lzdHJ5LmdldCgnU3RhcnRFdmVudF8xJyk7XG4gKiB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0byBiZSBpbnZva2VkXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgZnVuY3Rpb25zIHJldHVybiB2YWx1ZVxuICpcbiAqIEBtZXRob2QgQmFzZVZpZXdlciNpbnZva2VcbiAqL1xuXG5cbkJhc2VWaWV3ZXIucHJvdG90eXBlLl9zZXREZWZpbml0aW9ucyA9IGZ1bmN0aW9uKGRlZmluaXRpb25zKSB7XG4gIHRoaXMuX2RlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5nZXRNb2R1bGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9tb2R1bGVzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGRyYXduIGVsZW1lbnRzIGZyb20gdGhlIHZpZXdlci5cbiAqXG4gKiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIHRoZSB2aWV3ZXIgY2FuIHN0aWxsXG4gKiBiZSByZXVzZWQgZm9yIG9wZW5pbmcgYW5vdGhlciBkaWFncmFtLlxuICpcbiAqIEBtZXRob2QgQmFzZVZpZXdlciNjbGVhclxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZ2V0RGVmaW5pdGlvbnMoKSkge1xuXG4gICAgLy8gbm8gZGlhZ3JhbSB0byBjbGVhclxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHJlbW92ZSBidXNpbmVzc09iamVjdCNkaSBiaW5kaW5nXG4gIC8vXG4gIC8vIHRoaXMgaXMgbmVjZXNzYXJ5LCBhcyB3ZSBlc3RhYmxpc2ggdGhlIGJpbmRpbmdzXG4gIC8vIGluIHRoZSBQb3N0aXRUcmVlV2Fsa2VyIChhbmQgYXNzdW1lIG5vbmUgYXJlIGdpdmVuXG4gIC8vIG9uIHJlaW1wb3J0KVxuICB0aGlzLmdldCgnZWxlbWVudFJlZ2lzdHJ5JykuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGJvID0gZWxlbWVudC5idXNpbmVzc09iamVjdDtcblxuICAgIGlmIChibyAmJiBiby5kaSkge1xuICAgICAgZGVsZXRlIGJvLmRpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIGRyYXduIGVsZW1lbnRzXG4gIERpYWdyYW0ucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIHZpZXdlciBpbnN0YW5jZSBhbmQgcmVtb3ZlIGFsbCBpdHNcbiAqIHJlbWFpbmRlcnMgZnJvbSB0aGUgZG9jdW1lbnQgdHJlZS5cbiAqL1xuQmFzZVZpZXdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIGRpYWdyYW0gZGVzdHJveVxuICBEaWFncmFtLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgLy8gZG9tIGRldGFjaFxuICBkb21SZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBSZW1vdmUgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIHZpYSB7QGxpbmsgI29mZihldmVudCwgY2FsbGJhY2spfS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFt0aGF0XVxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBwcmlvcml0eSwgY2FsbGJhY2ssIHRhcmdldCkge1xuICByZXR1cm4gdGhpcy5nZXQoJ2V2ZW50QnVzJykub24oZXZlbnQsIHByaW9yaXR5LCBjYWxsYmFjaywgdGFyZ2V0KTtcbn07XG5cbi8qKlxuICogRGUtcmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkJhc2VWaWV3ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuICB0aGlzLmdldCgnZXZlbnRCdXMnKS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbn07XG5cbkJhc2VWaWV3ZXIucHJvdG90eXBlLmF0dGFjaFRvID0gZnVuY3Rpb24ocGFyZW50Tm9kZSkge1xuXG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFyZW50Tm9kZSByZXF1aXJlZCcpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHdlIGRldGFjaCBmcm9tIHRoZVxuICAvLyBwcmV2aW91cywgb2xkIHBhcmVudFxuICB0aGlzLmRldGFjaCgpO1xuXG4gIC8vIHVud3JhcCBqUXVlcnkgaWYgcHJvdmlkZWRcbiAgaWYgKHBhcmVudE5vZGUuZ2V0ICYmIHBhcmVudE5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLmpxdWVyeSkge1xuICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLmdldCgwKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyZW50Tm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXJlbnROb2RlID0gZG9tUXVlcnkocGFyZW50Tm9kZSk7XG4gIH1cblxuICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgdGhpcy5fZW1pdCgnYXR0YWNoJywge30pO1xuXG4gIHRoaXMuZ2V0KCdjYW52YXMnKS5yZXNpemVkKCk7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5nZXREZWZpbml0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbnM7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbigpIHtcblxuICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuICAgICAgcGFyZW50Tm9kZSA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuXG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2VtaXQoJ2RldGFjaCcsIHt9KTtcblxuICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgbW9kZGxlLCBvcHRpb25zKSB7XG5cbiAgdmFyIGJhc2VNb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzIHx8IHRoaXMuZ2V0TW9kdWxlcygpLFxuICAgICAgYWRkaXRpb25hbE1vZHVsZXMgPSBvcHRpb25zLmFkZGl0aW9uYWxNb2R1bGVzIHx8IFtdLFxuICAgICAgc3RhdGljTW9kdWxlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHBvc3RpdGpzOiBbICd2YWx1ZScsIHRoaXMgXSxcbiAgICAgICAgICBtb2RkbGU6IFsgJ3ZhbHVlJywgbW9kZGxlIF1cbiAgICAgICAgfVxuICAgICAgXTtcblxuICB2YXIgZGlhZ3JhbU1vZHVsZXMgPSBbXS5jb25jYXQoc3RhdGljTW9kdWxlcywgYmFzZU1vZHVsZXMsIGFkZGl0aW9uYWxNb2R1bGVzKTtcblxuICB2YXIgZGlhZ3JhbU9wdGlvbnMgPSBhc3NpZ24ob21pdChvcHRpb25zLCBbICdhZGRpdGlvbmFsTW9kdWxlcycgXSksIHtcbiAgICBjYW52YXM6IGFzc2lnbih7fSwgb3B0aW9ucy5jYW52YXMsIHsgY29udGFpbmVyOiBjb250YWluZXIgfSksXG4gICAgbW9kdWxlczogZGlhZ3JhbU1vZHVsZXNcbiAgfSk7XG5cbiAgLy8gaW52b2tlIGRpYWdyYW0gY29uc3RydWN0b3JcbiAgRGlhZ3JhbS5jYWxsKHRoaXMsIGRpYWdyYW1PcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5lcikge1xuICAgIHRoaXMuYXR0YWNoVG8ob3B0aW9ucy5jb250YWluZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIEVtaXQgYW4gZXZlbnQgb24gdGhlIHVuZGVybHlpbmcge0BsaW5rIEV2ZW50QnVzfVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICogQHBhcmFtICB7T2JqZWN0fSBldmVudFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZXZlbnQgcHJvY2Vzc2luZyByZXN1bHQgKGlmIGFueSlcbiAqL1xuQmFzZVZpZXdlci5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuICByZXR1cm4gdGhpcy5nZXQoJ2V2ZW50QnVzJykuZmlyZSh0eXBlLCBldmVudCk7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5fY3JlYXRlQ29udGFpbmVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gIHZhciBjb250YWluZXIgPSBkb21pZnkoJzxkaXYgY2xhc3M9XCJwanMtY29udGFpbmVyXCI+PC9kaXY+Jyk7XG5cbiAgYXNzaWduKGNvbnRhaW5lci5zdHlsZSwge1xuICAgIHdpZHRoOiBlbnN1cmVVbml0KG9wdGlvbnMud2lkdGgpLFxuICAgIGhlaWdodDogZW5zdXJlVW5pdChvcHRpb25zLmhlaWdodCksXG4gICAgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn07XG5cbkJhc2VWaWV3ZXIucHJvdG90eXBlLl9jcmVhdGVNb2RkbGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBtb2RkbGVPcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLl9tb2RkbGVFeHRlbnNpb25zLCBvcHRpb25zLm1vZGRsZUV4dGVuc2lvbnMpO1xuXG4gIHJldHVybiBuZXcgTW9kZGxlKG1vZGRsZU9wdGlvbnMpO1xufTtcblxuQmFzZVZpZXdlci5wcm90b3R5cGUuX21vZHVsZXMgPSBbXTtcblxuQmFzZVZpZXdlci5wcm90b3R5cGUuX21vZGRsZUV4dGVuc2lvbnMgPSB7fTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBhZGRXYXJuaW5nc1RvRXJyb3IoZXJyLCB3YXJuaW5nc0FyeSkge1xuICBlcnIud2FybmluZ3MgPSB3YXJuaW5nc0FyeTtcbiAgcmV0dXJuIGVycjtcbn1cblxuZnVuY3Rpb24gY2hlY2tWYWxpZGF0aW9uRXJyb3IoZXJyKSB7XG5cbiAgLy8gY2hlY2sgaWYgd2UgY2FuIGhlbHAgdGhlIHVzZXIgYnkgaW5kaWNhdGluZyB3cm9uZyBQb3N0aXQgeG1sXG4gIC8vIChpbiBjYXNlIGhlIG9yIHRoZSBleHBvcnRpbmcgdG9vbCBkaWQgbm90IGdldCB0aGF0IHJpZ2h0KVxuXG4gIHZhciBwYXR0ZXJuID0gL3VucGFyc2FibGUgY29udGVudCA8KFtePl0rKT4gZGV0ZWN0ZWQoW1xcc1xcU10qKSQvO1xuICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoZXJyLm1lc3NhZ2UpO1xuXG4gIGlmIChtYXRjaCkge1xuICAgIGVyci5tZXNzYWdlID1cbiAgICAgICd1bnBhcnNhYmxlIGNvbnRlbnQgPCcgKyBtYXRjaFsxXSArICc+IGRldGVjdGVkOyAnICtcbiAgICAgICd0aGlzIG1heSBpbmRpY2F0ZSBhbiBpbnZhbGlkIFBvc3RpdCBib2FyZCBmaWxlJyArIG1hdGNoWzJdO1xuICB9XG5cbiAgcmV0dXJuIGVycjtcbn1cblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgd2lkdGg6ICcxMDAlJyxcbiAgaGVpZ2h0OiAnMTAwJScsXG4gIHBvc2l0aW9uOiAncmVsYXRpdmUnXG59O1xuXG5cbi8qKlxuICogRW5zdXJlIHRoZSBwYXNzZWQgYXJndW1lbnQgaXMgYSBwcm9wZXIgdW5pdCAoZGVmYXVsdGluZyB0byBweClcbiAqL1xuZnVuY3Rpb24gZW5zdXJlVW5pdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCArIChpc051bWJlcih2YWwpID8gJ3B4JyA6ICcnKTtcbn1cblxuXG4vKipcbiAqIEZpbmQgUm9vdEJvYXJkIGluIGRlZmluaXRpb25zIGJ5IElEXG4gKlxuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50PERlZmluaXRpb25zPn0gZGVmaW5pdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBib2FyZElkXG4gKlxuICogQHJldHVybiB7TW9kZGxlRWxlbWVudDxQb3N0aXRSb290Qm9hcmQ+fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGZpbmRSb290Qm9hcmQoZGVmaW5pdGlvbnMsIGJvYXJkSWQpIHtcbiAgaWYgKCFib2FyZElkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZmluZChkZWZpbml0aW9ucy5yb290Qm9hcmRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuaWQgPT09IGJvYXJkSWQ7XG4gIH0pIHx8IG51bGw7XG59XG5cblxuaW1wb3J0IHtcbiAgZXZlbnQgYXMgZG9tRXZlbnRcbn0gZnJvbSAnbWluLWRvbSc7XG4iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgQmFzZU1vZGVsZXIgZnJvbSAnLi9CYXNlTW9kZWxlcic7XG5cbmltcG9ydCBWaWV3ZXIgZnJvbSAnLi9WaWV3ZXInO1xuaW1wb3J0IE5hdmlnYXRlZFZpZXdlciBmcm9tICcuL05hdmlnYXRlZFZpZXdlcic7XG5cbmltcG9ydCBLZXlib2FyZE1vdmVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi9rZXlib2FyZC1tb3ZlJztcbmltcG9ydCBNb3ZlQ2FudmFzTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL25hdmlnYXRpb24vbW92ZWNhbnZhcyc7XG5pbXBvcnQgVG91Y2hNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi90b3VjaCc7XG5pbXBvcnQgWm9vbVNjcm9sbE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL3pvb21zY3JvbGwnO1xuXG5pbXBvcnQgQWxpZ25FbGVtZW50c01vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9hbGlnbi1lbGVtZW50cyc7XG5pbXBvcnQgQXV0b1Njcm9sbE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9hdXRvLXNjcm9sbCc7XG5pbXBvcnQgQmVuZHBvaW50c01vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9iZW5kcG9pbnRzJztcbmltcG9ydCBDYW52YXNDcmVhdGUgZnJvbSAnLi9mZWF0dXJlcy9jYW52YXMtY3JlYXRlJztcbmltcG9ydCBDb25uZWN0TW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2Nvbm5lY3QnO1xuaW1wb3J0IENvbm5lY3Rpb25QcmV2aWV3TW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2Nvbm5lY3Rpb24tcHJldmlldyc7XG5pbXBvcnQgQ29udGV4dFBhZE1vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL2NvbnRleHQtcGFkJztcbmltcG9ydCBDb3B5UGFzdGVNb2R1bGUgZnJvbSAnLi9mZWF0dXJlcy9jb3B5LXBhc3RlJztcbmltcG9ydCBDcmVhdGVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY3JlYXRlJztcbmltcG9ydCBFZGl0b3JBY3Rpb25zTW9kdWxlIGZyb20gJy4vZmVhdHVyZXMvZWRpdG9yLWFjdGlvbnMnO1xuaW1wb3J0IEltYWdlU2VsZWN0aW9uTW9kdWxlIGZyb20gJy4vZmVhdHVyZXMvaW1hZ2Utc2VsZWN0aW9uJztcbmltcG9ydCBLZXlib2FyZE1vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL2tleWJvYXJkJztcbmltcG9ydCBLZXlib2FyZE1vdmVTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMva2V5Ym9hcmQtbW92ZS1zZWxlY3Rpb24nO1xuaW1wb3J0IExhYmVsRWRpdGluZ01vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL2xhYmVsLWVkaXRpbmcnO1xuaW1wb3J0IE1vZGVsaW5nTW9kdWxlIGZyb20gJy4vZmVhdHVyZXMvbW9kZWxpbmcnO1xuaW1wb3J0IE1vdmVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW92ZSc7XG5pbXBvcnQgUGFsZXR0ZU1vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL3BhbGV0dGUnO1xuaW1wb3J0IFJlcGxhY2VQcmV2aWV3TW9kdWxlIGZyb20gJy4vZmVhdHVyZXMvcmVwbGFjZS1wcmV2aWV3JztcbmltcG9ydCBSZXNpemVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcmVzaXplJztcbmltcG9ydCBTbmFwcGluZ01vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL3NuYXBwaW5nJztcblxuaW1wb3J0IERyYWdEcm9wSW1hZ2VzTW9kdWxlIGZyb20gJy4vZmVhdHVyZXMvZHJhZy1kcm9wLWltYWdlcyc7XG4vL2ltcG9ydCBTZWxlY3Rpb25Pcmdhbml6ZXJNb2R1bGUgZnJvbSAnLi9mZWF0dXJlcy9zZWxlY3Rpb24tb3JnYW5pemVyJztcbi8vaW1wb3J0IFByb3BlcnRpZXNQYW5lbE1vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL3Byb3BlcnRpZXMtcGFuZWwtdjInO1xuLy9pbXBvcnQgSW1hZ2VTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnLi9mZWF0dXJlcy9pbWFnZS1zZWxlY3Rpb24tdjInO1xuLy8gQ1RPRE9cblxuXG52YXIgaW5pdGlhbERpYWdyYW0gPVxuICBgPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XG4gIDxwb3N0aXQ6ZGVmaW5pdGlvbnMgeG1sbnM6eHNpPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2VcIiB4bWxuczpkYz1cImh0dHA6Ly93d3cub21nLm9yZy9zcGVjL0RELzIwMTAwNTI0L0RDXCIgeG1sbnM6ZGk9XCJodHRwOi8vd3d3Lm9tZy5vcmcvc3BlYy9ERC8yMDEwMDUyNC9ESVwiIGlkPVwic2FtcGxlLWRpYWdyYW1cIj5cbiAgICA8cG9zdGl0OlBvc3RpdEJvYXJkIGlkPVwiQm9hcmRfMVwiPlxuICAgIDwvcG9zdGl0OlBvc3RpdEJvYXJkPlxuICAgIDxwb3N0aXREaTpQb3N0aXRSb290Qm9hcmQgaWQ9XCJSb290Qm9hcmRfMVwiPlxuICAgICAgPHBvc3RpdERpOlBvc3RpdFBsYW5lIGlkPVwiUG9zaXRQbGFuZV8xXCIgYm9hcmRFbGVtZW50PVwiQm9hcmRfMVwiPlxuICAgICAgPC9wb3N0aXREaTpQb3N0aXRQbGFuZT5cbiAgICA8L3Bvc3RpdERpOlBvc3RpdFJvb3RCb2FyZD5cbiAgPC9wb3N0aXQ6ZGVmaW5pdGlvbnM+YDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW9kZWxlcihvcHRpb25zKSB7XG4gIEJhc2VNb2RlbGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5pbmhlcml0cyhNb2RlbGVyLCBCYXNlTW9kZWxlcik7XG5cblxuTW9kZWxlci5WaWV3ZXIgPSBWaWV3ZXI7XG5Nb2RlbGVyLk5hdmlnYXRlZFZpZXdlciA9IE5hdmlnYXRlZFZpZXdlcjtcblxuLyoqXG4qIFRoZSBjcmVhdGVEaWFncmFtIHJlc3VsdC5cbipcbiogQHR5cGVkZWYge09iamVjdH0gQ3JlYXRlRGlhZ3JhbVJlc3VsdFxuKlxuKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IHdhcm5pbmdzXG4qL1xuXG4vKipcbiogVGhlIGNyZWF0ZURpYWdyYW0gZXJyb3IuXG4qXG4qIEB0eXBlZGVmIHtFcnJvcn0gQ3JlYXRlRGlhZ3JhbUVycm9yXG4qXG4qIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gd2FybmluZ3NcbiovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGRpYWdyYW0gdG8gc3RhcnQgbW9kZWxpbmcuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8Q3JlYXRlRGlhZ3JhbVJlc3VsdCwgQ3JlYXRlRGlhZ3JhbUVycm9yPn1cbiAqXG4gKi9cbk1vZGVsZXIucHJvdG90eXBlLmNyZWF0ZURpYWdyYW0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaW1wb3J0WE1MKGluaXRpYWxEaWFncmFtKTtcbn07XG5cblxuTW9kZWxlci5wcm90b3R5cGUuX2ludGVyYWN0aW9uTW9kdWxlcyA9IFtcblxuICAvLyBub24tbW9kZWxpbmcgY29tcG9uZW50c1xuICBLZXlib2FyZE1vdmVNb2R1bGUsXG4gIE1vdmVDYW52YXNNb2R1bGUsXG4gIFRvdWNoTW9kdWxlLFxuICBab29tU2Nyb2xsTW9kdWxlXG5dO1xuXG5Nb2RlbGVyLnByb3RvdHlwZS5fbW9kZWxpbmdNb2R1bGVzID0gW1xuXG4gIC8vIG1vZGVsaW5nIGNvbXBvbmVudHNcbiAgQWxpZ25FbGVtZW50c01vZHVsZSxcbiAgQXV0b1Njcm9sbE1vZHVsZSxcbiAgQmVuZHBvaW50c01vZHVsZSxcbiAgQ2FudmFzQ3JlYXRlLFxuICBDb25uZWN0TW9kdWxlLFxuICBDb25uZWN0aW9uUHJldmlld01vZHVsZSxcbiAgQ29udGV4dFBhZE1vZHVsZSxcbiAgQ29weVBhc3RlTW9kdWxlLFxuICBDcmVhdGVNb2R1bGUsXG4gIEVkaXRvckFjdGlvbnNNb2R1bGUsXG4gIEltYWdlU2VsZWN0aW9uTW9kdWxlLFxuICBLZXlib2FyZE1vZHVsZSxcbiAgS2V5Ym9hcmRNb3ZlU2VsZWN0aW9uTW9kdWxlLFxuICBMYWJlbEVkaXRpbmdNb2R1bGUsXG4gIE1vZGVsaW5nTW9kdWxlLFxuICBNb3ZlTW9kdWxlLFxuICBQYWxldHRlTW9kdWxlLFxuICBSZXBsYWNlUHJldmlld01vZHVsZSxcbiAgUmVzaXplTW9kdWxlLFxuICBTbmFwcGluZ01vZHVsZSxcblxuICBEcmFnRHJvcEltYWdlc01vZHVsZSxcbiAgLy9TZWxlY3Rpb25Pcmdhbml6ZXJNb2R1bGUsXG4gIC8vUHJvcGVydGllc1BhbmVsTW9kdWxlLFxuICAvL0ltYWdlU2VsZWN0aW9uTW9kdWxlLFxuICAvLyBDVE9ET1xuICBcbl07XG5cblxuLy8gbW9kdWxlcyB0aGUgbW9kZWxlciBpcyBjb21wb3NlZCBvZlxuLy9cbi8vIC0gdmlld2VyIG1vZHVsZXNcbi8vIC0gaW50ZXJhY3Rpb24gbW9kdWxlc1xuLy8gLSBtb2RlbGluZyBtb2R1bGVzXG5cbk1vZGVsZXIucHJvdG90eXBlLl9tb2R1bGVzID0gW10uY29uY2F0KFxuICBWaWV3ZXIucHJvdG90eXBlLl9tb2R1bGVzLFxuICBNb2RlbGVyLnByb3RvdHlwZS5faW50ZXJhY3Rpb25Nb2R1bGVzLFxuICBNb2RlbGVyLnByb3RvdHlwZS5fbW9kZWxpbmdNb2R1bGVzXG4pO1xuIiwiaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IFZpZXdlciBmcm9tICcuL1ZpZXdlcic7XG5cbmltcG9ydCBLZXlib2FyZE1vdmVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi9rZXlib2FyZC1tb3ZlJztcbmltcG9ydCBNb3ZlQ2FudmFzTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL25hdmlnYXRpb24vbW92ZWNhbnZhcyc7XG5pbXBvcnQgWm9vbVNjcm9sbE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL3pvb21zY3JvbGwnO1xuXG5cbi8qKlxuICogQSB2aWV3ZXIgdGhhdCBpbmNsdWRlcyBtb3VzZSBuYXZpZ2F0aW9uIGZhY2lsaXRpZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBOYXZpZ2F0ZWRWaWV3ZXIob3B0aW9ucykge1xuICBWaWV3ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuaW5oZXJpdHMoTmF2aWdhdGVkVmlld2VyLCBWaWV3ZXIpO1xuXG5cbk5hdmlnYXRlZFZpZXdlci5wcm90b3R5cGUuX25hdmlnYXRpb25Nb2R1bGVzID0gW1xuICBLZXlib2FyZE1vdmVNb2R1bGUsXG4gIE1vdmVDYW52YXNNb2R1bGUsXG4gIFpvb21TY3JvbGxNb2R1bGVcbl07XG5cbk5hdmlnYXRlZFZpZXdlci5wcm90b3R5cGUuX21vZHVsZXMgPSBbXS5jb25jYXQoXG4gIFZpZXdlci5wcm90b3R5cGUuX21vZHVsZXMsXG4gIE5hdmlnYXRlZFZpZXdlci5wcm90b3R5cGUuX25hdmlnYXRpb25Nb2R1bGVzXG4pOyIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBDb3JlTW9kdWxlIGZyb20gJy4vY29yZSc7XG5pbXBvcnQgVHJhbnNsYXRlTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2kxOG4vdHJhbnNsYXRlJztcbmltcG9ydCBTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uJztcbmltcG9ydCBPdmVybGF5c01vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vdmVybGF5cyc7XG5cbmltcG9ydCBCYXNlVmlld2VyIGZyb20gJy4vQmFzZVZpZXdlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZpZXdlcihvcHRpb25zKSB7XG4gIEJhc2VWaWV3ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuaW5oZXJpdHMoVmlld2VyLCBCYXNlVmlld2VyKTtcblxuLy8gbW9kdWxlcyB0aGUgdmlld2VyIGlzIGNvbXBvc2VkIG9mXG5WaWV3ZXIucHJvdG90eXBlLl9tb2R1bGVzID0gW1xuICBDb3JlTW9kdWxlLFxuICBUcmFuc2xhdGVNb2R1bGUsXG4gIFNlbGVjdGlvbk1vZHVsZSxcbiAgT3ZlcmxheXNNb2R1bGVcbl07XG5cbi8vIGRlZmF1bHQgbW9kZGxlIGV4dGVuc2lvbnMgdGhlIHZpZXdlciBpcyBjb21wb3NlZCBvZlxuVmlld2VyLnByb3RvdHlwZS5fbW9kZGxlRXh0ZW5zaW9ucyA9IHt9OyIsImltcG9ydCBEcmF3TW9kdWxlIGZyb20gJy4uL2RyYXcnO1xuaW1wb3J0IEltcG9ydE1vZHVsZSBmcm9tICcuLi9pbXBvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgRHJhd01vZHVsZSxcbiAgICBJbXBvcnRNb2R1bGVcbiAgXVxufTsiLCIvKipcbiAqIE1hcCBjb250YWluaW5nIFNWRyBwYXRocyBuZWVkZWQgYnkgUG9zdGl0UmVuZGVyZXIuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGF0aE1hcCgpIHtcblxuICAvKipcbiAgICogQ29udGFpbnMgYSBtYXAgb2YgcGF0aCBlbGVtZW50c1xuICAgKlxuICAgKiA8aDE+UGF0aCBkZWZpbml0aW9uPC9oMT5cbiAgICogQSBwYXJhbWV0ZXJpemVkIHBhdGggaXMgZGVmaW5lZCBsaWtlIHRoaXM6XG4gICAqIDxwcmU+XG4gICAqICdHQVRFV0FZX1BBUkFMTEVMJzoge1xuICAgKiAgIGQ6ICdtIHtteH0se215fSB7ZS54MH0sMCAwLHtlLngxfSB7ZS54MX0sMCAwLHtlLnkwfSAte2UueDF9LDAgMCx7ZS55MX0gJyArXG4gICAgICAgICAgJy17ZS54MH0sMCAwLC17ZS55MX0gLXtlLngxfSwwIDAsLXtlLnkwfSB7ZS54MX0sMCB6JyxcbiAgICogICBoZWlnaHQ6IDE3LjUsXG4gICAqICAgd2lkdGg6ICAxNy41LFxuICAgKiAgIGhlaWdodEVsZW1lbnRzOiBbMi41LCA3LjVdLFxuICAgKiAgIHdpZHRoRWxlbWVudHM6IFsyLjUsIDcuNV1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICogPHA+SXQncyBpbXBvcnRhbnQgdG8gc3BlY2lmeSBhIGNvcnJlY3QgPGI+aGVpZ2h0IGFuZCB3aWR0aDwvYj4gZm9yIHRoZSBwYXRoIGFzIHRoZSBzY2FsaW5nXG4gICAqIGlzIGJhc2VkIG9uIHRoZSByYXRpbyBiZXR3ZWVuIHRoZSBzcGVjaWZpZWQgaGVpZ2h0IGFuZCB3aWR0aCBpbiB0aGlzIG9iamVjdCBhbmQgdGhlXG4gICAqIGhlaWdodCBhbmQgd2lkdGggdGhhdCBpcyBzZXQgYXMgc2NhbGUgdGFyZ2V0IChOb3RlIHgseSBjb29yZGluYXRlcyB3aWxsIGJlIHNjYWxlZCB3aXRoXG4gICAqIGluZGl2aWR1YWwgcmF0aW9zKS48L3A+XG4gICAqIDxwPlRoZSAnPGI+aGVpZ2h0RWxlbWVudHM8L2I+JyBhbmQgJzxiPndpZHRoRWxlbWVudHM8L2I+JyBhcnJheSBtdXN0IGNvbnRhaW4gdGhlIHZhbHVlcyB0aGF0IHdpbGwgYmUgc2NhbGVkLlxuICAgKiBUaGUgc2NhbGluZyBpcyBiYXNlZCBvbiB0aGUgY29tcHV0ZWQgcmF0aW9zLlxuICAgKiBDb29yZGluYXRlcyBvbiB0aGUgeSBheGlzIHNob3VsZCBiZSBpbiB0aGUgPGI+aGVpZ2h0RWxlbWVudDwvYj4ncyBhcnJheSwgdGhleSB3aWxsIGJlIHNjYWxlZCB1c2luZ1xuICAgKiB0aGUgY29tcHV0ZWQgcmF0aW8gY29lZmZpY2llbnQuXG4gICAqIEluIHRoZSBwYXJhbWV0ZXJpemVkIHBhdGggdGhlIHNjYWxlZCB2YWx1ZXMgY2FuIGJlIGFjY2Vzc2VkIHRocm91Z2ggdGhlICdlJyBvYmplY3QgaW4ge30gYnJhY2tldHMuXG4gICAqICAgPHVsPlxuICAgKiAgICA8bGk+VGhlIHZhbHVlcyBmb3IgdGhlIHkgYXhpcyBjYW4gYmUgYWNjZXNzZWQgaW4gdGhlIHBhdGggc3RyaW5nIHVzaW5nIHtlLnkwfSwge2UueTF9LCAuLi4uPC9saT5cbiAgICogICAgPGxpPlRoZSB2YWx1ZXMgZm9yIHRoZSB4IGF4aXMgY2FuIGJlIGFjY2Vzc2VkIGluIHRoZSBwYXRoIHN0cmluZyB1c2luZyB7ZS54MH0sIHtlLngxfSwgLi4uLjwvbGk+XG4gICAqICAgPC91bD5cbiAgICogICBUaGUgbnVtYmVycyB4MCwgeDEgcmVzcGVjdGl2ZWx5IHkwLCB5MSwgLi4uIG1hcCB0byB0aGUgY29ycmVzcG9uZGluZyBhcnJheSBpbmRleC5cbiAgICogPC9wPlxuICAgKi9cbiAgdGhpcy5wYXRoTWFwID0ge1xuICAgICdFVkVOVF9NRVNTQUdFJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IGwgMCx7ZS55MX0gbCB7ZS54MX0sMCBsIDAsLXtlLnkxfSB6IGwge2UueDB9LHtlLnkwfSBsIHtlLngwfSwte2UueTB9JyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogIDM2LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs2LCAxNF0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMTAuNSwgMjFdXG4gICAgfSxcbiAgICAnRVZFTlRfU0lHTkFMJzoge1xuICAgICAgZDogJ00ge214fSx7bXl9IGwge2UueDB9LHtlLnkwfSBsIC17ZS54MX0sMCBaJyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzE4XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFsxMCwgMjBdXG4gICAgfSxcbiAgICAnRVZFTlRfRVNDQUxBVElPTic6IHtcbiAgICAgIGQ6ICdNIHtteH0se215fSBsIHtlLngwfSx7ZS55MH0gbCAte2UueDB9LC17ZS55MX0gbCAte2UueDB9LHtlLnkxfSBaJyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzIwLCA3XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFs4XVxuICAgIH0sXG4gICAgJ0VWRU5UX0NPTkRJVElPTkFMJzoge1xuICAgICAgZDogJ00ge2UueDB9LHtlLnkwfSBsIHtlLngxfSwwIGwgMCx7ZS55Mn0gbCAte2UueDF9LDAgWiAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55M30gbCB7ZS54MH0sMCAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55NH0gbCB7ZS54MH0sMCAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55NX0gbCB7ZS54MH0sMCAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55Nn0gbCB7ZS54MH0sMCAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55N30gbCB7ZS54MH0sMCAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55OH0gbCB7ZS54MH0sMCAnLFxuICAgICAgaGVpZ2h0OiAzNixcbiAgICAgIHdpZHRoOiAgMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzguNSwgMTQuNSwgMTgsIDExLjUsIDE0LjUsIDE3LjUsIDIwLjUsIDIzLjUsIDI2LjVdLFxuICAgICAgd2lkdGhFbGVtZW50czogIFsxMC41LCAxNC41LCAxMi41XVxuICAgIH0sXG4gICAgJ0VWRU5UX0xJTksnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gMCx7ZS55MH0gLXtlLngxfSwwIDAse2UueTF9IHtlLngxfSwwIDAse2UueTB9IHtlLngwfSwte2UueTJ9IC17ZS54MH0sLXtlLnkyfSB6JyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzQuNDM3NSwgNi43NSwgNy44MTI1XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFs5Ljg0Mzc1LCAxMy41XVxuICAgIH0sXG4gICAgJ0VWRU5UX0VSUk9SJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IHtlLngwfSwte2UueTB9IHtlLngxfSwte2UueTF9IHtlLngyfSx7ZS55Mn0ge2UueDN9LC17ZS55M30gLXtlLng0fSx7ZS55NH0gLXtlLng1fSwte2UueTV9IHonLFxuICAgICAgaGVpZ2h0OiAzNixcbiAgICAgIHdpZHRoOiAzNixcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbMC4wMjMsIDguNzM3LCA4LjE1MSwgMTYuNTY0LCAxMC41OTEsIDguNzE0XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFswLjA4NSwgNi42NzIsIDYuOTcsIDQuMjczLCA1LjMzNywgNi42MzZdXG4gICAgfSxcbiAgICAnRVZFTlRfQ0FOQ0VMXzQ1Jzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IC17ZS54MX0sMCAwLHtlLngwfSB7ZS54MX0sMCAwLHtlLnkxfSB7ZS54MH0sMCAnICtcbiAgICAgICAgJzAsLXtlLnkxfSB7ZS54MX0sMCAwLC17ZS55MH0gLXtlLngxfSwwIDAsLXtlLnkxfSAte2UueDB9LDAgeicsXG4gICAgICBoZWlnaHQ6IDM2LFxuICAgICAgd2lkdGg6IDM2LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs0Ljc1LCA4LjVdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzQuNzUsIDguNV1cbiAgICB9LFxuICAgICdFVkVOVF9DT01QRU5TQVRJT04nOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0ge2UueDB9LC17ZS55MH0gMCx7ZS55MX0geiBtIHtlLngxfSwte2UueTJ9IHtlLngyfSwte2UueTN9IDAse2UueTF9IC17ZS54Mn0sLXtlLnkzfSB6JyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzYuNSwgMTMsIDAuNCwgNi4xXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFs5LCA5LjMsIDguN11cbiAgICB9LFxuICAgICdFVkVOVF9USU1FUl9XSCc6IHtcbiAgICAgIGQ6ICdNIHtteH0se215fSBsIHtlLngwfSwte2UueTB9IG0gLXtlLngwfSx7ZS55MH0gbCB7ZS54MX0se2UueTF9ICcsXG4gICAgICBoZWlnaHQ6IDM2LFxuICAgICAgd2lkdGg6ICAzNixcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbMTAsIDJdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzMsIDddXG4gICAgfSxcbiAgICAnRVZFTlRfVElNRVJfTElORSc6IHtcbiAgICAgIGQ6ICAnTSB7bXh9LHtteX0gJyArXG4gICAgICAgICAgJ20ge2UueDB9LHtlLnkwfSBsIC17ZS54MX0se2UueTF9ICcsXG4gICAgICBoZWlnaHQ6IDM2LFxuICAgICAgd2lkdGg6ICAzNixcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbMTAsIDNdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzAsIDBdXG4gICAgfSxcbiAgICAnRVZFTlRfTVVMVElQTEUnOiB7XG4gICAgICBkOidtIHtteH0se215fSB7ZS54MX0sLXtlLnkwfSB7ZS54MX0se2UueTB9IC17ZS54MH0se2UueTF9IC17ZS54Mn0sMCB6JyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogIDM2LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs2LjI4MDk5LCAxMi41NjE5OV0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMy4xNDA1LCA5LjQyMTQ5LCAxMi41NjE5OF1cbiAgICB9LFxuICAgICdFVkVOVF9QQVJBTExFTF9NVUxUSVBMRSc6IHtcbiAgICAgIGQ6J20ge214fSx7bXl9IHtlLngwfSwwIDAse2UueTF9IHtlLngxfSwwIDAse2UueTB9IC17ZS54MX0sMCAwLHtlLnkxfSAnICtcbiAgICAgICAgJy17ZS54MH0sMCAwLC17ZS55MX0gLXtlLngxfSwwIDAsLXtlLnkwfSB7ZS54MX0sMCB6JyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogIDM2LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFsyLjU2MjI4LCA3LjY4NjgzXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFsyLjU2MjI4LCA3LjY4NjgzXVxuICAgIH0sXG4gICAgJ0dBVEVXQVlfRVhDTFVTSVZFJzoge1xuICAgICAgZDonbSB7bXh9LHtteX0ge2UueDB9LHtlLnkwfSB7ZS54MX0se2UueTB9IHtlLngyfSwwIHtlLng0fSx7ZS55Mn0gJyArXG4gICAgICAgICAgICAgICAgICAgICd7ZS54NH0se2UueTF9IHtlLngyfSwwIHtlLngxfSx7ZS55M30ge2UueDB9LHtlLnkzfSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3tlLngzfSwwIHtlLng1fSx7ZS55MX0ge2UueDV9LHtlLnkyfSB7ZS54M30sMCB6JyxcbiAgICAgIGhlaWdodDogMTcuNSxcbiAgICAgIHdpZHRoOiAgMTcuNSxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbOC41LCA2LjUzMTIsIC02LjUzMTIsIC04LjVdLFxuICAgICAgd2lkdGhFbGVtZW50czogIFs2LjUsIC02LjUsIDMsIC0zLCA1LCAtNV1cbiAgICB9LFxuICAgICdHQVRFV0FZX1BBUkFMTEVMJzoge1xuICAgICAgZDonbSB7bXh9LHtteX0gMCx7ZS55MX0gLXtlLngxfSwwIDAse2UueTB9IHtlLngxfSwwIDAse2UueTF9IHtlLngwfSwwICcgK1xuICAgICAgICAnMCwte2UueTF9IHtlLngxfSwwIDAsLXtlLnkwfSAte2UueDF9LDAgMCwte2UueTF9IC17ZS54MH0sMCB6JyxcbiAgICAgIGhlaWdodDogMzAsXG4gICAgICB3aWR0aDogIDMwLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs1LCAxMi41XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFs1LCAxMi41XVxuICAgIH0sXG4gICAgJ0dBVEVXQVlfRVZFTlRfQkFTRUQnOiB7XG4gICAgICBkOidtIHtteH0se215fSB7ZS54MH0se2UueTB9IHtlLngwfSx7ZS55MX0ge2UueDF9LHtlLnkyfSB7ZS54Mn0sMCB6JyxcbiAgICAgIGhlaWdodDogMTEsXG4gICAgICB3aWR0aDogIDExLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFstNiwgNiwgMTIsIC0xMl0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbOSwgLTMsIC0xMl1cbiAgICB9LFxuICAgICdHQVRFV0FZX0NPTVBMRVgnOiB7XG4gICAgICBkOidtIHtteH0se215fSAwLHtlLnkwfSAte2UueDB9LC17ZS55MX0gLXtlLngxfSx7ZS55Mn0ge2UueDB9LHtlLnkxfSAte2UueDJ9LDAgMCx7ZS55M30gJyArXG4gICAgICAgICd7ZS54Mn0sMCAgLXtlLngwfSx7ZS55MX0gbCB7ZS54MX0se2UueTJ9IHtlLngwfSwte2UueTF9IDAse2UueTB9IHtlLngzfSwwIDAsLXtlLnkwfSB7ZS54MH0se2UueTF9ICcgK1xuICAgICAgICAne2UueDF9LC17ZS55Mn0gLXtlLngwfSwte2UueTF9IHtlLngyfSwwIDAsLXtlLnkzfSAte2UueDJ9LDAge2UueDB9LC17ZS55MX0gLXtlLngxfSwte2UueTJ9ICcgK1xuICAgICAgICAnLXtlLngwfSx7ZS55MX0gMCwte2UueTB9IC17ZS54M30sMCB6JyxcbiAgICAgIGhlaWdodDogMTcuMTI1LFxuICAgICAgd2lkdGg6ICAxNy4xMjUsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzQuODc1LCAzLjQzNzUsIDIuMTI1LCAzXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFszLjQzNzUsIDIuMTI1LCA0Ljg3NSwgM11cbiAgICB9LFxuICAgICdEQVRBX09CSkVDVF9QQVRIJzoge1xuICAgICAgZDonbSAwLDAge2UueDF9LDAge2UueDB9LHtlLnkwfSAwLHtlLnkxfSAte2UueDJ9LDAgMCwte2UueTJ9IHtlLngxfSwwIDAse2UueTB9IHtlLngwfSwwJyxcbiAgICAgIGhlaWdodDogNjEsXG4gICAgICB3aWR0aDogIDUxLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFsxMCwgNTAsIDYwXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFsxMCwgNDAsIDUwLCA2MF1cbiAgICB9LFxuICAgICdEQVRBX09CSkVDVF9DT0xMRUNUSU9OX1BBVEgnOiB7XG4gICAgICBkOidtIHtteH0sIHtteX0gJyArXG4gICAgICAgICdtICAwIDE1ICBsIDAgLTE1ICcgK1xuICAgICAgICAnbSAgNCAxNSAgbCAwIC0xNSAnICtcbiAgICAgICAgJ20gIDQgMTUgIGwgMCAtMTUgJyxcbiAgICAgIGhlaWdodDogNjEsXG4gICAgICB3aWR0aDogIDUxLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFsxMl0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMSwgNiwgMTIsIDE1XVxuICAgIH0sXG4gICAgJ0RBVEFfQVJST1cnOiB7XG4gICAgICBkOidtIDUsOSA5LDAgMCwtMyA1LDUgLTUsNSAwLC0zIC05LDAgeicsXG4gICAgICBoZWlnaHQ6IDYxLFxuICAgICAgd2lkdGg6ICA1MSxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFtdXG4gICAgfSxcbiAgICAnREFUQV9TVE9SRSc6IHtcbiAgICAgIGQ6J20gIHtteH0se215fSAnICtcbiAgICAgICAgJ2wgIDAse2UueTJ9ICcgK1xuICAgICAgICAnYyAge2UueDB9LHtlLnkxfSB7ZS54MX0se2UueTF9ICB7ZS54Mn0sMCAnICtcbiAgICAgICAgJ2wgIDAsLXtlLnkyfSAnICtcbiAgICAgICAgJ2MgLXtlLngwfSwte2UueTF9IC17ZS54MX0sLXtlLnkxfSAte2UueDJ9LDAnICtcbiAgICAgICAgJ2MgIHtlLngwfSx7ZS55MX0ge2UueDF9LHtlLnkxfSAge2UueDJ9LDAgJyArXG4gICAgICAgICdtICAte2UueDJ9LHtlLnkwfScgK1xuICAgICAgICAnYyAge2UueDB9LHtlLnkxfSB7ZS54MX0se2UueTF9IHtlLngyfSwwJyArXG4gICAgICAgICdtICAte2UueDJ9LHtlLnkwfScgK1xuICAgICAgICAnYyAge2UueDB9LHtlLnkxfSB7ZS54MX0se2UueTF9ICB7ZS54Mn0sMCcsXG4gICAgICBoZWlnaHQ6IDYxLFxuICAgICAgd2lkdGg6ICA2MSxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbNywgMTAsIDQ1XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6ICBbMiwgNTgsIDYwXVxuICAgIH0sXG4gICAgJ1RFWFRfQU5OT1RBVElPTic6IHtcbiAgICAgIGQ6ICdtIHtteH0sIHtteX0gbSAxMCwwIGwgLTEwLDAgbCAwLHtlLnkwfSBsIDEwLDAnLFxuICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgIHdpZHRoOiAxMCxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbMzBdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzEwXVxuICAgIH0sXG4gICAgJ01BUktFUl9TVUJfUFJPQ0VTUyc6IHtcbiAgICAgIGQ6ICdte214fSx7bXl9IG0gNywyIGwgMCwxMCBtIC01LC01IGwgMTAsMCcsXG4gICAgICBoZWlnaHQ6IDEwLFxuICAgICAgd2lkdGg6IDEwLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFtdLFxuICAgICAgd2lkdGhFbGVtZW50czogW11cbiAgICB9LFxuICAgICdNQVJLRVJfUEFSQUxMRUwnOiB7XG4gICAgICBkOiAnbXtteH0se215fSBtIDMsMiBsIDAsMTAgbSAzLC0xMCBsIDAsMTAgbSAzLC0xMCBsIDAsMTAnLFxuICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgIHdpZHRoOiAxMCxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFtdXG4gICAgfSxcbiAgICAnTUFSS0VSX1NFUVVFTlRJQUwnOiB7XG4gICAgICBkOiAnbXtteH0se215fSBtIDAsMyBsIDEwLDAgbSAtMTAsMyBsIDEwLDAgbSAtMTAsMyBsIDEwLDAnLFxuICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgIHdpZHRoOiAxMCxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFtdXG4gICAgfSxcbiAgICAnTUFSS0VSX0NPTVBFTlNBVElPTic6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSA3LC01IDAsMTAgeiBtIDcuMSwtMC4zIDYuOSwtNC43IDAsMTAgLTYuOSwtNC43IHonLFxuICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgIHdpZHRoOiAyMSxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFtdXG4gICAgfSxcbiAgICAnTUFSS0VSX0xPT1AnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gYyAzLjUyNjk3OSwwIDYuMzg2MTYxLC0yLjgyOTg1OCA2LjM4NjE2MSwtNi4zMjA2NjEgMCwtMy40OTA4MDYgLTIuODU5MTgyLC02LjMyMDY2MSAnICtcbiAgICAgICAgJy02LjM4NjE2MSwtNi4zMjA2NjEgLTMuNTI2OTc4LDAgLTYuMzg2MTYsMi44Mjk4NTUgLTYuMzg2MTYsNi4zMjA2NjEgMCwxLjc0NTQwMiAnICtcbiAgICAgICAgJzAuNzE0Nzk3LDMuMzI1NTY3IDEuODcwNDYzLDQuNDY5MzgxIDAuNTc3ODM0LDAuNTcxOTA4IDEuMjY1ODg1LDEuMDM0NzI4IDIuMDI5OTE2LDEuMzU0NTcgJyArXG4gICAgICAgICdsIC0wLjcxODE2MywtMy45MDk3OTMgbSAwLjcxODE2MywzLjkwOTc5MyAtMy44ODUyMTEsMC44MDI5MDInLFxuICAgICAgaGVpZ2h0OiAxMy45LFxuICAgICAgd2lkdGg6IDEzLjcsXG4gICAgICBoZWlnaHRFbGVtZW50czogW10sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbXVxuICAgIH0sXG4gICAgJ01BUktFUl9BREhPQyc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBtIDAuODQ0NjEsMi42NDQxMSBjIDEuMDU1MzMsLTEuMjM3ODA5OTYgMi42NDMzNywtMi4wNzg4MiA0LjI5NjUzLC0xLjk3OTk3OTk2IDIuMDUxNjMsMC4wODA1ICcgK1xuICAgICAgICAnMy44NTU3OSwxLjE1ODAzIDUuNzYwODIsMS43OTEwNyAxLjA2Mzg1LDAuMzQxMzk5OTYgMi4yNDQ1NCwwLjE0MzggMy4xODc1OSwtMC40Mzc2NyAwLjYxNzQzLC0wLjMzNjQyICcgK1xuICAgICAgICAnMS4yNzc1LC0wLjY0MDc4IDEuNzU0MiwtMS4xNzUxMSAwLDAuNTYwMjMgMCwxLjEyMDQ2IDAsMS42ODA3IC0wLjk4NzA2LDAuOTYyMzc5OTYgLTIuMjk3OTIsMS42MjM5Mzk5NiAnICtcbiAgICAgICAgJy0zLjY5MTgsMS42NjE4MTk5NiAtMS4yNDQ1OSwwLjA5MjcgLTIuNDY2NzEsLTAuMjQ5MSAtMy41OTUwNSwtMC43NDgxMiAtMS4zNTc4OSwtMC41NTk2NSAnICtcbiAgICAgICAgJy0yLjc1MTMzLC0xLjMzNDM2OTk2IC00LjI3MDI3LC0xLjE4MTIxOTk2IC0xLjM3NzQxLDAuMTQ2MDEgLTIuNDE4NDIsMS4xMzY4NTk5NiAtMy40NDI4OCwxLjk2NzgyOTk2IHonLFxuICAgICAgaGVpZ2h0OiA0LFxuICAgICAgd2lkdGg6IDE1LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFtdLFxuICAgICAgd2lkdGhFbGVtZW50czogW11cbiAgICB9LFxuICAgICdUQVNLX1RZUEVfU0VORCc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBsIDAse2UueTF9IGwge2UueDF9LDAgbCAwLC17ZS55MX0geiBsIHtlLngwfSx7ZS55MH0gbCB7ZS54MH0sLXtlLnkwfScsXG4gICAgICBoZWlnaHQ6IDE0LFxuICAgICAgd2lkdGg6ICAyMSxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbNiwgMTRdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzEwLjUsIDIxXVxuICAgIH0sXG4gICAgJ1RBU0tfVFlQRV9TQ1JJUFQnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gYyA5Ljk2NjU1MywtNi4yNzI3NiAtOC4wMDA5MjYsLTcuOTE5MzIgMi45Njg5NjgsLTE0LjkzOCBsIC04LjgwMjcyOCwwICcgK1xuICAgICAgICAnYyAtMTAuOTY5ODk0LDcuMDE4NjggNi45OTc1ODUsOC42NjUyNCAtMi45Njg5NjcsMTQuOTM4IHogJyArXG4gICAgICAgICdtIC03LC0xMiBsIDUsMCAnICtcbiAgICAgICAgJ20gLTQuNSwzIGwgNC41LDAgJyArXG4gICAgICAgICdtIC0zLDMgbCA1LDAnICtcbiAgICAgICAgJ20gLTQsMyBsIDUsMCcsXG4gICAgICBoZWlnaHQ6IDE1LFxuICAgICAgd2lkdGg6ICAxMi42LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs2LCAxNF0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMTAuNSwgMjFdXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX1VTRVJfMSc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBjIDAuOTA5LC0wLjg0NSAxLjU5NCwtMi4wNDkgMS41OTQsLTMuMzg1IDAsLTIuNTU0IC0xLjgwNSwtNC42MjE5OTk5OSAnICtcbiAgICAgICAgJy00LjM1NywtNC42MjE5OTk5OSAtMi41NTE5OTk5OCwwIC00LjI4Nzk5OTk4LDIuMDY3OTk5OTkgLTQuMjg3OTk5OTgsNC42MjE5OTk5OSAwLDEuMzQ4ICcgK1xuICAgICAgICAnMC45NzQsMi41NjIgMS44OTU5OTk5OCwzLjQwNSAtMC41Mjg5OTk5OCwwLjE4NyAtNS42NjksMi4wOTcgLTUuNzk0LDQuNzU2MDAwNSB2IDYuNzE4ICcgK1xuICAgICAgICAnaCAxNyB2IC02LjcxOCBjIDAsLTIuMjk4MDAwNSAtNS41Mjc5OTk2LC00LjU5NTAwMDUgLTYuMDUwOTk5NiwtNC43NzYwMDA1IHonICtcbiAgICAgICAgJ20gLTgsNiBsIDAsNS41IG0gMTEsMCBsIDAsLTUnXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX1VTRVJfMic6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBtIDIuMTYyLDEuMDA5IGMgMCwyLjQ0NzAwMDUgLTIuMTU4LDQuNDMxMDAwNSAtNC44MjEsNC40MzEwMDA1ICcgK1xuICAgICAgICAnLTIuNjY0OTk5OTgsMCAtNC44MjIsLTEuOTgxIC00LjgyMiwtNC40MzEwMDA1ICdcbiAgICB9LFxuICAgICdUQVNLX1RZUEVfVVNFUl8zJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IG0gLTYuOSwtMy44MCBjIDAsMCAyLjI1MDk5OTk4LC0yLjM1OCA0LjI3Mzk5OTk4LC0xLjE3NyAyLjAyNCwxLjE4MSA0LjIyMSwxLjUzNyAnICtcbiAgICAgICAgJzQuMTI0LDAuOTY1IC0wLjA5OCwtMC41NyAtMC4xMTcsLTMuNzkwOTk5OTkgLTQuMTkxLC00LjEzNTk5OTk5IC0zLjU3NDk5OTk4LDAuMDAxICcgK1xuICAgICAgICAnLTQuMjA3OTk5OTgsMy4zNjY5OTk5OSAtNC4yMDY5OTk5OCw0LjM0Nzk5OTk5IHonXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX01BTlVBTCc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBjIDAuMjM0LC0wLjAxIDUuNjA0LDAuMDA4IDguMDI5LDAuMDA0IDAuODA4LDAgMS4yNzEsLTAuMTcyIDEuNDE3LC0wLjc1MiAwLjIyNywtMC44OTggJyArXG4gICAgICAgICctMC4zMzQsLTEuMzE0IC0xLjMzOCwtMS4zMTYgLTIuNDY3LC0wLjAxIC03Ljg4NiwtMC4wMDQgLTguMTA4LC0wLjAwNCAtMC4wMTQsLTAuMDc5IDAuMDE2LC0wLjUzMyAwLC0wLjYxICcgK1xuICAgICAgICAnMC4xOTUsLTAuMDQyIDguNTA3LDAuMDA2IDkuNjE2LDAuMDAyIDAuODc3LC0wLjAwNyAxLjM1LC0wLjQzOCAxLjM1MywtMS4yMDggMC4wMDMsLTAuNzY4IC0wLjQ3OSwtMS4wOSAnICtcbiAgICAgICAgJy0xLjM1LC0xLjA5MSAtMi45NjgsLTAuMDAyIC05LjYxOSwtMC4wMTMgLTkuNjE5LC0wLjAxMyB2IC0wLjU5MSBjIDAsMCA1LjA1MiwtMC4wMTYgNy4yMjUsLTAuMDE2ICcgK1xuICAgICAgICAnMC44ODgsLTAuMDAyIDEuMzU0LC0wLjQxNiAxLjM1MSwtMS4xOTMgLTAuMDA2LC0wLjc2MSAtMC40OTIsLTEuMTk2IC0xLjM2MSwtMS4xOTYgLTMuNDczLC0wLjAwNSAnICtcbiAgICAgICAgJy0xMC44NiwtMC4wMDMgLTExLjA4Mjk5OTUsLTAuMDAzIC0wLjAyMiwtMC4wNDcgLTAuMDQ1LC0wLjA5NCAtMC4wNjksLTAuMTM5IDAuMzkzOTk5NSwtMC4zMTkgJyArXG4gICAgICAgICcyLjA0MDk5OTUsLTEuNjI2IDIuNDE0OTk5NSwtMi4wMTcgMC40NjksLTAuNDg3MDAwNSAwLjUxOSwtMS4xNjUwMDA1IDAuMTYyLC0xLjYwNDAwMDUgLTAuNDE0LC0wLjUxMSAnICtcbiAgICAgICAgJy0wLjk3MywtMC41IC0xLjQ4LC0wLjIzNiAtMS40NjA5OTk1LDAuNzY0IC02LjU5OTk5OTUsMy42NDMwMDA1IC03LjczMjk5OTUsNC4yNzEwMDA1IC0wLjksMC40OTkgJyArXG4gICAgICAgICctMS41MTYsMS4yNTMgLTEuODgyLDIuMTkgLTAuMzcwMDAwMDIsMC45NSAtMC4xNywyLjAxIC0wLjE2NiwyLjk3OSAwLjAwNCwwLjcxOCAtMC4yNzMwMDAwMiwxLjM0NSAnICtcbiAgICAgICAgJy0wLjA1NSwyLjA2MyAwLjYyOSwyLjA4NyAyLjQyNSwzLjMxMiA0Ljg1OSwzLjMxOCA0LjYxNzk5OTUsMC4wMTQgOS4yMzc5OTk1LC0wLjEzOSAxMy44NTY5OTk1LC0wLjE1OCAnICtcbiAgICAgICAgJzAuNzU1LC0wLjAwNCAxLjE3MSwtMC4zMDEgMS4xODIsLTEuMDMzIDAuMDEyLC0wLjc1NCAtMC40MjMsLTAuOTY5IC0xLjE4MywtMC45NzMgLTEuNzc4LC0wLjAxICcgK1xuICAgICAgICAnLTUuODI0LC0wLjAwNCAtNi4wNCwtMC4wMDQgMTBlLTQsLTAuMDg0IDAuMDAzLC0wLjU4NiAxMGUtNCwtMC42NyB6J1xuICAgIH0sXG4gICAgJ1RBU0tfVFlQRV9JTlNUQU5USUFUSU5HX1NFTkQnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gbCAwLDguNCBsIDEyLjYsMCBsIDAsLTguNCB6IGwgNi4zLDMuNiBsIDYuMywtMy42J1xuICAgIH0sXG4gICAgJ1RBU0tfVFlQRV9TRVJWSUNFJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IHYgLTEuNzEzMzUgYyAwLjM1MjMyNiwtMC4wNzA1IDAuNzAzOTMyLC0wLjE3ODM4IDEuMDQ3NjI4LC0wLjMyMTMzICcgK1xuICAgICAgICAnMC4zNDQ0MTYsLTAuMTQ0NjUgMC42NjU4MjIsLTAuMzIxMzMgMC45NjYzNzcsLTAuNTIxNDUgbCAxLjE5NDMxLDEuMTgwMDUgMS41Njc0ODcsLTEuNTc2ODggJyArXG4gICAgICAgICctMS4xOTUwMjgsLTEuMTgwMTQgYyAwLjQwMzM3NiwtMC42MTM5NCAwLjY4MzA3OSwtMS4yOTkwOCAwLjgyNTQ0NywtMi4wMTgyNCBsIDEuNjIyMTMzLC0wLjAxICcgK1xuICAgICAgICAndiAtMi4yMTk2IGwgLTEuNjM2NTE0LDAuMDEgYyAtMC4wNzMzMywtMC4zNTE1MyAtMC4xNzgzMTksLTAuNzAwMjQgLTAuMzIzNTY0LC0xLjA0MzcyICcgK1xuICAgICAgICAnLTAuMTQ1MjQ0LC0wLjM0NDA2IC0wLjMyMTQwNywtMC42NjQ0IC0wLjUyMjczNSwtMC45NjIxNyBsIDEuMTMxMDM1LC0xLjEzNjMxIC0xLjU4MzMwNSwtMS41NjI5MyAnICtcbiAgICAgICAgJy0xLjEyOTU5OCwxLjEzNTg5IGMgLTAuNjE0MDUyLC0wLjQwMTA4IC0xLjMwMjg4MywtMC42ODA5MyAtMi4wMjI2MzMsLTAuODIyNDcgbCAwLjAwOTMsLTEuNjE4NTIgJyArXG4gICAgICAgICdoIC0yLjI0MTE3MyBsIDAuMDA0MiwxLjYzMTI0IGMgLTAuMzUzNzYzLDAuMDczNiAtMC43MDUzNjksMC4xNzk3NyAtMS4wNDk3ODUsMC4zMjM3MSAtMC4zNDQ0MTUsMC4xNDQzNyAnICtcbiAgICAgICAgJy0wLjY2NTEwMiwwLjMyMDkyIC0wLjk2MzUwMDYsMC41MjA0NiBsIC0xLjE2OTg2MjgsLTEuMTU4MjMgLTEuNTY2NzY5MSwxLjU3OTIgMS4xNjg0MjY1LDEuMTU2NjkgJyArXG4gICAgICAgICdjIC0wLjQwMjY1NzMsMC42MTI4MyAtMC42ODMwOCwxLjI5Nzk3IC0wLjgyNDcyODcsMi4wMTcxMyBsIC0xLjY1ODgwNDEsMC4wMDMgdiAyLjIyMTc0ICcgK1xuICAgICAgICAnbCAxLjY3MjQ2NDgsLTAuMDA2IGMgMC4wNzMzMjcsMC4zNTA3NyAwLjE3OTc1OTgsMC43MDI0MyAwLjMyNDI4NTEsMS4wNDQ3MiAwLjE0NTI0MjgsMC4zNDQ0OCAnICtcbiAgICAgICAgJzAuMzIxNDA2NCwwLjY2NDQgMC41MjI3MzM5LDAuOTYwNjYgbCAtMS4xOTkzNDMxLDEuMTk3MjMgMS41ODQwMjU2LDEuNTYwMTEgMS4xOTY0NjY4LC0xLjE5MzQ4ICcgK1xuICAgICAgICAnYyAwLjYxNDA1MTcsMC40MDM0NiAxLjMwMjg4MjcsMC42ODIzMiAyLjAyMzM1MTcsMC44MjMzMSBsIDcuMTllLTQsMS42OTg5MiBoIDIuMjI2ODQ4IHogJyArXG4gICAgICAgICdtIDAuMjIxNDYyLC0zLjk5NTcgYyAtMS43ODg5NDgsMC43NTAyIC0zLjg1NzYsLTAuMDkyOCAtNC42MDk3MDU1LC0xLjg3NDM4IC0wLjc1MjEwNjUsLTEuNzgzMjEgJyArXG4gICAgICAgICcwLjA5MDU5OCwtMy44NDYyNyAxLjg4MDI2NDUsLTQuNTk2MDQgMS43ODgyMywtMC43NDkzNiAzLjg1Njg4MSwwLjA5MjkgNC42MDg5ODcsMS44NzQzNyAnICtcbiAgICAgICAgJzAuNzUyMTA2LDEuNzgxNjUgLTAuMDkwNiwzLjg0NjEyIC0xLjg3OTU0Niw0LjU5NjA1IHonXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX1NFUlZJQ0VfRklMTCc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBjIC0xLjc4ODk0OCwwLjc1MDIgLTMuODU3NiwtMC4wOTI4IC00LjYwOTcwNTUsLTEuODc0MzggLTAuNzUyMTA2NSwtMS43ODMyMSAnICtcbiAgICAgICAgJzAuMDkwNTk4LC0zLjg0NjI3IDEuODgwMjY0NSwtNC41OTYwNCAxLjc4ODIzLC0wLjc0OTM2IDMuODU2ODgxLDAuMDkyOSA0LjYwODk4NywxLjg3NDM3ICcgK1xuICAgICAgICAnMC43NTIxMDYsMS43ODE2NSAtMC4wOTA2LDMuODQ2MTIgLTEuODc5NTQ2LDQuNTk2MDUgeidcbiAgICB9LFxuICAgICdUQVNLX1RZUEVfQlVTSU5FU1NfUlVMRV9IRUFERVInOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gMCw0IDIwLDAgMCwtNCB6J1xuICAgIH0sXG4gICAgJ1RBU0tfVFlQRV9CVVNJTkVTU19SVUxFX01BSU4nOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gMCwxMiAyMCwwIDAsLTEyIHonICtcbiAgICAgICAgJ20gMCw4IGwgMjAsMCAnICtcbiAgICAgICAgJ20gLTEzLC00IGwgMCw4J1xuICAgIH0sXG4gICAgJ01FU1NBR0VfRkxPV19NQVJLRVInOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gbSAtMTAuNSAsLTcgbCAwLDE0IGwgMjEsMCBsIDAsLTE0IHogbCAxMC41LDYgbCAxMC41LC02J1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmdldFJhd1BhdGggPSBmdW5jdGlvbiBnZXRSYXdQYXRoKHBhdGhJZCkge1xuICAgIHJldHVybiB0aGlzLnBhdGhNYXBbcGF0aElkXS5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTY2FsZXMgdGhlIHBhdGggdG8gdGhlIGdpdmVuIGhlaWdodCBhbmQgd2lkdGguXG4gICAqIDxoMT5Vc2UgY2FzZTwvaDE+XG4gICAqIDxwPlVzZSBjYXNlIGlzIHRvIHNjYWxlIHRoZSBjb250ZW50IG9mIGVsZW1lbnRzIChldmVudCwgZ2F0ZXdheXMpIGJhc2VkXG4gICAqIG9uIHRoZSBlbGVtZW50IGJvdW5kaW5nIGJveCdzIHNpemUuXG4gICAqIDwvcD5cbiAgICogPGgxPldoeSBub3QgdHJhbnNmb3JtPC9oMT5cbiAgICogPHA+U2NhbGluZyBhIHBhdGggd2l0aCB0cmFuc2Zvcm0oKSB3aWxsIGFsc28gc2NhbGUgdGhlIHN0cm9rZSBhbmQgSUUgZG9lcyBub3Qgc3VwcG9ydFxuICAgKiB0aGUgb3B0aW9uICdub24tc2NhbGluZy1zdHJva2UnIHRvIHByZXZlbnQgdGhpcy5cbiAgICogQWxzbyB0aGVyZSBhcmUgdXNlIGNhc2VzIHdoZXJlIG9ubHkgc29tZSBwYXJ0cyBvZiBhIHBhdGggc2hvdWxkIGJlXG4gICAqIHNjYWxlZC48L3A+XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoSWQgVGhlIElEIG9mIHRoZSBwYXRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gPHA+XG4gICAqICAgRXhhbXBsZSBwYXJhbSBvYmplY3Qgc2NhbGVzIHRoZSBwYXRoIHRvIDYwJSBzaXplIG9mIHRoZSBjb250YWluZXIgKGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0KS5cbiAgICogICA8cHJlPlxuICAgKiAgIHtcbiAgICogICAgIHhTY2FsZUZhY3RvcjogMC42LFxuICAgKiAgICAgeVNjYWxlRmFjdG9yOjAuNixcbiAgICogICAgIGNvbnRhaW5lcldpZHRoOiBkYXRhLndpZHRoLFxuICAgKiAgICAgY29udGFpbmVySGVpZ2h0OiBkYXRhLmhlaWdodCxcbiAgICogICAgIHBvc2l0aW9uOiB7XG4gICAqICAgICAgIG14OiAwLjQ2LFxuICAgKiAgICAgICBteTogMC4yLFxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogICA8L3ByZT5cbiAgICogICA8dWw+XG4gICAqICAgIDxsaT50YXJnZXRwYXRod2lkdGggPSB4U2NhbGVGYWN0b3IgKiBjb250YWluZXJXaWR0aDwvbGk+XG4gICAqICAgIDxsaT50YXJnZXRwYXRoaGVpZ2h0ID0geVNjYWxlRmFjdG9yICogY29udGFpbmVySGVpZ2h0PC9saT5cbiAgICogICAgPGxpPlBvc2l0aW9uIGlzIHVzZWQgdG8gc2V0IHRoZSBzdGFydGluZyBjb29yZGluYXRlIG9mIHRoZSBwYXRoLiBNIGlzIGNvbXB1dGVkOlxuICAgICogICAgPHVsPlxuICAgICogICAgICA8bGk+cG9zaXRpb24ueCAqIGNvbnRhaW5lcldpZHRoPC9saT5cbiAgICAqICAgICAgPGxpPnBvc2l0aW9uLnkgKiBjb250YWluZXJIZWlnaHQ8L2xpPlxuICAgICogICAgPC91bD5cbiAgICAqICAgIENlbnRlciBvZiB0aGUgY29udGFpbmVyIDxwcmU+IHBvc2l0aW9uOiB7XG4gICAqICAgICAgIG14OiAwLjUsXG4gICAqICAgICAgIG15OiAwLjUsXG4gICAqICAgICB9PC9wcmU+XG4gICAqICAgICBVcHBlciBsZWZ0IGNvcm5lciBvZiB0aGUgY29udGFpbmVyXG4gICAqICAgICA8cHJlPiBwb3NpdGlvbjoge1xuICAgKiAgICAgICBteDogMC4wLFxuICAgKiAgICAgICBteTogMC4wLFxuICAgKiAgICAgfTwvcHJlPlxuICAgKiAgICA8L2xpPlxuICAgKiAgIDwvdWw+XG4gICAqIDwvcD5cbiAgICpcbiAgICovXG4gIHRoaXMuZ2V0U2NhbGVkUGF0aCA9IGZ1bmN0aW9uIGdldFNjYWxlZFBhdGgocGF0aElkLCBwYXJhbSkge1xuICAgIHZhciByYXdQYXRoID0gdGhpcy5wYXRoTWFwW3BhdGhJZF07XG5cbiAgICAvLyBwb3NpdGlvbmluZ1xuICAgIC8vIGNvbXB1dGUgdGhlIHN0YXJ0IHBvaW50IG9mIHRoZSBwYXRoXG4gICAgdmFyIG14LCBteTtcblxuICAgIGlmIChwYXJhbS5hYnNwb3MpIHtcbiAgICAgIG14ID0gcGFyYW0uYWJzcG9zLng7XG4gICAgICBteSA9IHBhcmFtLmFic3Bvcy55O1xuICAgIH0gZWxzZSB7XG4gICAgICBteCA9IHBhcmFtLmNvbnRhaW5lcldpZHRoICogcGFyYW0ucG9zaXRpb24ubXg7XG4gICAgICBteSA9IHBhcmFtLmNvbnRhaW5lckhlaWdodCAqIHBhcmFtLnBvc2l0aW9uLm15O1xuICAgIH1cblxuICAgIHZhciBjb29yZGluYXRlcyA9IHt9OyAvLyBtYXAgZm9yIHRoZSBzY2FsZWQgY29vcmRpbmF0ZXNcbiAgICBpZiAocGFyYW0ucG9zaXRpb24pIHtcblxuICAgICAgLy8gcGF0aFxuICAgICAgdmFyIGhlaWdodFJhdGlvID0gKHBhcmFtLmNvbnRhaW5lckhlaWdodCAvIHJhd1BhdGguaGVpZ2h0KSAqIHBhcmFtLnlTY2FsZUZhY3RvcjtcbiAgICAgIHZhciB3aWR0aFJhdGlvID0gKHBhcmFtLmNvbnRhaW5lcldpZHRoIC8gcmF3UGF0aC53aWR0aCkgKiBwYXJhbS54U2NhbGVGYWN0b3I7XG5cblxuICAgICAgLy8gQXBwbHkgaGVpZ2h0IHJhdGlvXG4gICAgICBmb3IgKHZhciBoZWlnaHRJbmRleCA9IDA7IGhlaWdodEluZGV4IDwgcmF3UGF0aC5oZWlnaHRFbGVtZW50cy5sZW5ndGg7IGhlaWdodEluZGV4KyspIHtcbiAgICAgICAgY29vcmRpbmF0ZXNbJ3knICsgaGVpZ2h0SW5kZXhdID0gcmF3UGF0aC5oZWlnaHRFbGVtZW50c1toZWlnaHRJbmRleF0gKiBoZWlnaHRSYXRpbztcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgd2lkdGggcmF0aW9cbiAgICAgIGZvciAodmFyIHdpZHRoSW5kZXggPSAwOyB3aWR0aEluZGV4IDwgcmF3UGF0aC53aWR0aEVsZW1lbnRzLmxlbmd0aDsgd2lkdGhJbmRleCsrKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzWyd4JyArIHdpZHRoSW5kZXhdID0gcmF3UGF0aC53aWR0aEVsZW1lbnRzW3dpZHRoSW5kZXhdICogd2lkdGhSYXRpbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSB2YWx1ZSB0byByYXcgcGF0aFxuICAgIHZhciBwYXRoID0gZm9ybWF0KFxuICAgICAgcmF3UGF0aC5kLCB7XG4gICAgICAgIG14OiBteCxcbiAgICAgICAgbXk6IG15LFxuICAgICAgICBlOiBjb29yZGluYXRlc1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG59XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUtd2VicGxhdGZvcm0vU25hcC5zdmcvYmxvYi9tYXN0ZXIvc3JjL3N2Zy5qc1xudmFyIHRva2VuUmVnZXggPSAvXFx7KFtefV0rKVxcfS9nLFxuICAgIG9iak5vdGF0aW9uUmVnZXggPSAvKD86KD86XnxcXC4pKC4rPykoPz1cXFt8XFwufCR8XFwoKXxcXFsoJ3xcIikoLis/KVxcMlxcXSkoXFwoXFwpKT8vZzsgLy8gbWF0Y2hlcyAueHh4eHggb3IgW1wieHh4eHhcIl0gdG8gcnVuIG92ZXIgb2JqZWN0IHByb3BlcnRpZXNcblxuZnVuY3Rpb24gcmVwbGFjZXIoYWxsLCBrZXksIG9iaikge1xuICB2YXIgcmVzID0gb2JqO1xuICBrZXkucmVwbGFjZShvYmpOb3RhdGlvblJlZ2V4LCBmdW5jdGlvbihhbGwsIG5hbWUsIHF1b3RlLCBxdW90ZWROYW1lLCBpc0Z1bmMpIHtcbiAgICBuYW1lID0gbmFtZSB8fCBxdW90ZWROYW1lO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGlmIChuYW1lIGluIHJlcykge1xuICAgICAgICByZXMgPSByZXNbbmFtZV07XG4gICAgICB9XG4gICAgICB0eXBlb2YgcmVzID09ICdmdW5jdGlvbicgJiYgaXNGdW5jICYmIChyZXMgPSByZXMoKSk7XG4gICAgfVxuICB9KTtcbiAgcmVzID0gKHJlcyA9PSBudWxsIHx8IHJlcyA9PSBvYmogPyBhbGwgOiByZXMpICsgJyc7XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZm9ybWF0KHN0ciwgb2JqKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHRva2VuUmVnZXgsIGZ1bmN0aW9uKGFsbCwga2V5KSB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKGFsbCwga2V5LCBvYmopO1xuICB9KTtcbn1cbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCB7XG4gIGlzT2JqZWN0LFxuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXG4gIGNsYXNzZXMgYXMgc3ZnQ2xhc3Nlc1xufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCBCYXNlUmVuZGVyZXIgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZHJhdy9CYXNlUmVuZGVyZXInO1xuXG5pbXBvcnQge1xuICBnZXRMYWJlbFxufSBmcm9tICcuLi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL0xhYmVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldEJ1c2luZXNzT2JqZWN0LFxuICBpc1xufSBmcm9tICcuLi91dGlsL01vZGVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldFNlbWFudGljLFxuICBnZXRSZWN0UGF0aCxcbiAgZ2V0RmlsbENvbG9yLFxuICBnZXRTdHJva2VDb2xvclxufSBmcm9tICcuL1Bvc3RpdFJlbmRlcmVyVXRpbCc7XG5cbnZhciBERUZBVUxUX0ZJTExfT1BBQ0lUWSA9IC45NTtcblxudmFyIFRBU0tfQk9SREVSX1JBRElVUyA9IDEwO1xuXG52YXIgREVGQVVMVF9URVhUX1NJWkUgPSAxNjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0UmVuZGVyZXIoXG4gICAgY29uZmlnLCBldmVudEJ1cywgc3R5bGVzLCBwYXRoTWFwLFxuICAgIGNhbnZhcywgdGV4dFJlbmRlcmVyLCBwcmlvcml0eSkge1xuXG4gIEJhc2VSZW5kZXJlci5jYWxsKHRoaXMsIGV2ZW50QnVzLCBwcmlvcml0eSk7XG5cbiAgdmFyIGRlZmF1bHRGaWxsQ29sb3IgPSBjb25maWcgJiYgY29uZmlnLmRlZmF1bHRGaWxsQ29sb3IsXG4gICAgICBkZWZhdWx0U3Ryb2tlQ29sb3IgPSBjb25maWcgJiYgY29uZmlnLmRlZmF1bHRTdHJva2VDb2xvcjtcblxuICB2YXIgY29tcHV0ZVN0eWxlID0gc3R5bGVzLmNvbXB1dGVTdHlsZTtcblxuICBmdW5jdGlvbiBkcmF3Q2lyY2xlKHBhcmVudEdmeCwgd2lkdGgsIGhlaWdodCwgb2Zmc2V0LCBhdHRycykge1xuXG4gICAgaWYgKGlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICAgIGF0dHJzID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGF0dHJzID0gY29tcHV0ZVN0eWxlKGF0dHJzLCB7XG4gICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgIGZpbGw6ICd3aGl0ZSdcbiAgICB9KTtcblxuICAgIGlmIChhdHRycy5maWxsID09PSAnbm9uZScpIHtcbiAgICAgIGRlbGV0ZSBhdHRycy5maWxsT3BhY2l0eTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSB3aWR0aCAvIDIsXG4gICAgICAgIGN5ID0gaGVpZ2h0IC8gMjtcblxuICAgIHZhciBjaXJjbGUgPSBzdmdDcmVhdGUoJ2NpcmNsZScpO1xuICAgIHN2Z0F0dHIoY2lyY2xlLCB7XG4gICAgICBjeDogY3gsXG4gICAgICBjeTogY3ksXG4gICAgICByOiBNYXRoLnJvdW5kKCh3aWR0aCArIGhlaWdodCkgLyA0IC0gb2Zmc2V0KVxuICAgIH0pO1xuICAgIHN2Z0F0dHIoY2lyY2xlLCBhdHRycyk7XG5cbiAgICBzdmdBcHBlbmQocGFyZW50R2Z4LCBjaXJjbGUpO1xuXG4gICAgcmV0dXJuIGNpcmNsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXdSZWN0KHBhcmVudEdmeCwgd2lkdGgsIGhlaWdodCwgciwgb2Zmc2V0LCBhdHRycykge1xuXG4gICAgaWYgKGlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICAgIGF0dHJzID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGF0dHJzID0gY29tcHV0ZVN0eWxlKGF0dHJzLCB7XG4gICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgIGZpbGw6ICd3aGl0ZSdcbiAgICB9KTtcblxuICAgIHZhciByZWN0ID0gc3ZnQ3JlYXRlKCdyZWN0Jyk7XG4gICAgc3ZnQXR0cihyZWN0LCB7XG4gICAgICB4OiBvZmZzZXQsXG4gICAgICB5OiBvZmZzZXQsXG4gICAgICB3aWR0aDogd2lkdGggLSBvZmZzZXQgKiAyLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgLSBvZmZzZXQgKiAyLFxuICAgICAgcng6IHIsXG4gICAgICByeTogclxuICAgIH0pO1xuICAgIHN2Z0F0dHIocmVjdCwgYXR0cnMpO1xuXG4gICAgc3ZnQXBwZW5kKHBhcmVudEdmeCwgcmVjdCk7XG5cbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXdQYXRoKHBhcmVudEdmeCwgZCwgYXR0cnMpIHtcblxuICAgIGF0dHJzID0gY29tcHV0ZVN0eWxlKGF0dHJzLCBbICduby1maWxsJyBdLCB7XG4gICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgIHN0cm9rZTogJ2JsYWNrJ1xuICAgIH0pO1xuXG4gICAgdmFyIHBhdGggPSBzdmdDcmVhdGUoJ3BhdGgnKTtcbiAgICBzdmdBdHRyKHBhdGgsIHsgZDogZCB9KTtcbiAgICBzdmdBdHRyKHBhdGgsIGF0dHJzKTtcblxuICAgIHN2Z0FwcGVuZChwYXJlbnRHZngsIHBhdGgpO1xuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHJlbmRlckxhYmVsKHBhcmVudEdmeCwgbGFiZWwsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBhc3NpZ24oe1xuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aDogMTAwXG4gICAgICB9XG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgdGV4dCA9IHRleHRSZW5kZXJlci5jcmVhdGVUZXh0KGxhYmVsIHx8ICcnLCBvcHRpb25zKTtcblxuICAgIHN2Z0NsYXNzZXModGV4dCkuYWRkKCdkanMtbGFiZWwnKTtcblxuICAgIHN2Z0FwcGVuZChwYXJlbnRHZngsIHRleHQpO1xuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJFbWJlZGRlZExhYmVsKHBhcmVudEdmeCwgZWxlbWVudCwgYWxpZ24sIGZvbnRTaXplKSB7XG4gICAgdmFyIHNlbWFudGljID0gZ2V0U2VtYW50aWMoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gcmVuZGVyTGFiZWwocGFyZW50R2Z4LCBzZW1hbnRpYy5uYW1lLCB7XG4gICAgICBib3g6IGVsZW1lbnQsXG4gICAgICBhbGlnbjogYWxpZ24sXG4gICAgICBwYWRkaW5nOiA1LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogZ2V0Q29sb3IoZWxlbWVudCkgPT09ICdibGFjaycgPyAnd2hpdGUnIDogJ2JsYWNrJyxcbiAgICAgICAgZm9udFNpemU6IGZvbnRTaXplIHx8IERFRkFVTFRfVEVYVF9TSVpFXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyRXh0ZXJuYWxMYWJlbChwYXJlbnRHZngsIGVsZW1lbnQpIHtcblxuICAgIHZhciBib3ggPSB7XG4gICAgICB3aWR0aDogOTAsXG4gICAgICBoZWlnaHQ6IDMwLFxuICAgICAgeDogZWxlbWVudC53aWR0aCAvIDIgKyBlbGVtZW50LngsXG4gICAgICB5OiBlbGVtZW50LmhlaWdodCAvIDIgKyBlbGVtZW50LnlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlbmRlckxhYmVsKHBhcmVudEdmeCwgZ2V0TGFiZWwoZWxlbWVudCksIHtcbiAgICAgIGJveDogYm94LFxuICAgICAgZml0Qm94OiB0cnVlLFxuICAgICAgc3R5bGU6IGFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIHRleHRSZW5kZXJlci5nZXRFeHRlcm5hbFN0eWxlKCksXG4gICAgICAgIHtcbiAgICAgICAgICBmaWxsOiAnYmxhY2snXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuaGFuZGxlcnMgPSB7XG4gICAgJ3Bvc3RpdDpTcXVhcmVQb3N0aXQnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcblxuICAgICAgdmFyIGF0dHJzID0ge1xuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfTtcblxuICAgICAgaWYgKCEoJ2ZpbGxPcGFjaXR5JyBpbiBhdHRycykpIHtcbiAgICAgICAgYXR0cnMuZmlsbE9wYWNpdHkgPSBERUZBVUxUX0ZJTExfT1BBQ0lUWTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY3QgPSBkcmF3UmVjdChwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCAwLCBhdHRycyk7XG5cbiAgICAgIHJlbmRlckVtYmVkZGVkTGFiZWwocGFyZW50R2Z4LCBlbGVtZW50LCAnY2VudGVyLW1pZGRsZScpO1xuXG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9LFxuXG4gICAgJ3Bvc3RpdDpHcm91cCc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuXG4gICAgICB2YXIgZ3JvdXAgPSBkcmF3UmVjdChwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCBUQVNLX0JPUkRFUl9SQURJVVMsIHtcbiAgICAgICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnOCwzLDEsMycsXG4gICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0sXG5cbiAgICAncG9zdGl0OkNpcmNsZVBvc3RpdCc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIGF0dHJzID0ge1xuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfTtcblxuICAgICAgaWYgKCEoJ2ZpbGxPcGFjaXR5JyBpbiBhdHRycykpIHtcbiAgICAgICAgYXR0cnMuZmlsbE9wYWNpdHkgPSBERUZBVUxUX0ZJTExfT1BBQ0lUWTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY3QgPSBkcmF3Q2lyY2xlKHBhcmVudEdmeCwgZWxlbWVudC53aWR0aCwgZWxlbWVudC5oZWlnaHQsIGF0dHJzKTtcblxuICAgICAgcmVuZGVyRW1iZWRkZWRMYWJlbChwYXJlbnRHZngsIGVsZW1lbnQsICdjZW50ZXItbWlkZGxlJyk7XG5cbiAgICAgIHJldHVybiByZWN0O1xuICAgIH0sXG4gICAgJ3Bvc3RpdDpUZXh0Qm94JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG4gICAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgc3Ryb2tlOiAnbm9uZSdcbiAgICAgIH07XG5cbiAgICAgIHZhciB0ZXh0U2l6ZSA9IGVsZW1lbnQudGV4dFNpemUgfHwgREVGQVVMVF9URVhUX1NJWkU7XG5cbiAgICAgIHZhciByZWN0ID0gZHJhd1JlY3QocGFyZW50R2Z4LCBlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCwgMCwgYXR0cnMpO1xuXG4gICAgICByZW5kZXJFbWJlZGRlZExhYmVsKHBhcmVudEdmeCwgZWxlbWVudCwgJ2NlbnRlci1taWRkbGUnLCB0ZXh0U2l6ZSk7XG5cbiAgICAgIHJldHVybiByZWN0O1xuICAgIH0sXG4gICAgJ3Bvc3RpdDpJbWFnZSc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIGltYWdlU291cmNlID0gZ2V0SW1hZ2VTb3VyY2UoZWxlbWVudCk7XG5cbiAgICAgIHZhciBnZng7XG4gICAgICBpZiAoIWltYWdlU291cmNlKSB7XG5cbiAgICAgICAgLy8gZGVmYXVsdCBwbGFjZWhvbGRlclxuICAgICAgICBnZnggPSBkcmF3UmVjdChwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCAwLCB7XG4gICAgICAgICAgZmlsbDogJyNjY2MnLFxuICAgICAgICAgIHN0cm9rZTogJyNjY2MnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlckxhYmVsKHBhcmVudEdmeCwgJ0ltYWdlIFBsYWNlaG9sZGVyJywge1xuICAgICAgICAgIGJveDogZWxlbWVudCxcbiAgICAgICAgICBhbGlnbjogJ2NlbnRlci1taWRkbGUnLFxuICAgICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGZpbGw6ICdibGFjaycsXG4gICAgICAgICAgICBmb250U2l6ZTogREVGQVVMVF9URVhUX1NJWkVcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2Z4ID0gc3ZnQ3JlYXRlKCdpbWFnZScsIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBocmVmOiBnZXRJbWFnZVNvdXJjZShlbGVtZW50KVxuICAgICAgICB9KTtcblxuICAgICAgICBzdmdBcHBlbmQocGFyZW50R2Z4LCBnZngpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2Z4O1xuICAgIH0sXG5cbiAgICAnbGFiZWwnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiByZW5kZXJFeHRlcm5hbExhYmVsKHBhcmVudEdmeCwgZWxlbWVudCk7XG4gICAgfVxuICB9O1xuXG5cbiAgLy8gZXh0ZW5zaW9uIEFQSSwgdXNlIGF0IHlvdXIgb3duIHJpc2tcbiAgdGhpcy5fZHJhd1BhdGggPSBkcmF3UGF0aDtcblxufVxuXG5cbmluaGVyaXRzKFBvc3RpdFJlbmRlcmVyLCBCYXNlUmVuZGVyZXIpO1xuXG5Qb3N0aXRSZW5kZXJlci4kaW5qZWN0ID0gW1xuICAnY29uZmlnLnBvc3RpdCcsXG4gICdldmVudEJ1cycsXG4gICdzdHlsZXMnLFxuICAncGF0aE1hcCcsXG4gICdjYW52YXMnLFxuICAndGV4dFJlbmRlcmVyJ1xuXTtcblxuXG5Qb3N0aXRSZW5kZXJlci5wcm90b3R5cGUuY2FuUmVuZGVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gaXMoZWxlbWVudCwgJ3Bvc3RpdDpCb2FyZEVsZW1lbnQnKTtcbn07XG5cblBvc3RpdFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3U2hhcGUgPSBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBoID0gdGhpcy5oYW5kbGVyc1t0eXBlXTtcblxuICAvKiBqc2hpbnQgLVcwNDAgKi9cbiAgcmV0dXJuIGgocGFyZW50R2Z4LCBlbGVtZW50KTtcbn07XG5cblBvc3RpdFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaGFwZVBhdGggPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgcmV0dXJuIGdldFJlY3RQYXRoKGVsZW1lbnQpO1xufTtcblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGdldENvbG9yKGVsZW1lbnQpIHtcbiAgdmFyIGJvID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XG5cbiAgcmV0dXJuIGJvLmNvbG9yIHx8IGVsZW1lbnQuY29sb3I7XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlU291cmNlKGVsZW1lbnQpIHtcbiAgdmFyIGJvID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XG5cbiAgcmV0dXJuIGJvLnNvdXJjZSB8fCBlbGVtZW50LnNvdXJjZTtcbn1cblxuIiwiaW1wb3J0IHtcbiAgZXZlcnksXG4gIHNvbWVcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBjb21wb25lbnRzVG9QYXRoXG59IGZyb20gJ2RpYWdyYW0tanMvbGliL3V0aWwvUmVuZGVyVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldEJ1c2luZXNzT2JqZWN0XG59IGZyb20gJy4uL3V0aWwvTW9kZWxVdGlsJztcblxuXG4vLyBlbGVtZW50IHV0aWxzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDaGVja3MgaWYgZXZlbnREZWZpbml0aW9uIG9mIHRoZSBnaXZlbiBlbGVtZW50IG1hdGNoZXMgd2l0aCBzZW1hbnRpYyB0eXBlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgZWxlbWVudCBpcyBvZiB0aGUgZ2l2ZW4gc2VtYW50aWMgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlZEV2ZW50KGV2ZW50LCBldmVudERlZmluaXRpb25UeXBlLCBmaWx0ZXIpIHtcblxuICBmdW5jdGlvbiBtYXRjaGVzKGRlZmluaXRpb24sIGZpbHRlcikge1xuICAgIHJldHVybiBldmVyeShmaWx0ZXIsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cbiAgICAgIC8vIHdlIHdhbnQgYSA9PSBjb252ZXJzaW9uIGhlcmUsIHRvIGJlIGFibGUgdG8gY2F0Y2hcbiAgICAgIC8vIHVuZGVmaW5lZCA9PSBmYWxzZSBhbmQgZnJpZW5kc1xuICAgICAgLyoganNoaW50IC1XMTE2ICovXG4gICAgICByZXR1cm4gZGVmaW5pdGlvbltrZXldID09IHZhbDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzb21lKGV2ZW50LmV2ZW50RGVmaW5pdGlvbnMsIGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvbi4kdHlwZSA9PT0gZXZlbnREZWZpbml0aW9uVHlwZSAmJiBtYXRjaGVzKGV2ZW50LCBmaWx0ZXIpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuYnVzaW5lc3NPYmplY3QuZGk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW1hbnRpYyhlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LmJ1c2luZXNzT2JqZWN0O1xufVxuXG5cbi8vIGNvbG9yIGFjY2VzcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdENvbG9yKSB7XG4gIHJldHVybiAoXG4gICAgZ2V0Q29sb3IoZWxlbWVudCkgfHxcbiAgICBnZXREaShlbGVtZW50KS5nZXQoJ2Jpb2M6ZmlsbCcpIHx8XG4gICAgZGVmYXVsdENvbG9yIHx8XG4gICAgJ3doaXRlJ1xuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdENvbG9yKSB7XG4gIHJldHVybiAoXG4gICAgZ2V0Q29sb3IoZWxlbWVudCkgfHxcbiAgICBnZXREaShlbGVtZW50KS5nZXQoJ2Jpb2M6c3Ryb2tlJykgfHxcbiAgICBkZWZhdWx0Q29sb3IgfHxcbiAgICAnYmxhY2snXG4gICk7XG59XG5cblxuLy8gY3JvcHBpbmcgcGF0aCBjdXN0b21pemF0aW9ucyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaXJjbGVQYXRoKHNoYXBlKSB7XG5cbiAgdmFyIGN4ID0gc2hhcGUueCArIHNoYXBlLndpZHRoIC8gMixcbiAgICAgIGN5ID0gc2hhcGUueSArIHNoYXBlLmhlaWdodCAvIDIsXG4gICAgICByYWRpdXMgPSBzaGFwZS53aWR0aCAvIDI7XG5cbiAgdmFyIGNpcmNsZVBhdGggPSBbXG4gICAgWydNJywgY3gsIGN5XSxcbiAgICBbJ20nLCAwLCAtcmFkaXVzXSxcbiAgICBbJ2EnLCByYWRpdXMsIHJhZGl1cywgMCwgMSwgMSwgMCwgMiAqIHJhZGl1c10sXG4gICAgWydhJywgcmFkaXVzLCByYWRpdXMsIDAsIDEsIDEsIDAsIC0yICogcmFkaXVzXSxcbiAgICBbJ3onXVxuICBdO1xuXG4gIHJldHVybiBjb21wb25lbnRzVG9QYXRoKGNpcmNsZVBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91bmRSZWN0UGF0aChzaGFwZSwgYm9yZGVyUmFkaXVzKSB7XG5cbiAgdmFyIHggPSBzaGFwZS54LFxuICAgICAgeSA9IHNoYXBlLnksXG4gICAgICB3aWR0aCA9IHNoYXBlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuXG4gIHZhciByb3VuZFJlY3RQYXRoID0gW1xuICAgIFsnTScsIHggKyBib3JkZXJSYWRpdXMsIHldLFxuICAgIFsnbCcsIHdpZHRoIC0gYm9yZGVyUmFkaXVzICogMiwgMF0sXG4gICAgWydhJywgYm9yZGVyUmFkaXVzLCBib3JkZXJSYWRpdXMsIDAsIDAsIDEsIGJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzXSxcbiAgICBbJ2wnLCAwLCBoZWlnaHQgLSBib3JkZXJSYWRpdXMgKiAyXSxcbiAgICBbJ2EnLCBib3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1cywgMCwgMCwgMSwgLWJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzXSxcbiAgICBbJ2wnLCBib3JkZXJSYWRpdXMgKiAyIC0gd2lkdGgsIDBdLFxuICAgIFsnYScsIGJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzLCAwLCAwLCAxLCAtYm9yZGVyUmFkaXVzLCAtYm9yZGVyUmFkaXVzXSxcbiAgICBbJ2wnLCAwLCBib3JkZXJSYWRpdXMgKiAyIC0gaGVpZ2h0XSxcbiAgICBbJ2EnLCBib3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1cywgMCwgMCwgMSwgYm9yZGVyUmFkaXVzLCAtYm9yZGVyUmFkaXVzXSxcbiAgICBbJ3onXVxuICBdO1xuXG4gIHJldHVybiBjb21wb25lbnRzVG9QYXRoKHJvdW5kUmVjdFBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlhbW9uZFBhdGgoc2hhcGUpIHtcblxuICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aCxcbiAgICAgIGhlaWdodCA9IHNoYXBlLmhlaWdodCxcbiAgICAgIHggPSBzaGFwZS54LFxuICAgICAgeSA9IHNoYXBlLnksXG4gICAgICBoYWxmV2lkdGggPSB3aWR0aCAvIDIsXG4gICAgICBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblxuICB2YXIgZGlhbW9uZFBhdGggPSBbXG4gICAgWydNJywgeCArIGhhbGZXaWR0aCwgeV0sXG4gICAgWydsJywgaGFsZldpZHRoLCBoYWxmSGVpZ2h0XSxcbiAgICBbJ2wnLCAtaGFsZldpZHRoLCBoYWxmSGVpZ2h0XSxcbiAgICBbJ2wnLCAtaGFsZldpZHRoLCAtaGFsZkhlaWdodF0sXG4gICAgWyd6J11cbiAgXTtcblxuICByZXR1cm4gY29tcG9uZW50c1RvUGF0aChkaWFtb25kUGF0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWN0UGF0aChzaGFwZSkge1xuICB2YXIgeCA9IHNoYXBlLngsXG4gICAgICB5ID0gc2hhcGUueSxcbiAgICAgIHdpZHRoID0gc2hhcGUud2lkdGgsXG4gICAgICBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG5cbiAgdmFyIHJlY3RQYXRoID0gW1xuICAgIFsnTScsIHgsIHldLFxuICAgIFsnbCcsIHdpZHRoLCAwXSxcbiAgICBbJ2wnLCAwLCBoZWlnaHRdLFxuICAgIFsnbCcsIC13aWR0aCwgMF0sXG4gICAgWyd6J11cbiAgXTtcblxuICByZXR1cm4gY29tcG9uZW50c1RvUGF0aChyZWN0UGF0aCk7XG59XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBnZXRDb2xvcihlbGVtZW50KSB7XG4gIHZhciBibyA9IGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpO1xuXG4gIHJldHVybiBiby5jb2xvciB8fCBlbGVtZW50LmNvbG9yO1xufSIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IFRleHRVdGlsIGZyb20gJ2RpYWdyYW0tanMvbGliL3V0aWwvVGV4dCc7XG5cbnZhciBERUZBVUxUX0ZPTlRfU0laRSA9IDE2O1xudmFyIExJTkVfSEVJR0hUX1JBVElPID0gMS4yO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRleHRSZW5kZXJlcihjb25maWcpIHtcblxuICB2YXIgZGVmYXVsdFN0eWxlID0gYXNzaWduKHtcbiAgICBmb250RmFtaWx5OiAnSUJNIFBsZXgsIHNhbnMtc2VyaWYnLFxuICAgIGZvbnRTaXplOiBERUZBVUxUX0ZPTlRfU0laRSxcbiAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICBsaW5lSGVpZ2h0OiBMSU5FX0hFSUdIVF9SQVRJT1xuICB9LCBjb25maWcgJiYgY29uZmlnLmRlZmF1bHRTdHlsZSB8fCB7fSk7XG5cbiAgdmFyIGZvbnRTaXplID0gcGFyc2VJbnQoZGVmYXVsdFN0eWxlLmZvbnRTaXplLCAxMCkgLSAxO1xuXG4gIHZhciBleHRlcm5hbFN0eWxlID0gYXNzaWduKHt9LCBkZWZhdWx0U3R5bGUsIHtcbiAgICBmb250U2l6ZTogZm9udFNpemVcbiAgfSwgY29uZmlnICYmIGNvbmZpZy5leHRlcm5hbFN0eWxlIHx8IHt9KTtcblxuICB2YXIgdGV4dFV0aWwgPSBuZXcgVGV4dFV0aWwoe1xuICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV3IGJvdW5kcyBvZiBhbiBleHRlcm5hbGx5IHJlbmRlcmVkLFxuICAgKiBsYXlvdXRlZCBsYWJlbC5cbiAgICpcbiAgICogQHBhcmFtICB7Qm91bmRzfSBib3VuZHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0XG4gICAqXG4gICAqIEByZXR1cm4ge0JvdW5kc31cbiAgICovXG4gIHRoaXMuZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kcyA9IGZ1bmN0aW9uKGJvdW5kcywgdGV4dCkge1xuXG4gICAgdmFyIGxheW91dGVkRGltZW5zaW9ucyA9IHRleHRVdGlsLmdldERpbWVuc2lvbnModGV4dCwge1xuICAgICAgYm94OiB7XG4gICAgICAgIHdpZHRoOiA5MCxcbiAgICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgICAgeDogYm91bmRzLndpZHRoIC8gMiArIGJvdW5kcy54LFxuICAgICAgICB5OiBib3VuZHMuaGVpZ2h0IC8gMiArIGJvdW5kcy55XG4gICAgICB9LFxuICAgICAgc3R5bGU6IGV4dGVybmFsU3R5bGVcbiAgICB9KTtcblxuICAgIC8vIHJlc2l6ZSBsYWJlbCBzaGFwZSB0byBmaXQgbGFiZWwgdGV4dFxuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLnJvdW5kKGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMiAtIGxheW91dGVkRGltZW5zaW9ucy53aWR0aCAvIDIpLFxuICAgICAgeTogTWF0aC5yb3VuZChib3VuZHMueSksXG4gICAgICB3aWR0aDogTWF0aC5jZWlsKGxheW91dGVkRGltZW5zaW9ucy53aWR0aCksXG4gICAgICBoZWlnaHQ6IE1hdGguY2VpbChsYXlvdXRlZERpbWVuc2lvbnMuaGVpZ2h0KVxuICAgIH07XG5cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbGF5b3V0ZWQgdGV4dCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqXG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHJlbmRlcmVkIHRleHRcbiAgICovXG4gIHRoaXMuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGV4dFV0aWwuY3JlYXRlVGV4dCh0ZXh0LCBvcHRpb25zIHx8IHt9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGRlZmF1bHQgdGV4dCBzdHlsZS5cbiAgICovXG4gIHRoaXMuZ2V0RGVmYXVsdFN0eWxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRTdHlsZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlcm5hbCB0ZXh0IHN0eWxlLlxuICAgKi9cbiAgdGhpcy5nZXRFeHRlcm5hbFN0eWxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGV4dGVybmFsU3R5bGU7XG4gIH07XG5cbn1cblxuVGV4dFJlbmRlcmVyLiRpbmplY3QgPSBbXG4gICdjb25maWcudGV4dFJlbmRlcmVyJ1xuXTsiLCJpbXBvcnQgUG9zdGl0UmVuZGVyZXIgZnJvbSAnLi9Qb3N0aXRSZW5kZXJlcic7XG5pbXBvcnQgVGV4dFJlbmRlcmVyIGZyb20gJy4vVGV4dFJlbmRlcmVyJztcblxuaW1wb3J0IFBhdGhNYXAgZnJvbSAnLi9QYXRoTWFwJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAncG9zdGl0UmVuZGVyZXInIF0sXG4gIHBvc3RpdFJlbmRlcmVyOiBbICd0eXBlJywgUG9zdGl0UmVuZGVyZXIgXSxcbiAgdGV4dFJlbmRlcmVyOiBbICd0eXBlJywgVGV4dFJlbmRlcmVyIF0sXG4gIHBhdGhNYXA6IFsgJ3R5cGUnLCBQYXRoTWFwIF1cbn07XG4iLCJpbXBvcnQge1xuICBkZWxlZ2F0ZSBhcyBkb21EZWxlZ2F0ZVxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZ2V0QnVzaW5lc3NPYmplY3Rcbn0gZnJvbSAnLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG5pbXBvcnQgQ09MT1JTIGZyb20gJy4uLy4uL3V0aWwvQ29sb3JVdGlsJztcblxuaW1wb3J0IHtcbiAgdG9Qb2ludFxufSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL0V2ZW50JztcbmltcG9ydCB7IGlzQW55IH0gZnJvbSAnLi4vbW9kZWxpbmcvdXRpbC9Nb2RlbGluZ1V0aWwnO1xuXG52YXIgREVGQVVMVF9TSEFQRSA9IHtcbiAgdHlwZTogJ3Bvc3RpdDpTcXVhcmVQb3N0aXQnLFxuICBjb2xvcjogQ09MT1JTLllFTExPVyxcbiAgJGluc3RhbmNlT2Y6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FudmFzQ3JlYXRlKFxuICAgIGV2ZW50QnVzLCBlbGVtZW50RmFjdG9yeSwgY2FudmFzLCBkaXJlY3RFZGl0aW5nLCBtb2RlbGluZykge1xuXG4gIHZhciBsYXN0Q3JlYXRlZFNoYXBlID0gREVGQVVMVF9TSEFQRTtcblxuICBmdW5jdGlvbiBfZ2V0TmV3U2hhcGVQb3NpdGlvbihldmVudCkge1xuICAgIHZhciBldmVudFBvaW50ID0gdG9Qb2ludChldmVudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnRQb2ludC54LFxuICAgICAgeTogZXZlbnRQb2ludC55XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hY3RpdmF0ZURpcmVjdEVkaXQoZWxlbWVudCkge1xuICAgIGlmIChpc0FueShlbGVtZW50LCBbICdwb3N0aXQ6UG9zdGl0JywgJ3Bvc3RpdDpHcm91cCcsICdwb3N0aXQ6VGV4dEJveCcgXSkpIHtcblxuICAgICAgZGlyZWN0RWRpdGluZy5hY3RpdmF0ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlU2hhcGVPbkNhbnZhcyhldmVudCkge1xuICAgIHZhciBwb3NpdGlvbiA9IF9nZXROZXdTaGFwZVBvc2l0aW9uKGV2ZW50KTtcblxuICAgIHZhciBuZXdTaGFwZSA9IGVsZW1lbnRGYWN0b3J5LmNyZWF0ZVBvc3RpdEVsZW1lbnQoXG4gICAgICAnc2hhcGUnLCBhc3NpZ24obGFzdENyZWF0ZWRTaGFwZSwgcG9zaXRpb24pKTtcblxuICAgIHZhciByb290ID0gY2FudmFzLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgICB2YXIgY3JlYXRlZFNoYXBlID0gbW9kZWxpbmcuY3JlYXRlU2hhcGUobmV3U2hhcGUsIHBvc2l0aW9uLCByb290KTtcblxuICAgIF9hY3RpdmF0ZURpcmVjdEVkaXQoY3JlYXRlZFNoYXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zYXZlTGFzdENyZWF0ZWRTaGFwZShzaGFwZSkge1xuICAgIGlmICghc2hhcGUpIHtcbiAgICAgIGxhc3RDcmVhdGVkU2hhcGUgPSBERUZBVUxUX1NIQVBFO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBibyA9IGdldEJ1c2luZXNzT2JqZWN0KHNoYXBlKTtcblxuICAgIGxhc3RDcmVhdGVkU2hhcGUgPSB7XG4gICAgICB0eXBlOiBzaGFwZS50eXBlLFxuICAgICAgY29sb3I6IHNoYXBlLmNvbG9yIHx8IGJvLmNvbG9yLFxuICAgICAgJGluc3RhbmNlT2Y6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgYm8uJGluc3RhbmNlT2YgPT09ICdmdW5jdGlvbicpICYmIGJvLiRpbnN0YW5jZU9mKHR5cGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVEcm9wU2hhZG93RmlsdGVyKHZpZXdwb3J0KSB7XG4gICAgdmlld3BvcnQuaW5uZXJIVE1MID0gJzxmaWx0ZXIgaWQ9XCJub3RlRHJvcFNoYWRvd1wiIHN0eWxlPVwiaGVpZ2h0OiAxMzAlO1wiPjxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwiM1wiPjwvZmVHYXVzc2lhbkJsdXI+PGZlT2Zmc2V0IGR4PVwiMVwiIGR5PVwiMlwiIHJlc3VsdD1cIm9mZnNldGJsdXJcIj48L2ZlT2Zmc2V0PjxmZU1lcmdlPjxmZU1lcmdlTm9kZT48L2ZlTWVyZ2VOb2RlPjxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIj48L2ZlTWVyZ2VOb2RlPjwvZmVNZXJnZT48L2ZpbHRlcj4nO1xuICB9XG5cblxuICBldmVudEJ1cy5vbignY2FudmFzLmluaXQnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHN2ZyA9IGNvbnRleHQuc3ZnO1xuXG4gICAgX2NyZWF0ZURyb3BTaGFkb3dGaWx0ZXIoY29udGV4dC52aWV3cG9ydCk7XG4gICAgZG9tRGVsZWdhdGUuYmluZChzdmcsICdzdmcnLCAnZGJsY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gc3ZnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX2NyZWF0ZVNoYXBlT25DYW52YXMoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgZXZlbnRCdXMub24oJ2NyZWF0ZS5lbmQnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlO1xuICAgICAgX3NhdmVMYXN0Q3JlYXRlZFNoYXBlKHNoYXBlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbkNhbnZhc0NyZWF0ZS5wcm90b3R5cGUuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2VsZW1lbnRGYWN0b3J5JyxcbiAgJ2NhbnZhcycsXG4gICdkaXJlY3RFZGl0aW5nJyxcbiAgJ21vZGVsaW5nJ1xuXTtcbiIsImltcG9ydCBDYW52YXNDcmVhdGUgZnJvbSAnLi9DYW52YXNDcmVhdGUnO1xuaW1wb3J0IERpcmVjdEVkaXRpbmdNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy1kaXJlY3QtZWRpdGluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBEaXJlY3RFZGl0aW5nTW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbICdjYW52YXNDcmVhdGUnIF0sXG4gIGNhbnZhc0NyZWF0ZTogWyAndHlwZScsIENhbnZhc0NyZWF0ZSBdXG59OyIsImltcG9ydCB7XG4gIGFzc2lnbixcbiAgaXNBcnJheSxcbiAga2V5cyxcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGhhc1ByaW1hcnlNb2RpZmllclxufSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL01vdXNlJztcblxuaW1wb3J0IENPTE9SUyBmcm9tICcuLi8uLi91dGlsL0NvbG9yVXRpbCc7XG5pbXBvcnQgeyBpcywgZ2V0QnVzaW5lc3NPYmplY3QgfSBmcm9tICcuLi8uLi91dGlsL01vZGVsVXRpbCc7XG5cblxuLyoqXG4gKiBBIHByb3ZpZGVyIGZvciBwb3N0aXQgZWxlbWVudHMgY29udGV4dCBwYWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29udGV4dFBhZFByb3ZpZGVyKFxuICAgIGNvbmZpZywgaW5qZWN0b3IsIGV2ZW50QnVzLFxuICAgIGNvbnRleHRQYWQsIG1vZGVsaW5nLCBydWxlcyxcbiAgICBpbWFnZVNlbGVjdGlvbiwgdHJhbnNsYXRlKSB7XG5cbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gIGNvbnRleHRQYWQucmVnaXN0ZXJQcm92aWRlcih0aGlzKTtcblxuICB0aGlzLl9jb250ZXh0UGFkID0gY29udGV4dFBhZDtcblxuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuXG4gIHRoaXMuX3J1bGVzID0gcnVsZXM7XG4gIHRoaXMuX2ltYWdlU2VsZWN0aW9uID0gaW1hZ2VTZWxlY3Rpb247XG4gIHRoaXMuX3RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcblxuICBpZiAoY29uZmlnLmF1dG9QbGFjZSAhPT0gZmFsc2UpIHtcbiAgICB0aGlzLl9hdXRvUGxhY2UgPSBpbmplY3Rvci5nZXQoJ2F1dG9QbGFjZScsIGZhbHNlKTtcbiAgfVxuXG4gIGV2ZW50QnVzLm9uKCdjcmVhdGUuZW5kJywgMjUwLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlO1xuXG4gICAgaWYgKCFoYXNQcmltYXJ5TW9kaWZpZXIoZXZlbnQpIHx8ICFjb250ZXh0UGFkLmlzT3BlbihzaGFwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZW50cmllcyA9IGNvbnRleHRQYWQuZ2V0RW50cmllcyhzaGFwZSk7XG5cbiAgICBpZiAoZW50cmllcy5yZXBsYWNlKSB7XG4gICAgICBlbnRyaWVzLnJlcGxhY2UuYWN0aW9uLmNsaWNrKGV2ZW50LCBzaGFwZSk7XG4gICAgfVxuICB9KTtcbn1cblxuQ29udGV4dFBhZFByb3ZpZGVyLiRpbmplY3QgPSBbXG4gICdjb25maWcuY29udGV4dFBhZCcsXG4gICdpbmplY3RvcicsXG4gICdldmVudEJ1cycsXG4gICdjb250ZXh0UGFkJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ3J1bGVzJyxcbiAgJ2ltYWdlU2VsZWN0aW9uJyxcbiAgJ3RyYW5zbGF0ZSdcbl07XG5cblxuQ29udGV4dFBhZFByb3ZpZGVyLnByb3RvdHlwZS5nZXRDb250ZXh0UGFkRW50cmllcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICBjb25zdCB7XG4gICAgX3J1bGVzOiBydWxlcyxcbiAgICBfbW9kZWxpbmc6IG1vZGVsaW5nLFxuICAgIF9pbWFnZVNlbGVjdGlvbjogaW1hZ2VTZWxlY3Rpb24sXG4gICAgX3RyYW5zbGF0ZTogdHJhbnNsYXRlXG4gIH0gPSB0aGlzO1xuXG4gIGxldCBhY3Rpb25zID0ge307XG5cbiAgZnVuY3Rpb24gX3JlbW92ZUVsZW1lbnQoZSkge1xuICAgIHZhciB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIHZhciBzX2tleSA9IHVybFBhcmFtcy5nZXQoJ3Nfa2V5Jyk7XG4gICAgaWYoIHNfa2V5ID09PSBudWxsICkge1xuICAgICAgc2hlcGhlcmRBbGVydChcIlNjcmlwdCBSZXF1aXJlZFwiLCBcIllvdSBtdXN0IG9wZW4gYSBzY3JpcHQgdG8gdXBkYXRlIGl0J3Mgbm90ZXMuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB0eXBlOiBcIkRFTEVURVwiLFxuICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignWC1DU1JGLVRva2VuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpLmF0dHIoJ2NvbnRlbnQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgIHVybDogXCIvc2NyaXB0cy9cIiArIHNfa2V5ICsgXCIvZGVzdHJveV9pbWFnZS9cIiArIGVsZW1lbnQuYnVzaW5lc3NPYmplY3QuJGF0dHJzW1wia2V5XCJdLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgZmFpbHVyZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIC8vIENvbnNjaW91c2x5IG5vdCBkb2luZyBhbnl0aGluZy4gRmFpbCBzaWxlbnRseSBhbmQgY2xlYW4gdXBcbiAgICAgICAgICAvLyBsYXRlci5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIG1vZGVsaW5nLnJlbW92ZUVsZW1lbnRzKFsgZWxlbWVudCBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZSkge1xuICAgIGlmKCBlbGVtZW50LnR5cGUgPT09IFwicG9zdGl0OkltYWdlXCIgKSB7XG4gICAgICBzaGVwaGVyZENvbmZpcm0oXCJDb25maXJtIERlbGV0ZT9cIiwgXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgZWxlbWVudD9cIiwgX3JlbW92ZUVsZW1lbnQsIFtlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsaW5nLnJlbW92ZUVsZW1lbnRzKFsgZWxlbWVudCBdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDb2xvcihjb2xvcikge1xuICAgIG1vZGVsaW5nLnNldENvbG9yKGVsZW1lbnQsIGNvbG9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlbGV0ZUVudHJ5KGFjdGlvbnMpIHtcblxuICAgIC8vIGRlbGV0ZSBlbGVtZW50IGVudHJ5LCBvbmx5IHNob3cgaWYgYWxsb3dlZCBieSBydWxlc1xuICAgIGxldCBkZWxldGVBbGxvd2VkID0gcnVsZXMuYWxsb3dlZCgnZWxlbWVudHMuZGVsZXRlJywgeyBlbGVtZW50czogWyBlbGVtZW50IF0gfSk7XG5cbiAgICBpZiAoaXNBcnJheShkZWxldGVBbGxvd2VkKSkge1xuXG4gICAgICAvLyB3YXMgdGhlIGVsZW1lbnQgcmV0dXJuZWQgYXMgYSBkZWxldGlvbiBjYW5kaWRhdGU/XG4gICAgICBkZWxldGVBbGxvd2VkID0gZGVsZXRlQWxsb3dlZFswXSA9PT0gZWxlbWVudDtcbiAgICB9XG5cbiAgICBpZiAoZGVsZXRlQWxsb3dlZCkge1xuICAgICAgYXNzaWduKGFjdGlvbnMsIHtcbiAgICAgICAgJ2RlbGV0ZSc6IHtcbiAgICAgICAgICBncm91cDogJ2VkaXQnLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ2JwbW4taWNvbi10cmFzaCcsXG4gICAgICAgICAgdGl0bGU6IHRyYW5zbGF0ZSgnUmVtb3ZlJyksXG4gICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICBjbGljazogcmVtb3ZlRWxlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29sb3JpbmdFbnRyaWVzKGFjdGlvbnMpIHtcbiAgICBmb3JFYWNoKGtleXMoQ09MT1JTKSwga2V5ID0+IHtcbiAgICAgIHZhciBjb2xvciA9IENPTE9SU1trZXldO1xuXG4gICAgICBmdW5jdGlvbiBnZXRDbGFzc05hbWVzKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xuXG4gICAgICAgIGlmIChjb2xvciA9PT0gZ2V0Q29sb3IoZWxlbWVudCkpIHtcblxuICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgncGpzLWNvbG9yLWVudHJ5LWRpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ3Bqcy1jb2xvci1lbnRyeS0nICsga2V5KTtcblxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lcztcbiAgICAgIH1cblxuICAgICAgYXNzaWduKGFjdGlvbnMsIHtcbiAgICAgICAgWydjb2xvci0nICsga2V5XToge1xuICAgICAgICAgIGdyb3VwOiAnY29sb3InLFxuICAgICAgICAgIGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lcygpLFxuICAgICAgICAgIHRpdGxlOiB0cmFuc2xhdGUoJ1NldCBDb2xvcicpLFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgY2xpY2s6IChldmVudCkgPT4gc2V0Q29sb3IoY29sb3IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChlbGVtZW50LnR5cGUgPT09ICdsYWJlbCcpIHtcbiAgICByZXR1cm4gYWN0aW9ucztcbiAgfVxuXG4gIGlmIChpcyhlbGVtZW50LCAncG9zdGl0OlBvc3RpdCcpKSB7XG4gICAgY3JlYXRlQ29sb3JpbmdFbnRyaWVzKGFjdGlvbnMpO1xuICB9XG5cbiAgaWYgKGlzKGVsZW1lbnQsICdwb3N0aXQ6SW1hZ2UnKSkge1xuICAgIGFzc2lnbihhY3Rpb25zLCB7XG4gICAgICAncmVwbGFjZS5pbWFnZSc6IHtcbiAgICAgICAgZ3JvdXA6ICdyZXBsYWNlJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnYnBtbi1pY29uLXNjcmV3LXdyZW5jaCcsXG4gICAgICAgIHRpdGxlOiB0cmFuc2xhdGUoJ0NoYW5nZSBpbWFnZSBzb3VyY2UnKSxcbiAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgY2xpY2s6IChldmVudCkgPT4gaW1hZ2VTZWxlY3Rpb24uc2VsZWN0KGVsZW1lbnQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZURlbGV0ZUVudHJ5KGFjdGlvbnMpO1xuXG4gIHJldHVybiBhY3Rpb25zO1xufTtcblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGdldENvbG9yKGVsZW1lbnQpIHtcbiAgdmFyIGJvID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XG5cbiAgcmV0dXJuIGJvLmNvbG9yIHx8IGVsZW1lbnQuY29sb3I7XG59XG4iLCJpbXBvcnQgRGlyZWN0RWRpdGluZ01vZHVsZSBmcm9tICdkaWFncmFtLWpzLWRpcmVjdC1lZGl0aW5nJztcbmltcG9ydCBDb250ZXh0UGFkTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NvbnRleHQtcGFkJztcbmltcG9ydCBTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uJztcbmltcG9ydCBDb25uZWN0TW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2Nvbm5lY3QnO1xuaW1wb3J0IENyZWF0ZU1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9jcmVhdGUnO1xuaW1wb3J0IFBvcHVwTWVudU1vZHVsZSBmcm9tICcuLi9wb3B1cC1tZW51JztcblxuaW1wb3J0IENvbnRleHRQYWRQcm92aWRlciBmcm9tICcuL0NvbnRleHRQYWRQcm92aWRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBEaXJlY3RFZGl0aW5nTW9kdWxlLFxuICAgIENvbnRleHRQYWRNb2R1bGUsXG4gICAgU2VsZWN0aW9uTW9kdWxlLFxuICAgIENvbm5lY3RNb2R1bGUsXG4gICAgQ3JlYXRlTW9kdWxlLFxuICAgIFBvcHVwTWVudU1vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAnY29udGV4dFBhZFByb3ZpZGVyJyBdLFxuICBjb250ZXh0UGFkUHJvdmlkZXI6IFsgJ3R5cGUnLCBDb250ZXh0UGFkUHJvdmlkZXIgXVxufTsiLCJpbXBvcnQge1xuICBmaW5kLFxuICBmb3JFYWNoLFxuICBpc0FycmF5LFxuICBpc0RlZmluZWQsXG4gIGlzT2JqZWN0LFxuICBtYXRjaFBhdHRlcm4sXG4gIHJlZHVjZSxcbiAgaGFzLFxuICBzb3J0Qnlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG52YXIgRElTQUxMT1dFRF9QUk9QRVJUSUVTID0gW1xuICAnYm9hcmRFbGVtZW50cydcbl07XG5cbi8qKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSA8bW9kZGxlQ29weS5jYW5Db3B5UHJvcGVydGllcz4gbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBjb250ZXh0LnByb3BlcnR5TmFtZXNcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gY29udGV4dC5zb3VyY2VFbGVtZW50XG4gKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGNvbnRleHQudGFyZ2V0RWxlbWVudFxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fGJvb2xlYW59IC0gUmV0dXJuIHByb3BlcnRpZXMgdG8gYmUgY29waWVkIG9yIGZhbHNlIHRvIGRpc2FsbG93XG4gKiBjb3B5aW5nLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSA8bW9kZGxlQ29weS5jYW5Db3B5UHJvcGVydHk+IGxpc3RlbmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gY29udGV4dC5wYXJlbnRcbiAqIEBwYXJhbSB7Kn0gY29udGV4dC5wcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQucHJvcGVydHlOYW1lXG4gKlxuICogQHJldHVybnMgeyp8Ym9vbGVhbn0gLSBSZXR1cm4gY29waWVkIHByb3BlcnR5IG9yIGZhbHNlIHRvIGRpc2FsbG93XG4gKiBjb3B5aW5nLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSA8bW9kZGxlQ29weS5jYW5TZXRDb3BpZWRQcm9wZXJ0eT4gbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBjb250ZXh0LnBhcmVudFxuICogQHBhcmFtIHsqfSBjb250ZXh0LnByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dC5wcm9wZXJ0eU5hbWVcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBSZXR1cm4gZmFsc2UgdG8gZGlzYWxsb3dcbiAqIHNldHRpbmcgY29waWVkIHByb3BlcnR5LlxuICovXG5cbi8qKlxuICogVXRpbGl0eSBmb3IgY29weWluZyBtb2RlbCBwcm9wZXJ0aWVzIGZyb20gc291cmNlIGVsZW1lbnQgdG8gdGFyZ2V0IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7UG9zdGl0RmFjdG9yeX0gcG9zdGl0RmFjdG9yeVxuICogQHBhcmFtIHtQb3N0aXRNb2RkbGV9IG1vZGRsZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNb2RkbGVDb3B5KGV2ZW50QnVzLCBwb3N0aXRGYWN0b3J5LCBtb2RkbGUpIHtcbiAgdGhpcy5fcG9zdGl0RmFjdG9yeSA9IHBvc3RpdEZhY3Rvcnk7XG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX21vZGRsZSA9IG1vZGRsZTtcblxuICAvLyBjb3B5IGV4dGVuc2lvbiBlbGVtZW50cyBsYXN0XG4gIGV2ZW50QnVzLm9uKCdtb2RkbGVDb3B5LmNhbkNvcHlQcm9wZXJ0aWVzJywgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWVzID0gY29udGV4dC5wcm9wZXJ0eU5hbWVzO1xuXG4gICAgaWYgKCFwcm9wZXJ0eU5hbWVzIHx8ICFwcm9wZXJ0eU5hbWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBzb3J0QnkocHJvcGVydHlOYW1lcywgZnVuY3Rpb24ocHJvcGVydHlOYW1lKSB7XG4gICAgICByZXR1cm4gcHJvcGVydHlOYW1lID09PSAnZXh0ZW5zaW9uRWxlbWVudHMnO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBkZWZhdWx0IGNoZWNrIHdoZXRoZXIgcHJvcGVydHkgY2FuIGJlIGNvcGllZFxuICBldmVudEJ1cy5vbignbW9kZGxlQ29weS5jYW5Db3B5UHJvcGVydHknLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHBhcmVudCA9IGNvbnRleHQucGFyZW50LFxuICAgICAgICBwYXJlbnREZXNjcmlwdG9yID0gaXNPYmplY3QocGFyZW50KSAmJiBwYXJlbnQuJGRlc2NyaXB0b3IsXG4gICAgICAgIHByb3BlcnR5TmFtZSA9IGNvbnRleHQucHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKHByb3BlcnR5TmFtZSAmJiBESVNBTExPV0VEX1BST1BFUlRJRVMuaW5kZXhPZihwcm9wZXJ0eU5hbWUpICE9PSAtMSkge1xuXG4gICAgICAvLyBkaXNhbGxvdyBjb3B5aW5nIHByb3BlcnR5XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5TmFtZSAmJlxuICAgICAgcGFyZW50RGVzY3JpcHRvciAmJlxuICAgICAgIWZpbmQocGFyZW50RGVzY3JpcHRvci5wcm9wZXJ0aWVzLCBtYXRjaFBhdHRlcm4oeyBuYW1lOiBwcm9wZXJ0eU5hbWUgfSkpKSB7XG5cbiAgICAgIC8vIGRpc2FsbG93IGNvcHlpbmcgcHJvcGVydHlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuXG5Nb2RkbGVDb3B5LiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdwb3N0aXRGYWN0b3J5JyxcbiAgJ21vZGRsZSdcbl07XG5cbi8qKlxuICogQ29weSBtb2RlbCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBlbGVtZW50IHRvIHRhcmdldCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gc291cmNlRWxlbWVudFxuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSB0YXJnZXRFbGVtZW50XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwcm9wZXJ0eU5hbWVzXVxuICpcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH1cbiAqL1xuTW9kZGxlQ29weS5wcm90b3R5cGUuY29weUVsZW1lbnQgPSBmdW5jdGlvbihzb3VyY2VFbGVtZW50LCB0YXJnZXRFbGVtZW50LCBwcm9wZXJ0eU5hbWVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAocHJvcGVydHlOYW1lcyAmJiAhaXNBcnJheShwcm9wZXJ0eU5hbWVzKSkge1xuICAgIHByb3BlcnR5TmFtZXMgPSBbIHByb3BlcnR5TmFtZXMgXTtcbiAgfVxuXG4gIHByb3BlcnR5TmFtZXMgPSBwcm9wZXJ0eU5hbWVzIHx8IGdldFByb3BlcnR5TmFtZXMoc291cmNlRWxlbWVudC4kZGVzY3JpcHRvcik7XG5cbiAgdmFyIGNhbkNvcHlQcm9wZXJ0aWVzID0gdGhpcy5fZXZlbnRCdXMuZmlyZSgnbW9kZGxlQ29weS5jYW5Db3B5UHJvcGVydGllcycsIHtcbiAgICBwcm9wZXJ0eU5hbWVzOiBwcm9wZXJ0eU5hbWVzLFxuICAgIHNvdXJjZUVsZW1lbnQ6IHNvdXJjZUVsZW1lbnQsXG4gICAgdGFyZ2V0RWxlbWVudDogdGFyZ2V0RWxlbWVudFxuICB9KTtcblxuICBpZiAoY2FuQ29weVByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRhcmdldEVsZW1lbnQ7XG4gIH1cblxuICBpZiAoaXNBcnJheShjYW5Db3B5UHJvcGVydGllcykpIHtcbiAgICBwcm9wZXJ0eU5hbWVzID0gY2FuQ29weVByb3BlcnRpZXM7XG4gIH1cblxuICAvLyBjb3B5IHByb3BlcnRpZXNcbiAgZm9yRWFjaChwcm9wZXJ0eU5hbWVzLCBmdW5jdGlvbihwcm9wZXJ0eU5hbWUpIHtcbiAgICB2YXIgc291cmNlUHJvcGVydHk7XG5cbiAgICBpZiAoaGFzKHNvdXJjZUVsZW1lbnQsIHByb3BlcnR5TmFtZSkpIHtcbiAgICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlRWxlbWVudC5nZXQocHJvcGVydHlOYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgY29waWVkUHJvcGVydHkgPSBzZWxmLmNvcHlQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0RWxlbWVudCwgcHJvcGVydHlOYW1lKTtcblxuICAgIHZhciBjYW5TZXRQcm9wZXJ0eSA9IHNlbGYuX2V2ZW50QnVzLmZpcmUoJ21vZGRsZUNvcHkuY2FuU2V0Q29waWVkUHJvcGVydHknLCB7XG4gICAgICBwYXJlbnQ6IHRhcmdldEVsZW1lbnQsXG4gICAgICBwcm9wZXJ0eTogY29waWVkUHJvcGVydHksXG4gICAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZVxuICAgIH0pO1xuXG4gICAgaWYgKGNhblNldFByb3BlcnR5ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0RlZmluZWQoY29waWVkUHJvcGVydHkpKSB7XG4gICAgICB0YXJnZXRFbGVtZW50LnNldChwcm9wZXJ0eU5hbWUsIGNvcGllZFByb3BlcnR5KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXRFbGVtZW50O1xufTtcblxuLyoqXG4gKiBDb3B5IG1vZGVsIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7Kn0gcHJvcGVydHlcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbk1vZGRsZUNvcHkucHJvdG90eXBlLmNvcHlQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3BlcnR5LCBwYXJlbnQsIHByb3BlcnR5TmFtZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gYWxsb3cgb3RoZXJzIHRvIGNvcHkgcHJvcGVydHlcbiAgdmFyIGNvcGllZFByb3BlcnR5ID0gdGhpcy5fZXZlbnRCdXMuZmlyZSgnbW9kZGxlQ29weS5jYW5Db3B5UHJvcGVydHknLCB7XG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lXG4gIH0pO1xuXG4gIC8vIHJldHVybiBpZiBjb3B5aW5nIGlzIE5PVCBhbGxvd2VkXG4gIGlmIChjb3BpZWRQcm9wZXJ0eSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29waWVkUHJvcGVydHkpIHtcbiAgICBpZiAoaXNPYmplY3QoY29waWVkUHJvcGVydHkpICYmIGNvcGllZFByb3BlcnR5LiR0eXBlICYmICFjb3BpZWRQcm9wZXJ0eS4kcGFyZW50KSB7XG4gICAgICBjb3BpZWRQcm9wZXJ0eS4kcGFyZW50ID0gcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBjb3BpZWRQcm9wZXJ0eTtcbiAgfVxuXG4gIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSB0aGlzLl9tb2RkbGUuZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgcHJvcGVydHlOYW1lKTtcblxuICAvLyBkbyBOT1QgY29weSBJZHMgYW5kIHJlZmVyZW5jZXNcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5pc0lkIHx8IHByb3BlcnR5RGVzY3JpcHRvci5pc1JlZmVyZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNvcHkgYXJyYXlzXG4gIGlmIChpc0FycmF5KHByb3BlcnR5KSkge1xuICAgIHJldHVybiByZWR1Y2UocHJvcGVydHksIGZ1bmN0aW9uKGNoaWxkUHJvcGVydGllcywgY2hpbGRQcm9wZXJ0eSkge1xuXG4gICAgICAvLyByZWN1cnNpb25cbiAgICAgIGNvcGllZFByb3BlcnR5ID0gc2VsZi5jb3B5UHJvcGVydHkoY2hpbGRQcm9wZXJ0eSwgcGFyZW50LCBwcm9wZXJ0eU5hbWUpO1xuXG4gICAgICAvLyBjb3B5aW5nIG1pZ2h0IE5PVCBiZSBhbGxvd2VkXG4gICAgICBpZiAoY29waWVkUHJvcGVydHkpIHtcbiAgICAgICAgY29waWVkUHJvcGVydHkuJHBhcmVudCA9IHBhcmVudDtcblxuICAgICAgICByZXR1cm4gY2hpbGRQcm9wZXJ0aWVzLmNvbmNhdChjb3BpZWRQcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGlsZFByb3BlcnRpZXM7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgLy8gY29weSBtb2RlbCBlbGVtZW50c1xuICBpZiAoaXNPYmplY3QocHJvcGVydHkpICYmIHByb3BlcnR5LiR0eXBlKSB7XG4gICAgaWYgKHRoaXMuX21vZGRsZS5nZXRFbGVtZW50RGVzY3JpcHRvcihwcm9wZXJ0eSkuaXNHZW5lcmljKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29waWVkUHJvcGVydHkgPSBzZWxmLl9wb3N0aXRGYWN0b3J5LmNyZWF0ZShwcm9wZXJ0eS4kdHlwZSk7XG5cbiAgICBjb3BpZWRQcm9wZXJ0eS4kcGFyZW50ID0gcGFyZW50O1xuXG4gICAgLy8gcmVjdXJzaW9uXG4gICAgY29waWVkUHJvcGVydHkgPSBzZWxmLmNvcHlFbGVtZW50KHByb3BlcnR5LCBjb3BpZWRQcm9wZXJ0eSk7XG5cbiAgICByZXR1cm4gY29waWVkUHJvcGVydHk7XG4gIH1cblxuICAvLyBjb3B5IHByaW1pdGl2ZSBwcm9wZXJ0aWVzXG4gIHJldHVybiBwcm9wZXJ0eTtcbn07XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvcGVydHlOYW1lcyhkZXNjcmlwdG9yLCBrZWVwRGVmYXVsdFByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIHJlZHVjZShkZXNjcmlwdG9yLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnRpZXMsIHByb3BlcnR5KSB7XG5cbiAgICBpZiAoa2VlcERlZmF1bHRQcm9wZXJ0aWVzICYmIHByb3BlcnR5LmRlZmF1bHQpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wZXJ0aWVzLmNvbmNhdChwcm9wZXJ0eS5uYW1lKTtcbiAgfSwgW10pO1xufSIsImltcG9ydCB7XG4gIGdldEJ1c2luZXNzT2JqZWN0XG59IGZyb20gJy4uLy4uL3V0aWwvTW9kZWxVdGlsJztcblxuaW1wb3J0IHtcbiAgZm9yRWFjaCxcbiAgaXNBcnJheSxcbiAgaXNVbmRlZmluZWQsXG4gIG9taXQsXG4gIHJlZHVjZVxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmZ1bmN0aW9uIGNvcHlQcm9wZXJ0aWVzKHNvdXJjZSwgdGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIGlmICghaXNBcnJheShwcm9wZXJ0aWVzKSkge1xuICAgIHByb3BlcnRpZXMgPSBbIHByb3BlcnRpZXMgXTtcbiAgfVxuXG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHNvdXJjZVtwcm9wZXJ0eV0pKSB7XG4gICAgICB0YXJnZXRbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVQcm9wZXJ0aWVzKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgaWYgKCFpc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgcHJvcGVydGllcyA9IFsgcHJvcGVydGllcyBdO1xuICB9XG5cbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIGlmIChlbGVtZW50W3Byb3BlcnR5XSkge1xuICAgICAgZGVsZXRlIGVsZW1lbnRbcHJvcGVydHldO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBMT1dfUFJJT1JJVFkgPSA3NTA7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0Q29weVBhc3RlKHBvc3RpdEZhY3RvcnksIGV2ZW50QnVzLCBtb2RkbGVDb3B5KSB7XG5cbiAgZXZlbnRCdXMub24oJ2NvcHlQYXN0ZS5jb3B5RWxlbWVudCcsIExPV19QUklPUklUWSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gY29udGV4dC5kZXNjcmlwdG9yLFxuICAgICAgICBlbGVtZW50ID0gY29udGV4dC5lbGVtZW50O1xuXG4gICAgdmFyIGJ1c2luZXNzT2JqZWN0ID0gZGVzY3JpcHRvci5vbGRCdXNpbmVzc09iamVjdCA9IGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpO1xuXG4gICAgZGVzY3JpcHRvci50eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgY29weVByb3BlcnRpZXMoYnVzaW5lc3NPYmplY3QsIGRlc2NyaXB0b3IsICduYW1lJyk7XG5cbiAgICBkZXNjcmlwdG9yLmRpID0ge307XG5cbiAgICAvLyBmaWxsIGFuZCBzdHJva2Ugd2lsbCBiZSBzZXQgdG8gRElcbiAgICBjb3B5UHJvcGVydGllcyhidXNpbmVzc09iamVjdC5kaSwgZGVzY3JpcHRvci5kaSwgW1xuICAgICAgJ2ZpbGwnLFxuICAgICAgJ3N0cm9rZSdcbiAgICBdKTtcblxuICAgIGlmIChpc0xhYmVsKGRlc2NyaXB0b3IpKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9XG5cbiAgfSk7XG5cbiAgdmFyIHJlZmVyZW5jZXM7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZXMoZGVzY3JpcHRvciwgY2FjaGUpIHtcbiAgICB2YXIgYnVzaW5lc3NPYmplY3QgPSBnZXRCdXNpbmVzc09iamVjdChkZXNjcmlwdG9yKTtcblxuICAgIC8vIGRlZmF1bHQgc2VxdWVuY2UgZmxvd3NcbiAgICBpZiAoZGVzY3JpcHRvci5kZWZhdWx0KSB7XG5cbiAgICAgIC8vIHJlbGF0aW9uc2hpcCBjYW5ub3QgYmUgcmVzb2x2ZWQgaW1tZWRpYXRlbHlcbiAgICAgIHJlZmVyZW5jZXNbIGRlc2NyaXB0b3IuZGVmYXVsdCBdID0ge1xuICAgICAgICBlbGVtZW50OiBidXNpbmVzc09iamVjdCxcbiAgICAgICAgcHJvcGVydHk6ICdkZWZhdWx0J1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZWZlcmVuY2VzID0gb21pdChyZWZlcmVuY2VzLCByZWR1Y2UocmVmZXJlbmNlcywgZnVuY3Rpb24oYXJyYXksIHJlZmVyZW5jZSwga2V5KSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHJlZmVyZW5jZS5lbGVtZW50LFxuICAgICAgICAgIHByb3BlcnR5ID0gcmVmZXJlbmNlLnByb3BlcnR5O1xuXG4gICAgICBpZiAoa2V5ID09PSBkZXNjcmlwdG9yLmlkKSB7XG4gICAgICAgIGVsZW1lbnRbIHByb3BlcnR5IF0gPSBidXNpbmVzc09iamVjdDtcblxuICAgICAgICBhcnJheS5wdXNoKGRlc2NyaXB0b3IuaWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSwgW10pKTtcbiAgfVxuXG4gIGV2ZW50QnVzLm9uKCdjb3B5UGFzdGUucGFzdGVFbGVtZW50cycsIGZ1bmN0aW9uKCkge1xuICAgIHJlZmVyZW5jZXMgPSB7fTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2NvcHlQYXN0ZS5wYXN0ZUVsZW1lbnQnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIGNhY2hlID0gY29udGV4dC5jYWNoZSxcbiAgICAgICAgZGVzY3JpcHRvciA9IGNvbnRleHQuZGVzY3JpcHRvcixcbiAgICAgICAgb2xkQnVzaW5lc3NPYmplY3QgPSBkZXNjcmlwdG9yLm9sZEJ1c2luZXNzT2JqZWN0LFxuICAgICAgICBuZXdCdXNpbmVzc09iamVjdDtcblxuICAgIC8vIGRvIE5PVCBjb3B5IGJ1c2luZXNzIG9iamVjdCBpZiBleHRlcm5hbCBsYWJlbFxuICAgIGlmIChpc0xhYmVsKGRlc2NyaXB0b3IpKSB7XG4gICAgICBkZXNjcmlwdG9yLmJ1c2luZXNzT2JqZWN0ID0gZ2V0QnVzaW5lc3NPYmplY3QoY2FjaGVbIGRlc2NyaXB0b3IubGFiZWxUYXJnZXQgXSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXdCdXNpbmVzc09iamVjdCA9IHBvc3RpdEZhY3RvcnkuY3JlYXRlKG9sZEJ1c2luZXNzT2JqZWN0LiR0eXBlKTtcblxuICAgIGRlc2NyaXB0b3IuYnVzaW5lc3NPYmplY3QgPSBtb2RkbGVDb3B5LmNvcHlFbGVtZW50KFxuICAgICAgb2xkQnVzaW5lc3NPYmplY3QsXG4gICAgICBuZXdCdXNpbmVzc09iamVjdFxuICAgICk7XG5cbiAgICAvLyByZXNvbHZlIHJlZmVyZW5jZXMgZS5nLiBkZWZhdWx0IHNlcXVlbmNlIGZsb3dcbiAgICByZXNvbHZlUmVmZXJlbmNlcyhkZXNjcmlwdG9yLCBjYWNoZSk7XG5cbiAgICBjb3B5UHJvcGVydGllcyhkZXNjcmlwdG9yLCBuZXdCdXNpbmVzc09iamVjdCwgW1xuICAgICAgJ2NvbG9yJyxcbiAgICAgICduYW1lJ1xuICAgIF0pO1xuXG4gICAgcmVtb3ZlUHJvcGVydGllcyhkZXNjcmlwdG9yLCAnb2xkQnVzaW5lc3NPYmplY3QnKTtcbiAgfSk7XG5cbn1cblxuXG5Qb3N0aXRDb3B5UGFzdGUuJGluamVjdCA9IFtcbiAgJ3Bvc3RpdEZhY3RvcnknLFxuICAnZXZlbnRCdXMnLFxuICAnbW9kZGxlQ29weSdcbl07XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc0xhYmVsKGVsZW1lbnQpIHtcbiAgcmV0dXJuICEhZWxlbWVudC5sYWJlbFRhcmdldDtcbn1cbiIsImltcG9ydCBDb3B5UGFzdGVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY29weS1wYXN0ZSc7XG5cbmltcG9ydCBQb3N0aXRDb3B5UGFzdGUgZnJvbSAnLi9Qb3N0aXRDb3B5UGFzdGUnO1xuaW1wb3J0IE1vZGRsZUNvcHkgZnJvbSAnLi9Nb2RkbGVDb3B5JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIENvcHlQYXN0ZU1vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAncG9zdGl0Q29weVBhc3RlJywgJ21vZGRsZUNvcHknIF0sXG4gIHBvc3RpdENvcHlQYXN0ZTogWyAndHlwZScsIFBvc3RpdENvcHlQYXN0ZSBdLFxuICBtb2RkbGVDb3B5OiBbICd0eXBlJywgTW9kZGxlQ29weSBdXG59O1xuIiwiaW1wb3J0IHsgZ2V0RGkgfSBmcm9tICcuLi8uLi9kcmF3L1Bvc3RpdFJlbmRlcmVyVXRpbCc7XG5pbXBvcnQgeyBnZXRCdXNpbmVzc09iamVjdCB9IGZyb20gJy4uLy4uL3V0aWwvTW9kZWxVdGlsJztcblxuaW1wb3J0IHtcbiAgZmlsdGVyLFxuICBtYXBcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgeyBzZWxmQW5kQWxsQ2hpbGRyZW4gfSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL0VsZW1lbnRzJztcblxuXG52YXIgSElHSF9QUklPUklUWSA9IDIwMDA7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvc3RpdERpT3JkZXJpbmcoZXZlbnRCdXMsIGNhbnZhcykge1xuXG4gIGV2ZW50QnVzLm9uKCdzYXZlWE1MLnN0YXJ0JywgSElHSF9QUklPUklUWSwgb3JkZXJEaSk7XG5cbiAgZnVuY3Rpb24gb3JkZXJEaSgpIHtcbiAgICB2YXIgcm9vdCA9IGNhbnZhcy5nZXRSb290RWxlbWVudCgpLFxuICAgICAgICByb290RGkgPSBnZXRCdXNpbmVzc09iamVjdChyb290KS5kaSxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIGRpRWxlbWVudHM7XG5cbiAgICBlbGVtZW50cyA9IHNlbGZBbmRBbGxDaGlsZHJlbihbIHJvb3QgXSwgZmFsc2UpO1xuXG4gICAgLy8gb25seSBwb3N0aXREaTpTaGFwZSBjYW4gYmUgZGlyZWN0IGNoaWxkcmVuIG9mIHBvc3RpdERpOlBsYW5lXG4gICAgZWxlbWVudHMgPSBmaWx0ZXIoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50ICE9PSByb290ICYmICFlbGVtZW50LmxhYmVsVGFyZ2V0O1xuICAgIH0pO1xuXG4gICAgZGlFbGVtZW50cyA9IG1hcChlbGVtZW50cywgZ2V0RGkpO1xuXG4gICAgcm9vdERpLnNldCgncGxhbmVFbGVtZW50JywgZGlFbGVtZW50cyk7XG4gIH1cbn1cblxuUG9zdGl0RGlPcmRlcmluZy4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnLCAnY2FudmFzJyBdO1xuIiwiaW1wb3J0IFBvc3RpdERpT3JkZXJpbmcgZnJvbSAnLi9Qb3N0aXREaU9yZGVyaW5nJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogW1xuICAgICdwb3N0aXREaU9yZGVyaW5nJ1xuICBdLFxuICBwb3N0aXREaU9yZGVyaW5nOiBbICd0eXBlJywgUG9zdGl0RGlPcmRlcmluZyBdXG59OyIsImltcG9ydCB7XG4gIGRvbWlmeSxcbiAgZXZlbnQgYXMgZG9tRXZlbnRcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGZpbGVSZWFkZXJcbn0gZnJvbSAnLi9GaWxlVXRpbC5qcyc7XG5cbi8qIGNvbnN0YW50cyAqL1xuY29uc3QgUE9TVElUX0lNQUdFID0gJ3Bvc3RpdDpJbWFnZSc7XG5mdW5jdGlvbiByYW5kU3RyKGxlbmd0aD01KSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNoYXJhY3RlcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICB2YXIgY2hhcmFjdGVyc0xlbmd0aCA9IGNoYXJhY3RlcnMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnNMZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgRU5UUllfUFJPVE9UWVBFID0gKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIG9iaklkOiByYW5kU3RyKCksXG4gICAgb2JqVHlwZTogUE9TVElUX0lNQUdFLFxuICAgIG9ialRpdGxlOiAnJyxcbiAgICBvYmpEZXNjcmlwdGlvbjogJycsXG4gICAgb2JqU3RhcnJlZDogZmFsc2UsXG4gICAgb2JqSGlkZGVuOiBmYWxzZSxcbiAgICBvYmpVbmtleWVkOiBmYWxzZSxcbiAgICBvYmpVbmtleWVkT3JpZ2luYWw6IGZhbHNlLFxuICAgIG9ialNyY1Vua2V5ZWQ6ICcnLFxuICAgIG9iakNyZWF0aW9uRGF0ZTogJycsXG4gICAgc291cmNlOiAnJyxcbiAgICBvYmpQb3NpdGlvblg6IG51bGwsXG4gICAgb2JqUG9zaXRpb25ZOiBudWxsLFxuICB9O1xufTtcblxuLyogY29uc3RhbnRzICovXG5cblxudmFyIHRleHQ7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEcmFnRHJvcEltYWdlcyhldmVudEJ1cywgY2FudmFzLCBtb2RlbGluZywgZWxlbWVudEZhY3RvcnksIGNyZWF0ZSwgdHJhbnNsYXRlKSB7XG5cbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuICB0aGlzLl9lbGVtZW50RmFjdG9yeSA9IGVsZW1lbnRGYWN0b3J5O1xuICB0aGlzLl9jcmVhdGUgPSBjcmVhdGU7XG4gIHRoaXMuX3RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcblxuICB0ZXh0ID0geyAnVVJMJzogdGhpcy5fdHJhbnNsYXRlKCdVUkwnKSxcbiAgICAnQW4gZXJyb3Igb2NjdXJlZCBkdXJpbmcgdGhlIGZpbGUgdXBsb2FkJzogdGhpcy5fdHJhbnNsYXRlKCdBbiBlcnJvciBvY2N1cmVkIGR1cmluZyB0aGUgZmlsZSB1cGxvYWQnKSxcbiAgICAnVXBsb2FkIGZpbGVzIGhlcmUnOiB0aGlzLl90cmFuc2xhdGUoJ1VwbG9hZCBmaWxlcyBoZXJlJyksXG4gICAgJ1VwbG9hZCBmcm9tIGxvY2FsIGlzIGZvciBkZW1vIHB1cnBvc2VzIG9ubHkuIEl0IHNsb3dzIGRvd24gdGhlIHBhZ2UgYW5kIGluY3JlYXNlcyB0aGUgZmlsZSBzaXplLic6IHRoaXMuX3RyYW5zbGF0ZSgnVXBsb2FkIGZyb20gbG9jYWwgaXMgZm9yIGRlbW8gcHVycG9zZXMgb25seS4gSXQgc2xvd3MgZG93biB0aGUgcGFnZSBhbmQgaW5jcmVhc2VzIHRoZSBmaWxlIHNpemUuJyksXG4gICAgJ3VwbG9hZGVkJzogdGhpcy5fdHJhbnNsYXRlKCd1cGxvYWRlZCcpLFxuICAgICdmaWxlJzogdGhpcy5fdHJhbnNsYXRlKCdmaWxlJyksXG4gICAgJ2ZpbGVzJzogdGhpcy5fdHJhbnNsYXRlKCdmaWxlcycpLFxuICAgICdzZWxlY3RlZCc6IHRoaXMuX3RyYW5zbGF0ZSgnc2VsZWN0ZWQnKSxcbiAgICAnVXBsb2FkIGFnYWluJzogdGhpcy5fdHJhbnNsYXRlKCdVcGxvYWQgYWdhaW4nKSxcbiAgICAnRHJhZyBoZXJlJzogdGhpcy5fdHJhbnNsYXRlKCdEcmFnIGhlcmUnKSxcbiAgfTtcblxuICBEcmFnRHJvcEltYWdlcy5DU1MgPSBgXG4gICAgLnBqcy12aXNpYmxlIHtcbiAgICAgIHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcbiAgICAgIGRpc3BsYXk6IGJsb2NrICFpbXBvcnRhbnQ7XG4gICAgfVxuICAgIFxuICAgICNwanMtZHJvcC16b25lIHtcbiAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzU1NTU1NTtcbiAgICAgIHotaW5kZXg6IDE7XG4gICAgICBvcGFjaXR5OiAwLjk7XG4gICAgfVxuXG4gICAgI3Bqcy1kcm9wLXpvbmUtYm9yZGVyIHtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEwcHggMTBweCAxMHB4IDEwcHg7XG4gICAgICAtbW96LWJvcmRlci1yYWRpdXM6IDEwcHggMTBweCAxMHB4IDEwcHg7XG4gICAgICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDEwcHggMTBweCAxMHB4IDEwcHg7XG4gICAgICBib3JkZXI6IDVweCBkYXNoZWQgIzAwMDAwMDtcbiAgICAgIHotaW5kZXg6IDI7XG4gICAgICBkaXNwbGF5OiB0YWJsZTtcbiAgICAgIHdpZHRoOiA5OC45JTtcbiAgICAgIGhlaWdodDogMTAwJTsgXG4gICAgfVxuXG4gICAgLnBqcy1kcm9wLXpvbmUtdGV4dCB7XG4gICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBmb250LXNpemU6IDI1cHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIG1hcmdpbjogMCBhdXRvO1xuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgZGlzcGxheTogdGFibGUtY2VsbDtcbiAgfWA7XG5cbiAgRHJhZ0Ryb3BJbWFnZXMuSFRNTF9NQVJLVVAgPSAnPGRpdiBpZD1cInBqcy1kcm9wLXpvbmVcIj4nK1xuICAgICAgICAnPGRpdiBpZD1cInBqcy1kcm9wLXpvbmUtYm9yZGVyXCI+JytcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cInBqcy1kcm9wLXpvbmUtdGV4dFwiPicrXG4gICAgICAgICAgdGV4dFsnRHJhZyBoZXJlJ10rXG4gICAgICAgICc8L2Rpdj4nK1xuICAgICAgJzwvZGl2PicrXG4gICc8L2Rpdj4nO1xuXG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICBzdHlsZS5pbm5lckhUTUwgPSBEcmFnRHJvcEltYWdlcy5DU1M7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdIRUFEJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXG4gIGNvbnN0IGNhbnZhc0RPTSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub3RlQ2FudmFzJyk7XG5cbiAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9taWZ5KERyYWdEcm9wSW1hZ2VzLkhUTUxfTUFSS1VQKTtcbiAgY2FudmFzRE9NLmluc2VydEJlZm9yZShjb250YWluZXIsIGNhbnZhcy5maXJzdENoaWxkKTtcblxuICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdHMoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZG9tRXZlbnQuYmluZChjYW52YXNET00sICdkcmFnJywgZnVuY3Rpb24oZXYpIHtcbiAgfSwgZmFsc2UpO1xuICBkb21FdmVudC5iaW5kKGNhbnZhc0RPTSwgJ2RyYWdzdGFydCcsIGZ1bmN0aW9uKGV2KSB7XG4gIH0sIGZhbHNlKTtcbiAgZG9tRXZlbnQuYmluZChjYW52YXNET00sICdkcmFnZW5kJywgZnVuY3Rpb24oZXYpIHtcbiAgfSwgZmFsc2UpO1xuICBkb21FdmVudC5iaW5kKGNhbnZhc0RPTSwgJ2RyYWdvdmVyJywgZnVuY3Rpb24oZXYpIHtcbiAgICBwcmV2ZW50RGVmYXVsdHMoZXYpO1xuICB9LCBmYWxzZSk7XG4gIGRvbUV2ZW50LmJpbmQoY2FudmFzRE9NLCAnZHJhZ2VudGVyJywgZnVuY3Rpb24oZXYpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGpzLWRyb3Atem9uZScpLmNsYXNzTGlzdC5hZGQoJ3Bqcy12aXNpYmxlJyk7XG4gIH0sIGZhbHNlKTtcbiAgZG9tRXZlbnQuYmluZChjYW52YXNET00sJ2RyYWdsZWF2ZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bqcy1kcm9wLXpvbmUnKS5jbGFzc0xpc3QucmVtb3ZlKCdwanMtdmlzaWJsZScpO1xuICB9LCBmYWxzZSk7XG4gIGRvbUV2ZW50LmJpbmQoY2FudmFzRE9NLCAnZHJvcCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgcHJldmVudERlZmF1bHRzKGV2KTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGpzLWRyb3Atem9uZScpLmNsYXNzTGlzdC5yZW1vdmUoJ3Bqcy12aXNpYmxlJyk7XG4gICAgdXBsb2FkRmlsZXMoZXYpO1xuICB9LCBmYWxzZSk7XG5cblxuICBhc3luYyBmdW5jdGlvbiB1cGxvYWRGaWxlcyhldikge1xuICAgIGxldCB1cGxvYWREaXNwbGF5VGV4dDtcbiAgICBsZXQgdXBsb2FkUmVzdWx0T2JqID0gYXdhaXQgZmlsZVJlYWRlcihldiwgbnVsbCk7XG4gICAgbGV0IHVwbG9hZFJlc3VsdCA9IHVwbG9hZFJlc3VsdE9iai5yZXN1bHRzO1xuICAgIGxldCBlcnJvcnMgPSB1cGxvYWRSZXN1bHRPYmouZXJyb3JzO1xuICAgIGlmICghZXJyb3JzKSB7XG4gICAgICBsZXQgdXBsb2FkZWRGaWxlc0NvdW50ID0gKHVwbG9hZFJlc3VsdC5sZW5ndGgpID8gdXBsb2FkUmVzdWx0Lmxlbmd0aCA6IG51bGw7XG4gICAgICB1cGxvYWREaXNwbGF5VGV4dCA9IHVwbG9hZGVkRmlsZXNDb3VudDtcbiAgICAgIGlmIChpc05hTih1cGxvYWRlZEZpbGVzQ291bnQpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBmaWxlUGx1cmFsVGV4dCA9KyAodXBsb2FkUmVzdWx0Lmxlbmd0aCA9PSAxKSA/IHRleHRbJ2ZpbGUnXSA6IHRleHRbJ2ZpbGVzJ107XG4gICAgICAgIHVwbG9hZERpc3BsYXlUZXh0ICs9ICcgJyArIGZpbGVQbHVyYWxUZXh0ICsgJyAnICsgdGV4dFsndXBsb2FkZWQnXTtcbiAgICAgIH1cbiAgICAgIGxldCBpID0gdXBsb2FkUmVzdWx0Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYXdhaXQgY3JlYXRlSW1hZ2VFbGVtZW50KGV2LCBjb252ZXJ0VG9FbnRyeSh7IHNvdXJjZTogdXBsb2FkUmVzdWx0W2ldIH0pKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKHVwbG9hZERpc3BsYXlUZXh0KTtcblxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUltYWdlRWxlbWVudChldmVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IFtdO1xuXG4gICAgdmFyIHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgdmFyIHNfa2V5ID0gdXJsUGFyYW1zLmdldCgnc19rZXknKTtcbiAgICBpZiggc19rZXkgPT09IG51bGwgKSB7XG4gICAgICBzaGVwaGVyZEFsZXJ0KFwiU2NyaXB0IFJlcXVpcmVkXCIsIFwiWW91IG11c3Qgb3BlbiBhIHNjcmlwdCBiZWZvcmUgeW91IGNhbiB0YWtlIG5vdGVzIVwiKVxuICAgICAgcmV0dXJuIHsgLi4uRU5UUllfUFJPVE9UWVBFKCksIC4uLm9wdGlvbnMgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGltYWdlLCBibG9iO1xuICAgICAgYmxvYiA9IG9wdGlvbnMuc291cmNlO1xuXG4gICAgICAvLyBVZ2x5IGJlY2F1c2Ugd2UgZXhwZWN0IHRoaXMgVVJMIHRvIGV4aXN0IG9uIHRoZSBwYWdlLlxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyBBY3RpdmVTdG9yYWdlLkRpcmVjdFVwbG9hZChcbiAgICAgICAgYmxvYixcbiAgICAgICAgZGlyZWN0X3VwbG9hZF91cmxcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHVwbG9hZC5jcmVhdGUoZnVuY3Rpb24oZXJyb3IsIGJsb2IpIHtcbiAgICAgICAgaWYoIGVycm9yICE9PSBudWxsICkge1xuICAgICAgICAgIGlmKCBlcnJvci5zZWFyY2goXCJTdGF0dXM6IDQwM1wiKSA+PSAwICkge1xuICAgICAgICAgICAgc2hlcGhlcmRBbGVydChcIlN1YnNjcmlwdGlvbiBOZWVkZWQhXCIsIFwiWW91IG11c3QgaGF2ZSBhbiBhY3RpdmUgc3Vic2NyaXB0aW9uIHRvIHNhdmUgaW1hZ2VzISBZb3UgY2FuIHNpZ24gdXAgPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cXFwibW9kYWxcXFwiIGhyZWY9XFxcIiNzdWJzY3JpcHRpb25Nb2RhbFxcXCIgb25jbGljaz1cXFwiU2hlcGhlcmQuYWN0aXZlVG91ci5jb21wbGV0ZSgpOyAkKCcjaWRlYXRvck5vdGVzTW9kYWwnKS5tb2RhbCgnaGlkZScpO1xcXCIgZGF0YS1kZXNjcmlwdGlvbj1cXFwiU2lnbiB1cCBmb3IgaW1hZ2UgdXBsb2FkaW5nIGFuZCBvdGhlciBncmVhdCBmZWF0dWVycyFcXFwiIGRhdGEtcmVzZXQ9XFxcIiQoJyNpZGVhdG9yTm90ZXNNb2RhbCcpLm1vZGFsKFxcJ3Nob3dcXCcpO1xcXCIgc3R5bGU9XFxcImNvbG9yOiBibHVlOyBtYXJnaW4tbGVmdDogLTZweDsgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxcIj5oZXJlITwvYnV0dG9uPlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hlcGhlcmRBbGVydChcIlVua25vd24gRXJyb3JcIiwgXCJXZSd2ZSBsb2dnZWQgdGhpcyBpc3N1ZS4gIElmIGl0IGNvbnRpbnVlcywgcGxlYXNlIHJlYWNoIG91dCB0byBzdXBwb3J0LlwiKTtcbiAgICAgICAgICAgIEJ1Z3NuYWcubm90aWZ5KFwiVW5rbm93biB1cGxvYWQgcmVzcG9uc2U6IFwiICsgYmxvYi50b1N0cmluZygpIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgYnVpbGQgb3VyIGxvY2FsIGNvcHkuXG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZWxlbWVudEZhY3RvcnkuY3JlYXRlU2hhcGUoe1xuICAgICAgICAgIHR5cGU6IFBPU1RJVF9JTUFHRSxcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXR0YWNoID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGhpbnRzID0geyBjcmVhdGVFbGVtZW50c0JlaGF2aW9yOiBmYWxzZSB9O1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHsgeDogZXZlbnQueCArIChNYXRoLnJhbmRvbSgpICogMTAwKSwgeTogZXZlbnQueSArIChNYXRoLnJhbmRvbSgpICogMTAwKSB9O1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9jYW52YXMuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5fbW9kZWxpbmcuY3JlYXRlRWxlbWVudHMoW3NoYXBlXSwgcG9zaXRpb24sIHRhcmdldCwgYXNzaWduKHt9LCBoaW50cywge1xuICAgICAgICAgIGF0dGFjaDogYXR0YWNoLFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYoIGJsb2Iua2V5ICkge1xuXG4gICAgICAgICAgLy8gTm93IHJlZ2lzdGVyIGl0IHdpdGggdGhlIHNlcnZlci5cbiAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignWC1DU1JGLVRva2VuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJ21ldGFbbmFtZT1cImNzcmYtdG9rZW5cIl0nKS5hdHRyKCdjb250ZW50JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVybDogXCIvc2NyaXB0cy9cIiArIHNfa2V5ICsgXCIvaW1hZ2VfdXJsL1wiICsgYmxvYi5rZXksXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgIHNlbGYuX21vZGVsaW5nLnVwZGF0ZVByb3BlcnRpZXMoZWxlbWVudCwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogZGF0YS51cmwsXG4gICAgICAgICAgICAgICAga2V5OiBkYXRhLmtleVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlkOiBzaGFwZS5pZCwgeDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueSwgc2hhcGUsIHdpZHRoOiBzaGFwZS53aWR0aCwgaGVpZ2h0OiBzaGFwZS5oZWlnaHQgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBjb252ZXJ0VG9FbnRyeSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHsgLi4uRU5UUllfUFJPVE9UWVBFKCksIC4uLm9wdGlvbnMgfTtcbn07XG5cbkRyYWdEcm9wSW1hZ2VzLnByb3RvdHlwZS4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ2VsZW1lbnRGYWN0b3J5JyxcbiAgJ2NyZWF0ZScsXG4gICd0cmFuc2xhdGUnXG5dO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGZpbGVUb0RhdGFVUkwoZmlsZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3QoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltYWdlUHJvY2Vzc29yKGV2LCBmaWxlKSB7XG4gIGNvbnN0IGJhc2U2NGZpbGUgPSBhd2FpdCBmaWxlVG9EYXRhVVJMKGZpbGUpO1xuICByZXR1cm4gYmFzZTY0ZmlsZTsgLy8gcGFzc2luZyBhbnkgZXJyb3JzIHRocm91Z2hcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbGVSZWFkZXIoZXYsIGZpbGVzKSB7XG4gIGxldCB1cGxvYWRSZXN1bHQgPSBbXTtcbiAgbGV0IGVycm9ycztcbiAgbGV0IGZpbGVJdGVtcyA9IGZpbGVzO1xuICBpZiAoZXYgJiYgKGV2LmRhdGFUcmFuc2Zlci5pdGVtcyB8fCBldi5kYXRhVHJhbnNmZXIuZmlsZXMpKSB7XG4gICAgZmlsZUl0ZW1zID0gZXYuZGF0YVRyYW5zZmVyLml0ZW1zIHx8IGV2LmRhdGFUcmFuc2Zlci5maWxlcztcbiAgfVxuICB0cnkge1xuICAgIGlmIChmaWxlSXRlbXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChldiAmJiBldi5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgICAgICBpZiAoZmlsZUl0ZW1zW2ldLmtpbmQgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgdmFyIGZpbGUgPSBmaWxlSXRlbXNbaV0uZ2V0QXNGaWxlKCk7XG4gICAgICAgICAgICB1cGxvYWRSZXN1bHQucHVzaChmaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBsb2FkUmVzdWx0LnB1c2goZmlsZUl0ZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9ycyA9IGU7XG4gICAgdXBsb2FkUmVzdWx0ID0gbnVsbDtcbiAgfVxuICBjb25zdCByZXN1bHRzID0gW107XG4gIHZhciBqID0gMDtcbiAgd2hpbGUgKGogPCB1cGxvYWRSZXN1bHQubGVuZ3RoKSB7XG4gICAgY29uc3QgZmlsZUltZyA9IGF3YWl0IGltYWdlUHJvY2Vzc29yKGV2LCB1cGxvYWRSZXN1bHRbal0pO1xuICAgIHJlc3VsdHMucHVzaChmaWxlSW1nKTtcbiAgICBqKz0xO1xuICB9XG4gIHJldHVybiB7IHJlc3VsdHMsIGVycm9ycyB9O1xufVxuXG4iLCJpbXBvcnQgRHJhZ0Ryb3BJbWFnZXMgZnJvbSAnLi9EcmFnRHJvcEltYWdlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ2RyYWdEcm9wSW1hZ2VzJyBdLFxuICBkcmFnRHJvcEltYWdlczogWyAndHlwZScsIERyYWdEcm9wSW1hZ2VzXVxufTtcbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBFZGl0b3JBY3Rpb25zIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2VkaXRvci1hY3Rpb25zL0VkaXRvckFjdGlvbnMnO1xuXG5pbXBvcnQge1xuICBnZXRCQm94XG59IGZyb20gJ2RpYWdyYW0tanMvbGliL3V0aWwvRWxlbWVudHMnO1xuXG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuZCBleGVjdXRlcyBQb3N0aXQgc3BlY2lmaWMgZWRpdG9yIGFjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtJbmplY3Rvcn0gaW5qZWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0RWRpdG9yQWN0aW9ucyhpbmplY3Rvcikge1xuICBpbmplY3Rvci5pbnZva2UoRWRpdG9yQWN0aW9ucywgdGhpcyk7XG59XG5cbmluaGVyaXRzKFBvc3RpdEVkaXRvckFjdGlvbnMsIEVkaXRvckFjdGlvbnMpO1xuXG5Qb3N0aXRFZGl0b3JBY3Rpb25zLiRpbmplY3QgPSBbXG4gICdpbmplY3Rvcidcbl07XG5cbi8qKlxuICogUmVnaXN0ZXIgZGVmYXVsdCBhY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7SW5qZWN0b3J9IGluamVjdG9yXG4gKi9cblBvc3RpdEVkaXRvckFjdGlvbnMucHJvdG90eXBlLl9yZWdpc3RlckRlZmF1bHRBY3Rpb25zID0gZnVuY3Rpb24oaW5qZWN0b3IpIHtcblxuICAvLyAoMCkgaW52b2tlIHN1cGVyIG1ldGhvZFxuXG4gIEVkaXRvckFjdGlvbnMucHJvdG90eXBlLl9yZWdpc3RlckRlZmF1bHRBY3Rpb25zLmNhbGwodGhpcywgaW5qZWN0b3IpO1xuXG4gIC8vICgxKSByZXRyaWV2ZSBvcHRpb25hbCBjb21wb25lbnRzIHRvIGludGVncmF0ZSB3aXRoXG5cbiAgdmFyIGNhbnZhcyA9IGluamVjdG9yLmdldCgnY2FudmFzJywgZmFsc2UpO1xuICB2YXIgZWxlbWVudFJlZ2lzdHJ5ID0gaW5qZWN0b3IuZ2V0KCdlbGVtZW50UmVnaXN0cnknLCBmYWxzZSk7XG4gIHZhciBzZWxlY3Rpb24gPSBpbmplY3Rvci5nZXQoJ3NlbGVjdGlvbicsIGZhbHNlKTtcbiAgdmFyIHNwYWNlVG9vbCA9IGluamVjdG9yLmdldCgnc3BhY2VUb29sJywgZmFsc2UpO1xuICB2YXIgbGFzc29Ub29sID0gaW5qZWN0b3IuZ2V0KCdsYXNzb1Rvb2wnLCBmYWxzZSk7XG4gIHZhciBoYW5kVG9vbCA9IGluamVjdG9yLmdldCgnaGFuZFRvb2wnLCBmYWxzZSk7XG4gIHZhciBkaXN0cmlidXRlRWxlbWVudHMgPSBpbmplY3Rvci5nZXQoJ2Rpc3RyaWJ1dGVFbGVtZW50cycsIGZhbHNlKTtcbiAgdmFyIGFsaWduRWxlbWVudHMgPSBpbmplY3Rvci5nZXQoJ2FsaWduRWxlbWVudHMnLCBmYWxzZSk7XG4gIHZhciBkaXJlY3RFZGl0aW5nID0gaW5qZWN0b3IuZ2V0KCdkaXJlY3RFZGl0aW5nJywgZmFsc2UpO1xuICB2YXIgc2VhcmNoUGFkID0gaW5qZWN0b3IuZ2V0KCdzZWFyY2hQYWQnLCBmYWxzZSk7XG4gIHZhciBtb2RlbGluZyA9IGluamVjdG9yLmdldCgnbW9kZWxpbmcnLCBmYWxzZSk7XG5cbiAgLy8gKDIpIGNoZWNrIGNvbXBvbmVudHMgYW5kIHJlZ2lzdGVyIGFjdGlvbnNcblxuICBpZiAoY2FudmFzICYmIGVsZW1lbnRSZWdpc3RyeSAmJiBzZWxlY3Rpb24pIHtcbiAgICB0aGlzLl9yZWdpc3RlckFjdGlvbignc2VsZWN0RWxlbWVudHMnLCBmdW5jdGlvbigpIHtcblxuICAgICAgLy8gc2VsZWN0IGFsbCBlbGVtZW50cyBleGNlcHQgZm9yIHRoZSBpbnZpc2libGVcbiAgICAgIC8vIHJvb3QgZWxlbWVudFxuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gY2FudmFzLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IGVsZW1lbnRSZWdpc3RyeS5maWx0ZXIoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudCAhPT0gcm9vdEVsZW1lbnQ7XG4gICAgICB9KTtcblxuICAgICAgc2VsZWN0aW9uLnNlbGVjdChlbGVtZW50cyk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzcGFjZVRvb2wpIHtcbiAgICB0aGlzLl9yZWdpc3RlckFjdGlvbignc3BhY2VUb29sJywgZnVuY3Rpb24oKSB7XG4gICAgICBzcGFjZVRvb2wudG9nZ2xlKCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAobGFzc29Ub29sKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJBY3Rpb24oJ2xhc3NvVG9vbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgbGFzc29Ub29sLnRvZ2dsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGhhbmRUb29sKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJBY3Rpb24oJ2hhbmRUb29sJywgZnVuY3Rpb24oKSB7XG4gICAgICBoYW5kVG9vbC50b2dnbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzZWxlY3Rpb24gJiYgZGlzdHJpYnV0ZUVsZW1lbnRzKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJBY3Rpb24oJ2Rpc3RyaWJ1dGVFbGVtZW50cycsIGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gc2VsZWN0aW9uLmdldCgpLFxuICAgICAgICAgIHR5cGUgPSBvcHRzLnR5cGU7XG5cbiAgICAgIGlmIChjdXJyZW50U2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICBkaXN0cmlidXRlRWxlbWVudHMudHJpZ2dlcihjdXJyZW50U2VsZWN0aW9uLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzZWxlY3Rpb24gJiYgYWxpZ25FbGVtZW50cykge1xuICAgIHRoaXMuX3JlZ2lzdGVyQWN0aW9uKCdhbGlnbkVsZW1lbnRzJywgZnVuY3Rpb24ob3B0cykge1xuICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBzZWxlY3Rpb24uZ2V0KCksXG4gICAgICAgICAgdHlwZSA9IG9wdHMudHlwZTtcblxuICAgICAgaWYgKGN1cnJlbnRTZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgIGFsaWduRWxlbWVudHMudHJpZ2dlcihjdXJyZW50U2VsZWN0aW9uLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzZWxlY3Rpb24gJiYgbW9kZWxpbmcpIHtcbiAgICB0aGlzLl9yZWdpc3RlckFjdGlvbignc2V0Q29sb3InLCBmdW5jdGlvbihvcHRzKSB7XG4gICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IHNlbGVjdGlvbi5nZXQoKTtcblxuICAgICAgaWYgKGN1cnJlbnRTZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgIG1vZGVsaW5nLnNldENvbG9yKGN1cnJlbnRTZWxlY3Rpb24sIG9wdHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHNlbGVjdGlvbiAmJiBkaXJlY3RFZGl0aW5nKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJBY3Rpb24oJ2RpcmVjdEVkaXRpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gc2VsZWN0aW9uLmdldCgpO1xuXG4gICAgICBpZiAoY3VycmVudFNlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgZGlyZWN0RWRpdGluZy5hY3RpdmF0ZShjdXJyZW50U2VsZWN0aW9uWzBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzZWFyY2hQYWQpIHtcbiAgICB0aGlzLl9yZWdpc3RlckFjdGlvbignZmluZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VhcmNoUGFkLnRvZ2dsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGNhbnZhcyAmJiBtb2RlbGluZykge1xuICAgIHRoaXMuX3JlZ2lzdGVyQWN0aW9uKCdtb3ZlVG9PcmlnaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IGNhbnZhcy5nZXRSb290RWxlbWVudCgpLFxuICAgICAgICAgIGJvdW5kaW5nQm94O1xuXG5cbiAgICAgIHZhciBlbGVtZW50cyA9IGVsZW1lbnRSZWdpc3RyeS5maWx0ZXIoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudCAhPT0gcm9vdEVsZW1lbnQ7XG4gICAgICB9KTtcblxuICAgICAgYm91bmRpbmdCb3ggPSBnZXRCQm94KGVsZW1lbnRzKTtcblxuICAgICAgbW9kZWxpbmcubW92ZUVsZW1lbnRzKFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgeyB4OiAtYm91bmRpbmdCb3gueCwgeTogLWJvdW5kaW5nQm94LnkgfSxcbiAgICAgICAgcm9vdEVsZW1lbnRcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxufTsiLCJpbXBvcnQgRWRpdG9yQWN0aW9uc01vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9lZGl0b3ItYWN0aW9ucyc7XG5cbmltcG9ydCBQb3N0aXRFZGl0b3JBY3Rpb25zIGZyb20gJy4vUG9zdGl0RWRpdG9yQWN0aW9ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBFZGl0b3JBY3Rpb25zTW9kdWxlXG4gIF0sXG4gIGVkaXRvckFjdGlvbnM6IFsgJ3R5cGUnLCBQb3N0aXRFZGl0b3JBY3Rpb25zIF1cbn07XG4iLCJpbXBvcnQge1xuICBkb21pZnksXG4gIGV2ZW50IGFzIGRvbUV2ZW50XG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQge1xuICBmaWxlUmVhZGVyXG59IGZyb20gJy4uLy4uL3V0aWwvRmlsZVV0aWwuanMnO1xuXG5pbXBvcnQge1xuICBnZXRNb3VzZVBvc2l0aW9uXG59IGZyb20gJy4uLy4uL3V0aWwvU2NyZWVuVXRpbC5qcyc7XG5cbnZhciBMT1dfUFJJT1JJVFkgPSA1MDA7XG52YXIgdGV4dDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSW1hZ2VTZWxlY3Rpb24oY2FudmFzLCBldmVudEJ1cywgbW9kZWxpbmcsIHRyYW5zbGF0ZSkge1xuXG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbiAgdGhpcy5fdHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBldmVudEJ1cy5vbignY3JlYXRlLmVuZCcsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBoaW50cyA9IGNvbnRleHQuaGludHM7XG5cbiAgICBpZiAoaGludHMuc2VsZWN0SW1hZ2UpIHtcbiAgICAgIHNlbGYuc2VsZWN0KGVsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGV4dCA9IHsgJ1VSTCc6IHRoaXMuX3RyYW5zbGF0ZSgnVVJMJyksXG4gICAgJ0FuIGVycm9yIG9jY3VyZWQgZHVyaW5nIHRoZSBmaWxlIHVwbG9hZCc6IHRoaXMuX3RyYW5zbGF0ZSgnQW4gZXJyb3Igb2NjdXJlZCBkdXJpbmcgdGhlIGZpbGUgdXBsb2FkJyksXG4gICAgJ1VwbG9hZCBmaWxlcyBoZXJlJzogdGhpcy5fdHJhbnNsYXRlKCdVcGxvYWQgZmlsZXMgaGVyZScpLFxuICAgICdVcGxvYWQnOiB0aGlzLl90cmFuc2xhdGUoJ1VwbG9hZCcpLFxuICAgICdmaWxlJzogdGhpcy5fdHJhbnNsYXRlKCdmaWxlJyksXG4gICAgJ2ZpbGVzJzogdGhpcy5fdHJhbnNsYXRlKCdmaWxlcycpLFxuICAgICdzZWxlY3RlZCc6IHRoaXMuX3RyYW5zbGF0ZSgnc2VsZWN0ZWQnKSxcbiAgICAnVXBsb2FkIGFnYWluJzogdGhpcy5fdHJhbnNsYXRlKCdVcGxvYWQgYWdhaW4nKSxcbiAgfTtcblxuICBJbWFnZVNlbGVjdGlvbi5JTUFHRV9TRUxFQ1RJT05fTUFSS1VQID0gJzxkaXYgaWQ9XCJwanMtaW1hZ2Utc2VsZWN0aW9uLW1vZGFsXCIgY2xhc3M9XCJwanMtaW8tZGlhbG9nLWxvY2FsXCI+JytcbiAgICAnPGRpdiBjbGFzcz1cInBqcy1pby1kaWFsb2ctc2VjdGlvbiBwanMtZmlyc3RcIj4nK1xuICAgICAgJzxkaXYgaWQ9XCJwanMtaW1hZ2Utc2VsZWN0aW9uLWlucHV0LXdyYXBwZXJcIj48aW5wdXQgaWQ9XCJwanMtaW1hZ2Utc2VsZWN0aW9uLWlucHV0XCIgY2xhc3M9XCJwanMtdWktZWxlbWVudC1ib3JkZXJlZFwiPjwvaW5wdXQ+PC9kaXY+JytcbiAgICAgICc8ZGl2IGNsYXNzPVwicGpzLWxhYmVsZWQtaW5wdXRcIj4nK1xuICAgICAgJzxsYWJlbCBmb3I9XCJwanMtaW1hZ2Utc2VsZWN0aW9uLWlucHV0XCIgY2xhc3M9XCJwanMtaW5wdXQtdGV4dC1zdGF0aWNcIj48IS0tU2VhcmNoIC8gLS0+Jyt0ZXh0WydVUkwnXSsnOjwvbGFiZWw+JytcbiAgICAgICc8L2Rpdj4nK1xuICAgICc8L2RpdlwiPicrXG4gICAgJzxkaXYgY2xhc3M9XCJwanMtaW8tZGlhbG9nLXNlY3Rpb25cIj4nK1xuICAgICc8ZGl2IGNsYXNzPVwicGpzLXNlY3Rpb24tc3BhY2VyXCI+PC9kaXY+JytcbiAgICAnPGxhYmVsIGZvcj1cInBqcy1pbWFnZS11cGxvYWRcIj48ZGl2IGNsYXNzPVwicGpzLWlvLWRpYWxvZy10ZXh0LWhpbnRcIj4nK1xuICAgICAgJzxhIHN0eWxlPVwiZGlzcGxheTpibG9ja1wiPjx1bCBpZD1cInBqcy1pbWFnZS1kaWFsb2ctdGV4dC1oaW50LWxpc3RcIiBjbGFzcz1cInBqcy1ob3Jpem9udGFsXCI+JytcbiAgICAgICAgJzxsaT48ZGl2IGNsYXNzPVwicGpzLWdlbmVyYWwtaWNvbiBwanMtaW1hZ2UtZGlhbG9nLXVwbG9hZC1pY29uXCI+PC9kaXY+PC9saT4nK1xuICAgICAgICAnPGxpIGlkPVwicGpzLWltYWdlLXNlbGVjdGlvbi1maWxlcy10ZXh0LWVycm9yXCI+Jyt0ZXh0WydBbiBlcnJvciBvY2N1cmVkIGR1cmluZyB0aGUgZmlsZSB1cGxvYWQnXSsnPC9saT4nK1xuICAgICAgICAnPGxpIGlkPVwicGpzLWltYWdlLXNlbGVjdGlvbi1maWxlcy10ZXh0LXVwbG9hZFwiPicrdGV4dFsnVXBsb2FkIGZpbGVzIGhlcmUnXSsnPC9saT4nK1xuICAgICAgJzwvdWw+PC9hPicrXG4gICAgJzwvZGl2PjwvbGFiZWw+JytcbiAgICAnPGlucHV0IHR5cGU9XCJmaWxlXCIgaWQ9XCJwanMtaW1hZ2UtdXBsb2FkXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBtdWx0aXBsZS8+JytcbiAgICAnPGRpdiBjbGFzcz1cInBqcy1pby1kaWFsb2ctc2VjdGlvblwiPicrXG4gICAgJzxkaXYgY2xhc3M9XCJwanMtYnV0dG9ucyBwanMtaW1hZ2Utc2VsZWN0aW9uLXN1Ym1pdC13cmFwcGVyXCI+PGJ1dHRvbiBpZD1cInBqcy1pbWFnZS1zZWxlY3Rpb24tc3VibWl0XCI+Jyt0ZXh0WydVcGxvYWQnXSsnPC9idXR0b24+PC9kaXY+JytcbiAgICAnPC9kaXY+JytcbiAgICAnPC9kaXY+JytcbiAgJzwvZGl2Pic7XG5cbn1cblxuSW1hZ2VTZWxlY3Rpb24ucHJvdG90eXBlLl9nZXRQYXJlbnRDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NhbnZhcy5nZXRDb250YWluZXIoKTtcbn07XG5cbkltYWdlU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvbWlmeShJbWFnZVNlbGVjdGlvbi5JTUFHRV9TRUxFQ1RJT05fTUFSS1VQKTtcblxuICBjb25zdCBjYW52YXMgPSB0aGlzLl9jYW52YXMuX2NvbnRhaW5lci5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIGNhbnZhcy5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjYW52YXMuZmlyc3RDaGlsZCk7XG5cbiAgY29uc3QgbW91c2VQb3NpdGlvbiA9IGdldE1vdXNlUG9zaXRpb24obnVsbCk7XG4gIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gKCBtb3VzZVBvc2l0aW9uLnBhZ2VYIC0gZ2V0T2Zmc2V0TGVmdChjb250YWluZXIpICkgKyAncHgnO1xuICBjb250YWluZXIuc3R5bGUudG9wID0gKCBtb3VzZVBvc2l0aW9uLnBhZ2VZIC0gZ2V0T2Zmc2V0VG9wKGNvbnRhaW5lcikgKSArICdweCc7XG5cbiAgY29uc3QgaW5wdXRGaWVsZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwanMtaW1hZ2Utc2VsZWN0aW9uLWlucHV0JyksXG4gICAgICAgIHN1Ym1pdEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwanMtaW1hZ2Utc2VsZWN0aW9uLXN1Ym1pdCcpLFxuICAgICAgICBpbWFnZVVwbG9hZFRleHRFcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwanMtaW1hZ2Utc2VsZWN0aW9uLWZpbGVzLXRleHQtZXJyb3InKSxcbiAgICAgICAgaW1hZ2VVcGxvYWRUZXh0VXBsb2FkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bqcy1pbWFnZS1zZWxlY3Rpb24tZmlsZXMtdGV4dC11cGxvYWQnKSxcbiAgICAgICAgaW1hZ2VVcGxvYWRUZXh0TGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwanMtaW1hZ2UtZGlhbG9nLXRleHQtaGludC1saXN0JyksXG4gICAgICAgIGltYWdlVXBsb2FkUmVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bqcy1pbWFnZS11cGxvYWQnKSxcbiAgICAgICAgbW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGpzLWltYWdlLXNlbGVjdGlvbi1tb2RhbCcpO1xuXG4gIHZhciB1cGxvYWRUZXh0TGlzdEhlaWdodCA9IGltYWdlVXBsb2FkVGV4dExpc3Quc3R5bGUuaGVpZ2h0O1xuXG4gIHZhciBzb3VyY2UsIGZpbGVzVG9VcGxvYWQ7XG5cbiAgLy8gZm9jdXMgdXJsIGlucHV0IGZpZWxkIG9uIG1vZGFsIG9wZW5cbiAgaW5wdXRGaWVsZC5mb2N1cygpO1xuXG4gIC8vIHJlbW92ZSBtb2RhbCBieSBjbGlja2luZyBhbnl3aGVyZSBlbHNlXG4gIGNvbnN0IGNhbnZhc0RlZmF1bHRDbGljayA9IGRvbUV2ZW50LmJpbmQoY2FudmFzLCAnY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgIGlmIChtb2RhbCkge1xuXG4gICAgICAvLyBJZiB3ZSBjbGlja2VkIG9uZSBvZiBvdXIgdXBkYXRlIGJ1dHRvbnMsIGRvbid0IGNsb3NlIHRoZSBkaWFsb2cuXG4gICAgICB2YXIgaXNCdG4gPSBmYWxzZTtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kanMtY29udGV4dC1wYWQgLmVudHJ5JykuZm9yRWFjaCggZnVuY3Rpb24oYnRuKSB7XG4gICAgICAgIGlmIChidG4gPT0gZXZlbnQudGFyZ2V0ICkge1xuICAgICAgICAgIGlzQnRuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vdXNlUG9zID0gZ2V0TW91c2VQb3NpdGlvbihldik7XG5cbiAgICAgIC8vIFRoZSBkaWFsb2cgaXMgZGlzcGxhY2VkIGJ5IGEgYm94IHRoZSBzaXplIG9mIGZvbnQtc2l6ZSBvbiBlYWNoIGVkZ2UuXG4gICAgICB2YXIgZm9udFNpemUgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG1vZGFsKVsnZm9udC1zaXplJ107XG4gICAgICBmb250U2l6ZSA9IHBhcnNlSW50KGZvbnRTaXplLnN1YnN0cmluZygwLCBmb250U2l6ZS5pbmRleE9mKCdweCcpKSk7XG4gICAgICBpZiAoIWlzQnRuICYmIChcbiAgICAgICAgICAobW91c2VQb3MucGFnZVggPiBtb2RhbC5vZmZzZXRMZWZ0K2dldE9mZnNldExlZnQoY2FudmFzKSttb2RhbC5jbGllbnRXaWR0aFxuICAgICAgICAgIHx8IG1vdXNlUG9zLnBhZ2VYIDwgbW9kYWwub2Zmc2V0TGVmdCtnZXRPZmZzZXRMZWZ0KGNhbnZhcykgLSBmb250U2l6ZSlcbiAgICAgICAgICB8fCAobW91c2VQb3MucGFnZVkgPiBtb2RhbC5vZmZzZXRUb3ArZ2V0T2Zmc2V0VG9wKGNhbnZhcykrbW9kYWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgfHwgbW91c2VQb3MucGFnZVkgPCBtb2RhbC5vZmZzZXRUb3ArZ2V0T2Zmc2V0VG9wKGNhbnZhcykgLSBmb250U2l6ZSkgKSkge1xuICAgICAgICByZW1vdmVJbWFnZVNlbGVjdGlvbk1vZGFsKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuXG4gIGZvciAodmFyIGk9MDsgaSA8IGltYWdlVXBsb2FkUmVhZGVyLmxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIC8vIG9wZW4gZmlsZSBkaWFsb2dcbiAgICBkb21FdmVudC5iaW5kKGltYWdlVXBsb2FkUmVhZGVyLmxhYmVsc1tpXSwgJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIFxuICAgICAgaW1hZ2VVcGxvYWRSZWFkZXIuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChldi50eXBlLCBldikpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gYWZ0ZXIgd2Ugb3BlbiBmaWxlIGRpYWxvZ1xuICBkb21FdmVudC5iaW5kKGltYWdlVXBsb2FkUmVhZGVyLCAnY2hhbmdlJywgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgaW5wdXRGaWVsZC5kaXNhYmxlZCA9ICd0cnVlJztcblxuICAgIGxldCB1cGxvYWREaXNwbGF5VGV4dDtcblxuICAgIGxldCB1cGxvYWRSZXN1bHRPYmogPSBhd2FpdCBmaWxlUmVhZGVyKG51bGwsIGltYWdlVXBsb2FkUmVhZGVyLmZpbGVzKSxcbiAgICAgICAgdXBsb2FkUmVzdWx0ID0gdXBsb2FkUmVzdWx0T2JqLnVwbG9hZFJlc3VsdCxcbiAgICAgICAgZXJyb3JzID0gdXBsb2FkUmVzdWx0T2JqLmVycm9ycztcblxuICAgIGlmICghZXJyb3JzKSB7XG4gICAgICBsZXQgdXBsb2FkZWRGaWxlc0NvdW50ID0gKHVwbG9hZFJlc3VsdC5sZW5ndGgpID8gdXBsb2FkUmVzdWx0Lmxlbmd0aCA6IDA7XG4gICAgICB1cGxvYWREaXNwbGF5VGV4dCA9IHVwbG9hZGVkRmlsZXNDb3VudDtcblxuICAgICAgaWYgKGlzTmFOKHVwbG9hZGVkRmlsZXNDb3VudCkgPT09IGZhbHNlKSB7XG5cbiAgICAgICAgY29uc3QgZmlsZVBsdXJhbFRleHQgPSsgKHVwbG9hZFJlc3VsdC5sZW5ndGggPT0gMSkgPyB0ZXh0WydmaWxlJ10gOiB0ZXh0WydmaWxlcyddO1xuICAgICAgICB1cGxvYWREaXNwbGF5VGV4dCArPSAnICcgKyBmaWxlUGx1cmFsVGV4dCArICcgJyArIHRleHRbJ3NlbGVjdGVkJ107XG5cbiAgICAgICAgLy8gdXBsb2FkZWQgZmlsZXMgYXJlIHNhdmVkIGluIGdsb2JhbCB2YXJcbiAgICAgICAgZmlsZXNUb1VwbG9hZCA9IHVwbG9hZFJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZGlzcGxheVVwbG9hZFN0YWdpbmcodXBsb2FkRGlzcGxheVRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwbGF5RXJyb3IoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHVwbG9hZCBidXR0b25cbiAgZG9tRXZlbnQuYmluZChzdWJtaXRCdXR0b24sICdjbGljaycsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgIHNvdXJjZSA9IGZpbGVzVG9VcGxvYWQ7XG5cbiAgICAvLyAoMSkgY2FsbCBmcm9tIGNhbnZhcywgcHJvdmlkaW5nIGEgdGFyZ2V0IGVsZW1lbnRcbiAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuXG4gICAgICAvLyAoMS4xKSBsb2NhbCBmaWxlIHNlbGVjdGlvbiB1cGxvYWRcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBmIGluIGZpbGVzVG9VcGxvYWQpIHtcbiAgICAgICAgICB1cGxvYWRJbWFnZShzZWxmLCBmaWxlc1RvVXBsb2FkW2ZdKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyAoMS4yKSB1cmwgdXBsb2FkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2UgPSBpbnB1dEZpZWxkLnZhbHVlO1xuICAgICAgICB1cGxvYWRJbWFnZShzZWxmLCBzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9ldmVudEJ1cy5maXJlKCdpbWFnZVNlbGVjdGlvbi5jb21wbGV0ZScsIHsgZWxlbWVudDogZWxlbWVudCB9KTtcblxuICAgIC8vICgyKSBleHRlcm5hbCBjYWxsIHcvbyBjYW52YXMgdGFyZ2V0XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gKDIuMSBkZWZhdWx0KSBsb2NhbCBmaWxlIHNlbGVjdGlvbiBkYXRhIGlzIHVzZWRcblxuICAgICAgLy8gKDIuMikgdXJsIHVwbG9hZFxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gaW5wdXRGaWVsZC52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soc291cmNlKTtcbiAgICB9XG5cbiAgICAvLyBlcnJvciBoYW5kbGluZyBub3QgbmVjZXNzYXJ5IGFzIGRlZmF1bHQgaW1nIHdpbGwgYmUgc2hvd24gaW4gZXJyb3Igc2l0dWF0aW9uXG4gICAgcmVtb3ZlSW1hZ2VTZWxlY3Rpb25Nb2RhbCgpO1xuICB9KTtcblxuICAvLyBlbnRlciBwcmVzc2VkXG4gIGRvbUV2ZW50LmJpbmQoaW5wdXRGaWVsZCwgJ2tleXVwJywgZnVuY3Rpb24oZXN2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3VibWl0QnV0dG9uLmNsaWNrKCk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBnZXRPZmZzZXRMZWZ0KGVsZW0pIHtcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKCAhaXNOYU4oIGVsZW0ub2Zmc2V0TGVmdCApIClcbiAgICAgIHtcbiAgICAgICAgICBvZmZzZXRMZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcbiAgICAgIH1cbiAgICB9IHdoaWxlKCBlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQgKTtcbiAgICByZXR1cm4gb2Zmc2V0TGVmdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9mZnNldFRvcChlbGVtKSB7XG4gICAgdmFyIG9mZnNldFRvcCA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKCAhaXNOYU4oIGVsZW0ub2Zmc2V0VG9wICkgKVxuICAgICAge1xuICAgICAgICAgIG9mZnNldFRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICB9IHdoaWxlKCBlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQgKTtcbiAgICByZXR1cm4gb2Zmc2V0VG9wO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzcGxheVVwbG9hZFN0YWdpbmcodGV4dCkge1xuICAgIGltYWdlVXBsb2FkVGV4dExpc3Quc3R5bGUuaGVpZ2h0ID0gdXBsb2FkVGV4dExpc3RIZWlnaHQ7XG4gICAgaW1hZ2VVcGxvYWRUZXh0RXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpbWFnZVVwbG9hZFRleHRVcGxvYWQuaW5uZXJIVE1MID0gdGV4dDtcblxuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdwanMtaW1hZ2UtZGlhbG9nLXVwbG9hZC1pY29uJykubGVuZ3RoID4gMCkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncGpzLWltYWdlLWRpYWxvZy11cGxvYWQtaWNvbicpWzBdLmNsYXNzTGlzdC5yZW1vdmUoJ3Bqcy1pbWFnZS1kaWFsb2ctdXBsb2FkLWljb24tZXJyb3InKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwbGF5RXJyb3IoKSB7XG4gICAgdXBsb2FkVGV4dExpc3RIZWlnaHQgPSBpbWFnZVVwbG9hZFRleHRMaXN0LnN0eWxlLmhlaWdodDtcblxuICAgIGltYWdlVXBsb2FkVGV4dExpc3Quc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgIGltYWdlVXBsb2FkVGV4dEVycm9yLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGltYWdlVXBsb2FkVGV4dFVwbG9hZC5pbm5lckhUTUwgPSB0ZXh0WydVcGxvYWQgYWdhaW4nXTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Bqcy1pbWFnZS1kaWFsb2ctdXBsb2FkLWljb24nKVswXS5jbGFzc0xpc3QuYWRkKCdwanMtaW1hZ2UtZGlhbG9nLXVwbG9hZC1pY29uLWVycm9yJyk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiB1cGxvYWRJbWFnZShzZWxmLCBzb3VyY2UpIHtcbiAgICB2YXIgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICB2YXIgc19rZXkgPSB1cmxQYXJhbXMuZ2V0KCdzX2tleScpO1xuICAgIGlmKCBzX2tleSA9PT0gbnVsbCApIHtcbiAgICAgIHNoZXBoZXJkQWxlcnQoXCJTY3JpcHQgUmVxdWlyZWRcIiwgXCJZb3UgbXVzdCBvcGVuIGEgc2NyaXB0IGJlZm9yZSB5b3UgY2FuIHRha2Ugbm90ZXMhXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBpbWFnZSwgYmxvYjtcbiAgICAgIGlmKCBzb3VyY2Uuc3Vic3RyaW5nKDAsNCkgIT09IFwiZGF0YVwiICkge1xuICAgICAgICBibG9iID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vY29ycy1hbnl3aGVyZS1kb3QtaW5kaWVza2VkZ2UtcHJvZHVjdGlvbi53bC5yLmFwcHNwb3QuY29tLycgKyBzb3VyY2UpLnRoZW4oIHIgPT4gci5ibG9iKCkgKTtcbiAgICAgICAgYmxvYi5uYW1lID0gXCJSZW1vdGUgRmlsZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvYiA9IGltYWdlVXBsb2FkUmVhZGVyLmZpbGVzWzBdO1xuICAgICAgfVxuXG4gICAgICAvLyBVZ2x5IGJlY2F1c2Ugd2UgZXhwZWN0IHRoaXMgVVJMIHRvIGV4aXN0IG9uIHRoZSBwYWdlLlxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyBBY3RpdmVTdG9yYWdlLkRpcmVjdFVwbG9hZChcbiAgICAgICAgYmxvYixcbiAgICAgICAgZGlyZWN0X3VwbG9hZF91cmxcbiAgICAgICk7XG5cbiAgICAgIHVwbG9hZC5jcmVhdGUoZnVuY3Rpb24oZXJyb3IsIGJsb2IpIHtcbiAgICAgICAgaWYoIGVycm9yICE9PSBudWxsICkge1xuICAgICAgICAgIGlmKCBlcnJvci5zZWFyY2goXCJTdGF0dXM6IDQwM1wiKSA+PSAwICkge1xuICAgICAgICAgICAgc2hlcGhlcmRBbGVydChcIlN1YnNjcmlwdGlvbiBOZWVkZWQhXCIsIFwiWW91IG11c3QgaGF2ZSBhbiBhY3RpdmUgc3Vic2NyaXB0aW9uIHRvIHNhdmUgaW1hZ2VzISBZb3UgY2FuIHNpZ24gdXAgPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cXFwibW9kYWxcXFwiIGhyZWY9XFxcIiNzdWJzY3JpcHRpb25Nb2RhbFxcXCIgb25jbGljaz1cXFwiU2hlcGhlcmQuYWN0aXZlVG91ci5jb21wbGV0ZSgpOyAkKCcjaWRlYXRvck5vdGVzTW9kYWwnKS5tb2RhbCgnaGlkZScpO1xcXCIgZGF0YS1kZXNjcmlwdGlvbj1cXFwiU2lnbiB1cCBmb3IgaW1hZ2UgdXBsb2FkaW5nIGFuZCBvdGhlciBncmVhdCBmZWF0dWVycyFcXFwiIGRhdGEtcmVzZXQ9XFxcIiQoJyNpZGVhdG9yTm90ZXNNb2RhbCcpLm1vZGFsKFxcJ3Nob3dcXCcpO1xcXCIgc3R5bGU9XFxcImNvbG9yOiBibHVlOyBtYXJnaW4tbGVmdDogLTZweDsgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxcIj5oZXJlITwvYnV0dG9uPlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hlcGhlcmRBbGVydChcIlVwbG9hZCBFcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIGJsb2Iua2V5ICkge1xuICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUNTUkYtVG9rZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpLmF0dHIoJ2NvbnRlbnQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXJsOiBcIi9zY3JpcHRzL1wiICsgc19rZXkgKyBcIi9pbWFnZV91cmwvXCIgKyBibG9iLmtleSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgc2VsZi5fbW9kZWxpbmcudXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBkYXRhLnVybCxcbiAgICAgICAgICAgICAgICBrZXk6IGRhdGEua2V5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoZXBoZXJkQWxlcnQoXCJVbmtub3duIEVycm9yXCIsIFwiV2UndmUgbG9nZ2VkIHRoaXMgaXNzdWUuICBJZiBpdCBjb250aW51ZXMsIHBsZWFzZSByZWFjaCBvdXQgdG8gc3VwcG9ydC5cIik7XG4gICAgICAgICAgQnVnc25hZy5ub3RpZnkoXCJVbmtub3duIHVwbG9hZCByZXNwb25zZTogXCIgKyBibG9iLnRvU3RyaW5nKCkgKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVJbWFnZVNlbGVjdGlvbk1vZGFsKCkge1xuICAgIGlmIChtb2RhbCAmJiBtb2RhbC5wYXJlbnROb2RlKSB7XG4gICAgICBtb2RhbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG1vZGFsKTtcbiAgICAgIGlmIChjYW52YXNEZWZhdWx0Q2xpY2spIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2FudmFzRGVmYXVsdENsaWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuSW1hZ2VTZWxlY3Rpb24ucHJvdG90eXBlLiRpbmplY3QgPSBbXG4gICdjYW52YXMnLFxuICAnZXZlbnRCdXMnLFxuICAnbW9kZWxuZycsXG4gICd0cmFuc2xhdGUnXG5dO1xuIiwiaW1wb3J0IEltYWdlU2VsZWN0aW9uIGZyb20gJy4vSW1hZ2VTZWxlY3Rpb24nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdpbWFnZVNlbGVjdGlvbicgXSxcbiAgaW1hZ2VTZWxlY3Rpb246IFsgJ3R5cGUnLCBJbWFnZVNlbGVjdGlvbiBdXG59O1xuIiwiaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IEtleWJvYXJkQmluZGluZ3MgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMva2V5Ym9hcmQvS2V5Ym9hcmRCaW5kaW5ncyc7XG5cblxuLyoqXG4gKiBQb3N0aXQgc3BlY2lmaWMga2V5Ym9hcmQgYmluZGluZ3MuXG4gKlxuICogQHBhcmFtIHtJbmplY3Rvcn0gaW5qZWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0S2V5Ym9hcmRCaW5kaW5ncyhpbmplY3Rvcikge1xuICBpbmplY3Rvci5pbnZva2UoS2V5Ym9hcmRCaW5kaW5ncywgdGhpcyk7XG59XG5cbmluaGVyaXRzKFBvc3RpdEtleWJvYXJkQmluZGluZ3MsIEtleWJvYXJkQmluZGluZ3MpO1xuXG5Qb3N0aXRLZXlib2FyZEJpbmRpbmdzLiRpbmplY3QgPSBbXG4gICdpbmplY3Rvcidcbl07XG5cblxuLyoqXG4gKiBSZWdpc3RlciBhdmFpbGFibGUga2V5Ym9hcmQgYmluZGluZ3MuXG4gKlxuICogQHBhcmFtIHtLZXlib2FyZH0ga2V5Ym9hcmRcbiAqIEBwYXJhbSB7RWRpdG9yQWN0aW9uc30gZWRpdG9yQWN0aW9uc1xuICovXG5Qb3N0aXRLZXlib2FyZEJpbmRpbmdzLnByb3RvdHlwZS5yZWdpc3RlckJpbmRpbmdzID0gZnVuY3Rpb24oa2V5Ym9hcmQsIGVkaXRvckFjdGlvbnMpIHtcblxuICAvLyBpbmhlcml0IGRlZmF1bHQgYmluZGluZ3NcbiAgS2V5Ym9hcmRCaW5kaW5ncy5wcm90b3R5cGUucmVnaXN0ZXJCaW5kaW5ncy5jYWxsKHRoaXMsIGtleWJvYXJkLCBlZGl0b3JBY3Rpb25zKTtcblxuICAvKipcbiAgICogQWRkIGtleWJvYXJkIGJpbmRpbmcgaWYgcmVzcGVjdGl2ZSBlZGl0b3IgYWN0aW9uXG4gICAqIGlzIHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGF0IGltcGxlbWVudHMgdGhlIGtleSBiaW5kaW5nXG4gICAqL1xuICBmdW5jdGlvbiBhZGRMaXN0ZW5lcihhY3Rpb24sIGZuKSB7XG5cbiAgICBpZiAoZWRpdG9yQWN0aW9ucy5pc1JlZ2lzdGVyZWQoYWN0aW9uKSkge1xuICAgICAga2V5Ym9hcmQuYWRkTGlzdGVuZXIoZm4pO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNlbGVjdCBhbGwgZWxlbWVudHNcbiAgLy8gQ1RSTCArIEFcbiAgYWRkTGlzdGVuZXIoJ3NlbGVjdEVsZW1lbnRzJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudDtcblxuICAgIGlmIChrZXlib2FyZC5pc0tleShbJ2EnLCAnQSddLCBldmVudCkgJiYga2V5Ym9hcmQuaXNDbWQoZXZlbnQpKSB7XG4gICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ3NlbGVjdEVsZW1lbnRzJyk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gc2VhcmNoIGxhYmVsc1xuICAvLyBDVFJMICsgRlxuICBhZGRMaXN0ZW5lcignZmluZCcsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBldmVudCA9IGNvbnRleHQua2V5RXZlbnQ7XG5cbiAgICBpZiAoa2V5Ym9hcmQuaXNLZXkoWydmJywgJ0YnXSwgZXZlbnQpICYmIGtleWJvYXJkLmlzQ21kKGV2ZW50KSkge1xuICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdmaW5kJyk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWN0aXZhdGUgc3BhY2UgdG9vbFxuICAvLyBTXG4gIGFkZExpc3RlbmVyKCdzcGFjZVRvb2wnLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgaWYgKGtleWJvYXJkLmhhc01vZGlmaWVyKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXlib2FyZC5pc0tleShbJ3MnLCAnUyddLCBldmVudCkpIHtcbiAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcignc3BhY2VUb29sJyk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWN0aXZhdGUgbGFzc28gdG9vbFxuICAvLyBMXG4gIGFkZExpc3RlbmVyKCdsYXNzb1Rvb2wnLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgaWYgKGtleWJvYXJkLmhhc01vZGlmaWVyKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXlib2FyZC5pc0tleShbJ2wnLCAnTCddLCBldmVudCkpIHtcbiAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcignbGFzc29Ub29sJyk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWN0aXZhdGUgaGFuZCB0b29sXG4gIC8vIEhcbiAgYWRkTGlzdGVuZXIoJ2hhbmRUb29sJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudDtcblxuICAgIGlmIChrZXlib2FyZC5oYXNNb2RpZmllcihldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5Ym9hcmQuaXNLZXkoWydoJywgJ0gnXSwgZXZlbnQpKSB7XG4gICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ2hhbmRUb29sJyk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWN0aXZhdGUgZGlyZWN0IGVkaXRpbmdcbiAgLy8gRVxuICBhZGRMaXN0ZW5lcignZGlyZWN0RWRpdGluZycsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBldmVudCA9IGNvbnRleHQua2V5RXZlbnQ7XG5cbiAgICBpZiAoa2V5Ym9hcmQuaGFzTW9kaWZpZXIoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleWJvYXJkLmlzS2V5KFsnZScsICdFJ10sIGV2ZW50KSkge1xuICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdkaXJlY3RFZGl0aW5nJyk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbn07IiwiaW1wb3J0IEtleWJvYXJkTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2tleWJvYXJkJztcblxuaW1wb3J0IFBvc3RpdEtleWJvYXJkQmluZGluZ3MgZnJvbSAnLi9Qb3N0aXRLZXlib2FyZEJpbmRpbmdzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIEtleWJvYXJkTW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbICdrZXlib2FyZEJpbmRpbmdzJyBdLFxuICBrZXlib2FyZEJpbmRpbmdzOiBbICd0eXBlJywgUG9zdGl0S2V5Ym9hcmRCaW5kaW5ncyBdXG59O1xuIiwiaW1wb3J0IHtcbiAgcmVtb3ZlIGFzIHN2Z1JlbW92ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7XG4gIGlzXG59IGZyb20gJy4uLy4uL3V0aWwvTW9kZWxVdGlsJztcblxudmFyIE1BUktFUl9ISURERU4gPSAnZGpzLWVsZW1lbnQtaGlkZGVuJyxcbiAgICBNQVJLRVJfTEFCRUxfSElEREVOID0gJ2Rqcy1sYWJlbC1oaWRkZW4nO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExhYmVsRWRpdGluZ1ByZXZpZXcoXG4gICAgZXZlbnRCdXMsIGNhbnZhcywgZWxlbWVudFJlZ2lzdHJ5LFxuICAgIHBhdGhNYXApIHtcblxuXG4gIHZhciBlbGVtZW50LCBnZng7XG5cbiAgZXZlbnRCdXMub24oJ2RpcmVjdEVkaXRpbmcuYWN0aXZhdGUnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIGFjdGl2ZVByb3ZpZGVyID0gY29udGV4dC5hY3RpdmU7XG5cbiAgICBlbGVtZW50ID0gYWN0aXZlUHJvdmlkZXIuZWxlbWVudC5sYWJlbCB8fCBhY3RpdmVQcm92aWRlci5lbGVtZW50O1xuXG5cbiAgICBpZiAoZWxlbWVudC5sYWJlbFRhcmdldCkge1xuICAgICAgY2FudmFzLmFkZE1hcmtlcihlbGVtZW50LCBNQVJLRVJfSElEREVOKTtcbiAgICB9IGVsc2UgaWYgKGlzKGVsZW1lbnQsICdwb3N0aXQ6UG9zdGl0JykpIHtcbiAgICAgIGNhbnZhcy5hZGRNYXJrZXIoZWxlbWVudCwgTUFSS0VSX0xBQkVMX0hJRERFTik7XG4gICAgfVxuICB9KTtcblxuXG4gIGV2ZW50QnVzLm9uKFsgJ2RpcmVjdEVkaXRpbmcuY29tcGxldGUnLCAnZGlyZWN0RWRpdGluZy5jYW5jZWwnIF0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgYWN0aXZlUHJvdmlkZXIgPSBjb250ZXh0LmFjdGl2ZTtcblxuICAgIGlmIChhY3RpdmVQcm92aWRlcikge1xuICAgICAgY2FudmFzLnJlbW92ZU1hcmtlcihhY3RpdmVQcm92aWRlci5lbGVtZW50LmxhYmVsIHx8IGFjdGl2ZVByb3ZpZGVyLmVsZW1lbnQsIE1BUktFUl9ISURERU4pO1xuICAgICAgY2FudmFzLnJlbW92ZU1hcmtlcihlbGVtZW50LCBNQVJLRVJfTEFCRUxfSElEREVOKTtcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGdmeCkge1xuICAgICAgc3ZnUmVtb3ZlKGdmeCk7XG5cbiAgICAgIGdmeCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xufVxuXG5MYWJlbEVkaXRpbmdQcmV2aWV3LiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnZWxlbWVudFJlZ2lzdHJ5JyxcbiAgJ3BhdGhNYXAnXG5dOyIsImltcG9ydCB7XG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGdldExhYmVsXG59IGZyb20gJy4vTGFiZWxVdGlsJztcblxuaW1wb3J0IHsgaXNBbnkgfSBmcm9tICcuLi9tb2RlbGluZy91dGlsL01vZGVsaW5nVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldEV4dGVybmFsTGFiZWxNaWQsXG4gIGlzTGFiZWxFeHRlcm5hbCxcbiAgaGFzRXh0ZXJuYWxMYWJlbCxcbiAgaXNMYWJlbFxufSBmcm9tICcuLi8uLi91dGlsL0xhYmVsVXRpbCc7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGFiZWxFZGl0aW5nUHJvdmlkZXIoXG4gICAgZXZlbnRCdXMsIHBvc3RpdEZhY3RvcnksIGNhbnZhcywgZGlyZWN0RWRpdGluZyxcbiAgICBtb2RlbGluZywgcmVzaXplSGFuZGxlcywgdGV4dFJlbmRlcmVyKSB7XG5cbiAgdGhpcy5fcG9zdGl0RmFjdG9yeSA9IHBvc3RpdEZhY3Rvcnk7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbiAgdGhpcy5fdGV4dFJlbmRlcmVyID0gdGV4dFJlbmRlcmVyO1xuXG4gIGRpcmVjdEVkaXRpbmcucmVnaXN0ZXJQcm92aWRlcih0aGlzKTtcblxuICAvLyBsaXN0ZW4gdG8gZGJsY2xpY2sgb24gbm9uLXJvb3QgZWxlbWVudHNcbiAgZXZlbnRCdXMub24oJ2VsZW1lbnQuZGJsY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgIGFjdGl2YXRlRGlyZWN0RWRpdChldmVudC5lbGVtZW50LCB0cnVlKTtcbiAgfSk7XG5cbiAgLy8gY29tcGxldGUgb24gZm9sbG93dXAgY2FudmFzIG9wZXJhdGlvblxuICBldmVudEJ1cy5vbihbXG4gICAgJ2F1dG9QbGFjZS5zdGFydCcsXG4gICAgJ2NhbnZhcy52aWV3Ym94LmNoYW5naW5nJyxcbiAgICAnZHJhZy5pbml0JyxcbiAgICAnZWxlbWVudC5tb3VzZWRvd24nLFxuICAgICdwb3B1cE1lbnUub3BlbidcbiAgXSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIGlmIChkaXJlY3RFZGl0aW5nLmlzQWN0aXZlKCkpIHtcbiAgICAgIGRpcmVjdEVkaXRpbmcuY29tcGxldGUoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNhbmNlbCBvbiBjb21tYW5kIHN0YWNrIGNoYW5nZXNcbiAgZXZlbnRCdXMub24oWyAnY29tbWFuZFN0YWNrLmNoYW5nZWQnIF0sIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZGlyZWN0RWRpdGluZy5pc0FjdGl2ZSgpKSB7XG4gICAgICBkaXJlY3RFZGl0aW5nLmNhbmNlbCgpO1xuICAgIH1cbiAgfSk7XG5cblxuICBldmVudEJ1cy5vbignZGlyZWN0RWRpdGluZy5hY3RpdmF0ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmVzaXplSGFuZGxlcy5yZW1vdmVSZXNpemVycygpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignY3JlYXRlLmVuZCcsIDUwMCwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgZWxlbWVudCA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIGNhbkV4ZWN1dGUgPSBldmVudC5jb250ZXh0LmNhbkV4ZWN1dGUsXG4gICAgICAgIGlzVG91Y2ggPSBldmVudC5pc1RvdWNoO1xuXG4gICAgLy8gVE9ETyhuaWtrdSk6IHdlIG5lZWQgdG8gZmluZCBhIHdheSB0byBzdXBwb3J0IHRoZVxuICAgIC8vIGRpcmVjdCBlZGl0aW5nIG9uIG1vYmlsZSBkZXZpY2VzOyByaWdodCBub3cgdGhpcyB3aWxsXG4gICAgLy8gYnJlYWsgZm9yIGRlc3dvcmtmbG93ZWRpdGluZyBvbiBtb2JpbGUgZGV2aWNlc1xuICAgIC8vIGFzIGl0IGJyZWFrcyB0aGUgdXNlciBpbnRlcmFjdGlvbiB3b3JrZmxvd1xuXG4gICAgLy8gVE9ETyhucmUpOiB3ZSBzaG91bGQgdGVtcG9yYXJpbHkgZm9jdXMgdGhlIGVkaXRlZCBlbGVtZW50XG4gICAgLy8gaGVyZSBhbmQgcmVsZWFzZSB0aGUgZm9jdXNlZCB2aWV3cG9ydCBhZnRlciB0aGUgZGlyZWN0IGVkaXRcbiAgICAvLyBvcGVyYXRpb24gaXMgZmluaXNoZWRcbiAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghY2FuRXhlY3V0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LmhpbnRzICYmIGNvbnRleHQuaGludHMuY3JlYXRlRWxlbWVudHNCZWhhdmlvciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZURpcmVjdEVkaXQoZWxlbWVudCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdhdXRvUGxhY2UuZW5kJywgNTAwLCBmdW5jdGlvbihldmVudCkge1xuICAgIGFjdGl2YXRlRGlyZWN0RWRpdChldmVudC5zaGFwZSk7XG4gIH0pO1xuXG5cbiAgZnVuY3Rpb24gYWN0aXZhdGVEaXJlY3RFZGl0KGVsZW1lbnQsIGZvcmNlKSB7XG4gICAgaWYgKGZvcmNlIHx8XG4gICAgICAgIGlzQW55KGVsZW1lbnQsIFsgJ3Bvc3RpdDpQb3N0aXQnLCAncG9zdGl0Okdyb3VwJywgJ3Bvc3RpdDpUZXh0Qm94JyBdKSkge1xuXG4gICAgICBkaXJlY3RFZGl0aW5nLmFjdGl2YXRlKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG59XG5cbkxhYmVsRWRpdGluZ1Byb3ZpZGVyLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdwb3N0aXRGYWN0b3J5JyxcbiAgJ2NhbnZhcycsXG4gICdkaXJlY3RFZGl0aW5nJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ3Jlc2l6ZUhhbmRsZXMnLFxuICAndGV4dFJlbmRlcmVyJ1xuXTtcblxuXG4vKipcbiAqIEFjdGl2YXRlIGRpcmVjdCBlZGl0aW5nIGZvciBhY3Rpdml0aWVzIGFuZCB0ZXh0IGFubm90YXRpb25zLlxuICpcbiAqIEBwYXJhbSAge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGJvdW5kcyAocG9zaXRpb24gYW5kIHNpemUpLCB0ZXh0IGFuZCBvcHRpb25zXG4gKi9cbkxhYmVsRWRpdGluZ1Byb3ZpZGVyLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAvLyB0ZXh0XG4gIHZhciB0ZXh0ID0gZ2V0TGFiZWwoZWxlbWVudCk7XG5cbiAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgIHRleHQ6IHRleHRcbiAgfTtcblxuICAvLyBib3VuZHNcbiAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0RWRpdGluZ0JCb3goZWxlbWVudCk7XG5cbiAgYXNzaWduKGNvbnRleHQsIGJvdW5kcyk7XG5cbiAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAvLyBwb3N0aXRzIGFuZCB0ZXh0IGJveGVzXG4gIGlmIChpc0FueShlbGVtZW50LCBbJ3Bvc3RpdDpQb3N0aXQnLCAncG9zdGl0OlRleHRCb3gnXSkpIHtcbiAgICBhc3NpZ24ob3B0aW9ucywge1xuICAgICAgY2VudGVyVmVydGljYWxseTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gZXh0ZXJuYWwgbGFiZWxzXG4gIGlmIChpc0xhYmVsRXh0ZXJuYWwoZWxlbWVudCkpIHtcbiAgICBhc3NpZ24ob3B0aW9ucywge1xuICAgICAgYXV0b1Jlc2l6ZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cblxuICBhc3NpZ24oY29udGV4dCwge1xuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBlZGl0aW5nIGJvdW5kaW5nIGJveCBiYXNlZCBvbiB0aGUgZWxlbWVudCdzIHNpemUgYW5kIHBvc2l0aW9uXG4gKlxuICogQHBhcmFtICB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgICAgIGFuZCBzaXplIChmaXhlZCBvciBtaW5pbXVtIGFuZC9vciBtYXhpbXVtKVxuICovXG5MYWJlbEVkaXRpbmdQcm92aWRlci5wcm90b3R5cGUuZ2V0RWRpdGluZ0JCb3ggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cbiAgdmFyIHRhcmdldCA9IGVsZW1lbnQubGFiZWwgfHwgZWxlbWVudDtcblxuICB2YXIgYmJveCA9IGNhbnZhcy5nZXRBYnNvbHV0ZUJCb3godGFyZ2V0KTtcblxuICB2YXIgbWlkID0ge1xuICAgIHg6IGJib3gueCArIGJib3gud2lkdGggLyAyLFxuICAgIHk6IGJib3gueSArIGJib3guaGVpZ2h0IC8gMlxuICB9O1xuXG4gIC8vIGRlZmF1bHQgcG9zaXRpb25cbiAgdmFyIGJvdW5kcyA9IHsgeDogYmJveC54LCB5OiBiYm94LnkgfTtcblxuICB2YXIgem9vbSA9IGNhbnZhcy56b29tKCk7XG5cbiAgdmFyIGRlZmF1bHRTdHlsZSA9IHRoaXMuX3RleHRSZW5kZXJlci5nZXREZWZhdWx0U3R5bGUoKSxcbiAgICAgIGV4dGVybmFsU3R5bGUgPSB0aGlzLl90ZXh0UmVuZGVyZXIuZ2V0RXh0ZXJuYWxTdHlsZSgpO1xuXG4gIC8vIHRha2Ugem9vbSBpbnRvIGFjY291bnRcbiAgdmFyIGV4dGVybmFsRm9udFNpemUgPSBleHRlcm5hbFN0eWxlLmZvbnRTaXplICogem9vbSxcbiAgICAgIGV4dGVybmFsTGluZUhlaWdodCA9IGV4dGVybmFsU3R5bGUubGluZUhlaWdodCxcbiAgICAgIGRlZmF1bHRGb250U2l6ZSA9IGRlZmF1bHRTdHlsZS5mb250U2l6ZSAqIHpvb20sXG4gICAgICBkZWZhdWx0TGluZUhlaWdodCA9IGRlZmF1bHRTdHlsZS5saW5lSGVpZ2h0O1xuXG4gIHZhciBzdHlsZSA9IHtcbiAgICBmb250RmFtaWx5OiB0aGlzLl90ZXh0UmVuZGVyZXIuZ2V0RGVmYXVsdFN0eWxlKCkuZm9udEZhbWlseSxcbiAgICBmb250V2VpZ2h0OiB0aGlzLl90ZXh0UmVuZGVyZXIuZ2V0RGVmYXVsdFN0eWxlKCkuZm9udFdlaWdodFxuICB9O1xuXG5cbiAgaWYgKGlzQW55KGVsZW1lbnQsIFsgJ3Bvc3RpdDpQb3N0aXQnLCAncG9zdGl0OlRleHRCb3gnLCAncG9zdGl0Okdyb3VwJ10pKSB7XG5cbiAgICBhc3NpZ24oYm91bmRzLCB7XG4gICAgICB3aWR0aDogYmJveC53aWR0aCxcbiAgICAgIGhlaWdodDogYmJveC5oZWlnaHRcbiAgICB9KTtcblxuICAgIGFzc2lnbihzdHlsZSwge1xuICAgICAgZm9udFNpemU6IGRlZmF1bHRGb250U2l6ZSArICdweCcsXG4gICAgICBsaW5lSGVpZ2h0OiBkZWZhdWx0TGluZUhlaWdodCxcbiAgICAgIHBhZGRpbmdUb3A6ICg3ICogem9vbSkgKyAncHgnLFxuICAgICAgcGFkZGluZ0JvdHRvbTogKDcgKiB6b29tKSArICdweCcsXG4gICAgICBwYWRkaW5nTGVmdDogKDUgKiB6b29tKSArICdweCcsXG4gICAgICBwYWRkaW5nUmlnaHQ6ICg1ICogem9vbSkgKyAncHgnXG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2lkdGggPSA5MCAqIHpvb20sXG4gICAgICBwYWRkaW5nVG9wID0gNyAqIHpvb20sXG4gICAgICBwYWRkaW5nQm90dG9tID0gNCAqIHpvb207XG5cbiAgLy8gZXh0ZXJuYWwgbGFiZWxzIGZvciBldmVudHMsIGRhdGEgZWxlbWVudHMsIGdhdGV3YXlzLCBncm91cHMgYW5kIGNvbm5lY3Rpb25zXG4gIGlmICh0YXJnZXQubGFiZWxUYXJnZXQpIHtcbiAgICBhc3NpZ24oYm91bmRzLCB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGJib3guaGVpZ2h0ICsgcGFkZGluZ1RvcCArIHBhZGRpbmdCb3R0b20sXG4gICAgICB4OiBtaWQueCAtIHdpZHRoIC8gMixcbiAgICAgIHk6IGJib3gueSAtIHBhZGRpbmdUb3BcbiAgICB9KTtcblxuICAgIGFzc2lnbihzdHlsZSwge1xuICAgICAgZm9udFNpemU6IGV4dGVybmFsRm9udFNpemUgKyAncHgnLFxuICAgICAgbGluZUhlaWdodDogZXh0ZXJuYWxMaW5lSGVpZ2h0LFxuICAgICAgcGFkZGluZ1RvcDogcGFkZGluZ1RvcCArICdweCcsXG4gICAgICBwYWRkaW5nQm90dG9tOiBwYWRkaW5nQm90dG9tICsgJ3B4J1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZXh0ZXJuYWwgbGFiZWwgbm90IHlldCBjcmVhdGVkXG4gIGlmIChpc0xhYmVsRXh0ZXJuYWwodGFyZ2V0KVxuICAgICAgJiYgIWhhc0V4dGVybmFsTGFiZWwodGFyZ2V0KVxuICAgICAgJiYgIWlzTGFiZWwodGFyZ2V0KSkge1xuXG4gICAgdmFyIGV4dGVybmFsTGFiZWxNaWQgPSBnZXRFeHRlcm5hbExhYmVsTWlkKGVsZW1lbnQpO1xuXG4gICAgdmFyIGFic29sdXRlQkJveCA9IGNhbnZhcy5nZXRBYnNvbHV0ZUJCb3goe1xuICAgICAgeDogZXh0ZXJuYWxMYWJlbE1pZC54LFxuICAgICAgeTogZXh0ZXJuYWxMYWJlbE1pZC55LFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9KTtcblxuICAgIHZhciBoZWlnaHQgPSBleHRlcm5hbEZvbnRTaXplICsgcGFkZGluZ1RvcCArIHBhZGRpbmdCb3R0b207XG5cbiAgICBhc3NpZ24oYm91bmRzLCB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHg6IGFic29sdXRlQkJveC54IC0gd2lkdGggLyAyLFxuICAgICAgeTogYWJzb2x1dGVCQm94LnkgLSBoZWlnaHQgLyAyXG4gICAgfSk7XG5cbiAgICBhc3NpZ24oc3R5bGUsIHtcbiAgICAgIGZvbnRTaXplOiBleHRlcm5hbEZvbnRTaXplICsgJ3B4JyxcbiAgICAgIGxpbmVIZWlnaHQ6IGV4dGVybmFsTGluZUhlaWdodCxcbiAgICAgIHBhZGRpbmdUb3A6IHBhZGRpbmdUb3AgKyAncHgnLFxuICAgICAgcGFkZGluZ0JvdHRvbTogcGFkZGluZ0JvdHRvbSArICdweCdcbiAgICB9KTtcbiAgfVxuXG5cbiAgLy8gdHJhbnNwYXJlbnQgZWRpdCBib3hcbiAgaWYgKGlzQW55KGVsZW1lbnQsIFsgJ3Bvc3RpdDpQb3N0aXQnIF0pKSB7XG4gICAgYXNzaWduKHN0eWxlLCB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7IGJvdW5kczogYm91bmRzLCBzdHlsZTogc3R5bGUgfTtcbn07XG5cblxuTGFiZWxFZGl0aW5nUHJvdmlkZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG5ld0xhYmVsKSB7XG5cbiAgaWYgKGlzRW1wdHlUZXh0KG5ld0xhYmVsKSkge1xuICAgIG5ld0xhYmVsID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuX21vZGVsaW5nLnVwZGF0ZUxhYmVsKGVsZW1lbnQsIG5ld0xhYmVsKTtcbn07XG5cblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNFbXB0eVRleHQobGFiZWwpIHtcbiAgcmV0dXJuICFsYWJlbCB8fCAhbGFiZWwudHJpbSgpO1xufSIsImltcG9ydCB7IGlzQW55IH0gZnJvbSAnLi4vbW9kZWxpbmcvdXRpbC9Nb2RlbGluZ1V0aWwnO1xuXG5mdW5jdGlvbiBnZXRMYWJlbEF0dHIoc2VtYW50aWMpIHtcbiAgaWYgKGlzQW55KHNlbWFudGljLCBbICdwb3N0aXQ6UG9zdGl0JywgJ3Bvc3RpdDpUZXh0Qm94JywgJ3Bvc3RpdDpHcm91cCcgXSkpIHtcbiAgICByZXR1cm4gJ25hbWUnO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYWJlbChlbGVtZW50KSB7XG4gIHZhciBzZW1hbnRpYyA9IGVsZW1lbnQuYnVzaW5lc3NPYmplY3QsXG4gICAgICBhdHRyID0gZ2V0TGFiZWxBdHRyKHNlbWFudGljKTtcblxuICBpZiAoYXR0cikge1xuICAgIHJldHVybiBzZW1hbnRpY1thdHRyXSB8fCAnJztcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRMYWJlbChlbGVtZW50LCB0ZXh0KSB7XG4gIHZhciBzZW1hbnRpYyA9IGVsZW1lbnQuYnVzaW5lc3NPYmplY3QsXG4gICAgICBhdHRyID0gZ2V0TGFiZWxBdHRyKHNlbWFudGljKTtcblxuICBpZiAoYXR0cikge1xuICAgIHNlbWFudGljW2F0dHJdID0gdGV4dDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufSIsImltcG9ydCB7XG4gIHNldExhYmVsLFxuICBnZXRMYWJlbFxufSBmcm9tICcuLi9MYWJlbFV0aWwnO1xuXG5pbXBvcnQge1xuICBnZXRFeHRlcm5hbExhYmVsTWlkLFxuICBpc0xhYmVsRXh0ZXJuYWwsXG4gIGhhc0V4dGVybmFsTGFiZWwsXG4gIGlzTGFiZWxcbn0gZnJvbSAnLi4vLi4vLi4vdXRpbC9MYWJlbFV0aWwnO1xuXG52YXIgTlVMTF9ESU1FTlNJT05TID0ge1xuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwXG59O1xuXG5cbi8qKlxuICogQSBoYW5kbGVyIHRoYXQgdXBkYXRlcyB0aGUgdGV4dCBvZiBhIHBvc3RpdCBlbGVtZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBVcGRhdGVMYWJlbEhhbmRsZXIobW9kZWxpbmcsIHRleHRSZW5kZXJlcikge1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxhYmVsIGFuZCByZXR1cm4gdGhlIGNoYW5nZWQgZWxlbWVudHMuXG4gICAqXG4gICAqIEVsZW1lbnQgcGFyYW1ldGVyIGNhbiBiZSBsYWJlbCBpdHNlbGYgb3IgY29ubmVjdGlvbiAoaS5lLiBzZXF1ZW5jZSBmbG93KS5cbiAgICpcbiAgICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VGV4dChlbGVtZW50LCB0ZXh0KSB7XG5cbiAgICAvLyBleHRlcm5hbCBsYWJlbCBpZiBwcmVzZW50XG4gICAgdmFyIGxhYmVsID0gZWxlbWVudC5sYWJlbCB8fCBlbGVtZW50O1xuXG4gICAgdmFyIGxhYmVsVGFyZ2V0ID0gZWxlbWVudC5sYWJlbFRhcmdldCB8fCBlbGVtZW50O1xuXG4gICAgc2V0TGFiZWwobGFiZWwsIHRleHQsIGxhYmVsVGFyZ2V0ICE9PSBsYWJlbCk7XG5cbiAgICByZXR1cm4gWyBsYWJlbCwgbGFiZWxUYXJnZXQgXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZUV4ZWN1dGUoY3R4KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBjdHguZWxlbWVudCxcbiAgICAgICAgYnVzaW5lc3NPYmplY3QgPSBlbGVtZW50LmJ1c2luZXNzT2JqZWN0LFxuICAgICAgICBuZXdMYWJlbCA9IGN0eC5uZXdMYWJlbDtcblxuICAgIGlmICghaXNMYWJlbChlbGVtZW50KVxuICAgICAgICAmJiBpc0xhYmVsRXh0ZXJuYWwoZWxlbWVudClcbiAgICAgICAgJiYgIWhhc0V4dGVybmFsTGFiZWwoZWxlbWVudClcbiAgICAgICAgJiYgIWlzRW1wdHlUZXh0KG5ld0xhYmVsKSkge1xuXG4gICAgICAvLyBjcmVhdGUgbGFiZWxcbiAgICAgIHZhciBwYWRkaW5nVG9wID0gNztcblxuICAgICAgdmFyIGxhYmVsQ2VudGVyID0gZ2V0RXh0ZXJuYWxMYWJlbE1pZChlbGVtZW50KTtcblxuICAgICAgbGFiZWxDZW50ZXIgPSB7XG4gICAgICAgIHg6IGxhYmVsQ2VudGVyLngsXG4gICAgICAgIHk6IGxhYmVsQ2VudGVyLnkgKyBwYWRkaW5nVG9wXG4gICAgICB9O1xuXG4gICAgICBtb2RlbGluZy5jcmVhdGVMYWJlbChlbGVtZW50LCBsYWJlbENlbnRlciwge1xuICAgICAgICBpZDogYnVzaW5lc3NPYmplY3QuaWQgKyAnX2xhYmVsJyxcbiAgICAgICAgYnVzaW5lc3NPYmplY3Q6IGJ1c2luZXNzT2JqZWN0XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleGVjdXRlKGN0eCkge1xuICAgIGN0eC5vbGRMYWJlbCA9IGdldExhYmVsKGN0eC5lbGVtZW50KTtcbiAgICByZXR1cm4gc2V0VGV4dChjdHguZWxlbWVudCwgY3R4Lm5ld0xhYmVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVydChjdHgpIHtcbiAgICByZXR1cm4gc2V0VGV4dChjdHguZWxlbWVudCwgY3R4Lm9sZExhYmVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc3RFeGVjdXRlKGN0eCkge1xuICAgIHZhciBlbGVtZW50ID0gY3R4LmVsZW1lbnQsXG4gICAgICAgIGxhYmVsID0gZWxlbWVudC5sYWJlbCB8fCBlbGVtZW50LFxuICAgICAgICBuZXdMYWJlbCA9IGN0eC5uZXdMYWJlbCxcbiAgICAgICAgbmV3Qm91bmRzID0gY3R4Lm5ld0JvdW5kcyxcbiAgICAgICAgaGludHMgPSBjdHguaGludHMgfHwge307XG5cbiAgICAvLyBpZ25vcmUgaW50ZXJuYWwgbGFiZWxzIGZvciBlbGVtZW50c1xuICAgIGlmICghaXNMYWJlbChsYWJlbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNMYWJlbChsYWJlbCkgJiYgaXNFbXB0eVRleHQobmV3TGFiZWwpKSB7XG5cbiAgICAgIGlmIChoaW50cy5yZW1vdmVTaGFwZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgbW9kZWxpbmcucmVtb3ZlU2hhcGUobGFiZWwsIHsgdW5zZXRMYWJlbDogZmFsc2UgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IGdldExhYmVsKGxhYmVsKTtcblxuICAgIC8vIHJlc2l6ZSBlbGVtZW50IGJhc2VkIG9uIGxhYmVsIF9vcl8gcHJlLWRlZmluZWQgYm91bmRzXG4gICAgaWYgKHR5cGVvZiBuZXdCb3VuZHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBuZXdCb3VuZHMgPSB0ZXh0UmVuZGVyZXIuZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kcyhsYWJlbCwgdGV4dCk7XG4gICAgfVxuXG4gICAgLy8gc2V0dGluZyBuZXdCb3VuZHMgdG8gZmFsc2Ugb3IgX251bGxfIHdpbGxcbiAgICAvLyBkaXNhYmxlIHRoZSBwb3N0RXhlY3V0ZSByZXNpemUgb3BlcmF0aW9uXG4gICAgaWYgKG5ld0JvdW5kcykge1xuICAgICAgbW9kZWxpbmcucmVzaXplU2hhcGUobGFiZWwsIG5ld0JvdW5kcywgTlVMTF9ESU1FTlNJT05TKTtcbiAgICB9XG4gIH1cblxuICAvLyBBUElcblxuICB0aGlzLnByZUV4ZWN1dGUgPSBwcmVFeGVjdXRlO1xuICB0aGlzLmV4ZWN1dGUgPSBleGVjdXRlO1xuICB0aGlzLnJldmVydCA9IHJldmVydDtcbiAgdGhpcy5wb3N0RXhlY3V0ZSA9IHBvc3RFeGVjdXRlO1xufVxuXG5VcGRhdGVMYWJlbEhhbmRsZXIuJGluamVjdCA9IFtcbiAgJ21vZGVsaW5nJyxcbiAgJ3RleHRSZW5kZXJlcidcbl07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc0VtcHR5VGV4dChsYWJlbCkge1xuICByZXR1cm4gIWxhYmVsIHx8ICFsYWJlbC50cmltKCk7XG59IiwiaW1wb3J0IENoYW5nZVN1cHBvcnRNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY2hhbmdlLXN1cHBvcnQnO1xuaW1wb3J0IFJlc2l6ZU1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9yZXNpemUnO1xuaW1wb3J0IERpcmVjdEVkaXRpbmdNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy1kaXJlY3QtZWRpdGluZyc7XG5cbmltcG9ydCBMYWJlbEVkaXRpbmdQcm92aWRlciBmcm9tICcuL0xhYmVsRWRpdGluZ1Byb3ZpZGVyJztcbmltcG9ydCBMYWJlbEVkaXRpbmdQcmV2aWV3IGZyb20gJy4vTGFiZWxFZGl0aW5nUHJldmlldyc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIENoYW5nZVN1cHBvcnRNb2R1bGUsXG4gICAgUmVzaXplTW9kdWxlLFxuICAgIERpcmVjdEVkaXRpbmdNb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFtcbiAgICAnbGFiZWxFZGl0aW5nUHJvdmlkZXInLFxuICAgICdsYWJlbEVkaXRpbmdQcmV2aWV3J1xuICBdLFxuICBsYWJlbEVkaXRpbmdQcm92aWRlcjogWyAndHlwZScsIExhYmVsRWRpdGluZ1Byb3ZpZGVyIF0sXG4gIGxhYmVsRWRpdGluZ1ByZXZpZXc6IFsgJ3R5cGUnLCBMYWJlbEVkaXRpbmdQcmV2aWV3IF1cbn07XG4iLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uLy4uL3V0aWwvTW9kZWxVdGlsJztcblxuaW1wb3J0IEJhc2VFbGVtZW50RmFjdG9yeSBmcm9tICdkaWFncmFtLWpzL2xpYi9jb3JlL0VsZW1lbnRGYWN0b3J5JztcblxuaW1wb3J0IHtcbiAgREVGQVVMVF9MQUJFTF9TSVpFXG59IGZyb20gJy4uLy4uL3V0aWwvTGFiZWxVdGlsJztcblxuXG4vKipcbiAqIEEgcG9zdGl0LWF3YXJlIGZhY3RvcnkgZm9yIGRpYWdyYW0tanMgc2hhcGVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVsZW1lbnRGYWN0b3J5KHBvc3RpdEZhY3RvcnksIG1vZGRsZSwgdHJhbnNsYXRlKSB7XG4gIEJhc2VFbGVtZW50RmFjdG9yeS5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuX3Bvc3RpdEZhY3RvcnkgPSBwb3N0aXRGYWN0b3J5O1xuICB0aGlzLl9tb2RkbGUgPSBtb2RkbGU7XG4gIHRoaXMuX3RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbn1cblxuaW5oZXJpdHMoRWxlbWVudEZhY3RvcnksIEJhc2VFbGVtZW50RmFjdG9yeSk7XG5cbkVsZW1lbnRGYWN0b3J5LiRpbmplY3QgPSBbXG4gICdwb3N0aXRGYWN0b3J5JyxcbiAgJ21vZGRsZScsXG4gICd0cmFuc2xhdGUnXG5dO1xuXG5FbGVtZW50RmFjdG9yeS5wcm90b3R5cGUuYmFzZUNyZWF0ZSA9IEJhc2VFbGVtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlO1xuXG5FbGVtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oZWxlbWVudFR5cGUsIGF0dHJzKSB7XG5cbiAgLy8gbm8gc3BlY2lhbCBtYWdpYyBmb3IgbGFiZWxzLFxuICAvLyB3ZSBhc3N1bWUgdGhlaXIgYnVzaW5lc3NPYmplY3RzIGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgLy8gYW5kIHdpcmVkIHZpYSBhdHRyc1xuICBpZiAoZWxlbWVudFR5cGUgPT09ICdsYWJlbCcpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlQ3JlYXRlKGVsZW1lbnRUeXBlLCBhc3NpZ24oeyB0eXBlOiAnbGFiZWwnIH0sIERFRkFVTFRfTEFCRUxfU0laRSwgYXR0cnMpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmNyZWF0ZVBvc3RpdEVsZW1lbnQoZWxlbWVudFR5cGUsIGF0dHJzKTtcbn07XG5cbkVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVQb3N0aXRFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudFR5cGUsIGF0dHJzKSB7XG4gIHZhciBzaXplLFxuICAgICAgdHJhbnNsYXRlID0gdGhpcy5fdHJhbnNsYXRlO1xuXG4gIGF0dHJzID0gYXR0cnMgfHwge307XG5cbiAgdmFyIGJ1c2luZXNzT2JqZWN0ID0gYXR0cnMuYnVzaW5lc3NPYmplY3Q7XG5cbiAgaWYgKCFidXNpbmVzc09iamVjdCkge1xuICAgIGlmICghYXR0cnMudHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zbGF0ZSgnbm8gc2hhcGUgdHlwZSBzcGVjaWZpZWQnKSk7XG4gICAgfVxuXG4gICAgYnVzaW5lc3NPYmplY3QgPSB0aGlzLl9wb3N0aXRGYWN0b3J5LmNyZWF0ZShhdHRycy50eXBlKTtcbiAgfVxuXG4gIGlmICghYnVzaW5lc3NPYmplY3QuZGkpIHtcbiAgICBpZiAoZWxlbWVudFR5cGUgPT09ICdyb290Jykge1xuICAgICAgYnVzaW5lc3NPYmplY3QuZGkgPSB0aGlzLl9wb3N0aXRGYWN0b3J5LmNyZWF0ZURpUGxhbmUoYnVzaW5lc3NPYmplY3QsIFtdLCB7XG4gICAgICAgIGlkOiBidXNpbmVzc09iamVjdC5pZCArICdfZGknXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVzaW5lc3NPYmplY3QuZGkgPSB0aGlzLl9wb3N0aXRGYWN0b3J5LmNyZWF0ZURpU2hhcGUoYnVzaW5lc3NPYmplY3QsIHt9LCB7XG4gICAgICAgIGlkOiBidXNpbmVzc09iamVjdC5pZCArICdfZGknXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXMoYnVzaW5lc3NPYmplY3QsICdwb3N0aXQ6R3JvdXAnKSkge1xuICAgIGF0dHJzID0gYXNzaWduKHtcbiAgICAgIGlzRnJhbWU6IHRydWVcbiAgICB9LCBhdHRycyk7XG4gIH1cblxuICBpZiAoYXR0cnMuZGkpIHtcbiAgICBhc3NpZ24oYnVzaW5lc3NPYmplY3QuZGksIGF0dHJzLmRpKTtcblxuICAgIGRlbGV0ZSBhdHRycy5kaTtcbiAgfVxuXG4gIGFwcGx5QXR0cmlidXRlcyhidXNpbmVzc09iamVjdCwgYXR0cnMsIFtcbiAgICAncHJvY2Vzc1JlZicsXG4gICAgJ2lzSW50ZXJydXB0aW5nJyxcbiAgICAnYXNzb2NpYXRpb25EaXJlY3Rpb24nLFxuICAgICdpc0ZvckNvbXBlbnNhdGlvbidcbiAgXSk7XG5cbiAgc2l6ZSA9IHRoaXMuX2dldERlZmF1bHRTaXplKGJ1c2luZXNzT2JqZWN0KTtcblxuICBhdHRycyA9IGFzc2lnbih7XG4gICAgYnVzaW5lc3NPYmplY3Q6IGJ1c2luZXNzT2JqZWN0LFxuICAgIGlkOiBidXNpbmVzc09iamVjdC5pZFxuICB9LCBzaXplLCBhdHRycyk7XG5cbiAgcmV0dXJuIHRoaXMuYmFzZUNyZWF0ZShlbGVtZW50VHlwZSwgYXR0cnMpO1xufTtcblxuXG5FbGVtZW50RmFjdG9yeS5wcm90b3R5cGUuX2dldERlZmF1bHRTaXplID0gZnVuY3Rpb24oc2VtYW50aWMpIHtcbiAgaWYgKGlzKHNlbWFudGljLCAncG9zdGl0OlBvc3RpdCcpKSB7XG4gICAgcmV0dXJuIHsgd2lkdGg6IDE1MCwgaGVpZ2h0OiAxNTAgfTtcbiAgfVxuXG4gIGlmIChpcyhzZW1hbnRpYywgJ3Bvc3RpdDpHcm91cCcpKSB7XG4gICAgcmV0dXJuIHsgd2lkdGg6IDMwMCwgaGVpZ2h0OiAzMDAgfTtcbiAgfVxuXG4gIGlmIChpcyhzZW1hbnRpYywgJ3Bvc3RpdDpJbWFnZScpKSB7XG4gICAgcmV0dXJuIHsgd2lkdGg6IDMwMCwgaGVpZ2h0OiAzMDAgfTtcbiAgfVxuXG4gIHJldHVybiB7IHdpZHRoOiAxMDAsIGhlaWdodDogODAgfTtcbn07XG5cblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBcHBseSBhdHRyaWJ1dGVzIGZyb20gYSBtYXAgdG8gdGhlIGdpdmVuIGVsZW1lbnQsXG4gKiByZW1vdmUgYXR0cmlidXRlIGZyb20gdGhlIG1hcCBvbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Jhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyAoaW4vb3V0IG1hcCBvZiBhdHRyaWJ1dGVzKVxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBhdHRyaWJ1dGVOYW1lcyBuYW1lIG9mIGF0dHJpYnV0ZXMgdG8gYXBwbHlcbiAqL1xuZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJzLCBhdHRyaWJ1dGVOYW1lcykge1xuXG4gIGZvckVhY2goYXR0cmlidXRlTmFtZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgaWYgKGF0dHJzW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcHBseUF0dHJpYnV0ZShlbGVtZW50LCBhdHRycywgcHJvcGVydHkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQXBwbHkgbmFtZWQgcHJvcGVydHkgdG8gZWxlbWVudCBhbmQgZHJhaW4gaXQgZnJvbSB0aGUgYXR0cnNcbiAqIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtCYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgKGluL291dCBtYXAgb2YgYXR0cmlidXRlcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIHRvIGFwcGx5XG4gKi9cbmZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJzLCBhdHRyaWJ1dGVOYW1lKSB7XG4gIGVsZW1lbnRbYXR0cmlidXRlTmFtZV0gPSBhdHRyc1thdHRyaWJ1dGVOYW1lXTtcblxuICBkZWxldGUgYXR0cnNbYXR0cmlidXRlTmFtZV07XG59IiwiaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IEJhc2VNb2RlbGluZyBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9Nb2RlbGluZyc7XG5cbmltcG9ydCBVcGRhdGVQcm9wZXJ0aWVzSGFuZGxlciBmcm9tICcuL2NtZC9VcGRhdGVQcm9wZXJ0aWVzSGFuZGxlcic7XG5pbXBvcnQgVXBkYXRlQ2FudmFzUm9vdEhhbmRsZXIgZnJvbSAnLi9jbWQvVXBkYXRlQ2FudmFzUm9vdEhhbmRsZXInO1xuaW1wb3J0IElkQ2xhaW1IYW5kbGVyIGZyb20gJy4vY21kL0lkQ2xhaW1IYW5kbGVyJztcbmltcG9ydCBTZXRDb2xvckhhbmRsZXIgZnJvbSAnLi9jbWQvU2V0Q29sb3JIYW5kbGVyJztcblxuaW1wb3J0IFVwZGF0ZUxhYmVsSGFuZGxlciBmcm9tICcuLi9sYWJlbC1lZGl0aW5nL2NtZC9VcGRhdGVMYWJlbEhhbmRsZXInO1xuXG5cbi8qKlxuICogUG9zdGl0IG1vZGVsaW5nIGZlYXR1cmVzIGFjdGl2YXRvclxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0VsZW1lbnRGYWN0b3J5fSBlbGVtZW50RmFjdG9yeVxuICogQHBhcmFtIHtDb21tYW5kU3RhY2t9IGNvbW1hbmRTdGFja1xuICogQHBhcmFtIHtQb3N0aXRSdWxlc30gcG9zdGl0UnVsZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW9kZWxpbmcoXG4gICAgZXZlbnRCdXMsIGVsZW1lbnRGYWN0b3J5LCBjb21tYW5kU3RhY2ssXG4gICAgcG9zdGl0UnVsZXMpIHtcblxuICBCYXNlTW9kZWxpbmcuY2FsbCh0aGlzLCBldmVudEJ1cywgZWxlbWVudEZhY3RvcnksIGNvbW1hbmRTdGFjayk7XG5cbiAgdGhpcy5fcG9zdGl0UnVsZXMgPSBwb3N0aXRSdWxlcztcbn1cblxuaW5oZXJpdHMoTW9kZWxpbmcsIEJhc2VNb2RlbGluZyk7XG5cbk1vZGVsaW5nLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdlbGVtZW50RmFjdG9yeScsXG4gICdjb21tYW5kU3RhY2snLFxuICAncG9zdGl0UnVsZXMnXG5dO1xuXG5cbk1vZGVsaW5nLnByb3RvdHlwZS5nZXRIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGFuZGxlcnMgPSBCYXNlTW9kZWxpbmcucHJvdG90eXBlLmdldEhhbmRsZXJzLmNhbGwodGhpcyk7XG5cbiAgaGFuZGxlcnNbJ2VsZW1lbnQudXBkYXRlUHJvcGVydGllcyddID0gVXBkYXRlUHJvcGVydGllc0hhbmRsZXI7XG4gIGhhbmRsZXJzWydjYW52YXMudXBkYXRlUm9vdCddID0gVXBkYXRlQ2FudmFzUm9vdEhhbmRsZXI7XG4gIGhhbmRsZXJzWydpZC51cGRhdGVDbGFpbSddID0gSWRDbGFpbUhhbmRsZXI7XG4gIGhhbmRsZXJzWydlbGVtZW50LnNldENvbG9yJ10gPSBTZXRDb2xvckhhbmRsZXI7XG4gIGhhbmRsZXJzWydlbGVtZW50LnVwZGF0ZUxhYmVsJ10gPSBVcGRhdGVMYWJlbEhhbmRsZXI7XG5cbiAgcmV0dXJuIGhhbmRsZXJzO1xufTtcblxuXG5Nb2RlbGluZy5wcm90b3R5cGUudXBkYXRlTGFiZWwgPSBmdW5jdGlvbihlbGVtZW50LCBuZXdMYWJlbCwgbmV3Qm91bmRzLCBoaW50cykge1xuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnZWxlbWVudC51cGRhdGVMYWJlbCcsIHtcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIG5ld0xhYmVsOiBuZXdMYWJlbCxcbiAgICBuZXdCb3VuZHM6IG5ld0JvdW5kcyxcbiAgICBoaW50czogaGludHMgfHwge31cbiAgfSk7XG59O1xuXG5cbk1vZGVsaW5nLnByb3RvdHlwZS51cGRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydGllcykge1xuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnZWxlbWVudC51cGRhdGVQcm9wZXJ0aWVzJywge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgcHJvcGVydGllczogcHJvcGVydGllc1xuICB9KTtcbn07XG5cbk1vZGVsaW5nLnByb3RvdHlwZS5jbGFpbUlkID0gZnVuY3Rpb24oaWQsIG1vZGRsZUVsZW1lbnQpIHtcbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2lkLnVwZGF0ZUNsYWltJywge1xuICAgIGlkOiBpZCxcbiAgICBlbGVtZW50OiBtb2RkbGVFbGVtZW50LFxuICAgIGNsYWltaW5nOiB0cnVlXG4gIH0pO1xufTtcblxuXG5Nb2RlbGluZy5wcm90b3R5cGUudW5jbGFpbUlkID0gZnVuY3Rpb24oaWQsIG1vZGRsZUVsZW1lbnQpIHtcbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2lkLnVwZGF0ZUNsYWltJywge1xuICAgIGlkOiBpZCxcbiAgICBlbGVtZW50OiBtb2RkbGVFbGVtZW50XG4gIH0pO1xufTtcblxuTW9kZWxpbmcucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24oZWxlbWVudHMsIGNvbG9yKSB7XG4gIGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgZWxlbWVudHMgPSBbIGVsZW1lbnRzIF07XG4gIH1cblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnZWxlbWVudC5zZXRDb2xvcicsIHtcbiAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgY29sb3I6IGNvbG9yXG4gIH0pO1xufTtcbiIsImltcG9ydCB7XG4gIGFzc2lnbixcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBpc0FueVxufSBmcm9tICcuL3V0aWwvTW9kZWxpbmdVdGlsJztcblxuaW1wb3J0IHtcbiAgaXNcbn0gZnJvbSAnLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvc2l0RmFjdG9yeShtb2RkbGUpIHtcbiAgdGhpcy5fbW9kZWwgPSBtb2RkbGU7XG59XG5cblBvc2l0RmFjdG9yeS4kaW5qZWN0ID0gWyAnbW9kZGxlJyBdO1xuXG5cblBvc2l0RmFjdG9yeS5wcm90b3R5cGUuX25lZWRzSWQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiBpc0FueShlbGVtZW50LCBbXG4gICAgJ3Bvc3RpdDpCb2FyZEVsZW1lbnQnXG4gIF0pO1xufTtcblxuUG9zaXRGYWN0b3J5LnByb3RvdHlwZS5fZW5zdXJlSWQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgLy8gZ2VuZXJhdGUgc2VtYW50aWMgaWRzIGZvciBlbGVtZW50c1xuICAvLyBwb3N0aXQ6UG9zdGl0IC0+IFBvc2l0aXRfSURcbiAgdmFyIHByZWZpeDtcblxuICBpZiAoaXMoZWxlbWVudCwgJ3Bvc3RpdDpQb3N0aXQnKSkge1xuICAgIHByZWZpeCA9ICdQb3N0aXQnO1xuICB9IGVsc2Uge1xuICAgIHByZWZpeCA9IChlbGVtZW50LiR0eXBlIHx8ICcnKS5yZXBsYWNlKC9eW146XSo6L2csICcnKTtcbiAgfVxuXG4gIHByZWZpeCArPSAnXyc7XG5cbiAgaWYgKCFlbGVtZW50LmlkICYmIHRoaXMuX25lZWRzSWQoZWxlbWVudCkpIHtcbiAgICBlbGVtZW50LmlkID0gdGhpcy5fbW9kZWwuaWRzLm5leHRQcmVmaXhlZChwcmVmaXgsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5cblBvc2l0RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24odHlwZSwgYXR0cnMpIHtcbiAgdmFyIGVsZW1lbnQgPSB0aGlzLl9tb2RlbC5jcmVhdGUodHlwZSwgYXR0cnMgfHwge30pO1xuXG4gIHRoaXMuX2Vuc3VyZUlkKGVsZW1lbnQpO1xuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuXG5Qb3NpdEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZURpTGFiZWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlKCdwb3N0aXREaTpQb3N0aXRMYWJlbCcsIHtcbiAgICBib3VuZHM6IHRoaXMuY3JlYXRlRGlCb3VuZHMoKVxuICB9KTtcbn07XG5cblxuUG9zaXRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVEaVNoYXBlID0gZnVuY3Rpb24oc2VtYW50aWMsIGJvdW5kcywgYXR0cnMpIHtcblxuICByZXR1cm4gdGhpcy5jcmVhdGUoJ3Bvc3RpdERpOlBvc3RpdFNoYXBlJywgYXNzaWduKHtcbiAgICBib2FyZEVsZW1lbnQ6IHNlbWFudGljLFxuICAgIGJvdW5kczogdGhpcy5jcmVhdGVEaUJvdW5kcyhib3VuZHMpXG4gIH0sIGF0dHJzKSk7XG59O1xuXG5cblBvc2l0RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlRGlCb3VuZHMgPSBmdW5jdGlvbihib3VuZHMpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlKCdkYzpCb3VuZHMnLCBib3VuZHMpO1xufTtcblxuXG5Qb3NpdEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZURpUGxhbmUgPSBmdW5jdGlvbihzZW1hbnRpYykge1xuICByZXR1cm4gdGhpcy5jcmVhdGUoJ3Bvc3RpdERpOlBvc3RpdFBsYW5lJywge1xuICAgIGJvYXJkRWxlbWVudDogc2VtYW50aWNcbiAgfSk7XG59OyIsImltcG9ydCB7XG4gIGFzc2lnbixcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCB7XG4gIHJlbW92ZSBhcyBjb2xsZWN0aW9uUmVtb3ZlXG59IGZyb20gJ2RpYWdyYW0tanMvbGliL3V0aWwvQ29sbGVjdGlvbnMnO1xuXG5pbXBvcnQge1xuICBMYWJlbFxufSBmcm9tICdkaWFncmFtLWpzL2xpYi9tb2RlbCc7XG5cbmltcG9ydCB7XG4gIGlzXG59IGZyb20gJy4uLy4uL3V0aWwvTW9kZWxVdGlsJztcblxuaW1wb3J0IENvbW1hbmRJbnRlcmNlcHRvciBmcm9tICdkaWFncmFtLWpzL2xpYi9jb21tYW5kL0NvbW1hbmRJbnRlcmNlcHRvcic7XG5cbi8qKlxuICogQSBoYW5kbGVyIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZyB0aGUgdW5kZXJseWluZyBQb3N0aXQgWE1MICsgRElcbiAqIG9uY2UgY2hhbmdlcyBvbiB0aGUgZGlhZ3JhbSBoYXBwZW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0VXBkYXRlcihcbiAgICBldmVudEJ1cywgcG9zdGl0RmFjdG9yeSwgY29ubmVjdGlvbkRvY2tpbmcsXG4gICAgdHJhbnNsYXRlKSB7XG5cbiAgQ29tbWFuZEludGVyY2VwdG9yLmNhbGwodGhpcywgZXZlbnRCdXMpO1xuXG4gIHRoaXMuX3Bvc3RpdEZhY3RvcnkgPSBwb3N0aXRGYWN0b3J5O1xuICB0aGlzLl90cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cbiAgLy8gUG9zdGl0ICsgREkgdXBkYXRlIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gIC8vIHVwZGF0ZSBwYXJlbnRcbiAgZnVuY3Rpb24gdXBkYXRlUGFyZW50KGUpIHtcbiAgICB2YXIgY29udGV4dCA9IGUuY29udGV4dDtcblxuICAgIHNlbGYudXBkYXRlUGFyZW50KGNvbnRleHQuc2hhcGUgfHwgY29udGV4dC5jb25uZWN0aW9uLCBjb250ZXh0Lm9sZFBhcmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXZlcnNlVXBkYXRlUGFyZW50KGUpIHtcbiAgICB2YXIgY29udGV4dCA9IGUuY29udGV4dDtcblxuICAgIHZhciBlbGVtZW50ID0gY29udGV4dC5zaGFwZSB8fCBjb250ZXh0LmNvbm5lY3Rpb24sXG5cbiAgICAgICAgLy8gb2xkUGFyZW50IGlzIHRoZSAob2xkKSBuZXcgcGFyZW50LCBiZWNhdXNlIHdlIGFyZSB1bmRvaW5nXG4gICAgICAgIG9sZFBhcmVudCA9IGNvbnRleHQucGFyZW50IHx8IGNvbnRleHQubmV3UGFyZW50O1xuXG4gICAgc2VsZi51cGRhdGVQYXJlbnQoZWxlbWVudCwgb2xkUGFyZW50KTtcbiAgfVxuXG4gIHRoaXMuZXhlY3V0ZWQoW1xuICAgICdzaGFwZS5tb3ZlJyxcbiAgICAnc2hhcGUuY3JlYXRlJyxcbiAgICAnc2hhcGUuZGVsZXRlJ1xuICBdLCBpZlBvc3RpdCh1cGRhdGVQYXJlbnQpKTtcblxuICB0aGlzLnJldmVydGVkKFtcbiAgICAnc2hhcGUubW92ZScsXG4gICAgJ3NoYXBlLmNyZWF0ZScsXG4gICAgJ3NoYXBlLmRlbGV0ZSdcbiAgXSwgaWZQb3N0aXQocmV2ZXJzZVVwZGF0ZVBhcmVudCkpO1xuXG4gIC8qXG4gICAqICMjIFVwZGF0aW5nIFBhcmVudFxuICAgKlxuICAgKiBXaGVuIG1vcnBoaW5nIGEgcm9vdCBlbGVtZW50XG4gICAqIG1ha2Ugc3VyZSB0aGF0IGJvdGggdGhlICpzZW1hbnRpYyogYW5kICpkaSogcGFyZW50IG9mIGVhY2ggZWxlbWVudFxuICAgKiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlUm9vdChldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgb2xkUm9vdCA9IGNvbnRleHQub2xkUm9vdCxcbiAgICAgICAgY2hpbGRyZW4gPSBvbGRSb290LmNoaWxkcmVuO1xuXG4gICAgZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChpcyhjaGlsZCwgJ3Bvc3RpdDpCb2FyZEVsZW1lbnQnKSkge1xuICAgICAgICBzZWxmLnVwZGF0ZVBhcmVudChjaGlsZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLmV4ZWN1dGVkKFsgJ2NhbnZhcy51cGRhdGVSb290JyBdLCB1cGRhdGVSb290KTtcbiAgdGhpcy5yZXZlcnRlZChbICdjYW52YXMudXBkYXRlUm9vdCcgXSwgdXBkYXRlUm9vdCk7XG5cblxuICAvLyB1cGRhdGUgYm91bmRzXG4gIGZ1bmN0aW9uIHVwZGF0ZUJvdW5kcyhlKSB7XG4gICAgdmFyIHNoYXBlID0gZS5jb250ZXh0LnNoYXBlO1xuXG4gICAgaWYgKCFpcyhzaGFwZSwgJ3Bvc3RpdDpCb2FyZEVsZW1lbnQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYudXBkYXRlQm91bmRzKHNoYXBlKTtcbiAgfVxuXG4gIHRoaXMuZXhlY3V0ZWQoWyAnc2hhcGUubW92ZScsICdzaGFwZS5jcmVhdGUnLCAnc2hhcGUucmVzaXplJyBdLCBpZlBvc3RpdChmdW5jdGlvbihldmVudCkge1xuXG4gICAgLy8gZXhjbHVkZSBsYWJlbHMgYmVjYXVzZSB0aGV5J3JlIGhhbmRsZWQgc2VwYXJhdGVseSBkdXJpbmcgc2hhcGUuY2hhbmdlZFxuICAgIGlmIChldmVudC5jb250ZXh0LnNoYXBlLnR5cGUgPT09ICdsYWJlbCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1cGRhdGVCb3VuZHMoZXZlbnQpO1xuICB9KSk7XG5cbiAgdGhpcy5yZXZlcnRlZChbICdzaGFwZS5tb3ZlJywgJ3NoYXBlLmNyZWF0ZScsICdzaGFwZS5yZXNpemUnIF0sIGlmUG9zdGl0KGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAvLyBleGNsdWRlIGxhYmVscyBiZWNhdXNlIHRoZXkncmUgaGFuZGxlZCBzZXBhcmF0ZWx5IGR1cmluZyBzaGFwZS5jaGFuZ2VkXG4gICAgaWYgKGV2ZW50LmNvbnRleHQuc2hhcGUudHlwZSA9PT0gJ2xhYmVsJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZUJvdW5kcyhldmVudCk7XG4gIH0pKTtcblxuICAvLyBIYW5kbGUgbGFiZWxzIHNlcGFyYXRlbHkuIFRoaXMgaXMgbmVjZXNzYXJ5LCBiZWNhdXNlIHRoZSBsYWJlbCBib3VuZHMgaGF2ZSB0byBiZSB1cGRhdGVkXG4gIC8vIGV2ZXJ5IHRpbWUgaXRzIHNoYXBlIGNoYW5nZXMsIG5vdCBvbmx5IG9uIG1vdmUsIGNyZWF0ZSBhbmQgcmVzaXplLlxuICBldmVudEJ1cy5vbignc2hhcGUuY2hhbmdlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmVsZW1lbnQudHlwZSA9PT0gJ2xhYmVsJykge1xuICAgICAgdXBkYXRlQm91bmRzKHsgY29udGV4dDogeyBzaGFwZTogZXZlbnQuZWxlbWVudCB9IH0pO1xuICAgIH1cbiAgfSk7XG5cbn1cblxuaW5oZXJpdHMoUG9zdGl0VXBkYXRlciwgQ29tbWFuZEludGVyY2VwdG9yKTtcblxuUG9zdGl0VXBkYXRlci4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAncG9zdGl0RmFjdG9yeScsXG4gICdjb25uZWN0aW9uRG9ja2luZycsXG4gICd0cmFuc2xhdGUnXG5dO1xuXG5cbi8vIGltcGxlbWVudGF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuUG9zdGl0VXBkYXRlci5wcm90b3R5cGUudXBkYXRlQXR0YWNobWVudCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgYnVzaW5lc3NPYmplY3QgPSBzaGFwZS5idXNpbmVzc09iamVjdCxcbiAgICAgIGhvc3QgPSBzaGFwZS5ob3N0O1xuXG4gIGJ1c2luZXNzT2JqZWN0LmF0dGFjaGVkVG9SZWYgPSBob3N0ICYmIGhvc3QuYnVzaW5lc3NPYmplY3Q7XG59O1xuXG5Qb3N0aXRVcGRhdGVyLnByb3RvdHlwZS51cGRhdGVQYXJlbnQgPSBmdW5jdGlvbihlbGVtZW50LCBvbGRQYXJlbnQpIHtcblxuICAvLyBkbyBub3QgdXBkYXRlIGxhYmVsIHBhcmVudFxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIExhYmVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhcmVudFNoYXBlID0gZWxlbWVudC5wYXJlbnQ7XG5cbiAgdmFyIGJ1c2luZXNzT2JqZWN0ID0gZWxlbWVudC5idXNpbmVzc09iamVjdCxcbiAgICAgIHBhcmVudEJ1c2luZXNzT2JqZWN0ID0gcGFyZW50U2hhcGUgJiYgcGFyZW50U2hhcGUuYnVzaW5lc3NPYmplY3QsXG4gICAgICBwYXJlbnREaSA9IHBhcmVudEJ1c2luZXNzT2JqZWN0ICYmIHBhcmVudEJ1c2luZXNzT2JqZWN0LmRpO1xuXG4gIHRoaXMudXBkYXRlU2VtYW50aWNQYXJlbnQoYnVzaW5lc3NPYmplY3QsIHBhcmVudEJ1c2luZXNzT2JqZWN0KTtcblxuICB0aGlzLnVwZGF0ZURpUGFyZW50KGJ1c2luZXNzT2JqZWN0LmRpLCBwYXJlbnREaSk7XG59O1xuXG5cblBvc3RpdFVwZGF0ZXIucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uKHNoYXBlKSB7XG5cbiAgdmFyIGRpID0gc2hhcGUuYnVzaW5lc3NPYmplY3QuZGk7XG5cbiAgdmFyIHRhcmdldCA9IChzaGFwZSBpbnN0YW5jZW9mIExhYmVsKSA/IHRoaXMuX2dldExhYmVsKGRpKSA6IGRpO1xuXG4gIHZhciBib3VuZHMgPSB0YXJnZXQuYm91bmRzO1xuXG4gIGlmICghYm91bmRzKSB7XG4gICAgYm91bmRzID0gdGhpcy5fcG9zdGl0RmFjdG9yeS5jcmVhdGVEaUJvdW5kcygpO1xuICAgIHRhcmdldC5zZXQoJ2JvdW5kcycsIGJvdW5kcyk7XG4gIH1cblxuICBhc3NpZ24oYm91bmRzLCB7XG4gICAgeDogc2hhcGUueCxcbiAgICB5OiBzaGFwZS55LFxuICAgIHdpZHRoOiBzaGFwZS53aWR0aCxcbiAgICBoZWlnaHQ6IHNoYXBlLmhlaWdodFxuICB9KTtcbn07XG5cblxuUG9zdGl0VXBkYXRlci5wcm90b3R5cGUudXBkYXRlRGlQYXJlbnQgPSBmdW5jdGlvbihkaSwgcGFyZW50RGkpIHtcblxuICBpZiAocGFyZW50RGkgJiYgIWlzKHBhcmVudERpLCAncG9zdGl0RGk6UG9zdGl0UGxhbmUnKSkge1xuICAgIHBhcmVudERpID0gcGFyZW50RGkuJHBhcmVudDtcbiAgfVxuXG4gIGlmIChkaS4kcGFyZW50ID09PSBwYXJlbnREaSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwbGFuZUVsZW1lbnRzID0gKHBhcmVudERpIHx8IGRpLiRwYXJlbnQpLmdldCgncGxhbmVFbGVtZW50Jyk7XG5cbiAgaWYgKHBhcmVudERpKSB7XG4gICAgcGxhbmVFbGVtZW50cy5wdXNoKGRpKTtcbiAgICBkaS4kcGFyZW50ID0gcGFyZW50RGk7XG4gIH0gZWxzZSB7XG4gICAgY29sbGVjdGlvblJlbW92ZShwbGFuZUVsZW1lbnRzLCBkaSk7XG4gICAgZGkuJHBhcmVudCA9IG51bGw7XG4gIH1cbn07XG5cblxuUG9zdGl0VXBkYXRlci5wcm90b3R5cGUudXBkYXRlU2VtYW50aWNQYXJlbnQgPSBmdW5jdGlvbihidXNpbmVzc09iamVjdCwgbmV3UGFyZW50LCB2aXN1YWxQYXJlbnQpIHtcblxuICB2YXIgY29udGFpbm1lbnQsXG4gICAgICB0cmFuc2xhdGUgPSB0aGlzLl90cmFuc2xhdGU7XG5cbiAgaWYgKGJ1c2luZXNzT2JqZWN0LiRwYXJlbnQgPT09IG5ld1BhcmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG5cbiAgaWYgKGlzKGJ1c2luZXNzT2JqZWN0LCAncG9zdGl0OkJvYXJkRWxlbWVudCcpKSB7XG4gICAgY29udGFpbm1lbnQgPSAnYm9hcmRFbGVtZW50cyc7XG4gIH1cblxuICBpZiAoIWNvbnRhaW5tZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zbGF0ZShcbiAgICAgICdubyBwYXJlbnQgZm9yIHtlbGVtZW50fSBpbiB7cGFyZW50fScsXG4gICAgICB7XG4gICAgICAgIGVsZW1lbnQ6IGJ1c2luZXNzT2JqZWN0LmlkLFxuICAgICAgICBwYXJlbnQ6IG5ld1BhcmVudC5pZFxuICAgICAgfVxuICAgICkpO1xuICB9XG5cbiAgdmFyIGNoaWxkcmVuO1xuXG4gIGlmIChidXNpbmVzc09iamVjdC4kcGFyZW50KSB7XG5cbiAgICAvLyByZW1vdmUgZnJvbSBvbGQgcGFyZW50XG4gICAgY2hpbGRyZW4gPSBidXNpbmVzc09iamVjdC4kcGFyZW50LmdldChjb250YWlubWVudCk7XG4gICAgY29sbGVjdGlvblJlbW92ZShjaGlsZHJlbiwgYnVzaW5lc3NPYmplY3QpO1xuICB9XG5cbiAgaWYgKCFuZXdQYXJlbnQpIHtcbiAgICBidXNpbmVzc09iamVjdC4kcGFyZW50ID0gbnVsbDtcbiAgfSBlbHNlIHtcblxuICAgIC8vIGFkZCB0byBuZXcgcGFyZW50XG4gICAgY2hpbGRyZW4gPSBuZXdQYXJlbnQuZ2V0KGNvbnRhaW5tZW50KTtcbiAgICBjaGlsZHJlbi5wdXNoKGJ1c2luZXNzT2JqZWN0KTtcbiAgICBidXNpbmVzc09iamVjdC4kcGFyZW50ID0gbmV3UGFyZW50O1xuICB9XG5cbiAgaWYgKHZpc3VhbFBhcmVudCkge1xuICAgIHZhciBkaUNoaWxkcmVuID0gdmlzdWFsUGFyZW50LmdldChjb250YWlubWVudCk7XG5cbiAgICBjb2xsZWN0aW9uUmVtb3ZlKGNoaWxkcmVuLCBidXNpbmVzc09iamVjdCk7XG5cbiAgICBpZiAobmV3UGFyZW50KSB7XG5cbiAgICAgIGlmICghZGlDaGlsZHJlbikge1xuICAgICAgICBkaUNoaWxkcmVuID0gW107XG4gICAgICAgIG5ld1BhcmVudC5zZXQoY29udGFpbm1lbnQsIGRpQ2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICBkaUNoaWxkcmVuLnB1c2goYnVzaW5lc3NPYmplY3QpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuUG9zdGl0VXBkYXRlci5wcm90b3R5cGUuX2dldExhYmVsID0gZnVuY3Rpb24oZGkpIHtcbiAgaWYgKCFkaS5sYWJlbCkge1xuICAgIGRpLmxhYmVsID0gdGhpcy5fcG9zdGl0RmFjdG9yeS5jcmVhdGVEaUxhYmVsKCk7XG4gIH1cblxuICByZXR1cm4gZGkubGFiZWw7XG59O1xuXG5cbi8qKlxuICogTWFrZSBzdXJlIHRoZSBldmVudCBsaXN0ZW5lciBpcyBvbmx5IGNhbGxlZFxuICogaWYgdGhlIHRvdWNoZWQgZWxlbWVudCBpcyBhIHBvc3RpdCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259IGd1YXJkZWQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaWZQb3N0aXQoZm4pIHtcblxuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgZWxlbWVudCA9IGNvbnRleHQuc2hhcGUgfHwgY29udGV4dC5jb25uZWN0aW9uO1xuXG4gICAgaWYgKGlzKGVsZW1lbnQsICdwb3N0aXQ6Qm9hcmRFbGVtZW50JykpIHtcbiAgICAgIGZuKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQge1xuICBnZXRPcmllbnRhdGlvbixcbiAgZ2V0TWlkLFxuICBhc1RSQkxcbn0gZnJvbSAnZGlhZ3JhbS1qcy9saWIvbGF5b3V0L0xheW91dFV0aWwnO1xuXG5pbXBvcnQge1xuICBzdWJzdHJhY3Rcbn0gZnJvbSAnZGlhZ3JhbS1qcy9saWIvdXRpbC9NYXRoJztcblxuaW1wb3J0IHtcbiAgaGFzRXh0ZXJuYWxMYWJlbFxufSBmcm9tICcuLi8uLi8uLi91dGlsL0xhYmVsVXRpbCc7XG5cbmltcG9ydCBDb21tYW5kSW50ZXJjZXB0b3IgZnJvbSAnZGlhZ3JhbS1qcy9saWIvY29tbWFuZC9Db21tYW5kSW50ZXJjZXB0b3InO1xuXG52YXIgQUxJR05NRU5UUyA9IFtcbiAgJ3RvcCcsXG4gICdib3R0b20nLFxuICAnbGVmdCcsXG4gICdyaWdodCdcbl07XG5cbnZhciBFTEVNRU5UX0xBQkVMX0RJU1RBTkNFID0gMTA7XG5cbi8qKlxuICogQSBjb21wb25lbnQgdGhhdCBtYWtlcyBzdXJlIHRoYXQgZXh0ZXJuYWwgbGFiZWxzIGFyZSBhZGRlZFxuICogdG9nZXRoZXIgd2l0aCByZXNwZWN0aXZlIGVsZW1lbnRzIGFuZCBwcm9wZXJseSB1cGRhdGVkIChESSB3aXNlKVxuICogZHVyaW5nIG1vdmUuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFkYXB0aXZlTGFiZWxQb3NpdGlvbmluZ0JlaGF2aW9yKGV2ZW50QnVzLCBtb2RlbGluZykge1xuXG4gIENvbW1hbmRJbnRlcmNlcHRvci5jYWxsKHRoaXMsIGV2ZW50QnVzKTtcblxuICB0aGlzLnBvc3RFeGVjdXRlZChbXG4gICAgJ2Nvbm5lY3Rpb24uY3JlYXRlJyxcbiAgICAnY29ubmVjdGlvbi5sYXlvdXQnLFxuICAgICdjb25uZWN0aW9uLnVwZGF0ZVdheXBvaW50cydcbiAgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICAgIHNvdXJjZSA9IGNvbm5lY3Rpb24uc291cmNlLFxuICAgICAgICB0YXJnZXQgPSBjb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gICAgaWYgKGhpbnRzLmNyZWF0ZUVsZW1lbnRzQmVoYXZpb3IgIT09IGZhbHNlKSB7XG4gICAgICBjaGVja0xhYmVsQWRqdXN0bWVudChzb3VyY2UpO1xuICAgICAgY2hlY2tMYWJlbEFkanVzdG1lbnQodGFyZ2V0KTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgdGhpcy5wb3N0RXhlY3V0ZWQoW1xuICAgICdsYWJlbC5jcmVhdGUnXG4gIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIGhpbnRzID0gY29udGV4dC5oaW50cyB8fCB7fTtcblxuICAgIGlmIChoaW50cy5jcmVhdGVFbGVtZW50c0JlaGF2aW9yICE9PSBmYWxzZSkge1xuICAgICAgY2hlY2tMYWJlbEFkanVzdG1lbnQoc2hhcGUubGFiZWxUYXJnZXQpO1xuICAgIH1cbiAgfSk7XG5cblxuICB0aGlzLnBvc3RFeGVjdXRlZChbXG4gICAgJ2VsZW1lbnRzLmNyZWF0ZSdcbiAgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGVsZW1lbnRzID0gY29udGV4dC5lbGVtZW50cyxcbiAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gICAgaWYgKGhpbnRzLmNyZWF0ZUVsZW1lbnRzQmVoYXZpb3IgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgY2hlY2tMYWJlbEFkanVzdG1lbnQoZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGNoZWNrTGFiZWxBZGp1c3RtZW50KGVsZW1lbnQpIHtcblxuICAgIC8vIHNraXAgbm9uLWV4aXN0aW5nIGxhYmVsc1xuICAgIGlmICghaGFzRXh0ZXJuYWxMYWJlbChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcHRpbWFsUG9zaXRpb24gPSBnZXRPcHRpbWFsUG9zaXRpb24oZWxlbWVudCk7XG5cbiAgICAvLyBubyBvcHRpbWFsIHBvc2l0aW9uIGZvdW5kXG4gICAgaWYgKCFvcHRpbWFsUG9zaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhZGp1c3RMYWJlbFBvc2l0aW9uKGVsZW1lbnQsIG9wdGltYWxQb3NpdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBhZGp1c3RMYWJlbFBvc2l0aW9uKGVsZW1lbnQsIG9yaWVudGF0aW9uKSB7XG5cbiAgICB2YXIgZWxlbWVudE1pZCA9IGdldE1pZChlbGVtZW50KSxcbiAgICAgICAgbGFiZWwgPSBlbGVtZW50LmxhYmVsLFxuICAgICAgICBsYWJlbE1pZCA9IGdldE1pZChsYWJlbCk7XG5cbiAgICAvLyBpZ25vcmUgbGFiZWxzIHRoYXQgYXJlIGJlaW5nIGNyZWF0ZWRcbiAgICBpZiAoIWxhYmVsLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50VHJibCA9IGFzVFJCTChlbGVtZW50KTtcblxuICAgIHZhciBuZXdMYWJlbE1pZDtcblxuICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgbmV3TGFiZWxNaWQgPSB7XG4gICAgICAgIHg6IGVsZW1lbnRNaWQueCxcbiAgICAgICAgeTogZWxlbWVudFRyYmwudG9wIC0gRUxFTUVOVF9MQUJFTF9ESVNUQU5DRSAtIGxhYmVsLmhlaWdodCAvIDJcbiAgICAgIH07XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbGVmdCc6XG5cbiAgICAgIG5ld0xhYmVsTWlkID0ge1xuICAgICAgICB4OiBlbGVtZW50VHJibC5sZWZ0IC0gRUxFTUVOVF9MQUJFTF9ESVNUQU5DRSAtIGxhYmVsLndpZHRoIC8gMixcbiAgICAgICAgeTogZWxlbWVudE1pZC55XG4gICAgICB9O1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG5cbiAgICAgIG5ld0xhYmVsTWlkID0ge1xuICAgICAgICB4OiBlbGVtZW50TWlkLngsXG4gICAgICAgIHk6IGVsZW1lbnRUcmJsLmJvdHRvbSArIEVMRU1FTlRfTEFCRUxfRElTVEFOQ0UgKyBsYWJlbC5oZWlnaHQgLyAyXG4gICAgICB9O1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcblxuICAgICAgbmV3TGFiZWxNaWQgPSB7XG4gICAgICAgIHg6IGVsZW1lbnRUcmJsLnJpZ2h0ICsgRUxFTUVOVF9MQUJFTF9ESVNUQU5DRSArIGxhYmVsLndpZHRoIC8gMixcbiAgICAgICAgeTogZWxlbWVudE1pZC55XG4gICAgICB9O1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZGVsdGEgPSBzdWJzdHJhY3QobmV3TGFiZWxNaWQsIGxhYmVsTWlkKTtcblxuICAgIG1vZGVsaW5nLm1vdmVTaGFwZShsYWJlbCwgZGVsdGEpO1xuICB9XG5cbn1cblxuaW5oZXJpdHMoQWRhcHRpdmVMYWJlbFBvc2l0aW9uaW5nQmVoYXZpb3IsIENvbW1hbmRJbnRlcmNlcHRvcik7XG5cbkFkYXB0aXZlTGFiZWxQb3NpdGlvbmluZ0JlaGF2aW9yLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdtb2RlbGluZydcbl07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUmV0dXJuIGFsaWdubWVudHMgd2hpY2ggYXJlIHRha2VuIGJ5IGEgYm91bmRhcnkncyBob3N0IGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge1NoYXBlfSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7QXJyYXk8U3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0VGFrZW5Ib3N0QWxpZ25tZW50cyhlbGVtZW50KSB7XG5cbiAgdmFyIGhvc3RFbGVtZW50ID0gZWxlbWVudC5ob3N0LFxuICAgICAgZWxlbWVudE1pZCA9IGdldE1pZChlbGVtZW50KSxcbiAgICAgIGhvc3RPcmllbnRhdGlvbiA9IGdldE9yaWVudGF0aW9uKGVsZW1lbnRNaWQsIGhvc3RFbGVtZW50KTtcblxuICB2YXIgZnJlZUFsaWdubWVudHM7XG5cbiAgLy8gY2hlY2sgd2hldGhlciB0aGVyZSBpcyBhIG11bHRpLW9yaWVudGF0aW9uLCBlLmcuICd0b3AtbGVmdCdcbiAgaWYgKGhvc3RPcmllbnRhdGlvbi5pbmRleE9mKCctJykgPj0gMCkge1xuICAgIGZyZWVBbGlnbm1lbnRzID0gaG9zdE9yaWVudGF0aW9uLnNwbGl0KCctJyk7XG4gIH0gZWxzZSB7XG4gICAgZnJlZUFsaWdubWVudHMgPSBbIGhvc3RPcmllbnRhdGlvbiBdO1xuICB9XG5cbiAgdmFyIHRha2VuQWxpZ25tZW50cyA9IEFMSUdOTUVOVFMuZmlsdGVyKGZ1bmN0aW9uKGFsaWdubWVudCkge1xuXG4gICAgcmV0dXJuIGZyZWVBbGlnbm1lbnRzLmluZGV4T2YoYWxpZ25tZW50KSA9PT0gLTE7XG4gIH0pO1xuXG4gIHJldHVybiB0YWtlbkFsaWdubWVudHM7XG5cbn1cblxuLyoqXG4gKiBSZXR1cm4gYWxpZ25tZW50cyB3aGljaCBhcmUgdGFrZW4gYnkgcmVsYXRlZCBjb25uZWN0aW9uc1xuICpcbiAqIEBwYXJhbSB7U2hhcGV9IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxTdHJpbmc+fVxuICovXG5mdW5jdGlvbiBnZXRUYWtlbkNvbm5lY3Rpb25BbGlnbm1lbnRzKGVsZW1lbnQpIHtcblxuICB2YXIgZWxlbWVudE1pZCA9IGdldE1pZChlbGVtZW50KTtcblxuICB2YXIgdGFrZW5BbGlnbm1lbnRzID0gW10uY29uY2F0KFxuICAgIGVsZW1lbnQuaW5jb21pbmcubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBjLndheXBvaW50c1tjLndheXBvaW50cy5sZW5ndGggLSAyIF07XG4gICAgfSksXG4gICAgZWxlbWVudC5vdXRnb2luZy5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMud2F5cG9pbnRzWzFdO1xuICAgIH0pXG4gICkubWFwKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIGdldEFwcHJveGltYXRlT3JpZW50YXRpb24oZWxlbWVudE1pZCwgcG9pbnQpO1xuICB9KTtcblxuICByZXR1cm4gdGFrZW5BbGlnbm1lbnRzO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgb3B0aW1hbCBsYWJlbCBwb3NpdGlvbiBhcm91bmQgYW4gZWxlbWVudFxuICogb3IgX3VuZGVmaW5lZF8sIGlmIG5vbmUgd2FzIGZvdW5kLlxuICpcbiAqIEBwYXJhbSAge1NoYXBlfSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBwb3NpdGlvbmluZyBpZGVudGlmaWVyXG4gKi9cbmZ1bmN0aW9uIGdldE9wdGltYWxQb3NpdGlvbihlbGVtZW50KSB7XG5cbiAgdmFyIGxhYmVsTWlkID0gZ2V0TWlkKGVsZW1lbnQubGFiZWwpO1xuXG4gIHZhciBlbGVtZW50TWlkID0gZ2V0TWlkKGVsZW1lbnQpO1xuXG4gIHZhciBsYWJlbE9yaWVudGF0aW9uID0gZ2V0QXBwcm94aW1hdGVPcmllbnRhdGlvbihlbGVtZW50TWlkLCBsYWJlbE1pZCk7XG5cbiAgaWYgKCFpc0FsaWduZWQobGFiZWxPcmllbnRhdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGFrZW5BbGlnbm1lbnRzID0gZ2V0VGFrZW5Db25uZWN0aW9uQWxpZ25tZW50cyhlbGVtZW50KTtcblxuICBpZiAoZWxlbWVudC5ob3N0KSB7XG4gICAgdmFyIHRha2VuSG9zdEFsaWdubWVudHMgPSBnZXRUYWtlbkhvc3RBbGlnbm1lbnRzKGVsZW1lbnQpO1xuXG4gICAgdGFrZW5BbGlnbm1lbnRzID0gdGFrZW5BbGlnbm1lbnRzLmNvbmNhdCh0YWtlbkhvc3RBbGlnbm1lbnRzKTtcbiAgfVxuXG4gIHZhciBmcmVlQWxpZ25tZW50cyA9IEFMSUdOTUVOVFMuZmlsdGVyKGZ1bmN0aW9uKGFsaWdubWVudCkge1xuXG4gICAgcmV0dXJuIHRha2VuQWxpZ25tZW50cy5pbmRleE9mKGFsaWdubWVudCkgPT09IC0xO1xuICB9KTtcblxuICAvLyBOT1RISU5HIFRPIERPOyBsYWJlbCBhbHJlYWR5IGFsaWduZWQgYS5PLksuXG4gIGlmIChmcmVlQWxpZ25tZW50cy5pbmRleE9mKGxhYmVsT3JpZW50YXRpb24pICE9PSAtMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBmcmVlQWxpZ25tZW50c1swXTtcbn1cblxuZnVuY3Rpb24gZ2V0QXBwcm94aW1hdGVPcmllbnRhdGlvbihwMCwgcDEpIHtcbiAgcmV0dXJuIGdldE9yaWVudGF0aW9uKHAxLCBwMCwgNSk7XG59XG5cbmZ1bmN0aW9uIGlzQWxpZ25lZChvcmllbnRhdGlvbikge1xuICByZXR1cm4gQUxJR05NRU5UUy5pbmRleE9mKG9yaWVudGF0aW9uKSAhPT0gLTE7XG59XG4iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgQ29tbWFuZEludGVyY2VwdG9yIGZyb20gJ2RpYWdyYW0tanMvbGliL2NvbW1hbmQvQ29tbWFuZEludGVyY2VwdG9yJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHBlbmRCZWhhdmlvcihldmVudEJ1cykge1xuXG4gIENvbW1hbmRJbnRlcmNlcHRvci5jYWxsKHRoaXMsIGV2ZW50QnVzKTtcblxuICAvLyBhc3NpZ24gY29ycmVjdCBzaGFwZSBwb3NpdGlvbiB1bmxlc3MgYWxyZWFkeSBzZXRcblxuICB0aGlzLnByZUV4ZWN1dGUoJ3NoYXBlLmFwcGVuZCcsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBzb3VyY2UgPSBjb250ZXh0LnNvdXJjZSxcbiAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlO1xuXG4gICAgaWYgKCFjb250ZXh0LnBvc2l0aW9uKSB7XG5cbiAgICAgIGNvbnRleHQucG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHNvdXJjZS54ICsgc291cmNlLndpZHRoICsgODAgKyBzaGFwZS53aWR0aCAvIDIsXG4gICAgICAgIHk6IHNvdXJjZS55ICsgc291cmNlLmhlaWdodCAvIDJcbiAgICAgIH07XG5cbiAgICB9XG4gIH0sIHRydWUpO1xufVxuXG5pbmhlcml0cyhBcHBlbmRCZWhhdmlvciwgQ29tbWFuZEludGVyY2VwdG9yKTtcblxuQXBwZW5kQmVoYXZpb3IuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJ1xuXTsiLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQge1xuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRCdXNpbmVzc09iamVjdCxcbiAgaXNcbn0gZnJvbSAnLi4vLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG5pbXBvcnQgQ29tbWFuZEludGVyY2VwdG9yIGZyb20gJ2RpYWdyYW0tanMvbGliL2NvbW1hbmQvQ29tbWFuZEludGVyY2VwdG9yJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDcmVhdGVCb2FyZEVsZW1lbnRCZWhhdmlvcihldmVudEJ1cykge1xuXG4gIENvbW1hbmRJbnRlcmNlcHRvci5jYWxsKHRoaXMsIGV2ZW50QnVzKTtcblxuICAvLyBlbnN1cmUgcHJvcGVydGllcyB3ZXJlIHNldCBpbiBidXNpbmVzcyBvYmplY3RcblxuICB0aGlzLmV4ZWN1dGUoJ3NoYXBlLmNyZWF0ZScsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBzaGFwZSA9IGNvbnRleHQuY29udGV4dC5zaGFwZTtcblxuICAgIGlmIChpcyhzaGFwZSwgJ3Bvc3RpdDpQb3N0aXQnKSkge1xuICAgICAgY29uc3QgYnVzaW5lc3NPYmplY3QgPSBnZXRCdXNpbmVzc09iamVjdChzaGFwZSk7XG4gICAgICAhYnVzaW5lc3NPYmplY3QuY29sb3IgJiYgYXNzaWduKGJ1c2luZXNzT2JqZWN0LCB7IGNvbG9yOiBzaGFwZS5jb2xvciB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXMoc2hhcGUsICdwb3N0aXQ6SW1hZ2UnKSkge1xuICAgICAgY29uc3QgYnVzaW5lc3NPYmplY3QgPSBnZXRCdXNpbmVzc09iamVjdChzaGFwZSk7XG4gICAgICAhYnVzaW5lc3NPYmplY3Quc291cmNlICYmIGFzc2lnbihidXNpbmVzc09iamVjdCwgeyBzb3VyY2U6IHNoYXBlLnNvdXJjZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5pbmhlcml0cyhDcmVhdGVCb2FyZEVsZW1lbnRCZWhhdmlvciwgQ29tbWFuZEludGVyY2VwdG9yKTtcblxuQ3JlYXRlQm9hcmRFbGVtZW50QmVoYXZpb3IuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJ1xuXTsiLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQge1xuICBpcyxcbiAgZ2V0QnVzaW5lc3NPYmplY3Rcbn0gZnJvbSAnLi4vLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG5pbXBvcnQgQ29tbWFuZEludGVyY2VwdG9yIGZyb20gJ2RpYWdyYW0tanMvbGliL2NvbW1hbmQvQ29tbWFuZEludGVyY2VwdG9yJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbXB0eVRleHRCb3hCZWhhdmlvcihldmVudEJ1cywgbW9kZWxpbmcsIGRpcmVjdEVkaXRpbmcpIHtcblxuICBDb21tYW5kSW50ZXJjZXB0b3IuY2FsbCh0aGlzLCBldmVudEJ1cyk7XG5cbiAgLy8gZGVsZXRlIHRleHQgYm94IGlmIGl0IGhhcyBubyB0ZXh0XG4gIHRoaXMucG9zdEV4ZWN1dGUoJ2VsZW1lbnQudXBkYXRlTGFiZWwnLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudCxcbiAgICAgICAgbmV3TGFiZWwgPSBjb250ZXh0Lm5ld0xhYmVsO1xuXG4gICAgaWYgKGlzKGVsZW1lbnQsICdwb3N0aXQ6VGV4dEJveCcpICYmIGlzRW1wdHkobmV3TGFiZWwpKSB7XG4gICAgICBtb2RlbGluZy5yZW1vdmVFbGVtZW50cyhbIGVsZW1lbnQgXSk7XG4gICAgfVxuICB9LCB0cnVlKTtcblxuICBldmVudEJ1cy5vbignZGlyZWN0RWRpdGluZy5jYW5jZWwnLCAxMDAxLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBhY3RpdmUgPSBldmVudC5hY3RpdmUsXG4gICAgICAgIGVsZW1lbnQgPSBhY3RpdmUuZWxlbWVudDtcblxuICAgIGlmIChpcyhlbGVtZW50LCAncG9zdGl0OlRleHRCb3gnKSAmJiBpc0VtcHR5KGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpLm5hbWUpKSB7XG4gICAgICBkaXJlY3RFZGl0aW5nLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIG1vZGVsaW5nLnJlbW92ZUVsZW1lbnRzKFsgZWxlbWVudCBdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5pbmhlcml0cyhFbXB0eVRleHRCb3hCZWhhdmlvciwgQ29tbWFuZEludGVyY2VwdG9yKTtcblxuRW1wdHlUZXh0Qm94QmVoYXZpb3IuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ2RpcmVjdEVkaXRpbmcnXG5dO1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc0VtcHR5KGxhYmVsKSB7XG4gIHJldHVybiAhbGFiZWwgfHwgbGFiZWwgPT09ICcnO1xufSIsImltcG9ydCB7IGlzIH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xyXG5cclxudmFyIEhJR0hfUFJJT1JJVFkgPSAxNTAwO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb3JyZWN0IGhvdmVyIHRhcmdldHMgaW4gY2VydGFpbiBzaXR1YXRpb25zIHRvIGltcHJvdmUgZGlhZ3JhbSBpbnRlcmFjdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnl9IGVsZW1lbnRSZWdpc3RyeVxyXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xyXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGaXhIb3ZlckJlaGF2aW9yKGVsZW1lbnRSZWdpc3RyeSwgZXZlbnRCdXMsIGNhbnZhcykge1xyXG5cclxuICBldmVudEJ1cy5vbihbXHJcbiAgICAnY3JlYXRlLmhvdmVyJyxcclxuICAgICdjcmVhdGUubW92ZScsXHJcbiAgICAnY3JlYXRlLmVuZCcsXHJcbiAgICAnc2hhcGUubW92ZS5ob3ZlcicsXHJcbiAgICAnc2hhcGUubW92ZS5tb3ZlJyxcclxuICAgICdzaGFwZS5tb3ZlLmVuZCdcclxuICBdLCBISUdIX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxyXG4gICAgICAgIHNoYXBlID0gY29udGV4dC5zaGFwZSB8fCBldmVudC5zaGFwZSxcclxuICAgICAgICBob3ZlciA9IGV2ZW50LmhvdmVyO1xyXG5cclxuICAgIHZhciByb290RWxlbWVudCA9IGNhbnZhcy5nZXRSb290RWxlbWVudCgpO1xyXG5cclxuICAgIC8vIGVuc3VyZSBncm91cCAmIGxhYmVsIGVsZW1lbnRzIGFyZSBkcm9wcGVkIGFsd2F5cyBvbnRvIHRoZSByb290XHJcbiAgICBpZiAoaG92ZXIgIT09IHJvb3RFbGVtZW50ICYmIChzaGFwZS5sYWJlbFRhcmdldCB8fCBpcyhzaGFwZSwgJ3Bvc3RpdDpHcm91cCcpKSkge1xyXG4gICAgICBldmVudC5ob3ZlciA9IHJvb3RFbGVtZW50O1xyXG4gICAgICBldmVudC5ob3ZlckdmeCA9IGVsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhldmVudC5ob3Zlcik7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG59XHJcblxyXG5GaXhIb3ZlckJlaGF2aW9yLiRpbmplY3QgPSBbXHJcbiAgJ2VsZW1lbnRSZWdpc3RyeScsXHJcbiAgJ2V2ZW50QnVzJyxcclxuICAnY2FudmFzJ1xyXG5dOyIsImltcG9ydCB7XG4gIGdldE1pZFxufSBmcm9tICdkaWFncmFtLWpzL2xpYi9sYXlvdXQvTGF5b3V0VXRpbCc7XG5cbmltcG9ydCBsaW5lSW50ZXJzZWN0IGZyb20gJy4vdXRpbC9MaW5lSW50ZXJzZWN0JztcblxuXG4vKipcbiAqIEZpeCBicm9rZW4gZG9ja2luZ3MgYWZ0ZXIgREkgaW1wb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbXBvcnREb2NraW5nRml4KGV2ZW50QnVzKSB7XG5cbiAgZnVuY3Rpb24gYWRqdXN0RG9ja2luZyhzdGFydFBvaW50LCBuZXh0UG9pbnQsIGVsZW1lbnRNaWQpIHtcblxuICAgIHZhciBlbGVtZW50VG9wID0ge1xuICAgICAgeDogZWxlbWVudE1pZC54LFxuICAgICAgeTogZWxlbWVudE1pZC55IC0gNTBcbiAgICB9O1xuXG4gICAgdmFyIGVsZW1lbnRMZWZ0ID0ge1xuICAgICAgeDogZWxlbWVudE1pZC54IC0gNTAsXG4gICAgICB5OiBlbGVtZW50TWlkLnlcbiAgICB9O1xuXG4gICAgdmFyIHZlcnRpY2FsSW50ZXJzZWN0ID0gbGluZUludGVyc2VjdChzdGFydFBvaW50LCBuZXh0UG9pbnQsIGVsZW1lbnRNaWQsIGVsZW1lbnRUb3ApLFxuICAgICAgICBob3Jpem9udGFsSW50ZXJzZWN0ID0gbGluZUludGVyc2VjdChzdGFydFBvaW50LCBuZXh0UG9pbnQsIGVsZW1lbnRNaWQsIGVsZW1lbnRMZWZ0KTtcblxuICAgIC8vIG9yaWdpbmFsIGlzIGhvcml6b250YWwgb3IgdmVydGljYWwgY2VudGVyIGNyb3NzIGludGVyc2VjdGlvblxuICAgIHZhciBjZW50ZXJJbnRlcnNlY3Q7XG5cbiAgICBpZiAodmVydGljYWxJbnRlcnNlY3QgJiYgaG9yaXpvbnRhbEludGVyc2VjdCkge1xuICAgICAgaWYgKGdldERpc3RhbmNlKHZlcnRpY2FsSW50ZXJzZWN0LCBlbGVtZW50TWlkKSA+IGdldERpc3RhbmNlKGhvcml6b250YWxJbnRlcnNlY3QsIGVsZW1lbnRNaWQpKSB7XG4gICAgICAgIGNlbnRlckludGVyc2VjdCA9IGhvcml6b250YWxJbnRlcnNlY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZW50ZXJJbnRlcnNlY3QgPSB2ZXJ0aWNhbEludGVyc2VjdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2VudGVySW50ZXJzZWN0ID0gdmVydGljYWxJbnRlcnNlY3QgfHwgaG9yaXpvbnRhbEludGVyc2VjdDtcbiAgICB9XG5cbiAgICBzdGFydFBvaW50Lm9yaWdpbmFsID0gY2VudGVySW50ZXJzZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gZml4RG9ja2luZ3MoY29ubmVjdGlvbikge1xuICAgIHZhciB3YXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cztcblxuICAgIGFkanVzdERvY2tpbmcoXG4gICAgICB3YXlwb2ludHNbMF0sXG4gICAgICB3YXlwb2ludHNbMV0sXG4gICAgICBnZXRNaWQoY29ubmVjdGlvbi5zb3VyY2UpXG4gICAgKTtcblxuICAgIGFkanVzdERvY2tpbmcoXG4gICAgICB3YXlwb2ludHNbd2F5cG9pbnRzLmxlbmd0aCAtIDFdLFxuICAgICAgd2F5cG9pbnRzW3dheXBvaW50cy5sZW5ndGggLSAyXSxcbiAgICAgIGdldE1pZChjb25uZWN0aW9uLnRhcmdldClcbiAgICApO1xuICB9XG5cbiAgZXZlbnRCdXMub24oJ2JvYXJkRWxlbWVudC5hZGRlZCcsIGZ1bmN0aW9uKGUpIHtcblxuICAgIHZhciBlbGVtZW50ID0gZS5lbGVtZW50O1xuXG4gICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgICBmaXhEb2NraW5ncyhlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xufVxuXG5JbXBvcnREb2NraW5nRml4LiRpbmplY3QgPSBbXG4gICdldmVudEJ1cydcbl07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxLnggLSBwMi54LCAyKSArIE1hdGgucG93KHAxLnkgLSBwMi55LCAyKSk7XG59IiwiaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IHtcbiAgaXMsXG4gIGdldEJ1c2luZXNzT2JqZWN0XG59IGZyb20gJy4uLy4uLy4uL3V0aWwvTW9kZWxVdGlsJztcblxuaW1wb3J0IHtcbiAgaXNMYWJlbEV4dGVybmFsLFxuICBnZXRFeHRlcm5hbExhYmVsTWlkLFxuICBoYXNFeHRlcm5hbExhYmVsLFxuICBpc0xhYmVsXG59IGZyb20gJy4uLy4uLy4uL3V0aWwvTGFiZWxVdGlsJztcblxuaW1wb3J0IHtcbiAgZ2V0TGFiZWxcbn0gZnJvbSAnLi4vLi4vbGFiZWwtZWRpdGluZy9MYWJlbFV0aWwnO1xuXG5pbXBvcnQge1xuICBnZXRMYWJlbEFkanVzdG1lbnRcbn0gZnJvbSAnLi91dGlsL0xhYmVsTGF5b3V0VXRpbCc7XG5cbmltcG9ydCBDb21tYW5kSW50ZXJjZXB0b3IgZnJvbSAnZGlhZ3JhbS1qcy9saWIvY29tbWFuZC9Db21tYW5kSW50ZXJjZXB0b3InO1xuXG5pbXBvcnQge1xuICBnZXROZXdBdHRhY2hQb2ludFxufSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL0F0dGFjaFV0aWwnO1xuXG5pbXBvcnQge1xuICBnZXRNaWQsXG4gIHJvdW5kUG9pbnRcbn0gZnJvbSAnZGlhZ3JhbS1qcy9saWIvbGF5b3V0L0xheW91dFV0aWwnO1xuXG5pbXBvcnQge1xuICBkZWx0YVxufSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL1Bvc2l0aW9uVXRpbCc7XG5cbmltcG9ydCB7XG4gIHNvcnRCeVxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGdldERpc3RhbmNlUG9pbnRMaW5lLFxuICBwZXJwZW5kaWN1bGFyRm9vdFxufSBmcm9tICcuL3V0aWwvR2VvbWV0cmljVXRpbCc7XG5cbnZhciBERUZBVUxUX0xBQkVMX0RJTUVOU0lPTlMgPSB7XG4gIHdpZHRoOiA5MCxcbiAgaGVpZ2h0OiAyMFxufTtcblxudmFyIE5BTUVfUFJPUEVSVFkgPSAnbmFtZSc7XG5cbi8qKlxuICogQSBjb21wb25lbnQgdGhhdCBtYWtlcyBzdXJlIHRoYXQgZXh0ZXJuYWwgbGFiZWxzIGFyZSBhZGRlZFxuICogdG9nZXRoZXIgd2l0aCByZXNwZWN0aXZlIGVsZW1lbnRzIGFuZCBwcm9wZXJseSB1cGRhdGVkIChESSB3aXNlKVxuICogZHVyaW5nIG1vdmUuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKiBAcGFyYW0ge1Bvc3RpdEZhY3Rvcnl9IHBvc3RpdEZhY3RvcnlcbiAqIEBwYXJhbSB7VGV4dFJlbmRlcmVyfSB0ZXh0UmVuZGVyZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGFiZWxCZWhhdmlvcihcbiAgICBldmVudEJ1cywgbW9kZWxpbmcsIHBvc3RpdEZhY3RvcnksXG4gICAgdGV4dFJlbmRlcmVyKSB7XG5cbiAgQ29tbWFuZEludGVyY2VwdG9yLmNhbGwodGhpcywgZXZlbnRCdXMpO1xuXG4gIC8vIHVwZGF0ZSBsYWJlbCBpZiBuYW1lIHByb3BlcnR5IHdhcyB1cGRhdGVkXG4gIHRoaXMucG9zdEV4ZWN1dGUoJ2VsZW1lbnQudXBkYXRlUHJvcGVydGllcycsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY29udGV4dCA9IGUuY29udGV4dCxcbiAgICAgICAgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudCxcbiAgICAgICAgcHJvcGVydGllcyA9IGNvbnRleHQucHJvcGVydGllcztcblxuICAgIGlmIChOQU1FX1BST1BFUlRZIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIG1vZGVsaW5nLnVwZGF0ZUxhYmVsKGVsZW1lbnQsIHByb3BlcnRpZXNbTkFNRV9QUk9QRVJUWV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gY3JlYXRlIGxhYmVsIHNoYXBlIGFmdGVyIHNoYXBlL2Nvbm5lY3Rpb24gd2FzIGNyZWF0ZWRcbiAgdGhpcy5wb3N0RXhlY3V0ZShbICdzaGFwZS5jcmVhdGUnLCAnY29ubmVjdGlvbi5jcmVhdGUnIF0sIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY29udGV4dCA9IGUuY29udGV4dCxcbiAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gICAgaWYgKGhpbnRzLmNyZWF0ZUVsZW1lbnRzQmVoYXZpb3IgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0LnNoYXBlIHx8IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgICAgYnVzaW5lc3NPYmplY3QgPSBlbGVtZW50LmJ1c2luZXNzT2JqZWN0O1xuXG4gICAgaWYgKGlzTGFiZWwoZWxlbWVudCkgfHwgIWlzTGFiZWxFeHRlcm5hbChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG9ubHkgY3JlYXRlIGxhYmVsIGlmIGF0dHJpYnV0ZSBhdmFpbGFibGVcbiAgICBpZiAoIWdldExhYmVsKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxhYmVsQ2VudGVyID0gZ2V0RXh0ZXJuYWxMYWJlbE1pZChlbGVtZW50KTtcblxuICAgIC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgeCBhbmQgeVxuICAgIHZhciBsYWJlbERpbWVuc2lvbnMgPSB0ZXh0UmVuZGVyZXIuZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kcyhcbiAgICAgIERFRkFVTFRfTEFCRUxfRElNRU5TSU9OUyxcbiAgICAgIGdldExhYmVsKGVsZW1lbnQpXG4gICAgKTtcblxuICAgIG1vZGVsaW5nLmNyZWF0ZUxhYmVsKGVsZW1lbnQsIGxhYmVsQ2VudGVyLCB7XG4gICAgICBpZDogYnVzaW5lc3NPYmplY3QuaWQgKyAnX2xhYmVsJyxcbiAgICAgIGJ1c2luZXNzT2JqZWN0OiBidXNpbmVzc09iamVjdCxcbiAgICAgIHdpZHRoOiBsYWJlbERpbWVuc2lvbnMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGxhYmVsRGltZW5zaW9ucy5oZWlnaHRcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdXBkYXRlIGxhYmVsIGFmdGVyIGxhYmVsIHNoYXBlIHdhcyBkZWxldGVkXG4gIHRoaXMucG9zdEV4ZWN1dGUoJ3NoYXBlLmRlbGV0ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBsYWJlbFRhcmdldCA9IGNvbnRleHQubGFiZWxUYXJnZXQsXG4gICAgICAgIGhpbnRzID0gY29udGV4dC5oaW50cyB8fCB7fTtcblxuICAgIC8vIGNoZWNrIGlmIGxhYmVsXG4gICAgaWYgKGxhYmVsVGFyZ2V0ICYmIGhpbnRzLnVuc2V0TGFiZWwgIT09IGZhbHNlKSB7XG4gICAgICBtb2RlbGluZy51cGRhdGVMYWJlbChsYWJlbFRhcmdldCwgbnVsbCwgbnVsbCwgeyByZW1vdmVTaGFwZTogZmFsc2UgfSk7XG4gICAgfVxuICB9KTtcblxuICAvLyB1cGRhdGUgZGkgaW5mb3JtYXRpb24gb24gbGFiZWwgY3JlYXRpb25cbiAgdGhpcy5wb3N0RXhlY3V0ZShbICdsYWJlbC5jcmVhdGUnIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBidXNpbmVzc09iamVjdCxcbiAgICAgICAgZGk7XG5cbiAgICAvLyB3ZSB3YW50IHRvIHRyaWdnZXIgb24gcmVhbCBsYWJlbHMgb25seVxuICAgIGlmICghZWxlbWVudC5sYWJlbFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBib2FyZCBlbGVtZW50cyBvbmx5XG4gICAgaWYgKCFpcyhlbGVtZW50LmxhYmVsVGFyZ2V0IHx8IGVsZW1lbnQsICdwb3N0aXQ6Qm9hcmRFbGVtZW50JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBidXNpbmVzc09iamVjdCA9IGVsZW1lbnQuYnVzaW5lc3NPYmplY3QsXG4gICAgZGkgPSBidXNpbmVzc09iamVjdC5kaTtcblxuXG4gICAgaWYgKCFkaS5sYWJlbCkge1xuICAgICAgZGkubGFiZWwgPSBwb3N0aXRGYWN0b3J5LmNyZWF0ZSgncG9zdGl0RGk6UG9zdGl0TGFiZWwnLCB7XG4gICAgICAgIGJvdW5kczogcG9zdGl0RmFjdG9yeS5jcmVhdGUoJ2RjOkJvdW5kcycpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3NpZ24oZGkubGFiZWwuYm91bmRzLCB7XG4gICAgICB4OiBlbGVtZW50LngsXG4gICAgICB5OiBlbGVtZW50LnksXG4gICAgICB3aWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHRcbiAgICB9KTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2V0VmlzaWJsZUxhYmVsQWRqdXN0bWVudChldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgICBsYWJlbCA9IGNvbm5lY3Rpb24ubGFiZWwsXG4gICAgICAgIGhpbnRzID0gYXNzaWduKHt9LCBjb250ZXh0LmhpbnRzKSxcbiAgICAgICAgbmV3V2F5cG9pbnRzID0gY29udGV4dC5uZXdXYXlwb2ludHMgfHwgY29ubmVjdGlvbi53YXlwb2ludHMsXG4gICAgICAgIG9sZFdheXBvaW50cyA9IGNvbnRleHQub2xkV2F5cG9pbnRzO1xuXG5cbiAgICBpZiAodHlwZW9mIGhpbnRzLnN0YXJ0Q2hhbmdlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGhpbnRzLnN0YXJ0Q2hhbmdlZCA9ICEhaGludHMuY29ubmVjdGlvblN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGludHMuZW5kQ2hhbmdlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGhpbnRzLmVuZENoYW5nZWQgPSAhIWhpbnRzLmNvbm5lY3Rpb25FbmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldExhYmVsQWRqdXN0bWVudChsYWJlbCwgbmV3V2F5cG9pbnRzLCBvbGRXYXlwb2ludHMsIGhpbnRzKTtcbiAgfVxuXG4gIHRoaXMucG9zdEV4ZWN1dGUoW1xuICAgICdjb25uZWN0aW9uLmxheW91dCcsXG4gICAgJ2Nvbm5lY3Rpb24udXBkYXRlV2F5cG9pbnRzJ1xuICBdLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gICAgaWYgKGhpbnRzLmxhYmVsQmVoYXZpb3IgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICAgIGxhYmVsID0gY29ubmVjdGlvbi5sYWJlbCxcbiAgICAgICAgbGFiZWxBZGp1c3RtZW50O1xuXG4gICAgLy8gaGFuZGxlIG1pc3NpbmcgbGFiZWwgYXMgd2VsbCBhcyB0aGUgY2FzZVxuICAgIC8vIHRoYXQgdGhlIGxhYmVsIHBhcmVudCBkb2VzIG5vdCBleGlzdCAoeWV0KSxcbiAgICAvLyBiZWNhdXNlIGl0IGlzIGJlaW5nIHBhc3RlZCAvIGNyZWF0ZWQgdmlhIG11bHRpIGVsZW1lbnQgY3JlYXRlXG4gICAgLy9cbiAgICAvLyBDZi4gaHR0cHM6Ly9naXRodWIuY29tL2JwbW4taW8vYnBtbi1qcy9wdWxsLzEyMjdcbiAgICBpZiAoIWxhYmVsIHx8ICFsYWJlbC5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYWJlbEFkanVzdG1lbnQgPSBnZXRWaXNpYmxlTGFiZWxBZGp1c3RtZW50KGV2ZW50KTtcblxuICAgIG1vZGVsaW5nLm1vdmVTaGFwZShsYWJlbCwgbGFiZWxBZGp1c3RtZW50KTtcbiAgfSk7XG5cblxuICAvLyBrZWVwIGxhYmVsIHBvc2l0aW9uIG9uIHNoYXBlIHJlcGxhY2VcbiAgdGhpcy5wb3N0RXhlY3V0ZShbICdzaGFwZS5yZXBsYWNlJyBdLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgbmV3U2hhcGUgPSBjb250ZXh0Lm5ld1NoYXBlLFxuICAgICAgICBvbGRTaGFwZSA9IGNvbnRleHQub2xkU2hhcGU7XG5cbiAgICB2YXIgYnVzaW5lc3NPYmplY3QgPSBnZXRCdXNpbmVzc09iamVjdChuZXdTaGFwZSk7XG5cbiAgICBpZiAoYnVzaW5lc3NPYmplY3RcbiAgICAgICYmIGlzTGFiZWxFeHRlcm5hbChidXNpbmVzc09iamVjdClcbiAgICAgICYmIG9sZFNoYXBlLmxhYmVsXG4gICAgICAmJiBuZXdTaGFwZS5sYWJlbCkge1xuICAgICAgbmV3U2hhcGUubGFiZWwueCA9IG9sZFNoYXBlLmxhYmVsLng7XG4gICAgICBuZXdTaGFwZS5sYWJlbC55ID0gb2xkU2hhcGUubGFiZWwueTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgLy8gbW92ZSBleHRlcm5hbCBsYWJlbCBhZnRlciByZXNpemluZ1xuICB0aGlzLnBvc3RFeGVjdXRlKCdzaGFwZS5yZXNpemUnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIG5ld0JvdW5kcyA9IGNvbnRleHQubmV3Qm91bmRzLFxuICAgICAgICBvbGRCb3VuZHMgPSBjb250ZXh0Lm9sZEJvdW5kcztcblxuICAgIGlmIChoYXNFeHRlcm5hbExhYmVsKHNoYXBlKSkge1xuXG4gICAgICB2YXIgbGFiZWwgPSBzaGFwZS5sYWJlbCxcbiAgICAgICAgICBsYWJlbE1pZCA9IGdldE1pZChsYWJlbCksXG4gICAgICAgICAgZWRnZXMgPSBhc0VkZ2VzKG9sZEJvdW5kcyk7XG5cbiAgICAgIC8vIGdldCBuZWFyZXN0IGJvcmRlciBwb2ludCB0byBsYWJlbCBhcyByZWZlcmVuY2UgcG9pbnRcbiAgICAgIHZhciByZWZlcmVuY2VQb2ludCA9IGdldFJlZmVyZW5jZVBvaW50KGxhYmVsTWlkLCBlZGdlcyk7XG5cbiAgICAgIHZhciBkZWx0YSA9IGdldFJlZmVyZW5jZVBvaW50RGVsdGEocmVmZXJlbmNlUG9pbnQsIG9sZEJvdW5kcywgbmV3Qm91bmRzKTtcblxuICAgICAgbW9kZWxpbmcubW92ZVNoYXBlKGxhYmVsLCBkZWx0YSk7XG5cbiAgICB9XG5cbiAgfSk7XG5cbn1cblxuaW5oZXJpdHMoTGFiZWxCZWhhdmlvciwgQ29tbWFuZEludGVyY2VwdG9yKTtcblxuTGFiZWxCZWhhdmlvci4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnbW9kZWxpbmcnLFxuICAncG9zdGl0RmFjdG9yeScsXG4gICd0ZXh0UmVuZGVyZXInXG5dO1xuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgcmVmZXJlbmNlIHBvaW50IGRlbHRhIHJlbGF0aXZlIHRvIGEgbmV3IHBvc2l0aW9uXG4gKiBvZiBhIGNlcnRhaW4gZWxlbWVudCdzIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gKiBAcGFyYW0ge0JvdW5kc30gb2xkQm91bmRzXG4gKiBAcGFyYW0ge0JvdW5kc30gbmV3Qm91bmRzXG4gKlxuICogQHJldHVybiB7RGVsdGF9IGRlbHRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWZlcmVuY2VQb2ludERlbHRhKHJlZmVyZW5jZVBvaW50LCBvbGRCb3VuZHMsIG5ld0JvdW5kcykge1xuXG4gIHZhciBuZXdSZWZlcmVuY2VQb2ludCA9IGdldE5ld0F0dGFjaFBvaW50KHJlZmVyZW5jZVBvaW50LCBvbGRCb3VuZHMsIG5ld0JvdW5kcyk7XG5cbiAgcmV0dXJuIHJvdW5kUG9pbnQoZGVsdGEobmV3UmVmZXJlbmNlUG9pbnQsIHJlZmVyZW5jZVBvaW50KSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBuZWFyZXN0IHBvaW50IChyZWZlcmVuY2UgcG9pbnQpIGZvciBhIGdpdmVuIHBvaW50XG4gKiBvbnRvIGdpdmVuIHNldCBvZiBsaW5lc1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnQsIFBvaW50Pn0gbGluZXNcbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gKlxuICogQHBhcmFtIHtQb2ludH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlZmVyZW5jZVBvaW50KHBvaW50LCBsaW5lcykge1xuXG4gIGlmICghbGluZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5lYXJlc3RMaW5lID0gZ2V0TmVhcmVzdExpbmUocG9pbnQsIGxpbmVzKTtcblxuICByZXR1cm4gcGVycGVuZGljdWxhckZvb3QocG9pbnQsIG5lYXJlc3RMaW5lKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBib3VuZHMgdG8gYSBsaW5lcyBhcnJheSBjb250YWluaW5nIGFsbCBlZGdlc1xuICpcbiAqIEBwYXJhbSB7Qm91bmRzfFBvaW50fSBib3VuZHNcbiAqXG4gKiBAcmV0dXJuIEFycmF5PFBvaW50PlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNFZGdlcyhib3VuZHMpIHtcbiAgcmV0dXJuIFtcbiAgICBbIC8vIHRvcFxuICAgICAge1xuICAgICAgICB4OiBib3VuZHMueCxcbiAgICAgICAgeTogYm91bmRzLnlcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHg6IGJvdW5kcy54ICsgKGJvdW5kcy53aWR0aCB8fCAwKSxcbiAgICAgICAgeTogYm91bmRzLnlcbiAgICAgIH1cbiAgICBdLFxuICAgIFsgLy8gcmlnaHRcbiAgICAgIHtcbiAgICAgICAgeDogYm91bmRzLnggKyAoYm91bmRzLndpZHRoIHx8IDApLFxuICAgICAgICB5OiBib3VuZHMueVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgeDogYm91bmRzLnggKyAoYm91bmRzLndpZHRoIHx8IDApLFxuICAgICAgICB5OiBib3VuZHMueSArIChib3VuZHMuaGVpZ2h0IHx8IDApXG4gICAgICB9XG4gICAgXSxcbiAgICBbIC8vIGJvdHRvbVxuICAgICAge1xuICAgICAgICB4OiBib3VuZHMueCxcbiAgICAgICAgeTogYm91bmRzLnkgKyAoYm91bmRzLmhlaWdodCB8fCAwKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgeDogYm91bmRzLnggKyAoYm91bmRzLndpZHRoIHx8IDApLFxuICAgICAgICB5OiBib3VuZHMueSArIChib3VuZHMuaGVpZ2h0IHx8IDApXG4gICAgICB9XG4gICAgXSxcbiAgICBbIC8vIGxlZnRcbiAgICAgIHtcbiAgICAgICAgeDogYm91bmRzLngsXG4gICAgICAgIHk6IGJvdW5kcy55XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB4OiBib3VuZHMueCxcbiAgICAgICAgeTogYm91bmRzLnkgKyAoYm91bmRzLmhlaWdodCB8fCAwKVxuICAgICAgfVxuICAgIF1cbiAgXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZWFyZXN0IGxpbmUgZm9yIGEgZ2l2ZW4gcG9pbnQgYnkgZGlzdGFuY2VcbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gKiBAcGFyYW0gQXJyYXk8UG9pbnQ+IGxpbmVzXG4gKlxuICogQHJldHVybiBBcnJheTxQb2ludD5cbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdExpbmUocG9pbnQsIGxpbmVzKSB7XG5cbiAgdmFyIGRpc3RhbmNlcyA9IGxpbmVzLm1hcChmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IGwsXG4gICAgICBkaXN0YW5jZTogZ2V0RGlzdGFuY2VQb2ludExpbmUocG9pbnQsIGwpXG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIHNvcnRlZCA9IHNvcnRCeShkaXN0YW5jZXMsICdkaXN0YW5jZScpO1xuXG4gIHJldHVybiBzb3J0ZWRbMF0ubGluZTtcbn1cbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCB7IGZvckVhY2ggfSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCBDb21tYW5kSW50ZXJjZXB0b3IgZnJvbSAnZGlhZ3JhbS1qcy9saWIvY29tbWFuZC9Db21tYW5kSW50ZXJjZXB0b3InO1xuXG5cbi8qKlxuICogcG9zdGl0LXNwZWNpZmljIHJlcGxhY2UgYmVoYXZpb3IuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJlcGxhY2VFbGVtZW50QmVoYXZpb3VyKFxuICAgIHBvc3RpdFJlcGxhY2UsXG4gICAgcG9zdGl0UnVsZXMsXG4gICAgZWxlbWVudFJlZ2lzdHJ5LFxuICAgIGluamVjdG9yLFxuICAgIG1vZGVsaW5nLFxuICAgIHNlbGVjdGlvblxuKSB7XG4gIGluamVjdG9yLmludm9rZShDb21tYW5kSW50ZXJjZXB0b3IsIHRoaXMpO1xuXG4gIHRoaXMuX3Bvc3RpdFJlcGxhY2UgPSBwb3N0aXRSZXBsYWNlO1xuICB0aGlzLl9lbGVtZW50UmVnaXN0cnkgPSBlbGVtZW50UmVnaXN0cnk7XG4gIHRoaXMuX3NlbGVjdGlvbiA9IHNlbGVjdGlvbjtcblxuICAvLyByZXBsYWNlIGVsZW1lbnRzIG9uIG1vdmVcbiAgdGhpcy5wb3N0RXhlY3V0ZWQoWyAnZWxlbWVudHMubW92ZScgXSwgNTAwLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgdGFyZ2V0ID0gY29udGV4dC5uZXdQYXJlbnQsXG4gICAgICAgIG5ld0hvc3QgPSBjb250ZXh0Lm5ld0hvc3QsXG4gICAgICAgIGVsZW1lbnRzID0gW107XG5cbiAgICBmb3JFYWNoKGNvbnRleHQuY2xvc3VyZS50b3BMZXZlbCwgZnVuY3Rpb24odG9wTGV2ZWxFbGVtZW50cykge1xuICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5jb25jYXQodG9wTGV2ZWxFbGVtZW50cyk7XG4gICAgfSk7XG5cbiAgICAvLyBzZXQgdGFyZ2V0IHRvIGhvc3QgaWYgYXR0YWNoaW5nXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBuZXdIb3N0KSB7XG4gICAgICB0YXJnZXQgPSBuZXdIb3N0O1xuICAgIH1cblxuICAgIHZhciBjYW5SZXBsYWNlID0gcG9zdGl0UnVsZXMuY2FuUmVwbGFjZShlbGVtZW50cywgdGFyZ2V0KTtcblxuICAgIGlmIChjYW5SZXBsYWNlKSB7XG4gICAgICB0aGlzLnJlcGxhY2VFbGVtZW50cyhlbGVtZW50cywgY2FuUmVwbGFjZS5yZXBsYWNlbWVudHMsIG5ld0hvc3QpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgLy8gdXBkYXRlIGF0dGFjaG1lbnRzIG9uIGhvc3QgcmVwbGFjZVxuICB0aGlzLnBvc3RFeGVjdXRlKFsgJ3NoYXBlLnJlcGxhY2UnIF0sIDE1MDAsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY29udGV4dCA9IGUuY29udGV4dCxcbiAgICAgICAgb2xkU2hhcGUgPSBjb250ZXh0Lm9sZFNoYXBlLFxuICAgICAgICBuZXdTaGFwZSA9IGNvbnRleHQubmV3U2hhcGUsXG4gICAgICAgIGF0dGFjaGVycyA9IG9sZFNoYXBlLmF0dGFjaGVycyxcbiAgICAgICAgY2FuUmVwbGFjZTtcblxuICAgIGlmIChhdHRhY2hlcnMgJiYgYXR0YWNoZXJzLmxlbmd0aCkge1xuICAgICAgY2FuUmVwbGFjZSA9IHBvc3RpdFJ1bGVzLmNhblJlcGxhY2UoYXR0YWNoZXJzLCBuZXdTaGFwZSk7XG5cbiAgICAgIHRoaXMucmVwbGFjZUVsZW1lbnRzKGF0dGFjaGVycywgY2FuUmVwbGFjZS5yZXBsYWNlbWVudHMpO1xuICAgIH1cblxuICB9LCB0aGlzKTtcblxuICAvLyBrZWVwIElEIG9uIHNoYXBlIHJlcGxhY2VcbiAgdGhpcy5wb3N0RXhlY3V0ZWQoWyAnc2hhcGUucmVwbGFjZScgXSwgMTUwMCwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBvbGRTaGFwZSA9IGNvbnRleHQub2xkU2hhcGUsXG4gICAgICAgIG5ld1NoYXBlID0gY29udGV4dC5uZXdTaGFwZTtcblxuICAgIG1vZGVsaW5nLnVuY2xhaW1JZChvbGRTaGFwZS5idXNpbmVzc09iamVjdC5pZCwgb2xkU2hhcGUuYnVzaW5lc3NPYmplY3QpO1xuICAgIG1vZGVsaW5nLnVwZGF0ZVByb3BlcnRpZXMobmV3U2hhcGUsIHsgaWQ6IG9sZFNoYXBlLmlkIH0pO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoUmVwbGFjZUVsZW1lbnRCZWhhdmlvdXIsIENvbW1hbmRJbnRlcmNlcHRvcik7XG5cblJlcGxhY2VFbGVtZW50QmVoYXZpb3VyLnByb3RvdHlwZS5yZXBsYWNlRWxlbWVudHMgPSBmdW5jdGlvbihlbGVtZW50cywgbmV3RWxlbWVudHMpIHtcbiAgdmFyIGVsZW1lbnRSZWdpc3RyeSA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeSxcbiAgICAgIHBvc3RpdFJlcGxhY2UgPSB0aGlzLl9wb3N0aXRSZXBsYWNlLFxuICAgICAgc2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uO1xuXG4gIGZvckVhY2gobmV3RWxlbWVudHMsIGZ1bmN0aW9uKHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIG5ld0VsZW1lbnQgPSB7XG4gICAgICB0eXBlOiByZXBsYWNlbWVudC5uZXdFbGVtZW50VHlwZVxuICAgIH07XG5cbiAgICB2YXIgb2xkRWxlbWVudCA9IGVsZW1lbnRSZWdpc3RyeS5nZXQocmVwbGFjZW1lbnQub2xkRWxlbWVudElkKTtcblxuICAgIHZhciBpZHggPSBlbGVtZW50cy5pbmRleE9mKG9sZEVsZW1lbnQpO1xuXG4gICAgZWxlbWVudHNbaWR4XSA9IHBvc3RpdFJlcGxhY2UucmVwbGFjZUVsZW1lbnQob2xkRWxlbWVudCwgbmV3RWxlbWVudCwgeyBzZWxlY3Q6IGZhbHNlIH0pO1xuICB9KTtcblxuICBpZiAobmV3RWxlbWVudHMpIHtcbiAgICBzZWxlY3Rpb24uc2VsZWN0KGVsZW1lbnRzKTtcbiAgfVxufTtcblxuUmVwbGFjZUVsZW1lbnRCZWhhdmlvdXIuJGluamVjdCA9IFtcbiAgJ3Bvc3RpdFJlcGxhY2UnLFxuICAncG9zdGl0UnVsZXMnLFxuICAnZWxlbWVudFJlZ2lzdHJ5JyxcbiAgJ2luamVjdG9yJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ3NlbGVjdGlvbidcbl07XG4iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgQ29tbWFuZEludGVyY2VwdG9yIGZyb20gJ2RpYWdyYW0tanMvbGliL2NvbW1hbmQvQ29tbWFuZEludGVyY2VwdG9yJztcblxuaW1wb3J0IHsgaXNMYWJlbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwvTGFiZWxVdGlsJztcblxuXG4vKipcbiAqIFVuY2xhaW1zIG1vZGVsIElEcyBvbiBlbGVtZW50IGRlbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqIEBwYXJhbSB7SW5qZWN0b3J9IGluamVjdG9yXG4gKiBAcGFyYW0ge01vZGRsZX0gbW9kZGxlXG4gKiBAcGFyYW0ge01vZGVsaW5nfSBtb2RlbGluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBVbmNsYWltSWRCZWhhdmlvcihjYW52YXMsIGluamVjdG9yLCBtb2RkbGUsIG1vZGVsaW5nKSB7XG4gIGluamVjdG9yLmludm9rZShDb21tYW5kSW50ZXJjZXB0b3IsIHRoaXMpO1xuXG4gIHRoaXMucHJlRXhlY3V0ZSgnc2hhcGUuZGVsZXRlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgICAgc2hhcGVCbyA9IHNoYXBlLmJ1c2luZXNzT2JqZWN0O1xuXG4gICAgaWYgKGlzTGFiZWwoc2hhcGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW9kZWxpbmcudW5jbGFpbUlkKHNoYXBlQm8uaWQsIHNoYXBlQm8pO1xuICB9KTtcblxuICB0aGlzLnByZUV4ZWN1dGUoJ2NhbnZhcy51cGRhdGVSb290JywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJvb3RFbGVtZW50ID0gY2FudmFzLmdldFJvb3RFbGVtZW50KCksXG4gICAgICAgIHJvb3RFbGVtZW50Qm8gPSByb290RWxlbWVudC5idXNpbmVzc09iamVjdDtcblxuICAgIG1vZGRsZS5pZHMudW5jbGFpbShyb290RWxlbWVudEJvLmlkKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFVuY2xhaW1JZEJlaGF2aW9yLCBDb21tYW5kSW50ZXJjZXB0b3IpO1xuXG5VbmNsYWltSWRCZWhhdmlvci4kaW5qZWN0ID0gWyAnY2FudmFzJywgJ2luamVjdG9yJywgJ21vZGRsZScsICdtb2RlbGluZycgXTsiLCJpbXBvcnQgQWRhcHRpdmVMYWJlbFBvc2l0aW9uaW5nQmVoYXZpb3IgZnJvbSAnLi9BZGFwdGl2ZUxhYmVsUG9zaXRpb25pbmdCZWhhdmlvcic7XG5pbXBvcnQgQXBwZW5kQmVoYXZpb3IgZnJvbSAnLi9BcHBlbmRCZWhhdmlvcic7XG5pbXBvcnQgRml4SG92ZXJCZWhhdmlvciBmcm9tICcuL0ZpeEhvdmVyQmVoYXZpb3InO1xuaW1wb3J0IEltcG9ydERvY2tpbmdGaXggZnJvbSAnLi9JbXBvcnREb2NraW5nRml4JztcbmltcG9ydCBMYWJlbEJlaGF2aW9yIGZyb20gJy4vTGFiZWxCZWhhdmlvcic7XG5pbXBvcnQgUmVwbGFjZUVsZW1lbnRCZWhhdmlvdXIgZnJvbSAnLi9SZXBsYWNlRWxlbWVudEJlaGF2aW91cic7XG5pbXBvcnQgVW5jbGFpbUlkQmVoYXZpb3IgZnJvbSAnLi9VbmNsYWltSWRCZWhhdmlvcic7XG5pbXBvcnQgQ3JlYXRlQm9hcmRFbGVtZW50QmVoYXZpb3IgZnJvbSAnLi9DcmVhdGVCb2FyZEVsZW1lbnRCZWhhdmlvcic7XG5pbXBvcnQgRW1wdHlUZXh0Qm94QmVoYXZpb3IgZnJvbSAnLi9FbXB0eVRleHRCb3hCZWhhdmlvcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFtcbiAgICAnYWRhcHRpdmVMYWJlbFBvc2l0aW9uaW5nQmVoYXZpb3InLFxuICAgICdhcHBlbmRCZWhhdmlvcicsXG4gICAgJ2ZpeEhvdmVyQmVoYXZpb3InLFxuICAgICdpbXBvcnREb2NraW5nRml4JyxcbiAgICAnbGFiZWxCZWhhdmlvcicsXG4gICAgJ3JlcGxhY2VFbGVtZW50QmVoYXZpb3VyJyxcbiAgICAndW5jbGFpbUlkQmVoYXZpb3InLFxuICAgICdjcmVhdGVCb2FyZEVsZW1lbnRCZWhhdmlvcicsXG4gICAgJ2VtcHR5VGV4dEJveEJlaGF2aW9yJ1xuICBdLFxuICBhZGFwdGl2ZUxhYmVsUG9zaXRpb25pbmdCZWhhdmlvcjogWyAndHlwZScsIEFkYXB0aXZlTGFiZWxQb3NpdGlvbmluZ0JlaGF2aW9yIF0sXG4gIGFwcGVuZEJlaGF2aW9yOiBbICd0eXBlJywgQXBwZW5kQmVoYXZpb3IgXSxcbiAgZml4SG92ZXJCZWhhdmlvcjogWyAndHlwZScsIEZpeEhvdmVyQmVoYXZpb3IgXSxcbiAgaW1wb3J0RG9ja2luZ0ZpeDogWyAndHlwZScsIEltcG9ydERvY2tpbmdGaXggXSxcbiAgbGFiZWxCZWhhdmlvcjogWyAndHlwZScsIExhYmVsQmVoYXZpb3IgXSxcbiAgcmVwbGFjZUVsZW1lbnRCZWhhdmlvdXI6IFsgJ3R5cGUnLCBSZXBsYWNlRWxlbWVudEJlaGF2aW91ciBdLFxuICB1bmNsYWltSWRCZWhhdmlvcjogWyAndHlwZScsIFVuY2xhaW1JZEJlaGF2aW9yIF0sXG4gIGNyZWF0ZUJvYXJkRWxlbWVudEJlaGF2aW9yOiBbICd0eXBlJywgQ3JlYXRlQm9hcmRFbGVtZW50QmVoYXZpb3IgXSxcbiAgZW1wdHlUZXh0Qm94QmVoYXZpb3I6IFsgJ3R5cGUnLCBFbXB0eVRleHRCb3hCZWhhdmlvciBdXG59O1xuIiwiLyoqXG4gKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge1ZlY3Rvcn1cbiAqIEByZXR1cm4ge0Zsb2F0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVjdG9yTGVuZ3RoKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2LngsIDIpICsgTWF0aC5wb3codi55LCAyKSk7XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhbmdsZSBiZXR3ZWVuIGEgbGluZSBhIHRoZSB5QXhpc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJuIHtGbG9hdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFuZ2xlKGxpbmUpIHtcblxuICAvLyByZXR1cm4gdmFsdWUgaXMgYmV0d2VlbiAwLCAxODAgYW5kIC0xODAsIC0wXG4gIC8vIEBqYW5zdHVlbW1lbDogbWF5YmUgcmVwbGFjZSByZXR1cm4gYS9iIHdpdGggYi9hXG4gIHJldHVybiBNYXRoLmF0YW4oKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSkgLyAobGluZVsxXS54IC0gbGluZVswXS54KSk7XG59XG5cblxuLyoqXG4gKiBSb3RhdGVzIGEgdmVjdG9yIGJ5IGEgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge1ZlY3Rvcn1cbiAqIEBwYXJhbSB7RmxvYXR9IEFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVZlY3Rvcih2ZWN0b3IsIGFuZ2xlKSB7XG4gIHJldHVybiAoIWFuZ2xlKSA/IHZlY3RvciA6IHtcbiAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiB2ZWN0b3IueCAtIE1hdGguc2luKGFuZ2xlKSAqIHZlY3Rvci55LFxuICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIHZlY3Rvci54ICsgTWF0aC5jb3MoYW5nbGUpICogdmVjdG9yLnlcbiAgfTtcbn1cblxuXG4vKipcbiAqIFNvbHZlcyBhIDJEIGVxdWF0aW9uIHN5c3RlbVxuICogYSArIHIqYiA9IGMsIHdoZXJlIGEsYixjIGFyZSAyRCB2ZWN0b3JzXG4gKlxuICogQHBhcmFtIHtWZWN0b3J9XG4gKiBAcGFyYW0ge1ZlY3Rvcn1cbiAqIEBwYXJhbSB7VmVjdG9yfVxuICogQHJldHVybiB7RmxvYXR9XG4gKi9cbmZ1bmN0aW9uIHNvbHZlTGFtYmFTeXN0ZW0oYSwgYiwgYykge1xuXG4gIC8vIHRoZSAyZCBzeXN0ZW1cbiAgdmFyIHN5c3RlbSA9IFtcbiAgICB7IG46IGFbMF0gLSBjWzBdLCBsYW1iZGE6IGJbMF0gfSxcbiAgICB7IG46IGFbMV0gLSBjWzFdLCBsYW1iZGE6IGJbMV0gfVxuICBdO1xuXG4gIC8vIHNvbHZlXG4gIHZhciBuID0gc3lzdGVtWzBdLm4gKiBiWzBdICsgc3lzdGVtWzFdLm4gKiBiWzFdLFxuICAgICAgbCA9IHN5c3RlbVswXS5sYW1iZGEgKiBiWzBdICsgc3lzdGVtWzFdLmxhbWJkYSAqIGJbMV07XG5cbiAgcmV0dXJuIC1uL2w7XG59XG5cblxuLyoqXG4gKiBQb3NpdGlvbiBvZiBwZXJwZW5kaWN1bGFyIGZvb3RcbiAqXG4gKiBAcGFyYW0ge1BvaW50fVxuICogQHBhcmFtIFsge1BvaW50fSwge1BvaW50fSBdIGxpbmUgZGVmaW5lZCB0aHJvdWdoIHR3byBwb2ludHNcbiAqIEByZXR1cm4ge1BvaW50fSB0aGUgcGVycGVuZGljdWxhciBmb290IHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZXJwZW5kaWN1bGFyRm9vdChwb2ludCwgbGluZSkge1xuXG4gIHZhciBhID0gbGluZVswXSwgYiA9IGxpbmVbMV07XG5cbiAgLy8gcmVsYXRpdmUgcG9zaXRpb24gb2YgYiBmcm9tIGFcbiAgdmFyIGJkID0geyB4OiBiLnggLSBhLngsIHk6IGIueSAtIGEueSB9O1xuXG4gIC8vIHNvbHZlIGVxdWF0aW9uIHN5c3RlbSB0byB0aGUgcGFyYW1ldHJpemVkIHZlY3RvcnMgcGFyYW0gcmVhbCB2YWx1ZVxuICB2YXIgciA9IHNvbHZlTGFtYmFTeXN0ZW0oWyBhLngsIGEueSBdLCBbIGJkLngsIGJkLnkgXSwgWyBwb2ludC54LCBwb2ludC55IF0pO1xuXG4gIHJldHVybiB7IHg6IGEueCArIHIqYmQueCwgeTogYS55ICsgcipiZC55IH07XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgYW5kIGEgbGluZVxuICpcbiAqIEBwYXJhbSB7UG9pbnR9XG4gKiBAcGFyYW0gWyB7UG9pbnR9LCB7UG9pbnR9IF0gbGluZSBkZWZpbmVkIHRocm91Z2ggdHdvIHBvaW50c1xuICogQHJldHVybiB7RmxvYXR9IGRpc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZVBvaW50TGluZShwb2ludCwgbGluZSkge1xuXG4gIHZhciBwZlBvaW50ID0gcGVycGVuZGljdWxhckZvb3QocG9pbnQsIGxpbmUpO1xuXG4gIC8vIGRpc3RhbmNlIHZlY3RvclxuICB2YXIgY29ubmVjdGlvblZlY3RvciA9IHtcbiAgICB4OiBwZlBvaW50LnggLSBwb2ludC54LFxuICAgIHk6IHBmUG9pbnQueSAtIHBvaW50LnlcbiAgfTtcblxuICByZXR1cm4gdmVjdG9yTGVuZ3RoKGNvbm5lY3Rpb25WZWN0b3IpO1xufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKlxuICogQHBhcmFtIHtQb2ludH1cbiAqIEBwYXJhbSB7UG9pbnR9XG4gKiBAcmV0dXJuIHtGbG9hdH0gZGlzdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlUG9pbnRQb2ludChwb2ludDEsIHBvaW50Mikge1xuXG4gIHJldHVybiB2ZWN0b3JMZW5ndGgoe1xuICAgIHg6IHBvaW50MS54IC0gcG9pbnQyLngsXG4gICAgeTogcG9pbnQxLnkgLSBwb2ludDIueVxuICB9KTtcbn0iLCJpbXBvcnQge1xuICBnZXREaXN0YW5jZVBvaW50UG9pbnQsXG4gIHJvdGF0ZVZlY3RvcixcbiAgZ2V0QW5nbGVcbn0gZnJvbSAnLi9HZW9tZXRyaWNVdGlsJztcblxuaW1wb3J0IHtcbiAgZ2V0QXR0YWNobWVudFxufSBmcm9tICcuL0xpbmVBdHRhY2htZW50VXRpbCc7XG5cbmltcG9ydCB7XG4gIHJvdW5kUG9pbnRcbn0gZnJvbSAnZGlhZ3JhbS1qcy9saWIvbGF5b3V0L0xheW91dFV0aWwnO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTmV3TGFiZWxMaW5lU3RhcnRJbmRleChvbGRXYXlwb2ludHMsIG5ld1dheXBvaW50cywgYXR0YWNobWVudCwgaGludHMpIHtcblxuICB2YXIgaW5kZXggPSBhdHRhY2htZW50LnNlZ21lbnRJbmRleDtcblxuICB2YXIgb2Zmc2V0ID0gbmV3V2F5cG9pbnRzLmxlbmd0aCAtIG9sZFdheXBvaW50cy5sZW5ndGg7XG5cbiAgLy8gc2VnbWVudE1vdmUgaGFwcGVuZWRcbiAgaWYgKGhpbnRzLnNlZ21lbnRNb3ZlKSB7XG5cbiAgICB2YXIgb2xkU2VnbWVudFN0YXJ0SW5kZXggPSBoaW50cy5zZWdtZW50TW92ZS5zZWdtZW50U3RhcnRJbmRleCxcbiAgICAgICAgbmV3U2VnbWVudFN0YXJ0SW5kZXggPSBoaW50cy5zZWdtZW50TW92ZS5uZXdTZWdtZW50U3RhcnRJbmRleDtcblxuICAgIC8vIGlmIGxhYmVsIHdhcyBvbiBtb3ZlZCBzZWdtZW50IHJldHVybiBuZXcgc2VnbWVudCBpbmRleFxuICAgIGlmIChpbmRleCA9PT0gb2xkU2VnbWVudFN0YXJ0SW5kZXgpIHtcbiAgICAgIHJldHVybiBuZXdTZWdtZW50U3RhcnRJbmRleDtcbiAgICB9XG5cbiAgICAvLyBsYWJlbCBpcyBhZnRlciBuZXcgc2VnbWVudCBpbmRleFxuICAgIGlmIChpbmRleCA+PSBuZXdTZWdtZW50U3RhcnRJbmRleCkge1xuICAgICAgcmV0dXJuIChpbmRleCtvZmZzZXQgPCBuZXdTZWdtZW50U3RhcnRJbmRleCkgPyBuZXdTZWdtZW50U3RhcnRJbmRleCA6IGluZGV4K29mZnNldDtcbiAgICB9XG5cbiAgICAvLyBpZiBsYWJlbCBpcyBiZWZvcmUgbmV3IHNlZ21lbnQgaW5kZXhcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvLyBiZW5kcG9pbnRNb3ZlIGhhcHBlbmVkXG4gIGlmIChoaW50cy5iZW5kcG9pbnRNb3ZlKSB7XG5cbiAgICB2YXIgaW5zZXJ0ID0gaGludHMuYmVuZHBvaW50TW92ZS5pbnNlcnQsXG4gICAgICAgIGJlbmRwb2ludEluZGV4ID0gaGludHMuYmVuZHBvaW50TW92ZS5iZW5kcG9pbnRJbmRleCxcbiAgICAgICAgbmV3SW5kZXg7XG5cbiAgICAvLyB3YXlwb2ludHMgbGVuZ3RoIGRpZG50IGNoYW5nZVxuICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICAvLyBsYWJlbCBiZWhpbmQgbmV3L3JlbW92ZWQgYmVuZHBvaW50XG4gICAgaWYgKGluZGV4ID49IGJlbmRwb2ludEluZGV4KSB7XG4gICAgICBuZXdJbmRleCA9IGluc2VydCA/IGluZGV4ICsgMSA6IGluZGV4IC0gMTtcbiAgICB9XG5cbiAgICAvLyBsYWJlbCBiZWZvcmUgbmV3L3JlbW92ZWQgYmVuZHBvaW50XG4gICAgaWYgKGluZGV4IDwgYmVuZHBvaW50SW5kZXgpIHtcblxuICAgICAgbmV3SW5kZXggPSBpbmRleDtcblxuICAgICAgLy8gZGVjaWRlIGxhYmVsIHNob3VsZCB0YWtlIHJpZ2h0IG9yIGxlZnQgc2VnbWVudFxuICAgICAgaWYgKGluc2VydCAmJiBhdHRhY2htZW50LnR5cGUgIT09ICdiZW5kcG9pbnQnICYmIGJlbmRwb2ludEluZGV4LTEgPT09IGluZGV4KSB7XG5cbiAgICAgICAgdmFyIHJlbCA9IHJlbGF0aXZlUG9zaXRpb25NaWRXYXlwb2ludChuZXdXYXlwb2ludHMsIGJlbmRwb2ludEluZGV4KTtcblxuICAgICAgICBpZiAocmVsIDwgYXR0YWNobWVudC5yZWxhdGl2ZUxvY2F0aW9uKSB7XG4gICAgICAgICAgbmV3SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdJbmRleDtcbiAgfVxuXG4gIC8vIHN0YXJ0L2VuZCBjaGFuZ2VkXG4gIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBpZiAoaGludHMuY29ubmVjdGlvblN0YXJ0KSB7XG4gICAgcmV0dXJuIChpbmRleCA9PT0gMCkgPyAwIDogbnVsbDtcbiAgfVxuXG4gIGlmIChoaW50cy5jb25uZWN0aW9uRW5kKSB7XG4gICAgcmV0dXJuIChpbmRleCA9PT0gb2xkV2F5cG9pbnRzLmxlbmd0aCAtIDIpID8gbmV3V2F5cG9pbnRzLmxlbmd0aCAtIDIgOiBudWxsO1xuICB9XG5cbiAgLy8gaWYgbm90aGluZyBmaXRzLCByZXR1cm4gbnVsbFxuICByZXR1cm4gbnVsbDtcbn1cblxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcmVxdWlyZWQgYWRqdXN0bWVudCAobW92ZSBkZWx0YSkgZm9yIHRoZSBnaXZlbiBsYWJlbFxuICogYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gd2F5cG9pbnRzIGdvdCB1cGRhdGVkLlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkxhYmVsfSBsYWJlbFxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IG5ld1dheXBvaW50c1xuICogQHBhcmFtIHtBcnJheTxQb2ludD59IG9sZFdheXBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IGhpbnRzXG4gKlxuICogQHJldHVybiB7UG9pbnR9IGRlbHRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYWJlbEFkanVzdG1lbnQobGFiZWwsIG5ld1dheXBvaW50cywgb2xkV2F5cG9pbnRzLCBoaW50cykge1xuXG4gIHZhciB4ID0gMCxcbiAgICAgIHkgPSAwO1xuXG4gIHZhciBsYWJlbFBvc2l0aW9uID0gZ2V0TGFiZWxNaWQobGFiZWwpO1xuXG4gIC8vIGdldCBjbG9zZXN0IGF0dGFjaG1lbnRcbiAgdmFyIGF0dGFjaG1lbnQgPSBnZXRBdHRhY2htZW50KGxhYmVsUG9zaXRpb24sIG9sZFdheXBvaW50cyksXG4gICAgICBvbGRMYWJlbExpbmVJbmRleCA9IGF0dGFjaG1lbnQuc2VnbWVudEluZGV4LFxuICAgICAgbmV3TGFiZWxMaW5lSW5kZXggPSBmaW5kTmV3TGFiZWxMaW5lU3RhcnRJbmRleChvbGRXYXlwb2ludHMsIG5ld1dheXBvaW50cywgYXR0YWNobWVudCwgaGludHMpO1xuXG4gIGlmIChuZXdMYWJlbExpbmVJbmRleCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgfVxuXG4gIC8vIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgLy8gVE9ETyhAamFuc3R1ZW1tZWwpOiB0aHJvdyBhbiBlcnJvciBoZXJlIHdoZW4gY29ubmVjdGlvblNlZ21lbnRNb3ZlIGlzIHJlZmFjdG9yZWRcbiAgaWYgKG5ld0xhYmVsTGluZUluZGV4IDwgMCB8fFxuICAgICAgbmV3TGFiZWxMaW5lSW5kZXggPiBuZXdXYXlwb2ludHMubGVuZ3RoIC0gMikge1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgfVxuXG4gIHZhciBvbGRMYWJlbExpbmUgPSBnZXRMaW5lKG9sZFdheXBvaW50cywgb2xkTGFiZWxMaW5lSW5kZXgpLFxuICAgICAgbmV3TGFiZWxMaW5lID0gZ2V0TGluZShuZXdXYXlwb2ludHMsIG5ld0xhYmVsTGluZUluZGV4KSxcbiAgICAgIG9sZEZvb3QgPSBhdHRhY2htZW50LnBvc2l0aW9uO1xuXG4gIHZhciByZWxhdGl2ZUZvb3RQb3NpdGlvbiA9IGdldFJlbGF0aXZlRm9vdFBvc2l0aW9uKG9sZExhYmVsTGluZSwgb2xkRm9vdCksXG4gICAgICBhbmdsZURlbHRhID0gZ2V0QW5nbGVEZWx0YShvbGRMYWJlbExpbmUsIG5ld0xhYmVsTGluZSk7XG5cbiAgLy8gc3BlY2lhbCBydWxlIGlmIGxhYmVsIG9uIGJlbmRwb2ludFxuICBpZiAoYXR0YWNobWVudC50eXBlID09PSAnYmVuZHBvaW50Jykge1xuXG4gICAgdmFyIG9mZnNldCA9IG5ld1dheXBvaW50cy5sZW5ndGggLSBvbGRXYXlwb2ludHMubGVuZ3RoLFxuICAgICAgICBvbGRCZW5kcG9pbnRJbmRleCA9IGF0dGFjaG1lbnQuYmVuZHBvaW50SW5kZXgsXG4gICAgICAgIG9sZEJlbmRwb2ludCA9IG9sZFdheXBvaW50c1tvbGRCZW5kcG9pbnRJbmRleF07XG5cbiAgICAvLyBiZW5kcG9pbnQgcG9zaXRpb24gaGFzbid0IGNoYW5nZWQsIHJldHVybiBzYW1lIHBvc2l0aW9uXG4gICAgaWYgKG5ld1dheXBvaW50cy5pbmRleE9mKG9sZEJlbmRwb2ludCkgIT09IC0xKSB7XG4gICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfVxuXG4gICAgLy8gbmV3IGJlbmRwb2ludCBhbmQgb2xkIGJlbmRwb2ludCBoYXZlIHNhbWUgaW5kZXgsIHRoZW4ganVzdCByZXR1cm4gdGhlIG9mZnNldFxuICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgIHZhciBuZXdCZW5kcG9pbnQgPSBuZXdXYXlwb2ludHNbb2xkQmVuZHBvaW50SW5kZXhdO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBuZXdCZW5kcG9pbnQueCAtIGF0dGFjaG1lbnQucG9zaXRpb24ueCxcbiAgICAgICAgeTogbmV3QmVuZHBvaW50LnkgLSBhdHRhY2htZW50LnBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaWYgYmVuZHBvaW50cyBnZXQgcmVtb3ZlZFxuICAgIGlmIChvZmZzZXQgPCAwICYmIG9sZEJlbmRwb2ludEluZGV4ICE9PSAwICYmIG9sZEJlbmRwb2ludEluZGV4IDwgb2xkV2F5cG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJlbGF0aXZlRm9vdFBvc2l0aW9uID0gcmVsYXRpdmVQb3NpdGlvbk1pZFdheXBvaW50KG9sZFdheXBvaW50cywgb2xkQmVuZHBvaW50SW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdGb290ID0ge1xuICAgIHg6IChuZXdMYWJlbExpbmVbMV0ueCAtIG5ld0xhYmVsTGluZVswXS54KSAqIHJlbGF0aXZlRm9vdFBvc2l0aW9uICsgbmV3TGFiZWxMaW5lWzBdLngsXG4gICAgeTogKG5ld0xhYmVsTGluZVsxXS55IC0gbmV3TGFiZWxMaW5lWzBdLnkpICogcmVsYXRpdmVGb290UG9zaXRpb24gKyBuZXdMYWJlbExpbmVbMF0ueVxuICB9O1xuXG4gIC8vIHRoZSByb3RhdGVkIHZlY3RvciB0byBsYWJlbFxuICB2YXIgbmV3TGFiZWxWZWN0b3IgPSByb3RhdGVWZWN0b3Ioe1xuICAgIHg6IGxhYmVsUG9zaXRpb24ueCAtIG9sZEZvb3QueCxcbiAgICB5OiBsYWJlbFBvc2l0aW9uLnkgLSBvbGRGb290LnlcbiAgfSwgYW5nbGVEZWx0YSk7XG5cbiAgLy8gdGhlIG5ldyByZWxhdGl2ZSBwb3NpdGlvblxuICB4ID0gbmV3Rm9vdC54ICsgbmV3TGFiZWxWZWN0b3IueCAtIGxhYmVsUG9zaXRpb24ueDtcbiAgeSA9IG5ld0Zvb3QueSArIG5ld0xhYmVsVmVjdG9yLnkgLSBsYWJlbFBvc2l0aW9uLnk7XG5cbiAgcmV0dXJuIHJvdW5kUG9pbnQoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KTtcbn1cblxuXG4vLyBIRUxQRVJTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gcmVsYXRpdmVQb3NpdGlvbk1pZFdheXBvaW50KHdheXBvaW50cywgaWR4KSB7XG5cbiAgdmFyIGRpc3RhbmNlU2VnbWVudDEgPSBnZXREaXN0YW5jZVBvaW50UG9pbnQod2F5cG9pbnRzW2lkeC0xXSwgd2F5cG9pbnRzW2lkeF0pLFxuICAgICAgZGlzdGFuY2VTZWdtZW50MiA9IGdldERpc3RhbmNlUG9pbnRQb2ludCh3YXlwb2ludHNbaWR4XSwgd2F5cG9pbnRzW2lkeCsxXSk7XG5cbiAgdmFyIHJlbGF0aXZlUG9zaXRpb24gPSBkaXN0YW5jZVNlZ21lbnQxIC8gKGRpc3RhbmNlU2VnbWVudDEgKyBkaXN0YW5jZVNlZ21lbnQyKTtcblxuICByZXR1cm4gcmVsYXRpdmVQb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWxNaWQobGFiZWwpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBsYWJlbC54ICsgbGFiZWwud2lkdGggLyAyLFxuICAgIHk6IGxhYmVsLnkgKyBsYWJlbC5oZWlnaHQgLyAyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFuZ2xlRGVsdGEobDEsIGwyKSB7XG4gIHZhciBhMSA9IGdldEFuZ2xlKGwxKSxcbiAgICAgIGEyID0gZ2V0QW5nbGUobDIpO1xuICByZXR1cm4gYTIgLSBhMTtcbn1cblxuZnVuY3Rpb24gZ2V0TGluZSh3YXlwb2ludHMsIGlkeCkge1xuICByZXR1cm4gWyB3YXlwb2ludHNbaWR4XSwgd2F5cG9pbnRzW2lkeCsxXSBdO1xufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZUZvb3RQb3NpdGlvbihsaW5lLCBmb290KSB7XG5cbiAgdmFyIGxlbmd0aCA9IGdldERpc3RhbmNlUG9pbnRQb2ludChsaW5lWzBdLCBsaW5lWzFdKSxcbiAgICAgIGxlbmd0aFRvRm9vdCA9IGdldERpc3RhbmNlUG9pbnRQb2ludChsaW5lWzBdLCBmb290KTtcblxuICByZXR1cm4gbGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aFRvRm9vdCAvIGxlbmd0aDtcbn1cbiIsInZhciBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIG1pbiA9IE1hdGgubWluLFxuICAgIG1heCA9IE1hdGgubWF4LFxuICAgIGFicyA9IE1hdGguYWJzO1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgc3F1YXJlIChwb3dlciB0byB0d28pIG9mIGEgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBzcShuKSB7XG4gIHJldHVybiBNYXRoLnBvdyhuLCAyKTtcbn1cblxuLyoqXG4gKiBHZXQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICpcbiAqIEBwYXJhbSB7UG9pbnR9IHAxXG4gKiBAcGFyYW0ge1BvaW50fSBwMlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyKSB7XG4gIHJldHVybiBzcXJ0KHNxKHAxLnggLSBwMi54KSArIHNxKHAxLnkgLSBwMi55KSk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBhdHRhY2htZW50IG9mIHRoZSBnaXZlbiBwb2ludCBvbiB0aGUgc3BlY2lmaWVkIGxpbmUuXG4gKlxuICogVGhlIGF0dGFjaG1lbnQgaXMgZWl0aGVyIGEgYmVuZHBvaW50IChhdHRhY2hlZCB0byB0aGUgZ2l2ZW4gcG9pbnQpXG4gKiBvciBzZWdtZW50IChhdHRhY2hlZCB0byBhIGxvY2F0aW9uIG9uIGEgbGluZSBzZWdtZW50KSBhdHRhY2htZW50OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwb2ludEF0dGFjaG1lbnQgPSB7XG4gKiAgIHR5cGU6ICdiZW5kcG9pbnQnLFxuICogICBiZW5kcG9pbnRJbmRleDogMyxcbiAqICAgcG9zaXRpb246IHsgeDogMTAsIHk6IDEwIH0gLy8gdGhlIGF0dGFjaCBwb2ludCBvbiB0aGUgbGluZVxuICogfTtcbiAqXG4gKiB2YXIgc2VnbWVudEF0dGFjaG1lbnQgPSB7XG4gKiAgIHR5cGU6ICdzZWdtZW50JyxcbiAqICAgc2VnbWVudEluZGV4OiAyLFxuICogICByZWxhdGl2ZUxvY2F0aW9uOiAwLjMxLCAvLyBhdHRhY2ggcG9pbnQgbG9jYXRpb24gYmV0d2VlbiAwIChhdCBzdGFydCkgYW5kIDEgKGF0IGVuZClcbiAqICAgcG9zaXRpb246IHsgeDogMTAsIHk6IDEwIH0gLy8gdGhlIGF0dGFjaCBwb2ludCBvbiB0aGUgbGluZVxuICogfTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gbGluZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gYXR0YWNobWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0YWNobWVudChwb2ludCwgbGluZSkge1xuXG4gIHZhciBpZHggPSAwLFxuICAgICAgc2VnbWVudFN0YXJ0LFxuICAgICAgc2VnbWVudEVuZCxcbiAgICAgIHNlZ21lbnRTdGFydERpc3RhbmNlLFxuICAgICAgc2VnbWVudEVuZERpc3RhbmNlLFxuICAgICAgYXR0YWNobWVudFBvc2l0aW9uLFxuICAgICAgbWluRGlzdGFuY2UsXG4gICAgICBpbnRlcnNlY3Rpb25zLFxuICAgICAgYXR0YWNobWVudCxcbiAgICAgIGF0dGFjaG1lbnREaXN0YW5jZSxcbiAgICAgIGNsb3Nlc3RBdHRhY2htZW50RGlzdGFuY2UsXG4gICAgICBjbG9zZXN0QXR0YWNobWVudDtcblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxpbmUubGVuZ3RoIC0gMTsgaWR4KyspIHtcblxuICAgIHNlZ21lbnRTdGFydCA9IGxpbmVbaWR4XTtcbiAgICBzZWdtZW50RW5kID0gbGluZVtpZHggKyAxXTtcblxuICAgIGlmIChwb2ludHNFcXVhbChzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQpKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zID0gWyBzZWdtZW50U3RhcnQgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VnbWVudFN0YXJ0RGlzdGFuY2UgPSBnZXREaXN0YW5jZShwb2ludCwgc2VnbWVudFN0YXJ0KTtcbiAgICAgIHNlZ21lbnRFbmREaXN0YW5jZSA9IGdldERpc3RhbmNlKHBvaW50LCBzZWdtZW50RW5kKTtcblxuICAgICAgbWluRGlzdGFuY2UgPSBtaW4oc2VnbWVudFN0YXJ0RGlzdGFuY2UsIHNlZ21lbnRFbmREaXN0YW5jZSk7XG5cbiAgICAgIGludGVyc2VjdGlvbnMgPSBnZXRDaXJjbGVTZWdtZW50SW50ZXJzZWN0aW9ucyhzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQsIHBvaW50LCBtaW5EaXN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBiZXR3ZWVuIFsxLCAyXSBjaXJjbGUgLT4gbGluZSBpbnRlcnNlY3Rpb25zJyk7XG4gICAgfVxuXG4gICAgLy8gb25lIGludGVyc2VjdGlvbiAtPiBiZW5kcG9pbnQgYXR0YWNobWVudFxuICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgYXR0YWNobWVudCA9IHtcbiAgICAgICAgdHlwZTogJ2JlbmRwb2ludCcsXG4gICAgICAgIHBvc2l0aW9uOiBpbnRlcnNlY3Rpb25zWzBdLFxuICAgICAgICBzZWdtZW50SW5kZXg6IGlkeCxcbiAgICAgICAgYmVuZHBvaW50SW5kZXg6IHBvaW50c0VxdWFsKHNlZ21lbnRTdGFydCwgaW50ZXJzZWN0aW9uc1swXSkgPyBpZHggOiBpZHggKyAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHR3byBpbnRlcnNlY3Rpb25zIC0+IHNlZ21lbnQgYXR0YWNobWVudFxuICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA9PT0gMikge1xuXG4gICAgICBhdHRhY2htZW50UG9zaXRpb24gPSBtaWQoaW50ZXJzZWN0aW9uc1swXSwgaW50ZXJzZWN0aW9uc1sxXSk7XG5cbiAgICAgIGF0dGFjaG1lbnQgPSB7XG4gICAgICAgIHR5cGU6ICdzZWdtZW50JyxcbiAgICAgICAgcG9zaXRpb246IGF0dGFjaG1lbnRQb3NpdGlvbixcbiAgICAgICAgc2VnbWVudEluZGV4OiBpZHgsXG4gICAgICAgIHJlbGF0aXZlTG9jYXRpb246IGdldERpc3RhbmNlKHNlZ21lbnRTdGFydCwgYXR0YWNobWVudFBvc2l0aW9uKSAvIGdldERpc3RhbmNlKHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYXR0YWNobWVudERpc3RhbmNlID0gZ2V0RGlzdGFuY2UoYXR0YWNobWVudC5wb3NpdGlvbiwgcG9pbnQpO1xuXG4gICAgaWYgKCFjbG9zZXN0QXR0YWNobWVudCB8fCBjbG9zZXN0QXR0YWNobWVudERpc3RhbmNlID4gYXR0YWNobWVudERpc3RhbmNlKSB7XG4gICAgICBjbG9zZXN0QXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XG4gICAgICBjbG9zZXN0QXR0YWNobWVudERpc3RhbmNlID0gYXR0YWNobWVudERpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0QXR0YWNobWVudDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiBhIGNpcmNsZSBhbmQgYSBsaW5lIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gczEgc2VnbWVudCBzdGFydFxuICogQHBhcmFtIHtQb2ludH0gczIgc2VnbWVudCBlbmRcbiAqIEBwYXJhbSB7UG9pbnR9IGNjIGNpcmNsZSBjZW50ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjciBjaXJjbGUgcmFkaXVzXG4gKlxuICogQHJldHVybiB7QXJyYXk8UG9pbnQ+fSBpbnRlcnNlY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGdldENpcmNsZVNlZ21lbnRJbnRlcnNlY3Rpb25zKHMxLCBzMiwgY2MsIGNyKSB7XG5cbiAgdmFyIGJhWCA9IHMyLnggLSBzMS54O1xuICB2YXIgYmFZID0gczIueSAtIHMxLnk7XG4gIHZhciBjYVggPSBjYy54IC0gczEueDtcbiAgdmFyIGNhWSA9IGNjLnkgLSBzMS55O1xuXG4gIHZhciBhID0gYmFYICogYmFYICsgYmFZICogYmFZO1xuICB2YXIgYkJ5MiA9IGJhWCAqIGNhWCArIGJhWSAqIGNhWTtcbiAgdmFyIGMgPSBjYVggKiBjYVggKyBjYVkgKiBjYVkgLSBjciAqIGNyO1xuXG4gIHZhciBwQnkyID0gYkJ5MiAvIGE7XG4gIHZhciBxID0gYyAvIGE7XG5cbiAgdmFyIGRpc2MgPSBwQnkyICogcEJ5MiAtIHE7XG5cbiAgLy8gY2hlY2sgYWdhaW5zdCBuZWdhdGl2ZSB2YWx1ZSB0byB3b3JrIGFyb3VuZFxuICAvLyBuZWdhdGl2ZSwgdmVyeSBjbG9zZSB0byB6ZXJvIHJlc3VsdHMgKC00ZS0xNSlcbiAgLy8gYmVpbmcgcHJvZHVjZWQgaW4gc29tZSBlbnZpcm9ubWVudHNcbiAgaWYgKGRpc2MgPCAwICYmIGRpc2MgPiAtMC4wMDAwMDEpIHtcbiAgICBkaXNjID0gMDtcbiAgfVxuXG4gIGlmIChkaXNjIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIGlmIGRpc2MgPT0gMCAuLi4gZGVhbHQgd2l0aCBsYXRlclxuICB2YXIgdG1wU3FydCA9IHNxcnQoZGlzYyk7XG4gIHZhciBhYlNjYWxpbmdGYWN0b3IxID0gLXBCeTIgKyB0bXBTcXJ0O1xuICB2YXIgYWJTY2FsaW5nRmFjdG9yMiA9IC1wQnkyIC0gdG1wU3FydDtcblxuICB2YXIgaTEgPSB7XG4gICAgeDogczEueCAtIGJhWCAqIGFiU2NhbGluZ0ZhY3RvcjEsXG4gICAgeTogczEueSAtIGJhWSAqIGFiU2NhbGluZ0ZhY3RvcjFcbiAgfTtcblxuICBpZiAoZGlzYyA9PT0gMCkgeyAvLyBhYlNjYWxpbmdGYWN0b3IxID09IGFiU2NhbGluZ0ZhY3RvcjJcbiAgICByZXR1cm4gWyBpMSBdO1xuICB9XG5cbiAgdmFyIGkyID0ge1xuICAgIHg6IHMxLnggLSBiYVggKiBhYlNjYWxpbmdGYWN0b3IyLFxuICAgIHk6IHMxLnkgLSBiYVkgKiBhYlNjYWxpbmdGYWN0b3IyXG4gIH07XG5cbiAgLy8gcmV0dXJuIG9ubHkgcG9pbnRzIG9uIGxpbmUgc2VnbWVudFxuICByZXR1cm4gWyBpMSwgaTIgXS5maWx0ZXIoZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBpc1BvaW50SW5TZWdtZW50KHAsIHMxLCBzMik7XG4gIH0pO1xufVxuXG5cbmZ1bmN0aW9uIGlzUG9pbnRJblNlZ21lbnQocCwgc2VnbWVudFN0YXJ0LCBzZWdtZW50RW5kKSB7XG4gIHJldHVybiAoXG4gICAgZmVuY2VkKHAueCwgc2VnbWVudFN0YXJ0LngsIHNlZ21lbnRFbmQueCkgJiZcbiAgICBmZW5jZWQocC55LCBzZWdtZW50U3RhcnQueSwgc2VnbWVudEVuZC55KVxuICApO1xufVxuXG5mdW5jdGlvbiBmZW5jZWQobiwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpIHtcblxuICAvLyB1c2UgbWF0Y2hpbmcgdGhyZXNob2xkIHRvIHdvcmsgYXJvdW5kXG4gIC8vIHByZWNpc2lvbiBlcnJvcnMgaW4gaW50ZXJzZWN0aW9uIGNvbXB1dGF0aW9uXG5cbiAgcmV0dXJuIChcbiAgICBuID49IG1pbihyYW5nZVN0YXJ0LCByYW5nZUVuZCkgLSBFUVVBTF9USFJFU0hPTEQgJiZcbiAgICBuIDw9IG1heChyYW5nZVN0YXJ0LCByYW5nZUVuZCkgKyBFUVVBTF9USFJFU0hPTERcbiAgKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgbWlkIG9mIHR3byBwb2ludHMuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gcDFcbiAqIEBwYXJhbSB7UG9pbnR9IHAyXG4gKlxuICogQHJldHVybiB7UG9pbnR9XG4gKi9cbmZ1bmN0aW9uIG1pZChwMSwgcDIpIHtcblxuICByZXR1cm4ge1xuICAgIHg6IChwMS54ICsgcDIueCkgLyAyLFxuICAgIHk6IChwMS55ICsgcDIueSkgLyAyXG4gIH07XG59XG5cbnZhciBFUVVBTF9USFJFU0hPTEQgPSAwLjE7XG5cbmZ1bmN0aW9uIHBvaW50c0VxdWFsKHAxLCBwMikge1xuXG4gIHJldHVybiAoXG4gICAgYWJzKHAxLnggLSBwMi54KSA8PSBFUVVBTF9USFJFU0hPTEQgJiZcbiAgICBhYnMocDEueSAtIHAyLnkpIDw9IEVRVUFMX1RIUkVTSE9MRFxuICApO1xufVxuIiwiLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0d28gbGluZSBzZWdtZW50cyBhIGFuZCBiLlxuICpcbiAqIEBwYXJhbSB7UG9pbnR9IGwxc1xuICogQHBhcmFtIHtQb2ludH0gbDFlXG4gKiBAcGFyYW0ge1BvaW50fSBsMnNcbiAqIEBwYXJhbSB7UG9pbnR9IGwyZVxuICpcbiAqIEByZXR1cm4ge1BvaW50fVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaW5lSW50ZXJzZWN0KGwxcywgbDFlLCBsMnMsIGwyZSkge1xuXG4gIC8vIGlmIHRoZSBsaW5lcyBpbnRlcnNlY3QsIHRoZSByZXN1bHQgY29udGFpbnMgdGhlIHggYW5kIHkgb2YgdGhlXG4gIC8vIGludGVyc2VjdGlvbiAodHJlYXRpbmcgdGhlIGxpbmVzIGFzIGluZmluaXRlKSBhbmQgYm9vbGVhbnMgZm9yXG4gIC8vIHdoZXRoZXIgbGluZSBzZWdtZW50IDEgb3IgbGluZSBzZWdtZW50IDIgY29udGFpbiB0aGUgcG9pbnRcbiAgdmFyIGRlbm9taW5hdG9yLCBhLCBiLCBjLCBudW1lcmF0b3I7XG5cbiAgZGVub21pbmF0b3IgPSAoKGwyZS55IC0gbDJzLnkpICogKGwxZS54IC0gbDFzLngpKSAtICgobDJlLnggLSBsMnMueCkgKiAobDFlLnkgLSBsMXMueSkpO1xuXG4gIGlmIChkZW5vbWluYXRvciA9PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBhID0gbDFzLnkgLSBsMnMueTtcbiAgYiA9IGwxcy54IC0gbDJzLng7XG4gIG51bWVyYXRvciA9ICgobDJlLnggLSBsMnMueCkgKiBhKSAtICgobDJlLnkgLSBsMnMueSkgKiBiKTtcblxuICBjID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG5cbiAgLy8gaWYgd2UgY2FzdCB0aGVzZSBsaW5lcyBpbmZpbml0ZWx5IGluXG4gIC8vIGJvdGggZGlyZWN0aW9ucywgdGhleSBpbnRlcnNlY3QgaGVyZVxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQobDFzLnggKyAoYyAqIChsMWUueCAtIGwxcy54KSkpLFxuICAgIHk6IE1hdGgucm91bmQobDFzLnkgKyAoYyAqIChsMWUueSAtIGwxcy55KSkpXG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSWRDbGFpbUhhbmRsZXIobW9kZGxlKSB7XG4gIHRoaXMuX21vZGRsZSA9IG1vZGRsZTtcbn1cblxuSWRDbGFpbUhhbmRsZXIuJGluamVjdCA9IFsgJ21vZGRsZScgXTtcblxuXG5JZENsYWltSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIGlkcyA9IHRoaXMuX21vZGRsZS5pZHMsXG4gICAgICBpZCA9IGNvbnRleHQuaWQsXG4gICAgICBlbGVtZW50ID0gY29udGV4dC5lbGVtZW50LFxuICAgICAgY2xhaW1pbmcgPSBjb250ZXh0LmNsYWltaW5nO1xuXG4gIGlmIChjbGFpbWluZykge1xuICAgIGlkcy5jbGFpbShpZCwgZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWRzLnVuY2xhaW0oaWQpO1xuICB9XG59O1xuXG4vKipcbiAqIENvbW1hbmQgcmV2ZXJ0IGltcGxlbWVudGF0aW9uLlxuICovXG5JZENsYWltSGFuZGxlci5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgaWRzID0gdGhpcy5fbW9kZGxlLmlkcyxcbiAgICAgIGlkID0gY29udGV4dC5pZCxcbiAgICAgIGVsZW1lbnQgPSBjb250ZXh0LmVsZW1lbnQsXG4gICAgICBjbGFpbWluZyA9IGNvbnRleHQuY2xhaW1pbmc7XG5cbiAgaWYgKGNsYWltaW5nKSB7XG4gICAgaWRzLnVuY2xhaW0oaWQpO1xuICB9IGVsc2Uge1xuICAgIGlkcy5jbGFpbShpZCwgZWxlbWVudCk7XG4gIH1cbn07XG5cbiIsImltcG9ydCB7XHJcbiAgZm9yRWFjaFxyXG59IGZyb20gJ21pbi1kYXNoJztcclxuXHJcbmltcG9ydCBDT0xPUiBmcm9tICcuLi8uLi8uLi91dGlsL0NvbG9yVXRpbCc7XHJcblxyXG5cclxudmFyIERFRkFVTFRfQ09MT1IgPSBDT0xPUi5ZRUxMT1c7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2V0Q29sb3JIYW5kbGVyKGNvbW1hbmRTdGFjaykge1xyXG4gIHRoaXMuX2NvbW1hbmRTdGFjayA9IGNvbW1hbmRTdGFjaztcclxufVxyXG5cclxuU2V0Q29sb3JIYW5kbGVyLiRpbmplY3QgPSBbXHJcbiAgJ2NvbW1hbmRTdGFjaydcclxuXTtcclxuXHJcblxyXG5TZXRDb2xvckhhbmRsZXIucHJvdG90eXBlLnBvc3RFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG4gIHZhciBlbGVtZW50cyA9IGNvbnRleHQuZWxlbWVudHMsXHJcbiAgICAgIGNvbG9yID0gY29udGV4dC5jb2xvciB8fCBERUZBVUxUX0NPTE9SO1xyXG5cclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHJcbiAgICBzZWxmLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnZWxlbWVudC51cGRhdGVQcm9wZXJ0aWVzJywge1xyXG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgY29sb3I6IGNvbG9yXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxufTtcclxuIiwiaW1wb3J0IHtcbiAgYWRkIGFzIGNvbGxlY3Rpb25BZGQsXG4gIHJlbW92ZSBhcyBjb2xsZWN0aW9uUmVtb3ZlXG59IGZyb20gJ2RpYWdyYW0tanMvbGliL3V0aWwvQ29sbGVjdGlvbnMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFVwZGF0ZUNhbnZhc1Jvb3RIYW5kbGVyKGNhbnZhcywgbW9kZWxpbmcpIHtcbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xufVxuXG5VcGRhdGVDYW52YXNSb290SGFuZGxlci4kaW5qZWN0ID0gW1xuICAnY2FudmFzJyxcbiAgJ21vZGVsaW5nJ1xuXTtcblxuXG5VcGRhdGVDYW52YXNSb290SGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuXG4gIHZhciBuZXdSb290ID0gY29udGV4dC5uZXdSb290LFxuICAgICAgbmV3Um9vdEJ1c2luZXNzT2JqZWN0ID0gbmV3Um9vdC5idXNpbmVzc09iamVjdCxcbiAgICAgIG9sZFJvb3QgPSBjYW52YXMuZ2V0Um9vdEVsZW1lbnQoKSxcbiAgICAgIG9sZFJvb3RCdXNpbmVzc09iamVjdCA9IG9sZFJvb3QuYnVzaW5lc3NPYmplY3QsXG4gICAgICBwb3N0aXREZWZpbml0aW9ucyA9IG9sZFJvb3RCdXNpbmVzc09iamVjdC4kcGFyZW50LFxuICAgICAgZGlQbGFuZSA9IG9sZFJvb3RCdXNpbmVzc09iamVjdC5kaTtcblxuICAvLyAoMSkgcmVwbGFjZSBwcm9jZXNzIG9sZCA8PiBuZXcgcm9vdFxuICBjYW52YXMuc2V0Um9vdEVsZW1lbnQobmV3Um9vdCwgdHJ1ZSk7XG5cbiAgLy8gKDIpIHVwZGF0ZSByb290IGVsZW1lbnRzXG4gIGNvbGxlY3Rpb25BZGQocG9zdGl0RGVmaW5pdGlvbnMucm9vdEVsZW1lbnRzLCBuZXdSb290QnVzaW5lc3NPYmplY3QpO1xuICBuZXdSb290QnVzaW5lc3NPYmplY3QuJHBhcmVudCA9IHBvc3RpdERlZmluaXRpb25zO1xuXG4gIGNvbGxlY3Rpb25SZW1vdmUocG9zdGl0RGVmaW5pdGlvbnMucm9vdEVsZW1lbnRzLCBvbGRSb290QnVzaW5lc3NPYmplY3QpO1xuICBvbGRSb290QnVzaW5lc3NPYmplY3QuJHBhcmVudCA9IG51bGw7XG5cbiAgLy8gKDMpIHdpcmUgZGlcbiAgb2xkUm9vdEJ1c2luZXNzT2JqZWN0LmRpID0gbnVsbDtcblxuICBkaVBsYW5lLmJvYXJkRWxlbWVudCA9IG5ld1Jvb3RCdXNpbmVzc09iamVjdDtcbiAgbmV3Um9vdEJ1c2luZXNzT2JqZWN0LmRpID0gZGlQbGFuZTtcblxuICBjb250ZXh0Lm9sZFJvb3QgPSBvbGRSb290O1xuXG4gIC8vIFRPRE8obmlra3UpOiByZXR1cm4gY2hhbmdlZCBlbGVtZW50cz9cbiAgLy8gcmV0dXJuIFsgbmV3Um9vdCwgb2xkUm9vdCBdO1xufTtcblxuXG5VcGRhdGVDYW52YXNSb290SGFuZGxlci5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cbiAgdmFyIG5ld1Jvb3QgPSBjb250ZXh0Lm5ld1Jvb3QsXG4gICAgICBuZXdSb290QnVzaW5lc3NPYmplY3QgPSBuZXdSb290LmJ1c2luZXNzT2JqZWN0LFxuICAgICAgb2xkUm9vdCA9IGNvbnRleHQub2xkUm9vdCxcbiAgICAgIG9sZFJvb3RCdXNpbmVzc09iamVjdCA9IG9sZFJvb3QuYnVzaW5lc3NPYmplY3QsXG4gICAgICBwb3N0aXREZWZpbml0aW9ucyA9IG5ld1Jvb3RCdXNpbmVzc09iamVjdC4kcGFyZW50LFxuICAgICAgZGlQbGFuZSA9IG5ld1Jvb3RCdXNpbmVzc09iamVjdC5kaTtcblxuICAvLyAoMSkgcmVwbGFjZSBwcm9jZXNzIG9sZCA8PiBuZXcgcm9vdFxuICBjYW52YXMuc2V0Um9vdEVsZW1lbnQob2xkUm9vdCwgdHJ1ZSk7XG5cbiAgLy8gKDIpIHVwZGF0ZSByb290IGVsZW1lbnRzXG4gIGNvbGxlY3Rpb25SZW1vdmUocG9zdGl0RGVmaW5pdGlvbnMucm9vdEVsZW1lbnRzLCBuZXdSb290QnVzaW5lc3NPYmplY3QpO1xuICBuZXdSb290QnVzaW5lc3NPYmplY3QuJHBhcmVudCA9IG51bGw7XG5cbiAgY29sbGVjdGlvbkFkZChwb3N0aXREZWZpbml0aW9ucy5yb290RWxlbWVudHMsIG9sZFJvb3RCdXNpbmVzc09iamVjdCk7XG4gIG9sZFJvb3RCdXNpbmVzc09iamVjdC4kcGFyZW50ID0gcG9zdGl0RGVmaW5pdGlvbnM7XG5cbiAgLy8gKDMpIHdpcmUgZGlcbiAgbmV3Um9vdEJ1c2luZXNzT2JqZWN0LmRpID0gbnVsbDtcblxuICBkaVBsYW5lLmJvYXJkRWxlbWVudCA9IG9sZFJvb3RCdXNpbmVzc09iamVjdDtcbiAgb2xkUm9vdEJ1c2luZXNzT2JqZWN0LmRpID0gZGlQbGFuZTtcblxuICAvLyBUT0RPKG5pa2t1KTogcmV0dXJuIGNoYW5nZWQgZWxlbWVudHM/XG4gIC8vIHJldHVybiBbIG5ld1Jvb3QsIG9sZFJvb3QgXTtcbn07IiwiaW1wb3J0IHtcbiAgcmVkdWNlLFxuICBrZXlzLFxuICBmb3JFYWNoLFxuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRCdXNpbmVzc09iamVjdFxufSBmcm9tICcuLi8uLi8uLi91dGlsL01vZGVsVXRpbCc7XG5cbnZhciBJRCA9ICdpZCcsXG4gICAgREkgPSAnZGknO1xuXG52YXIgTlVMTF9ESU1FTlNJT05TID0ge1xuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwXG59O1xuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IGltcGxlbWVudHMgYSBwb3N0aXQgZWxlbWVudHMgcHJvcGVydHkgdXBkYXRlLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gc2V0IHNpbXBsZSBwcm9wZXJ0aWVzIG9uIGVsZW1lbnRzIHdpdGhcbiAqIGFuIHVuZGVybHlpbmcgWE1MIGJ1c2luZXNzIG9iamVjdC5cbiAqXG4gKiBVc2UgcmVzcGVjdGl2ZSBkaWFncmFtLWpzIHByb3ZpZGVkIGhhbmRsZXJzIGlmIHlvdSB3b3VsZFxuICogbGlrZSB0byBwZXJmb3JtIGF1dG9tYXRlZCBtb2RlbGluZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVXBkYXRlUHJvcGVydGllc0hhbmRsZXIoXG4gICAgZWxlbWVudFJlZ2lzdHJ5LCBtb2RkbGUsIHRyYW5zbGF0ZSxcbiAgICBtb2RlbGluZywgdGV4dFJlbmRlcmVyKSB7XG5cbiAgdGhpcy5fZWxlbWVudFJlZ2lzdHJ5ID0gZWxlbWVudFJlZ2lzdHJ5O1xuICB0aGlzLl9tb2RkbGUgPSBtb2RkbGU7XG4gIHRoaXMuX3RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbiAgdGhpcy5fdGV4dFJlbmRlcmVyID0gdGV4dFJlbmRlcmVyO1xufVxuXG5VcGRhdGVQcm9wZXJ0aWVzSGFuZGxlci4kaW5qZWN0ID0gW1xuICAnZWxlbWVudFJlZ2lzdHJ5JyxcbiAgJ21vZGRsZScsXG4gICd0cmFuc2xhdGUnLFxuICAnbW9kZWxpbmcnLFxuICAndGV4dFJlbmRlcmVyJ1xuXTtcblxuXG4vLyBhcGkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBib2FyZCBlbGVtZW50IHdpdGggYSBsaXN0IG9mIG5ldyBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGNvbnRleHQuZWxlbWVudCB0aGUgZWxlbWVudCB0byB1cGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0LnByb3BlcnRpZXMgYSBsaXN0IG9mIHByb3BlcnRpZXMgdG8gc2V0IG9uIHRoZSBlbGVtZW50J3NcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVzaW5lc3NPYmplY3QgKHRoZSBYTUwgbW9kZWwgZWxlbWVudClcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59IHRoZSB1cGRhdGVkIGVsZW1lbnRcbiAqL1xuVXBkYXRlUHJvcGVydGllc0hhbmRsZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGVsZW1lbnQgPSBjb250ZXh0LmVsZW1lbnQsXG4gICAgICBjaGFuZ2VkID0gWyBlbGVtZW50IF0sXG4gICAgICB0cmFuc2xhdGUgPSB0aGlzLl90cmFuc2xhdGU7XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zbGF0ZSgnZWxlbWVudCByZXF1aXJlZCcpKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50UmVnaXN0cnkgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnksXG4gICAgICBpZHMgPSB0aGlzLl9tb2RkbGUuaWRzO1xuXG4gIHZhciBidXNpbmVzc09iamVjdCA9IGVsZW1lbnQuYnVzaW5lc3NPYmplY3QsXG4gICAgICBwcm9wZXJ0aWVzID0gdW53cmFwQnVzaW5lc3NPYmplY3RzKGNvbnRleHQucHJvcGVydGllcyksXG4gICAgICBvbGRQcm9wZXJ0aWVzID0gY29udGV4dC5vbGRQcm9wZXJ0aWVzIHx8IGdldFByb3BlcnRpZXMoYnVzaW5lc3NPYmplY3QsIHByb3BlcnRpZXMpO1xuXG4gIGlmIChpc0lkQ2hhbmdlKHByb3BlcnRpZXMsIGJ1c2luZXNzT2JqZWN0KSkge1xuICAgIGlkcy51bmNsYWltKGJ1c2luZXNzT2JqZWN0W0lEXSk7XG5cbiAgICBlbGVtZW50UmVnaXN0cnkudXBkYXRlSWQoZWxlbWVudCwgcHJvcGVydGllc1tJRF0pO1xuXG4gICAgaWRzLmNsYWltKHByb3BlcnRpZXNbSURdLCBidXNpbmVzc09iamVjdCk7XG4gIH1cblxuICAvLyB1cGRhdGUgcHJvcGVydGllc1xuICBzZXRQcm9wZXJ0aWVzKGJ1c2luZXNzT2JqZWN0LCBwcm9wZXJ0aWVzKTtcblxuICAvLyBzdG9yZSBvbGQgdmFsdWVzXG4gIGNvbnRleHQub2xkUHJvcGVydGllcyA9IG9sZFByb3BlcnRpZXM7XG4gIGNvbnRleHQuY2hhbmdlZCA9IGNoYW5nZWQ7XG5cbiAgLy8gaW5kaWNhdGUgY2hhbmdlZCBvbiBvYmplY3RzIGFmZmVjdGVkIGJ5IHRoZSB1cGRhdGVcbiAgcmV0dXJuIGNoYW5nZWQ7XG59O1xuXG5cblVwZGF0ZVByb3BlcnRpZXNIYW5kbGVyLnByb3RvdHlwZS5wb3N0RXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIGVsZW1lbnQgPSBjb250ZXh0LmVsZW1lbnQsXG4gICAgICBsYWJlbCA9IGVsZW1lbnQubGFiZWw7XG5cbiAgdmFyIHRleHQgPSBsYWJlbCAmJiBnZXRCdXNpbmVzc09iamVjdChsYWJlbCkubmFtZTtcblxuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBnZXQgbGF5b3V0ZWQgdGV4dCBib3VuZHMgYW5kIHJlc2l6ZSBleHRlcm5hbFxuICAvLyBleHRlcm5hbCBsYWJlbCBhY2NvcmRpbmdseVxuICB2YXIgbmV3TGFiZWxCb3VuZHMgPSB0aGlzLl90ZXh0UmVuZGVyZXIuZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kcyhsYWJlbCwgdGV4dCk7XG5cbiAgdGhpcy5fbW9kZWxpbmcucmVzaXplU2hhcGUobGFiZWwsIG5ld0xhYmVsQm91bmRzLCBOVUxMX0RJTUVOU0lPTlMpO1xufTtcblxuLyoqXG4gKiBSZXZlcnRzIHRoZSB1cGRhdGUgb24gYSBib2FyZCBlbGVtZW50cyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dFxuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5CYXNlfSB0aGUgdXBkYXRlZCBlbGVtZW50XG4gKi9cblVwZGF0ZVByb3BlcnRpZXNIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGVsZW1lbnQgPSBjb250ZXh0LmVsZW1lbnQsXG4gICAgICBwcm9wZXJ0aWVzID0gY29udGV4dC5wcm9wZXJ0aWVzLFxuICAgICAgb2xkUHJvcGVydGllcyA9IGNvbnRleHQub2xkUHJvcGVydGllcyxcbiAgICAgIGJ1c2luZXNzT2JqZWN0ID0gZWxlbWVudC5idXNpbmVzc09iamVjdCxcbiAgICAgIGVsZW1lbnRSZWdpc3RyeSA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeSxcbiAgICAgIGlkcyA9IHRoaXMuX21vZGRsZS5pZHM7XG5cbiAgLy8gdXBkYXRlIHByb3BlcnRpZXNcbiAgc2V0UHJvcGVydGllcyhidXNpbmVzc09iamVjdCwgb2xkUHJvcGVydGllcyk7XG5cbiAgaWYgKGlzSWRDaGFuZ2UocHJvcGVydGllcywgYnVzaW5lc3NPYmplY3QpKSB7XG4gICAgaWRzLnVuY2xhaW0ocHJvcGVydGllc1tJRF0pO1xuXG4gICAgZWxlbWVudFJlZ2lzdHJ5LnVwZGF0ZUlkKGVsZW1lbnQsIG9sZFByb3BlcnRpZXNbSURdKTtcblxuICAgIGlkcy5jbGFpbShvbGRQcm9wZXJ0aWVzW0lEXSwgYnVzaW5lc3NPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQuY2hhbmdlZDtcbn07XG5cblxuZnVuY3Rpb24gaXNJZENoYW5nZShwcm9wZXJ0aWVzLCBidXNpbmVzc09iamVjdCkge1xuICByZXR1cm4gSUQgaW4gcHJvcGVydGllcyAmJiBwcm9wZXJ0aWVzW0lEXSAhPT0gYnVzaW5lc3NPYmplY3RbSURdO1xufVxuXG5cbmZ1bmN0aW9uIGdldFByb3BlcnRpZXMoYnVzaW5lc3NPYmplY3QsIHByb3BlcnRpZXMpIHtcbiAgdmFyIHByb3BlcnR5TmFtZXMgPSBrZXlzKHByb3BlcnRpZXMpO1xuXG4gIHJldHVybiByZWR1Y2UocHJvcGVydHlOYW1lcywgZnVuY3Rpb24ocmVzdWx0LCBrZXkpIHtcblxuICAgIC8vIGhhbmRsZSBESSBzZXBhcmF0ZWx5XG4gICAgaWYgKGtleSAhPT0gREkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gYnVzaW5lc3NPYmplY3QuZ2V0KGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gZ2V0RGlQcm9wZXJ0aWVzKGJ1c2luZXNzT2JqZWN0LmRpLCBrZXlzKHByb3BlcnRpZXMuZGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG59XG5cblxuZnVuY3Rpb24gZ2V0RGlQcm9wZXJ0aWVzKGRpLCBwcm9wZXJ0eU5hbWVzKSB7XG4gIHJldHVybiByZWR1Y2UocHJvcGVydHlOYW1lcywgZnVuY3Rpb24ocmVzdWx0LCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IGRpLmdldChrZXkpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xufVxuXG5cbmZ1bmN0aW9uIHNldFByb3BlcnRpZXMoYnVzaW5lc3NPYmplY3QsIHByb3BlcnRpZXMpIHtcbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cbiAgICBpZiAoa2V5ICE9PSBESSkge1xuICAgICAgYnVzaW5lc3NPYmplY3Quc2V0KGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIG9ubHkgdXBkYXRlLCBpZiBidXNpbmVzc09iamVjdC5kaSBleGlzdHNcbiAgICAgIGlmIChidXNpbmVzc09iamVjdC5kaSkge1xuICAgICAgICBzZXREaVByb3BlcnRpZXMoYnVzaW5lc3NPYmplY3QuZGksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5cbmZ1bmN0aW9uIHNldERpUHJvcGVydGllcyhkaSwgcHJvcGVydGllcykge1xuICBmb3JFYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICBkaS5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0pO1xufVxuXG5cbnZhciByZWZlcmVuY2VQcm9wZXJ0eU5hbWVzID0gWyAnZGVmYXVsdCcgXTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgd2UgdW53cmFwIHRoZSBhY3R1YWwgYnVzaW5lc3Mgb2JqZWN0XG4gKiBiZWhpbmQgZGlhZ3JhbSBlbGVtZW50IHRoYXQgbWF5IGhhdmUgYmVlblxuICogcGFzc2VkIGFzIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHByb3BlcnRpZXNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHVud3JhcHBlZFByb3BzXG4gKi9cbmZ1bmN0aW9uIHVud3JhcEJ1c2luZXNzT2JqZWN0cyhwcm9wZXJ0aWVzKSB7XG5cbiAgdmFyIHVud3JhcHBlZFByb3BzID0gYXNzaWduKHt9LCBwcm9wZXJ0aWVzKTtcblxuICByZWZlcmVuY2VQcm9wZXJ0eU5hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChuYW1lIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIHVud3JhcHBlZFByb3BzW25hbWVdID0gZ2V0QnVzaW5lc3NPYmplY3QodW53cmFwcGVkUHJvcHNbbmFtZV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHVud3JhcHBlZFByb3BzO1xufSIsImltcG9ydCBCZWhhdmlvck1vZHVsZSBmcm9tICcuL2JlaGF2aW9yJztcbmltcG9ydCBSdWxlc01vZHVsZSBmcm9tICcuLi9ydWxlcyc7XG5pbXBvcnQgRGlPcmRlcmluZ01vZHVsZSBmcm9tICcuLi9kaS1vcmRlcmluZyc7XG5pbXBvcnQgT3JkZXJpbmdNb2R1bGUgZnJvbSAnLi4vb3JkZXJpbmcnO1xuaW1wb3J0IFJlcGxhY2VNb2R1bGUgZnJvbSAnLi4vcmVwbGFjZSc7XG5cbmltcG9ydCBDb21tYW5kTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2NvbW1hbmQnO1xuaW1wb3J0IFRvb2x0aXBzTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3Rvb2x0aXBzJztcbmltcG9ydCBMYWJlbFN1cHBvcnRNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbGFiZWwtc3VwcG9ydCc7XG5pbXBvcnQgQXR0YWNoU3VwcG9ydE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9hdHRhY2gtc3VwcG9ydCc7XG5pbXBvcnQgU2VsZWN0aW9uTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NlbGVjdGlvbic7XG5pbXBvcnQgQ2hhbmdlU3VwcG9ydE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9jaGFuZ2Utc3VwcG9ydCc7XG5pbXBvcnQgU3BhY2VUb29sTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NwYWNlLXRvb2wnO1xuXG5pbXBvcnQgUG9zaXRGYWN0b3J5IGZyb20gJy4vUG9zdGl0RmFjdG9yeSc7XG5pbXBvcnQgUG9zdGl0VXBkYXRlciBmcm9tICcuL1Bvc3RpdFVwZGF0ZXInO1xuaW1wb3J0IEVsZW1lbnRGYWN0b3J5IGZyb20gJy4vRWxlbWVudEZhY3RvcnknO1xuaW1wb3J0IE1vZGVsaW5nIGZyb20gJy4vTW9kZWxpbmcnO1xuaW1wb3J0IExheW91dGVyIGZyb20gJ2RpYWdyYW0tanMvbGliL2xheW91dC9CYXNlTGF5b3V0ZXInO1xuaW1wb3J0IENyb3BwaW5nQ29ubmVjdGlvbkRvY2tpbmcgZnJvbSAnZGlhZ3JhbS1qcy9saWIvbGF5b3V0L0Nyb3BwaW5nQ29ubmVjdGlvbkRvY2tpbmcnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFtcbiAgICAnbW9kZWxpbmcnLFxuICAgICdwb3N0aXRVcGRhdGVyJ1xuICBdLFxuICBfX2RlcGVuZHNfXzogW1xuICAgIEJlaGF2aW9yTW9kdWxlLFxuICAgIFJ1bGVzTW9kdWxlLFxuICAgIERpT3JkZXJpbmdNb2R1bGUsXG4gICAgT3JkZXJpbmdNb2R1bGUsXG4gICAgUmVwbGFjZU1vZHVsZSxcbiAgICBDb21tYW5kTW9kdWxlLFxuICAgIFRvb2x0aXBzTW9kdWxlLFxuICAgIExhYmVsU3VwcG9ydE1vZHVsZSxcbiAgICBBdHRhY2hTdXBwb3J0TW9kdWxlLFxuICAgIFNlbGVjdGlvbk1vZHVsZSxcbiAgICBDaGFuZ2VTdXBwb3J0TW9kdWxlLFxuICAgIFNwYWNlVG9vbE1vZHVsZVxuICBdLFxuICBwb3N0aXRGYWN0b3J5OiBbICd0eXBlJywgUG9zaXRGYWN0b3J5IF0sXG4gIHBvc3RpdFVwZGF0ZXI6IFsgJ3R5cGUnLCBQb3N0aXRVcGRhdGVyIF0sXG4gIGVsZW1lbnRGYWN0b3J5OiBbICd0eXBlJywgRWxlbWVudEZhY3RvcnkgXSxcbiAgbW9kZWxpbmc6IFsgJ3R5cGUnLCBNb2RlbGluZyBdLFxuICBsYXlvdXRlcjogWyAndHlwZScsIExheW91dGVyIF0sXG4gIGNvbm5lY3Rpb25Eb2NraW5nOiBbICd0eXBlJywgQ3JvcHBpbmdDb25uZWN0aW9uRG9ja2luZyBdXG59OyIsImltcG9ydCB7XG4gIHNvbWVcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uLy4uLy4uL3V0aWwvTW9kZWxVdGlsJztcblxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGVsZW1lbnQgaGFzIGFueSBvZiB0aGUgZ2l2ZW4gdHlwZXMuXG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSB0eXBlc1xuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FueShlbGVtZW50LCB0eXBlcykge1xuICByZXR1cm4gc29tZSh0eXBlcywgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBpcyhlbGVtZW50LCB0KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBvZiB0aGUgZWxlbWVudCB3aXRoIGFueSBvZiB0aGUgZ2l2ZW4gdHlwZXMuXG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXk8U3RyaW5nPn0gYW55VHlwZVxuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5CYXNlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50KGVsZW1lbnQsIGFueVR5cGUpIHtcblxuICBpZiAodHlwZW9mIGFueVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYW55VHlwZSA9IFsgYW55VHlwZSBdO1xuICB9XG5cbiAgd2hpbGUgKChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQpKSB7XG4gICAgaWYgKGlzQW55KGVsZW1lbnQsIGFueVR5cGUpKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgT3JkZXJpbmdQcm92aWRlciBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vcmRlcmluZy9PcmRlcmluZ1Byb3ZpZGVyJztcblxuaW1wb3J0IHtcbiAgaXNBbnlcbn0gZnJvbSAnLi4vbW9kZWxpbmcvdXRpbC9Nb2RlbGluZ1V0aWwnO1xuXG5pbXBvcnQge1xuICBmaW5kSW5kZXgsXG4gIGZpbmRcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbi8qKlxuICogYSBzaW1wbGUgb3JkZXJpbmcgcHJvdmlkZXIgdGhhdCBtYWtlcyBzdXJlOlxuICpcbiAqICgwKSBsYWJlbHMgYW5kIGdyb3VwcyBhcmUgcmVuZGVyZWQgYWx3YXlzIG9uIHRvcFxuICogKDEpIGVsZW1lbnRzIGFyZSBvcmRlcmVkIGJ5IGEge2xldmVsfSBwcm9wZXJ0eVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQb3N0aXRPcmRlcmluZ1Byb3ZpZGVyKGV2ZW50QnVzLCBjYW52YXMsIHRyYW5zbGF0ZSkge1xuXG4gIE9yZGVyaW5nUHJvdmlkZXIuY2FsbCh0aGlzLCBldmVudEJ1cyk7XG5cbiAgdmFyIG9yZGVycyA9IFtcbiAgICB7IHR5cGU6ICdwb3N0aXQ6Qm9hcmRFbGVtZW50Jywgb3JkZXI6IHsgbGV2ZWw6IDUgfSB9XG4gIF07XG5cbiAgZnVuY3Rpb24gY29tcHV0ZU9yZGVyKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5sYWJlbFRhcmdldCkge1xuICAgICAgcmV0dXJuIHsgbGV2ZWw6IDEwIH07XG4gICAgfVxuXG4gICAgdmFyIGVudHJ5ID0gZmluZChvcmRlcnMsIGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBpc0FueShlbGVtZW50LCBbIG8udHlwZSBdKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS5vcmRlciB8fCB7IGxldmVsOiAxIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPcmRlcihlbGVtZW50KSB7XG5cbiAgICB2YXIgb3JkZXIgPSBlbGVtZW50Lm9yZGVyO1xuXG4gICAgaWYgKCFvcmRlcikge1xuICAgICAgZWxlbWVudC5vcmRlciA9IG9yZGVyID0gY29tcHV0ZU9yZGVyKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBvcmRlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRBY3R1YWxQYXJlbnQoZWxlbWVudCwgbmV3UGFyZW50LCBjb250YWluZXJzKSB7XG5cbiAgICB2YXIgYWN0dWFsUGFyZW50ID0gbmV3UGFyZW50O1xuXG4gICAgd2hpbGUgKGFjdHVhbFBhcmVudCkge1xuXG4gICAgICBpZiAoaXNBbnkoYWN0dWFsUGFyZW50LCBjb250YWluZXJzKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYWN0dWFsUGFyZW50ID0gYWN0dWFsUGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoIWFjdHVhbFBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zbGF0ZSgnbm8gcGFyZW50IGZvciB7ZWxlbWVudH0gaW4ge3BhcmVudH0nLCB7XG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQuaWQsXG4gICAgICAgIHBhcmVudDogbmV3UGFyZW50LmlkXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdHVhbFBhcmVudDtcbiAgfVxuXG4gIHRoaXMuZ2V0T3JkZXJpbmcgPSBmdW5jdGlvbihlbGVtZW50LCBuZXdQYXJlbnQpIHtcblxuICAgIC8vIHJlbmRlciBsYWJlbHMgYWx3YXlzIG9uIHRvcFxuICAgIGlmIChlbGVtZW50LmxhYmVsVGFyZ2V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IGNhbnZhcy5nZXRSb290RWxlbWVudCgpLFxuICAgICAgICBpbmRleDogLTFcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRPcmRlciA9IGdldE9yZGVyKGVsZW1lbnQpO1xuXG5cbiAgICBpZiAoZWxlbWVudE9yZGVyLmNvbnRhaW5lcnMpIHtcbiAgICAgIG5ld1BhcmVudCA9IGZpbmRBY3R1YWxQYXJlbnQoZWxlbWVudCwgbmV3UGFyZW50LCBlbGVtZW50T3JkZXIuY29udGFpbmVycyk7XG4gICAgfVxuXG5cbiAgICB2YXIgY3VycmVudEluZGV4ID0gbmV3UGFyZW50LmNoaWxkcmVuLmluZGV4T2YoZWxlbWVudCk7XG5cbiAgICB2YXIgaW5zZXJ0SW5kZXggPSBmaW5kSW5kZXgobmV3UGFyZW50LmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuXG4gICAgICAvLyBkbyBub3QgY29tcGFyZSB3aXRoIGxhYmVscywgdGhleSBhcmUgY3JlYXRlZFxuICAgICAgLy8gaW4gdGhlIHdyb25nIG9yZGVyIChyaWdodCBhZnRlciBlbGVtZW50cykgZHVyaW5nIGltcG9ydCBhbmRcbiAgICAgIC8vIG1lc3MgdXAgdGhlIHBvc2l0aW9uaW5nLlxuICAgICAgaWYgKCFlbGVtZW50LmxhYmVsVGFyZ2V0ICYmIGNoaWxkLmxhYmVsVGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRPcmRlci5sZXZlbCA8IGdldE9yZGVyKGNoaWxkKS5sZXZlbDtcbiAgICB9KTtcblxuXG4gICAgLy8gaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBpbiB0aGUgY2hpbGQgbGlzdCBhdFxuICAgIC8vIGEgc21hbGxlciBpbmRleCwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGluc2VydCBpbmRleC5cbiAgICAvLyB0aGlzIHRha2VzIGludG8gYWNjb3VudCB0aGF0IHRoZSBlbGVtZW50IGlzIGJlaW5nIHJlbW92ZWRcbiAgICAvLyBiZWZvcmUgYmVpbmcgcmUtaW5zZXJ0ZWRcbiAgICBpZiAoaW5zZXJ0SW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoY3VycmVudEluZGV4ICE9PSAtMSAmJiBjdXJyZW50SW5kZXggPCBpbnNlcnRJbmRleCkge1xuICAgICAgICBpbnNlcnRJbmRleCAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpbmRleDogaW5zZXJ0SW5kZXgsXG4gICAgICBwYXJlbnQ6IG5ld1BhcmVudFxuICAgIH07XG4gIH07XG59XG5cblBvc3RpdE9yZGVyaW5nUHJvdmlkZXIuJGluamVjdCA9IFsgJ2V2ZW50QnVzJywgJ2NhbnZhcycsICd0cmFuc2xhdGUnIF07XG5cbmluaGVyaXRzKFBvc3RpdE9yZGVyaW5nUHJvdmlkZXIsIE9yZGVyaW5nUHJvdmlkZXIpOyIsImltcG9ydCB0cmFuc2xhdGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvaTE4bi90cmFuc2xhdGUnO1xuXG5pbXBvcnQgUG9zdGl0T3JkZXJpbmdQcm92aWRlciBmcm9tICcuL1Bvc3RpdE9yZGVyaW5nUHJvdmlkZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgdHJhbnNsYXRlXG4gIF0sXG4gIF9faW5pdF9fOiBbICdwb3N0aXRPcmRlcmluZ1Byb3ZpZGVyJyBdLFxuICBwb3N0aXRPcmRlcmluZ1Byb3ZpZGVyOiBbICd0eXBlJywgUG9zdGl0T3JkZXJpbmdQcm92aWRlciBdXG59OyIsImltcG9ydCB7XG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCBDT0xPUlMgZnJvbSAnLi4vLi4vdXRpbC9Db2xvclV0aWwnO1xuXG5cbi8qKlxuICogQSBwYWxldHRlIHByb3ZpZGVyIGZvciBwb3N0aXQgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhbGV0dGVQcm92aWRlcihcbiAgICBwYWxldHRlLCBjcmVhdGUsIGVsZW1lbnRGYWN0b3J5LFxuICAgIHNwYWNlVG9vbCwgbGFzc29Ub29sLCBoYW5kVG9vbCwgdHJhbnNsYXRlKSB7XG5cbiAgdGhpcy5fcGFsZXR0ZSA9IHBhbGV0dGU7XG4gIHRoaXMuX2NyZWF0ZSA9IGNyZWF0ZTtcbiAgdGhpcy5fZWxlbWVudEZhY3RvcnkgPSBlbGVtZW50RmFjdG9yeTtcbiAgdGhpcy5fc3BhY2VUb29sID0gc3BhY2VUb29sO1xuICB0aGlzLl9sYXNzb1Rvb2wgPSBsYXNzb1Rvb2w7XG4gIHRoaXMuX2hhbmRUb29sID0gaGFuZFRvb2w7XG4gIHRoaXMuX3RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcblxuICBwYWxldHRlLnJlZ2lzdGVyUHJvdmlkZXIodGhpcyk7XG59XG5cblBhbGV0dGVQcm92aWRlci4kaW5qZWN0ID0gW1xuICAncGFsZXR0ZScsXG4gICdjcmVhdGUnLFxuICAnZWxlbWVudEZhY3RvcnknLFxuICAnc3BhY2VUb29sJyxcbiAgJ2xhc3NvVG9vbCcsXG4gICdoYW5kVG9vbCcsXG4gICd0cmFuc2xhdGUnXG5dO1xuXG5cblBhbGV0dGVQcm92aWRlci5wcm90b3R5cGUuZ2V0UGFsZXR0ZUVudHJpZXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgdmFyIGFjdGlvbnMgPSB7fSxcbiAgICAgIGNyZWF0ZSA9IHRoaXMuX2NyZWF0ZSxcbiAgICAgIGVsZW1lbnRGYWN0b3J5ID0gdGhpcy5fZWxlbWVudEZhY3RvcnksXG4gICAgICBzcGFjZVRvb2wgPSB0aGlzLl9zcGFjZVRvb2wsXG4gICAgICBsYXNzb1Rvb2wgPSB0aGlzLl9sYXNzb1Rvb2wsXG4gICAgICBoYW5kVG9vbCA9IHRoaXMuX2hhbmRUb29sLFxuICAgICAgdHJhbnNsYXRlID0gdGhpcy5fdHJhbnNsYXRlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbih0eXBlLCBncm91cCwgY2xhc3NOYW1lLCB0aXRsZSwgb3B0aW9ucykge1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgIHZhciBzaGFwZSA9IGVsZW1lbnRGYWN0b3J5LmNyZWF0ZVNoYXBlKGFzc2lnbih7IHR5cGU6IHR5cGUgfSwgb3B0aW9ucykpO1xuICAgICAgY3JlYXRlLnN0YXJ0KGV2ZW50LCBzaGFwZSk7XG4gICAgfVxuXG4gICAgdmFyIHNob3J0VHlwZSA9IHR5cGUucmVwbGFjZSgvXnBvc3RpdDovLCAnJyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ3JvdXA6IGdyb3VwLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICB0aXRsZTogdGl0bGUgfHwgdHJhbnNsYXRlKCdDcmVhdGUge3R5cGV9JywgeyB0eXBlOiBzaG9ydFR5cGUgfSksXG4gICAgICBhY3Rpb246IHtcbiAgICAgICAgZHJhZ3N0YXJ0OiBjcmVhdGVMaXN0ZW5lcixcbiAgICAgICAgY2xpY2s6IGNyZWF0ZUxpc3RlbmVyXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUltYWdlKGV2ZW50KSB7XG4gICAgdmFyIHNoYXBlID0gZWxlbWVudEZhY3RvcnkuY3JlYXRlU2hhcGUoe1xuICAgICAgdHlwZTogJ3Bvc3RpdDpJbWFnZSdcbiAgICB9KTtcblxuICAgIGNyZWF0ZS5zdGFydChldmVudCwgc2hhcGUsIHtcbiAgICAgIGhpbnRzOiB7IHNlbGVjdEltYWdlOiB0cnVlIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzc2lnbihhY3Rpb25zLCB7XG4gICAgJ2hhbmQtdG9vbCc6IHtcbiAgICAgIGdyb3VwOiAndG9vbHMnLFxuICAgICAgY2xhc3NOYW1lOiAnYnBtbi1pY29uLWhhbmQtdG9vbCcsXG4gICAgICB0aXRsZTogdHJhbnNsYXRlKCdBY3RpdmF0ZSB0aGUgaGFuZCB0b29sJyksXG4gICAgICBhY3Rpb246IHtcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgaGFuZFRvb2wuYWN0aXZhdGVIYW5kKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2xhc3NvLXRvb2wnOiB7XG4gICAgICBncm91cDogJ3Rvb2xzJyxcbiAgICAgIGNsYXNzTmFtZTogJ2JwbW4taWNvbi1sYXNzby10b29sJyxcbiAgICAgIHRpdGxlOiB0cmFuc2xhdGUoJ0FjdGl2YXRlIHRoZSBsYXNzbyB0b29sJyksXG4gICAgICBhY3Rpb246IHtcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgbGFzc29Ub29sLmFjdGl2YXRlU2VsZWN0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3NwYWNlLXRvb2wnOiB7XG4gICAgICBncm91cDogJ3Rvb2xzJyxcbiAgICAgIGNsYXNzTmFtZTogJ2JwbW4taWNvbi1zcGFjZS10b29sJyxcbiAgICAgIHRpdGxlOiB0cmFuc2xhdGUoJ0FjdGl2YXRlIHRoZSBjcmVhdGUvcmVtb3ZlIHNwYWNlIHRvb2wnKSxcbiAgICAgIGFjdGlvbjoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICBzcGFjZVRvb2wuYWN0aXZhdGVTZWxlY3Rpb24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAndG9vbC1zZXBhcmF0b3InOiB7XG4gICAgICBncm91cDogJ3Rvb2xzJyxcbiAgICAgIHNlcGFyYXRvcjogdHJ1ZVxuICAgIH0sXG4gICAgJ2NyZWF0ZS5zcXVhcmUtcG9zdGl0JzogY3JlYXRlQWN0aW9uKFxuICAgICAgJ3Bvc3RpdDpTcXVhcmVQb3N0aXQnLCAncG9zdGl0cycsICdwanMtcG9zdGl0LXNxdWFyZScsXG4gICAgICB0cmFuc2xhdGUoJ0NyZWF0ZSBTcXVhcmUgUG9zdGl0JyksIHsgY29sb3I6IENPTE9SUy5ZRUxMT1cgfVxuICAgICksXG4gICAgJ2NyZWF0ZS5jaXJjbGUtcG9zdGl0JzogY3JlYXRlQWN0aW9uKFxuICAgICAgJ3Bvc3RpdDpDaXJjbGVQb3N0aXQnLCAncG9zdGl0cycsICdwanMtcG9zdGl0LWNpcmNsZScsXG4gICAgICB0cmFuc2xhdGUoJ0NyZWF0ZSBDaXJjbGUgUG9zdGl0JyksIHsgY29sb3I6IENPTE9SUy5QSU5LIH1cbiAgICApLFxuICAgICdwb3N0aXQtc2VwYXJhdG9yJzoge1xuICAgICAgZ3JvdXA6ICdwb3N0aXRzJyxcbiAgICAgIHNlcGFyYXRvcjogdHJ1ZVxuICAgIH0sXG4gICAgJ2NyZWF0ZS5pbWFnZSc6IHtcbiAgICAgIGdyb3VwOiAnYXJ0aWZhY3QnLFxuICAgICAgY2xhc3NOYW1lOiAncGpzLWltYWdlJyxcbiAgICAgIHRpdGxlOiB0cmFuc2xhdGUoJ0NyZWF0ZSBJbWFnZScpLFxuICAgICAgYWN0aW9uOiB7XG4gICAgICAgIGNsaWNrOiBjcmVhdGVJbWFnZSxcbiAgICAgICAgZHJhZ3N0YXJ0OiBjcmVhdGVJbWFnZVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2NyZWF0ZS50ZXh0LWJveCc6IGNyZWF0ZUFjdGlvbihcbiAgICAgICdwb3N0aXQ6VGV4dEJveCcsICdhcnRpZmFjdCcsICdwanMtdGV4dC1ib3gnLFxuICAgICAgdHJhbnNsYXRlKCdDcmVhdGUgVGV4dCcpXG4gICAgKSxcbiAgICAnY3JlYXRlLmdyb3VwJzogY3JlYXRlQWN0aW9uKFxuICAgICAgJ3Bvc3RpdDpHcm91cCcsICdhcnRpZmFjdCcsICdwanMtZ3JvdXAnLFxuICAgICAgdHJhbnNsYXRlKCdDcmVhdGUgR3JvdXAnKVxuICAgIClcbiAgfSk7XG5cbiAgcmV0dXJuIGFjdGlvbnM7XG59O1xuIiwiaW1wb3J0IFBhbGV0dGVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcGFsZXR0ZSc7XG5pbXBvcnQgQ3JlYXRlTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NyZWF0ZSc7XG5pbXBvcnQgU3BhY2VUb29sTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NwYWNlLXRvb2wnO1xuaW1wb3J0IExhc3NvVG9vbE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9sYXNzby10b29sJztcbmltcG9ydCBIYW5kVG9vbE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9oYW5kLXRvb2wnO1xuaW1wb3J0IHRyYW5zbGF0ZSBmcm9tICdkaWFncmFtLWpzL2xpYi9pMThuL3RyYW5zbGF0ZSc7XG5cbmltcG9ydCBQYWxldHRlUHJvdmlkZXIgZnJvbSAnLi9QYWxldHRlUHJvdmlkZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgUGFsZXR0ZU1vZHVsZSxcbiAgICBDcmVhdGVNb2R1bGUsXG4gICAgU3BhY2VUb29sTW9kdWxlLFxuICAgIExhc3NvVG9vbE1vZHVsZSxcbiAgICBIYW5kVG9vbE1vZHVsZSxcbiAgICB0cmFuc2xhdGVcbiAgXSxcbiAgX19pbml0X186IFsgJ3BhbGV0dGVQcm92aWRlcicgXSxcbiAgcGFsZXR0ZVByb3ZpZGVyOiBbICd0eXBlJywgUGFsZXR0ZVByb3ZpZGVyIF1cbn07XG4iLCJpbXBvcnQge1xuICBmb3JFYWNoXG59IGZyb20gJ21pbi1kYXNoJztcblxuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGlzIGFuIGVsZW1lbnQgYWdub3N0aWMgcmVwbGFjZSBtZW51IHByb3ZpZGVyIGZvciB0aGUgcG9wdXAgbWVudS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmVwbGFjZU1lbnVQcm92aWRlcihcbiAgICBwb3B1cE1lbnUsIG1vZGVsaW5nLCBtb2RkbGUsXG4gICAgcG9zdGl0UmVwbGFjZSwgcnVsZXMsIHRyYW5zbGF0ZSkge1xuXG4gIHRoaXMuX3BvcHVwTWVudSA9IHBvcHVwTWVudTtcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbiAgdGhpcy5fbW9kZGxlID0gbW9kZGxlO1xuICB0aGlzLl9wb3N0aXRSZXBsYWNlID0gcG9zdGl0UmVwbGFjZTtcbiAgdGhpcy5fcnVsZXMgPSBydWxlcztcbiAgdGhpcy5fdHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuXG4gIHRoaXMucmVnaXN0ZXIoKTtcbn1cblxuUmVwbGFjZU1lbnVQcm92aWRlci4kaW5qZWN0ID0gW1xuICAncG9wdXBNZW51JyxcbiAgJ21vZGVsaW5nJyxcbiAgJ21vZGRsZScsXG4gICdwb3N0aXRSZXBsYWNlJyxcbiAgJ3J1bGVzJyxcbiAgJ3RyYW5zbGF0ZSdcbl07XG5cblxuLyoqXG4gKiBSZWdpc3RlciByZXBsYWNlIG1lbnUgcHJvdmlkZXIgaW4gdGhlIHBvcHVwIG1lbnVcbiAqL1xuUmVwbGFjZU1lbnVQcm92aWRlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcG9wdXBNZW51LnJlZ2lzdGVyUHJvdmlkZXIoJ3Bvc3RpdC1yZXBsYWNlJywgdGhpcyk7XG59O1xuXG5cbi8qKlxuICogR2V0IGFsbCBlbnRyaWVzIGZyb20gcmVwbGFjZU9wdGlvbnMgZm9yIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBhcHBseSBmaWx0ZXJzXG4gKiBvbiB0aGVtLiBHZXQgZm9yIGV4YW1wbGUgb25seSBlbGVtZW50cywgd2hpY2ggYXJlIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IG9uZS5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gYSBsaXN0IG9mIG1lbnUgZW50cnkgaXRlbXNcbiAqL1xuUmVwbGFjZU1lbnVQcm92aWRlci5wcm90b3R5cGUuZ2V0RW50cmllcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICB2YXIgcnVsZXMgPSB0aGlzLl9ydWxlcztcblxuICB2YXIgZW50cmllcyA9IFtdO1xuXG4gIGlmICghcnVsZXMuYWxsb3dlZCgnc2hhcGUucmVwbGFjZScsIHsgZWxlbWVudDogZWxlbWVudCB9KSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBlbnRyaWVzO1xufTtcblxuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgaGVhZGVyIGl0ZW1zIGZvciB0aGUgZ2l2ZW4gZWxlbWVudC4gVGhpcyBpbmNsdWRlcyBidXR0b25zXG4gKiBmb3IgbXVsdGkgaW5zdGFuY2UgbWFya2VycyBhbmQgZm9yIHRoZSBhZCBob2MgbWFya2VyLlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fSBhIGxpc3Qgb2YgbWVudSBlbnRyeSBpdGVtc1xuICovXG5SZXBsYWNlTWVudVByb3ZpZGVyLnByb3RvdHlwZS5nZXRIZWFkZXJFbnRyaWVzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gIHZhciBoZWFkZXJFbnRyaWVzID0gW107XG5cbiAgcmV0dXJuIGhlYWRlckVudHJpZXM7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBtZW51IGVudHJ5IG9iamVjdHMgZm9yIGEgZ2l2ZW4gZWxlbWVudCBhbmQgZmlsdGVycyB0aGUgcmVwbGFjZU9wdGlvbnNcbiAqIGFjY29yZGluZyB0byBhIGZpbHRlciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHBhcmFtICB7T2JqZWN0fSByZXBsYWNlT3B0aW9uc1xuICpcbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IGEgbGlzdCBvZiBtZW51IGl0ZW1zXG4gKi9cblJlcGxhY2VNZW51UHJvdmlkZXIucHJvdG90eXBlLl9jcmVhdGVFbnRyaWVzID0gZnVuY3Rpb24oZWxlbWVudCwgcmVwbGFjZU9wdGlvbnMpIHtcbiAgdmFyIG1lbnVFbnRyaWVzID0gW107XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZvckVhY2gocmVwbGFjZU9wdGlvbnMsIGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcbiAgICB2YXIgZW50cnkgPSBzZWxmLl9jcmVhdGVNZW51RW50cnkoZGVmaW5pdGlvbiwgZWxlbWVudCk7XG5cbiAgICBtZW51RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG1lbnVFbnRyaWVzO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBzaW5nbGUgbWVudSBlbnRyeSBpdGVtLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gZGVmaW5pdGlvbiBhIHNpbmdsZSByZXBsYWNlIG9wdGlvbnMgZGVmaW5pdGlvbiBvYmplY3RcbiAqIEBwYXJhbSAge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2FjdGlvbl0gYW4gYWN0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGdldHMgY2FsbGVkIHdoZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbWVudSBlbnRyeSBpcyBiZWluZyB0cmlnZ2VyZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBtZW51IGVudHJ5IGl0ZW1cbiAqL1xuUmVwbGFjZU1lbnVQcm92aWRlci5wcm90b3R5cGUuX2NyZWF0ZU1lbnVFbnRyeSA9IGZ1bmN0aW9uKGRlZmluaXRpb24sIGVsZW1lbnQsIGFjdGlvbikge1xuICB2YXIgdHJhbnNsYXRlID0gdGhpcy5fdHJhbnNsYXRlO1xuICB2YXIgcmVwbGFjZUVsZW1lbnQgPSB0aGlzLl9wb3N0aXRSZXBsYWNlLnJlcGxhY2VFbGVtZW50O1xuXG4gIHZhciByZXBsYWNlQWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VFbGVtZW50KGVsZW1lbnQsIGRlZmluaXRpb24udGFyZ2V0KTtcbiAgfTtcblxuICBhY3Rpb24gPSBhY3Rpb24gfHwgcmVwbGFjZUFjdGlvbjtcblxuICB2YXIgbWVudUVudHJ5ID0ge1xuICAgIGxhYmVsOiB0cmFuc2xhdGUoZGVmaW5pdGlvbi5sYWJlbCksXG4gICAgY2xhc3NOYW1lOiBkZWZpbml0aW9uLmNsYXNzTmFtZSxcbiAgICBpZDogZGVmaW5pdGlvbi5hY3Rpb25OYW1lLFxuICAgIGFjdGlvbjogYWN0aW9uXG4gIH07XG5cbiAgcmV0dXJuIG1lbnVFbnRyeTtcbn07XG4iLCJpbXBvcnQgUG9wdXBNZW51TW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3BvcHVwLW1lbnUnO1xuaW1wb3J0IFJlcGxhY2VNb2R1bGUgZnJvbSAnLi4vcmVwbGFjZSc7XG5cbmltcG9ydCBSZXBsYWNlTWVudVByb3ZpZGVyIGZyb20gJy4vUmVwbGFjZU1lbnVQcm92aWRlcic7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIFBvcHVwTWVudU1vZHVsZSxcbiAgICBSZXBsYWNlTW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbICdyZXBsYWNlTWVudVByb3ZpZGVyJyBdLFxuICByZXBsYWNlTWVudVByb3ZpZGVyOiBbICd0eXBlJywgUmVwbGFjZU1lbnVQcm92aWRlciBdXG59OyIsImltcG9ydCBDb21tYW5kSW50ZXJjZXB0b3IgZnJvbSAnZGlhZ3JhbS1qcy9saWIvY29tbWFuZC9Db21tYW5kSW50ZXJjZXB0b3InO1xuXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgY3NzRXNjYXBlIGZyb20gJ2Nzcy5lc2NhcGUnO1xuXG5pbXBvcnQge1xuICBhc3NpZ24sXG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBxdWVyeSBhcyBkb21RdWVyeVxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgYXR0ciBhcyBzdmdBdHRyXG59IGZyb20gJ3Rpbnktc3ZnJztcblxudmFyIExPV19QUklPUklUWSA9IDI1MDtcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQb3N0aXRSZXBsYWNlUHJldmlldyhcbiAgICBldmVudEJ1cywgZWxlbWVudFJlZ2lzdHJ5LCBlbGVtZW50RmFjdG9yeSxcbiAgICBjYW52YXMsIHByZXZpZXdTdXBwb3J0KSB7XG5cbiAgQ29tbWFuZEludGVyY2VwdG9yLmNhbGwodGhpcywgZXZlbnRCdXMpO1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSB2aXN1YWxzIG9mIGFsbCBlbGVtZW50cyBpbiB0aGUgY29udGV4dCB3aGljaCBjYW4gYmUgcmVwbGFjZWRcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlVmlzdWFsKGNvbnRleHQpIHtcblxuICAgIHZhciByZXBsYWNlbWVudHMgPSBjb250ZXh0LmNhbkV4ZWN1dGUucmVwbGFjZW1lbnRzO1xuXG4gICAgZm9yRWFjaChyZXBsYWNlbWVudHMsIGZ1bmN0aW9uKHJlcGxhY2VtZW50KSB7XG5cbiAgICAgIHZhciBpZCA9IHJlcGxhY2VtZW50Lm9sZEVsZW1lbnRJZDtcblxuICAgICAgdmFyIG5ld0VsZW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IHJlcGxhY2VtZW50Lm5ld0VsZW1lbnRUeXBlXG4gICAgICB9O1xuXG4gICAgICAvLyBpZiB0aGUgdmlzdWFsIG9mIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgcmVwbGFjZWRcbiAgICAgIGlmIChjb250ZXh0LnZpc3VhbFJlcGxhY2VtZW50c1tpZF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRSZWdpc3RyeS5nZXQoaWQpO1xuXG4gICAgICBhc3NpZ24obmV3RWxlbWVudCwgeyB4OiBlbGVtZW50LngsIHk6IGVsZW1lbnQueSB9KTtcblxuICAgICAgLy8gY3JlYXRlIGEgdGVtcG9yYXJ5IHNoYXBlXG4gICAgICB2YXIgdGVtcFNoYXBlID0gZWxlbWVudEZhY3RvcnkuY3JlYXRlU2hhcGUobmV3RWxlbWVudCk7XG5cbiAgICAgIGNhbnZhcy5hZGRTaGFwZSh0ZW1wU2hhcGUsIGVsZW1lbnQucGFyZW50KTtcblxuICAgICAgLy8gc2VsZWN0IHRoZSBvcmlnaW5hbCBTVkcgZWxlbWVudCByZWxhdGVkIHRvIHRoZSBlbGVtZW50IGFuZCBoaWRlIGl0XG4gICAgICB2YXIgZ2Z4ID0gZG9tUXVlcnkoJ1tkYXRhLWVsZW1lbnQtaWQ9XCInICsgY3NzRXNjYXBlKGVsZW1lbnQuaWQpICsgJ1wiXScsIGNvbnRleHQuZHJhZ0dyb3VwKTtcblxuICAgICAgaWYgKGdmeCkge1xuICAgICAgICBzdmdBdHRyKGdmeCwgeyBkaXNwbGF5OiAnbm9uZScgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNsb25lIHRoZSBnZnggb2YgdGhlIHRlbXBvcmFyeSBzaGFwZSBhbmQgYWRkIGl0IHRvIHRoZSBkcmFnIGdyb3VwXG4gICAgICB2YXIgZHJhZ2dlciA9IHByZXZpZXdTdXBwb3J0LmFkZERyYWdnZXIodGVtcFNoYXBlLCBjb250ZXh0LmRyYWdHcm91cCk7XG5cbiAgICAgIGNvbnRleHQudmlzdWFsUmVwbGFjZW1lbnRzW2lkXSA9IGRyYWdnZXI7XG5cbiAgICAgIGNhbnZhcy5yZW1vdmVTaGFwZSh0ZW1wU2hhcGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHZpc3VhbHMgb2YgdGhlIHByZXZpb3VzbHkgcmVwbGFjZWQgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBmdW5jdGlvbiByZXN0b3JlVmlzdWFsKGNvbnRleHQpIHtcblxuICAgIHZhciB2aXN1YWxSZXBsYWNlbWVudHMgPSBjb250ZXh0LnZpc3VhbFJlcGxhY2VtZW50cztcblxuICAgIGZvckVhY2godmlzdWFsUmVwbGFjZW1lbnRzLCBmdW5jdGlvbihkcmFnZ2VyLCBpZCkge1xuXG4gICAgICB2YXIgb3JpZ2luYWxHZnggPSBkb21RdWVyeSgnW2RhdGEtZWxlbWVudC1pZD1cIicgKyBjc3NFc2NhcGUoaWQpICsgJ1wiXScsIGNvbnRleHQuZHJhZ0dyb3VwKTtcblxuICAgICAgaWYgKG9yaWdpbmFsR2Z4KSB7XG4gICAgICAgIHN2Z0F0dHIob3JpZ2luYWxHZngsIHsgZGlzcGxheTogJ2lubGluZScgfSk7XG4gICAgICB9XG5cbiAgICAgIGRyYWdnZXIucmVtb3ZlKCk7XG5cbiAgICAgIGlmICh2aXN1YWxSZXBsYWNlbWVudHNbaWRdKSB7XG4gICAgICAgIGRlbGV0ZSB2aXN1YWxSZXBsYWNlbWVudHNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZXZlbnRCdXMub24oJ3NoYXBlLm1vdmUubW92ZScsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgY2FuRXhlY3V0ZSA9IGNvbnRleHQuY2FuRXhlY3V0ZTtcblxuICAgIGlmICghY29udGV4dC52aXN1YWxSZXBsYWNlbWVudHMpIHtcbiAgICAgIGNvbnRleHQudmlzdWFsUmVwbGFjZW1lbnRzID0ge307XG4gICAgfVxuXG4gICAgaWYgKGNhbkV4ZWN1dGUgJiYgY2FuRXhlY3V0ZS5yZXBsYWNlbWVudHMpIHtcbiAgICAgIHJlcGxhY2VWaXN1YWwoY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVWaXN1YWwoY29udGV4dCk7XG4gICAgfVxuICB9KTtcbn1cblxuUG9zdGl0UmVwbGFjZVByZXZpZXcuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2VsZW1lbnRSZWdpc3RyeScsXG4gICdlbGVtZW50RmFjdG9yeScsXG4gICdjYW52YXMnLFxuICAncHJldmlld1N1cHBvcnQnXG5dO1xuXG5pbmhlcml0cyhQb3N0aXRSZXBsYWNlUHJldmlldywgQ29tbWFuZEludGVyY2VwdG9yKTsiLCJpbXBvcnQgUHJldmlld1N1cHBvcnRNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcHJldmlldy1zdXBwb3J0JztcblxuaW1wb3J0IFBvc3RpdFJlcGxhY2VQcmV2aWV3IGZyb20gJy4vUG9zdGl0UmVwbGFjZVByZXZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgUHJldmlld1N1cHBvcnRNb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFsgJ3Bvc3RpdFJlcGxhY2VQcmV2aWV3JyBdLFxuICBwb3N0aXRSZXBsYWNlUHJldmlldzogWyAndHlwZScsIFBvc3RpdFJlcGxhY2VQcmV2aWV3IF1cbn07XG4iLCJpbXBvcnQge1xuICBwaWNrLFxuICBhc3NpZ24sXG4gIGZvckVhY2gsXG4gIGlzQXJyYXksXG4gIGlzVW5kZWZpbmVkXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHsgZ2V0UHJvcGVydHlOYW1lcyB9IGZyb20gJy4uL2NvcHktcGFzdGUvTW9kZGxlQ29weSc7XG5cbmZ1bmN0aW9uIGNvcHlQcm9wZXJ0aWVzKHNvdXJjZSwgdGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIGlmICghaXNBcnJheShwcm9wZXJ0aWVzKSkge1xuICAgIHByb3BlcnRpZXMgPSBbIHByb3BlcnRpZXMgXTtcbiAgfVxuXG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHNvdXJjZVtwcm9wZXJ0eV0pKSB7XG4gICAgICB0YXJnZXRbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgQ1VTVE9NX1BST1BFUlRJRVMgPSBbXG4gICdjYW5jZWxBY3Rpdml0eScsXG4gICdpbnN0YW50aWF0ZScsXG4gICdldmVudEdhdGV3YXlUeXBlJyxcbiAgJ3RyaWdnZXJlZEJ5RXZlbnQnLFxuICAnaXNJbnRlcnJ1cHRpbmcnXG5dO1xuXG5cblxuLyoqXG4gKiBUaGlzIG1vZHVsZSB0YWtlcyBjYXJlIG9mIHJlcGxhY2luZyBwb3N0aXQgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0UmVwbGFjZShcbiAgICBwb3N0aXRGYWN0b3J5LFxuICAgIGVsZW1lbnRGYWN0b3J5LFxuICAgIG1vZGRsZUNvcHksXG4gICAgbW9kZWxpbmcsXG4gICAgcmVwbGFjZSxcbiAgICBzZWxlY3Rpb25cbikge1xuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyBhIG5ldyBidXNpbmVzcyBvYmplY3QgZm9yIHRoZSByZXBsYWNlbWVudCBlbGVtZW50XG4gICAqIGFuZCB0cmlnZ2VycyB0aGUgcmVwbGFjZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSAge09iamVjdH0gW2hpbnRzXVxuICAgKlxuICAgKiBAcmV0dXJuIHtkanMubW9kZWwuQmFzZX0gdGhlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUVsZW1lbnQoZWxlbWVudCwgdGFyZ2V0LCBoaW50cykge1xuXG4gICAgaGludHMgPSBoaW50cyB8fCB7fTtcblxuICAgIHZhciB0eXBlID0gdGFyZ2V0LnR5cGUsXG4gICAgICAgIG9sZEJ1c2luZXNzT2JqZWN0ID0gZWxlbWVudC5idXNpbmVzc09iamVjdDtcblxuICAgIHZhciBuZXdCdXNpbmVzc09iamVjdCA9IHBvc3RpdEZhY3RvcnkuY3JlYXRlKHR5cGUpO1xuXG4gICAgdmFyIG5ld0VsZW1lbnQgPSB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgYnVzaW5lc3NPYmplY3Q6IG5ld0J1c2luZXNzT2JqZWN0XG4gICAgfTtcblxuICAgIHZhciBlbGVtZW50UHJvcHMgPSBnZXRQcm9wZXJ0eU5hbWVzKG9sZEJ1c2luZXNzT2JqZWN0LiRkZXNjcmlwdG9yKSxcbiAgICAgICAgbmV3RWxlbWVudFByb3BzID0gZ2V0UHJvcGVydHlOYW1lcyhuZXdCdXNpbmVzc09iamVjdC4kZGVzY3JpcHRvciwgdHJ1ZSksXG4gICAgICAgIGNvcHlQcm9wcyA9IGludGVyc2VjdGlvbihlbGVtZW50UHJvcHMsIG5ld0VsZW1lbnRQcm9wcyk7XG5cbiAgICAvLyBpbml0aWFsaXplIHNwZWNpYWwgcHJvcGVydGllcyBkZWZpbmVkIGluIHRhcmdldCBkZWZpbml0aW9uXG4gICAgYXNzaWduKG5ld0J1c2luZXNzT2JqZWN0LCBwaWNrKHRhcmdldCwgQ1VTVE9NX1BST1BFUlRJRVMpKTtcblxuICAgIHZhciBwcm9wZXJ0aWVzID0gY29weVByb3BzO1xuXG4gICAgbmV3QnVzaW5lc3NPYmplY3QgPSBtb2RkbGVDb3B5LmNvcHlFbGVtZW50KFxuICAgICAgb2xkQnVzaW5lc3NPYmplY3QsXG4gICAgICBuZXdCdXNpbmVzc09iamVjdCxcbiAgICAgIHByb3BlcnRpZXNcbiAgICApO1xuXG4gICAgbmV3QnVzaW5lc3NPYmplY3QubmFtZSA9IG9sZEJ1c2luZXNzT2JqZWN0Lm5hbWU7XG5cbiAgICBuZXdFbGVtZW50LmRpID0ge307XG5cbiAgICAvLyBmaWxsIGFuZCBzdHJva2Ugd2lsbCBiZSBzZXQgdG8gRElcbiAgICBjb3B5UHJvcGVydGllcyhvbGRCdXNpbmVzc09iamVjdC5kaSwgbmV3RWxlbWVudC5kaSwgW1xuICAgICAgJ2ZpbGwnLFxuICAgICAgJ3N0cm9rZSdcbiAgICBdKTtcblxuICAgIG5ld0VsZW1lbnQgPSByZXBsYWNlLnJlcGxhY2VFbGVtZW50KGVsZW1lbnQsIG5ld0VsZW1lbnQsIGhpbnRzKTtcblxuICAgIGlmIChoaW50cy5zZWxlY3QgIT09IGZhbHNlKSB7XG4gICAgICBzZWxlY3Rpb24uc2VsZWN0KG5ld0VsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbiAgdGhpcy5yZXBsYWNlRWxlbWVudCA9IHJlcGxhY2VFbGVtZW50O1xufVxuXG5Qb3N0aXRSZXBsYWNlLiRpbmplY3QgPSBbXG4gICdwb3N0aXRGYWN0b3J5JyxcbiAgJ2VsZW1lbnRGYWN0b3J5JyxcbiAgJ21vZGRsZUNvcHknLFxuICAnbW9kZWxpbmcnLFxuICAncmVwbGFjZScsXG4gICdzZWxlY3Rpb24nXG5dO1xuXG4vKipcbiAqIENvbXB1dGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKGExLCBhMikge1xuICByZXR1cm4gYTEuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGEyLmluZGV4T2YoZWwpICE9PSAtMTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgQ29weVBhc3RlTW9kdWxlIGZyb20gJy4uL2NvcHktcGFzdGUnO1xuaW1wb3J0IFJlcGxhY2VNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcmVwbGFjZSc7XG5pbXBvcnQgU2VsZWN0aW9uTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NlbGVjdGlvbic7XG5cbmltcG9ydCBQb3N0aXRSZXBsYWNlIGZyb20gJy4vUG9zdGl0UmVwbGFjZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBDb3B5UGFzdGVNb2R1bGUsXG4gICAgUmVwbGFjZU1vZHVsZSxcbiAgICBTZWxlY3Rpb25Nb2R1bGVcbiAgXSxcbiAgcG9zdGl0UmVwbGFjZTogWyAndHlwZScsIFBvc3RpdFJlcGxhY2UgXVxufTtcbiIsImltcG9ydCB7XG4gIGV2ZXJ5XG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IHtcbiAgaXNcbn0gZnJvbSAnLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG5pbXBvcnQge1xuICBpc0xhYmVsXG59IGZyb20gJy4uLy4uL3V0aWwvTGFiZWxVdGlsJztcblxuaW1wb3J0IFJ1bGVQcm92aWRlciBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9ydWxlcy9SdWxlUHJvdmlkZXInO1xuaW1wb3J0IHsgaXNBbnkgfSBmcm9tICcuLi9tb2RlbGluZy91dGlsL01vZGVsaW5nVXRpbCc7XG5cblxuLyoqXG4gKiBQb3N0aXQgc3BlY2lmaWMgbW9kZWxpbmcgcnVsZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQb3N0aXRSdWxlcyhldmVudEJ1cykge1xuICBSdWxlUHJvdmlkZXIuY2FsbCh0aGlzLCBldmVudEJ1cyk7XG59XG5cbmluaGVyaXRzKFBvc3RpdFJ1bGVzLCBSdWxlUHJvdmlkZXIpO1xuXG5Qb3N0aXRSdWxlcy4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnIF07XG5cblBvc3RpdFJ1bGVzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgdGhpcy5hZGRSdWxlKCdzaGFwZS5yZXNpemUnLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBuZXdCb3VuZHMgPSBjb250ZXh0Lm5ld0JvdW5kcztcblxuICAgIHJldHVybiBjYW5SZXNpemUoc2hhcGUsIG5ld0JvdW5kcyk7XG4gIH0pO1xuXG4gIHRoaXMuYWRkUnVsZSgnZWxlbWVudHMuY3JlYXRlJywgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBlbGVtZW50cyA9IGNvbnRleHQuZWxlbWVudHMsXG4gICAgICAgIHBvc2l0aW9uID0gY29udGV4dC5wb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0ID0gY29udGV4dC50YXJnZXQ7XG5cbiAgICByZXR1cm4gZXZlcnkoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50Lmhvc3QpIHtcbiAgICAgICAgcmV0dXJuIGNhbkF0dGFjaChlbGVtZW50LCBlbGVtZW50Lmhvc3QsIG51bGwsIHBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbkNyZWF0ZShlbGVtZW50LCB0YXJnZXQsIG51bGwsIHBvc2l0aW9uKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGhpcy5hZGRSdWxlKCdlbGVtZW50cy5tb3ZlJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0LFxuICAgICAgICBzaGFwZXMgPSBjb250ZXh0LnNoYXBlcyxcbiAgICAgICAgcG9zaXRpb24gPSBjb250ZXh0LnBvc2l0aW9uO1xuXG4gICAgcmV0dXJuIGNhbkF0dGFjaChzaGFwZXMsIHRhcmdldCwgbnVsbCwgcG9zaXRpb24pIHx8XG4gICAgICAgICAgIGNhbk1vdmUoc2hhcGVzLCB0YXJnZXQsIHBvc2l0aW9uKTtcbiAgfSk7XG5cbiAgdGhpcy5hZGRSdWxlKCdzaGFwZS5jcmVhdGUnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNhbkNyZWF0ZShcbiAgICAgIGNvbnRleHQuc2hhcGUsXG4gICAgICBjb250ZXh0LnRhcmdldCxcbiAgICAgIGNvbnRleHQuc291cmNlLFxuICAgICAgY29udGV4dC5wb3NpdGlvblxuICAgICk7XG4gIH0pO1xuXG4gIHRoaXMuYWRkUnVsZSgnc2hhcGUuYXR0YWNoJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgcmV0dXJuIGNhbkF0dGFjaChcbiAgICAgIGNvbnRleHQuc2hhcGUsXG4gICAgICBjb250ZXh0LnRhcmdldCxcbiAgICAgIG51bGwsXG4gICAgICBjb250ZXh0LnBvc2l0aW9uXG4gICAgKTtcbiAgfSk7XG5cbiAgdGhpcy5hZGRSdWxlKCdlbGVtZW50LmNvcHknLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0LmVsZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzID0gY29udGV4dC5lbGVtZW50cztcblxuICAgIHJldHVybiBjYW5Db3B5KGVsZW1lbnRzLCBlbGVtZW50KTtcbiAgfSk7XG59O1xuXG5Qb3N0aXRSdWxlcy5wcm90b3R5cGUuY2FuTW92ZSA9IGNhbk1vdmU7XG5cblBvc3RpdFJ1bGVzLnByb3RvdHlwZS5jYW5BdHRhY2ggPSBjYW5BdHRhY2g7XG5cblBvc3RpdFJ1bGVzLnByb3RvdHlwZS5jYW5Ecm9wID0gY2FuRHJvcDtcblxuUG9zdGl0UnVsZXMucHJvdG90eXBlLmNhbkNyZWF0ZSA9IGNhbkNyZWF0ZTtcblxuUG9zdGl0UnVsZXMucHJvdG90eXBlLmNhblJlcGxhY2UgPSBjYW5SZXBsYWNlO1xuXG5Qb3N0aXRSdWxlcy5wcm90b3R5cGUuY2FuUmVzaXplID0gY2FuUmVzaXplO1xuXG5Qb3N0aXRSdWxlcy5wcm90b3R5cGUuY2FuQ29weSA9IGNhbkNvcHk7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHJ1bGUgY2hlY2tpbmdcbiAqL1xuXG5mdW5jdGlvbiBpc1NhbWUoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50cyhlbGVtZW50KSB7XG5cbiAgdmFyIHBhcmVudHMgPSBbXTtcblxuICB3aGlsZSAoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBwYXJlbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50KHBvc3NpYmxlUGFyZW50LCBlbGVtZW50KSB7XG4gIHZhciBhbGxQYXJlbnRzID0gZ2V0UGFyZW50cyhlbGVtZW50KTtcbiAgcmV0dXJuIGFsbFBhcmVudHMuaW5kZXhPZihwb3NzaWJsZVBhcmVudCkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBpc0dyb3VwKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzKGVsZW1lbnQsICdwb3N0aXQ6R3JvdXAnKSAmJiAhZWxlbWVudC5sYWJlbFRhcmdldDtcbn1cblxuLyoqXG4gKiBDYW4gYW4gZWxlbWVudCBiZSBkcm9wcGVkIGludG8gdGhlIHRhcmdldCBlbGVtZW50XG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY2FuRHJvcChlbGVtZW50LCB0YXJnZXQpIHtcblxuICAvLyBjYW4gbW92ZSBsYWJlbHNcbiAgaWYgKGlzTGFiZWwoZWxlbWVudCkgfHwgaXNHcm91cChlbGVtZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZHJvcCBib2FyZCBlbGVtZW50cyBvbnRvIGJvYXJkc1xuICBpZiAoaXMoZWxlbWVudCwgJ3Bvc3RpdDpCb2FyZEVsZW1lbnQnKSAmJiBpcyh0YXJnZXQsICdwb3N0aXQ6UG9zdGl0Qm9hcmQnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjYW5SZXBsYWNlKGVsZW1lbnRzLCB0YXJnZXQpIHtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5cbmZ1bmN0aW9uIGNhbkF0dGFjaChlbGVtZW50cywgdGFyZ2V0KSB7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGVsZW1lbnRzKSkge1xuICAgIGVsZW1lbnRzID0gWyBlbGVtZW50cyBdO1xuICB9XG5cbiAgLy8gb25seSAocmUtKWF0dGFjaCBvbmUgZWxlbWVudCBhdCBhIHRpbWVcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gZWxlbWVudHNbMF07XG5cbiAgLy8gZG8gbm90IGF0dGFjaCBsYWJlbHNcbiAgaWYgKGlzTGFiZWwoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXModGFyZ2V0LCAncG9zdGl0OkJvYXJkRWxlbWVudCcpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICdhdHRhY2gnO1xufVxuXG5cbmZ1bmN0aW9uIGNhbk1vdmUoZWxlbWVudHMsIHRhcmdldCkge1xuXG4gIC8vIGFsbG93IGRlZmF1bHQgbW92ZSBjaGVjayB0byBzdGFydCBtb3ZlIG9wZXJhdGlvblxuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRzLmV2ZXJ5KGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gY2FuRHJvcChlbGVtZW50LCB0YXJnZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2FuQ3JlYXRlKHNoYXBlLCB0YXJnZXQsIHNvdXJjZSwgcG9zaXRpb24pIHtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0xhYmVsKHNoYXBlKSB8fCBpc0dyb3VwKHNoYXBlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzU2FtZShzb3VyY2UsIHRhcmdldCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBlbnN1cmUgd2UgZG8gbm90IGRyb3AgdGhlIGVsZW1lbnRcbiAgLy8gaW50byBzb3VyY2VcbiAgaWYgKHNvdXJjZSAmJiBpc1BhcmVudChzb3VyY2UsIHRhcmdldCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY2FuRHJvcChzaGFwZSwgdGFyZ2V0LCBwb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNhblJlc2l6ZShzaGFwZSwgbmV3Qm91bmRzKSB7XG5cbiAgaWYgKGlzQW55KHNoYXBlLCBbICdwb3N0aXQ6UG9zdGl0JywgJ3Bvc3RpdDpUZXh0Qm94JyBdKSkge1xuICAgIHJldHVybiAhbmV3Qm91bmRzIHx8IChuZXdCb3VuZHMud2lkdGggPj0gNTAgJiYgbmV3Qm91bmRzLmhlaWdodCA+PSA1MCk7XG4gIH1cblxuICBpZiAoaXMoc2hhcGUsICdwb3N0aXQ6R3JvdXAnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzKHNoYXBlLCAncG9zdGl0OkltYWdlJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY2FuQ29weShlbGVtZW50cywgZWxlbWVudCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCBSdWxlc01vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9ydWxlcyc7XG5cbmltcG9ydCBQb3N0aXRSdWxlcyBmcm9tICcuL1Bvc3RpdFJ1bGVzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIFJ1bGVzTW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbICdwb3N0aXRSdWxlcycgXSxcbiAgcG9zdGl0UnVsZXM6IFsgJ3R5cGUnLCBQb3N0aXRSdWxlcyBdXG59O1xuIiwiaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IENyZWF0ZU1vdmVTbmFwcGluZyBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zbmFwcGluZy9DcmVhdGVNb3ZlU25hcHBpbmcnO1xuXG4vKipcbiAqIFNuYXAgZHVyaW5nIGNyZWF0ZSBhbmQgbW92ZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtJbmplY3Rvcn0gaW5qZWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0Q3JlYXRlTW92ZVNuYXBwaW5nKGluamVjdG9yKSB7XG4gIGluamVjdG9yLmludm9rZShDcmVhdGVNb3ZlU25hcHBpbmcsIHRoaXMpO1xufVxuXG5pbmhlcml0cyhQb3N0aXRDcmVhdGVNb3ZlU25hcHBpbmcsIENyZWF0ZU1vdmVTbmFwcGluZyk7XG5cblBvc3RpdENyZWF0ZU1vdmVTbmFwcGluZy4kaW5qZWN0ID0gW1xuICAnaW5qZWN0b3InXG5dO1xuXG5Qb3N0aXRDcmVhdGVNb3ZlU25hcHBpbmcucHJvdG90eXBlLmluaXRTbmFwID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgcmV0dXJuIENyZWF0ZU1vdmVTbmFwcGluZy5wcm90b3R5cGUuaW5pdFNuYXAuY2FsbCh0aGlzLCBldmVudCk7XG59O1xuXG5Qb3N0aXRDcmVhdGVNb3ZlU25hcHBpbmcucHJvdG90eXBlLmFkZFNuYXBUYXJnZXRQb2ludHMgPSBmdW5jdGlvbihzbmFwUG9pbnRzLCBzaGFwZSwgdGFyZ2V0KSB7XG4gIHJldHVybiBDcmVhdGVNb3ZlU25hcHBpbmcucHJvdG90eXBlLmFkZFNuYXBUYXJnZXRQb2ludHMuY2FsbCh0aGlzLCBzbmFwUG9pbnRzLCBzaGFwZSwgdGFyZ2V0KTtcbn07XG5cblBvc3RpdENyZWF0ZU1vdmVTbmFwcGluZy5wcm90b3R5cGUuZ2V0U25hcFRhcmdldHMgPSBmdW5jdGlvbihzaGFwZSwgdGFyZ2V0KSB7XG4gIHJldHVybiBDcmVhdGVNb3ZlU25hcHBpbmcucHJvdG90eXBlLmdldFNuYXBUYXJnZXRzLmNhbGwodGhpcywgc2hhcGUsIHRhcmdldCk7XG59O1xuIiwiaW1wb3J0IFBvc3RpdENyZWF0ZU1vdmVTbmFwcGluZyBmcm9tICcuL1Bvc3RpdENyZWF0ZU1vdmVTbmFwcGluZyc7XG5pbXBvcnQgU25hcHBpbmdNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc25hcHBpbmcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbIFNuYXBwaW5nTW9kdWxlIF0sXG4gIF9faW5pdF9fOiBbXG4gICAgJ2NyZWF0ZU1vdmVTbmFwcGluZydcbiAgXSxcbiAgY3JlYXRlTW92ZVNuYXBwaW5nOiBbICd0eXBlJywgUG9zdGl0Q3JlYXRlTW92ZVNuYXBwaW5nIF1cbn07IiwiaW1wb3J0IFBvc3RpdFRyZWVXYWxrZXIgZnJvbSAnLi9Qb3N0aXRUcmVlV2Fsa2VyJztcblxuLyoqXG4gKiBUaGUgaW1wb3J0UG9zdGl0RGlhZ3JhbSByZXN1bHQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gaW1wb3J0UG9zdGl0RGlhZ3JhbVJlc3VsdFxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gd2FybmluZ3NcbiAqL1xuXG4vKipcbiogVGhlIGltcG9ydFBvc3RpdERpYWdyYW0gZXJyb3IuXG4qXG4qIEB0eXBlZGVmIHtFcnJvcn0gaW1wb3J0UG9zdGl0RGlhZ3JhbUVycm9yXG4qXG4qIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gd2FybmluZ3NcbiovXG5cbi8qKlxuICogSW1wb3J0IHRoZSBkZWZpbml0aW9ucyBpbnRvIGEgZGlhZ3JhbS5cbiAqXG4gKiBFcnJvcnMgYW5kIHdhcm5pbmdzIGFyZSByZXBvcnRlZCB0aHJvdWdoIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtICB7ZGpzLkRpYWdyYW19IGRpYWdyYW1cbiAqIEBwYXJhbSAge01vZGRsZUVsZW1lbnQ8RGVmaW5pdGlvbnM+fSBkZWZpbml0aW9uc1xuICogQHBhcmFtICB7TW9kZGxlRWxlbWVudDxQb3RpdFJvb3RCb2FyZD59IFtyb290Qm9hcmRdIHRoZSBkaWFncmFtIHRvIGJlIHJlbmRlcmVkXG4gKiAoaWYgbm90IHByb3ZpZGVkLCB0aGUgZmlyc3Qgb25lIHdpbGwgYmUgcmVuZGVyZWQpXG4gKlxuICogUmV0dXJucyB7UHJvbWlzZTxpbXBvcnRQb3N0aXREaWFncmFtUmVzdWx0LCBpbXBvcnRQb3N0aXREaWFncmFtRXJyb3I+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1wb3J0UG9zdGl0RGlhZ3JhbShkaWFncmFtLCBkZWZpbml0aW9ucywgcm9vdEJvYXJkKSB7XG5cbiAgdmFyIGltcG9ydGVyLFxuICAgICAgZXZlbnRCdXMsXG4gICAgICB0cmFuc2xhdGU7XG5cbiAgdmFyIGVycm9yLFxuICAgICAgd2FybmluZ3MgPSBbXTtcblxuICAvKipcbiAgICogV2FsayB0aGUgZGlhZ3JhbSBzZW1hbnRpY2FsbHksIGltcG9ydGluZyAoPWRyYXdpbmcpXG4gICAqIGFsbCBlbGVtZW50cyB5b3UgZW5jb3VudGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnQ8RGVmaW5pdGlvbnM+fSBkZWZpbml0aW9uc1xuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnQ8UG9zdGl0Um9vdEJvYXJkPn0gcm9vdEJvYXJkXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXIoZGVmaW5pdGlvbnMsIHJvb3RCb2FyZCkge1xuXG4gICAgdmFyIHZpc2l0b3IgPSB7XG5cbiAgICAgIHJvb3Q6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGltcG9ydGVyLmFkZChlbGVtZW50KTtcbiAgICAgIH0sXG5cbiAgICAgIGVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBhcmVudFNoYXBlKSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRlci5hZGQoZWxlbWVudCwgcGFyZW50U2hhcGUpO1xuICAgICAgfSxcblxuICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1lc3NhZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgd2FybmluZ3MucHVzaCh7IG1lc3NhZ2U6IG1lc3NhZ2UsIGNvbnRleHQ6IGNvbnRleHQgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB3YWxrZXIgPSBuZXcgUG9zdGl0VHJlZVdhbGtlcih2aXNpdG9yLCB0cmFuc2xhdGUpO1xuXG4gICAgLy8gdHJhdmVyc2UgeG1sIGRvY3VtZW50IG1vZGVsLFxuICAgIC8vIHN0YXJ0aW5nIGF0IGRlZmluaXRpb25zXG4gICAgd2Fsa2VyLmhhbmRsZURlZmluaXRpb25zKGRlZmluaXRpb25zLCByb290Qm9hcmQpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHRyeSB7XG4gICAgICBpbXBvcnRlciA9IGRpYWdyYW0uZ2V0KCdwb3N0aXRJbXBvcnRlcicpO1xuICAgICAgZXZlbnRCdXMgPSBkaWFncmFtLmdldCgnZXZlbnRCdXMnKTtcbiAgICAgIHRyYW5zbGF0ZSA9IGRpYWdyYW0uZ2V0KCd0cmFuc2xhdGUnKTtcblxuICAgICAgZXZlbnRCdXMuZmlyZSgnaW1wb3J0LnJlbmRlci5zdGFydCcsIHsgZGVmaW5pdGlvbnM6IGRlZmluaXRpb25zIH0pO1xuXG4gICAgICByZW5kZXIoZGVmaW5pdGlvbnMsIHJvb3RCb2FyZCk7XG5cbiAgICAgIGV2ZW50QnVzLmZpcmUoJ2ltcG9ydC5yZW5kZXIuY29tcGxldGUnLCB7XG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc29sdmUoeyB3YXJuaW5nczogd2FybmluZ3MgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICB9XG4gIH0pO1xufSIsImltcG9ydCB7XG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7IGlzIH0gZnJvbSAnLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG5pbXBvcnQge1xuICBpc0xhYmVsRXh0ZXJuYWwsXG4gIGdldEV4dGVybmFsTGFiZWxCb3VuZHNcbn0gZnJvbSAnLi4vdXRpbC9MYWJlbFV0aWwnO1xuXG5pbXBvcnQge1xuICBnZXRMYWJlbFxufSBmcm9tICcuLi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL0xhYmVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGVsZW1lbnRUb1N0cmluZ1xufSBmcm9tICcuL1V0aWwnO1xuXG5cbmZ1bmN0aW9uIGVsZW1lbnREYXRhKHNlbWFudGljLCBhdHRycykge1xuICByZXR1cm4gYXNzaWduKHtcbiAgICBpZDogc2VtYW50aWMuaWQsXG4gICAgdHlwZTogc2VtYW50aWMuJHR5cGUsXG4gICAgYnVzaW5lc3NPYmplY3Q6IHNlbWFudGljXG4gIH0sIGF0dHJzKTtcbn1cblxuZnVuY3Rpb24gbm90WWV0RHJhd24odHJhbnNsYXRlLCBzZW1hbnRpYywgcmVmU2VtYW50aWMsIHByb3BlcnR5KSB7XG4gIHJldHVybiBuZXcgRXJyb3IodHJhbnNsYXRlKCdlbGVtZW50IHtlbGVtZW50fSByZWZlcmVuY2VkIGJ5IHtyZWZlcmVuY2VkfSN7cHJvcGVydHl9IG5vdCB5ZXQgZHJhd24nLCB7XG4gICAgZWxlbWVudDogZWxlbWVudFRvU3RyaW5nKHJlZlNlbWFudGljKSxcbiAgICByZWZlcmVuY2VkOiBlbGVtZW50VG9TdHJpbmcoc2VtYW50aWMpLFxuICAgIHByb3BlcnR5OiBwcm9wZXJ0eVxuICB9KSk7XG59XG5cblxuLyoqXG4gKiBBbiBpbXBvcnRlciB0aGF0IGFkZHMgcG9zdGl0IGVsZW1lbnRzIHRvIHRoZSBjYW52YXNcbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtFbGVtZW50RmFjdG9yeX0gZWxlbWVudEZhY3RvcnlcbiAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zbGF0ZVxuICogQHBhcmFtIHtUZXh0UmVuZGVyZXJ9IHRleHRSZW5kZXJlclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQb3N0aXRJbXBvcnRlcihcbiAgICBldmVudEJ1cywgY2FudmFzLCBlbGVtZW50RmFjdG9yeSxcbiAgICBlbGVtZW50UmVnaXN0cnksIHRyYW5zbGF0ZSwgdGV4dFJlbmRlcmVyKSB7XG5cbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICB0aGlzLl9lbGVtZW50RmFjdG9yeSA9IGVsZW1lbnRGYWN0b3J5O1xuICB0aGlzLl9lbGVtZW50UmVnaXN0cnkgPSBlbGVtZW50UmVnaXN0cnk7XG4gIHRoaXMuX3RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiAgdGhpcy5fdGV4dFJlbmRlcmVyID0gdGV4dFJlbmRlcmVyO1xufVxuXG5Qb3N0aXRJbXBvcnRlci4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJyxcbiAgJ2VsZW1lbnRGYWN0b3J5JyxcbiAgJ2VsZW1lbnRSZWdpc3RyeScsXG4gICd0cmFuc2xhdGUnLFxuICAndGV4dFJlbmRlcmVyJ1xuXTtcblxuXG4vKipcbiAqIEFkZCBwb3N0aXQgZWxlbWVudCAoc2VtYW50aWMpIHRvIHRoZSBjYW52YXMgb250byB0aGVcbiAqIHNwZWNpZmllZCBwYXJlbnQgc2hhcGUuXG4gKi9cblBvc3RpdEltcG9ydGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihzZW1hbnRpYywgcGFyZW50RWxlbWVudCkge1xuXG4gIHZhciBkaSA9IHNlbWFudGljLmRpLFxuICAgICAgZWxlbWVudCxcbiAgICAgIHRyYW5zbGF0ZSA9IHRoaXMuX3RyYW5zbGF0ZSxcbiAgICAgIGhpZGRlbjtcblxuICB2YXIgcGFyZW50SW5kZXg7XG5cbiAgLy8gUk9PVCBFTEVNRU5UXG4gIC8vIGhhbmRsZSB0aGUgc3BlY2lhbCBjYXNlIHRoYXQgd2UgZGVhbCB3aXRoIGFcbiAgLy8gaW52aXNpYmxlIHJvb3QgZWxlbWVudFxuICBpZiAoaXMoZGksICdwb3N0aXREaTpQb3N0aXRQbGFuZScpKSB7XG5cbiAgICAvLyBhZGQgYSB2aXJ0dWFsIGVsZW1lbnQgKG5vdCBiZWluZyBkcmF3bilcbiAgICBlbGVtZW50ID0gdGhpcy5fZWxlbWVudEZhY3RvcnkuY3JlYXRlUm9vdChlbGVtZW50RGF0YShzZW1hbnRpYykpO1xuXG4gICAgdGhpcy5fY2FudmFzLnNldFJvb3RFbGVtZW50KGVsZW1lbnQpO1xuICB9XG5cbiAgLy8gU0hBUEVcbiAgZWxzZSBpZiAoaXMoZGksICdwb3N0aXREaTpQb3N0aXRTaGFwZScpKSB7XG5cbiAgICB2YXIgaXNGcmFtZSA9IGlzRnJhbWVFbGVtZW50KHNlbWFudGljKTtcblxuICAgIGhpZGRlbiA9IHBhcmVudEVsZW1lbnQgJiYgKHBhcmVudEVsZW1lbnQuaGlkZGVuIHx8IHBhcmVudEVsZW1lbnQuY29sbGFwc2VkKTtcblxuICAgIHZhciBib3VuZHMgPSBzZW1hbnRpYy5kaS5ib3VuZHM7XG5cbiAgICBlbGVtZW50ID0gdGhpcy5fZWxlbWVudEZhY3RvcnkuY3JlYXRlU2hhcGUoZWxlbWVudERhdGEoc2VtYW50aWMsIHtcbiAgICAgIGhpZGRlbjogaGlkZGVuLFxuICAgICAgeDogTWF0aC5yb3VuZChib3VuZHMueCksXG4gICAgICB5OiBNYXRoLnJvdW5kKGJvdW5kcy55KSxcbiAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKGJvdW5kcy53aWR0aCksXG4gICAgICBoZWlnaHQ6IE1hdGgucm91bmQoYm91bmRzLmhlaWdodCksXG4gICAgICBpc0ZyYW1lOiBpc0ZyYW1lXG4gICAgfSkpO1xuXG4gICAgdGhpcy5fY2FudmFzLmFkZFNoYXBlKGVsZW1lbnQsIHBhcmVudEVsZW1lbnQsIHBhcmVudEluZGV4KTtcbiAgfVxuXG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcih0cmFuc2xhdGUoJ3Vua25vd24gZGkge2RpfSBmb3IgZWxlbWVudCB7c2VtYW50aWN9Jywge1xuICAgICAgZGk6IGVsZW1lbnRUb1N0cmluZyhkaSksXG4gICAgICBzZW1hbnRpYzogZWxlbWVudFRvU3RyaW5nKHNlbWFudGljKVxuICAgIH0pKTtcbiAgfVxuXG4gIC8vIChvcHRpb25hbCkgTEFCRUxcbiAgaWYgKGlzTGFiZWxFeHRlcm5hbChzZW1hbnRpYykgJiYgZ2V0TGFiZWwoZWxlbWVudCkpIHtcbiAgICB0aGlzLmFkZExhYmVsKHNlbWFudGljLCBlbGVtZW50KTtcbiAgfVxuXG5cbiAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnYm9hcmRFbGVtZW50LmFkZGVkJywgeyBlbGVtZW50OiBlbGVtZW50IH0pO1xuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuXG4vKipcbiAqIEF0dGFjaCB0aGUgYm91bmRhcnkgZWxlbWVudCB0byB0aGUgZ2l2ZW4gaG9zdFxuICpcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gYm91bmRhcnlTZW1hbnRpY1xuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gYm91bmRhcnlFbGVtZW50XG4gKi9cblBvc3RpdEltcG9ydGVyLnByb3RvdHlwZS5fYXR0YWNoQm91bmRhcnkgPSBmdW5jdGlvbihib3VuZGFyeVNlbWFudGljLCBib3VuZGFyeUVsZW1lbnQpIHtcbiAgdmFyIHRyYW5zbGF0ZSA9IHRoaXMuX3RyYW5zbGF0ZTtcbiAgdmFyIGhvc3RTZW1hbnRpYyA9IGJvdW5kYXJ5U2VtYW50aWMuYXR0YWNoZWRUb1JlZjtcblxuICBpZiAoIWhvc3RTZW1hbnRpYykge1xuICAgIHRocm93IG5ldyBFcnJvcih0cmFuc2xhdGUoJ21pc3Npbmcge3NlbWFudGljfSNhdHRhY2hlZFRvUmVmJywge1xuICAgICAgc2VtYW50aWM6IGVsZW1lbnRUb1N0cmluZyhib3VuZGFyeVNlbWFudGljKVxuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBob3N0ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChob3N0U2VtYW50aWMuaWQpLFxuICAgICAgYXR0YWNoZXJzID0gaG9zdCAmJiBob3N0LmF0dGFjaGVycztcblxuICBpZiAoIWhvc3QpIHtcbiAgICB0aHJvdyBub3RZZXREcmF3bih0cmFuc2xhdGUsIGJvdW5kYXJ5U2VtYW50aWMsIGhvc3RTZW1hbnRpYywgJ2F0dGFjaGVkVG9SZWYnKTtcbiAgfVxuXG4gIC8vIHdpcmUgZWxlbWVudC5ob3N0IDw+IGhvc3QuYXR0YWNoZXJzXG4gIGJvdW5kYXJ5RWxlbWVudC5ob3N0ID0gaG9zdDtcblxuICBpZiAoIWF0dGFjaGVycykge1xuICAgIGhvc3QuYXR0YWNoZXJzID0gYXR0YWNoZXJzID0gW107XG4gIH1cblxuICBpZiAoYXR0YWNoZXJzLmluZGV4T2YoYm91bmRhcnlFbGVtZW50KSA9PT0gLTEpIHtcbiAgICBhdHRhY2hlcnMucHVzaChib3VuZGFyeUVsZW1lbnQpO1xuICB9XG59O1xuXG5cbi8qKlxuICogYWRkIGxhYmVsIGZvciBhbiBlbGVtZW50XG4gKi9cblBvc3RpdEltcG9ydGVyLnByb3RvdHlwZS5hZGRMYWJlbCA9IGZ1bmN0aW9uKHNlbWFudGljLCBlbGVtZW50KSB7XG4gIHZhciBib3VuZHMsXG4gICAgICB0ZXh0LFxuICAgICAgbGFiZWw7XG5cbiAgYm91bmRzID0gZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kcyhzZW1hbnRpYywgZWxlbWVudCk7XG5cbiAgdGV4dCA9IGdldExhYmVsKGVsZW1lbnQpO1xuXG4gIGlmICh0ZXh0KSB7XG5cbiAgICAvLyBnZXQgY29ycmVjdGVkIGJvdW5kcyBmcm9tIGFjdHVhbCBsYXlvdXRlZCB0ZXh0XG4gICAgYm91bmRzID0gdGhpcy5fdGV4dFJlbmRlcmVyLmdldEV4dGVybmFsTGFiZWxCb3VuZHMoYm91bmRzLCB0ZXh0KTtcbiAgfVxuXG4gIGxhYmVsID0gdGhpcy5fZWxlbWVudEZhY3RvcnkuY3JlYXRlTGFiZWwoZWxlbWVudERhdGEoc2VtYW50aWMsIHtcbiAgICBpZDogc2VtYW50aWMuaWQgKyAnX2xhYmVsJyxcbiAgICBsYWJlbFRhcmdldDogZWxlbWVudCxcbiAgICB0eXBlOiAnbGFiZWwnLFxuICAgIGhpZGRlbjogZWxlbWVudC5oaWRkZW4gfHwgIWdldExhYmVsKGVsZW1lbnQpLFxuICAgIHg6IE1hdGgucm91bmQoYm91bmRzLngpLFxuICAgIHk6IE1hdGgucm91bmQoYm91bmRzLnkpLFxuICAgIHdpZHRoOiBNYXRoLnJvdW5kKGJvdW5kcy53aWR0aCksXG4gICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGJvdW5kcy5oZWlnaHQpXG4gIH0pKTtcblxuICByZXR1cm4gdGhpcy5fY2FudmFzLmFkZFNoYXBlKGxhYmVsLCBlbGVtZW50LnBhcmVudCk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZHJhd24gY29ubmVjdGlvbiBlbmQgYmFzZWQgb24gdGhlIGdpdmVuIHNpZGUuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBlbmQgaXMgbm90IHlldCBkcmF3blxuICovXG5Qb3N0aXRJbXBvcnRlci5wcm90b3R5cGUuX2dldEVuZCA9IGZ1bmN0aW9uKHNlbWFudGljLCBzaWRlKSB7XG5cbiAgdmFyIGVsZW1lbnQsXG4gICAgICByZWZTZW1hbnRpYyxcbiAgICAgIHRyYW5zbGF0ZSA9IHRoaXMuX3RyYW5zbGF0ZTtcblxuICByZWZTZW1hbnRpYyA9IHNlbWFudGljW3NpZGUgKyAnUmVmJ107XG5cblxuICBlbGVtZW50ID0gcmVmU2VtYW50aWMgJiYgdGhpcy5fZ2V0RWxlbWVudChyZWZTZW1hbnRpYyk7XG5cbiAgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGlmIChyZWZTZW1hbnRpYykge1xuICAgIHRocm93IG5vdFlldERyYXduKHRyYW5zbGF0ZSwgc2VtYW50aWMsIHJlZlNlbWFudGljLCBzaWRlICsgJ1JlZicpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcih0cmFuc2xhdGUoJ3tzZW1hbnRpY30je3NpZGV9IFJlZiBub3Qgc3BlY2lmaWVkJywge1xuICAgICAgc2VtYW50aWM6IGVsZW1lbnRUb1N0cmluZyhzZW1hbnRpYyksXG4gICAgICBzaWRlOiBzaWRlXG4gICAgfSkpO1xuICB9XG59O1xuXG5Qb3N0aXRJbXBvcnRlci5wcm90b3R5cGUuX2dldFNvdXJjZSA9IGZ1bmN0aW9uKHNlbWFudGljKSB7XG4gIHJldHVybiB0aGlzLl9nZXRFbmQoc2VtYW50aWMsICdzb3VyY2UnKTtcbn07XG5cblBvc3RpdEltcG9ydGVyLnByb3RvdHlwZS5fZ2V0VGFyZ2V0ID0gZnVuY3Rpb24oc2VtYW50aWMpIHtcbiAgcmV0dXJuIHRoaXMuX2dldEVuZChzZW1hbnRpYywgJ3RhcmdldCcpO1xufTtcblxuXG5Qb3N0aXRJbXBvcnRlci5wcm90b3R5cGUuX2dldEVsZW1lbnQgPSBmdW5jdGlvbihzZW1hbnRpYykge1xuICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChzZW1hbnRpYy5pZCk7XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc0ZyYW1lRWxlbWVudChzZW1hbnRpYykge1xuICByZXR1cm4gaXMoc2VtYW50aWMsICdwb3N0aXQ6R3JvdXAnKTtcbn0iLCJpbXBvcnQge1xuICBmaW5kLFxuICBmb3JFYWNoXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IFJlZnMgZnJvbSAnb2JqZWN0LXJlZnMnO1xuXG5pbXBvcnQge1xuICBlbGVtZW50VG9TdHJpbmdcbn0gZnJvbSAnLi9VdGlsJztcblxudmFyIGRpUmVmcyA9IG5ldyBSZWZzKFxuICB7IG5hbWU6ICdib2FyZEVsZW1lbnQnLCBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHsgbmFtZTogJ2RpJywgY29uZmlndXJhYmxlOiB0cnVlIH1cbik7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIGVsZW1lbnQgaGFzIHRoZSBnaXZlbiBtZXRhLW1vZGVsIHR5cGVcbiAqXG4gKiBAcGFyYW0gIHtNb2RkbGVFbGVtZW50fSAgZWxlbWVudFxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgIHR5cGVcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpcyhlbGVtZW50LCB0eXBlKSB7XG4gIHJldHVybiBlbGVtZW50LiRpbnN0YW5jZU9mKHR5cGUpO1xufVxuXG5cbi8qKlxuICogRmluZCBhIHN1aXRhYmxlIGRpc3BsYXkgY2FuZGlkYXRlIGZvciBkZWZpbml0aW9ucyB3aGVyZSB0aGUgREkgZG9lcyBub3RcbiAqIGNvcnJlY3RseSBzcGVjaWZ5IG9uZS5cbiAqL1xuZnVuY3Rpb24gZmluZERpc3BsYXlDYW5kaWRhdGUoZGVmaW5pdGlvbnMpIHtcbiAgcmV0dXJuIGZpbmQoZGVmaW5pdGlvbnMucm9vdEVsZW1lbnRzLCBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGlzKGUsICdwb3N0aXQ6UG9zdGl0Qm9hcmQnKTtcbiAgfSk7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0VHJlZVdhbGtlcihoYW5kbGVyLCB0cmFuc2xhdGUpIHtcblxuICAvLyBsaXN0IG9mIGNvbnRhaW5lcnMgYWxyZWFkeSB3YWxrZWRcbiAgdmFyIGhhbmRsZWRFbGVtZW50cyA9IHt9O1xuXG4gIC8vIGxpc3Qgb2YgZWxlbWVudHMgdG8gaGFuZGxlIGRlZmVycmVkIHRvIGVuc3VyZVxuICAvLyBwcmVyZXF1aXNpdGVzIGFyZSBkcmF3blxuICB2YXIgZGVmZXJyZWQgPSBbXTtcblxuICAvLyBIZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiB2aXNpdFJvb3QoZWxlbWVudCwgZGlhZ3JhbSkge1xuICAgIHJldHVybiBoYW5kbGVyLnJvb3QoZWxlbWVudCwgZGlhZ3JhbSk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpdChlbGVtZW50LCBjdHgpIHtcblxuICAgIHZhciBnZnggPSBlbGVtZW50LmdmeDtcblxuICAgIC8vIGF2b2lkIG11bHRpcGxlIHJlbmRlcmluZyBvZiBlbGVtZW50c1xuICAgIGlmIChnZngpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgdHJhbnNsYXRlKCdhbHJlYWR5IHJlbmRlcmVkIHtlbGVtZW50fScsIHsgZWxlbWVudDogZWxlbWVudFRvU3RyaW5nKGVsZW1lbnQpIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNhbGwgaGFuZGxlclxuICAgIHJldHVybiBoYW5kbGVyLmVsZW1lbnQoZWxlbWVudCwgY3R4KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2l0SWZEaShlbGVtZW50LCBjdHgpIHtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgZ2Z4ID0gZWxlbWVudC5kaSAmJiB2aXNpdChlbGVtZW50LCBjdHgpO1xuXG4gICAgICBoYW5kbGVkKGVsZW1lbnQpO1xuXG4gICAgICByZXR1cm4gZ2Z4O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ0Vycm9yKGUubWVzc2FnZSwgeyBlbGVtZW50OiBlbGVtZW50LCBlcnJvcjogZSB9KTtcblxuICAgICAgY29uc29sZS5lcnJvcih0cmFuc2xhdGUoJ2ZhaWxlZCB0byBpbXBvcnQge2VsZW1lbnR9JywgeyBlbGVtZW50OiBlbGVtZW50VG9TdHJpbmcoZWxlbWVudCkgfSkpO1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2dFcnJvcihtZXNzYWdlLCBjb250ZXh0KSB7XG4gICAgaGFuZGxlci5lcnJvcihtZXNzYWdlLCBjb250ZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZWQoZWxlbWVudCkge1xuICAgIGhhbmRsZWRFbGVtZW50c1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG4gIH1cblxuICAvLyBESSBoYW5kbGluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJEaShkaSkge1xuICAgIHZhciBib2FyZEVsZW1lbnQgPSBkaS5ib2FyZEVsZW1lbnQ7XG5cbiAgICBpZiAoYm9hcmRFbGVtZW50KSB7XG4gICAgICBpZiAoYm9hcmRFbGVtZW50LmRpKSB7XG4gICAgICAgIGxvZ0Vycm9yKFxuICAgICAgICAgIHRyYW5zbGF0ZSgnbXVsdGlwbGUgREkgZWxlbWVudHMgZGVmaW5lZCBmb3Ige2VsZW1lbnR9Jywge1xuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFRvU3RyaW5nKGJvYXJkRWxlbWVudClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IGVsZW1lbnQ6IGJvYXJkRWxlbWVudCB9XG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaVJlZnMuYmluZChib2FyZEVsZW1lbnQsICdkaScpO1xuICAgICAgICBib2FyZEVsZW1lbnQuZGkgPSBkaTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nRXJyb3IoXG4gICAgICAgIHRyYW5zbGF0ZSgnbm8gYm9hcmRFbGVtZW50IHJlZmVyZW5jZWQgaW4ge2VsZW1lbnR9Jywge1xuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRUb1N0cmluZyhkaSlcbiAgICAgICAgfSksXG4gICAgICAgIHsgZWxlbWVudDogZGkgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVCb2FyZChkaWFncmFtKSB7XG4gICAgaGFuZGxlUGxhbmUoZGlhZ3JhbS5wbGFuZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQbGFuZShwbGFuZSkge1xuICAgIHJlZ2lzdGVyRGkocGxhbmUpO1xuXG4gICAgZm9yRWFjaChwbGFuZS5wbGFuZUVsZW1lbnQsIGhhbmRsZVBsYW5lRWxlbWVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQbGFuZUVsZW1lbnQocGxhbmVFbGVtZW50KSB7XG4gICAgcmVnaXN0ZXJEaShwbGFuZUVsZW1lbnQpO1xuICB9XG5cblxuICAvLyBTZW1hbnRpYyBoYW5kbGluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBkZWZpbml0aW9ucyBhbmQgcmV0dXJuIHRoZSByZW5kZXJlZCBib2FyZCAoaWYgYW55KVxuICAgKlxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGRlZmluaXRpb25zIHRvIHdhbGsgYW5kIGltcG9ydFxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IFtyb290Qm9hcmRdIHNwZWNpZmljIGJvYXJkIHRvIGltcG9ydCBhbmQgZGlzcGxheVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gZGlhZ3JhbSB0byBkaXNwbGF5IGNvdWxkIGJlIGZvdW5kXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVEZWZpbml0aW9ucyhkZWZpbml0aW9ucywgcm9vdEJvYXJkKSB7XG5cbiAgICAvLyBtYWtlIHN1cmUgd2Ugd2FsayB0aGUgY29ycmVjdCBib2FyZEVsZW1lbnRcblxuICAgIHZhciByb290Qm9hcmRzID0gZGVmaW5pdGlvbnMucm9vdEJvYXJkcztcblxuICAgIGlmIChyb290Qm9hcmQgJiYgcm9vdEJvYXJkcy5pbmRleE9mKHJvb3RCb2FyZCkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnNsYXRlKCdyb290Qm9hcmQgbm90IHBhcnQgb2YgcG9zdGl0OkRlZmluaXRpb25zJykpO1xuICAgIH1cblxuICAgIGlmICghcm9vdEJvYXJkICYmIHJvb3RCb2FyZHMgJiYgcm9vdEJvYXJkcy5sZW5ndGgpIHtcbiAgICAgIHJvb3RCb2FyZCA9IHJvb3RCb2FyZHNbMF07XG4gICAgfVxuXG4gICAgLy8gbm8gcm9vdCBib2FyZCAtPiBub3RoaW5nIHRvIGltcG9ydFxuICAgIGlmICghcm9vdEJvYXJkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnNsYXRlKCdubyByb290Qm9hcmQgdG8gZGlzcGxheScpKTtcbiAgICB9XG5cbiAgICAvLyBsb2FkIERJIGZyb20gc2VsZWN0ZWQgcm9vdCBib2FyZCBvbmx5XG4gICAgaGFuZGxlQm9hcmQocm9vdEJvYXJkKTtcblxuICAgIHZhciBwbGFuZSA9IHJvb3RCb2FyZC5wbGFuZTtcblxuICAgIGlmICghcGxhbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0cmFuc2xhdGUoXG4gICAgICAgICdubyBwbGFuZSBmb3Ige2VsZW1lbnR9JyxcbiAgICAgICAgeyBlbGVtZW50OiBlbGVtZW50VG9TdHJpbmcocm9vdEJvYXJkKSB9XG4gICAgICApKTtcbiAgICB9XG5cbiAgICB2YXIgcm9vdEVsZW1lbnQgPSBwbGFuZS5ib2FyZEVsZW1lbnQ7XG5cbiAgICAvLyBlbnN1cmUgd2UgZGVmYXVsdCB0byBhIHN1aXRhYmxlIGRpc3BsYXkgY2FuZGlkYXRlIChib2FyZCksXG4gICAgLy8gZXZlbiBpZiBub24gaXMgc3BlY2lmaWVkIGluIERJXG4gICAgaWYgKCFyb290RWxlbWVudCkge1xuICAgICAgcm9vdEVsZW1lbnQgPSBmaW5kRGlzcGxheUNhbmRpZGF0ZShkZWZpbml0aW9ucyk7XG5cbiAgICAgIGlmICghcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zbGF0ZSgnbm8gYm9hcmQgdG8gZGlzcGxheScpKTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgbG9nRXJyb3IoXG4gICAgICAgICAgdHJhbnNsYXRlKCdjb3JyZWN0aW5nIG1pc3NpbmcgYm9hcmRFbGVtZW50IG9uIHtwbGFuZX0gdG8ge3Jvb3RFbGVtZW50fScsIHtcbiAgICAgICAgICAgIHBsYW5lOiBlbGVtZW50VG9TdHJpbmcocGxhbmUpLFxuICAgICAgICAgICAgcm9vdEVsZW1lbnQ6IGVsZW1lbnRUb1N0cmluZyhyb290RWxlbWVudClcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGNvcnJlY3QgREkgb24gdGhlIGZseVxuICAgICAgICBwbGFuZS5ib2FyZEVsZW1lbnQgPSByb290RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJEaShwbGFuZSk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgY3R4ID0gdmlzaXRSb290KHJvb3RFbGVtZW50LCBwbGFuZSk7XG5cbiAgICBpZiAoaXMocm9vdEVsZW1lbnQsICdwb3N0aXQ6UG9zdGl0Qm9hcmQnKSkge1xuICAgICAgaGFuZGxlUG9zdGl0Qm9hcmQocm9vdEVsZW1lbnQsIGN0eCk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGFsbCBkZWZlcnJlZCBlbGVtZW50c1xuICAgIGhhbmRsZURlZmVycmVkKGRlZmVycmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUJvYXJkRWxlbWVudHMoYm9hcmRFbGVtZW50cywgY29udGV4dCkge1xuICAgIGZvckVhY2goYm9hcmRFbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdmlzaXRJZkRpKGVsZW1lbnQsIGNvbnRleHQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9zdGl0Qm9hcmQoYm9hcmQsIGNvbnRleHQpIHtcbiAgICBoYW5kbGVCb2FyZEVsZW1lbnRzKGJvYXJkLmJvYXJkRWxlbWVudHMsIGNvbnRleHQpO1xuXG4gICAgLy8gbG9nIGJvYXJkIGhhbmRsZWRcbiAgICBoYW5kbGVkKGJvYXJkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURlZmVycmVkKCkge1xuXG4gICAgdmFyIGZuO1xuXG4gICAgLy8gZHJhaW4gZGVmZXJyZWQgdW50aWwgZW1wdHlcbiAgICB3aGlsZSAoZGVmZXJyZWQubGVuZ3RoKSB7XG4gICAgICBmbiA9IGRlZmVycmVkLnNoaWZ0KCk7XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9XG5cblxuXG5cbiAgLy8gQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICByZXR1cm4ge1xuICAgIGhhbmRsZURlZmVycmVkOiBoYW5kbGVEZWZlcnJlZCxcbiAgICBoYW5kbGVEZWZpbml0aW9uczogaGFuZGxlRGVmaW5pdGlvbnMsXG4gICAgcmVnaXN0ZXJEaTogcmVnaXN0ZXJEaVxuICB9O1xufSIsImV4cG9ydCBmdW5jdGlvbiBlbGVtZW50VG9TdHJpbmcoZSkge1xuICBpZiAoIWUpIHtcbiAgICByZXR1cm4gJzxudWxsPic7XG4gIH1cblxuICByZXR1cm4gJzwnICsgZS4kdHlwZSArIChlLmlkID8gJyBpZD1cIicgKyBlLmlkIDogJycpICsgJ1wiIC8+Jztcbn0iLCJpbXBvcnQgdHJhbnNsYXRlIGZyb20gJ2RpYWdyYW0tanMvbGliL2kxOG4vdHJhbnNsYXRlJztcblxuaW1wb3J0IFBvc3RpdEltcG9ydGVyIGZyb20gJy4vUG9zdGl0SW1wb3J0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgdHJhbnNsYXRlXG4gIF0sXG4gIHBvc3RpdEltcG9ydGVyOiBbICd0eXBlJywgUG9zdGl0SW1wb3J0ZXIgXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBNb2RlbGVyID0gcmVxdWlyZSgnLi9Nb2RlbGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWxlcjtcbiIsImltcG9ydCB7IGlzU3RyaW5nLCBhc3NpZ24gfSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7IE1vZGRsZSB9IGZyb20gJ21vZGRsZSc7XG5cbmltcG9ydCB7IFJlYWRlciwgV3JpdGVyIH0gZnJvbSAnbW9kZGxlLXhtbCc7XG5cbi8qKlxuICogQSBzdWIgY2xhc3Mgb2Yge0BsaW5rIE1vZGRsZX0gd2l0aCBzdXBwb3J0IGZvciBpbXBvcnQgYW5kIGV4cG9ydCBvZiBQb3N0aXQtanMgeG1sIGZpbGVzLlxuICpcbiAqIEBjbGFzcyBQb3N0aXRNb2RkbGVcbiAqXG4gKiBAZXh0ZW5kcyBNb2RkbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gcGFja2FnZXMgdG8gdXNlIGZvciBpbnN0YW50aWF0aW5nIHRoZSBtb2RlbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyBvdmVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvc3RpdE1vZGRsZShwYWNrYWdlcywgb3B0aW9ucykge1xuICBNb2RkbGUuY2FsbCh0aGlzLCBwYWNrYWdlcywgb3B0aW9ucyk7XG59XG5cblBvc3RpdE1vZGRsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vZGRsZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFRoZSBmcm9tWE1MIHJlc3VsdC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJzZVJlc3VsdFxuICpcbiAqIEBwcm9wZXJ0eSB7TW9kZGxlRWxlbWVudH0gcm9vdEVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8T2JqZWN0Pn0gcmVmZXJlbmNlc1xuICogQHByb3BlcnR5IHtBcnJheTxFcnJvcj59IHdhcm5pbmdzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZWxlbWVudHNCeUlkIC0gYSBtYXBwaW5nIGNvbnRhaW5pbmcgZWFjaCBJRCAtPiBNb2RkbGVFbGVtZW50XG4gKi9cblxuLyoqXG4gKiBUaGUgZnJvbVhNTCBlcnJvci5cbiAqXG4gKiBAdHlwZWRlZiB7RXJyb3J9IFBhcnNlRXJyb3JcbiAqXG4gKiBAcHJvcGVydHkge0FycmF5PEVycm9yPn0gd2FybmluZ3NcbiAqL1xuXG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIFBvc3RpdCBtb2RlbCB0cmVlIGZyb20gYSBnaXZlbiB4bWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIHhtbFN0clxuICogQHBhcmFtIHtTdHJpbmd9ICAgW3R5cGVOYW1lPSdwb3N0aXQ6RGVmaW5pdGlvbnMnXSBuYW1lIG9mIHRoZSByb290IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIFtvcHRpb25zXSAgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSB1bmRlcmx5aW5nIHJlYWRlclxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFBhcnNlUmVzdWx0LCBQYXJzZUVycm9yPn1cbiAqL1xuUG9zdGl0TW9kZGxlLnByb3RvdHlwZS5mcm9tWE1MID0gZnVuY3Rpb24oeG1sU3RyLCB0eXBlTmFtZSwgb3B0aW9ucykge1xuICBpZiAoIWlzU3RyaW5nKHR5cGVOYW1lKSkge1xuICAgIG9wdGlvbnMgPSB0eXBlTmFtZTtcbiAgICB0eXBlTmFtZSA9ICdwb3N0aXQ6RGVmaW5pdGlvbnMnO1xuICB9XG5cbiAgdmFyIHJlYWRlciA9IG5ldyBSZWFkZXIoYXNzaWduKHsgbW9kZWw6IHRoaXMsIGxheDogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gIHZhciByb290SGFuZGxlciA9IHJlYWRlci5oYW5kbGVyKHR5cGVOYW1lKTtcblxuICByZXR1cm4gcmVhZGVyLmZyb21YTUwoeG1sU3RyLCByb290SGFuZGxlcik7XG59O1xuXG4vKipcbiAqIFRoZSB0b1hNTCByZXN1bHQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VyaWFsaXphdGlvblJlc3VsdFxuICpcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB4bWxcbiAqL1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgYSBQb3N0aXQgb2JqZWN0IHRyZWUgdG8gWE1MLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIGVsZW1lbnQgICAgdGhlIHJvb3QgZWxlbWVudCwgdHlwaWNhbGx5IGFuIGluc3RhbmNlIG9mIGBwb3N0aXQ6RGVmaW5pdGlvbnNgXG4gKiBAcGFyYW0ge09iamVjdH0gICBbb3B0aW9uc10gIHRvIHBhc3MgdG8gdGhlIHVuZGVybHlpbmcgd3JpdGVyXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8U2VyaWFsaXphdGlvblJlc3VsdCwgRXJyb3I+fVxuICovXG5Qb3N0aXRNb2RkbGUucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICB2YXIgd3JpdGVyID0gbmV3IFdyaXRlcihvcHRpb25zKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXN1bHQgPSB3cml0ZXIudG9YTUwoZWxlbWVudCk7XG5cbiAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgeG1sOiByZXN1bHRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiXG5pbXBvcnQge1xuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgTW9kZGxlIGZyb20gJy4vTW9kZGxlJztcblxuaW1wb3J0IFBvc3RpdERlc2NyaXB0b3JzIGZyb20gJy4vcmVzb3VyY2VzL3Bvc3RpdC5qc29uJztcbmltcG9ydCBEaURlc2NyaXB0b3JzIGZyb20gJy4vcmVzb3VyY2VzL3Bvc3RpdERpLmpzb24nO1xuaW1wb3J0IERjRGVzY3JpcHRvcnMgZnJvbSAnLi9yZXNvdXJjZXMvZGMuanNvbic7XG5cbnZhciBwYWNrYWdlcyA9IHtcbiAgcG9zdGl0OiBQb3N0aXREZXNjcmlwdG9ycyxcbiAgcG9zdGl0RGk6IERpRGVzY3JpcHRvcnMsXG4gIGRjOiBEY0Rlc2NyaXB0b3JzLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYWRkaXRpb25hbFBhY2thZ2VzLCBvcHRpb25zKSB7XG4gIHZhciBwa3MgPSBhc3NpZ24oe30sIHBhY2thZ2VzLCBhZGRpdGlvbmFsUGFja2FnZXMpO1xuXG4gIHJldHVybiBuZXcgTW9kZGxlKHBrcywgb3B0aW9ucyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIFlFTExPVzogJyNGRkZGODgnLFxuICBHUkVFTjogJyM3RUM4NDUnLFxuICBQSU5LOiAnI0Y0NkY2MCcsXG4gIElDRV9CTFVFOiAnI0I4RDZGNycsXG4gIEJMVUU6ICcjMjNCRkU3JyxcbiAgT1JBTkdFOiAnI0ZGOUQ0OCcsXG4gIEJMQUNLOiAnYmxhY2snXG59O1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGZpbGVUb0RhdGFVUkwoZmlsZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3QoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1hZ2VQcm9jZXNzb3IoZXYsIGZpbGUpIHtcbiAgY29uc3QgYmFzZTY0ZmlsZSA9IGF3YWl0IGZpbGVUb0RhdGFVUkwoZmlsZSk7XG5cbiAgLy8gY3JlYXRlSW1hZ2UoZXYsIGJhc2U2NGZpbGUpO1xuICByZXR1cm4gYmFzZTY0ZmlsZTsgLy8gcGFzc2luZyBhbnkgZXJyb3JzIHRocm91Z2hcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbGVSZWFkZXIoZXYsIGZpbGVzKSB7XG4gIGxldCB1cGxvYWRSZXN1bHQgPSBbXTtcbiAgbGV0IGVycm9ycztcbiAgbGV0IGZpbGVJdGVtcyA9IGZpbGVzO1xuICBpZiAoZXYgJiYgKGV2LmRhdGFUcmFuc2Zlci5pdGVtcyB8fCBldi5kYXRhVHJhbnNmZXIuZmlsZXMpKSB7XG4gICAgZmlsZUl0ZW1zID0gZXYuZGF0YVRyYW5zZmVyLml0ZW1zIHx8IGV2LmRhdGFUcmFuc2Zlci5maWxlcztcbiAgfVxuICB0cnkge1xuICAgIGlmIChmaWxlSXRlbXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChldiAmJiBldi5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgICAgICBpZiAoZmlsZUl0ZW1zW2ldLmtpbmQgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgdmFyIGZpbGUgPSBmaWxlSXRlbXNbaV0uZ2V0QXNGaWxlKCk7XG4gICAgICAgICAgICB1cGxvYWRSZXN1bHQucHVzaChhd2FpdCBpbWFnZVByb2Nlc3NvcihldiwgZmlsZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cGxvYWRSZXN1bHQucHVzaChhd2FpdCBpbWFnZVByb2Nlc3NvcihldiwgZmlsZUl0ZW1zW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvcnMgPSBlO1xuICAgIHVwbG9hZFJlc3VsdCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHsgdXBsb2FkUmVzdWx0LCBlcnJvcnMgfTtcbn1cblxuIiwiaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHsgaXMgfSBmcm9tICcuL01vZGVsVXRpbCc7XG5cblxuZXhwb3J0IHZhciBERUZBVUxUX0xBQkVMX1NJWkUgPSB7XG4gIHdpZHRoOiA5MCxcbiAgaGVpZ2h0OiAyMFxufTtcblxuZXhwb3J0IHZhciBGTE9XX0xBQkVMX0lOREVOVCA9IDE1O1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzZW1hbnRpYyBoYXMgYW4gZXh0ZXJuYWwgbGFiZWxcbiAqXG4gKiBAcGFyYW0ge0JvYXJkRWxlbWVudH0gc2VtYW50aWNcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgaGFzIGxhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xhYmVsRXh0ZXJuYWwoc2VtYW50aWMpIHtcbiAgcmV0dXJuIGlzKHNlbWFudGljLCAncG9zdGl0Okdyb3VwJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBlbGVtZW50IGhhcyBhbiBleHRlcm5hbCBsYWJlbFxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLnNoYXBlfSBlbGVtZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGhhcyBsYWJlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRXh0ZXJuYWxMYWJlbChlbGVtZW50KSB7XG4gIHJldHVybiBpc0xhYmVsKGVsZW1lbnQubGFiZWwpO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBtaWRkbGUgb2YgYSBudW1iZXIgb2Ygd2F5cG9pbnRzXG4gKlxuICogQHBhcmFtICB7QXJyYXk8UG9pbnQ+fSB3YXlwb2ludHNcbiAqIEByZXR1cm4ge1BvaW50fSB0aGUgbWlkIHBvaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXYXlwb2ludHNNaWQod2F5cG9pbnRzKSB7XG5cbiAgdmFyIG1pZCA9IHdheXBvaW50cy5sZW5ndGggLyAyIC0gMTtcblxuICB2YXIgZmlyc3QgPSB3YXlwb2ludHNbTWF0aC5mbG9vcihtaWQpXTtcbiAgdmFyIHNlY29uZCA9IHdheXBvaW50c1tNYXRoLmNlaWwobWlkICsgMC4wMSldO1xuXG4gIHJldHVybiB7XG4gICAgeDogZmlyc3QueCArIChzZWNvbmQueCAtIGZpcnN0LngpIC8gMixcbiAgICB5OiBmaXJzdC55ICsgKHNlY29uZC55IC0gZmlyc3QueSkgLyAyXG4gIH07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVybmFsTGFiZWxNaWQoZWxlbWVudCkge1xuXG4gIGlmIChpcyhlbGVtZW50LCAncG9zdGl0Okdyb3VwJykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZWxlbWVudC54ICsgZWxlbWVudC53aWR0aCAvIDIsXG4gICAgICB5OiBlbGVtZW50LnkgKyBERUZBVUxUX0xBQkVMX1NJWkUuaGVpZ2h0IC8gMlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGVsZW1lbnQueCArIGVsZW1lbnQud2lkdGggLyAyLFxuICAgICAgeTogZWxlbWVudC55ICsgZWxlbWVudC5oZWlnaHQgKyBERUZBVUxUX0xBQkVMX1NJWkUuaGVpZ2h0IC8gMlxuICAgIH07XG4gIH1cbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJvdW5kcyBvZiBhbiBlbGVtZW50cyBsYWJlbCwgcGFyc2VkIGZyb20gdGhlIGVsZW1lbnRzIERJIG9yXG4gKiBnZW5lcmF0ZWQgZnJvbSBpdHMgYm91bmRzLlxuICpcbiAqIEBwYXJhbSB7Qm9hcmRFbGVtZW50fSBzZW1hbnRpY1xuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kcyhzZW1hbnRpYywgZWxlbWVudCkge1xuXG4gIHZhciBtaWQsXG4gICAgICBzaXplLFxuICAgICAgYm91bmRzLFxuICAgICAgZGkgPSBzZW1hbnRpYy5kaSxcbiAgICAgIGxhYmVsID0gZGkubGFiZWw7XG5cbiAgaWYgKGxhYmVsICYmIGxhYmVsLmJvdW5kcykge1xuICAgIGJvdW5kcyA9IGxhYmVsLmJvdW5kcztcblxuICAgIHNpemUgPSB7XG4gICAgICB3aWR0aDogTWF0aC5tYXgoREVGQVVMVF9MQUJFTF9TSVpFLndpZHRoLCBib3VuZHMud2lkdGgpLFxuICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0XG4gICAgfTtcblxuICAgIG1pZCA9IHtcbiAgICAgIHg6IGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMixcbiAgICAgIHk6IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCAvIDJcbiAgICB9O1xuICB9IGVsc2Uge1xuXG4gICAgbWlkID0gZ2V0RXh0ZXJuYWxMYWJlbE1pZChlbGVtZW50KTtcblxuICAgIHNpemUgPSBERUZBVUxUX0xBQkVMX1NJWkU7XG4gIH1cblxuICByZXR1cm4gYXNzaWduKHtcbiAgICB4OiBtaWQueCAtIHNpemUud2lkdGggLyAyLFxuICAgIHk6IG1pZC55IC0gc2l6ZS5oZWlnaHQgLyAyXG4gIH0sIHNpemUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMYWJlbChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ICYmICEhZWxlbWVudC5sYWJlbFRhcmdldDtcbn1cbiIsIi8qKlxuICogSXMgYW4gZWxlbWVudCBvZiB0aGUgZ2l2ZW4gcG9zdGl0IHR5cGU/XG4gKlxuICogQHBhcmFtICB7ZGpzLm1vZGVsLkJhc2V8TW9kZGxlRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzKGVsZW1lbnQsIHR5cGUpIHtcbiAgdmFyIGJvID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XG5cbiAgcmV0dXJuIGJvICYmICh0eXBlb2YgYm8uJGluc3RhbmNlT2YgPT09ICdmdW5jdGlvbicpICYmIGJvLiRpbnN0YW5jZU9mKHR5cGUpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBidXNpbmVzcyBvYmplY3QgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtkanMubW9kZWwuQmFzZXxNb2RkbGVFbGVtZW50fSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7TW9kZGxlRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIChlbGVtZW50ICYmIGVsZW1lbnQuYnVzaW5lc3NPYmplY3QpIHx8IGVsZW1lbnQ7XG59IiwiZXhwb3J0IGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXZlbnQpIHtcbiAgZXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgdmFyIHBhZ2VYID0gZXZlbnQucGFnZVg7XG4gIHZhciBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXG4gIC8vIElFIDhcbiAgaWYgKHBhZ2VYID09PSB1bmRlZmluZWQpIHtcbiAgICBwYWdlWCA9IGV2ZW50LmNsaWVudFggKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBwYWdlWSA9IGV2ZW50LmNsaWVudFkgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICByZXR1cm4geyBwYWdlWCwgcGFnZVkgfTtcbn1cblxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9jc3Nlc2NhcGUgdjEuNS4xIGJ5IEBtYXRoaWFzIHwgTUlUIGxpY2Vuc2UgKi9cbjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kL2Jsb2IvbWFzdGVyL3JldHVybkV4cG9ydHMuanNcblx0aWYgKHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnKSB7XG5cdFx0Ly8gRm9yIE5vZGUuanMuXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJvb3QpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gRm9yIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoW10sIGZhY3RvcnkuYmluZChyb290LCByb290KSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gRm9yIGJyb3dzZXIgZ2xvYmFscyAobm90IGV4cG9zaW5nIHRoZSBmdW5jdGlvbiBzZXBhcmF0ZWx5KS5cblx0XHRmYWN0b3J5KHJvb3QpO1xuXHR9XG59KHR5cGVvZiBnbG9iYWwgIT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0aGlzLCBmdW5jdGlvbihyb290KSB7XG5cblx0aWYgKHJvb3QuQ1NTICYmIHJvb3QuQ1NTLmVzY2FwZSkge1xuXHRcdHJldHVybiByb290LkNTUy5lc2NhcGU7XG5cdH1cblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3NlcmlhbGl6ZS1hbi1pZGVudGlmaWVyXG5cdHZhciBjc3NFc2NhcGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2BDU1MuZXNjYXBlYCByZXF1aXJlcyBhbiBhcmd1bWVudC4nKTtcblx0XHR9XG5cdFx0dmFyIHN0cmluZyA9IFN0cmluZyh2YWx1ZSk7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVVbml0O1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHR2YXIgZmlyc3RDb2RlVW5pdCA9IHN0cmluZy5jaGFyQ29kZUF0KDApO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlVW5pdCA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcblx0XHRcdC8vIE5vdGU6IHRoZXJl4oCZcyBubyBuZWVkIHRvIHNwZWNpYWwtY2FzZSBhc3RyYWwgc3ltYm9scywgc3Vycm9nYXRlXG5cdFx0XHQvLyBwYWlycywgb3IgbG9uZSBzdXJyb2dhdGVzLlxuXG5cdFx0XHQvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIE5VTEwgKFUrMDAwMCksIHRoZW4gdGhlIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0Ly8gKFUrRkZGRCkuXG5cdFx0XHRpZiAoY29kZVVuaXQgPT0gMHgwMDAwKSB7XG5cdFx0XHRcdHJlc3VsdCArPSAnXFx1RkZGRCc7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgaW4gdGhlIHJhbmdlIFtcXDEtXFwxRl0gKFUrMDAwMSB0byBVKzAwMUYpIG9yIGlzXG5cdFx0XHRcdC8vIFUrMDA3RiwgW+KApl1cblx0XHRcdFx0KGNvZGVVbml0ID49IDB4MDAwMSAmJiBjb2RlVW5pdCA8PSAweDAwMUYpIHx8IGNvZGVVbml0ID09IDB4MDA3RiB8fFxuXHRcdFx0XHQvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGlzIGluIHRoZSByYW5nZSBbMC05XVxuXHRcdFx0XHQvLyAoVSswMDMwIHRvIFUrMDAzOSksIFvigKZdXG5cdFx0XHRcdChpbmRleCA9PSAwICYmIGNvZGVVbml0ID49IDB4MDAzMCAmJiBjb2RlVW5pdCA8PSAweDAwMzkpIHx8XG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgdGhlIHNlY29uZCBjaGFyYWN0ZXIgYW5kIGlzIGluIHRoZSByYW5nZSBbMC05XVxuXHRcdFx0XHQvLyAoVSswMDMwIHRvIFUrMDAzOSkgYW5kIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgYSBgLWAgKFUrMDAyRCksIFvigKZdXG5cdFx0XHRcdChcblx0XHRcdFx0XHRpbmRleCA9PSAxICYmXG5cdFx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDMwICYmIGNvZGVVbml0IDw9IDB4MDAzOSAmJlxuXHRcdFx0XHRcdGZpcnN0Q29kZVVuaXQgPT0gMHgwMDJEXG5cdFx0XHRcdClcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2VzY2FwZS1hLWNoYXJhY3Rlci1hcy1jb2RlLXBvaW50XG5cdFx0XHRcdHJlc3VsdCArPSAnXFxcXCcgKyBjb2RlVW5pdC50b1N0cmluZygxNikgKyAnICc7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXMgYSBgLWAgKFUrMDAyRCksIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBzZWNvbmQgY2hhcmFjdGVyLCBb4oCmXVxuXHRcdFx0XHRpbmRleCA9PSAwICYmXG5cdFx0XHRcdGxlbmd0aCA9PSAxICYmXG5cdFx0XHRcdGNvZGVVbml0ID09IDB4MDAyRFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJlc3VsdCArPSAnXFxcXCcgKyBzdHJpbmcuY2hhckF0KGluZGV4KTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgbm90IGhhbmRsZWQgYnkgb25lIG9mIHRoZSBhYm92ZSBydWxlcyBhbmQgaXNcblx0XHRcdC8vIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBVKzAwODAsIGlzIGAtYCAoVSswMDJEKSBvciBgX2AgKFUrMDA1RiksIG9yXG5cdFx0XHQvLyBpcyBpbiBvbmUgb2YgdGhlIHJhbmdlcyBbMC05XSAoVSswMDMwIHRvIFUrMDAzOSksIFtBLVpdIChVKzAwNDEgdG9cblx0XHRcdC8vIFUrMDA1QSksIG9yIFthLXpdIChVKzAwNjEgdG8gVSswMDdBKSwgW+KApl1cblx0XHRcdGlmIChcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDgwIHx8XG5cdFx0XHRcdGNvZGVVbml0ID09IDB4MDAyRCB8fFxuXHRcdFx0XHRjb2RlVW5pdCA9PSAweDAwNUYgfHxcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDMwICYmIGNvZGVVbml0IDw9IDB4MDAzOSB8fFxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwNDEgJiYgY29kZVVuaXQgPD0gMHgwMDVBIHx8XG5cdFx0XHRcdGNvZGVVbml0ID49IDB4MDA2MSAmJiBjb2RlVW5pdCA8PSAweDAwN0Fcblx0XHRcdCkge1xuXHRcdFx0XHQvLyB0aGUgY2hhcmFjdGVyIGl0c2VsZlxuXHRcdFx0XHRyZXN1bHQgKz0gc3RyaW5nLmNoYXJBdChpbmRleCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cblx0XHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jZXNjYXBlLWEtY2hhcmFjdGVyXG5cdFx0XHRyZXN1bHQgKz0gJ1xcXFwnICsgc3RyaW5nLmNoYXJBdChpbmRleCk7XG5cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRpZiAoIXJvb3QuQ1NTKSB7XG5cdFx0cm9vdC5DU1MgPSB7fTtcblx0fVxuXG5cdHJvb3QuQ1NTLmVzY2FwZSA9IGNzc0VzY2FwZTtcblx0cmV0dXJuIGNzc0VzY2FwZTtcblxufSkpO1xuIiwiaW1wb3J0IEludGVyYWN0aW9uRXZlbnRzTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2ludGVyYWN0aW9uLWV2ZW50cyc7XG5cbmltcG9ydCBEaXJlY3RFZGl0aW5nIGZyb20gJy4vbGliL0RpcmVjdEVkaXRpbmcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgSW50ZXJhY3Rpb25FdmVudHNNb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFsgJ2RpcmVjdEVkaXRpbmcnIF0sXG4gIGRpcmVjdEVkaXRpbmc6IFsgJ3R5cGUnLCBEaXJlY3RFZGl0aW5nIF1cbn07IiwiaW1wb3J0IHtcbiAgYmluZCxcbiAgZmluZFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCBUZXh0Qm94IGZyb20gJy4vVGV4dEJveCc7XG5cblxuLyoqXG4gKiBBIGRpcmVjdCBlZGl0aW5nIGNvbXBvbmVudCB0aGF0IGFsbG93cyB1c2Vyc1xuICogdG8gZWRpdCBhbiBlbGVtZW50cyB0ZXh0IGRpcmVjdGx5IGluIHRoZSBkaWFncmFtXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXMgdGhlIGV2ZW50IGJ1c1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEaXJlY3RFZGl0aW5nKGV2ZW50QnVzLCBjYW52YXMpIHtcblxuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuXG4gIHRoaXMuX3Byb3ZpZGVycyA9IFtdO1xuICB0aGlzLl90ZXh0Ym94ID0gbmV3IFRleHRCb3goe1xuICAgIGNvbnRhaW5lcjogY2FudmFzLmdldENvbnRhaW5lcigpLFxuICAgIGtleUhhbmRsZXI6IGJpbmQodGhpcy5faGFuZGxlS2V5LCB0aGlzKSxcbiAgICByZXNpemVIYW5kbGVyOiBiaW5kKHRoaXMuX2hhbmRsZVJlc2l6ZSwgdGhpcylcbiAgfSk7XG59XG5cbkRpcmVjdEVkaXRpbmcuJGluamVjdCA9IFsgJ2V2ZW50QnVzJywgJ2NhbnZhcycgXTtcblxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgZGlyZWN0IGVkaXRpbmcgcHJvdmlkZXJcblxuICogQHBhcmFtIHtPYmplY3R9IHByb3ZpZGVyIHRoZSBwcm92aWRlciwgbXVzdCBleHBvc2UgYW4gI2FjdGl2YXRlKGVsZW1lbnQpIG1ldGhvZCB0aGF0IHJldHVybnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhY3RpdmF0aW9uIGNvbnRleHQgKHsgYm91bmRzOiB7eCwgeSwgd2lkdGgsIGhlaWdodCB9LCB0ZXh0IH0pIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0IGVkaXRpbmcgaXMgYXZhaWxhYmxlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBBZGRpdGlvbmFsbHkgdGhlIHByb3ZpZGVyIG11c3QgZXhwb3NlIGEgI3VwZGF0ZShlbGVtZW50LCB2YWx1ZSkgbWV0aG9kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gcmVjZWl2ZSBkaXJlY3QgZWRpdGluZyB1cGRhdGVzLlxuICovXG5EaXJlY3RFZGl0aW5nLnByb3RvdHlwZS5yZWdpc3RlclByb3ZpZGVyID0gZnVuY3Rpb24ocHJvdmlkZXIpIHtcbiAgdGhpcy5fcHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBkaXJlY3QgZWRpdGluZyBpcyBjdXJyZW50bHkgYWN0aXZlXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuRGlyZWN0RWRpdGluZy5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhdGhpcy5fYWN0aXZlO1xufTtcblxuXG4vKipcbiAqIENhbmNlbCBkaXJlY3QgZWRpdGluZywgaWYgaXQgaXMgY3VycmVudGx5IGFjdGl2ZVxuICovXG5EaXJlY3RFZGl0aW5nLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9maXJlKCdjYW5jZWwnKTtcbiAgdGhpcy5jbG9zZSgpO1xufTtcblxuXG5EaXJlY3RFZGl0aW5nLnByb3RvdHlwZS5fZmlyZSA9IGZ1bmN0aW9uKGV2ZW50LCBjb250ZXh0KSB7XG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2RpcmVjdEVkaXRpbmcuJyArIGV2ZW50LCBjb250ZXh0IHx8IHsgYWN0aXZlOiB0aGlzLl9hY3RpdmUgfSk7XG59O1xuXG5EaXJlY3RFZGl0aW5nLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl90ZXh0Ym94LmRlc3Ryb3koKTtcblxuICB0aGlzLl9maXJlKCdkZWFjdGl2YXRlJyk7XG5cbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcblxuICB0aGlzLnJlc2l6YWJsZSA9IHVuZGVmaW5lZDtcbn07XG5cblxuRGlyZWN0RWRpdGluZy5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuXG4gIGlmICghYWN0aXZlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5lckJvdW5kcyxcbiAgICAgIHByZXZpb3VzQm91bmRzID0gYWN0aXZlLmNvbnRleHQuYm91bmRzLFxuICAgICAgbmV3Qm91bmRzID0gdGhpcy4kdGV4dGJveC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIG5ld1RleHQgPSB0aGlzLmdldFZhbHVlKCksXG4gICAgICBwcmV2aW91c1RleHQgPSBhY3RpdmUuY29udGV4dC50ZXh0O1xuXG4gIGlmIChcbiAgICBuZXdUZXh0ICE9PSBwcmV2aW91c1RleHQgfHxcbiAgICBuZXdCb3VuZHMuaGVpZ2h0ICE9PSBwcmV2aW91c0JvdW5kcy5oZWlnaHQgfHxcbiAgICBuZXdCb3VuZHMud2lkdGggIT09IHByZXZpb3VzQm91bmRzLndpZHRoXG4gICkge1xuICAgIGNvbnRhaW5lckJvdW5kcyA9IHRoaXMuX3RleHRib3guY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgYWN0aXZlLnByb3ZpZGVyLnVwZGF0ZShhY3RpdmUuZWxlbWVudCwgbmV3VGV4dCwgYWN0aXZlLmNvbnRleHQudGV4dCwge1xuICAgICAgeDogbmV3Qm91bmRzLmxlZnQgLSBjb250YWluZXJCb3VuZHMubGVmdCxcbiAgICAgIHk6IG5ld0JvdW5kcy50b3AgLSBjb250YWluZXJCb3VuZHMudG9wLFxuICAgICAgd2lkdGg6IG5ld0JvdW5kcy53aWR0aCxcbiAgICAgIGhlaWdodDogbmV3Qm91bmRzLmhlaWdodFxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5fZmlyZSgnY29tcGxldGUnKTtcblxuICB0aGlzLmNsb3NlKCk7XG59O1xuXG5cbkRpcmVjdEVkaXRpbmcucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90ZXh0Ym94LmdldFZhbHVlKCk7XG59O1xuXG5cbkRpcmVjdEVkaXRpbmcucHJvdG90eXBlLl9oYW5kbGVLZXkgPSBmdW5jdGlvbihlKSB7XG5cbiAgLy8gc3RvcCBidWJibGVcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICB2YXIga2V5ID0gZS5rZXlDb2RlIHx8IGUuY2hhckNvZGU7XG5cbiAgLy8gRVNDXG4gIGlmIChrZXkgPT09IDI3KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiB0aGlzLmNhbmNlbCgpO1xuICB9XG5cbiAgLy8gRW50ZXJcbiAgaWYgKGtleSA9PT0gMTMgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGxldGUoKTtcbiAgfVxufTtcblxuXG5EaXJlY3RFZGl0aW5nLnByb3RvdHlwZS5faGFuZGxlUmVzaXplID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdGhpcy5fZmlyZSgncmVzaXplJywgZXZlbnQpO1xufTtcblxuXG4vKipcbiAqIEFjdGl2YXRlIGRpcmVjdCBlZGl0aW5nIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IEVsZW1lbnREZXNjcmlwdG9yIHRoZSBkZXNjcmlwdG9yIGZvciBhIHNoYXBlIG9yIGNvbm5lY3Rpb25cbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFjdGl2YXRpb24gd2FzIHBvc3NpYmxlXG4gKi9cbkRpcmVjdEVkaXRpbmcucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgdGhpcy5jYW5jZWwoKTtcbiAgfVxuXG4gIC8vIHRoZSBkaXJlY3QgZWRpdGluZyBjb250ZXh0XG4gIHZhciBjb250ZXh0O1xuXG4gIHZhciBwcm92aWRlciA9IGZpbmQodGhpcy5fcHJvdmlkZXJzLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIChjb250ZXh0ID0gcC5hY3RpdmF0ZShlbGVtZW50KSkgPyBwIDogbnVsbDtcbiAgfSk7XG5cbiAgLy8gY2hlY2sgaWYgYWN0aXZhdGlvbiB0b29rIHBsYWNlXG4gIGlmIChjb250ZXh0KSB7XG4gICAgdGhpcy4kdGV4dGJveCA9IHRoaXMuX3RleHRib3guY3JlYXRlKFxuICAgICAgY29udGV4dC5ib3VuZHMsXG4gICAgICBjb250ZXh0LnN0eWxlLFxuICAgICAgY29udGV4dC50ZXh0LFxuICAgICAgY29udGV4dC5vcHRpb25zXG4gICAgKTtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyXG4gICAgfTtcblxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMgJiYgY29udGV4dC5vcHRpb25zLnJlc2l6YWJsZSkge1xuICAgICAgdGhpcy5yZXNpemFibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpcmUoJ2FjdGl2YXRlJyk7XG4gIH1cblxuICByZXR1cm4gISFjb250ZXh0O1xufTtcbiIsImltcG9ydCB7XG4gIGFzc2lnbixcbiAgYmluZCxcbiAgcGlja1xufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGRvbWlmeSxcbiAgcXVlcnkgYXMgZG9tUXVlcnksXG4gIGV2ZW50IGFzIGRvbUV2ZW50LFxuICByZW1vdmUgYXMgZG9tUmVtb3ZlXG59IGZyb20gJ21pbi1kb20nO1xuXG52YXIgbWluID0gTWF0aC5taW4sXG4gICAgbWF4ID0gTWF0aC5tYXg7XG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZSkge1xuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KG5vZGVMaXN0KSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKG5vZGVMaXN0KTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGNvbnRhaW5lciBmb3IgYSBjb250ZW50IGVkaXRhYmxlIGRpdi5cbiAqXG4gKiBTdHJ1Y3R1cmU6XG4gKlxuICogY29udGFpbmVyXG4gKiAgIHBhcmVudFxuICogICAgIGNvbnRlbnRcbiAqICAgICByZXNpemUtaGFuZGxlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3B0aW9ucy5jb250YWluZXIgVGhlIERPTSBlbGVtZW50IHRvIGFwcGVuZCB0aGUgY29udGVudENvbnRhaW5lciB0b1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5rZXlIYW5kbGVyIEhhbmRsZXIgZm9yIGtleSBldmVudHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMucmVzaXplSGFuZGxlciBIYW5kbGVyIGZvciByZXNpemUgZXZlbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRleHRCb3gob3B0aW9ucykge1xuICB0aGlzLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuXG4gIHRoaXMucGFyZW50ID0gZG9taWZ5KFxuICAgICc8ZGl2IGNsYXNzPVwiZGpzLWRpcmVjdC1lZGl0aW5nLXBhcmVudFwiPicgK1xuICAgICAgJzxkaXYgY2xhc3M9XCJkanMtZGlyZWN0LWVkaXRpbmctY29udGVudFwiIGNvbnRlbnRlZGl0YWJsZT1cInRydWVcIj48L2Rpdj4nICtcbiAgICAnPC9kaXY+J1xuICApO1xuXG4gIHRoaXMuY29udGVudCA9IGRvbVF1ZXJ5KCdbY29udGVudGVkaXRhYmxlXScsIHRoaXMucGFyZW50KTtcblxuICB0aGlzLmtleUhhbmRsZXIgPSBvcHRpb25zLmtleUhhbmRsZXIgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdGhpcy5yZXNpemVIYW5kbGVyID0gb3B0aW9ucy5yZXNpemVIYW5kbGVyIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgdGhpcy5hdXRvUmVzaXplID0gYmluZCh0aGlzLmF1dG9SZXNpemUsIHRoaXMpO1xuICB0aGlzLmhhbmRsZVBhc3RlID0gYmluZCh0aGlzLmhhbmRsZVBhc3RlLCB0aGlzKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIHRleHQgYm94IHdpdGggdGhlIGdpdmVuIHBvc2l0aW9uLCBzaXplLCBzdHlsZSBhbmQgdGV4dCBjb250ZW50XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGJvdW5kc1xuICogQHBhcmFtIHtOdW1iZXJ9IGJvdW5kcy54IGFic29sdXRlIHggcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3VuZHMueSBhYnNvbHV0ZSB5IHBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy53aWR0aF0gZml4ZWQgd2lkdGggdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLmhlaWdodF0gZml4ZWQgaGVpZ2h0IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy5tYXhXaWR0aF0gbWF4aW11bSB3aWR0aCB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMubWF4SGVpZ2h0XSBtYXhpbXVtIGhlaWdodCB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMubWluV2lkdGhdIG1pbmltdW0gd2lkdGggdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLm1pbkhlaWdodF0gbWluaW11bSBoZWlnaHQgdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVdXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdGV4dCBjb250ZW50XG4gKlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gVGhlIGNyZWF0ZWQgY29udGVudCBET00gZWxlbWVudFxuICovXG5UZXh0Qm94LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihib3VuZHMsIHN0eWxlLCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgY29udGVudCA9IHRoaXMuY29udGVudCxcbiAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuXG4gIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHN0eWxlID0gdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9O1xuXG4gIHZhciBwYXJlbnRTdHlsZSA9IHBpY2soc3R5bGUsIFtcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnLFxuICAgICdtYXhXaWR0aCcsXG4gICAgJ21heEhlaWdodCcsXG4gICAgJ21pbldpZHRoJyxcbiAgICAnbWluSGVpZ2h0JyxcbiAgICAnbGVmdCcsXG4gICAgJ3RvcCcsXG4gICAgJ2JhY2tncm91bmRDb2xvcicsXG4gICAgJ3Bvc2l0aW9uJyxcbiAgICAnb3ZlcmZsb3cnLFxuICAgICdib3JkZXInLFxuICAgICd3b3JkV3JhcCcsXG4gICAgJ3RleHRBbGlnbicsXG4gICAgJ291dGxpbmUnLFxuICAgICd0cmFuc2Zvcm0nXG4gIF0pO1xuXG4gIGFzc2lnbihwYXJlbnQuc3R5bGUsIHtcbiAgICB3aWR0aDogYm91bmRzLndpZHRoICsgJ3B4JyxcbiAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQgKyAncHgnLFxuICAgIG1heFdpZHRoOiBib3VuZHMubWF4V2lkdGggKyAncHgnLFxuICAgIG1heEhlaWdodDogYm91bmRzLm1heEhlaWdodCArICdweCcsXG4gICAgbWluV2lkdGg6IGJvdW5kcy5taW5XaWR0aCArICdweCcsXG4gICAgbWluSGVpZ2h0OiBib3VuZHMubWluSGVpZ2h0ICsgJ3B4JyxcbiAgICBsZWZ0OiBib3VuZHMueCArICdweCcsXG4gICAgdG9wOiBib3VuZHMueSArICdweCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZmZmZicsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcbiAgICBib3JkZXI6ICcxcHggc29saWQgI2NjYycsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgd29yZFdyYXA6ICdub3JtYWwnLFxuICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgb3V0bGluZTogJ25vbmUnXG4gIH0sIHBhcmVudFN0eWxlKTtcblxuICB2YXIgY29udGVudFN0eWxlID0gcGljayhzdHlsZSwgW1xuICAgICdmb250RmFtaWx5JyxcbiAgICAnZm9udFNpemUnLFxuICAgICdmb250V2VpZ2h0JyxcbiAgICAnbGluZUhlaWdodCcsXG4gICAgJ3BhZGRpbmcnLFxuICAgICdwYWRkaW5nVG9wJyxcbiAgICAncGFkZGluZ1JpZ2h0JyxcbiAgICAncGFkZGluZ0JvdHRvbScsXG4gICAgJ3BhZGRpbmdMZWZ0J1xuICBdKTtcblxuICBhc3NpZ24oY29udGVudC5zdHlsZSwge1xuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgb3V0bGluZTogJ25vbmUnLFxuICAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCdcbiAgfSwgY29udGVudFN0eWxlKTtcblxuICBpZiAob3B0aW9ucy5jZW50ZXJWZXJ0aWNhbGx5KSB7XG4gICAgYXNzaWduKGNvbnRlbnQuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnNTAlJyxcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLCAtNTAlKSdcbiAgICB9LCBjb250ZW50U3R5bGUpO1xuICB9XG5cbiAgY29udGVudC5pbm5lclRleHQgPSB2YWx1ZTtcblxuICBkb21FdmVudC5iaW5kKGNvbnRlbnQsICdrZXlkb3duJywgdGhpcy5rZXlIYW5kbGVyKTtcbiAgZG9tRXZlbnQuYmluZChjb250ZW50LCAnbW91c2Vkb3duJywgc3RvcFByb3BhZ2F0aW9uKTtcbiAgZG9tRXZlbnQuYmluZChjb250ZW50LCAncGFzdGUnLCBzZWxmLmhhbmRsZVBhc3RlKTtcblxuICBpZiAob3B0aW9ucy5hdXRvUmVzaXplKSB7XG4gICAgZG9tRXZlbnQuYmluZChjb250ZW50LCAnaW5wdXQnLCB0aGlzLmF1dG9SZXNpemUpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVzaXphYmxlKSB7XG4gICAgdGhpcy5yZXNpemFibGUoc3R5bGUpO1xuICB9XG5cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBhcmVudCk7XG5cbiAgLy8gc2V0IHNlbGVjdGlvbiB0byBlbmQgb2YgdGV4dFxuICB0aGlzLnNldFNlbGVjdGlvbihjb250ZW50Lmxhc3RDaGlsZCwgY29udGVudC5sYXN0Q2hpbGQgJiYgY29udGVudC5sYXN0Q2hpbGQubGVuZ3RoKTtcblxuICByZXR1cm4gcGFyZW50O1xufTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgcGFzdGUgZXZlbnRzIHRvIHJlbW92ZSBmb3JtYXR0aW5nIGZyb20gcGFzdGVkIHRleHQuXG4gKi9cblRleHRCb3gucHJvdG90eXBlLmhhbmRsZVBhc3RlID0gZnVuY3Rpb24oZSkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIHN0eWxlID0gdGhpcy5zdHlsZTtcblxuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgdmFyIHRleHQ7XG5cbiAgaWYgKGUuY2xpcGJvYXJkRGF0YSkge1xuXG4gICAgLy8gQ2hyb21lLCBGaXJlZm94LCBTYWZhcmlcbiAgICB0ZXh0ID0gZS5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgfSBlbHNlIHtcblxuICAgIC8vIEludGVybmV0IEV4cGxvcmVyXG4gICAgdGV4dCA9IHdpbmRvdy5jbGlwYm9hcmREYXRhLmdldERhdGEoJ1RleHQnKTtcbiAgfVxuXG4gIHRoaXMuaW5zZXJ0VGV4dCh0ZXh0KTtcblxuICBpZiAob3B0aW9ucy5hdXRvUmVzaXplKSB7XG4gICAgdmFyIGhhc1Jlc2l6ZWQgPSB0aGlzLmF1dG9SZXNpemUoc3R5bGUpO1xuXG4gICAgaWYgKGhhc1Jlc2l6ZWQpIHtcbiAgICAgIHRoaXMucmVzaXplSGFuZGxlcihoYXNSZXNpemVkKTtcbiAgICB9XG4gIH1cbn07XG5cblRleHRCb3gucHJvdG90eXBlLmluc2VydFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG5cbiAgLy8gaW5zZXJ0VGV4dCBjb21tYW5kIG5vdCBzdXBwb3J0ZWQgYnkgSW50ZXJuZXQgRXhwbG9yZXJcbiAgdmFyIHN1Y2Nlc3MgPSBkb2N1bWVudC5leGVjQ29tbWFuZCgnaW5zZXJ0VGV4dCcsIGZhbHNlLCB0ZXh0KTtcblxuICBpZiAoc3VjY2Vzcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2luc2VydFRleHRJRSh0ZXh0KTtcbn07XG5cblRleHRCb3gucHJvdG90eXBlLl9pbnNlcnRUZXh0SUUgPSBmdW5jdGlvbih0ZXh0KSB7XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXJcbiAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgIHN0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICBlbmRDb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXIsXG4gICAgICBzdGFydE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0LFxuICAgICAgZW5kT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0LFxuICAgICAgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICB2YXIgY2hpbGROb2Rlc0FycmF5ID0gdG9BcnJheShjb21tb25BbmNlc3RvckNvbnRhaW5lci5jaGlsZE5vZGVzKTtcblxuICB2YXIgY29udGFpbmVyLFxuICAgICAgb2Zmc2V0O1xuXG4gIGlmIChpc1RleHROb2RlKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgIHZhciBjb250YWluZXJUZXh0Q29udGVudCA9IHN0YXJ0Q29udGFpbmVyLnRleHRDb250ZW50O1xuXG4gICAgc3RhcnRDb250YWluZXIudGV4dENvbnRlbnQgPVxuICAgICAgY29udGFpbmVyVGV4dENvbnRlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KVxuICAgICAgKyB0ZXh0XG4gICAgICArIGNvbnRhaW5lclRleHRDb250ZW50LnN1YnN0cmluZyhlbmRPZmZzZXQpO1xuXG4gICAgY29udGFpbmVyID0gc3RhcnRDb250YWluZXI7XG4gICAgb2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyB0ZXh0Lmxlbmd0aDtcblxuICB9IGVsc2UgaWYgKHN0YXJ0Q29udGFpbmVyID09PSB0aGlzLmNvbnRlbnQgJiYgZW5kQ29udGFpbmVyID09PSB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcblxuICAgIHRoaXMuY29udGVudC5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIGNoaWxkTm9kZXNBcnJheVtzdGFydE9mZnNldF0pO1xuXG4gICAgY29udGFpbmVyID0gdGV4dE5vZGU7XG4gICAgb2Zmc2V0ID0gdGV4dE5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdGFydENvbnRhaW5lckNoaWxkSW5kZXggPSBjaGlsZE5vZGVzQXJyYXkuaW5kZXhPZihzdGFydENvbnRhaW5lciksXG4gICAgICAgIGVuZENvbnRhaW5lckNoaWxkSW5kZXggPSBjaGlsZE5vZGVzQXJyYXkuaW5kZXhPZihlbmRDb250YWluZXIpO1xuXG4gICAgY2hpbGROb2Rlc0FycmF5LmZvckVhY2goZnVuY3Rpb24oY2hpbGROb2RlLCBpbmRleCkge1xuXG4gICAgICBpZiAoaW5kZXggPT09IHN0YXJ0Q29udGFpbmVyQ2hpbGRJbmRleCkge1xuICAgICAgICBjaGlsZE5vZGUudGV4dENvbnRlbnQgPVxuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyLnRleHRDb250ZW50LnN1YnN0cmluZygwLCBzdGFydE9mZnNldCkgK1xuICAgICAgICAgIHRleHQgK1xuICAgICAgICAgIGVuZENvbnRhaW5lci50ZXh0Q29udGVudC5zdWJzdHJpbmcoZW5kT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiBzdGFydENvbnRhaW5lckNoaWxkSW5kZXggJiYgaW5kZXggPD0gZW5kQ29udGFpbmVyQ2hpbGRJbmRleCkge1xuICAgICAgICBkb21SZW1vdmUoY2hpbGROb2RlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnRhaW5lciA9IHN0YXJ0Q29udGFpbmVyO1xuICAgIG9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgdGV4dC5sZW5ndGg7XG4gIH1cblxuICBpZiAoY29udGFpbmVyICYmIG9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAvLyBpcyBuZWNlc3NhcnkgaW4gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5zZXRTZWxlY3Rpb24oY29udGFpbmVyLCBvZmZzZXQpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgcmVzaXplIGVsZW1lbnQgdmVydGljYWxseSB0byBmaXQgaXRzIGNvbnRlbnQuXG4gKi9cblRleHRCb3gucHJvdG90eXBlLmF1dG9SZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgY29udGVudCA9IHRoaXMuY29udGVudDtcblxuICB2YXIgZm9udFNpemUgPSBwYXJzZUludCh0aGlzLnN0eWxlLmZvbnRTaXplKSB8fCAxMjtcblxuICBpZiAoY29udGVudC5zY3JvbGxIZWlnaHQgPiBwYXJlbnQub2Zmc2V0SGVpZ2h0IHx8XG4gICAgICBjb250ZW50LnNjcm9sbEhlaWdodCA8IHBhcmVudC5vZmZzZXRIZWlnaHQgLSBmb250U2l6ZSkge1xuICAgIHZhciBib3VuZHMgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICB2YXIgaGVpZ2h0ID0gY29udGVudC5zY3JvbGxIZWlnaHQ7XG4gICAgcGFyZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXIoe1xuICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodCxcbiAgICAgIGR4OiAwLFxuICAgICAgZHk6IGhlaWdodCAtIGJvdW5kcy5oZWlnaHRcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYWtlIGFuIGVsZW1lbnQgcmVzaXphYmxlIGJ5IGFkZGluZyBhIHJlc2l6ZSBoYW5kbGUuXG4gKi9cblRleHRCb3gucHJvdG90eXBlLnJlc2l6YWJsZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgcmVzaXplSGFuZGxlID0gdGhpcy5yZXNpemVIYW5kbGU7XG5cbiAgdmFyIG1pbldpZHRoID0gcGFyc2VJbnQodGhpcy5zdHlsZS5taW5XaWR0aCkgfHwgMCxcbiAgICAgIG1pbkhlaWdodCA9IHBhcnNlSW50KHRoaXMuc3R5bGUubWluSGVpZ2h0KSB8fCAwLFxuICAgICAgbWF4V2lkdGggPSBwYXJzZUludCh0aGlzLnN0eWxlLm1heFdpZHRoKSB8fCBJbmZpbml0eSxcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlSW50KHRoaXMuc3R5bGUubWF4SGVpZ2h0KSB8fCBJbmZpbml0eTtcblxuICBpZiAoIXJlc2l6ZUhhbmRsZSkge1xuICAgIHJlc2l6ZUhhbmRsZSA9IHRoaXMucmVzaXplSGFuZGxlID0gZG9taWZ5KFxuICAgICAgJzxkaXYgY2xhc3M9XCJkanMtZGlyZWN0LWVkaXRpbmctcmVzaXplLWhhbmRsZVwiPjwvZGl2PidcbiAgICApO1xuXG4gICAgdmFyIHN0YXJ0WCwgc3RhcnRZLCBzdGFydFdpZHRoLCBzdGFydEhlaWdodDtcblxuICAgIHZhciBvbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgc3RvcFByb3BhZ2F0aW9uKGUpO1xuXG4gICAgICBzdGFydFggPSBlLmNsaWVudFg7XG4gICAgICBzdGFydFkgPSBlLmNsaWVudFk7XG5cbiAgICAgIHZhciBib3VuZHMgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHN0YXJ0V2lkdGggPSBib3VuZHMud2lkdGg7XG4gICAgICBzdGFydEhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgIGRvbUV2ZW50LmJpbmQoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgICBkb21FdmVudC5iaW5kKGRvY3VtZW50LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgfTtcblxuICAgIHZhciBvbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgc3RvcFByb3BhZ2F0aW9uKGUpO1xuXG4gICAgICB2YXIgbmV3V2lkdGggPSBtaW4obWF4KHN0YXJ0V2lkdGggKyBlLmNsaWVudFggLSBzdGFydFgsIG1pbldpZHRoKSwgbWF4V2lkdGgpO1xuICAgICAgdmFyIG5ld0hlaWdodCA9IG1pbihtYXgoc3RhcnRIZWlnaHQgKyBlLmNsaWVudFkgLSBzdGFydFksIG1pbkhlaWdodCksIG1heEhlaWdodCk7XG5cbiAgICAgIHBhcmVudC5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4JztcbiAgICAgIHBhcmVudC5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyAncHgnO1xuXG4gICAgICBzZWxmLnJlc2l6ZUhhbmRsZXIoe1xuICAgICAgICB3aWR0aDogc3RhcnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzdGFydEhlaWdodCxcbiAgICAgICAgZHg6IGUuY2xpZW50WCAtIHN0YXJ0WCxcbiAgICAgICAgZHk6IGUuY2xpZW50WSAtIHN0YXJ0WVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBvbk1vdXNlVXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIHN0b3BQcm9wYWdhdGlvbihlKTtcblxuICAgICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgIH07XG5cbiAgICBkb21FdmVudC5iaW5kKHJlc2l6ZUhhbmRsZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgfVxuXG4gIGFzc2lnbihyZXNpemVIYW5kbGUuc3R5bGUsIHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBib3R0b206ICcwcHgnLFxuICAgIHJpZ2h0OiAnMHB4JyxcbiAgICBjdXJzb3I6ICdud3NlLXJlc2l6ZScsXG4gICAgd2lkdGg6ICcwJyxcbiAgICBoZWlnaHQ6ICcwJyxcbiAgICBib3JkZXJUb3A6IChwYXJzZUludCh0aGlzLnN0eWxlLmZvbnRTaXplKSAvIDQgfHwgMykgKyAncHggc29saWQgdHJhbnNwYXJlbnQnLFxuICAgIGJvcmRlclJpZ2h0OiAocGFyc2VJbnQodGhpcy5zdHlsZS5mb250U2l6ZSkgLyA0IHx8IDMpICsgJ3B4IHNvbGlkICNjY2MnLFxuICAgIGJvcmRlckJvdHRvbTogKHBhcnNlSW50KHRoaXMuc3R5bGUuZm9udFNpemUpIC8gNCB8fCAzKSArICdweCBzb2xpZCAjY2NjJyxcbiAgICBib3JkZXJMZWZ0OiAocGFyc2VJbnQodGhpcy5zdHlsZS5mb250U2l6ZSkgLyA0IHx8IDMpICsgJ3B4IHNvbGlkIHRyYW5zcGFyZW50J1xuICB9KTtcblxuICBwYXJlbnQuYXBwZW5kQ2hpbGQocmVzaXplSGFuZGxlKTtcbn07XG5cblxuLyoqXG4gKiBDbGVhciBjb250ZW50IGFuZCBzdHlsZSBvZiB0aGUgdGV4dGJveCwgdW5iaW5kIGxpc3RlbmVycyBhbmRcbiAqIHJlc2V0IENTUyBzdHlsZS5cbiAqL1xuVGV4dEJveC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICBjb250ZW50ID0gdGhpcy5jb250ZW50LFxuICAgICAgcmVzaXplSGFuZGxlID0gdGhpcy5yZXNpemVIYW5kbGU7XG5cbiAgLy8gY2xlYXIgY29udGVudFxuICBjb250ZW50LmlubmVyVGV4dCA9ICcnO1xuXG4gIC8vIGNsZWFyIHN0eWxlc1xuICBwYXJlbnQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICBjb250ZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICBkb21FdmVudC51bmJpbmQoY29udGVudCwgJ2tleWRvd24nLCB0aGlzLmtleUhhbmRsZXIpO1xuICBkb21FdmVudC51bmJpbmQoY29udGVudCwgJ21vdXNlZG93bicsIHN0b3BQcm9wYWdhdGlvbik7XG4gIGRvbUV2ZW50LnVuYmluZChjb250ZW50LCAnaW5wdXQnLCB0aGlzLmF1dG9SZXNpemUpO1xuICBkb21FdmVudC51bmJpbmQoY29udGVudCwgJ3Bhc3RlJywgdGhpcy5oYW5kbGVQYXN0ZSk7XG5cbiAgaWYgKHJlc2l6ZUhhbmRsZSkge1xuICAgIHJlc2l6ZUhhbmRsZS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgICBkb21SZW1vdmUocmVzaXplSGFuZGxlKTtcbiAgfVxuXG4gIGRvbVJlbW92ZShwYXJlbnQpO1xufTtcblxuXG5UZXh0Qm94LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb250ZW50LmlubmVyVGV4dC50cmltKCk7XG59O1xuXG5cblRleHRCb3gucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpLFxuICAgICAgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICByZXR1cm4gcmFuZ2U7XG59O1xuXG5cblRleHRCb3gucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgb2Zmc2V0KSB7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyh0aGlzLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIHJhbmdlLnNldFN0YXJ0KGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoY29udGFpbmVyLCBvZmZzZXQpO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG59O1xuIiwiaW1wb3J0IHsgSW5qZWN0b3IgfSBmcm9tICdkaWRpJztcblxuaW1wb3J0IENvcmVNb2R1bGUgZnJvbSAnLi9jb3JlJztcblxuXG4vKipcbiAqIEJvb3RzdHJhcCBhbiBpbmplY3RvciBmcm9tIGEgbGlzdCBvZiBtb2R1bGVzLCBpbnN0YW50aWF0aW5nIGEgbnVtYmVyIG9mIGRlZmF1bHQgY29tcG9uZW50c1xuICpcbiAqIEBpZ25vcmVcbiAqIEBwYXJhbSB7QXJyYXk8ZGlkaS5Nb2R1bGU+fSBib290c3RyYXBNb2R1bGVzXG4gKlxuICogQHJldHVybiB7ZGlkaS5JbmplY3Rvcn0gYSBpbmplY3RvciB0byB1c2UgdG8gYWNjZXNzIHRoZSBjb21wb25lbnRzXG4gKi9cbmZ1bmN0aW9uIGJvb3RzdHJhcChib290c3RyYXBNb2R1bGVzKSB7XG5cbiAgdmFyIG1vZHVsZXMgPSBbXSxcbiAgICAgIGNvbXBvbmVudHMgPSBbXTtcblxuICBmdW5jdGlvbiBoYXNNb2R1bGUobSkge1xuICAgIHJldHVybiBtb2R1bGVzLmluZGV4T2YobSkgPj0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE1vZHVsZShtKSB7XG4gICAgbW9kdWxlcy5wdXNoKG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlzaXQobSkge1xuICAgIGlmIChoYXNNb2R1bGUobSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAobS5fX2RlcGVuZHNfXyB8fCBbXSkuZm9yRWFjaCh2aXNpdCk7XG5cbiAgICBpZiAoaGFzTW9kdWxlKG0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWRkTW9kdWxlKG0pO1xuXG4gICAgKG0uX19pbml0X18gfHwgW10pLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgY29tcG9uZW50cy5wdXNoKGMpO1xuICAgIH0pO1xuICB9XG5cbiAgYm9vdHN0cmFwTW9kdWxlcy5mb3JFYWNoKHZpc2l0KTtcblxuICB2YXIgaW5qZWN0b3IgPSBuZXcgSW5qZWN0b3IobW9kdWxlcyk7XG5cbiAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcblxuICAgIHRyeSB7XG5cbiAgICAgIC8vIGVhZ2VybHkgcmVzb2x2ZSBjb21wb25lbnQgKGZuIG9yIHN0cmluZylcbiAgICAgIGluamVjdG9yW3R5cGVvZiBjID09PSAnc3RyaW5nJyA/ICdnZXQnIDogJ2ludm9rZSddKGMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbnN0YW50aWF0ZSBjb21wb25lbnQnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5zdGFjayk7XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaW5qZWN0b3I7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbmplY3RvciBmcm9tIHBhc3NlZCBvcHRpb25zLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7ZGlkaS5JbmplY3Rvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5qZWN0b3Iob3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBjb25maWdNb2R1bGUgPSB7XG4gICAgJ2NvbmZpZyc6IFsndmFsdWUnLCBvcHRpb25zXVxuICB9O1xuXG4gIHZhciBtb2R1bGVzID0gWyBjb25maWdNb2R1bGUsIENvcmVNb2R1bGUgXS5jb25jYXQob3B0aW9ucy5tb2R1bGVzIHx8IFtdKTtcblxuICByZXR1cm4gYm9vdHN0cmFwKG1vZHVsZXMpO1xufVxuXG5cbi8qKlxuICogVGhlIG1haW4gZGlhZ3JhbS1qcyBlbnRyeSBwb2ludCB0aGF0IGJvb3RzdHJhcHMgdGhlIGRpYWdyYW0gd2l0aCB0aGUgZ2l2ZW5cbiAqIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogVG8gcmVnaXN0ZXIgZXh0ZW5zaW9ucyB3aXRoIHRoZSBkaWFncmFtLCBwYXNzIHRoZW0gYXMgQXJyYXk8ZGlkaS5Nb2R1bGU+IHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAY2xhc3MgZGpzLkRpYWdyYW1cbiAqIEBtZW1iZXJPZiBkanNcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogPGNhcHRpb24+Q3JlYXRpbmcgYSBwbHVnLWluIHRoYXQgbG9ncyB3aGVuZXZlciBhIHNoYXBlIGlzIGFkZGVkIHRvIHRoZSBjYW52YXMuPC9jYXB0aW9uPlxuICpcbiAqIC8vIHBsdWctaW4gaW1wbGVtZW5lbnRhdGlvblxuICogZnVuY3Rpb24gTXlMb2dnaW5nUGx1Z2luKGV2ZW50QnVzKSB7XG4gKiAgIGV2ZW50QnVzLm9uKCdzaGFwZS5hZGRlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgICAgY29uc29sZS5sb2coJ3NoYXBlICcsIGV2ZW50LnNoYXBlLCAnIHdhcyBhZGRlZCB0byB0aGUgZGlhZ3JhbScpO1xuICogICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBleHBvcnQgYXMgbW9kdWxlXG4gKiBleHBvcnQgZGVmYXVsdCB7XG4gKiAgIF9faW5pdF9fOiBbICdteUxvZ2dpbmdQbHVnaW4nIF0sXG4gKiAgICAgbXlMb2dnaW5nUGx1Z2luOiBbICd0eXBlJywgTXlMb2dnaW5nUGx1Z2luIF1cbiAqIH07XG4gKlxuICpcbiAqIC8vIGluc3RhbnRpYXRlIHRoZSBkaWFncmFtIHdpdGggdGhlIG5ldyBwbHVnLWluXG4gKlxuICogaW1wb3J0IE15TG9nZ2luZ01vZHVsZSBmcm9tICdwYXRoLXRvLW15LWxvZ2dpbmctcGx1Z2luJztcbiAqXG4gKiB2YXIgZGlhZ3JhbSA9IG5ldyBEaWFncmFtKHtcbiAqICAgbW9kdWxlczogW1xuICogICAgIE15TG9nZ2luZ01vZHVsZVxuICogICBdXG4gKiB9KTtcbiAqXG4gKiBkaWFncmFtLmludm9rZShbICdjYW52YXMnLCBmdW5jdGlvbihjYW52YXMpIHtcbiAqICAgLy8gYWRkIHNoYXBlIHRvIGRyYXdpbmcgY2FudmFzXG4gKiAgIGNhbnZhcy5hZGRTaGFwZSh7IHg6IDEwLCB5OiAxMCB9KTtcbiAqIH0pO1xuICpcbiAqIC8vICdzaGFwZSAuLi4gd2FzIGFkZGVkIHRvIHRoZSBkaWFncmFtJyBsb2dnZWQgdG8gY29uc29sZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5PGRpZGkuTW9kdWxlPn0gW29wdGlvbnMubW9kdWxlc10gZXh0ZXJuYWwgbW9kdWxlcyB0byBpbnN0YW50aWF0ZSB3aXRoIHRoZSBkaWFncmFtXG4gKiBAcGFyYW0ge2RpZGkuSW5qZWN0b3J9IFtpbmplY3Rvcl0gYW4gKG9wdGlvbmFsKSBpbmplY3RvciB0byBib290c3RyYXAgdGhlIGRpYWdyYW0gd2l0aFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEaWFncmFtKG9wdGlvbnMsIGluamVjdG9yKSB7XG5cbiAgLy8gY3JlYXRlIGluamVjdG9yIHVubGVzcyBleHBsaWNpdGx5IHNwZWNpZmllZFxuICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3IgPSBpbmplY3RvciB8fCBjcmVhdGVJbmplY3RvcihvcHRpb25zKTtcblxuICAvLyBBUElcblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBkaWFncmFtIHNlcnZpY2VcbiAgICpcbiAgICogQG1ldGhvZCBEaWFncmFtI2dldFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZGlhZ3JhbSBzZXJ2aWNlIHRvIGJlIHJldHJpZXZlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdHJpY3Q9dHJ1ZV0gaWYgZmFsc2UsIHJlc29sdmUgbWlzc2luZyBzZXJ2aWNlcyB0byBudWxsXG4gICAqL1xuICB0aGlzLmdldCA9IGluamVjdG9yLmdldDtcblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBmdW5jdGlvbiBpbnRvIHdoaWNoIGRpYWdyYW0gc2VydmljZXMgYXJlIGluamVjdGVkXG4gICAqXG4gICAqIEBtZXRob2QgRGlhZ3JhbSNpbnZva2VcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3RbXX0gZm4gdGhlIGZ1bmN0aW9uIHRvIHJlc29sdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGxvY2FscyBhIG51bWJlciBvZiBsb2NhbHMgdG8gdXNlIHRvIHJlc29sdmUgY2VydGFpbiBkZXBlbmRlbmNpZXNcbiAgICovXG4gIHRoaXMuaW52b2tlID0gaW5qZWN0b3IuaW52b2tlO1xuXG4gIC8vIGluaXRcblxuICAvLyBpbmRpY2F0ZSB2aWEgZXZlbnRcblxuXG4gIC8qKlxuICAgKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgYWxsIHBsdWctaW5zIGFyZSBsb2FkZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGV2ZW50IHRvIGZpcmUgb3RoZXIgZXZlbnRzIHRvIGludGVyZXN0ZWQgcGx1Zy1pbnNcbiAgICpcbiAgICogQG1lbWJlck9mIERpYWdyYW1cbiAgICpcbiAgICogQGV2ZW50IGRpYWdyYW0uaW5pdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBldmVudEJ1cy5vbignZGlhZ3JhbS5pbml0JywgZnVuY3Rpb24oKSB7XG4gICAqICAgZXZlbnRCdXMuZmlyZSgnbXktY3VzdG9tLWV2ZW50JywgeyBmb286ICdCQVInIH0pO1xuICAgKiB9KTtcbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuZ2V0KCdldmVudEJ1cycpLmZpcmUoJ2RpYWdyYW0uaW5pdCcpO1xufVxuXG5cbi8qKlxuICogRGVzdHJveXMgdGhlIGRpYWdyYW1cbiAqXG4gKiBAbWV0aG9kICBEaWFncmFtI2Rlc3Ryb3lcbiAqL1xuRGlhZ3JhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdldCgnZXZlbnRCdXMnKS5maXJlKCdkaWFncmFtLmRlc3Ryb3knKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIGRpYWdyYW0sIHJlbW92aW5nIGFsbCBjb250ZW50cy5cbiAqL1xuRGlhZ3JhbS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nZXQoJ2V2ZW50QnVzJykuZmlyZSgnZGlhZ3JhbS5jbGVhcicpO1xufTtcbiIsImltcG9ydCB7XG4gIGZvckVhY2gsXG4gIGlzRnVuY3Rpb24sXG4gIGlzQXJyYXksXG4gIGlzTnVtYmVyLFxuICBpc09iamVjdFxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxudmFyIERFRkFVTFRfUFJJT1JJVFkgPSAxMDAwO1xuXG4vKipcbiAqIEEgdXRpbGl0eSB0aGF0IGNhbiBiZSB1c2VkIHRvIHBsdWctaW4gaW50byB0aGUgY29tbWFuZCBleGVjdXRpb24gZm9yXG4gKiBleHRlbnNpb24gYW5kL29yIHZhbGlkYXRpb24uXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG4gKlxuICogaW1wb3J0IENvbW1hbmRJbnRlcmNlcHRvciBmcm9tICdkaWFncmFtLWpzL2xpYi9jb21tYW5kL0NvbW1hbmRJbnRlcmNlcHRvcic7XG4gKlxuICogZnVuY3Rpb24gQ29tbWFuZExvZ2dlcihldmVudEJ1cykge1xuICogICBDb21tYW5kSW50ZXJjZXB0b3IuY2FsbCh0aGlzLCBldmVudEJ1cyk7XG4gKlxuICogICB0aGlzLnByZUV4ZWN1dGUoZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgICBjb25zb2xlLmxvZygnY29tbWFuZCBwcmUtZXhlY3V0ZScsIGV2ZW50KTtcbiAqICAgfSk7XG4gKiB9XG4gKlxuICogaW5oZXJpdHMoQ29tbWFuZExvZ2dlciwgQ29tbWFuZEludGVyY2VwdG9yKTtcbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbW1hbmRJbnRlcmNlcHRvcihldmVudEJ1cykge1xuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xufVxuXG5Db21tYW5kSW50ZXJjZXB0b3IuJGluamVjdCA9IFsgJ2V2ZW50QnVzJyBdO1xuXG5mdW5jdGlvbiB1bndyYXBFdmVudChmbiwgdGhhdCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGF0IHx8IG51bGwsIGV2ZW50LmNvbnRleHQsIGV2ZW50LmNvbW1hbmQsIGV2ZW50KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhbiBpbnRlcmNlcHRvciBmb3IgYSBjb21tYW5kIGV4ZWN1dGlvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IFtldmVudHNdIGxpc3Qgb2YgY29tbWFuZHMgdG8gcmVnaXN0ZXIgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbaG9va10gY29tbWFuZCBob29rLCBpLmUuIHByZUV4ZWN1dGUsIGV4ZWN1dGVkIHRvIGxpc3RlbiBvblxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eV0gdGhlIHByaW9yaXR5IG9uIHdoaWNoIHRvIGhvb2sgaW50byB0aGUgZXhlY3V0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyRm4gaW50ZXJjZXB0b3IgdG8gYmUgaW52b2tlZCB3aXRoIChldmVudClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdW53cmFwIGlmIHRydWUsIHVud3JhcCB0aGUgZXZlbnQgYW5kIHBhc3MgKGNvbnRleHQsIGNvbW1hbmQsIGV2ZW50KSB0byB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciBpbnN0ZWFkXG4gKiBAcGFyYW0ge09iamVjdH0gW3RoYXRdIFBhc3MgY29udGV4dCAoYHRoaXNgKSB0byB0aGUgaGFuZGxlciBmdW5jdGlvblxuICovXG5Db21tYW5kSW50ZXJjZXB0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnRzLCBob29rLCBwcmlvcml0eSwgaGFuZGxlckZuLCB1bndyYXAsIHRoYXQpIHtcblxuICBpZiAoaXNGdW5jdGlvbihob29rKSB8fCBpc051bWJlcihob29rKSkge1xuICAgIHRoYXQgPSB1bndyYXA7XG4gICAgdW53cmFwID0gaGFuZGxlckZuO1xuICAgIGhhbmRsZXJGbiA9IHByaW9yaXR5O1xuICAgIHByaW9yaXR5ID0gaG9vaztcbiAgICBob29rID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0Z1bmN0aW9uKHByaW9yaXR5KSkge1xuICAgIHRoYXQgPSB1bndyYXA7XG4gICAgdW53cmFwID0gaGFuZGxlckZuO1xuICAgIGhhbmRsZXJGbiA9IHByaW9yaXR5O1xuICAgIHByaW9yaXR5ID0gREVGQVVMVF9QUklPUklUWTtcbiAgfVxuXG4gIGlmIChpc09iamVjdCh1bndyYXApKSB7XG4gICAgdGhhdCA9IHVud3JhcDtcbiAgICB1bndyYXAgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghaXNGdW5jdGlvbihoYW5kbGVyRm4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGVyRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoIWlzQXJyYXkoZXZlbnRzKSkge1xuICAgIGV2ZW50cyA9IFsgZXZlbnRzIF07XG4gIH1cblxuICB2YXIgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIC8vIGNvbmNhdCBjb21tYW5kU3RhY2soLmV2ZW50KT8oLmhvb2spP1xuICAgIHZhciBmdWxsRXZlbnQgPSBbICdjb21tYW5kU3RhY2snLCBldmVudCwgaG9vayBdLmZpbHRlcihmdW5jdGlvbihlKSB7IHJldHVybiBlOyB9KS5qb2luKCcuJyk7XG5cbiAgICBldmVudEJ1cy5vbihmdWxsRXZlbnQsIHByaW9yaXR5LCB1bndyYXAgPyB1bndyYXBFdmVudChoYW5kbGVyRm4sIHRoYXQpIDogaGFuZGxlckZuLCB0aGF0KTtcbiAgfSk7XG59O1xuXG5cbnZhciBob29rcyA9IFtcbiAgJ2NhbkV4ZWN1dGUnLFxuICAncHJlRXhlY3V0ZScsXG4gICdwcmVFeGVjdXRlZCcsXG4gICdleGVjdXRlJyxcbiAgJ2V4ZWN1dGVkJyxcbiAgJ3Bvc3RFeGVjdXRlJyxcbiAgJ3Bvc3RFeGVjdXRlZCcsXG4gICdyZXZlcnQnLFxuICAncmV2ZXJ0ZWQnXG5dO1xuXG4vKlxuICogSW5zdGFsbCBob29rIHNob3J0Y3V0c1xuICpcbiAqIFRoaXMgd2lsbCBnZW5lcmF0ZSB0aGUgQ29tbWFuZEludGVyY2VwdG9yIyhwcmVFeGVjdXRlfC4uLnxyZXZlcnRlZCkgbWV0aG9kc1xuICogd2hpY2ggd2lsbCBpbiB0ZXJtIGZvcndhcmQgdG8gQ29tbWFuZEludGVyY2VwdG9yI29uLlxuICovXG5mb3JFYWNoKGhvb2tzLCBmdW5jdGlvbihob29rKSB7XG5cbiAgLyoqXG4gICAqIHtjYW5FeGVjdXRlfHByZUV4ZWN1dGV8cHJlRXhlY3V0ZWR8ZXhlY3V0ZXxleGVjdXRlZHxwb3N0RXhlY3V0ZXxwb3N0RXhlY3V0ZWR8cmV2ZXJ0fHJldmVydGVkfVxuICAgKlxuICAgKiBBIG5hbWVkIGhvb2sgZm9yIHBsdWdnaW5nIGludG8gdGhlIGNvbW1hbmQgZXhlY3V0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IFtldmVudHNdIGxpc3Qgb2YgY29tbWFuZHMgdG8gcmVnaXN0ZXIgb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eV0gdGhlIHByaW9yaXR5IG9uIHdoaWNoIHRvIGhvb2sgaW50byB0aGUgZXhlY3V0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJGbiBpbnRlcmNlcHRvciB0byBiZSBpbnZva2VkIHdpdGggKGV2ZW50KVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1bndyYXA9ZmFsc2VdIGlmIHRydWUsIHVud3JhcCB0aGUgZXZlbnQgYW5kIHBhc3MgKGNvbnRleHQsIGNvbW1hbmQsIGV2ZW50KSB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyIGluc3RlYWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFt0aGF0XSBQYXNzIGNvbnRleHQgKGB0aGlzYCkgdG8gdGhlIGhhbmRsZXIgZnVuY3Rpb25cbiAgICovXG4gIENvbW1hbmRJbnRlcmNlcHRvci5wcm90b3R5cGVbaG9va10gPSBmdW5jdGlvbihldmVudHMsIHByaW9yaXR5LCBoYW5kbGVyRm4sIHVud3JhcCwgdGhhdCkge1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZlbnRzKSB8fCBpc051bWJlcihldmVudHMpKSB7XG4gICAgICB0aGF0ID0gdW53cmFwO1xuICAgICAgdW53cmFwID0gaGFuZGxlckZuO1xuICAgICAgaGFuZGxlckZuID0gcHJpb3JpdHk7XG4gICAgICBwcmlvcml0eSA9IGV2ZW50cztcbiAgICAgIGV2ZW50cyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5vbihldmVudHMsIGhvb2ssIHByaW9yaXR5LCBoYW5kbGVyRm4sIHVud3JhcCwgdGhhdCk7XG4gIH07XG59KTtcbiIsImltcG9ydCB7XG4gIHVuaXF1ZUJ5LFxuICBpc0FycmF5XG59IGZyb20gJ21pbi1kYXNoJztcblxuXG4vKipcbiAqIEEgc2VydmljZSB0aGF0IG9mZmVycyB1bi0gYW5kIHJlZG9hYmxlIGV4ZWN1dGlvbiBvZiBjb21tYW5kcy5cbiAqXG4gKiBUaGUgY29tbWFuZCBzdGFjayBpcyByZXNwb25zaWJsZSBmb3IgZXhlY3V0aW5nIG1vZGVsaW5nIGFjdGlvbnNcbiAqIGluIGEgdW4tIGFuZCByZWRvYWJsZSBtYW5uZXIuIFRvIGRvIHRoaXMgaXQgZGVsZWdhdGVzIHRoZSBhY3R1YWxcbiAqIGNvbW1hbmQgZXhlY3V0aW9uIHRvIHtAbGluayBDb21tYW5kSGFuZGxlcn1zLlxuICpcbiAqIENvbW1hbmQgaGFuZGxlcnMgcHJvdmlkZSB7QGxpbmsgQ29tbWFuZEhhbmRsZXIjZXhlY3V0ZShjdHgpfSBhbmRcbiAqIHtAbGluayBDb21tYW5kSGFuZGxlciNyZXZlcnQoY3R4KX0gbWV0aG9kcyB0byB1bi0gYW5kIHJlZG8gYSBjb21tYW5kXG4gKiBpZGVudGlmaWVkIGJ5IGEgY29tbWFuZCBjb250ZXh0LlxuICpcbiAqXG4gKiAjIyBMaWZlLUN5Y2xlIGV2ZW50c1xuICpcbiAqIEluIHRoZSBwcm9jZXNzIHRoZSBjb21tYW5kIHN0YWNrIGZpcmVzIGEgbnVtYmVyIG9mIGxpZmUtY3ljbGUgZXZlbnRzXG4gKiB0aGF0IG90aGVyIGNvbXBvbmVudHMgdG8gcGFydGljaXBhdGUgaW4gdGhlIGNvbW1hbmQgZXhlY3V0aW9uLlxuICpcbiAqICAgICogcHJlRXhlY3V0ZVxuICogICAgKiBwcmVFeGVjdXRlZFxuICogICAgKiBleGVjdXRlXG4gKiAgICAqIGV4ZWN1dGVkXG4gKiAgICAqIHBvc3RFeGVjdXRlXG4gKiAgICAqIHBvc3RFeGVjdXRlZFxuICogICAgKiByZXZlcnRcbiAqICAgICogcmV2ZXJ0ZWRcbiAqXG4gKiBBIHNwZWNpYWwgZXZlbnQgaXMgdXNlZCBmb3IgdmFsaWRhdGluZywgd2hldGhlciBhIGNvbW1hbmQgY2FuIGJlXG4gKiBwZXJmb3JtZWQgcHJpb3IgdG8gaXRzIGV4ZWN1dGlvbi5cbiAqXG4gKiAgICAqIGNhbkV4ZWN1dGVcbiAqXG4gKiBFYWNoIG9mIHRoZSBldmVudHMgaXMgZmlyZWQgYXMgYGNvbW1hbmRTdGFjay57ZXZlbnROYW1lfWAgYW5kXG4gKiBgY29tbWFuZFN0YWNrLntjb21tYW5kTmFtZX0ue2V2ZW50TmFtZX1gLCByZXNwZWN0aXZlbHkuIFRoaXMgZ2l2ZXNcbiAqIGNvbXBvbmVudHMgZmluZSBncmFpbmVkIGNvbnRyb2wgb24gd2hlcmUgdG8gaG9vayBpbnRvLlxuICpcbiAqIFRoZSBldmVudCBvYmplY3QgZmlyZWQgdHJhbnNwb3J0cyBgY29tbWFuZGAsIHRoZSBuYW1lIG9mIHRoZVxuICogY29tbWFuZCBhbmQgYGNvbnRleHRgLCB0aGUgY29tbWFuZCBjb250ZXh0LlxuICpcbiAqXG4gKiAjIyBDcmVhdGluZyBDb21tYW5kIEhhbmRsZXJzXG4gKlxuICogQ29tbWFuZCBoYW5kbGVycyBzaG91bGQgcHJvdmlkZSB0aGUge0BsaW5rIENvbW1hbmRIYW5kbGVyI2V4ZWN1dGUoY3R4KX1cbiAqIGFuZCB7QGxpbmsgQ29tbWFuZEhhbmRsZXIjcmV2ZXJ0KGN0eCl9IG1ldGhvZHMgdG8gaW1wbGVtZW50XG4gKiByZWRvaW5nIGFuZCB1bmRvaW5nIG9mIGEgY29tbWFuZC5cbiAqXG4gKiBBIGNvbW1hbmQgaGFuZGxlciBfbXVzdF8gZW5zdXJlIHVuZG8gaXMgcGVyZm9ybWVkIHByb3Blcmx5IGluIG9yZGVyXG4gKiBub3QgdG8gYnJlYWsgdGhlIHVuZG8gY2hhaW4uIEl0IG11c3QgYWxzbyByZXR1cm4gdGhlIHNoYXBlcyB0aGF0XG4gKiBnb3QgY2hhbmdlZCBkdXJpbmcgdGhlIGBleGVjdXRlYCBhbmQgYHJldmVydGAgb3BlcmF0aW9ucy5cbiAqXG4gKiBDb21tYW5kIGhhbmRsZXJzIG1heSBleGVjdXRlIG90aGVyIG1vZGVsaW5nIG9wZXJhdGlvbnMgKGFuZCB0aHVzXG4gKiBjb21tYW5kcykgaW4gdGhlaXIgYHByZUV4ZWN1dGVgIGFuZCBgcG9zdEV4ZWN1dGVgIHBoYXNlcy4gVGhlIGNvbW1hbmRcbiAqIHN0YWNrIHdpbGwgcHJvcGVybHkgZ3JvdXAgYWxsIGNvbW1hbmRzIHRvZ2V0aGVyIGludG8gYSBsb2dpY2FsIHVuaXRcbiAqIHRoYXQgbWF5IGJlIHJlLSBhbmQgdW5kb25lIGF0b21pY2FsbHkuXG4gKlxuICogQ29tbWFuZCBoYW5kbGVycyBtdXN0IG5vdCBleGVjdXRlIG90aGVyIGNvbW1hbmRzIGZyb20gd2l0aGluIHRoZWlyXG4gKiBjb3JlIGltcGxlbWVudGF0aW9uIChgZXhlY3V0ZWAsIGByZXZlcnRgKS5cbiAqXG4gKlxuICogIyMgQ2hhbmdlIFRyYWNraW5nXG4gKlxuICogRHVyaW5nIHRoZSBleGVjdXRpb24gb2YgdGhlIENvbW1hbmRTdGFjayBpdCB3aWxsIGtlZXAgdHJhY2sgb2YgYWxsXG4gKiBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiB0b3VjaGVkIGR1cmluZyB0aGUgY29tbWFuZCdzIGV4ZWN1dGlvbi5cbiAqXG4gKiBBdCB0aGUgZW5kIG9mIHRoZSBDb21tYW5kU3RhY2sgZXhlY3V0aW9uIGl0IHdpbGwgbm90aWZ5IGludGVyZXN0ZWRcbiAqIGNvbXBvbmVudHMgdmlhIGFuICdlbGVtZW50cy5jaGFuZ2VkJyBldmVudCB3aXRoIGFsbCB0aGUgZGlydHlcbiAqIGVsZW1lbnRzLlxuICpcbiAqIFRoZSBldmVudCBjYW4gYmUgcGlja2VkIHVwIGJ5IGNvbXBvbmVudHMgdGhhdCBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgZmFjdFxuICogdGhhdCBlbGVtZW50cyBoYXZlIGJlZW4gY2hhbmdlZC4gT25lIHVzZSBjYXNlIGZvciB0aGlzIGlzIHVwZGF0aW5nXG4gKiB0aGVpciBncmFwaGljYWwgcmVwcmVzZW50YXRpb24gYWZ0ZXIgbW92aW5nIC8gcmVzaXppbmcgb3IgZGVsZXRpb24uXG4gKlxuICogQHNlZSBDb21tYW5kSGFuZGxlclxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0luamVjdG9yfSBpbmplY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb21tYW5kU3RhY2soZXZlbnRCdXMsIGluamVjdG9yKSB7XG5cbiAgLyoqXG4gICAqIEEgbWFwIG9mIGFsbCByZWdpc3RlcmVkIGNvbW1hbmQgaGFuZGxlcnMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLl9oYW5kbGVyTWFwID0ge307XG5cbiAgLyoqXG4gICAqIEEgc3RhY2sgY29udGFpbmluZyBhbGwgcmUvdW5kb2FibGUgYWN0aW9ucyBvbiB0aGUgZGlhZ3JhbVxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8T2JqZWN0Pn1cbiAgICovXG4gIHRoaXMuX3N0YWNrID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGluZGV4IG9uIHRoZSBzdGFja1xuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5fc3RhY2tJZHggPSAtMTtcblxuICAvKipcbiAgICogQ3VycmVudCBhY3RpdmUgY29tbWFuZFN0YWNrIGV4ZWN1dGlvblxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge09iamVjdFtdfSBhY3Rpb25zXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IGRpcnR5XG4gICAqIEBwcm9wZXJ0eSB7ICd1bmRvJyB8ICdyZWRvJyB8ICdjbGVhcicgfCAnZXhlY3V0ZScgfCBudWxsIH0gdHJpZ2dlciB0aGUgY2F1c2Ugb2YgdGhlIGN1cnJlbnQgZXhjZWN1dGlvblxuICAgKi9cbiAgdGhpcy5fY3VycmVudEV4ZWN1dGlvbiA9IHtcbiAgICBhY3Rpb25zOiBbXSxcbiAgICBkaXJ0eTogW10sXG4gICAgdHJpZ2dlcjogbnVsbFxuICB9O1xuXG5cbiAgdGhpcy5faW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcblxuICB0aGlzLl91aWQgPSAxO1xuXG4gIGV2ZW50QnVzLm9uKFtcbiAgICAnZGlhZ3JhbS5kZXN0cm95JyxcbiAgICAnZGlhZ3JhbS5jbGVhcidcbiAgXSwgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhcihmYWxzZSk7XG4gIH0sIHRoaXMpO1xufVxuXG5Db21tYW5kU3RhY2suJGluamVjdCA9IFsgJ2V2ZW50QnVzJywgJ2luamVjdG9yJyBdO1xuXG5cbi8qKlxuICogRXhlY3V0ZSBhIGNvbW1hbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCB0aGUgY29tbWFuZCB0byBleGVjdXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCB0aGUgZW52aXJvbm1lbnQgdG8gZXhlY3V0ZSB0aGUgY29tbWFuZCBpblxuICovXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb21tYW5kLCBjb250ZXh0KSB7XG4gIGlmICghY29tbWFuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tbWFuZCByZXF1aXJlZCcpO1xuICB9XG5cbiAgdGhpcy5fY3VycmVudEV4ZWN1dGlvbi50cmlnZ2VyID0gJ2V4ZWN1dGUnO1xuXG4gIHZhciBhY3Rpb24gPSB7IGNvbW1hbmQ6IGNvbW1hbmQsIGNvbnRleHQ6IGNvbnRleHQgfTtcblxuICB0aGlzLl9wdXNoQWN0aW9uKGFjdGlvbik7XG4gIHRoaXMuX2ludGVybmFsRXhlY3V0ZShhY3Rpb24pO1xuICB0aGlzLl9wb3BBY3Rpb24oYWN0aW9uKTtcbn07XG5cblxuLyoqXG4gKiBBc2sgd2hldGhlciBhIGdpdmVuIGNvbW1hbmQgY2FuIGJlIGV4ZWN1dGVkLlxuICpcbiAqIEltcGxlbWVudG9ycyBtYXkgaG9vayBpbnRvIHRoZSBtZWNoYW5pc20gb24gdHdvIHdheXM6XG4gKlxuICogICAqIGluIGV2ZW50IGxpc3RlbmVyczpcbiAqXG4gKiAgICAgVXNlcnMgbWF5IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiB2aWEgYW4gZXZlbnQgbGlzdGVuZXIuXG4gKiAgICAgSXQgbXVzdCBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgYGNvbW1hbmRTdGFjay4oPGNvbW1hbmQ+LiljYW5FeGVjdXRlYCBldmVudHMuXG4gKlxuICogICAqIGluIGNvbW1hbmQgaGFuZGxlcnM6XG4gKlxuICogICAgIElmIHRoZSBtZXRob2Qge0BsaW5rIENvbW1hbmRIYW5kbGVyI2NhbkV4ZWN1dGV9IGlzIGltcGxlbWVudGVkIGluIGEgaGFuZGxlclxuICogICAgIGl0IHdpbGwgYmUgY2FsbGVkIHRvIGZpZ3VyZSBvdXQgd2hldGhlciB0aGUgZXhlY3V0aW9uIGlzIGFsbG93ZWQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBjb21tYW5kIHRoZSBjb21tYW5kIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dCB0aGUgZW52aXJvbm1lbnQgdG8gZXhlY3V0ZSB0aGUgY29tbWFuZCBpblxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNvbW1hbmQgY2FuIGJlIGV4ZWN1dGVkXG4gKi9cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuY2FuRXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbW1hbmQsIGNvbnRleHQpIHtcblxuICB2YXIgYWN0aW9uID0geyBjb21tYW5kOiBjb21tYW5kLCBjb250ZXh0OiBjb250ZXh0IH07XG5cbiAgdmFyIGhhbmRsZXIgPSB0aGlzLl9nZXRIYW5kbGVyKGNvbW1hbmQpO1xuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9maXJlKGNvbW1hbmQsICdjYW5FeGVjdXRlJywgYWN0aW9uKTtcblxuICAvLyBoYW5kbGVyI2NhbkV4ZWN1dGUgd2lsbCBvbmx5IGJlIGNhbGxlZCBpZiBubyBsaXN0ZW5lclxuICAvLyBkZWNpZGVkIG9uIGEgcmVzdWx0IGFscmVhZHlcbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZXIuY2FuRXhlY3V0ZSkge1xuICAgICAgcmVzdWx0ID0gaGFuZGxlci5jYW5FeGVjdXRlKGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogQ2xlYXIgdGhlIGNvbW1hbmQgc3RhY2ssIGVyYXNpbmcgYWxsIHVuZG8gLyByZWRvIGhpc3RvcnlcbiAqL1xuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKGVtaXQpIHtcbiAgdGhpcy5fc3RhY2subGVuZ3RoID0gMDtcbiAgdGhpcy5fc3RhY2tJZHggPSAtMTtcblxuICBpZiAoZW1pdCAhPT0gZmFsc2UpIHtcbiAgICB0aGlzLl9maXJlKCdjaGFuZ2VkJywgeyB0cmlnZ2VyOiAnY2xlYXInIH0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogVW5kbyBsYXN0IGNvbW1hbmQocylcbiAqL1xuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhY3Rpb24gPSB0aGlzLl9nZXRVbmRvQWN0aW9uKCksXG4gICAgICBuZXh0O1xuXG4gIGlmIChhY3Rpb24pIHtcbiAgICB0aGlzLl9jdXJyZW50RXhlY3V0aW9uLnRyaWdnZXIgPSAndW5kbyc7XG5cbiAgICB0aGlzLl9wdXNoQWN0aW9uKGFjdGlvbik7XG5cbiAgICB3aGlsZSAoYWN0aW9uKSB7XG4gICAgICB0aGlzLl9pbnRlcm5hbFVuZG8oYWN0aW9uKTtcbiAgICAgIG5leHQgPSB0aGlzLl9nZXRVbmRvQWN0aW9uKCk7XG5cbiAgICAgIGlmICghbmV4dCB8fCBuZXh0LmlkICE9PSBhY3Rpb24uaWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGFjdGlvbiA9IG5leHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fcG9wQWN0aW9uKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZWRvIGxhc3QgY29tbWFuZChzKVxuICovXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFjdGlvbiA9IHRoaXMuX2dldFJlZG9BY3Rpb24oKSxcbiAgICAgIG5leHQ7XG5cbiAgaWYgKGFjdGlvbikge1xuICAgIHRoaXMuX2N1cnJlbnRFeGVjdXRpb24udHJpZ2dlciA9ICdyZWRvJztcblxuICAgIHRoaXMuX3B1c2hBY3Rpb24oYWN0aW9uKTtcblxuICAgIHdoaWxlIChhY3Rpb24pIHtcbiAgICAgIHRoaXMuX2ludGVybmFsRXhlY3V0ZShhY3Rpb24sIHRydWUpO1xuICAgICAgbmV4dCA9IHRoaXMuX2dldFJlZG9BY3Rpb24oKTtcblxuICAgICAgaWYgKCFuZXh0IHx8IG5leHQuaWQgIT09IGFjdGlvbi5pZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYWN0aW9uID0gbmV4dDtcbiAgICB9XG5cbiAgICB0aGlzLl9wb3BBY3Rpb24oKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgaGFuZGxlciBpbnN0YW5jZSB3aXRoIHRoZSBjb21tYW5kIHN0YWNrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmRcbiAqIEBwYXJhbSB7Q29tbWFuZEhhbmRsZXJ9IGhhbmRsZXJcbiAqL1xuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGNvbW1hbmQsIGhhbmRsZXIpIHtcbiAgdGhpcy5fc2V0SGFuZGxlcihjb21tYW5kLCBoYW5kbGVyKTtcbn07XG5cblxuLyoqXG4gKiBSZWdpc3RlciBhIGhhbmRsZXIgdHlwZSB3aXRoIHRoZSBjb21tYW5kIHN0YWNrXG4gKiBieSBpbnN0YW50aWF0aW5nIGl0IGFuZCBpbmplY3RpbmcgaXRzIGRlcGVuZGVuY2llcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYSBjb25zdHJ1Y3RvciBmb3IgYSB7QGxpbmsgQ29tbWFuZEhhbmRsZXJ9XG4gKi9cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUucmVnaXN0ZXJIYW5kbGVyID0gZnVuY3Rpb24oY29tbWFuZCwgaGFuZGxlckNscykge1xuXG4gIGlmICghY29tbWFuZCB8fCAhaGFuZGxlckNscykge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tbWFuZCBhbmQgaGFuZGxlckNscyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gdGhpcy5faW5qZWN0b3IuaW5zdGFudGlhdGUoaGFuZGxlckNscyk7XG4gIHRoaXMucmVnaXN0ZXIoY29tbWFuZCwgaGFuZGxlcik7XG59O1xuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLmNhblVuZG8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhdGhpcy5fZ2V0VW5kb0FjdGlvbigpO1xufTtcblxuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS5jYW5SZWRvID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIXRoaXMuX2dldFJlZG9BY3Rpb24oKTtcbn07XG5cbi8vIHN0YWNrIGFjY2VzcyAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9nZXRSZWRvQWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFja0lkeCArIDFdO1xufTtcblxuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9nZXRVbmRvQWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFja0lkeF07XG59O1xuXG5cbi8vIGludGVybmFsIGZ1bmN0aW9uYWxpdHkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9pbnRlcm5hbFVuZG8gPSBmdW5jdGlvbihhY3Rpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBjb21tYW5kID0gYWN0aW9uLmNvbW1hbmQsXG4gICAgICBjb250ZXh0ID0gYWN0aW9uLmNvbnRleHQ7XG5cbiAgdmFyIGhhbmRsZXIgPSB0aGlzLl9nZXRIYW5kbGVyKGNvbW1hbmQpO1xuXG4gIC8vIGd1YXJkIGFnYWluc3QgaWxsZWdhbCBuZXN0ZWQgY29tbWFuZCBzdGFjayBpbnZvY2F0aW9uc1xuICB0aGlzLl9hdG9taWNEbyhmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9maXJlKGNvbW1hbmQsICdyZXZlcnQnLCBhY3Rpb24pO1xuXG4gICAgaWYgKGhhbmRsZXIucmV2ZXJ0KSB7XG4gICAgICBzZWxmLl9tYXJrRGlydHkoaGFuZGxlci5yZXZlcnQoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHNlbGYuX3JldmVydGVkQWN0aW9uKGFjdGlvbik7XG5cbiAgICBzZWxmLl9maXJlKGNvbW1hbmQsICdyZXZlcnRlZCcsIGFjdGlvbik7XG4gIH0pO1xufTtcblxuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9maXJlID0gZnVuY3Rpb24oY29tbWFuZCwgcXVhbGlmaWVyLCBldmVudCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICBldmVudCA9IHF1YWxpZmllcjtcbiAgICBxdWFsaWZpZXIgPSBudWxsO1xuICB9XG5cbiAgdmFyIG5hbWVzID0gcXVhbGlmaWVyID8gWyBjb21tYW5kICsgJy4nICsgcXVhbGlmaWVyLCBxdWFsaWZpZXIgXSA6IFsgY29tbWFuZCBdLFxuICAgICAgaSwgbmFtZSwgcmVzdWx0O1xuXG4gIGV2ZW50ID0gdGhpcy5fZXZlbnRCdXMuY3JlYXRlRXZlbnQoZXZlbnQpO1xuXG4gIGZvciAoaSA9IDA7IChuYW1lID0gbmFtZXNbaV0pOyBpKyspIHtcbiAgICByZXN1bHQgPSB0aGlzLl9ldmVudEJ1cy5maXJlKCdjb21tYW5kU3RhY2suJyArIG5hbWUsIGV2ZW50KTtcblxuICAgIGlmIChldmVudC5jYW5jZWxCdWJibGUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9jcmVhdGVJZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdWlkKys7XG59O1xuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9hdG9taWNEbyA9IGZ1bmN0aW9uKGZuKSB7XG5cbiAgdmFyIGV4ZWN1dGlvbiA9IHRoaXMuX2N1cnJlbnRFeGVjdXRpb247XG5cbiAgZXhlY3V0aW9uLmF0b21pYyA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4ZWN1dGlvbi5hdG9taWMgPSBmYWxzZTtcbiAgfVxufTtcblxuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS5faW50ZXJuYWxFeGVjdXRlID0gZnVuY3Rpb24oYWN0aW9uLCByZWRvKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgY29tbWFuZCA9IGFjdGlvbi5jb21tYW5kLFxuICAgICAgY29udGV4dCA9IGFjdGlvbi5jb250ZXh0O1xuXG4gIHZhciBoYW5kbGVyID0gdGhpcy5fZ2V0SGFuZGxlcihjb21tYW5kKTtcblxuICBpZiAoIWhhbmRsZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGNvbW1hbmQgaGFuZGxlciByZWdpc3RlcmVkIGZvciA8JyArIGNvbW1hbmQgKyAnPicpO1xuICB9XG5cbiAgdGhpcy5fcHVzaEFjdGlvbihhY3Rpb24pO1xuXG4gIGlmICghcmVkbykge1xuICAgIHRoaXMuX2ZpcmUoY29tbWFuZCwgJ3ByZUV4ZWN1dGUnLCBhY3Rpb24pO1xuXG4gICAgaWYgKGhhbmRsZXIucHJlRXhlY3V0ZSkge1xuICAgICAgaGFuZGxlci5wcmVFeGVjdXRlKGNvbnRleHQpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpcmUoY29tbWFuZCwgJ3ByZUV4ZWN1dGVkJywgYWN0aW9uKTtcbiAgfVxuXG4gIC8vIGd1YXJkIGFnYWluc3QgaWxsZWdhbCBuZXN0ZWQgY29tbWFuZCBzdGFjayBpbnZvY2F0aW9uc1xuICB0aGlzLl9hdG9taWNEbyhmdW5jdGlvbigpIHtcblxuICAgIHNlbGYuX2ZpcmUoY29tbWFuZCwgJ2V4ZWN1dGUnLCBhY3Rpb24pO1xuXG4gICAgaWYgKGhhbmRsZXIuZXhlY3V0ZSkge1xuXG4gICAgICAvLyBhY3R1YWwgZXhlY3V0ZSArIG1hcmsgcmV0dXJuIHJlc3VsdHMgYXMgZGlydHlcbiAgICAgIHNlbGYuX21hcmtEaXJ0eShoYW5kbGVyLmV4ZWN1dGUoY29udGV4dCkpO1xuICAgIH1cblxuICAgIC8vIGxvZyB0byBzdGFja1xuICAgIHNlbGYuX2V4ZWN1dGVkQWN0aW9uKGFjdGlvbiwgcmVkbyk7XG5cbiAgICBzZWxmLl9maXJlKGNvbW1hbmQsICdleGVjdXRlZCcsIGFjdGlvbik7XG4gIH0pO1xuXG4gIGlmICghcmVkbykge1xuICAgIHRoaXMuX2ZpcmUoY29tbWFuZCwgJ3Bvc3RFeGVjdXRlJywgYWN0aW9uKTtcblxuICAgIGlmIChoYW5kbGVyLnBvc3RFeGVjdXRlKSB7XG4gICAgICBoYW5kbGVyLnBvc3RFeGVjdXRlKGNvbnRleHQpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpcmUoY29tbWFuZCwgJ3Bvc3RFeGVjdXRlZCcsIGFjdGlvbik7XG4gIH1cblxuICB0aGlzLl9wb3BBY3Rpb24oYWN0aW9uKTtcbn07XG5cblxuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS5fcHVzaEFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbikge1xuXG4gIHZhciBleGVjdXRpb24gPSB0aGlzLl9jdXJyZW50RXhlY3V0aW9uLFxuICAgICAgYWN0aW9ucyA9IGV4ZWN1dGlvbi5hY3Rpb25zO1xuXG4gIHZhciBiYXNlQWN0aW9uID0gYWN0aW9uc1swXTtcblxuICBpZiAoZXhlY3V0aW9uLmF0b21pYykge1xuICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBpbnZvY2F0aW9uIGluIDxleGVjdXRlPiBvciA8cmV2ZXJ0PiBwaGFzZSAoYWN0aW9uOiAnICsgYWN0aW9uLmNvbW1hbmQgKyAnKScpO1xuICB9XG5cbiAgaWYgKCFhY3Rpb24uaWQpIHtcbiAgICBhY3Rpb24uaWQgPSAoYmFzZUFjdGlvbiAmJiBiYXNlQWN0aW9uLmlkKSB8fCB0aGlzLl9jcmVhdGVJZCgpO1xuICB9XG5cbiAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG59O1xuXG5cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuX3BvcEFjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXhlY3V0aW9uID0gdGhpcy5fY3VycmVudEV4ZWN1dGlvbixcbiAgICAgIHRyaWdnZXIgPSBleGVjdXRpb24udHJpZ2dlcixcbiAgICAgIGFjdGlvbnMgPSBleGVjdXRpb24uYWN0aW9ucyxcbiAgICAgIGRpcnR5ID0gZXhlY3V0aW9uLmRpcnR5O1xuXG4gIGFjdGlvbnMucG9wKCk7XG5cbiAgaWYgKCFhY3Rpb25zLmxlbmd0aCkge1xuICAgIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2VsZW1lbnRzLmNoYW5nZWQnLCB7IGVsZW1lbnRzOiB1bmlxdWVCeSgnaWQnLCBkaXJ0eS5yZXZlcnNlKCkpIH0pO1xuXG4gICAgZGlydHkubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuX2ZpcmUoJ2NoYW5nZWQnLCB7IHRyaWdnZXI6IHRyaWdnZXIgfSk7XG5cbiAgICBleGVjdXRpb24udHJpZ2dlciA9IG51bGw7XG4gIH1cbn07XG5cblxuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS5fbWFya0RpcnR5ID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgdmFyIGV4ZWN1dGlvbiA9IHRoaXMuX2N1cnJlbnRFeGVjdXRpb247XG5cbiAgaWYgKCFlbGVtZW50cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnRzID0gaXNBcnJheShlbGVtZW50cykgPyBlbGVtZW50cyA6IFsgZWxlbWVudHMgXTtcblxuICBleGVjdXRpb24uZGlydHkgPSBleGVjdXRpb24uZGlydHkuY29uY2F0KGVsZW1lbnRzKTtcbn07XG5cblxuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS5fZXhlY3V0ZWRBY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHJlZG8pIHtcbiAgdmFyIHN0YWNrSWR4ID0gKyt0aGlzLl9zdGFja0lkeDtcblxuICBpZiAoIXJlZG8pIHtcbiAgICB0aGlzLl9zdGFjay5zcGxpY2Uoc3RhY2tJZHgsIHRoaXMuX3N0YWNrLmxlbmd0aCwgYWN0aW9uKTtcbiAgfVxufTtcblxuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9yZXZlcnRlZEFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICB0aGlzLl9zdGFja0lkeC0tO1xufTtcblxuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9nZXRIYW5kbGVyID0gZnVuY3Rpb24oY29tbWFuZCkge1xuICByZXR1cm4gdGhpcy5faGFuZGxlck1hcFtjb21tYW5kXTtcbn07XG5cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuX3NldEhhbmRsZXIgPSBmdW5jdGlvbihjb21tYW5kLCBoYW5kbGVyKSB7XG4gIGlmICghY29tbWFuZCB8fCAhaGFuZGxlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tbWFuZCBhbmQgaGFuZGxlciByZXF1aXJlZCcpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2hhbmRsZXJNYXBbY29tbWFuZF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ292ZXJyaWRpbmcgaGFuZGxlciBmb3IgY29tbWFuZCA8JyArIGNvbW1hbmQgKyAnPicpO1xuICB9XG5cbiAgdGhpcy5faGFuZGxlck1hcFtjb21tYW5kXSA9IGhhbmRsZXI7XG59O1xuIiwiaW1wb3J0IENvbW1hbmRTdGFjayBmcm9tICcuL0NvbW1hbmRTdGFjayc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tbWFuZFN0YWNrOiBbICd0eXBlJywgQ29tbWFuZFN0YWNrIF1cbn07XG4iLCJpbXBvcnQge1xuICBpc051bWJlcixcbiAgYXNzaWduLFxuICBmb3JFYWNoLFxuICBldmVyeSxcbiAgZGVib3VuY2UsXG4gIGJpbmQsXG4gIHJlZHVjZVxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGFkZCBhcyBjb2xsZWN0aW9uQWRkLFxuICByZW1vdmUgYXMgY29sbGVjdGlvblJlbW92ZVxufSBmcm9tICcuLi91dGlsL0NvbGxlY3Rpb25zJztcblxuaW1wb3J0IHtcbiAgZ2V0VHlwZVxufSBmcm9tICcuLi91dGlsL0VsZW1lbnRzJztcblxuaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjbGFzc2VzIGFzIHN2Z0NsYXNzZXMsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXG4gIHRyYW5zZm9ybSBhcyBzdmdUcmFuc2Zvcm1cbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQgeyBjcmVhdGVNYXRyaXggYXMgY3JlYXRlTWF0cml4IH0gZnJvbSAndGlueS1zdmcnO1xuXG5cbmZ1bmN0aW9uIHJvdW5kKG51bWJlciwgcmVzb2x1dGlvbikge1xuICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVB4KG51bWJlcikge1xuICByZXR1cm4gaXNOdW1iZXIobnVtYmVyKSA/IG51bWJlciArICdweCcgOiBudW1iZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIEhUTUwgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgU1ZHIGVsZW1lbnQgd2l0aFxuICogdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKG9wdGlvbnMpIHtcblxuICBvcHRpb25zID0gYXNzaWduKHt9LCB7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH0sIG9wdGlvbnMpO1xuXG4gIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuXG4gIC8vIGNyZWF0ZSBhIDxkaXY+IGFyb3VuZCB0aGUgc3ZnIGVsZW1lbnQgd2l0aCB0aGUgcmVzcGVjdGl2ZSBzaXplXG4gIC8vIHRoaXMgd2F5IHdlIGNhbiBhbHdheXMgZ2V0IHRoZSBjb3JyZWN0IGNvbnRhaW5lciBzaXplXG4gIC8vICh0aGlzIGlzIGltcG9zc2libGUgZm9yIDxzdmc+IGVsZW1lbnRzIGF0IHRoZSBtb21lbnQpXG4gIHZhciBwYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcGFyZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGpzLWNvbnRhaW5lcicpO1xuXG4gIGFzc2lnbihwYXJlbnQuc3R5bGUsIHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgd2lkdGg6IGVuc3VyZVB4KG9wdGlvbnMud2lkdGgpLFxuICAgIGhlaWdodDogZW5zdXJlUHgob3B0aW9ucy5oZWlnaHQpXG4gIH0pO1xuXG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChwYXJlbnQpO1xuXG4gIHJldHVybiBwYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdyb3VwKHBhcmVudCwgY2xzLCBjaGlsZEluZGV4KSB7XG4gIHZhciBncm91cCA9IHN2Z0NyZWF0ZSgnZycpO1xuICBzdmdDbGFzc2VzKGdyb3VwKS5hZGQoY2xzKTtcblxuICB2YXIgaW5kZXggPSBjaGlsZEluZGV4ICE9PSB1bmRlZmluZWQgPyBjaGlsZEluZGV4IDogcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcblxuICAvLyBtdXN0IGVuc3VyZSBzZWNvbmQgYXJndW1lbnQgaXMgbm9kZSBvciBfbnVsbF9cbiAgLy8gY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL2luc2VydEJlZm9yZVxuICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGdyb3VwLCBwYXJlbnQuY2hpbGROb2Rlc1tpbmRleF0gfHwgbnVsbCk7XG5cbiAgcmV0dXJuIGdyb3VwO1xufVxuXG52YXIgQkFTRV9MQVlFUiA9ICdiYXNlJztcblxuXG52YXIgUkVRVUlSRURfTU9ERUxfQVRUUlMgPSB7XG4gIHNoYXBlOiBbICd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JyBdLFxuICBjb25uZWN0aW9uOiBbICd3YXlwb2ludHMnIF1cbn07XG5cbi8qKlxuICogVGhlIG1haW4gZHJhd2luZyBjYW52YXMuXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAZW1pdHMgQ2FudmFzI2NhbnZhcy5pbml0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7R3JhcGhpY3NGYWN0b3J5fSBncmFwaGljc0ZhY3RvcnlcbiAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FudmFzKGNvbmZpZywgZXZlbnRCdXMsIGdyYXBoaWNzRmFjdG9yeSwgZWxlbWVudFJlZ2lzdHJ5KSB7XG5cbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fZWxlbWVudFJlZ2lzdHJ5ID0gZWxlbWVudFJlZ2lzdHJ5O1xuICB0aGlzLl9ncmFwaGljc0ZhY3RvcnkgPSBncmFwaGljc0ZhY3Rvcnk7XG5cbiAgdGhpcy5faW5pdChjb25maWcgfHwge30pO1xufVxuXG5DYW52YXMuJGluamVjdCA9IFtcbiAgJ2NvbmZpZy5jYW52YXMnLFxuICAnZXZlbnRCdXMnLFxuICAnZ3JhcGhpY3NGYWN0b3J5JyxcbiAgJ2VsZW1lbnRSZWdpc3RyeSdcbl07XG5cblxuQ2FudmFzLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuXG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIC8vIENyZWF0ZXMgYSA8c3ZnPiBlbGVtZW50IHRoYXQgaXMgd3JhcHBlZCBpbnRvIGEgPGRpdj4uXG4gIC8vIFRoaXMgd2F5IHdlIGFyZSBhbHdheXMgYWJsZSB0byBjb3JyZWN0bHkgZmlndXJlIG91dCB0aGUgc2l6ZSBvZiB0aGUgc3ZnIGVsZW1lbnRcbiAgLy8gYnkgcXVlcnlpbmcgdGhlIHBhcmVudCBub2RlLlxuICAvL1xuICAvLyAoSXQgaXMgbm90IHBvc3NpYmxlIHRvIGdldCB0aGUgc2l6ZSBvZiBhIHN2ZyBlbGVtZW50IGNyb3NzIGJyb3dzZXIgQCAyMDE0LTA0LTAxKVxuICAvL1xuICAvLyA8ZGl2IGNsYXNzPVwiZGpzLWNvbnRhaW5lclwiIHN0eWxlPVwid2lkdGg6IHtkZXNpcmVkLXdpZHRofSwgaGVpZ2h0OiB7ZGVzaXJlZC1oZWlnaHR9XCI+XG4gIC8vICAgPHN2ZyB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCI+XG4gIC8vICAgIC4uLlxuICAvLyAgIDwvc3ZnPlxuICAvLyA8L2Rpdj5cblxuICAvLyBodG1sIGNvbnRhaW5lclxuICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlQ29udGFpbmVyKGNvbmZpZyk7XG5cbiAgdmFyIHN2ZyA9IHRoaXMuX3N2ZyA9IHN2Z0NyZWF0ZSgnc3ZnJyk7XG4gIHN2Z0F0dHIoc3ZnLCB7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH0pO1xuXG4gIHN2Z0FwcGVuZChjb250YWluZXIsIHN2Zyk7XG5cbiAgdmFyIHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQgPSBjcmVhdGVHcm91cChzdmcsICd2aWV3cG9ydCcpO1xuXG4gIHRoaXMuX2xheWVycyA9IHt9O1xuXG4gIC8vIGRlYm91bmNlIGNhbnZhcy52aWV3Ym94LmNoYW5nZWQgZXZlbnRzXG4gIC8vIGZvciBzbW9vdGhlciBkaWFncmFtIGludGVyYWN0aW9uXG4gIGlmIChjb25maWcuZGVmZXJVcGRhdGUgIT09IGZhbHNlKSB7XG4gICAgdGhpcy5fdmlld2JveENoYW5nZWQgPSBkZWJvdW5jZShiaW5kKHRoaXMuX3ZpZXdib3hDaGFuZ2VkLCB0aGlzKSwgMzAwKTtcbiAgfVxuXG4gIGV2ZW50QnVzLm9uKCdkaWFncmFtLmluaXQnLCBmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgY2FudmFzIGlzIHJlYWR5IHRvIGJlIGRyYXduIG9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIENhbnZhc1xuICAgICAqXG4gICAgICogQGV2ZW50IGNhbnZhcy5pbml0XG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gc3ZnIHRoZSBjcmVhdGVkIHN2ZyBlbGVtZW50XG4gICAgICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSB2aWV3cG9ydCB0aGUgZGlyZWN0IHBhcmVudCBvZiBkaWFncmFtIGVsZW1lbnRzIGFuZCBzaGFwZXNcbiAgICAgKi9cbiAgICBldmVudEJ1cy5maXJlKCdjYW52YXMuaW5pdCcsIHtcbiAgICAgIHN2Zzogc3ZnLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gICAgfSk7XG5cbiAgfSwgdGhpcyk7XG5cbiAgLy8gcmVzZXQgdmlld2JveCBvbiBzaGFwZSBjaGFuZ2VzIHRvXG4gIC8vIHJlY29tcHV0ZSB0aGUgdmlld2JveFxuICBldmVudEJ1cy5vbihbXG4gICAgJ3NoYXBlLmFkZGVkJyxcbiAgICAnY29ubmVjdGlvbi5hZGRlZCcsXG4gICAgJ3NoYXBlLnJlbW92ZWQnLFxuICAgICdjb25uZWN0aW9uLnJlbW92ZWQnLFxuICAgICdlbGVtZW50cy5jaGFuZ2VkJ1xuICBdLCBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FjaGVkVmlld2JveDtcbiAgfSwgdGhpcyk7XG5cbiAgZXZlbnRCdXMub24oJ2RpYWdyYW0uZGVzdHJveScsIDUwMCwgdGhpcy5fZGVzdHJveSwgdGhpcyk7XG4gIGV2ZW50QnVzLm9uKCdkaWFncmFtLmNsZWFyJywgNTAwLCB0aGlzLl9jbGVhciwgdGhpcyk7XG59O1xuXG5DYW52YXMucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24oZW1pdCkge1xuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjYW52YXMuZGVzdHJveScsIHtcbiAgICBzdmc6IHRoaXMuX3N2ZyxcbiAgICB2aWV3cG9ydDogdGhpcy5fdmlld3BvcnRcbiAgfSk7XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgfVxuXG4gIGRlbGV0ZSB0aGlzLl9zdmc7XG4gIGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG4gIGRlbGV0ZSB0aGlzLl9sYXllcnM7XG4gIGRlbGV0ZSB0aGlzLl9yb290RWxlbWVudDtcbiAgZGVsZXRlIHRoaXMuX3ZpZXdwb3J0O1xufTtcblxuQ2FudmFzLnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGFsbEVsZW1lbnRzID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldEFsbCgpO1xuXG4gIC8vIHJlbW92ZSBhbGwgZWxlbWVudHNcbiAgYWxsRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKGVsZW1lbnQpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdyb290Jykge1xuICAgICAgc2VsZi5zZXRSb290RWxlbWVudChudWxsLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fcmVtb3ZlRWxlbWVudChlbGVtZW50LCB0eXBlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGZvcmNlIHJlY29tcHV0YXRpb24gb2YgdmlldyBib3hcbiAgZGVsZXRlIHRoaXMuX2NhY2hlZFZpZXdib3g7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgbGF5ZXIgb24gd2hpY2hcbiAqIGFsbCBlbGVtZW50cyBhcmUgZHJhd24uXG4gKlxuICogQHJldHVybnMge1NWR0VsZW1lbnR9XG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuZ2V0RGVmYXVsdExheWVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdldExheWVyKEJBU0VfTEFZRVIsIDApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGF5ZXIgdGhhdCBpcyB1c2VkIHRvIGRyYXcgZWxlbWVudHNcbiAqIG9yIGFubm90YXRpb25zIG9uIGl0LlxuICpcbiAqIE5vbi1leGlzdGluZyBsYXllcnMgcmV0cmlldmVkIHRocm91Z2ggdGhpcyBtZXRob2RcbiAqIHdpbGwgYmUgY3JlYXRlZC4gRHVyaW5nIGNyZWF0aW9uLCB0aGUgb3B0aW9uYWwgaW5kZXhcbiAqIG1heSBiZSB1c2VkIHRvIGNyZWF0ZSBsYXllcnMgYmVsb3cgb3IgYWJvdmUgZXhpc3RpbmcgbGF5ZXJzLlxuICogQSBsYXllciB3aXRoIGEgY2VydGFpbiBpbmRleCBpcyBhbHdheXMgY3JlYXRlZCBhYm92ZSBhbGxcbiAqIGV4aXN0aW5nIGxheWVycyB3aXRoIHRoZSBzYW1lIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqXG4gKiBAcmV0dXJucyB7U1ZHRWxlbWVudH1cbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5nZXRMYXllciA9IGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cbiAgaWYgKCFuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZnkgYSBuYW1lJyk7XG4gIH1cblxuICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbbmFtZV07XG5cbiAgaWYgKCFsYXllcikge1xuICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW25hbWVdID0gdGhpcy5fY3JlYXRlTGF5ZXIobmFtZSwgaW5kZXgpO1xuICB9XG5cbiAgLy8gdGhyb3cgYW4gZXJyb3IgaWYgbGF5ZXIgY3JlYXRpb24gLyByZXRyaXZhbCBpc1xuICAvLyByZXF1ZXN0ZWQgb24gZGlmZmVyZW50IGluZGV4XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICd1bmRlZmluZWQnICYmIGxheWVyLmluZGV4ICE9PSBpbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGF5ZXIgPCcgKyBuYW1lICsgJz4gYWxyZWFkeSBjcmVhdGVkIGF0IGluZGV4IDwnICsgaW5kZXggKyAnPicpO1xuICB9XG5cbiAgcmV0dXJuIGxheWVyLmdyb3VwO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZ2l2ZW4gbGF5ZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGxheWVyIGRlc2NyaXB0b3Igd2l0aCB7IGluZGV4LCBncm91cDogU1ZHR3JvdXAgfVxuICovXG5DYW52YXMucHJvdG90eXBlLl9jcmVhdGVMYXllciA9IGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cbiAgaWYgKCFpbmRleCkge1xuICAgIGluZGV4ID0gMDtcbiAgfVxuXG4gIHZhciBjaGlsZEluZGV4ID0gcmVkdWNlKHRoaXMuX2xheWVycywgZnVuY3Rpb24oY2hpbGRJbmRleCwgbGF5ZXIpIHtcbiAgICBpZiAoaW5kZXggPj0gbGF5ZXIuaW5kZXgpIHtcbiAgICAgIGNoaWxkSW5kZXgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRJbmRleDtcbiAgfSwgMCk7XG5cbiAgcmV0dXJuIHtcbiAgICBncm91cDogY3JlYXRlR3JvdXAodGhpcy5fdmlld3BvcnQsICdsYXllci0nICsgbmFtZSwgY2hpbGRJbmRleCksXG4gICAgaW5kZXg6IGluZGV4XG4gIH07XG5cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaHRtbCBlbGVtZW50IHRoYXQgZW5jbG9zZXMgdGhlXG4gKiBkcmF3aW5nIGNhbnZhcy5cbiAqXG4gKiBAcmV0dXJuIHtET01Ob2RlfVxuICovXG5DYW52YXMucHJvdG90eXBlLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xufTtcblxuXG4vLyBtYXJrZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuQ2FudmFzLnByb3RvdHlwZS5fdXBkYXRlTWFya2VyID0gZnVuY3Rpb24oZWxlbWVudCwgbWFya2VyLCBhZGQpIHtcbiAgdmFyIGNvbnRhaW5lcjtcblxuICBpZiAoIWVsZW1lbnQuaWQpIHtcbiAgICBlbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChlbGVtZW50KTtcbiAgfVxuXG4gIC8vIHdlIG5lZWQgdG8gYWNjZXNzIGFsbFxuICBjb250YWluZXIgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuX2VsZW1lbnRzW2VsZW1lbnQuaWRdO1xuXG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaChbIGNvbnRhaW5lci5nZngsIGNvbnRhaW5lci5zZWNvbmRhcnlHZnggXSwgZnVuY3Rpb24oZ2Z4KSB7XG4gICAgaWYgKGdmeCkge1xuXG4gICAgICAvLyBpbnZva2UgZWl0aGVyIGFkZENsYXNzIG9yIHJlbW92ZUNsYXNzIGJhc2VkIG9uIG1vZGVcbiAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgc3ZnQ2xhc3NlcyhnZngpLmFkZChtYXJrZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ZnQ2xhc3NlcyhnZngpLnJlbW92ZShtYXJrZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhIG1hcmtlciBoYXMgYmVlbiB1cGRhdGVkIGZvciBhbiBlbGVtZW50XG4gICAqXG4gICAqIEBldmVudCBlbGVtZW50Lm1hcmtlci51cGRhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtkanMubW9kZWwuRWxlbWVudH0gZWxlbWVudCB0aGUgc2hhcGVcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGdmeCB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzaGFwZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbWFya2VyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWRkIHRydWUgaWYgdGhlIG1hcmtlciB3YXMgYWRkZWQsIGZhbHNlIGlmIGl0IGdvdCByZW1vdmVkXG4gICAqL1xuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdlbGVtZW50Lm1hcmtlci51cGRhdGUnLCB7IGVsZW1lbnQ6IGVsZW1lbnQsIGdmeDogY29udGFpbmVyLmdmeCwgbWFya2VyOiBtYXJrZXIsIGFkZDogISFhZGQgfSk7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIG1hcmtlciB0byBhbiBlbGVtZW50IChiYXNpY2FsbHkgYSBjc3MgY2xhc3MpLlxuICpcbiAqIEZpcmVzIHRoZSBlbGVtZW50Lm1hcmtlci51cGRhdGUgZXZlbnQsIG1ha2luZyBpdCBwb3NzaWJsZSB0b1xuICogaW50ZWdyYXRlIGV4dGVuc2lvbiBpbnRvIHRoZSBtYXJrZXIgbGlmZS1jeWNsZSwgdG9vLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjYW52YXMuYWRkTWFya2VyKCdmb28nLCAnc29tZS1tYXJrZXInKTtcbiAqXG4gKiB2YXIgZm9vR2Z4ID0gY2FudmFzLmdldEdyYXBoaWNzKCdmb28nKTtcbiAqXG4gKiBmb29HZng7IC8vIDxnIGNsYXNzPVwiLi4uIHNvbWUtbWFya2VyXCI+IC4uLiA8L2c+XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZXJcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5hZGRNYXJrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBtYXJrZXIpIHtcbiAgdGhpcy5fdXBkYXRlTWFya2VyKGVsZW1lbnQsIG1hcmtlciwgdHJ1ZSk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGEgbWFya2VyIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBGaXJlcyB0aGUgZWxlbWVudC5tYXJrZXIudXBkYXRlIGV2ZW50LCBtYWtpbmcgaXQgcG9zc2libGUgdG9cbiAqIGludGVncmF0ZSBleHRlbnNpb24gaW50byB0aGUgbWFya2VyIGxpZmUtY3ljbGUsIHRvby5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd8ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gbWFya2VyXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUucmVtb3ZlTWFya2VyID0gZnVuY3Rpb24oZWxlbWVudCwgbWFya2VyKSB7XG4gIHRoaXMuX3VwZGF0ZU1hcmtlcihlbGVtZW50LCBtYXJrZXIsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIGV4aXN0ZW5jZSBvZiBhIG1hcmtlciBvbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ3xkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHBhcmFtICB7c3RyaW5nfSBtYXJrZXJcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5oYXNNYXJrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBtYXJrZXIpIHtcbiAgaWYgKCFlbGVtZW50LmlkKSB7XG4gICAgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5nZXQoZWxlbWVudCk7XG4gIH1cblxuICB2YXIgZ2Z4ID0gdGhpcy5nZXRHcmFwaGljcyhlbGVtZW50KTtcblxuICByZXR1cm4gc3ZnQ2xhc3NlcyhnZngpLmhhcyhtYXJrZXIpO1xufTtcblxuLyoqXG4gKiBUb2dnbGVzIGEgbWFya2VyIG9uIGFuIGVsZW1lbnQuXG4gKlxuICogRmlyZXMgdGhlIGVsZW1lbnQubWFya2VyLnVwZGF0ZSBldmVudCwgbWFraW5nIGl0IHBvc3NpYmxlIHRvXG4gKiBpbnRlZ3JhdGUgZXh0ZW5zaW9uIGludG8gdGhlIG1hcmtlciBsaWZlLWN5Y2xlLCB0b28uXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfGRqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1hcmtlclxuICovXG5DYW52YXMucHJvdG90eXBlLnRvZ2dsZU1hcmtlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG1hcmtlcikge1xuICBpZiAodGhpcy5oYXNNYXJrZXIoZWxlbWVudCwgbWFya2VyKSkge1xuICAgIHRoaXMucmVtb3ZlTWFya2VyKGVsZW1lbnQsIG1hcmtlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hZGRNYXJrZXIoZWxlbWVudCwgbWFya2VyKTtcbiAgfVxufTtcblxuQ2FudmFzLnByb3RvdHlwZS5nZXRSb290RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgdGhpcy5zZXRSb290RWxlbWVudCh7IGlkOiAnX19pbXBsaWNpdHJvb3QnLCBjaGlsZHJlbjogW10gfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG59O1xuXG5cblxuLy8gcm9vdCBlbGVtZW50IGhhbmRsaW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBTZXRzIGEgZ2l2ZW4gZWxlbWVudCBhcyB0aGUgbmV3IHJvb3QgZWxlbWVudCBmb3IgdGhlIGNhbnZhc1xuICogYW5kIHJldHVybnMgdGhlIG5ldyByb290IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8ZGpzLm1vZGVsLlJvb3R9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJyaWRlXSB3aGV0aGVyIHRvIG92ZXJyaWRlIHRoZSBjdXJyZW50IHJvb3QgZWxlbWVudCwgaWYgYW55XG4gKlxuICogQHJldHVybiB7T2JqZWN0fGRqcy5tb2RlbC5Sb290fSBuZXcgcm9vdCBlbGVtZW50XG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuc2V0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBvdmVycmlkZSkge1xuXG4gIGlmIChlbGVtZW50KSB7XG4gICAgdGhpcy5fZW5zdXJlVmFsaWQoJ3Jvb3QnLCBlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBjdXJyZW50Um9vdCA9IHRoaXMuX3Jvb3RFbGVtZW50LFxuICAgICAgZWxlbWVudFJlZ2lzdHJ5ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LFxuICAgICAgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICBpZiAoY3VycmVudFJvb3QpIHtcbiAgICBpZiAoIW92ZXJyaWRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jvb3RFbGVtZW50IGFscmVhZHkgc2V0LCBuZWVkIHRvIHNwZWNpZnkgb3ZlcnJpZGUnKTtcbiAgICB9XG5cbiAgICAvLyBzaW11bGF0ZSBlbGVtZW50IHJlbW92ZSBldmVudCBzZXF1ZW5jZVxuICAgIGV2ZW50QnVzLmZpcmUoJ3Jvb3QucmVtb3ZlJywgeyBlbGVtZW50OiBjdXJyZW50Um9vdCB9KTtcbiAgICBldmVudEJ1cy5maXJlKCdyb290LnJlbW92ZWQnLCB7IGVsZW1lbnQ6IGN1cnJlbnRSb290IH0pO1xuXG4gICAgZWxlbWVudFJlZ2lzdHJ5LnJlbW92ZShjdXJyZW50Um9vdCk7XG4gIH1cblxuICBpZiAoZWxlbWVudCkge1xuICAgIHZhciBnZnggPSB0aGlzLmdldERlZmF1bHRMYXllcigpO1xuXG4gICAgLy8gcmVzZW1ibGUgZWxlbWVudCBhZGQgZXZlbnQgc2VxdWVuY2VcbiAgICBldmVudEJ1cy5maXJlKCdyb290LmFkZCcsIHsgZWxlbWVudDogZWxlbWVudCB9KTtcblxuICAgIGVsZW1lbnRSZWdpc3RyeS5hZGQoZWxlbWVudCwgZ2Z4LCB0aGlzLl9zdmcpO1xuXG4gICAgZXZlbnRCdXMuZmlyZSgncm9vdC5hZGRlZCcsIHsgZWxlbWVudDogZWxlbWVudCwgZ2Z4OiBnZnggfSk7XG4gIH1cblxuICB0aGlzLl9yb290RWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5cblxuLy8gYWRkIGZ1bmN0aW9uYWxpdHkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5DYW52YXMucHJvdG90eXBlLl9lbnN1cmVWYWxpZCA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50LmlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IG11c3QgaGF2ZSBhbiBpZCcpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5nZXQoZWxlbWVudC5pZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgd2l0aCBpZCAnICsgZWxlbWVudC5pZCArICcgYWxyZWFkeSBleGlzdHMnKTtcbiAgfVxuXG4gIHZhciByZXF1aXJlZEF0dHJzID0gUkVRVUlSRURfTU9ERUxfQVRUUlNbdHlwZV07XG5cbiAgdmFyIHZhbGlkID0gZXZlcnkocmVxdWlyZWRBdHRycywgZnVuY3Rpb24oYXR0cikge1xuICAgIHJldHVybiB0eXBlb2YgZWxlbWVudFthdHRyXSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH0pO1xuXG4gIGlmICghdmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnbXVzdCBzdXBwbHkgeyAnICsgcmVxdWlyZWRBdHRycy5qb2luKCcsICcpICsgJyB9IHdpdGggJyArIHR5cGUpO1xuICB9XG59O1xuXG5DYW52YXMucHJvdG90eXBlLl9zZXRQYXJlbnQgPSBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnQsIHBhcmVudEluZGV4KSB7XG4gIGNvbGxlY3Rpb25BZGQocGFyZW50LmNoaWxkcmVuLCBlbGVtZW50LCBwYXJlbnRJbmRleCk7XG4gIGVsZW1lbnQucGFyZW50ID0gcGFyZW50O1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIGNhbnZhcy5cbiAqXG4gKiBUaGlzIHdpcmVzIHRoZSBwYXJlbnQgPC0+IGNoaWxkIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZSBlbGVtZW50IGFuZFxuICogYSBleHBsaWNpdGx5IHNwZWNpZmllZCBwYXJlbnQgb3IgYW4gaW1wbGljaXQgcm9vdCBlbGVtZW50LlxuICpcbiAqIER1cmluZyBhZGQgaXQgZW1pdHMgdGhlIGV2ZW50c1xuICpcbiAqICAqIDx7dHlwZX0uYWRkPiAoZWxlbWVudCwgcGFyZW50KVxuICogICogPHt0eXBlfS5hZGRlZD4gKGVsZW1lbnQsIGdmeClcbiAqXG4gKiBFeHRlbnNpb25zIG1heSBob29rIGludG8gdGhlc2UgZXZlbnRzIHRvIHBlcmZvcm0gdGhlaXIgbWFnaWMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fGRqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdHxkanMubW9kZWwuQmFzZX0gW3BhcmVudF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyZW50SW5kZXhdXG4gKlxuICogQHJldHVybiB7T2JqZWN0fGRqcy5tb2RlbC5CYXNlfSB0aGUgYWRkZWQgZWxlbWVudFxuICovXG5DYW52YXMucHJvdG90eXBlLl9hZGRFbGVtZW50ID0gZnVuY3Rpb24odHlwZSwgZWxlbWVudCwgcGFyZW50LCBwYXJlbnRJbmRleCkge1xuXG4gIHBhcmVudCA9IHBhcmVudCB8fCB0aGlzLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXMsXG4gICAgICBncmFwaGljc0ZhY3RvcnkgPSB0aGlzLl9ncmFwaGljc0ZhY3Rvcnk7XG5cbiAgdGhpcy5fZW5zdXJlVmFsaWQodHlwZSwgZWxlbWVudCk7XG5cbiAgZXZlbnRCdXMuZmlyZSh0eXBlICsgJy5hZGQnLCB7IGVsZW1lbnQ6IGVsZW1lbnQsIHBhcmVudDogcGFyZW50IH0pO1xuXG4gIHRoaXMuX3NldFBhcmVudChlbGVtZW50LCBwYXJlbnQsIHBhcmVudEluZGV4KTtcblxuICAvLyBjcmVhdGUgZ3JhcGhpY3NcbiAgdmFyIGdmeCA9IGdyYXBoaWNzRmFjdG9yeS5jcmVhdGUodHlwZSwgZWxlbWVudCwgcGFyZW50SW5kZXgpO1xuXG4gIHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5hZGQoZWxlbWVudCwgZ2Z4KTtcblxuICAvLyB1cGRhdGUgaXRzIHZpc3VhbFxuICBncmFwaGljc0ZhY3RvcnkudXBkYXRlKHR5cGUsIGVsZW1lbnQsIGdmeCk7XG5cbiAgZXZlbnRCdXMuZmlyZSh0eXBlICsgJy5hZGRlZCcsIHsgZWxlbWVudDogZWxlbWVudCwgZ2Z4OiBnZnggfSk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBzaGFwZSB0byB0aGUgY2FudmFzXG4gKlxuICogQHBhcmFtIHtPYmplY3R8ZGpzLm1vZGVsLlNoYXBlfSBzaGFwZSB0byBhZGQgdG8gdGhlIGRpYWdyYW1cbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IFtwYXJlbnRdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmVudEluZGV4XVxuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5TaGFwZX0gdGhlIGFkZGVkIHNoYXBlXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbihzaGFwZSwgcGFyZW50LCBwYXJlbnRJbmRleCkge1xuICByZXR1cm4gdGhpcy5fYWRkRWxlbWVudCgnc2hhcGUnLCBzaGFwZSwgcGFyZW50LCBwYXJlbnRJbmRleCk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjb25uZWN0aW9uIHRvIHRoZSBjYW52YXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxkanMubW9kZWwuQ29ubmVjdGlvbn0gY29ubmVjdGlvbiB0byBhZGQgdG8gdGhlIGRpYWdyYW1cbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IFtwYXJlbnRdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmVudEluZGV4XVxuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5Db25uZWN0aW9ufSB0aGUgYWRkZWQgY29ubmVjdGlvblxuICovXG5DYW52YXMucHJvdG90eXBlLmFkZENvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uLCBwYXJlbnQsIHBhcmVudEluZGV4KSB7XG4gIHJldHVybiB0aGlzLl9hZGRFbGVtZW50KCdjb25uZWN0aW9uJywgY29ubmVjdGlvbiwgcGFyZW50LCBwYXJlbnRJbmRleCk7XG59O1xuXG5cbi8qKlxuICogSW50ZXJuYWwgcmVtb3ZlIGVsZW1lbnRcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5fcmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcblxuICB2YXIgZWxlbWVudFJlZ2lzdHJ5ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LFxuICAgICAgZ3JhcGhpY3NGYWN0b3J5ID0gdGhpcy5fZ3JhcGhpY3NGYWN0b3J5LFxuICAgICAgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICBlbGVtZW50ID0gZWxlbWVudFJlZ2lzdHJ5LmdldChlbGVtZW50LmlkIHx8IGVsZW1lbnQpO1xuXG4gIGlmICghZWxlbWVudCkge1xuXG4gICAgLy8gZWxlbWVudCB3YXMgcmVtb3ZlZCBhbHJlYWR5XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZXZlbnRCdXMuZmlyZSh0eXBlICsgJy5yZW1vdmUnLCB7IGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG5cbiAgZ3JhcGhpY3NGYWN0b3J5LnJlbW92ZShlbGVtZW50KTtcblxuICAvLyB1bnNldCBwYXJlbnQgPC0+IGNoaWxkIHJlbGF0aW9uc2hpcFxuICBjb2xsZWN0aW9uUmVtb3ZlKGVsZW1lbnQucGFyZW50ICYmIGVsZW1lbnQucGFyZW50LmNoaWxkcmVuLCBlbGVtZW50KTtcbiAgZWxlbWVudC5wYXJlbnQgPSBudWxsO1xuXG4gIGV2ZW50QnVzLmZpcmUodHlwZSArICcucmVtb3ZlZCcsIHsgZWxlbWVudDogZWxlbWVudCB9KTtcblxuICBlbGVtZW50UmVnaXN0cnkucmVtb3ZlKGVsZW1lbnQpO1xuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYSBzaGFwZSBmcm9tIHRoZSBjYW52YXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xkanMubW9kZWwuU2hhcGV9IHNoYXBlIG9yIHNoYXBlIGlkIHRvIGJlIHJlbW92ZWRcbiAqXG4gKiBAcmV0dXJuIHtkanMubW9kZWwuU2hhcGV9IHRoZSByZW1vdmVkIHNoYXBlXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUucmVtb3ZlU2hhcGUgPSBmdW5jdGlvbihzaGFwZSkge1xuXG4gIC8qKlxuICAgKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgYSBzaGFwZSBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gdGhlIGNhbnZhcy5cbiAgICpcbiAgICogQG1lbWJlck9mIENhbnZhc1xuICAgKlxuICAgKiBAZXZlbnQgc2hhcGUucmVtb3ZlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLlNoYXBlfSBlbGVtZW50IHRoZSBzaGFwZSBkZXNjcmlwdG9yXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBnZnggdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2hhcGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhIHNoYXBlIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgY2FudmFzLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgQ2FudmFzXG4gICAqXG4gICAqIEBldmVudCBzaGFwZS5yZW1vdmVkXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLlNoYXBlfSBlbGVtZW50IHRoZSBzaGFwZSBkZXNjcmlwdG9yXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBnZnggdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2hhcGVcbiAgICovXG4gIHJldHVybiB0aGlzLl9yZW1vdmVFbGVtZW50KHNoYXBlLCAnc2hhcGUnKTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmVzIGEgY29ubmVjdGlvbiBmcm9tIHRoZSBjYW52YXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xkanMubW9kZWwuQ29ubmVjdGlvbn0gY29ubmVjdGlvbiBvciBjb25uZWN0aW9uIGlkIHRvIGJlIHJlbW92ZWRcbiAqXG4gKiBAcmV0dXJuIHtkanMubW9kZWwuQ29ubmVjdGlvbn0gdGhlIHJlbW92ZWQgY29ubmVjdGlvblxuICovXG5DYW52YXMucHJvdG90eXBlLnJlbW92ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhIGNvbm5lY3Rpb24gaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBDYW52YXNcbiAgICpcbiAgICogQGV2ZW50IGNvbm5lY3Rpb24ucmVtb3ZlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLkNvbm5lY3Rpb259IGVsZW1lbnQgdGhlIGNvbm5lY3Rpb24gZGVzY3JpcHRvclxuICAgKiBAcHJvcGVydHkge09iamVjdH0gZ2Z4IHRoZSBncmFwaGljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbm5lY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhIGNvbm5lY3Rpb24gaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBDYW52YXNcbiAgICpcbiAgICogQGV2ZW50IGNvbm5lY3Rpb24ucmVtb3ZlZFxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge2Rqcy5tb2RlbC5Db25uZWN0aW9ufSBlbGVtZW50IHRoZSBjb25uZWN0aW9uIGRlc2NyaXB0b3JcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGdmeCB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb25uZWN0aW9uXG4gICAqL1xuICByZXR1cm4gdGhpcy5fcmVtb3ZlRWxlbWVudChjb25uZWN0aW9uLCAnY29ubmVjdGlvbicpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgZ3JhcGhpY2FsIG9iamVjdCB1bmRlcmxheWluZyBhIGNlcnRhaW4gZGlhZ3JhbSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnQgZGVzY3JpcHRvciBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBbc2Vjb25kYXJ5PWZhbHNlXSB3aGV0aGVyIHRvIHJldHVybiB0aGUgc2Vjb25kYXJ5IGNvbm5lY3RlZCBlbGVtZW50XG4gKlxuICogQHJldHVybiB7U1ZHRWxlbWVudH1cbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5nZXRHcmFwaGljcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIHNlY29uZGFyeSkge1xuICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldEdyYXBoaWNzKGVsZW1lbnQsIHNlY29uZGFyeSk7XG59O1xuXG5cbi8qKlxuICogUGVyZm9ybSBhIHZpZXdib3ggdXBkYXRlIHZpYSBhIGdpdmVuIGNoYW5nZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFuZ2VGblxuICovXG5DYW52YXMucHJvdG90eXBlLl9jaGFuZ2VWaWV3Ym94ID0gZnVuY3Rpb24oY2hhbmdlRm4pIHtcblxuICAvLyBub3RpZnkgb3RoZXJzIG9mIHRoZSB1cGNvbWluZyB2aWV3Ym94IGNoYW5nZVxuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjYW52YXMudmlld2JveC5jaGFuZ2luZycpO1xuXG4gIC8vIHBlcmZvcm0gYWN0dWFsIGNoYW5nZVxuICBjaGFuZ2VGbi5hcHBseSh0aGlzKTtcblxuICAvLyByZXNldCB0aGUgY2FjaGVkIHZpZXdib3ggc28gdGhhdFxuICAvLyBhIG5ldyBnZXQgb3BlcmF0aW9uIG9uIHZpZXdib3ggb3Igem9vbVxuICAvLyB0cmlnZ2VycyBhIHZpZXdib3ggcmUtY29tcHV0YXRpb25cbiAgdGhpcy5fY2FjaGVkVmlld2JveCA9IG51bGw7XG5cbiAgLy8gbm90aWZ5IG90aGVycyBvZiB0aGUgY2hhbmdlOyB0aGlzIHN0ZXBcbiAgLy8gbWF5IG9yIG1heSBub3QgYmUgZGVib3VuY2VkXG4gIHRoaXMuX3ZpZXdib3hDaGFuZ2VkKCk7XG59O1xuXG5DYW52YXMucHJvdG90eXBlLl92aWV3Ym94Q2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjYW52YXMudmlld2JveC5jaGFuZ2VkJywgeyB2aWV3Ym94OiB0aGlzLnZpZXdib3goKSB9KTtcbn07XG5cblxuLyoqXG4gKiBHZXRzIG9yIHNldHMgdGhlIHZpZXcgYm94IG9mIHRoZSBjYW52YXMsIGkuZS4gdGhlXG4gKiBhcmVhIHRoYXQgaXMgY3VycmVudGx5IGRpc3BsYXllZC5cbiAqXG4gKiBUaGUgZ2V0dGVyIG1heSByZXR1cm4gYSBjYWNoZWQgdmlld2JveCAoaWYgaXQgaXMgY3VycmVudGx5XG4gKiBjaGFuZ2luZykuIFRvIGZvcmNlIGEgcmVjb21wdXRhdGlvbiwgcGFzcyBgZmFsc2VgIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGNhbnZhcy52aWV3Ym94KHsgeDogMTAwLCB5OiAxMDAsIHdpZHRoOiA1MDAsIGhlaWdodDogNTAwIH0pXG4gKlxuICogLy8gc2V0cyB0aGUgdmlzaWJsZSBhcmVhIG9mIHRoZSBkaWFncmFtIHRvICgxMDB8MTAwKSAtPiAoNjAwfDEwMClcbiAqIC8vIGFuZCBhbmQgc2NhbGVzIGl0IGFjY29yZGluZyB0byB0aGUgZGlhZ3JhbSB3aWR0aFxuICpcbiAqIHZhciB2aWV3Ym94ID0gY2FudmFzLnZpZXdib3goKTsgLy8gcGFzcyBgZmFsc2VgIHRvIGZvcmNlIHJlY29tcHV0aW5nIHRoZSBib3guXG4gKlxuICogY29uc29sZS5sb2codmlld2JveCk7XG4gKiAvLyB7XG4gKiAvLyAgIGlubmVyOiBEaW1lbnNpb25zLFxuICogLy8gICBvdXRlcjogRGltZW5zaW9ucyxcbiAqIC8vICAgc2NhbGUsXG4gKiAvLyAgIHgsIHksXG4gKiAvLyAgIHdpZHRoLCBoZWlnaHRcbiAqIC8vIH1cbiAqXG4gKiAvLyBpZiB0aGUgY3VycmVudCBkaWFncmFtIGlzIHpvb21lZCBhbmQgc2Nyb2xsZWQsIHlvdSBtYXkgcmVzZXQgaXQgdG8gdGhlXG4gKiAvLyBkZWZhdWx0IHpvb20gdmlhIHRoaXMgbWV0aG9kLCB0b286XG4gKlxuICogdmFyIHpvb21lZEFuZFNjcm9sbGVkVmlld2JveCA9IGNhbnZhcy52aWV3Ym94KCk7XG4gKlxuICogY2FudmFzLnZpZXdib3goe1xuICogICB4OiAwLFxuICogICB5OiAwLFxuICogICB3aWR0aDogem9vbWVkQW5kU2Nyb2xsZWRWaWV3Ym94Lm91dGVyLndpZHRoLFxuICogICBoZWlnaHQ6IHpvb21lZEFuZFNjcm9sbGVkVmlld2JveC5vdXRlci5oZWlnaHRcbiAqIH0pO1xuICpcbiAqIEBwYXJhbSAge09iamVjdH0gW2JveF0gdGhlIG5ldyB2aWV3IGJveCB0byBzZXRcbiAqIEBwYXJhbSAge251bWJlcn0gYm94LnggdGhlIHRvcCBsZWZ0IFggY29vcmRpbmF0ZSBvZiB0aGUgY2FudmFzIHZpc2libGUgaW4gdmlldyBib3hcbiAqIEBwYXJhbSAge251bWJlcn0gYm94LnkgdGhlIHRvcCBsZWZ0IFkgY29vcmRpbmF0ZSBvZiB0aGUgY2FudmFzIHZpc2libGUgaW4gdmlldyBib3hcbiAqIEBwYXJhbSAge251bWJlcn0gYm94LndpZHRoIHRoZSB2aXNpYmxlIHdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGJveC5oZWlnaHRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjdXJyZW50IHZpZXcgYm94XG4gKi9cbkNhbnZhcy5wcm90b3R5cGUudmlld2JveCA9IGZ1bmN0aW9uKGJveCkge1xuXG4gIGlmIChib3ggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRWaWV3Ym94KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFZpZXdib3g7XG4gIH1cblxuICB2YXIgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydCxcbiAgICAgIGlubmVyQm94LFxuICAgICAgb3V0ZXJCb3ggPSB0aGlzLmdldFNpemUoKSxcbiAgICAgIG1hdHJpeCxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHNjYWxlLFxuICAgICAgeCwgeTtcblxuICBpZiAoIWJveCkge1xuXG4gICAgLy8gY29tcHV0ZSB0aGUgaW5uZXIgYm94IGJhc2VkIG9uIHRoZVxuICAgIC8vIGRpYWdyYW1zIGRlZmF1bHQgbGF5ZXIuIFRoaXMgYWxsb3dzIHVzIHRvIGV4Y2x1ZGVcbiAgICAvLyBleHRlcm5hbCBjb21wb25lbnRzLCBzdWNoIGFzIG92ZXJsYXlzXG4gICAgaW5uZXJCb3ggPSB0aGlzLmdldERlZmF1bHRMYXllcigpLmdldEJCb3goKTtcblxuICAgIHRyYW5zZm9ybSA9IHN2Z1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgbWF0cml4ID0gdHJhbnNmb3JtID8gdHJhbnNmb3JtLm1hdHJpeCA6IGNyZWF0ZU1hdHJpeCgpO1xuICAgIHNjYWxlID0gcm91bmQobWF0cml4LmEsIDEwMDApO1xuXG4gICAgeCA9IHJvdW5kKC1tYXRyaXguZSB8fCAwLCAxMDAwKTtcbiAgICB5ID0gcm91bmQoLW1hdHJpeC5mIHx8IDAsIDEwMDApO1xuXG4gICAgYm94ID0gdGhpcy5fY2FjaGVkVmlld2JveCA9IHtcbiAgICAgIHg6IHggPyB4IC8gc2NhbGUgOiAwLFxuICAgICAgeTogeSA/IHkgLyBzY2FsZSA6IDAsXG4gICAgICB3aWR0aDogb3V0ZXJCb3gud2lkdGggLyBzY2FsZSxcbiAgICAgIGhlaWdodDogb3V0ZXJCb3guaGVpZ2h0IC8gc2NhbGUsXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBpbm5lcjoge1xuICAgICAgICB3aWR0aDogaW5uZXJCb3gud2lkdGgsXG4gICAgICAgIGhlaWdodDogaW5uZXJCb3guaGVpZ2h0LFxuICAgICAgICB4OiBpbm5lckJveC54LFxuICAgICAgICB5OiBpbm5lckJveC55XG4gICAgICB9LFxuICAgICAgb3V0ZXI6IG91dGVyQm94XG4gICAgfTtcblxuICAgIHJldHVybiBib3g7XG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLl9jaGFuZ2VWaWV3Ym94KGZ1bmN0aW9uKCkge1xuICAgICAgc2NhbGUgPSBNYXRoLm1pbihvdXRlckJveC53aWR0aCAvIGJveC53aWR0aCwgb3V0ZXJCb3guaGVpZ2h0IC8gYm94LmhlaWdodCk7XG5cbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLl9zdmcuY3JlYXRlU1ZHTWF0cml4KClcbiAgICAgICAgLnNjYWxlKHNjYWxlKVxuICAgICAgICAudHJhbnNsYXRlKC1ib3gueCwgLWJveC55KTtcblxuICAgICAgc3ZnVHJhbnNmb3JtKHZpZXdwb3J0LCBtYXRyaXgpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGJveDtcbn07XG5cblxuLyoqXG4gKiBHZXRzIG9yIHNldHMgdGhlIHNjcm9sbCBvZiB0aGUgY2FudmFzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVsdGFdIHRoZSBuZXcgc2Nyb2xsIHRvIGFwcGx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsdGEuZHhdXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlbHRhLmR5XVxuICovXG5DYW52YXMucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uKGRlbHRhKSB7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLl92aWV3cG9ydDtcbiAgdmFyIG1hdHJpeCA9IG5vZGUuZ2V0Q1RNKCk7XG5cbiAgaWYgKGRlbHRhKSB7XG4gICAgdGhpcy5fY2hhbmdlVmlld2JveChmdW5jdGlvbigpIHtcbiAgICAgIGRlbHRhID0gYXNzaWduKHsgZHg6IDAsIGR5OiAwIH0sIGRlbHRhIHx8IHt9KTtcblxuICAgICAgbWF0cml4ID0gdGhpcy5fc3ZnLmNyZWF0ZVNWR01hdHJpeCgpLnRyYW5zbGF0ZShkZWx0YS5keCwgZGVsdGEuZHkpLm11bHRpcGx5KG1hdHJpeCk7XG5cbiAgICAgIHNldENUTShub2RlLCBtYXRyaXgpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHsgeDogbWF0cml4LmUsIHk6IG1hdHJpeC5mIH07XG59O1xuXG5cbi8qKlxuICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IHpvb20gb2YgdGhlIGNhbnZhcywgb3B0aW9uYWxseSB6b29taW5nXG4gKiB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICpcbiAqIFRoZSBnZXR0ZXIgbWF5IHJldHVybiBhIGNhY2hlZCB6b29tIGxldmVsLiBDYWxsIGl0IHdpdGggYGZhbHNlYCBhc1xuICogdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGZvcmNlIHJlY29tcHV0YXRpb24gb2YgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbbmV3U2NhbGVdIHRoZSBuZXcgem9vbSBsZXZlbCwgZWl0aGVyIGEgbnVtYmVyLCBpLmUuIDAuOSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBgZml0LXZpZXdwb3J0YCB0byBhZGp1c3QgdGhlIHNpemUgdG8gZml0IHRoZSBjdXJyZW50IHZpZXdwb3J0XG4gKiBAcGFyYW0ge3N0cmluZ3xQb2ludH0gW2NlbnRlcl0gdGhlIHJlZmVyZW5jZSBwb2ludCB7IHg6IC4uLCB5OiAuLn0gdG8gem9vbSB0bywgJ2F1dG8nIHRvIHpvb20gaW50byBtaWQgb3IgbnVsbFxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgc2NhbGVcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24obmV3U2NhbGUsIGNlbnRlcikge1xuXG4gIGlmICghbmV3U2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3Ym94KG5ld1NjYWxlKS5zY2FsZTtcbiAgfVxuXG4gIGlmIChuZXdTY2FsZSA9PT0gJ2ZpdC12aWV3cG9ydCcpIHtcbiAgICByZXR1cm4gdGhpcy5fZml0Vmlld3BvcnQoY2VudGVyKTtcbiAgfVxuXG4gIHZhciBvdXRlcixcbiAgICAgIG1hdHJpeDtcblxuICB0aGlzLl9jaGFuZ2VWaWV3Ym94KGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKHR5cGVvZiBjZW50ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICBvdXRlciA9IHRoaXMudmlld2JveCgpLm91dGVyO1xuXG4gICAgICBjZW50ZXIgPSB7XG4gICAgICAgIHg6IG91dGVyLndpZHRoIC8gMixcbiAgICAgICAgeTogb3V0ZXIuaGVpZ2h0IC8gMlxuICAgICAgfTtcbiAgICB9XG5cbiAgICBtYXRyaXggPSB0aGlzLl9zZXRab29tKG5ld1NjYWxlLCBjZW50ZXIpO1xuICB9KTtcblxuICByZXR1cm4gcm91bmQobWF0cml4LmEsIDEwMDApO1xufTtcblxuZnVuY3Rpb24gc2V0Q1RNKG5vZGUsIG0pIHtcbiAgdmFyIG1zdHIgPSAnbWF0cml4KCcgKyBtLmEgKyAnLCcgKyBtLmIgKyAnLCcgKyBtLmMgKyAnLCcgKyBtLmQgKyAnLCcgKyBtLmUgKyAnLCcgKyBtLmYgKyAnKSc7XG4gIG5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBtc3RyKTtcbn1cblxuQ2FudmFzLnByb3RvdHlwZS5fZml0Vmlld3BvcnQgPSBmdW5jdGlvbihjZW50ZXIpIHtcblxuICB2YXIgdmJveCA9IHRoaXMudmlld2JveCgpLFxuICAgICAgb3V0ZXIgPSB2Ym94Lm91dGVyLFxuICAgICAgaW5uZXIgPSB2Ym94LmlubmVyLFxuICAgICAgbmV3U2NhbGUsXG4gICAgICBuZXdWaWV3Ym94O1xuXG4gIC8vIGRpc3BsYXkgdGhlIGNvbXBsZXRlIGRpYWdyYW0gd2l0aG91dCB6b29taW5nIGluLlxuICAvLyBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gaW50ZXJuYWwgem9vbSwgd2UgcGVyZm9ybSBhXG4gIC8vIGhhcmQgcmVzZXQgb24gdGhlIGNhbnZhcyB2aWV3Ym94IHRvIHJlYWxpemUgdGhpc1xuICAvL1xuICAvLyBpZiBkaWFncmFtIGRvZXMgbm90IG5lZWQgdG8gYmUgem9vbWVkIGluLCB3ZSBmb2N1cyBpdCBhcm91bmRcbiAgLy8gdGhlIGRpYWdyYW0gb3JpZ2luIGluc3RlYWRcblxuICBpZiAoaW5uZXIueCA+PSAwICYmXG4gICAgICBpbm5lci55ID49IDAgJiZcbiAgICAgIGlubmVyLnggKyBpbm5lci53aWR0aCA8PSBvdXRlci53aWR0aCAmJlxuICAgICAgaW5uZXIueSArIGlubmVyLmhlaWdodCA8PSBvdXRlci5oZWlnaHQgJiZcbiAgICAgICFjZW50ZXIpIHtcblxuICAgIG5ld1ZpZXdib3ggPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBNYXRoLm1heChpbm5lci53aWR0aCArIGlubmVyLngsIG91dGVyLndpZHRoKSxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoaW5uZXIuaGVpZ2h0ICsgaW5uZXIueSwgb3V0ZXIuaGVpZ2h0KVxuICAgIH07XG4gIH0gZWxzZSB7XG5cbiAgICBuZXdTY2FsZSA9IE1hdGgubWluKDEsIG91dGVyLndpZHRoIC8gaW5uZXIud2lkdGgsIG91dGVyLmhlaWdodCAvIGlubmVyLmhlaWdodCk7XG4gICAgbmV3Vmlld2JveCA9IHtcbiAgICAgIHg6IGlubmVyLnggKyAoY2VudGVyID8gaW5uZXIud2lkdGggLyAyIC0gb3V0ZXIud2lkdGggLyBuZXdTY2FsZSAvIDIgOiAwKSxcbiAgICAgIHk6IGlubmVyLnkgKyAoY2VudGVyID8gaW5uZXIuaGVpZ2h0IC8gMiAtIG91dGVyLmhlaWdodCAvIG5ld1NjYWxlIC8gMiA6IDApLFxuICAgICAgd2lkdGg6IG91dGVyLndpZHRoIC8gbmV3U2NhbGUsXG4gICAgICBoZWlnaHQ6IG91dGVyLmhlaWdodCAvIG5ld1NjYWxlXG4gICAgfTtcbiAgfVxuXG4gIHRoaXMudmlld2JveChuZXdWaWV3Ym94KTtcblxuICByZXR1cm4gdGhpcy52aWV3Ym94KGZhbHNlKS5zY2FsZTtcbn07XG5cblxuQ2FudmFzLnByb3RvdHlwZS5fc2V0Wm9vbSA9IGZ1bmN0aW9uKHNjYWxlLCBjZW50ZXIpIHtcblxuICB2YXIgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydDtcblxuICB2YXIgbWF0cml4ID0gc3ZnLmNyZWF0ZVNWR01hdHJpeCgpO1xuICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcblxuICB2YXIgY2VudGVyUG9pbnQsXG4gICAgICBvcmlnaW5hbFBvaW50LFxuICAgICAgY3VycmVudE1hdHJpeCxcbiAgICAgIHNjYWxlTWF0cml4LFxuICAgICAgbmV3TWF0cml4O1xuXG4gIGN1cnJlbnRNYXRyaXggPSB2aWV3cG9ydC5nZXRDVE0oKTtcblxuICB2YXIgY3VycmVudFNjYWxlID0gY3VycmVudE1hdHJpeC5hO1xuXG4gIGlmIChjZW50ZXIpIHtcbiAgICBjZW50ZXJQb2ludCA9IGFzc2lnbihwb2ludCwgY2VudGVyKTtcblxuICAgIC8vIHJldmVydCBhcHBsaWVkIHZpZXdwb3J0IHRyYW5zZm9ybWF0aW9uc1xuICAgIG9yaWdpbmFsUG9pbnQgPSBjZW50ZXJQb2ludC5tYXRyaXhUcmFuc2Zvcm0oY3VycmVudE1hdHJpeC5pbnZlcnNlKCkpO1xuXG4gICAgLy8gY3JlYXRlIHNjYWxlIG1hdHJpeFxuICAgIHNjYWxlTWF0cml4ID0gbWF0cml4XG4gICAgICAudHJhbnNsYXRlKG9yaWdpbmFsUG9pbnQueCwgb3JpZ2luYWxQb2ludC55KVxuICAgICAgLnNjYWxlKDEgLyBjdXJyZW50U2NhbGUgKiBzY2FsZSlcbiAgICAgIC50cmFuc2xhdGUoLW9yaWdpbmFsUG9pbnQueCwgLW9yaWdpbmFsUG9pbnQueSk7XG5cbiAgICBuZXdNYXRyaXggPSBjdXJyZW50TWF0cml4Lm11bHRpcGx5KHNjYWxlTWF0cml4KTtcbiAgfSBlbHNlIHtcbiAgICBuZXdNYXRyaXggPSBtYXRyaXguc2NhbGUoc2NhbGUpO1xuICB9XG5cbiAgc2V0Q1RNKHRoaXMuX3ZpZXdwb3J0LCBuZXdNYXRyaXgpO1xuXG4gIHJldHVybiBuZXdNYXRyaXg7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzXG4gKlxuICogQHJldHVybiB7RGltZW5zaW9uc31cbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgfTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGFic29sdXRlIGJvdW5kaW5nIGJveCBmb3IgdGhlIGdpdmVuIGVsZW1lbnRcbiAqXG4gKiBUaGUgYWJzb2x1dGUgYm91bmRpbmcgYm94IG1heSBiZSB1c2VkIHRvIGRpc3BsYXkgb3ZlcmxheXMgaW4gdGhlXG4gKiBjYWxsZXJzIChicm93c2VyKSBjb29yZGluYXRlIHN5c3RlbSByYXRoZXIgdGhhbiB0aGUgem9vbWVkIGluL291dFxuICogY2FudmFzIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnREZXNjcmlwdG9yfSBlbGVtZW50XG4gKiBAcmV0dXJuIHtCb3VuZHN9IHRoZSBhYnNvbHV0ZSBib3VuZGluZyBib3hcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5nZXRBYnNvbHV0ZUJCb3ggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciB2Ym94ID0gdGhpcy52aWV3Ym94KCk7XG4gIHZhciBiYm94O1xuXG4gIC8vIGNvbm5lY3Rpb25cbiAgLy8gdXNlIHN2ZyBiYm94XG4gIGlmIChlbGVtZW50LndheXBvaW50cykge1xuICAgIHZhciBnZnggPSB0aGlzLmdldEdyYXBoaWNzKGVsZW1lbnQpO1xuXG4gICAgYmJveCA9IGdmeC5nZXRCQm94KCk7XG4gIH1cblxuICAvLyBzaGFwZXNcbiAgLy8gdXNlIGRhdGFcbiAgZWxzZSB7XG4gICAgYmJveCA9IGVsZW1lbnQ7XG4gIH1cblxuICB2YXIgeCA9IGJib3gueCAqIHZib3guc2NhbGUgLSB2Ym94LnggKiB2Ym94LnNjYWxlO1xuICB2YXIgeSA9IGJib3gueSAqIHZib3guc2NhbGUgLSB2Ym94LnkgKiB2Ym94LnNjYWxlO1xuXG4gIHZhciB3aWR0aCA9IGJib3gud2lkdGggKiB2Ym94LnNjYWxlO1xuICB2YXIgaGVpZ2h0ID0gYmJveC5oZWlnaHQgKiB2Ym94LnNjYWxlO1xuXG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufTtcblxuLyoqXG4gKiBGaXJlcyBhbiBldmVudCBpbiBvcmRlciBvdGhlciBtb2R1bGVzIGNhbiByZWFjdCB0byB0aGVcbiAqIGNhbnZhcyByZXNpemluZ1xuICovXG5DYW52YXMucHJvdG90eXBlLnJlc2l6ZWQgPSBmdW5jdGlvbigpIHtcblxuICAvLyBmb3JjZSByZWNvbXB1dGF0aW9uIG9mIHZpZXcgYm94XG4gIGRlbGV0ZSB0aGlzLl9jYWNoZWRWaWV3Ym94O1xuXG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NhbnZhcy5yZXNpemVkJyk7XG59O1xuIiwiaW1wb3J0IHtcbiAgY3JlYXRlXG59IGZyb20gJy4uL21vZGVsJztcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbWluLWRhc2gnO1xuXG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgZGlhZ3JhbS1qcyBzaGFwZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRWxlbWVudEZhY3RvcnkoKSB7XG4gIHRoaXMuX3VpZCA9IDEyO1xufVxuXG5cbkVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVSb290ID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlKCdyb290JywgYXR0cnMpO1xufTtcblxuRWxlbWVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUxhYmVsID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlKCdsYWJlbCcsIGF0dHJzKTtcbn07XG5cbkVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVTaGFwZSA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gIHJldHVybiB0aGlzLmNyZWF0ZSgnc2hhcGUnLCBhdHRycyk7XG59O1xuXG5FbGVtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gIHJldHVybiB0aGlzLmNyZWF0ZSgnY29ubmVjdGlvbicsIGF0dHJzKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbW9kZWwgZWxlbWVudCB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZFxuICogYSBudW1iZXIgb2YgcHJlLXNldCBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZVxuICogQHBhcmFtICB7T2JqZWN0fSBhdHRyc1xuICogQHJldHVybiB7ZGpzLm1vZGVsLkJhc2V9IHRoZSBuZXdseSBjcmVhdGVkIG1vZGVsIGluc3RhbmNlXG4gKi9cbkVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbih0eXBlLCBhdHRycykge1xuXG4gIGF0dHJzID0gYXNzaWduKHt9LCBhdHRycyB8fCB7fSk7XG5cbiAgaWYgKCFhdHRycy5pZCkge1xuICAgIGF0dHJzLmlkID0gdHlwZSArICdfJyArICh0aGlzLl91aWQrKyk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlKHR5cGUsIGF0dHJzKTtcbn07IiwidmFyIEVMRU1FTlRfSUQgPSAnZGF0YS1lbGVtZW50LWlkJztcblxuaW1wb3J0IHsgYXR0ciBhcyBzdmdBdHRyIH0gZnJvbSAndGlueS1zdmcnO1xuXG5cbi8qKlxuICogQGNsYXNzXG4gKlxuICogQSByZWdpc3RyeSB0aGF0IGtlZXBzIHRyYWNrIG9mIGFsbCBzaGFwZXMgaW4gdGhlIGRpYWdyYW0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVsZW1lbnRSZWdpc3RyeShldmVudEJ1cykge1xuICB0aGlzLl9lbGVtZW50cyA9IHt9O1xuXG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG59XG5cbkVsZW1lbnRSZWdpc3RyeS4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnIF07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBwYWlyIG9mIChlbGVtZW50LCBnZngsIChzZWNvbmRhcnlHZngpKS5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBbc2Vjb25kYXJ5R2Z4XSBvcHRpb25hbCBvdGhlciBlbGVtZW50IHRvIHJlZ2lzdGVyLCB0b29cbiAqL1xuRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlbGVtZW50LCBnZngsIHNlY29uZGFyeUdmeCkge1xuXG4gIHZhciBpZCA9IGVsZW1lbnQuaWQ7XG5cbiAgdGhpcy5fdmFsaWRhdGVJZChpZCk7XG5cbiAgLy8gYXNzb2NpYXRlIGRvbSBub2RlIHdpdGggZWxlbWVudFxuICBzdmdBdHRyKGdmeCwgRUxFTUVOVF9JRCwgaWQpO1xuXG4gIGlmIChzZWNvbmRhcnlHZngpIHtcbiAgICBzdmdBdHRyKHNlY29uZGFyeUdmeCwgRUxFTUVOVF9JRCwgaWQpO1xuICB9XG5cbiAgdGhpcy5fZWxlbWVudHNbaWRdID0geyBlbGVtZW50OiBlbGVtZW50LCBnZng6IGdmeCwgc2Vjb25kYXJ5R2Z4OiBzZWNvbmRhcnlHZnggfTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIHJlZ2lzdHJ5LlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqL1xuRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBlbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzLFxuICAgICAgaWQgPSBlbGVtZW50LmlkIHx8IGVsZW1lbnQsXG4gICAgICBjb250YWluZXIgPSBpZCAmJiBlbGVtZW50c1tpZF07XG5cbiAgaWYgKGNvbnRhaW5lcikge1xuXG4gICAgLy8gdW5zZXQgZWxlbWVudCBpZCBvbiBnZnhcbiAgICBzdmdBdHRyKGNvbnRhaW5lci5nZngsIEVMRU1FTlRfSUQsICcnKTtcblxuICAgIGlmIChjb250YWluZXIuc2Vjb25kYXJ5R2Z4KSB7XG4gICAgICBzdmdBdHRyKGNvbnRhaW5lci5zZWNvbmRhcnlHZngsIEVMRU1FTlRfSUQsICcnKTtcbiAgICB9XG5cbiAgICBkZWxldGUgZWxlbWVudHNbaWRdO1xuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgaWQgb2YgYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdJZFxuICovXG5FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLnVwZGF0ZUlkID0gZnVuY3Rpb24oZWxlbWVudCwgbmV3SWQpIHtcblxuICB0aGlzLl92YWxpZGF0ZUlkKG5ld0lkKTtcblxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgZWxlbWVudCA9IHRoaXMuZ2V0KGVsZW1lbnQpO1xuICB9XG5cbiAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnZWxlbWVudC51cGRhdGVJZCcsIHtcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIG5ld0lkOiBuZXdJZFxuICB9KTtcblxuICB2YXIgZ2Z4ID0gdGhpcy5nZXRHcmFwaGljcyhlbGVtZW50KSxcbiAgICAgIHNlY29uZGFyeUdmeCA9IHRoaXMuZ2V0R3JhcGhpY3MoZWxlbWVudCwgdHJ1ZSk7XG5cbiAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG5cbiAgZWxlbWVudC5pZCA9IG5ld0lkO1xuXG4gIHRoaXMuYWRkKGVsZW1lbnQsIGdmeCwgc2Vjb25kYXJ5R2Z4KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtb2RlbCBlbGVtZW50IGZvciBhIGdpdmVuIGlkIG9yIGdyYXBoaWNzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogZWxlbWVudFJlZ2lzdHJ5LmdldCgnU29tZUVsZW1lbnRJZF8xJyk7XG4gKiBlbGVtZW50UmVnaXN0cnkuZ2V0KGdmeCk7XG4gKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFNWR0VsZW1lbnR9IGZpbHRlciBmb3Igc2VsZWN0aW5nIHRoZSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7ZGpzLm1vZGVsLkJhc2V9XG4gKi9cbkVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gIHZhciBpZDtcblxuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICBpZCA9IGZpbHRlcjtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IGZpbHRlciAmJiBzdmdBdHRyKGZpbHRlciwgRUxFTUVOVF9JRCk7XG4gIH1cblxuICB2YXIgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudHNbaWRdO1xuICByZXR1cm4gY29udGFpbmVyICYmIGNvbnRhaW5lci5lbGVtZW50O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYWxsIGVsZW1lbnRzIHRoYXQgbWF0Y2ggYSBnaXZlbiBmaWx0ZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59XG4gKi9cbkVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZm4pIHtcblxuICB2YXIgZmlsdGVyZWQgPSBbXTtcblxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgZ2Z4KSB7XG4gICAgaWYgKGZuKGVsZW1lbnQsIGdmeCkpIHtcbiAgICAgIGZpbHRlcmVkLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmlsdGVyZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5CYXNlfVxuICovXG5FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihmbikge1xuICB2YXIgbWFwID0gdGhpcy5fZWxlbWVudHMsXG4gICAgICBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaWQgPSBrZXlzW2ldLFxuICAgICAgICBjb250YWluZXIgPSBtYXBbaWRdLFxuICAgICAgICBlbGVtZW50ID0gY29udGFpbmVyLmVsZW1lbnQsXG4gICAgICAgIGdmeCA9IGNvbnRhaW5lci5nZng7XG5cbiAgICBpZiAoZm4oZWxlbWVudCwgZ2Z4KSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybiBhbGwgcmVuZGVyZWQgbW9kZWwgZWxlbWVudHMuXG4gKlxuICogQHJldHVybiB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fVxuICovXG5FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oZSkgeyByZXR1cm4gZTsgfSk7XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgZGlhZ3JhbSBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmbikge1xuXG4gIHZhciBtYXAgPSB0aGlzLl9lbGVtZW50cztcblxuICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gbWFwW2lkXSxcbiAgICAgICAgZWxlbWVudCA9IGNvbnRhaW5lci5lbGVtZW50LFxuICAgICAgICBnZnggPSBjb250YWluZXIuZ2Z4O1xuXG4gICAgcmV0dXJuIGZuKGVsZW1lbnQsIGdmeCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhbiBlbGVtZW50IG9yIGl0cyBpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogZWxlbWVudFJlZ2lzdHJ5LmdldEdyYXBoaWNzKCdTb21lRWxlbWVudElkXzEnKTtcbiAqIGVsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhyb290RWxlbWVudCk7IC8vIDxnIC4uLj5cbiAqXG4gKiBlbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3Mocm9vdEVsZW1lbnQsIHRydWUpOyAvLyA8c3ZnIC4uLj5cbiAqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZGpzLm1vZGVsLkJhc2V9IGZpbHRlclxuICogQHBhcmFtIHtib29sZWFufSBbc2Vjb25kYXJ5PWZhbHNlXSB3aGV0aGVyIHRvIHJldHVybiB0aGUgc2Vjb25kYXJ5IGNvbm5lY3RlZCBlbGVtZW50XG4gKlxuICogQHJldHVybiB7U1ZHRWxlbWVudH1cbiAqL1xuRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRHcmFwaGljcyA9IGZ1bmN0aW9uKGZpbHRlciwgc2Vjb25kYXJ5KSB7XG4gIHZhciBpZCA9IGZpbHRlci5pZCB8fCBmaWx0ZXI7XG5cbiAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2VsZW1lbnRzW2lkXTtcbiAgcmV0dXJuIGNvbnRhaW5lciAmJiAoc2Vjb25kYXJ5ID8gY29udGFpbmVyLnNlY29uZGFyeUdmeCA6IGNvbnRhaW5lci5nZngpO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgc3VpdGFiaWxpdHkgb2YgdGhlIGdpdmVuIGlkIGFuZCBzaWduYWxzIGEgcHJvYmxlbVxuICogd2l0aCBhbiBleGNlcHRpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIGlkIGlzIGVtcHR5IG9yIGFscmVhZHkgYXNzaWduZWRcbiAqL1xuRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5fdmFsaWRhdGVJZCA9IGZ1bmN0aW9uKGlkKSB7XG4gIGlmICghaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgbXVzdCBoYXZlIGFuIGlkJyk7XG4gIH1cblxuICBpZiAodGhpcy5fZWxlbWVudHNbaWRdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IHdpdGggaWQgJyArIGlkICsgJyBhbHJlYWR5IGFkZGVkJyk7XG4gIH1cbn07XG4iLCJpbXBvcnQge1xuICBpc0Z1bmN0aW9uLFxuICBpc0FycmF5LFxuICBpc051bWJlcixcbiAgYmluZCxcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxudmFyIEZOX1JFRiA9ICdfX2ZuJztcblxudmFyIERFRkFVTFRfUFJJT1JJVFkgPSAxMDAwO1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogQSBnZW5lcmFsIHB1cnBvc2UgZXZlbnQgYnVzLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gY29tbXVuaWNhdGUgYWNyb3NzIGEgZGlhZ3JhbSBpbnN0YW5jZS5cbiAqIE90aGVyIHBhcnRzIG9mIGEgZGlhZ3JhbSBjYW4gdXNlIGl0IHRvIGxpc3RlbiB0byBhbmQgYnJvYWRjYXN0IGV2ZW50cy5cbiAqXG4gKlxuICogIyMgUmVnaXN0ZXJpbmcgZm9yIEV2ZW50c1xuICpcbiAqIFRoZSBldmVudCBidXMgcHJvdmlkZXMgdGhlIHtAbGluayBFdmVudEJ1cyNvbn0gYW5kIHtAbGluayBFdmVudEJ1cyNvbmNlfVxuICogbWV0aG9kcyB0byByZWdpc3RlciBmb3IgZXZlbnRzLiB7QGxpbmsgRXZlbnRCdXMjb2ZmfSBjYW4gYmUgdXNlZCB0b1xuICogcmVtb3ZlIGV2ZW50IHJlZ2lzdHJhdGlvbnMuIExpc3RlbmVycyByZWNlaXZlIGFuIGluc3RhbmNlIG9mIHtAbGluayBFdmVudH1cbiAqIGFzIHRoZSBmaXJzdCBhcmd1bWVudC4gSXQgYWxsb3dzIHRoZW0gdG8gaG9vayBpbnRvIHRoZSBldmVudCBleGVjdXRpb24uXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICpcbiAqIC8vIGxpc3RlbiBmb3IgZXZlbnRcbiAqIGV2ZW50QnVzLm9uKCdmb28nLCBmdW5jdGlvbihldmVudCkge1xuICpcbiAqICAgLy8gYWNjZXNzIGV2ZW50IHR5cGVcbiAqICAgZXZlbnQudHlwZTsgLy8gJ2ZvbydcbiAqXG4gKiAgIC8vIHN0b3AgcHJvcGFnYXRpb24gdG8gb3RoZXIgbGlzdGVuZXJzXG4gKiAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICpcbiAqICAgLy8gcHJldmVudCBldmVudCBkZWZhdWx0XG4gKiAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gKiB9KTtcbiAqXG4gKiAvLyBsaXN0ZW4gZm9yIGV2ZW50IHdpdGggY3VzdG9tIHBheWxvYWRcbiAqIGV2ZW50QnVzLm9uKCdiYXInLCBmdW5jdGlvbihldmVudCwgcGF5bG9hZCkge1xuICogICBjb25zb2xlLmxvZyhwYXlsb2FkKTtcbiAqIH0pO1xuICpcbiAqIC8vIGxpc3RlbiBmb3IgZXZlbnQgcmV0dXJuaW5nIHZhbHVlXG4gKiBldmVudEJ1cy5vbignZm9vYmFyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqXG4gKiAgIC8vIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24gKyBwcmV2ZW50IGRlZmF1bHRcbiAqICAgcmV0dXJuIGZhbHNlO1xuICpcbiAqICAgLy8gc3RvcCBldmVudCBwcm9wYWdhdGlvbiArIHJldHVybiBjdXN0b20gcmVzdWx0XG4gKiAgIHJldHVybiB7XG4gKiAgICAgY29tcGxleDogJ2xpc3RlbmluZyByZXN1bHQnXG4gKiAgIH07XG4gKiB9KTtcbiAqXG4gKlxuICogLy8gbGlzdGVuIHdpdGggY3VzdG9tIHByaW9yaXR5IChkZWZhdWx0PTEwMDAsIGhpZ2hlciBpcyBiZXR0ZXIpXG4gKiBldmVudEJ1cy5vbigncHJpb3JpdHlmb28nLCAxNTAwLCBmdW5jdGlvbihldmVudCkge1xuICogICBjb25zb2xlLmxvZygnaW52b2tlZCBmaXJzdCEnKTtcbiAqIH0pO1xuICpcbiAqXG4gKiAvLyBsaXN0ZW4gZm9yIGV2ZW50IGFuZCBwYXNzIHRoZSBjb250ZXh0IChgdGhpc2ApXG4gKiBldmVudEJ1cy5vbignZm9vYmFyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgdGhpcy5mb28oKTtcbiAqIH0sIHRoaXMpO1xuICogYGBgXG4gKlxuICpcbiAqICMjIEVtaXR0aW5nIEV2ZW50c1xuICpcbiAqIEV2ZW50cyBjYW4gYmUgZW1pdHRlZCB2aWEgdGhlIGV2ZW50IGJ1cyB1c2luZyB7QGxpbmsgRXZlbnRCdXMjZmlyZX0uXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICpcbiAqIC8vIGZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBkZWZhdWx0IGFjdGlvblxuICogLy8gd2FzIHByZXZlbnRlZCBieSBsaXN0ZW5lcnNcbiAqIGlmIChldmVudEJ1cy5maXJlKCdmb28nKSA9PT0gZmFsc2UpIHtcbiAqICAgY29uc29sZS5sb2coJ2RlZmF1bHQgaGFzIGJlZW4gcHJldmVudGVkIScpO1xuICogfTtcbiAqXG4gKlxuICogLy8gY3VzdG9tIGFyZ3MgKyByZXR1cm4gdmFsdWUgbGlzdGVuZXJcbiAqIGV2ZW50QnVzLm9uKCdzdW0nLCBmdW5jdGlvbihldmVudCwgYSwgYikge1xuICogICByZXR1cm4gYSArIGI7XG4gKiB9KTtcbiAqXG4gKiAvLyB5b3UgY2FuIHBhc3MgY3VzdG9tIGFyZ3VtZW50cyArIHJldHJpZXZlIHJlc3VsdCB2YWx1ZXMuXG4gKiB2YXIgc3VtID0gZXZlbnRCdXMuZmlyZSgnc3VtJywgMSwgMik7XG4gKiBjb25zb2xlLmxvZyhzdW0pOyAvLyAzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRXZlbnRCdXMoKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gIC8vIGNsZWFudXAgb24gZGVzdHJveSBvbiBsb3dlc3QgcHJpb3JpdHkgdG8gYWxsb3dcbiAgLy8gbWVzc2FnZSBwYXNzaW5nIHVudGlsIHRoZSBiaXR0ZXIgZW5kXG4gIHRoaXMub24oJ2RpYWdyYW0uZGVzdHJveScsIDEsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGV2ZW50cyB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICpcbiAqIFRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2l0aCBgZXZlbnQsIC4uLmFkZGl0aW9uYWxBcmd1bWVudHNgXG4gKiB0aGF0IGhhdmUgYmVlbiBwYXNzZWQgdG8ge0BsaW5rIEV2ZW50QnVzI2ZpcmV9LlxuICpcbiAqIFJldHVybmluZyBmYWxzZSBmcm9tIGEgbGlzdGVuZXIgd2lsbCBwcmV2ZW50IHRoZSBldmVudHMgZGVmYXVsdCBhY3Rpb25cbiAqIChpZiBhbnkgaXMgc3BlY2lmaWVkKS4gVG8gc3RvcCBhbiBldmVudCBmcm9tIGJlaW5nIHByb2Nlc3NlZCBmdXJ0aGVyIGluXG4gKiBvdGhlciBsaXN0ZW5lcnMgZXhlY3V0ZSB7QGxpbmsgRXZlbnQjc3RvcFByb3BhZ2F0aW9ufS5cbiAqXG4gKiBSZXR1cm5pbmcgYW55dGhpbmcgYnV0IGB1bmRlZmluZWRgIGZyb20gYSBsaXN0ZW5lciB3aWxsIHN0b3AgdGhlIGxpc3RlbmVyIHByb3BhZ2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IGV2ZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXSB0aGUgcHJpb3JpdHkgaW4gd2hpY2ggdGhpcyBsaXN0ZW5lciBpcyBjYWxsZWQsIGxhcmdlciBpcyBoaWdoZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW3RoYXRdIFBhc3MgY29udGV4dCAoYHRoaXNgKSB0byB0aGUgY2FsbGJhY2tcbiAqL1xuRXZlbnRCdXMucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnRzLCBwcmlvcml0eSwgY2FsbGJhY2ssIHRoYXQpIHtcblxuICBldmVudHMgPSBpc0FycmF5KGV2ZW50cykgPyBldmVudHMgOiBbIGV2ZW50cyBdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKHByaW9yaXR5KSkge1xuICAgIHRoYXQgPSBjYWxsYmFjaztcbiAgICBjYWxsYmFjayA9IHByaW9yaXR5O1xuICAgIHByaW9yaXR5ID0gREVGQVVMVF9QUklPUklUWTtcbiAgfVxuXG4gIGlmICghaXNOdW1iZXIocHJpb3JpdHkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcmlvcml0eSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cblxuICB2YXIgYWN0dWFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBpZiAodGhhdCkge1xuICAgIGFjdHVhbENhbGxiYWNrID0gYmluZChjYWxsYmFjaywgdGhhdCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UgcmVtZW1iZXIgYW5kIGFyZSBhYmxlIHRvIHJlbW92ZVxuICAgIC8vIGJvdW5kIGNhbGxiYWNrcyB2aWEge0BsaW5rICNvZmZ9IHVzaW5nIHRoZSBvcmlnaW5hbFxuICAgIC8vIGNhbGxiYWNrXG4gICAgYWN0dWFsQ2FsbGJhY2tbRk5fUkVGXSA9IGNhbGxiYWNrW0ZOX1JFRl0gfHwgY2FsbGJhY2s7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgIHNlbGYuX2FkZExpc3RlbmVyKGUsIHtcbiAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgIGNhbGxiYWNrOiBhY3R1YWxDYWxsYmFjayxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBpcyBleGVjdXRlZCBvbmx5IG9uY2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IHRoZSBldmVudCBuYW1lIHRvIHJlZ2lzdGVyIGZvclxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXSB0aGUgcHJpb3JpdHkgaW4gd2hpY2ggdGhpcyBsaXN0ZW5lciBpcyBjYWxsZWQsIGxhcmdlciBpcyBoaWdoZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRoZSBjYWxsYmFjayB0byBleGVjdXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW3RoYXRdIFBhc3MgY29udGV4dCAoYHRoaXNgKSB0byB0aGUgY2FsbGJhY2tcbiAqL1xuRXZlbnRCdXMucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgcHJpb3JpdHksIGNhbGxiYWNrLCB0aGF0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoaXNGdW5jdGlvbihwcmlvcml0eSkpIHtcbiAgICB0aGF0ID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSBwcmlvcml0eTtcbiAgICBwcmlvcml0eSA9IERFRkFVTFRfUFJJT1JJVFk7XG4gIH1cblxuICBpZiAoIWlzTnVtYmVyKHByaW9yaXR5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpb3JpdHkgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBlZENhbGxiYWNrKCkge1xuICAgIHdyYXBwZWRDYWxsYmFjay5fX2lzVG9tYiA9IHRydWU7XG5cbiAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2suYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcblxuICAgIHNlbGYub2ZmKGV2ZW50LCB3cmFwcGVkQ2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSByZW1lbWJlciBhbmQgYXJlIGFibGUgdG8gcmVtb3ZlXG4gIC8vIGJvdW5kIGNhbGxiYWNrcyB2aWEge0BsaW5rICNvZmZ9IHVzaW5nIHRoZSBvcmlnaW5hbFxuICAvLyBjYWxsYmFja1xuICB3cmFwcGVkQ2FsbGJhY2tbRk5fUkVGXSA9IGNhbGxiYWNrO1xuXG4gIHRoaXMub24oZXZlbnQsIHByaW9yaXR5LCB3cmFwcGVkQ2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGJ5IGV2ZW50IGFuZCBjYWxsYmFjay5cbiAqXG4gKiBJZiBubyBjYWxsYmFjayBpcyBnaXZlbiwgYWxsIGxpc3RlbmVycyBmb3IgYSBnaXZlbiBldmVudCBuYW1lIGFyZSBiZWluZyByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IGV2ZW50c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICovXG5FdmVudEJ1cy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oZXZlbnRzLCBjYWxsYmFjaykge1xuXG4gIGV2ZW50cyA9IGlzQXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IFsgZXZlbnRzIF07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgc2VsZi5fcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKTtcbiAgfSk7XG5cbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gRXZlbnRCdXMgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGV2ZW50LCByZWNvZ25pemVkIGJ5IHRoZSBldmVudEJ1c1xuICovXG5FdmVudEJ1cy5wcm90b3R5cGUuY3JlYXRlRXZlbnQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBldmVudCA9IG5ldyBJbnRlcm5hbEV2ZW50KCk7XG5cbiAgZXZlbnQuaW5pdChkYXRhKTtcblxuICByZXR1cm4gZXZlbnQ7XG59O1xuXG5cbi8qKlxuICogRmlyZXMgYSBuYW1lZCBldmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGZpcmUgZXZlbnQgYnkgbmFtZVxuICogZXZlbnRzLmZpcmUoJ2ZvbycpO1xuICpcbiAqIC8vIGZpcmUgZXZlbnQgb2JqZWN0IHdpdGggbmVzdGVkIHR5cGVcbiAqIHZhciBldmVudCA9IHsgdHlwZTogJ2ZvbycgfTtcbiAqIGV2ZW50cy5maXJlKGV2ZW50KTtcbiAqXG4gKiAvLyBmaXJlIGV2ZW50IHdpdGggZXhwbGljaXQgdHlwZVxuICogdmFyIGV2ZW50ID0geyB4OiAxMCwgeTogMjAgfTtcbiAqIGV2ZW50cy5maXJlKCdlbGVtZW50Lm1vdmVkJywgZXZlbnQpO1xuICpcbiAqIC8vIHBhc3MgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gdGhlIGV2ZW50XG4gKiBldmVudHMub24oJ2ZvbycsIGZ1bmN0aW9uKGV2ZW50LCBiYXIpIHtcbiAqICAgYWxlcnQoYmFyKTtcbiAqIH0pO1xuICpcbiAqIGV2ZW50cy5maXJlKHsgdHlwZTogJ2ZvbycgfSwgJ0kgYW0gYmFyIScpO1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gdGhlIG9wdGlvbmFsIGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnRdIHRoZSBldmVudCBvYmplY3RcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRoZSBldmVudHMgcmV0dXJuIHZhbHVlLCBpZiBzcGVjaWZpZWQgb3IgZmFsc2UgaWYgdGhlXG4gKiAgICAgICAgICAgICAgICAgICBkZWZhdWx0IGFjdGlvbiB3YXMgcHJldmVudGVkIGJ5IGxpc3RlbmVyc1xuICovXG5FdmVudEJ1cy5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgdmFyIGV2ZW50LFxuICAgICAgZmlyc3RMaXN0ZW5lcixcbiAgICAgIHJldHVyblZhbHVlLFxuICAgICAgYXJncztcblxuICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBkYXRhID0gdHlwZTtcbiAgICB0eXBlID0gZGF0YS50eXBlO1xuICB9XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdubyBldmVudCB0eXBlIHNwZWNpZmllZCcpO1xuICB9XG5cbiAgZmlyc3RMaXN0ZW5lciA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcblxuICBpZiAoIWZpcnN0TGlzdGVuZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB3ZSBtYWtlIHN1cmUgd2UgZmlyZSBpbnN0YW5jZXMgb2Ygb3VyIGhvbWUgbWFkZVxuICAvLyBldmVudHMgaGVyZS4gV2Ugd3JhcCB0aGVtIG9ubHkgb25jZSwgdGhvdWdoXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgSW50ZXJuYWxFdmVudCkge1xuXG4gICAgLy8gd2UgYXJlIGZpbmUsIHdlIGFscmVhZCBoYXZlIGFuIGV2ZW50XG4gICAgZXZlbnQgPSBkYXRhO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gdGhpcy5jcmVhdGVFdmVudChkYXRhKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSB3ZSBwYXNzIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyXG4gIGFyZ3NbMF0gPSBldmVudDtcblxuICAvLyBvcmlnaW5hbCBldmVudCB0eXBlIChpbiBjYXNlIHdlIGRlbGVnYXRlKVxuICB2YXIgb3JpZ2luYWxUeXBlID0gZXZlbnQudHlwZTtcblxuICAvLyB1cGRhdGUgZXZlbnQgdHlwZSBiZWZvcmUgZGVsZWdhdGlvblxuICBpZiAodHlwZSAhPT0gb3JpZ2luYWxUeXBlKSB7XG4gICAgZXZlbnQudHlwZSA9IHR5cGU7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVyblZhbHVlID0gdGhpcy5faW52b2tlTGlzdGVuZXJzKGV2ZW50LCBhcmdzLCBmaXJzdExpc3RlbmVyKTtcbiAgfSBmaW5hbGx5IHtcblxuICAgIC8vIHJlc2V0IGV2ZW50IHR5cGUgYWZ0ZXIgZGVsZWdhdGlvblxuICAgIGlmICh0eXBlICE9PSBvcmlnaW5hbFR5cGUpIHtcbiAgICAgIGV2ZW50LnR5cGUgPSBvcmlnaW5hbFR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHRoZSByZXR1cm4gdmFsdWUgdG8gZmFsc2UgaWYgdGhlIGV2ZW50IGRlZmF1bHRcbiAgLy8gZ290IHByZXZlbnRlZCBhbmQgbm8gb3RoZXIgcmV0dXJuIHZhbHVlIGV4aXN0c1xuICBpZiAocmV0dXJuVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG5cblxuRXZlbnRCdXMucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgcmV0dXJuIHRoaXMuZmlyZSgnZXJyb3InLCB7IGVycm9yOiBlcnJvciB9KSA9PT0gZmFsc2U7XG59O1xuXG5cbkV2ZW50QnVzLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbn07XG5cbkV2ZW50QnVzLnByb3RvdHlwZS5faW52b2tlTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQsIGFyZ3MsIGxpc3RlbmVyKSB7XG5cbiAgdmFyIHJldHVyblZhbHVlO1xuXG4gIHdoaWxlIChsaXN0ZW5lcikge1xuXG4gICAgLy8gaGFuZGxlIHN0b3BwZWQgcHJvcGFnYXRpb25cbiAgICBpZiAoZXZlbnQuY2FuY2VsQnViYmxlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm5WYWx1ZSA9IHRoaXMuX2ludm9rZUxpc3RlbmVyKGV2ZW50LCBhcmdzLCBsaXN0ZW5lcik7XG5cbiAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuXG5FdmVudEJ1cy5wcm90b3R5cGUuX2ludm9rZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGFyZ3MsIGxpc3RlbmVyKSB7XG5cbiAgdmFyIHJldHVyblZhbHVlO1xuXG4gIGlmIChsaXN0ZW5lci5jYWxsYmFjay5fX2lzVG9tYikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG4gIHRyeSB7XG5cbiAgICAvLyByZXR1cm5pbmcgZmFsc2UgcHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uXG4gICAgcmV0dXJuVmFsdWUgPSBpbnZva2VGdW5jdGlvbihsaXN0ZW5lci5jYWxsYmFjaywgYXJncyk7XG5cbiAgICAvLyBzdG9wIHByb3BhZ2F0aW9uIG9uIHJldHVybiB2YWx1ZVxuICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBkZWZhdWx0IG9uIHJldHVybiBmYWxzZVxuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCF0aGlzLmhhbmRsZUVycm9yKGUpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCd1bmhhbmRsZWQgZXJyb3IgaW4gZXZlbnQgbGlzdGVuZXInKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5zdGFjayk7XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcblxuLypcbiAqIEFkZCBuZXcgbGlzdGVuZXIgd2l0aCBhIGNlcnRhaW4gcHJpb3JpdHkgdG8gdGhlIGxpc3RcbiAqIG9mIGxpc3RlbmVycyAoZm9yIHRoZSBnaXZlbiBldmVudCkuXG4gKlxuICogVGhlIHNlbWFudGljcyBvZiBsaXN0ZW5lciByZWdpc3RyYXRpb24gLyBsaXN0ZW5lciBleGVjdXRpb24gYXJlXG4gKiBmaXJzdCByZWdpc3RlciwgZmlyc3Qgc2VydmU6IE5ldyBsaXN0ZW5lcnMgd2lsbCBhbHdheXMgYmUgaW5zZXJ0ZWRcbiAqIGFmdGVyIGV4aXN0aW5nIGxpc3RlbmVycyB3aXRoIHRoZSBzYW1lIHByaW9yaXR5LlxuICpcbiAqIEV4YW1wbGU6IEluc2VydGluZyB0d28gbGlzdGVuZXJzIHdpdGggcHJpb3JpdHkgMTAwMCBhbmQgMTMwMFxuICpcbiAqICAgICogYmVmb3JlOiBbIDE1MDAsIDE1MDAsIDEwMDAsIDEwMDAgXVxuICogICAgKiBhZnRlcjogWyAxNTAwLCAxNTAwLCAobmV3PTEzMDApLCAxMDAwLCAxMDAwLCAobmV3PTEwMDApIF1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0ZW5lciB7IHByaW9yaXR5LCBjYWxsYmFjayB9XG4gKi9cbkV2ZW50QnVzLnByb3RvdHlwZS5fYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgbmV3TGlzdGVuZXIpIHtcblxuICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9nZXRMaXN0ZW5lcnMoZXZlbnQpLFxuICAgICAgcHJldmlvdXNMaXN0ZW5lcjtcblxuICAvLyBubyBwcmlvciBsaXN0ZW5lcnNcbiAgaWYgKCFsaXN0ZW5lcikge1xuICAgIHRoaXMuX3NldExpc3RlbmVycyhldmVudCwgbmV3TGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZW5zdXJlIHdlIG9yZGVyIGxpc3RlbmVycyBieSBwcmlvcml0eSBmcm9tXG4gIC8vIDAgKGhpZ2gpIHRvIG4gPiAwIChsb3cpXG4gIHdoaWxlIChsaXN0ZW5lcikge1xuXG4gICAgaWYgKGxpc3RlbmVyLnByaW9yaXR5IDwgbmV3TGlzdGVuZXIucHJpb3JpdHkpIHtcblxuICAgICAgbmV3TGlzdGVuZXIubmV4dCA9IGxpc3RlbmVyO1xuXG4gICAgICBpZiAocHJldmlvdXNMaXN0ZW5lcikge1xuICAgICAgICBwcmV2aW91c0xpc3RlbmVyLm5leHQgPSBuZXdMaXN0ZW5lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldExpc3RlbmVycyhldmVudCwgbmV3TGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJldmlvdXNMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgfVxuXG4gIC8vIGFkZCBuZXcgbGlzdGVuZXIgdG8gYmFja1xuICBwcmV2aW91c0xpc3RlbmVyLm5leHQgPSBuZXdMaXN0ZW5lcjtcbn07XG5cblxuRXZlbnRCdXMucHJvdG90eXBlLl9nZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9saXN0ZW5lcnNbbmFtZV07XG59O1xuXG5FdmVudEJ1cy5wcm90b3R5cGUuX3NldExpc3RlbmVycyA9IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHRoaXMuX2xpc3RlbmVyc1tuYW1lXSA9IGxpc3RlbmVyO1xufTtcblxuRXZlbnRCdXMucHJvdG90eXBlLl9yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuXG4gIHZhciBsaXN0ZW5lciA9IHRoaXMuX2dldExpc3RlbmVycyhldmVudCksXG4gICAgICBuZXh0TGlzdGVuZXIsXG4gICAgICBwcmV2aW91c0xpc3RlbmVyLFxuICAgICAgbGlzdGVuZXJDYWxsYmFjaztcblxuICBpZiAoIWNhbGxiYWNrKSB7XG5cbiAgICAvLyBjbGVhciBsaXN0ZW5lcnNcbiAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoZXZlbnQsIG51bGwpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2hpbGUgKGxpc3RlbmVyKSB7XG5cbiAgICBuZXh0TGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuXG4gICAgbGlzdGVuZXJDYWxsYmFjayA9IGxpc3RlbmVyLmNhbGxiYWNrO1xuXG4gICAgaWYgKGxpc3RlbmVyQ2FsbGJhY2sgPT09IGNhbGxiYWNrIHx8IGxpc3RlbmVyQ2FsbGJhY2tbRk5fUkVGXSA9PT0gY2FsbGJhY2spIHtcbiAgICAgIGlmIChwcmV2aW91c0xpc3RlbmVyKSB7XG4gICAgICAgIHByZXZpb3VzTGlzdGVuZXIubmV4dCA9IG5leHRMaXN0ZW5lcjtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gbmV3IGZpcnN0IGxpc3RlbmVyXG4gICAgICAgIHRoaXMuX3NldExpc3RlbmVycyhldmVudCwgbmV4dExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2aW91c0xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgbGlzdGVuZXIgPSBuZXh0TGlzdGVuZXI7XG4gIH1cbn07XG5cbi8qKlxuICogQSBldmVudCB0aGF0IGlzIGVtaXR0ZWQgdmlhIHRoZSBldmVudCBidXMuXG4gKi9cbmZ1bmN0aW9uIEludGVybmFsRXZlbnQoKSB7IH1cblxuSW50ZXJuYWxFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn07XG5cbkludGVybmFsRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG59O1xuXG5JbnRlcm5hbEV2ZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZGF0YSkge1xuICBhc3NpZ24odGhpcywgZGF0YSB8fCB7fSk7XG59O1xuXG5cbi8qKlxuICogSW52b2tlIGZ1bmN0aW9uLiBCZSBmYXN0Li4uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gYXJnc1xuICpcbiAqIEByZXR1cm4ge0FueX1cbiAqL1xuZnVuY3Rpb24gaW52b2tlRnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuIiwiaW1wb3J0IHtcbiAgZm9yRWFjaCxcbiAgcmVkdWNlXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZ2V0Q2hpbGRyZW4sXG4gIGdldFZpc3VhbFxufSBmcm9tICcuLi91dGlsL0dyYXBoaWNzVXRpbCc7XG5cbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uL3V0aWwvU3ZnVHJhbnNmb3JtVXRpbCc7XG5cbmltcG9ydCB7IGNsZWFyIGFzIGRvbUNsZWFyIH0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY2xhc3NlcyBhcyBzdmdDbGFzc2VzLFxuICBjcmVhdGUgYXMgc3ZnQ3JlYXRlLFxuICByZW1vdmUgYXMgc3ZnUmVtb3ZlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IHtcbiAgaXNGcmFtZUVsZW1lbnRcbn0gZnJvbSAnLi4vdXRpbC9FbGVtZW50cyc7XG5cbi8qKlxuICogQSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBncmFwaGljYWwgZWxlbWVudHNcbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnl9IGVsZW1lbnRSZWdpc3RyeVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBHcmFwaGljc0ZhY3RvcnkoZXZlbnRCdXMsIGVsZW1lbnRSZWdpc3RyeSkge1xuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICB0aGlzLl9lbGVtZW50UmVnaXN0cnkgPSBlbGVtZW50UmVnaXN0cnk7XG59XG5cbkdyYXBoaWNzRmFjdG9yeS4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnICwgJ2VsZW1lbnRSZWdpc3RyeScgXTtcblxuXG5HcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLl9nZXRDaGlsZHJlbkNvbnRhaW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICB2YXIgZ2Z4ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldEdyYXBoaWNzKGVsZW1lbnQpO1xuXG4gIHZhciBjaGlsZHJlbkdmeDtcblxuICAvLyByb290IGVsZW1lbnRcbiAgaWYgKCFlbGVtZW50LnBhcmVudCkge1xuICAgIGNoaWxkcmVuR2Z4ID0gZ2Z4O1xuICB9IGVsc2Uge1xuICAgIGNoaWxkcmVuR2Z4ID0gZ2V0Q2hpbGRyZW4oZ2Z4KTtcbiAgICBpZiAoIWNoaWxkcmVuR2Z4KSB7XG4gICAgICBjaGlsZHJlbkdmeCA9IHN2Z0NyZWF0ZSgnZycpO1xuICAgICAgc3ZnQ2xhc3NlcyhjaGlsZHJlbkdmeCkuYWRkKCdkanMtY2hpbGRyZW4nKTtcblxuICAgICAgc3ZnQXBwZW5kKGdmeC5wYXJlbnROb2RlLCBjaGlsZHJlbkdmeCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuR2Z4O1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZWxlbWVudCBhbmQgcmV0dXJucyB0aGVcbiAqIGNsZWFyZWQgdmlzdWFsICh0aGUgPGcgY2xhc3M9XCJkanMtdmlzdWFsXCIgLz4gZWxlbWVudCkuXG4gKi9cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuX2NsZWFyID0gZnVuY3Rpb24oZ2Z4KSB7XG4gIHZhciB2aXN1YWwgPSBnZXRWaXN1YWwoZ2Z4KTtcblxuICBkb21DbGVhcih2aXN1YWwpO1xuXG4gIHJldHVybiB2aXN1YWw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBnZnggY29udGFpbmVyIGZvciBzaGFwZXMgYW5kIGNvbm5lY3Rpb25zXG4gKlxuICogVGhlIGxheW91dCBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIDxnIGNsYXNzPVwiZGpzLWdyb3VwXCI+XG4gKlxuICogICA8IS0tIHRoZSBnZnggLS0+XG4gKiAgIDxnIGNsYXNzPVwiZGpzLWVsZW1lbnQgZGpzLShzaGFwZXxjb25uZWN0aW9ufGZyYW1lKVwiPlxuICogICAgIDxnIGNsYXNzPVwiZGpzLXZpc3VhbFwiPlxuICogICAgICAgPCEtLSB0aGUgcmVuZGVyZXIgZHJhd3MgaW4gaGVyZSAtLT5cbiAqICAgICA8L2c+XG4gKlxuICogICAgIDwhLS0gZXh0ZW5zaW9ucyAob3ZlcmxheXMsIGNsaWNrIGJveCwgLi4uKSBnb2VzIGhlcmVcbiAqICAgPC9nPlxuICpcbiAqICAgPCEtLSB0aGUgZ2Z4IGNoaWxkIG5vZGVzIC0tPlxuICogICA8ZyBjbGFzcz1cImRqcy1jaGlsZHJlblwiPjwvZz5cbiAqIDwvZz5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudCwgaS5lLiBzaGFwZSB8IGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gW2NoaWxkcmVuR2Z4XVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJlbnRJbmRleF0gcG9zaXRpb24gdG8gY3JlYXRlIGNvbnRhaW5lciBpbiBwYXJlbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRnJhbWVdIGlzIGZyYW1lIGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICovXG5HcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLl9jcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbihcbiAgICB0eXBlLCBjaGlsZHJlbkdmeCwgcGFyZW50SW5kZXgsIGlzRnJhbWVcbikge1xuICB2YXIgb3V0ZXJHZnggPSBzdmdDcmVhdGUoJ2cnKTtcbiAgc3ZnQ2xhc3NlcyhvdXRlckdmeCkuYWRkKCdkanMtZ3JvdXAnKTtcblxuICAvLyBpbnNlcnQgbm9kZSBhdCBwb3NpdGlvblxuICBpZiAodHlwZW9mIHBhcmVudEluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHByZXBlbmRUbyhvdXRlckdmeCwgY2hpbGRyZW5HZngsIGNoaWxkcmVuR2Z4LmNoaWxkTm9kZXNbcGFyZW50SW5kZXhdKTtcbiAgfSBlbHNlIHtcbiAgICBzdmdBcHBlbmQoY2hpbGRyZW5HZngsIG91dGVyR2Z4KTtcbiAgfVxuXG4gIHZhciBnZnggPSBzdmdDcmVhdGUoJ2cnKTtcbiAgc3ZnQ2xhc3NlcyhnZngpLmFkZCgnZGpzLWVsZW1lbnQnKTtcbiAgc3ZnQ2xhc3NlcyhnZngpLmFkZCgnZGpzLScgKyB0eXBlKTtcblxuICBpZiAoaXNGcmFtZSkge1xuICAgIHN2Z0NsYXNzZXMoZ2Z4KS5hZGQoJ2Rqcy1mcmFtZScpO1xuICB9XG5cbiAgc3ZnQXBwZW5kKG91dGVyR2Z4LCBnZngpO1xuXG4gIC8vIGNyZWF0ZSB2aXN1YWxcbiAgdmFyIHZpc3VhbCA9IHN2Z0NyZWF0ZSgnZycpO1xuICBzdmdDbGFzc2VzKHZpc3VhbCkuYWRkKCdkanMtdmlzdWFsJyk7XG5cbiAgc3ZnQXBwZW5kKGdmeCwgdmlzdWFsKTtcblxuICByZXR1cm4gZ2Z4O1xufTtcblxuR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBwYXJlbnRJbmRleCkge1xuICB2YXIgY2hpbGRyZW5HZnggPSB0aGlzLl9nZXRDaGlsZHJlbkNvbnRhaW5lcihlbGVtZW50LnBhcmVudCk7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVDb250YWluZXIodHlwZSwgY2hpbGRyZW5HZngsIHBhcmVudEluZGV4LCBpc0ZyYW1lRWxlbWVudChlbGVtZW50KSk7XG59O1xuXG5HcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5tZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgZWxlbWVudFJlZ2lzdHJ5ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LFxuICAgICAgcGFyZW50cztcblxuICBwYXJlbnRzID0gcmVkdWNlKGVsZW1lbnRzLCBmdW5jdGlvbihtYXAsIGUpIHtcblxuICAgIGlmIChlLnBhcmVudCkge1xuICAgICAgbWFwW2UucGFyZW50LmlkXSA9IGUucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH0sIHt9KTtcblxuICAvLyB1cGRhdGUgYWxsIHBhcmVudHMgb2YgY2hhbmdlZCBhbmQgcmVvcmdhbml6ZWQgdGhlaXIgY2hpbGRyZW5cbiAgLy8gaW4gdGhlIGNvcnJlY3Qgb3JkZXIgKGFzIGluZGljYXRlZCBpbiBvdXIgbW9kZWwpXG4gIGZvckVhY2gocGFyZW50cywgZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG5cbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuR2Z4ID0gc2VsZi5fZ2V0Q2hpbGRyZW5Db250YWluZXIocGFyZW50KTtcblxuICAgIGZvckVhY2goY2hpbGRyZW4uc2xpY2UoKS5yZXZlcnNlKCksIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGRHZnggPSBlbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoY2hpbGQpO1xuXG4gICAgICBwcmVwZW5kVG8oY2hpbGRHZngucGFyZW50Tm9kZSwgY2hpbGRyZW5HZngpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuZHJhd1NoYXBlID0gZnVuY3Rpb24odmlzdWFsLCBlbGVtZW50KSB7XG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIHJldHVybiBldmVudEJ1cy5maXJlKCdyZW5kZXIuc2hhcGUnLCB7IGdmeDogdmlzdWFsLCBlbGVtZW50OiBlbGVtZW50IH0pO1xufTtcblxuR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS5nZXRTaGFwZVBhdGggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIHJldHVybiBldmVudEJ1cy5maXJlKCdyZW5kZXIuZ2V0U2hhcGVQYXRoJywgZWxlbWVudCk7XG59O1xuXG5HcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLmRyYXdDb25uZWN0aW9uID0gZnVuY3Rpb24odmlzdWFsLCBlbGVtZW50KSB7XG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIHJldHVybiBldmVudEJ1cy5maXJlKCdyZW5kZXIuY29ubmVjdGlvbicsIHsgZ2Z4OiB2aXN1YWwsIGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG59O1xuXG5HcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLmdldENvbm5lY3Rpb25QYXRoID0gZnVuY3Rpb24od2F5cG9pbnRzKSB7XG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIHJldHVybiBldmVudEJ1cy5maXJlKCdyZW5kZXIuZ2V0Q29ubmVjdGlvblBhdGgnLCB3YXlwb2ludHMpO1xufTtcblxuR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBnZngpIHtcblxuICAvLyBkbyBOT1QgdXBkYXRlIHJvb3QgZWxlbWVudFxuICBpZiAoIWVsZW1lbnQucGFyZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZpc3VhbCA9IHRoaXMuX2NsZWFyKGdmeCk7XG5cbiAgLy8gcmVkcmF3XG4gIGlmICh0eXBlID09PSAnc2hhcGUnKSB7XG4gICAgdGhpcy5kcmF3U2hhcGUodmlzdWFsLCBlbGVtZW50KTtcblxuICAgIC8vIHVwZGF0ZSBwb3NpdGlvbmluZ1xuICAgIHRyYW5zbGF0ZShnZngsIGVsZW1lbnQueCwgZWxlbWVudC55KTtcbiAgfSBlbHNlXG4gIGlmICh0eXBlID09PSAnY29ubmVjdGlvbicpIHtcbiAgICB0aGlzLmRyYXdDb25uZWN0aW9uKHZpc3VhbCwgZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHR5cGU6ICcgKyB0eXBlKTtcbiAgfVxuXG4gIGlmIChlbGVtZW50LmhpZGRlbikge1xuICAgIHN2Z0F0dHIoZ2Z4LCAnZGlzcGxheScsICdub25lJyk7XG4gIH0gZWxzZSB7XG4gICAgc3ZnQXR0cihnZngsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gIH1cbn07XG5cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgZ2Z4ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldEdyYXBoaWNzKGVsZW1lbnQpO1xuXG4gIC8vIHJlbW92ZVxuICBzdmdSZW1vdmUoZ2Z4LnBhcmVudE5vZGUpO1xufTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cblxuZnVuY3Rpb24gcHJlcGVuZFRvKG5ld05vZGUsIHBhcmVudE5vZGUsIHNpYmxpbmdOb2RlKSB7XG4gIHZhciBub2RlID0gc2libGluZ05vZGUgfHwgcGFyZW50Tm9kZS5maXJzdENoaWxkO1xuXG4gIC8vIGRvIG5vdCBwcmVwZW5kIG5vZGUgdG8gaXRzZWxmIHRvIHByZXZlbnQgSUUgZnJvbSBjcmFzaGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnBtbi1pby9icG1uLWpzL2lzc3Vlcy83NDZcbiAgaWYgKG5ld05vZGUgPT09IG5vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCBub2RlKTtcbn1cbiIsImltcG9ydCBEcmF3TW9kdWxlIGZyb20gJy4uL2RyYXcnO1xuXG5pbXBvcnQgQ2FudmFzIGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCBFbGVtZW50UmVnaXN0cnkgZnJvbSAnLi9FbGVtZW50UmVnaXN0cnknO1xuaW1wb3J0IEVsZW1lbnRGYWN0b3J5IGZyb20gJy4vRWxlbWVudEZhY3RvcnknO1xuaW1wb3J0IEV2ZW50QnVzIGZyb20gJy4vRXZlbnRCdXMnO1xuaW1wb3J0IEdyYXBoaWNzRmFjdG9yeSBmcm9tICcuL0dyYXBoaWNzRmFjdG9yeSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFsgRHJhd01vZHVsZSBdLFxuICBfX2luaXRfXzogWyAnY2FudmFzJyBdLFxuICBjYW52YXM6IFsgJ3R5cGUnLCBDYW52YXMgXSxcbiAgZWxlbWVudFJlZ2lzdHJ5OiBbICd0eXBlJywgRWxlbWVudFJlZ2lzdHJ5IF0sXG4gIGVsZW1lbnRGYWN0b3J5OiBbICd0eXBlJywgRWxlbWVudEZhY3RvcnkgXSxcbiAgZXZlbnRCdXM6IFsgJ3R5cGUnLCBFdmVudEJ1cyBdLFxuICBncmFwaGljc0ZhY3Rvcnk6IFsgJ3R5cGUnLCBHcmFwaGljc0ZhY3RvcnkgXVxufTsiLCJ2YXIgREVGQVVMVF9SRU5ERVJfUFJJT1JJVFkgPSAxMDAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIHNoYXBlIGFuZCBjb25uZWN0aW9uIHJlbmRlcmVycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtudW1iZXJ9IFtyZW5kZXJQcmlvcml0eT0xMDAwXVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCYXNlUmVuZGVyZXIoZXZlbnRCdXMsIHJlbmRlclByaW9yaXR5KSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICByZW5kZXJQcmlvcml0eSA9IHJlbmRlclByaW9yaXR5IHx8IERFRkFVTFRfUkVOREVSX1BSSU9SSVRZO1xuXG4gIGV2ZW50QnVzLm9uKFsgJ3JlbmRlci5zaGFwZScsICdyZW5kZXIuY29ubmVjdGlvbicgXSwgcmVuZGVyUHJpb3JpdHksIGZ1bmN0aW9uKGV2dCwgY29udGV4dCkge1xuICAgIHZhciB0eXBlID0gZXZ0LnR5cGUsXG4gICAgICAgIGVsZW1lbnQgPSBjb250ZXh0LmVsZW1lbnQsXG4gICAgICAgIHZpc3VhbHMgPSBjb250ZXh0LmdmeDtcblxuICAgIGlmIChzZWxmLmNhblJlbmRlcihlbGVtZW50KSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdyZW5kZXIuc2hhcGUnKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmRyYXdTaGFwZSh2aXN1YWxzLCBlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLmRyYXdDb25uZWN0aW9uKHZpc3VhbHMsIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oWyAncmVuZGVyLmdldFNoYXBlUGF0aCcsICdyZW5kZXIuZ2V0Q29ubmVjdGlvblBhdGgnXSwgcmVuZGVyUHJpb3JpdHksIGZ1bmN0aW9uKGV2dCwgZWxlbWVudCkge1xuICAgIGlmIChzZWxmLmNhblJlbmRlcihlbGVtZW50KSkge1xuICAgICAgaWYgKGV2dC50eXBlID09PSAncmVuZGVyLmdldFNoYXBlUGF0aCcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2hhcGVQYXRoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Q29ubmVjdGlvblBhdGgoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTaG91bGQgY2hlY2sgd2hldGhlciAqdGhpcyogcmVuZGVyZXIgY2FuIHJlbmRlclxuICogdGhlIGVsZW1lbnQvY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jYW5SZW5kZXIgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSBzaGFwZSdzIHNuYXAgc3ZnIGVsZW1lbnQgdG8gYmUgZHJhd24gb24gdGhlIGBjYW52YXNgLlxuICpcbiAqIEBwYXJhbSB7ZGpzLkdyYXBoaWNzfSB2aXN1YWxzXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxuICpcbiAqIEByZXR1cm5zIHtTbmFwLnN2Z30gW3JldHVybnMgYSBTbmFwLnN2ZyBwYXBlciBlbGVtZW50IF1cbiAqL1xuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3U2hhcGUgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSBzaGFwZSdzIHNuYXAgc3ZnIGVsZW1lbnQgdG8gYmUgZHJhd24gb24gdGhlIGBjYW52YXNgLlxuICpcbiAqIEBwYXJhbSB7ZGpzLkdyYXBoaWNzfSB2aXN1YWxzXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqXG4gKiBAcmV0dXJucyB7U25hcC5zdmd9IFtyZXR1cm5zIGEgU25hcC5zdmcgcGFwZXIgZWxlbWVudCBdXG4gKi9cbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuZHJhd0Nvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIEdldHMgdGhlIFNWRyBwYXRoIG9mIGEgc2hhcGUgdGhhdCByZXByZXNlbnRzIGl0J3MgdmlzdWFsIGJvdW5kcy5cbiAqXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gc3ZnIHBhdGhcbiAqL1xuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaGFwZVBhdGggPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIEdldHMgdGhlIFNWRyBwYXRoIG9mIGEgY29ubmVjdGlvbiB0aGF0IHJlcHJlc2VudHMgaXQncyB2aXN1YWwgYm91bmRzLlxuICpcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gc3ZnIHBhdGhcbiAqL1xuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUGF0aCA9IGZ1bmN0aW9uKCkge307XG4iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgQmFzZVJlbmRlcmVyIGZyb20gJy4vQmFzZVJlbmRlcmVyJztcblxuaW1wb3J0IHtcbiAgY29tcG9uZW50c1RvUGF0aCxcbiAgY3JlYXRlTGluZVxufSBmcm9tICcuLi91dGlsL1JlbmRlclV0aWwnO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQge1xuICBpc0ZyYW1lRWxlbWVudFxufSBmcm9tICcuLi91dGlsL0VsZW1lbnRzJztcblxuLy8gYXBwbHkgZGVmYXVsdCByZW5kZXJlciB3aXRoIGxvd2VzdCBwb3NzaWJsZSBwcmlvcml0eVxuLy8gc28gdGhhdCBpdCBvbmx5IGtpY2tzIGluIGlmIG5vb25lIGVsc2UgY291bGQgcmVuZGVyXG52YXIgREVGQVVMVF9SRU5ERVJfUFJJT1JJVFkgPSAxO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHJlbmRlcmVyIHVzZWQgZm9yIHNoYXBlcyBhbmQgY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7U3R5bGVzfSBzdHlsZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGVmYXVsdFJlbmRlcmVyKGV2ZW50QnVzLCBzdHlsZXMpIHtcblxuICAvL1xuICBCYXNlUmVuZGVyZXIuY2FsbCh0aGlzLCBldmVudEJ1cywgREVGQVVMVF9SRU5ERVJfUFJJT1JJVFkpO1xuXG4gIHRoaXMuQ09OTkVDVElPTl9TVFlMRSA9IHN0eWxlcy5zdHlsZShbICduby1maWxsJyBdLCB7IHN0cm9rZVdpZHRoOiA1LCBzdHJva2U6ICdmdWNoc2lhJyB9KTtcbiAgdGhpcy5TSEFQRV9TVFlMRSA9IHN0eWxlcy5zdHlsZSh7IGZpbGw6ICd3aGl0ZScsIHN0cm9rZTogJ2Z1Y2hzaWEnLCBzdHJva2VXaWR0aDogMiB9KTtcbiAgdGhpcy5GUkFNRV9TVFlMRSA9IHN0eWxlcy5zdHlsZShbICduby1maWxsJyBdLCB7IHN0cm9rZTogJ2Z1Y2hzaWEnLCBzdHJva2VEYXNoYXJyYXk6IDQsIHN0cm9rZVdpZHRoOiAyIH0pO1xufVxuXG5pbmhlcml0cyhEZWZhdWx0UmVuZGVyZXIsIEJhc2VSZW5kZXJlcik7XG5cblxuRGVmYXVsdFJlbmRlcmVyLnByb3RvdHlwZS5jYW5SZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5EZWZhdWx0UmVuZGVyZXIucHJvdG90eXBlLmRyYXdTaGFwZSA9IGZ1bmN0aW9uIGRyYXdTaGFwZSh2aXN1YWxzLCBlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gc3ZnQ3JlYXRlKCdyZWN0Jyk7XG5cbiAgc3ZnQXR0cihyZWN0LCB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiBlbGVtZW50LndpZHRoIHx8IDAsXG4gICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodCB8fCAwXG4gIH0pO1xuXG4gIGlmIChpc0ZyYW1lRWxlbWVudChlbGVtZW50KSkge1xuICAgIHN2Z0F0dHIocmVjdCwgdGhpcy5GUkFNRV9TVFlMRSk7XG4gIH0gZWxzZSB7XG4gICAgc3ZnQXR0cihyZWN0LCB0aGlzLlNIQVBFX1NUWUxFKTtcbiAgfVxuXG4gIHN2Z0FwcGVuZCh2aXN1YWxzLCByZWN0KTtcblxuICByZXR1cm4gcmVjdDtcbn07XG5cbkRlZmF1bHRSZW5kZXJlci5wcm90b3R5cGUuZHJhd0Nvbm5lY3Rpb24gPSBmdW5jdGlvbiBkcmF3Q29ubmVjdGlvbih2aXN1YWxzLCBjb25uZWN0aW9uKSB7XG5cbiAgdmFyIGxpbmUgPSBjcmVhdGVMaW5lKGNvbm5lY3Rpb24ud2F5cG9pbnRzLCB0aGlzLkNPTk5FQ1RJT05fU1RZTEUpO1xuICBzdmdBcHBlbmQodmlzdWFscywgbGluZSk7XG5cbiAgcmV0dXJuIGxpbmU7XG59O1xuXG5EZWZhdWx0UmVuZGVyZXIucHJvdG90eXBlLmdldFNoYXBlUGF0aCA9IGZ1bmN0aW9uIGdldFNoYXBlUGF0aChzaGFwZSkge1xuXG4gIHZhciB4ID0gc2hhcGUueCxcbiAgICAgIHkgPSBzaGFwZS55LFxuICAgICAgd2lkdGggPSBzaGFwZS53aWR0aCxcbiAgICAgIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcblxuICB2YXIgc2hhcGVQYXRoID0gW1xuICAgIFsnTScsIHgsIHldLFxuICAgIFsnbCcsIHdpZHRoLCAwXSxcbiAgICBbJ2wnLCAwLCBoZWlnaHRdLFxuICAgIFsnbCcsIC13aWR0aCwgMF0sXG4gICAgWyd6J11cbiAgXTtcblxuICByZXR1cm4gY29tcG9uZW50c1RvUGF0aChzaGFwZVBhdGgpO1xufTtcblxuRGVmYXVsdFJlbmRlcmVyLnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUGF0aCA9IGZ1bmN0aW9uIGdldENvbm5lY3Rpb25QYXRoKGNvbm5lY3Rpb24pIHtcbiAgdmFyIHdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzO1xuXG4gIHZhciBpZHgsIHBvaW50LCBjb25uZWN0aW9uUGF0aCA9IFtdO1xuXG4gIGZvciAoaWR4ID0gMDsgKHBvaW50ID0gd2F5cG9pbnRzW2lkeF0pOyBpZHgrKykge1xuXG4gICAgLy8gdGFrZSBpbnZpc2libGUgZG9ja2luZyBpbnRvIGFjY291bnRcbiAgICAvLyB3aGVuIGNyZWF0aW5nIHRoZSBwYXRoXG4gICAgcG9pbnQgPSBwb2ludC5vcmlnaW5hbCB8fCBwb2ludDtcblxuICAgIGNvbm5lY3Rpb25QYXRoLnB1c2goWyBpZHggPT09IDAgPyAnTScgOiAnTCcsIHBvaW50LngsIHBvaW50LnkgXSk7XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50c1RvUGF0aChjb25uZWN0aW9uUGF0aCk7XG59O1xuXG5cbkRlZmF1bHRSZW5kZXJlci4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnLCAnc3R5bGVzJyBdO1xuIiwiaW1wb3J0IHtcbiAgaXNBcnJheSxcbiAgYXNzaWduLFxuICByZWR1Y2Vcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbi8qKlxuICogQSBjb21wb25lbnQgdGhhdCBtYW5hZ2VzIHNoYXBlIHN0eWxlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTdHlsZXMoKSB7XG5cbiAgdmFyIGRlZmF1bHRUcmFpdHMgPSB7XG5cbiAgICAnbm8tZmlsbCc6IHtcbiAgICAgIGZpbGw6ICdub25lJ1xuICAgIH0sXG4gICAgJ25vLWJvcmRlcic6IHtcbiAgICAgIHN0cm9rZU9wYWNpdHk6IDAuMFxuICAgIH0sXG4gICAgJ25vLWV2ZW50cyc6IHtcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIHN0eWxlIGRlZmluaXRpb24gZnJvbSBhIGNsYXNzTmFtZSwgYSBsaXN0IG9mIHRyYWl0cyBhbmQgYW4gb2JqZWN0IG9mIGFkZGl0aW9uYWwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPn0gdHJhaXRzXG4gICAqIEBwYXJhbSAge09iamVjdH0gYWRkaXRpb25hbEF0dHJzXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHN0eWxlIGRlZmludGlvblxuICAgKi9cbiAgdGhpcy5jbHMgPSBmdW5jdGlvbihjbGFzc05hbWUsIHRyYWl0cywgYWRkaXRpb25hbEF0dHJzKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5zdHlsZSh0cmFpdHMsIGFkZGl0aW9uYWxBdHRycyk7XG5cbiAgICByZXR1cm4gYXNzaWduKGF0dHJzLCB7ICdjbGFzcyc6IGNsYXNzTmFtZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIGEgc3R5bGUgZGVmaW5pdGlvbiBmcm9tIGEgbGlzdCBvZiB0cmFpdHMgYW5kIGFuIG9iamVjdCBvZiBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5PHN0cmluZz59IHRyYWl0c1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IGFkZGl0aW9uYWxBdHRyc1xuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBzdHlsZSBkZWZpbnRpb25cbiAgICovXG4gIHRoaXMuc3R5bGUgPSBmdW5jdGlvbih0cmFpdHMsIGFkZGl0aW9uYWxBdHRycykge1xuXG4gICAgaWYgKCFpc0FycmF5KHRyYWl0cykgJiYgIWFkZGl0aW9uYWxBdHRycykge1xuICAgICAgYWRkaXRpb25hbEF0dHJzID0gdHJhaXRzO1xuICAgICAgdHJhaXRzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGF0dHJzID0gcmVkdWNlKHRyYWl0cywgZnVuY3Rpb24oYXR0cnMsIHQpIHtcbiAgICAgIHJldHVybiBhc3NpZ24oYXR0cnMsIGRlZmF1bHRUcmFpdHNbdF0gfHwge30pO1xuICAgIH0sIHt9KTtcblxuICAgIHJldHVybiBhZGRpdGlvbmFsQXR0cnMgPyBhc3NpZ24oYXR0cnMsIGFkZGl0aW9uYWxBdHRycykgOiBhdHRycztcbiAgfTtcblxuICB0aGlzLmNvbXB1dGVTdHlsZSA9IGZ1bmN0aW9uKGN1c3RvbSwgdHJhaXRzLCBkZWZhdWx0U3R5bGVzKSB7XG4gICAgaWYgKCFpc0FycmF5KHRyYWl0cykpIHtcbiAgICAgIGRlZmF1bHRTdHlsZXMgPSB0cmFpdHM7XG4gICAgICB0cmFpdHMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5zdHlsZSh0cmFpdHMgfHwgW10sIGFzc2lnbih7fSwgZGVmYXVsdFN0eWxlcywgY3VzdG9tIHx8IHt9KSk7XG4gIH07XG59XG4iLCJpbXBvcnQgRGVmYXVsdFJlbmRlcmVyIGZyb20gJy4vRGVmYXVsdFJlbmRlcmVyJztcbmltcG9ydCBTdHlsZXMgZnJvbSAnLi9TdHlsZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdkZWZhdWx0UmVuZGVyZXInIF0sXG4gIGRlZmF1bHRSZW5kZXJlcjogWyAndHlwZScsIERlZmF1bHRSZW5kZXJlciBdLFxuICBzdHlsZXM6IFsgJ3R5cGUnLCBTdHlsZXMgXVxufTtcbiIsImltcG9ydCB7XG4gIGZpbHRlcixcbiAgZm9yRWFjaCxcbiAgc29ydEJ5XG59IGZyb20gJ21pbi1kYXNoJztcblxuZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgcmV0dXJuIGFyciAmJiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufVxuXG5mdW5jdGlvbiBzb3J0VG9wT3JNaWRkbGUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC55O1xufVxuXG5mdW5jdGlvbiBzb3J0TGVmdE9yQ2VudGVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQueDtcbn1cblxuLyoqXG4gKiBTb3J0aW5nIGZ1bmN0aW9ucyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIGFsaWdubWVudFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnZhciBBTElHTk1FTlRfU09SVElORyA9IHtcbiAgbGVmdDogc29ydExlZnRPckNlbnRlcixcbiAgY2VudGVyOiBzb3J0TGVmdE9yQ2VudGVyLFxuICByaWdodDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LnggKyBlbGVtZW50LndpZHRoO1xuICB9LFxuICB0b3A6IHNvcnRUb3BPck1pZGRsZSxcbiAgbWlkZGxlOiBzb3J0VG9wT3JNaWRkbGUsXG4gIGJvdHRvbTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LnkgKyBlbGVtZW50LmhlaWdodDtcbiAgfVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBbGlnbkVsZW1lbnRzKG1vZGVsaW5nKSB7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG59XG5cbkFsaWduRWxlbWVudHMuJGluamVjdCA9IFsgJ21vZGVsaW5nJyBdO1xuXG5cbi8qKlxuICogR2V0IHRoZSByZWxldmFudCBcImF4aXNcIiBhbmQgXCJkaW1lbnNpb25cIiByZWxhdGVkIHRvIHRoZSBjdXJyZW50IHR5cGUgb2YgYWxpZ25tZW50XG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlIGxlZnR8cmlnaHR8Y2VudGVyfHRvcHxib3R0b218bWlkZGxlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB7IGF4aXMsIGRpbWVuc2lvbiB9XG4gKi9cbkFsaWduRWxlbWVudHMucHJvdG90eXBlLl9nZXRPcmllbnRhdGlvbkRldGFpbHMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciB2ZXJ0aWNhbCA9IFsgJ3RvcCcsICdib3R0b20nLCAnbWlkZGxlJyBdLFxuICAgICAgYXhpcyA9ICd4JyxcbiAgICAgIGRpbWVuc2lvbiA9ICd3aWR0aCc7XG5cbiAgaWYgKHZlcnRpY2FsLmluZGV4T2YodHlwZSkgIT09IC0xKSB7XG4gICAgYXhpcyA9ICd5JztcbiAgICBkaW1lbnNpb24gPSAnaGVpZ2h0JztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXhpczogYXhpcyxcbiAgICBkaW1lbnNpb246IGRpbWVuc2lvblxuICB9O1xufTtcblxuQWxpZ25FbGVtZW50cy5wcm90b3R5cGUuX2lzVHlwZSA9IGZ1bmN0aW9uKHR5cGUsIHR5cGVzKSB7XG4gIHJldHVybiB0eXBlcy5pbmRleE9mKHR5cGUpICE9PSAtMTtcbn07XG5cbi8qKlxuICogR2V0IGEgcG9pbnQgb24gdGhlIHJlbGV2YW50IGF4aXMgd2hlcmUgZWxlbWVudHMgc2hvdWxkIGFsaWduIHRvXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlIGxlZnR8cmlnaHR8Y2VudGVyfHRvcHxib3R0b218bWlkZGxlXG4gKiBAcGFyYW0gIHtBcnJheX0gc29ydGVkRWxlbWVudHNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkFsaWduRWxlbWVudHMucHJvdG90eXBlLl9hbGlnbm1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKHR5cGUsIHNvcnRlZEVsZW1lbnRzKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMuX2dldE9yaWVudGF0aW9uRGV0YWlscyh0eXBlKSxcbiAgICAgIGF4aXMgPSBvcmllbnRhdGlvbi5heGlzLFxuICAgICAgZGltZW5zaW9uID0gb3JpZW50YXRpb24uZGltZW5zaW9uLFxuICAgICAgYWxpZ25tZW50ID0ge30sXG4gICAgICBjZW50ZXJzID0ge30sXG4gICAgICBoYXNTaGFyZWRDZW50ZXJzID0gZmFsc2UsXG4gICAgICBjZW50ZXJlZEVsZW1lbnRzLFxuICAgICAgZmlyc3RFbGVtZW50LFxuICAgICAgbGFzdEVsZW1lbnQ7XG5cbiAgZnVuY3Rpb24gZ2V0TWlkZGxlT3JUb3AoZmlyc3QsIGxhc3QpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoZmlyc3RbYXhpc10gKyBsYXN0W2F4aXNdICsgbGFzdFtkaW1lbnNpb25dKSAvIDIpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2lzVHlwZSh0eXBlLCBbICdsZWZ0JywgJ3RvcCcgXSkpIHtcbiAgICBhbGlnbm1lbnRbdHlwZV0gPSBzb3J0ZWRFbGVtZW50c1swXVtheGlzXTtcblxuICB9IGVsc2UgaWYgKHRoaXMuX2lzVHlwZSh0eXBlLCBbICdyaWdodCcsICdib3R0b20nIF0pKSB7XG4gICAgbGFzdEVsZW1lbnQgPSBsYXN0KHNvcnRlZEVsZW1lbnRzKTtcblxuICAgIGFsaWdubWVudFt0eXBlXSA9IGxhc3RFbGVtZW50W2F4aXNdICsgbGFzdEVsZW1lbnRbZGltZW5zaW9uXTtcblxuICB9IGVsc2UgaWYgKHRoaXMuX2lzVHlwZSh0eXBlLCBbICdjZW50ZXInLCAnbWlkZGxlJyBdKSkge1xuXG4gICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYSBjZW50ZXIgc2hhcmVkIGJ5IG1vcmUgdGhhbiBvbmUgc2hhcGVcbiAgICAvLyBpZiBub3QsIGp1c3QgdGFrZSB0aGUgbWlkZGxlIG9mIHRoZSByYW5nZVxuICAgIGZvckVhY2goc29ydGVkRWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBjZW50ZXIgPSBlbGVtZW50W2F4aXNdICsgTWF0aC5yb3VuZChlbGVtZW50W2RpbWVuc2lvbl0gLyAyKTtcblxuICAgICAgaWYgKGNlbnRlcnNbY2VudGVyXSkge1xuICAgICAgICBjZW50ZXJzW2NlbnRlcl0uZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbnRlcnNbY2VudGVyXSA9IHtcbiAgICAgICAgICBlbGVtZW50czogWyBlbGVtZW50IF0sXG4gICAgICAgICAgY2VudGVyOiBjZW50ZXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNlbnRlcmVkRWxlbWVudHMgPSBzb3J0QnkoY2VudGVycywgZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgICBpZiAoY2VudGVyLmVsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaGFzU2hhcmVkQ2VudGVycyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjZW50ZXIuZWxlbWVudHMubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgaWYgKGhhc1NoYXJlZENlbnRlcnMpIHtcbiAgICAgIGFsaWdubWVudFt0eXBlXSA9IGxhc3QoY2VudGVyZWRFbGVtZW50cykuY2VudGVyO1xuXG4gICAgICByZXR1cm4gYWxpZ25tZW50O1xuICAgIH1cblxuICAgIGZpcnN0RWxlbWVudCA9IHNvcnRlZEVsZW1lbnRzWzBdO1xuXG4gICAgc29ydGVkRWxlbWVudHMgPSBzb3J0Qnkoc29ydGVkRWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50W2F4aXNdICsgZWxlbWVudFtkaW1lbnNpb25dO1xuICAgIH0pO1xuXG4gICAgbGFzdEVsZW1lbnQgPSBsYXN0KHNvcnRlZEVsZW1lbnRzKTtcblxuICAgIGFsaWdubWVudFt0eXBlXSA9IGdldE1pZGRsZU9yVG9wKGZpcnN0RWxlbWVudCwgbGFzdEVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGFsaWdubWVudDtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIGFsaWdubWVudCBvZiBhIHNlbGVjdGlvbiBvZiBlbGVtZW50c1xuICpcbiAqIEBwYXJhbSAge0FycmF5fSBlbGVtZW50cyBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgbGVmdHxyaWdodHxjZW50ZXJ8dG9wfGJvdHRvbXxtaWRkbGVcbiAqL1xuQWxpZ25FbGVtZW50cy5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGVsZW1lbnRzLCB0eXBlKSB7XG4gIHZhciBtb2RlbGluZyA9IHRoaXMuX21vZGVsaW5nO1xuXG4gIHZhciBmaWx0ZXJlZEVsZW1lbnRzID0gZmlsdGVyKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudC53YXlwb2ludHMgfHwgZWxlbWVudC5ob3N0IHx8IGVsZW1lbnQubGFiZWxUYXJnZXQpO1xuICB9KTtcblxuICBpZiAoZmlsdGVyZWRFbGVtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNvcnRGbiA9IEFMSUdOTUVOVF9TT1JUSU5HW3R5cGVdO1xuXG4gIHZhciBzb3J0ZWRFbGVtZW50cyA9IHNvcnRCeShmaWx0ZXJlZEVsZW1lbnRzLCBzb3J0Rm4pO1xuXG4gIHZhciBhbGlnbm1lbnQgPSB0aGlzLl9hbGlnbm1lbnRQb3NpdGlvbih0eXBlLCBzb3J0ZWRFbGVtZW50cyk7XG5cbiAgbW9kZWxpbmcuYWxpZ25FbGVtZW50cyhzb3J0ZWRFbGVtZW50cywgYWxpZ25tZW50KTtcbn07XG4iLCJpbXBvcnQgQWxpZ25FbGVtZW50cyBmcm9tICcuL0FsaWduRWxlbWVudHMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdhbGlnbkVsZW1lbnRzJyBdLFxuICBhbGlnbkVsZW1lbnRzOiBbICd0eXBlJywgQWxpZ25FbGVtZW50cyBdXG59O1xuIiwiaW1wb3J0IHtcbiAgZmxhdHRlbixcbiAgZmlsdGVyLFxuICBmb3JFYWNoLFxuICBncm91cEJ5LFxuICBtYXAsXG4gIHVuaW9uQnlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgeyBzYXZlQ2xlYXIgfSBmcm9tICcuLi8uLi91dGlsL1JlbW92YWwnO1xuXG5pbXBvcnQgeyBnZXROZXdBdHRhY2hTaGFwZURlbHRhIH0gZnJvbSAnLi4vLi4vdXRpbC9BdHRhY2hVdGlsJztcblxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IENvbW1hbmRJbnRlcmNlcHRvciBmcm9tICcuLi8uLi9jb21tYW5kL0NvbW1hbmRJbnRlcmNlcHRvcic7XG5cbnZhciBMT1dfUFJJT1JJVFkgPSAyNTEsXG4gICAgSElHSF9QUklPUklUWSA9IDE0MDE7XG5cbnZhciBNQVJLRVJfQVRUQUNIID0gJ2F0dGFjaC1vayc7XG5cblxuLyoqXG4gKiBBZGRzIHRoZSBub3Rpb24gb2YgYXR0YWNoZWQgZWxlbWVudHMgdG8gdGhlIG1vZGVsZXIuXG4gKlxuICogT3B0aW9uYWxseSBkZXBlbmRzIG9uIGBkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb3ZlYCB0byByZW5kZXJcbiAqIHRoZSBhdHRhY2hlZCBlbGVtZW50cyBkdXJpbmcgbW92ZSBwcmV2aWV3LlxuICpcbiAqIE9wdGlvbmFsbHkgZGVwZW5kcyBvbiBgZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbGFiZWwtc3VwcG9ydGBcbiAqIHRvIHJlbmRlciBhdHRhY2hlZCBsYWJlbHMgZHVyaW5nIG1vdmUgcHJldmlldy5cbiAqXG4gKiBAcGFyYW0ge2RpZGkuSW5qZWN0b3J9IGluamVjdG9yXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtSdWxlc30gcnVsZXNcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEF0dGFjaFN1cHBvcnQoaW5qZWN0b3IsIGV2ZW50QnVzLCBjYW52YXMsIHJ1bGVzLCBtb2RlbGluZykge1xuXG4gIENvbW1hbmRJbnRlcmNlcHRvci5jYWxsKHRoaXMsIGV2ZW50QnVzKTtcblxuICB2YXIgbW92ZVByZXZpZXcgPSBpbmplY3Rvci5nZXQoJ21vdmVQcmV2aWV3JywgZmFsc2UpO1xuXG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgYXR0YWNoZWQgZWxlbWVudHMgZnJvbSB0aGUgc2hhcGVzIHRvIGJlIHZhbGlkYXRlZFxuICAvLyBhZGQgYWxsIHRoZSBhdHRhY2hlZCBzaGFwZXMgdG8gdGhlIG92ZXJhbGwgbGlzdCBvZiBtb3ZlZCBzaGFwZXNcbiAgZXZlbnRCdXMub24oJ3NoYXBlLm1vdmUuc3RhcnQnLCBISUdIX1BSSU9SSVRZLCBmdW5jdGlvbihlKSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGUuY29udGV4dCxcbiAgICAgICAgc2hhcGVzID0gY29udGV4dC5zaGFwZXMsXG4gICAgICAgIHZhbGlkYXRlZFNoYXBlcyA9IGNvbnRleHQudmFsaWRhdGVkU2hhcGVzO1xuXG4gICAgY29udGV4dC5zaGFwZXMgPSBhZGRBdHRhY2hlZChzaGFwZXMpO1xuXG4gICAgY29udGV4dC52YWxpZGF0ZWRTaGFwZXMgPSByZW1vdmVBdHRhY2hlZCh2YWxpZGF0ZWRTaGFwZXMpO1xuICB9KTtcblxuICAvLyBhZGQgYXR0YWNoZXJzIHRvIHRoZSB2aXN1YWwncyBncm91cFxuICBtb3ZlUHJldmlldyAmJiBldmVudEJ1cy5vbignc2hhcGUubW92ZS5zdGFydCcsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBlLmNvbnRleHQsXG4gICAgICAgIHNoYXBlcyA9IGNvbnRleHQuc2hhcGVzLFxuICAgICAgICBhdHRhY2hlcnMgPSBnZXRBdHRhY2hlcnMoc2hhcGVzKTtcblxuICAgIGZvckVhY2goYXR0YWNoZXJzLCBmdW5jdGlvbihhdHRhY2hlcikge1xuICAgICAgbW92ZVByZXZpZXcubWFrZURyYWdnYWJsZShjb250ZXh0LCBhdHRhY2hlciwgdHJ1ZSk7XG5cbiAgICAgIGZvckVhY2goYXR0YWNoZXIubGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICBtb3ZlUHJldmlldy5tYWtlRHJhZ2dhYmxlKGNvbnRleHQsIGxhYmVsLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBhZGQgYXR0YWNoLW9rIG1hcmtlciB0byBjdXJyZW50IGhvc3RcbiAgbW92ZVByZXZpZXcgJiYgZXZlbnRCdXMub24oJ3NoYXBlLm1vdmUuc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgc2hhcGVzID0gY29udGV4dC5zaGFwZXM7XG5cbiAgICBpZiAoc2hhcGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaGFwZSA9IHNoYXBlc1swXTtcblxuICAgIHZhciBob3N0ID0gc2hhcGUuaG9zdDtcblxuICAgIGlmIChob3N0KSB7XG4gICAgICBjYW52YXMuYWRkTWFya2VyKGhvc3QsIE1BUktFUl9BVFRBQ0gpO1xuXG4gICAgICBldmVudEJ1cy5vbmNlKFtcbiAgICAgICAgJ3NoYXBlLm1vdmUub3V0JyxcbiAgICAgICAgJ3NoYXBlLm1vdmUuY2xlYW51cCdcbiAgICAgIF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGhvc3QsIE1BUktFUl9BVFRBQ0gpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBhZGQgYWxsIGF0dGFjaGVycyB0byBtb3ZlIGNsb3N1cmVcbiAgdGhpcy5wcmVFeGVjdXRlZCgnZWxlbWVudHMubW92ZScsIEhJR0hfUFJJT1JJVFksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY29udGV4dCA9IGUuY29udGV4dCxcbiAgICAgICAgY2xvc3VyZSA9IGNvbnRleHQuY2xvc3VyZSxcbiAgICAgICAgc2hhcGVzID0gY29udGV4dC5zaGFwZXMsXG4gICAgICAgIGF0dGFjaGVycyA9IGdldEF0dGFjaGVycyhzaGFwZXMpO1xuXG4gICAgZm9yRWFjaChhdHRhY2hlcnMsIGZ1bmN0aW9uKGF0dGFjaGVyKSB7XG4gICAgICBjbG9zdXJlLmFkZChhdHRhY2hlciwgY2xvc3VyZS50b3BMZXZlbFthdHRhY2hlci5ob3N0LmlkXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHBlcmZvcm0gdGhlIGF0dGFjaGluZyBhZnRlciBzaGFwZXMgYXJlIGRvbmUgbW92aW5nXG4gIHRoaXMucG9zdEV4ZWN1dGVkKCdlbGVtZW50cy5tb3ZlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBlLmNvbnRleHQsXG4gICAgICAgIHNoYXBlcyA9IGNvbnRleHQuc2hhcGVzLFxuICAgICAgICBuZXdIb3N0ID0gY29udGV4dC5uZXdIb3N0LFxuICAgICAgICBhdHRhY2hlcnM7XG5cbiAgICAvLyBvbmx5IHNpbmdsZSBlbGVtZW50cyBjYW4gYmUgYXR0YWNoZWRcbiAgICAvLyBtdWx0aXBseSBlbGVtZW50cyBjYW4gYmUgZGV0YWNoZWRcbiAgICBpZiAobmV3SG9zdCAmJiBzaGFwZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5ld0hvc3QpIHtcbiAgICAgIGF0dGFjaGVycyA9IHNoYXBlcztcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBmaW5kIGF0dGFjaGVycyBtb3ZlZCB3aXRob3V0IGhvc3RcbiAgICAgIGF0dGFjaGVycyA9IGZpbHRlcihzaGFwZXMsIGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgIHZhciBob3N0ID0gc2hhcGUuaG9zdDtcblxuICAgICAgICByZXR1cm4gaXNBdHRhY2hlcihzaGFwZSkgJiYgIWluY2x1ZGVzKHNoYXBlcywgaG9zdCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3JFYWNoKGF0dGFjaGVycywgZnVuY3Rpb24oYXR0YWNoZXIpIHtcbiAgICAgIG1vZGVsaW5nLnVwZGF0ZUF0dGFjaG1lbnQoYXR0YWNoZXIsIG5ld0hvc3QpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBlbnN1cmUgaW52YWxpZCBhdHRhY2htZW50IGNvbm5lY3Rpb25zIGFyZSByZW1vdmVkXG4gIHRoaXMucG9zdEV4ZWN1dGVkKCdlbGVtZW50cy5tb3ZlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIHNoYXBlcyA9IGUuY29udGV4dC5zaGFwZXM7XG5cbiAgICBmb3JFYWNoKHNoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcblxuICAgICAgZm9yRWFjaChzaGFwZS5hdHRhY2hlcnMsIGZ1bmN0aW9uKGF0dGFjaGVyKSB7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGludmFsaWQgb3V0Z29pbmcgY29ubmVjdGlvbnNcbiAgICAgICAgZm9yRWFjaChhdHRhY2hlci5vdXRnb2luZy5zbGljZSgpLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGFsbG93ZWQgPSBydWxlcy5hbGxvd2VkKCdjb25uZWN0aW9uLnJlY29ubmVjdCcsIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgICAgICAgICBzb3VyY2U6IGNvbm5lY3Rpb24uc291cmNlLFxuICAgICAgICAgICAgdGFyZ2V0OiBjb25uZWN0aW9uLnRhcmdldFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICAgICAgICBtb2RlbGluZy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGludmFsaWQgaW5jb21pbmcgY29ubmVjdGlvbnNcbiAgICAgICAgZm9yRWFjaChhdHRhY2hlci5pbmNvbWluZy5zbGljZSgpLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGFsbG93ZWQgPSBydWxlcy5hbGxvd2VkKCdjb25uZWN0aW9uLnJlY29ubmVjdCcsIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgICAgICAgICBzb3VyY2U6IGNvbm5lY3Rpb24uc291cmNlLFxuICAgICAgICAgICAgdGFyZ2V0OiBjb25uZWN0aW9uLnRhcmdldFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICAgICAgICBtb2RlbGluZy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGhpcy5wb3N0RXhlY3V0ZSgnc2hhcGUuY3JlYXRlJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIGhvc3QgPSBjb250ZXh0Lmhvc3Q7XG5cbiAgICBpZiAoaG9zdCkge1xuICAgICAgbW9kZWxpbmcudXBkYXRlQXR0YWNobWVudChzaGFwZSwgaG9zdCk7XG4gICAgfVxuICB9KTtcblxuICAvLyB1cGRhdGUgYXR0YWNobWVudHMgaWYgdGhlIGhvc3QgaXMgcmVwbGFjZWRcbiAgdGhpcy5wb3N0RXhlY3V0ZSgnc2hhcGUucmVwbGFjZScsIGZ1bmN0aW9uKGUpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBvbGRTaGFwZSA9IGNvbnRleHQub2xkU2hhcGUsXG4gICAgICAgIG5ld1NoYXBlID0gY29udGV4dC5uZXdTaGFwZTtcblxuICAgIC8vIG1vdmUgdGhlIGF0dGFjaGVycyB0byB0aGUgbmV3IGhvc3RcbiAgICBzYXZlQ2xlYXIob2xkU2hhcGUuYXR0YWNoZXJzLCBmdW5jdGlvbihhdHRhY2hlcikge1xuICAgICAgdmFyIGFsbG93ZWQgPSBydWxlcy5hbGxvd2VkKCdlbGVtZW50cy5tb3ZlJywge1xuICAgICAgICB0YXJnZXQ6IG5ld1NoYXBlLFxuICAgICAgICBzaGFwZXM6IFthdHRhY2hlcl1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYWxsb3dlZCA9PT0gJ2F0dGFjaCcpIHtcbiAgICAgICAgbW9kZWxpbmcudXBkYXRlQXR0YWNobWVudChhdHRhY2hlciwgbmV3U2hhcGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWxpbmcucmVtb3ZlU2hhcGUoYXR0YWNoZXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gbW92ZSBhdHRhY2hlcnMgaWYgbmV3IGhvc3QgaGFzIGRpZmZlcmVudCBzaXplXG4gICAgaWYgKG5ld1NoYXBlLmF0dGFjaGVycy5sZW5ndGgpIHtcblxuICAgICAgZm9yRWFjaChuZXdTaGFwZS5hdHRhY2hlcnMsIGZ1bmN0aW9uKGF0dGFjaGVyKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IGdldE5ld0F0dGFjaFNoYXBlRGVsdGEoYXR0YWNoZXIsIG9sZFNoYXBlLCBuZXdTaGFwZSk7XG4gICAgICAgIG1vZGVsaW5nLm1vdmVTaGFwZShhdHRhY2hlciwgZGVsdGEsIGF0dGFjaGVyLnBhcmVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gbW92ZSBzaGFwZSBvbiBob3N0IHJlc2l6ZVxuICB0aGlzLnBvc3RFeGVjdXRlKCdzaGFwZS5yZXNpemUnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBvbGRCb3VuZHMgPSBjb250ZXh0Lm9sZEJvdW5kcyxcbiAgICAgICAgbmV3Qm91bmRzID0gY29udGV4dC5uZXdCb3VuZHMsXG4gICAgICAgIGF0dGFjaGVycyA9IHNoYXBlLmF0dGFjaGVycyxcbiAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gICAgaWYgKGhpbnRzLmF0dGFjaFN1cHBvcnQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yRWFjaChhdHRhY2hlcnMsIGZ1bmN0aW9uKGF0dGFjaGVyKSB7XG4gICAgICB2YXIgZGVsdGEgPSBnZXROZXdBdHRhY2hTaGFwZURlbHRhKGF0dGFjaGVyLCBvbGRCb3VuZHMsIG5ld0JvdW5kcyk7XG5cbiAgICAgIG1vZGVsaW5nLm1vdmVTaGFwZShhdHRhY2hlciwgZGVsdGEsIGF0dGFjaGVyLnBhcmVudCk7XG5cbiAgICAgIGZvckVhY2goYXR0YWNoZXIubGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICBtb2RlbGluZy5tb3ZlU2hhcGUobGFiZWwsIGRlbHRhLCBsYWJlbC5wYXJlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHJlbW92ZSBhdHRhY2htZW50c1xuICB0aGlzLnByZUV4ZWN1dGUoJ3NoYXBlLmRlbGV0ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgc2hhcGUgPSBldmVudC5jb250ZXh0LnNoYXBlO1xuXG4gICAgc2F2ZUNsZWFyKHNoYXBlLmF0dGFjaGVycywgZnVuY3Rpb24oYXR0YWNoZXIpIHtcbiAgICAgIG1vZGVsaW5nLnJlbW92ZVNoYXBlKGF0dGFjaGVyKTtcbiAgICB9KTtcblxuICAgIGlmIChzaGFwZS5ob3N0KSB7XG4gICAgICBtb2RlbGluZy51cGRhdGVBdHRhY2htZW50KHNoYXBlLCBudWxsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5pbmhlcml0cyhBdHRhY2hTdXBwb3J0LCBDb21tYW5kSW50ZXJjZXB0b3IpO1xuXG5BdHRhY2hTdXBwb3J0LiRpbmplY3QgPSBbXG4gICdpbmplY3RvcicsXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAncnVsZXMnLFxuICAnbW9kZWxpbmcnXG5dO1xuXG5cbi8qKlxuICogUmV0dXJuIGF0dGFjaGVycyBvZiB0aGUgZ2l2ZW4gc2hhcGVzXG4gKlxuICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuQmFzZT59IHNoYXBlc1xuICogQHJldHVybiB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fVxuICovXG5mdW5jdGlvbiBnZXRBdHRhY2hlcnMoc2hhcGVzKSB7XG4gIHJldHVybiBmbGF0dGVuKG1hcChzaGFwZXMsIGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gcy5hdHRhY2hlcnMgfHwgW107XG4gIH0pKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBjb21iaW5lZCBsaXN0IG9mIGVsZW1lbnRzIGFuZFxuICogYXR0YWNoZXJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBlbGVtZW50c1xuICogQHJldHVybiB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBmaWx0ZXJlZFxuICovXG5mdW5jdGlvbiBhZGRBdHRhY2hlZChlbGVtZW50cykge1xuICB2YXIgYXR0YWNoZXJzID0gZ2V0QXR0YWNoZXJzKGVsZW1lbnRzKTtcblxuICByZXR1cm4gdW5pb25CeSgnaWQnLCBlbGVtZW50cywgYXR0YWNoZXJzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmaWx0ZXJlZCBsaXN0IG9mIGVsZW1lbnRzIHRoYXQgZG8gbm90XG4gKiBjb250YWluIGF0dGFjaGVkIGVsZW1lbnRzIHdpdGggaG9zdHMgYmVpbmcgcGFydFxuICogb2YgdGhlIHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzXG4gKlxuICogQHJldHVybiB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBmaWx0ZXJlZFxuICovXG5mdW5jdGlvbiByZW1vdmVBdHRhY2hlZChlbGVtZW50cykge1xuXG4gIHZhciBpZHMgPSBncm91cEJ5KGVsZW1lbnRzLCAnaWQnKTtcblxuICByZXR1cm4gZmlsdGVyKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgd2hpbGUgKGVsZW1lbnQpIHtcblxuICAgICAgLy8gaG9zdCBpbiBzZWxlY3Rpb25cbiAgICAgIGlmIChlbGVtZW50Lmhvc3QgJiYgaWRzW2VsZW1lbnQuaG9zdC5pZF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0F0dGFjaGVyKHNoYXBlKSB7XG4gIHJldHVybiAhIXNoYXBlLmhvc3Q7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzKGFycmF5LCBpdGVtKSB7XG4gIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbn0iLCJpbXBvcnQgUnVsZXNNb2R1bGUgZnJvbSAnLi4vcnVsZXMnO1xuXG5pbXBvcnQgQXR0YWNoU3VwcG9ydCBmcm9tICcuL0F0dGFjaFN1cHBvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgUnVsZXNNb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFsgJ2F0dGFjaFN1cHBvcnQnIF0sXG4gIGF0dGFjaFN1cHBvcnQ6IFsgJ3R5cGUnLCBBdHRhY2hTdXBwb3J0IF1cbn07XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIHRvUG9pbnRcbn0gZnJvbSAnLi4vLi4vdXRpbC9FdmVudCc7XG5cblxuLyoqXG4gKiBJbml0aWF0ZXMgY2FudmFzIHNjcm9sbGluZyBpZiBjdXJyZW50IGN1cnNvciBwb2ludCBpcyBjbG9zZSB0byBhIGJvcmRlci5cbiAqIENhbmNlbGxlZCB3aGVuIGN1cnJlbnQgcG9pbnQgbW92ZXMgYmFjayBpbnNpZGUgdGhlIHNjcm9sbGluZyBib3JkZXJzXG4gKiBvciBjYW5jZWxsZWQgbWFudWFsbHkuXG4gKlxuICogRGVmYXVsdCBvcHRpb25zIDpcbiAqICAgc2Nyb2xsVGhyZXNob2xkSW46IFsgMjAsIDIwLCAyMCwgMjAgXSxcbiAqICAgc2Nyb2xsVGhyZXNob2xkT3V0OiBbIDAsIDAsIDAsIDAgXSxcbiAqICAgc2Nyb2xsUmVwZWF0VGltZW91dDogMTUsXG4gKiAgIHNjcm9sbFN0ZXA6IDEwXG4gKlxuICogVGhyZXNob2xkIG9yZGVyOlxuICogICBbIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSBdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEF1dG9TY3JvbGwoY29uZmlnLCBldmVudEJ1cywgY2FudmFzKSB7XG5cbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuXG4gIHRoaXMuX29wdHMgPSBhc3NpZ24oe1xuICAgIHNjcm9sbFRocmVzaG9sZEluOiBbIDIwLCAyMCwgMjAsIDIwIF0sXG4gICAgc2Nyb2xsVGhyZXNob2xkT3V0OiBbIDAsIDAsIDAsIDAgXSxcbiAgICBzY3JvbGxSZXBlYXRUaW1lb3V0OiAxNSxcbiAgICBzY3JvbGxTdGVwOiAxMFxuICB9LCBjb25maWcpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBldmVudEJ1cy5vbignZHJhZy5tb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBwb2ludCA9IHNlbGYuX3RvQm9yZGVyUG9pbnQoZSk7XG5cbiAgICBzZWxmLnN0YXJ0U2Nyb2xsKHBvaW50KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oWyAnZHJhZy5jbGVhbnVwJyBdLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLnN0b3BTY3JvbGwoKTtcbiAgfSk7XG59XG5cbkF1dG9TY3JvbGwuJGluamVjdCA9IFtcbiAgJ2NvbmZpZy5hdXRvU2Nyb2xsJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcydcbl07XG5cblxuLyoqXG4gKiBTdGFydHMgc2Nyb2xsaW5nIGxvb3AuXG4gKiBQb2ludCBpcyBnaXZlbiBpbiBnbG9iYWwgc2NhbGUgaW4gY2FudmFzIGNvbnRhaW5lciBib3ggcGxhbmUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCB7IHg6IFgsIHk6IFkgfVxuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5zdGFydFNjcm9sbCA9IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcbiAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGNsaWVudFJlY3QgPSBjYW52YXMuZ2V0Q29udGFpbmVyKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgdmFyIGRpZmYgPSBbXG4gICAgcG9pbnQueCxcbiAgICBwb2ludC55LFxuICAgIGNsaWVudFJlY3Qud2lkdGggLSBwb2ludC54LFxuICAgIGNsaWVudFJlY3QuaGVpZ2h0IC0gcG9pbnQueVxuICBdO1xuXG4gIHRoaXMuc3RvcFNjcm9sbCgpO1xuXG4gIHZhciBkeCA9IDAsXG4gICAgICBkeSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBpZiAoYmV0d2VlbihkaWZmW2ldLCBvcHRzLnNjcm9sbFRocmVzaG9sZE91dFtpXSwgb3B0cy5zY3JvbGxUaHJlc2hvbGRJbltpXSkpIHtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGR4ID0gb3B0cy5zY3JvbGxTdGVwO1xuICAgICAgfSBlbHNlIGlmIChpID09IDEpIHtcbiAgICAgICAgZHkgPSBvcHRzLnNjcm9sbFN0ZXA7XG4gICAgICB9IGVsc2UgaWYgKGkgPT0gMikge1xuICAgICAgICBkeCA9IC1vcHRzLnNjcm9sbFN0ZXA7XG4gICAgICB9IGVsc2UgaWYgKGkgPT0gMykge1xuICAgICAgICBkeSA9IC1vcHRzLnNjcm9sbFN0ZXA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG4gICAgY2FudmFzLnNjcm9sbCh7IGR4OiBkeCwgZHk6IGR5IH0pO1xuXG4gICAgdGhpcy5fc2Nyb2xsaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuc3RhcnRTY3JvbGwocG9pbnQpO1xuICAgIH0sIG9wdHMuc2Nyb2xsUmVwZWF0VGltZW91dCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJldHdlZW4odmFsLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA8IHZhbCAmJiB2YWwgPCBlbmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKipcbiAqIFN0b3BzIHNjcm9sbGluZyBsb29wLlxuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5zdG9wU2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9zY3JvbGxpbmcpO1xufTtcblxuXG4vKipcbiAqIE92ZXJyaWRlcyBkZWZhdWx0cyBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICovXG5BdXRvU2Nyb2xsLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLl9vcHRzID0gYXNzaWduKHt9LCB0aGlzLl9vcHRzLCBvcHRpb25zKTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0cyBldmVudCB0byBhIHBvaW50IGluIGNhbnZhcyBjb250YWluZXIgcGxhbmUgaW4gZ2xvYmFsIHNjYWxlLlxuICpcbiAqIEBwYXJhbSAge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7UG9pbnR9XG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLl90b0JvcmRlclBvaW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSB0aGlzLl9jYW52YXMuX2NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICB2YXIgZ2xvYmFsUG9zaXRpb24gPSB0b1BvaW50KGV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuXG4gIHJldHVybiB7XG4gICAgeDogZ2xvYmFsUG9zaXRpb24ueCAtIGNsaWVudFJlY3QubGVmdCxcbiAgICB5OiBnbG9iYWxQb3NpdGlvbi55IC0gY2xpZW50UmVjdC50b3BcbiAgfTtcbn07IiwiaW1wb3J0IERyYWdnaW5nTW9kdWxlIGZyb20gJy4uL2RyYWdnaW5nJztcblxuaW1wb3J0IEF1dG9TY3JvbGwgZnJvbSAnLi9BdXRvU2Nyb2xsJztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgRHJhZ2dpbmdNb2R1bGUsXG4gIF0sXG4gIF9faW5pdF9fOiBbICdhdXRvU2Nyb2xsJyBdLFxuICBhdXRvU2Nyb2xsOiBbICd0eXBlJywgQXV0b1Njcm9sbCBdXG59OyIsImltcG9ydCB7IGZpbHRlclJlZHVuZGFudFdheXBvaW50cyB9IGZyb20gJy4uLy4uL2xheW91dC9MYXlvdXRVdGlsJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxudmFyIFJFQ09OTkVDVF9TVEFSVCA9ICdyZWNvbm5lY3RTdGFydCcsXG4gICAgUkVDT05ORUNUX0VORCA9ICdyZWNvbm5lY3RFbmQnLFxuICAgIFVQREFURV9XQVlQT0lOVFMgPSAndXBkYXRlV2F5cG9pbnRzJztcblxuXG4vKipcbiAqIE1vdmUgYmVuZHBvaW50cyB0aHJvdWdoIGRyYWcgYW5kIGRyb3AgdG8gYWRkL3JlbW92ZSBiZW5kcG9pbnRzIG9yIHJlY29ubmVjdCBjb25uZWN0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCZW5kcG9pbnRNb3ZlKGluamVjdG9yLCBldmVudEJ1cywgY2FudmFzLCBkcmFnZ2luZywgcnVsZXMsIG1vZGVsaW5nKSB7XG4gIHRoaXMuX2luamVjdG9yID0gaW5qZWN0b3I7XG5cbiAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKGV2ZW50LCBjb25uZWN0aW9uLCBiZW5kcG9pbnRJbmRleCwgaW5zZXJ0KSB7XG4gICAgdmFyIGdmeCA9IGNhbnZhcy5nZXRHcmFwaGljcyhjb25uZWN0aW9uKSxcbiAgICAgICAgc291cmNlID0gY29ubmVjdGlvbi5zb3VyY2UsXG4gICAgICAgIHRhcmdldCA9IGNvbm5lY3Rpb24udGFyZ2V0LFxuICAgICAgICB3YXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cyxcbiAgICAgICAgdHlwZTtcblxuICAgIGlmICghaW5zZXJ0ICYmIGJlbmRwb2ludEluZGV4ID09PSAwKSB7XG4gICAgICB0eXBlID0gUkVDT05ORUNUX1NUQVJUO1xuICAgIH0gZWxzZVxuICAgIGlmICghaW5zZXJ0ICYmIGJlbmRwb2ludEluZGV4ID09PSB3YXlwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgdHlwZSA9IFJFQ09OTkVDVF9FTkQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSBVUERBVEVfV0FZUE9JTlRTO1xuICAgIH1cblxuICAgIHZhciBjb21tYW5kID0gdHlwZSA9PT0gVVBEQVRFX1dBWVBPSU5UUyA/ICdjb25uZWN0aW9uLnVwZGF0ZVdheXBvaW50cycgOiAnY29ubmVjdGlvbi5yZWNvbm5lY3QnO1xuXG4gICAgdmFyIGFsbG93ZWQgPSBydWxlcy5hbGxvd2VkKGNvbW1hbmQsIHtcbiAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgfSk7XG5cbiAgICBpZiAoYWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGFsbG93ZWQgPSBydWxlcy5hbGxvd2VkKGNvbW1hbmQsIHtcbiAgICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgICAgc291cmNlOiB0YXJnZXQsXG4gICAgICAgIHRhcmdldDogc291cmNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkcmFnZ2luZy5pbml0KGV2ZW50LCAnYmVuZHBvaW50Lm1vdmUnLCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgICAgIGNvbm5lY3Rpb25HZng6IGdmeCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIGFsbG93ZWQ6IGFsbG93ZWQsXG4gICAgICAgICAgYmVuZHBvaW50SW5kZXg6IGJlbmRwb2ludEluZGV4LFxuICAgICAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgaW5zZXJ0OiBpbnNlcnQsXG4gICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZXZlbnRCdXMub24oJ2JlbmRwb2ludC5tb3ZlLmhvdmVyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICAgIHNvdXJjZSA9IGNvbm5lY3Rpb24uc291cmNlLFxuICAgICAgICB0YXJnZXQgPSBjb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgaG92ZXIgPSBldmVudC5ob3ZlcixcbiAgICAgICAgdHlwZSA9IGNvbnRleHQudHlwZTtcblxuICAgIC8vIGNhY2hlIGhvdmVyIHN0YXRlXG4gICAgY29udGV4dC5ob3ZlciA9IGhvdmVyO1xuXG4gICAgdmFyIGFsbG93ZWQ7XG5cbiAgICBpZiAoIWhvdmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbW1hbmQgPSB0eXBlID09PSBVUERBVEVfV0FZUE9JTlRTID8gJ2Nvbm5lY3Rpb24udXBkYXRlV2F5cG9pbnRzJyA6ICdjb25uZWN0aW9uLnJlY29ubmVjdCc7XG5cbiAgICBhbGxvd2VkID0gY29udGV4dC5hbGxvd2VkID0gcnVsZXMuYWxsb3dlZChjb21tYW5kLCB7XG4gICAgICBjb25uZWN0aW9uOiBjb25uZWN0aW9uLFxuICAgICAgc291cmNlOiB0eXBlID09PSBSRUNPTk5FQ1RfU1RBUlQgPyBob3ZlciA6IHNvdXJjZSxcbiAgICAgIHRhcmdldDogdHlwZSA9PT0gUkVDT05ORUNUX0VORCA/IGhvdmVyIDogdGFyZ2V0XG4gICAgfSk7XG5cbiAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgY29udGV4dC5zb3VyY2UgPSB0eXBlID09PSBSRUNPTk5FQ1RfU1RBUlQgPyBob3ZlciA6IHNvdXJjZTtcbiAgICAgIGNvbnRleHQudGFyZ2V0ID0gdHlwZSA9PT0gUkVDT05ORUNUX0VORCA/IGhvdmVyIDogdGFyZ2V0O1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFsbG93ZWQgPT09IGZhbHNlKSB7XG4gICAgICBhbGxvd2VkID0gY29udGV4dC5hbGxvd2VkID0gcnVsZXMuYWxsb3dlZChjb21tYW5kLCB7XG4gICAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgICAgIHNvdXJjZTogdHlwZSA9PT0gUkVDT05ORUNUX0VORCA/IGhvdmVyIDogdGFyZ2V0LFxuICAgICAgICB0YXJnZXQ6IHR5cGUgPT09IFJFQ09OTkVDVF9TVEFSVCA/IGhvdmVyIDogc291cmNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgY29udGV4dC5zb3VyY2UgPSB0eXBlID09PSBSRUNPTk5FQ1RfRU5EID8gaG92ZXIgOiB0YXJnZXQ7XG4gICAgICBjb250ZXh0LnRhcmdldCA9IHR5cGUgPT09IFJFQ09OTkVDVF9TVEFSVCA/IGhvdmVyIDogc291cmNlO1xuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oWyAnYmVuZHBvaW50Lm1vdmUub3V0JywgJ2JlbmRwb2ludC5tb3ZlLmNsZWFudXAnIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlO1xuXG4gICAgY29udGV4dC5ob3ZlciA9IG51bGw7XG4gICAgY29udGV4dC5zb3VyY2UgPSBudWxsO1xuICAgIGNvbnRleHQudGFyZ2V0ID0gbnVsbDtcblxuICAgIGlmICh0eXBlICE9PSBVUERBVEVfV0FZUE9JTlRTKSB7XG4gICAgICBjb250ZXh0LmFsbG93ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdiZW5kcG9pbnQubW92ZS5lbmQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgYWxsb3dlZCA9IGNvbnRleHQuYWxsb3dlZCxcbiAgICAgICAgYmVuZHBvaW50SW5kZXggPSBjb250ZXh0LmJlbmRwb2ludEluZGV4LFxuICAgICAgICBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgICBpbnNlcnQgPSBjb250ZXh0Lmluc2VydCxcbiAgICAgICAgbmV3V2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHMuc2xpY2UoKSxcbiAgICAgICAgc291cmNlID0gY29udGV4dC5zb3VyY2UsXG4gICAgICAgIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0LFxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlLFxuICAgICAgICBoaW50cyA9IGNvbnRleHQuaGludHMgfHwge307XG5cbiAgICAvLyBlbnN1cmUgaW50ZWdlciB2YWx1ZXMgKGltcG9ydGFudCBpZiB6b29tIGxldmVsIHdhcyA+IDEgZHVyaW5nIG1vdmUpXG4gICAgdmFyIGRvY2tpbmcgPSB7XG4gICAgICB4OiByb3VuZChldmVudC54KSxcbiAgICAgIHk6IHJvdW5kKGV2ZW50LnkpXG4gICAgfTtcblxuICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBVUERBVEVfV0FZUE9JTlRTKSB7XG4gICAgICBpZiAoaW5zZXJ0KSB7XG5cbiAgICAgICAgLy8gaW5zZXJ0IG5ldyBiZW5kcG9pbnRcbiAgICAgICAgbmV3V2F5cG9pbnRzLnNwbGljZShiZW5kcG9pbnRJbmRleCwgMCwgZG9ja2luZyk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHN3YXAgcHJldmlvdXMgd2F5cG9pbnQgd2l0aCBtb3ZlZCBvbmVcbiAgICAgICAgbmV3V2F5cG9pbnRzW2JlbmRwb2ludEluZGV4XSA9IGRvY2tpbmc7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhc3MgaGludHMgYWJvdXQgYWN0dWFsIG1vdmVkIGJlbmRwb2ludFxuICAgICAgLy8gdXNlZnVsIGZvciBjb25uZWN0aW9uL2xhYmVsIGxheW91dFxuICAgICAgaGludHMuYmVuZHBvaW50TW92ZSA9IHtcbiAgICAgICAgaW5zZXJ0OiBpbnNlcnQsXG4gICAgICAgIGJlbmRwb2ludEluZGV4OiBiZW5kcG9pbnRJbmRleFxuICAgICAgfTtcblxuICAgICAgbmV3V2F5cG9pbnRzID0gdGhpcy5jcm9wV2F5cG9pbnRzKGNvbm5lY3Rpb24sIG5ld1dheXBvaW50cyk7XG5cbiAgICAgIG1vZGVsaW5nLnVwZGF0ZVdheXBvaW50cyhjb25uZWN0aW9uLCBmaWx0ZXJSZWR1bmRhbnRXYXlwb2ludHMobmV3V2F5cG9pbnRzKSwgaGludHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVDT05ORUNUX1NUQVJUKSB7XG4gICAgICAgIGhpbnRzLmRvY2tpbmcgPSAnc291cmNlJztcblxuICAgICAgICBpZiAoaXNSZXZlcnNlKGNvbnRleHQpKSB7XG4gICAgICAgICAgaGludHMuZG9ja2luZyA9ICd0YXJnZXQnO1xuXG4gICAgICAgICAgaGludHMubmV3V2F5cG9pbnRzID0gbmV3V2F5cG9pbnRzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBSRUNPTk5FQ1RfRU5EKSB7XG4gICAgICAgIGhpbnRzLmRvY2tpbmcgPSAndGFyZ2V0JztcblxuICAgICAgICBpZiAoaXNSZXZlcnNlKGNvbnRleHQpKSB7XG4gICAgICAgICAgaGludHMuZG9ja2luZyA9ICdzb3VyY2UnO1xuXG4gICAgICAgICAgaGludHMubmV3V2F5cG9pbnRzID0gbmV3V2F5cG9pbnRzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtb2RlbGluZy5yZWNvbm5lY3QoY29ubmVjdGlvbiwgc291cmNlLCB0YXJnZXQsIGRvY2tpbmcsIGhpbnRzKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xufVxuXG5CZW5kcG9pbnRNb3ZlLiRpbmplY3QgPSBbXG4gICdpbmplY3RvcicsXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnZHJhZ2dpbmcnLFxuICAncnVsZXMnLFxuICAnbW9kZWxpbmcnXG5dO1xuXG5CZW5kcG9pbnRNb3ZlLnByb3RvdHlwZS5jcm9wV2F5cG9pbnRzID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgbmV3V2F5cG9pbnRzKSB7XG4gIHZhciBjb25uZWN0aW9uRG9ja2luZyA9IHRoaXMuX2luamVjdG9yLmdldCgnY29ubmVjdGlvbkRvY2tpbmcnLCBmYWxzZSk7XG5cbiAgaWYgKCFjb25uZWN0aW9uRG9ja2luZykge1xuICAgIHJldHVybiBuZXdXYXlwb2ludHM7XG4gIH1cblxuICB2YXIgd2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHM7XG5cbiAgY29ubmVjdGlvbi53YXlwb2ludHMgPSBuZXdXYXlwb2ludHM7XG5cbiAgY29ubmVjdGlvbi53YXlwb2ludHMgPSBjb25uZWN0aW9uRG9ja2luZy5nZXRDcm9wcGVkV2F5cG9pbnRzKGNvbm5lY3Rpb24pO1xuXG4gIG5ld1dheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzO1xuXG4gIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gd2F5cG9pbnRzO1xuXG4gIHJldHVybiBuZXdXYXlwb2ludHM7XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXZlcnNlKGNvbnRleHQpIHtcbiAgdmFyIGhvdmVyID0gY29udGV4dC5ob3ZlcixcbiAgICAgIHNvdXJjZSA9IGNvbnRleHQuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gY29udGV4dC50YXJnZXQsXG4gICAgICB0eXBlID0gY29udGV4dC50eXBlO1xuXG4gIGlmICh0eXBlID09PSBSRUNPTk5FQ1RfU1RBUlQpIHtcbiAgICByZXR1cm4gaG92ZXIgJiYgdGFyZ2V0ICYmIGhvdmVyID09PSB0YXJnZXQgJiYgc291cmNlICE9PSB0YXJnZXQ7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUkVDT05ORUNUX0VORCkge1xuICAgIHJldHVybiBob3ZlciAmJiBzb3VyY2UgJiYgaG92ZXIgPT09IHNvdXJjZSAmJiBzb3VyY2UgIT09IHRhcmdldDtcbiAgfVxufSIsImltcG9ydCB7XG4gIGNsYXNzZXMgYXMgc3ZnQ2xhc3NlcyxcbiAgcmVtb3ZlIGFzIHN2Z1JlbW92ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7IGFkZEJlbmRwb2ludCB9IGZyb20gJy4vQmVuZHBvaW50VXRpbCc7XG5cbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWwvU3ZnVHJhbnNmb3JtVXRpbCc7XG5cbmltcG9ydCB7IGlzUmV2ZXJzZSB9IGZyb20gJy4vQmVuZHBvaW50TW92ZSc7XG5cbnZhciBSRUNPTk5FQ1RfU1RBUlQgPSAncmVjb25uZWN0U3RhcnQnLFxuICAgIFJFQ09OTkVDVF9FTkQgPSAncmVjb25uZWN0RW5kJyxcbiAgICBVUERBVEVfV0FZUE9JTlRTID0gJ3VwZGF0ZVdheXBvaW50cyc7XG5cbnZhciBNQVJLRVJfT0sgPSAnY29ubmVjdC1vaycsXG4gICAgTUFSS0VSX05PVF9PSyA9ICdjb25uZWN0LW5vdC1vaycsXG4gICAgTUFSS0VSX0NPTk5FQ1RfSE9WRVIgPSAnY29ubmVjdC1ob3ZlcicsXG4gICAgTUFSS0VSX0NPTk5FQ1RfVVBEQVRJTkcgPSAnZGpzLXVwZGF0aW5nJyxcbiAgICBNQVJLRVJfRUxFTUVOVF9ISURERU4gPSAnZGpzLWVsZW1lbnQtaGlkZGVuJztcblxudmFyIEhJR0hfUFJJT1JJVFkgPSAxMTAwO1xuXG4vKipcbiAqIFByZXZpZXcgY29ubmVjdGlvbiB3aGlsZSBtb3ZpbmcgYmVuZHBvaW50cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQmVuZHBvaW50TW92ZVByZXZpZXcoYmVuZHBvaW50TW92ZSwgaW5qZWN0b3IsIGV2ZW50QnVzLCBjYW52YXMpIHtcbiAgdGhpcy5faW5qZWN0b3IgPSBpbmplY3RvcjtcblxuICB2YXIgY29ubmVjdGlvblByZXZpZXcgPSBpbmplY3Rvci5nZXQoJ2Nvbm5lY3Rpb25QcmV2aWV3JywgZmFsc2UpO1xuXG4gIGV2ZW50QnVzLm9uKCdiZW5kcG9pbnQubW92ZS5zdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBiZW5kcG9pbnRJbmRleCA9IGNvbnRleHQuYmVuZHBvaW50SW5kZXgsXG4gICAgICAgIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICAgIGluc2VydCA9IGNvbnRleHQuaW5zZXJ0LFxuICAgICAgICB3YXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cyxcbiAgICAgICAgbmV3V2F5cG9pbnRzID0gd2F5cG9pbnRzLnNsaWNlKCk7XG5cbiAgICBjb250ZXh0LndheXBvaW50cyA9IHdheXBvaW50cztcblxuICAgIGlmIChpbnNlcnQpIHtcblxuICAgICAgLy8gaW5zZXJ0IHBsYWNlaG9sZGVyIGZvciBuZXcgYmVuZHBvaW50XG4gICAgICBuZXdXYXlwb2ludHMuc3BsaWNlKGJlbmRwb2ludEluZGV4LCAwLCB7IHg6IGV2ZW50LngsIHk6IGV2ZW50LnkgfSk7XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi53YXlwb2ludHMgPSBuZXdXYXlwb2ludHM7XG5cbiAgICAvLyBhZGQgZHJhZ2dlciBnZnhcbiAgICB2YXIgZHJhZ2dlckdmeCA9IGNvbnRleHQuZHJhZ2dlckdmeCA9IGFkZEJlbmRwb2ludChjYW52YXMuZ2V0TGF5ZXIoJ292ZXJsYXlzJykpO1xuXG4gICAgc3ZnQ2xhc3NlcyhkcmFnZ2VyR2Z4KS5hZGQoJ2Rqcy1kcmFnZ2luZycpO1xuXG4gICAgY2FudmFzLmFkZE1hcmtlcihjb25uZWN0aW9uLCBNQVJLRVJfRUxFTUVOVF9ISURERU4pO1xuICAgIGNhbnZhcy5hZGRNYXJrZXIoY29ubmVjdGlvbiwgTUFSS0VSX0NPTk5FQ1RfVVBEQVRJTkcpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignYmVuZHBvaW50Lm1vdmUuaG92ZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgYWxsb3dlZCA9IGNvbnRleHQuYWxsb3dlZCxcbiAgICAgICAgaG92ZXIgPSBjb250ZXh0LmhvdmVyLFxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlO1xuXG4gICAgaWYgKGhvdmVyKSB7XG4gICAgICBjYW52YXMuYWRkTWFya2VyKGhvdmVyLCBNQVJLRVJfQ09OTkVDVF9IT1ZFUik7XG5cbiAgICAgIGlmICh0eXBlID09PSBVUERBVEVfV0FZUE9JTlRTKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZU1hcmtlcihob3ZlciwgTUFSS0VSX05PVF9PSyk7XG4gICAgICAgIGNhbnZhcy5hZGRNYXJrZXIoaG92ZXIsIE1BUktFUl9PSyk7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoaG92ZXIsIE1BUktFUl9PSyk7XG4gICAgICAgIGNhbnZhcy5hZGRNYXJrZXIoaG92ZXIsIE1BUktFUl9OT1RfT0spO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oW1xuICAgICdiZW5kcG9pbnQubW92ZS5vdXQnLFxuICAgICdiZW5kcG9pbnQubW92ZS5jbGVhbnVwJ1xuICBdLCBISUdIX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgaG92ZXIgPSBjb250ZXh0LmhvdmVyLFxuICAgICAgICB0YXJnZXQgPSBjb250ZXh0LnRhcmdldDtcblxuICAgIGlmIChob3Zlcikge1xuICAgICAgY2FudmFzLnJlbW92ZU1hcmtlcihob3ZlciwgTUFSS0VSX0NPTk5FQ1RfSE9WRVIpO1xuICAgICAgY2FudmFzLnJlbW92ZU1hcmtlcihob3ZlciwgdGFyZ2V0ID8gTUFSS0VSX09LIDogTUFSS0VSX05PVF9PSyk7XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbignYmVuZHBvaW50Lm1vdmUubW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBhbGxvd2VkID0gY29udGV4dC5hbGxvd2VkLFxuICAgICAgICBiZW5kcG9pbnRJbmRleCA9IGNvbnRleHQuYmVuZHBvaW50SW5kZXgsXG4gICAgICAgIGRyYWdnZXJHZnggPSBjb250ZXh0LmRyYWdnZXJHZngsXG4gICAgICAgIGhvdmVyID0gY29udGV4dC5ob3ZlcixcbiAgICAgICAgdHlwZSA9IGNvbnRleHQudHlwZSxcbiAgICAgICAgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgICAgc291cmNlID0gY29ubmVjdGlvbi5zb3VyY2UsXG4gICAgICAgIHRhcmdldCA9IGNvbm5lY3Rpb24udGFyZ2V0LFxuICAgICAgICBuZXdXYXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cy5zbGljZSgpLFxuICAgICAgICBiZW5kcG9pbnQgPSB7IHg6IGV2ZW50LngsIHk6IGV2ZW50LnkgfSxcbiAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9LFxuICAgICAgICBkcmF3UHJldmlld0hpbnRzID0ge307XG5cbiAgICBpZiAoY29ubmVjdGlvblByZXZpZXcpIHtcbiAgICAgIGlmIChoaW50cy5jb25uZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgZHJhd1ByZXZpZXdIaW50cy5jb25uZWN0aW9uU3RhcnQgPSBoaW50cy5jb25uZWN0aW9uU3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChoaW50cy5jb25uZWN0aW9uRW5kKSB7XG4gICAgICAgIGRyYXdQcmV2aWV3SGludHMuY29ubmVjdGlvbkVuZCA9IGhpbnRzLmNvbm5lY3Rpb25FbmQ7XG4gICAgICB9XG5cblxuICAgICAgaWYgKHR5cGUgPT09IFJFQ09OTkVDVF9TVEFSVCkge1xuICAgICAgICBpZiAoaXNSZXZlcnNlKGNvbnRleHQpKSB7XG4gICAgICAgICAgZHJhd1ByZXZpZXdIaW50cy5jb25uZWN0aW9uRW5kID0gZHJhd1ByZXZpZXdIaW50cy5jb25uZWN0aW9uRW5kIHx8IGJlbmRwb2ludDtcblxuICAgICAgICAgIGRyYXdQcmV2aWV3SGludHMuc291cmNlID0gdGFyZ2V0O1xuICAgICAgICAgIGRyYXdQcmV2aWV3SGludHMudGFyZ2V0ID0gaG92ZXIgfHwgc291cmNlO1xuXG4gICAgICAgICAgbmV3V2F5cG9pbnRzID0gbmV3V2F5cG9pbnRzLnJldmVyc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkcmF3UHJldmlld0hpbnRzLmNvbm5lY3Rpb25TdGFydCA9IGRyYXdQcmV2aWV3SGludHMuY29ubmVjdGlvblN0YXJ0IHx8IGJlbmRwb2ludDtcblxuICAgICAgICAgIGRyYXdQcmV2aWV3SGludHMuc291cmNlID0gaG92ZXIgfHwgc291cmNlO1xuICAgICAgICAgIGRyYXdQcmV2aWV3SGludHMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFJFQ09OTkVDVF9FTkQpIHtcbiAgICAgICAgaWYgKGlzUmV2ZXJzZShjb250ZXh0KSkge1xuICAgICAgICAgIGRyYXdQcmV2aWV3SGludHMuY29ubmVjdGlvblN0YXJ0ID0gZHJhd1ByZXZpZXdIaW50cy5jb25uZWN0aW9uU3RhcnQgfHwgYmVuZHBvaW50O1xuXG4gICAgICAgICAgZHJhd1ByZXZpZXdIaW50cy5zb3VyY2UgPSBob3ZlciB8fCB0YXJnZXQ7XG4gICAgICAgICAgZHJhd1ByZXZpZXdIaW50cy50YXJnZXQgPSBzb3VyY2U7XG5cbiAgICAgICAgICBuZXdXYXlwb2ludHMgPSBuZXdXYXlwb2ludHMucmV2ZXJzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRyYXdQcmV2aWV3SGludHMuY29ubmVjdGlvbkVuZCA9IGRyYXdQcmV2aWV3SGludHMuY29ubmVjdGlvbkVuZCB8fCBiZW5kcG9pbnQ7XG5cbiAgICAgICAgICBkcmF3UHJldmlld0hpbnRzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICBkcmF3UHJldmlld0hpbnRzLnRhcmdldCA9IGhvdmVyIHx8IHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmF3UHJldmlld0hpbnRzLm5vQ3JvcHBpbmcgPSB0cnVlO1xuICAgICAgICBkcmF3UHJldmlld0hpbnRzLm5vTGF5b3V0ID0gdHJ1ZTtcbiAgICAgICAgbmV3V2F5cG9pbnRzWyBiZW5kcG9pbnRJbmRleCBdID0gYmVuZHBvaW50O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gVVBEQVRFX1dBWVBPSU5UUykge1xuICAgICAgICBuZXdXYXlwb2ludHMgPSBiZW5kcG9pbnRNb3ZlLmNyb3BXYXlwb2ludHMoY29ubmVjdGlvbiwgbmV3V2F5cG9pbnRzKTtcbiAgICAgIH1cblxuICAgICAgZHJhd1ByZXZpZXdIaW50cy53YXlwb2ludHMgPSBuZXdXYXlwb2ludHM7XG5cbiAgICAgIGNvbm5lY3Rpb25QcmV2aWV3LmRyYXdQcmV2aWV3KGNvbnRleHQsIGFsbG93ZWQsIGRyYXdQcmV2aWV3SGludHMpO1xuICAgIH1cblxuICAgIHRyYW5zbGF0ZShkcmFnZ2VyR2Z4LCBldmVudC54LCBldmVudC55KTtcbiAgfSwgdGhpcyk7XG5cbiAgZXZlbnRCdXMub24oW1xuICAgICdiZW5kcG9pbnQubW92ZS5lbmQnLFxuICAgICdiZW5kcG9pbnQubW92ZS5jYW5jZWwnXG4gIF0sIEhJR0hfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgICBkcmFnZ2VyR2Z4ID0gY29udGV4dC5kcmFnZ2VyR2Z4LFxuICAgICAgICBob3ZlciA9IGNvbnRleHQuaG92ZXIsXG4gICAgICAgIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0LFxuICAgICAgICB3YXlwb2ludHMgPSBjb250ZXh0LndheXBvaW50cztcblxuICAgIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gd2F5cG9pbnRzO1xuXG4gICAgLy8gcmVtb3ZlIGRyYWdnZXIgZ2Z4XG4gICAgc3ZnUmVtb3ZlKGRyYWdnZXJHZngpO1xuXG4gICAgY2FudmFzLnJlbW92ZU1hcmtlcihjb25uZWN0aW9uLCBNQVJLRVJfQ09OTkVDVF9VUERBVElORyk7XG4gICAgY2FudmFzLnJlbW92ZU1hcmtlcihjb25uZWN0aW9uLCBNQVJLRVJfRUxFTUVOVF9ISURERU4pO1xuXG4gICAgaWYgKGhvdmVyKSB7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGhvdmVyLCBNQVJLRVJfT0spO1xuICAgICAgY2FudmFzLnJlbW92ZU1hcmtlcihob3ZlciwgdGFyZ2V0ID8gTUFSS0VSX09LIDogTUFSS0VSX05PVF9PSyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3Rpb25QcmV2aWV3KSB7XG4gICAgICBjb25uZWN0aW9uUHJldmlldy5jbGVhblVwKGNvbnRleHQpO1xuICAgIH1cbiAgfSk7XG59XG5cbkJlbmRwb2ludE1vdmVQcmV2aWV3LiRpbmplY3QgPSBbXG4gICdiZW5kcG9pbnRNb3ZlJyxcbiAgJ2luamVjdG9yJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcydcbl07IiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmb3JFYWNoLFxuICBpc0FycmF5XG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHsgc2V0U25hcHBlZCB9IGZyb20gJy4uL3NuYXBwaW5nL1NuYXBVdGlsJztcblxudmFyIGFicz0gTWF0aC5hYnMsXG4gICAgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG52YXIgVE9MRVJBTkNFID0gMTA7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQmVuZHBvaW50U25hcHBpbmcoZXZlbnRCdXMpIHtcblxuICBmdW5jdGlvbiBzbmFwVG8odmFsdWVzLCB2YWx1ZSkge1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgdmFyIGkgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSBpZiAoYWJzKHZhbHVlc1tpXSAtIHZhbHVlKSA8PSBUT0xFUkFOQ0UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1tpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzID0gK3ZhbHVlcztcbiAgICAgIHZhciByZW0gPSB2YWx1ZSAlIHZhbHVlcztcblxuICAgICAgaWYgKHJlbSA8IFRPTEVSQU5DRSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgLSByZW07XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW0gPiB2YWx1ZXMgLSBUT0xFUkFOQ0UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIC0gcmVtICsgdmFsdWVzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1pZChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQud2lkdGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJvdW5kKGVsZW1lbnQud2lkdGggLyAyICsgZWxlbWVudC54KSxcbiAgICAgICAgeTogcm91bmQoZWxlbWVudC5oZWlnaHQgLyAyICsgZWxlbWVudC55KVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBjb25uZWN0aW9uIHNlZ21lbnQgc25hcHBpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIGdldENvbm5lY3Rpb25TZWdtZW50U25hcHMoY29udGV4dCkge1xuXG4gICAgdmFyIHNuYXBQb2ludHMgPSBjb250ZXh0LnNuYXBQb2ludHMsXG4gICAgICAgIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICAgIHdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzLFxuICAgICAgICBzZWdtZW50U3RhcnQgPSBjb250ZXh0LnNlZ21lbnRTdGFydCxcbiAgICAgICAgc2VnbWVudFN0YXJ0SW5kZXggPSBjb250ZXh0LnNlZ21lbnRTdGFydEluZGV4LFxuICAgICAgICBzZWdtZW50RW5kID0gY29udGV4dC5zZWdtZW50RW5kLFxuICAgICAgICBzZWdtZW50RW5kSW5kZXggPSBjb250ZXh0LnNlZ21lbnRFbmRJbmRleCxcbiAgICAgICAgYXhpcyA9IGNvbnRleHQuYXhpcztcblxuICAgIGlmIChzbmFwUG9pbnRzKSB7XG4gICAgICByZXR1cm4gc25hcFBvaW50cztcbiAgICB9XG5cbiAgICB2YXIgcmVmZXJlbmNlV2F5cG9pbnRzID0gW1xuICAgICAgd2F5cG9pbnRzW3NlZ21lbnRTdGFydEluZGV4IC0gMV0sXG4gICAgICBzZWdtZW50U3RhcnQsXG4gICAgICBzZWdtZW50RW5kLFxuICAgICAgd2F5cG9pbnRzW3NlZ21lbnRFbmRJbmRleCArIDFdXG4gICAgXTtcblxuICAgIGlmIChzZWdtZW50U3RhcnRJbmRleCA8IDIpIHtcbiAgICAgIHJlZmVyZW5jZVdheXBvaW50cy51bnNoaWZ0KG1pZChjb25uZWN0aW9uLnNvdXJjZSkpO1xuICAgIH1cblxuICAgIGlmIChzZWdtZW50RW5kSW5kZXggPiB3YXlwb2ludHMubGVuZ3RoIC0gMykge1xuICAgICAgcmVmZXJlbmNlV2F5cG9pbnRzLnVuc2hpZnQobWlkKGNvbm5lY3Rpb24udGFyZ2V0KSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5zbmFwUG9pbnRzID0gc25hcFBvaW50cyA9IHsgaG9yaXpvbnRhbDogW10gLCB2ZXJ0aWNhbDogW10gfTtcblxuICAgIGZvckVhY2gocmVmZXJlbmNlV2F5cG9pbnRzLCBmdW5jdGlvbihwKSB7XG5cbiAgICAgIC8vIHdlIHNuYXAgb24gZXhpc3RpbmcgYmVuZHBvaW50cyBvbmx5LFxuICAgICAgLy8gbm90IHBsYWNlaG9sZGVycyB0aGF0IGFyZSBpbnNlcnRlZCBkdXJpbmcgYWRkXG4gICAgICBpZiAocCkge1xuICAgICAgICBwID0gcC5vcmlnaW5hbCB8fCBwO1xuXG4gICAgICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgICAgICBzbmFwUG9pbnRzLmhvcml6b250YWwucHVzaChwLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgICAgIHNuYXBQb2ludHMudmVydGljYWwucHVzaChwLngpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc25hcFBvaW50cztcbiAgfVxuXG4gIGV2ZW50QnVzLm9uKCdjb25uZWN0aW9uU2VnbWVudC5tb3ZlLm1vdmUnLCAxNTAwLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgc25hcFBvaW50cyA9IGdldENvbm5lY3Rpb25TZWdtZW50U25hcHMoY29udGV4dCksXG4gICAgICAgIHggPSBldmVudC54LFxuICAgICAgICB5ID0gZXZlbnQueSxcbiAgICAgICAgc3gsIHN5O1xuXG4gICAgaWYgKCFzbmFwUG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc25hcFxuICAgIHN4ID0gc25hcFRvKHNuYXBQb2ludHMudmVydGljYWwsIHgpO1xuICAgIHN5ID0gc25hcFRvKHNuYXBQb2ludHMuaG9yaXpvbnRhbCwgeSk7XG5cblxuICAgIC8vIGNvcnJlY3Rpb24geC95XG4gICAgdmFyIGN4ID0gKHggLSBzeCksXG4gICAgICAgIGN5ID0gKHkgLSBzeSk7XG5cbiAgICAvLyB1cGRhdGUgZGVsdGFcbiAgICBhc3NpZ24oZXZlbnQsIHtcbiAgICAgIGR4OiBldmVudC5keCAtIGN4LFxuICAgICAgZHk6IGV2ZW50LmR5IC0gY3ksXG4gICAgICB4OiBzeCxcbiAgICAgIHk6IHN5XG4gICAgfSk7XG5cbiAgICAvLyBvbmx5IHNldCBzbmFwcGVkIGlmIGFjdHVhbGx5IHNuYXBwZWRcbiAgICBpZiAoY3ggfHwgc25hcFBvaW50cy52ZXJ0aWNhbC5pbmRleE9mKHgpICE9PSAtMSkge1xuICAgICAgc2V0U25hcHBlZChldmVudCwgJ3gnLCBzeCk7XG4gICAgfVxuXG4gICAgaWYgKGN5IHx8IHNuYXBQb2ludHMuaG9yaXpvbnRhbC5pbmRleE9mKHkpICE9PSAtMSkge1xuICAgICAgc2V0U25hcHBlZChldmVudCwgJ3knLCBzeSk7XG4gICAgfVxuICB9KTtcblxuXG4gIC8vIGJlbmRwb2ludCBzbmFwcGluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gZ2V0QmVuZHBvaW50U25hcHMoY29udGV4dCkge1xuXG4gICAgdmFyIHNuYXBQb2ludHMgPSBjb250ZXh0LnNuYXBQb2ludHMsXG4gICAgICAgIHdheXBvaW50cyA9IGNvbnRleHQuY29ubmVjdGlvbi53YXlwb2ludHMsXG4gICAgICAgIGJlbmRwb2ludEluZGV4ID0gY29udGV4dC5iZW5kcG9pbnRJbmRleDtcblxuICAgIGlmIChzbmFwUG9pbnRzKSB7XG4gICAgICByZXR1cm4gc25hcFBvaW50cztcbiAgICB9XG5cbiAgICB2YXIgcmVmZXJlbmNlV2F5cG9pbnRzID0gWyB3YXlwb2ludHNbYmVuZHBvaW50SW5kZXggLSAxXSwgd2F5cG9pbnRzW2JlbmRwb2ludEluZGV4ICsgMV0gXTtcblxuICAgIGNvbnRleHQuc25hcFBvaW50cyA9IHNuYXBQb2ludHMgPSB7IGhvcml6b250YWw6IFtdICwgdmVydGljYWw6IFtdIH07XG5cbiAgICBmb3JFYWNoKHJlZmVyZW5jZVdheXBvaW50cywgZnVuY3Rpb24ocCkge1xuXG4gICAgICAvLyB3ZSBzbmFwIG9uIGV4aXN0aW5nIGJlbmRwb2ludHMgb25seSxcbiAgICAgIC8vIG5vdCBwbGFjZWhvbGRlcnMgdGhhdCBhcmUgaW5zZXJ0ZWQgZHVyaW5nIGFkZFxuICAgICAgaWYgKHApIHtcbiAgICAgICAgcCA9IHAub3JpZ2luYWwgfHwgcDtcblxuICAgICAgICBzbmFwUG9pbnRzLmhvcml6b250YWwucHVzaChwLnkpO1xuICAgICAgICBzbmFwUG9pbnRzLnZlcnRpY2FsLnB1c2gocC54KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzbmFwUG9pbnRzO1xuICB9XG5cblxuICBldmVudEJ1cy5vbihbICdiZW5kcG9pbnQubW92ZS5tb3ZlJywgJ2JlbmRwb2ludC5tb3ZlLmVuZCcgXSwgMTUwMCwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgc25hcFBvaW50cyA9IGdldEJlbmRwb2ludFNuYXBzKGNvbnRleHQpLFxuICAgICAgICBob3ZlciA9IGNvbnRleHQuaG92ZXIsXG4gICAgICAgIGhvdmVyTWlkID0gaG92ZXIgJiYgbWlkKGhvdmVyKSxcbiAgICAgICAgeCA9IGV2ZW50LngsXG4gICAgICAgIHkgPSBldmVudC55LFxuICAgICAgICBzeCwgc3k7XG5cbiAgICBpZiAoIXNuYXBQb2ludHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzbmFwIHRvIGhvdmVyIG1pZFxuICAgIHN4ID0gc25hcFRvKGhvdmVyTWlkID8gc25hcFBvaW50cy52ZXJ0aWNhbC5jb25jYXQoWyBob3Zlck1pZC54IF0pIDogc25hcFBvaW50cy52ZXJ0aWNhbCwgeCk7XG4gICAgc3kgPSBzbmFwVG8oaG92ZXJNaWQgPyBzbmFwUG9pbnRzLmhvcml6b250YWwuY29uY2F0KFsgaG92ZXJNaWQueSBdKSA6IHNuYXBQb2ludHMuaG9yaXpvbnRhbCwgeSk7XG5cbiAgICAvLyBjb3JyZWN0aW9uIHgveVxuICAgIHZhciBjeCA9ICh4IC0gc3gpLFxuICAgICAgICBjeSA9ICh5IC0gc3kpO1xuXG4gICAgLy8gdXBkYXRlIGRlbHRhXG4gICAgYXNzaWduKGV2ZW50LCB7XG4gICAgICBkeDogZXZlbnQuZHggLSBjeCxcbiAgICAgIGR5OiBldmVudC5keSAtIGN5LFxuICAgICAgeDogZXZlbnQueCAtIGN4LFxuICAgICAgeTogZXZlbnQueSAtIGN5XG4gICAgfSk7XG5cbiAgICAvLyBvbmx5IHNldCBzbmFwcGVkIGlmIGFjdHVhbGx5IHNuYXBwZWRcbiAgICBpZiAoY3ggfHwgc25hcFBvaW50cy52ZXJ0aWNhbC5pbmRleE9mKHgpICE9PSAtMSkge1xuICAgICAgc2V0U25hcHBlZChldmVudCwgJ3gnLCBzeCk7XG4gICAgfVxuXG4gICAgaWYgKGN5IHx8IHNuYXBQb2ludHMuaG9yaXpvbnRhbC5pbmRleE9mKHkpICE9PSAtMSkge1xuICAgICAgc2V0U25hcHBlZChldmVudCwgJ3knLCBzeSk7XG4gICAgfVxuICB9KTtcbn1cblxuXG5CZW5kcG9pbnRTbmFwcGluZy4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnIF07IiwiaW1wb3J0IHtcbiAgdG9Qb2ludFxufSBmcm9tICcuLi8uLi91dGlsL0V2ZW50JztcblxuaW1wb3J0IHtcbiAgZ2V0TWlkUG9pbnQsXG4gIHBvaW50c0FsaWduZWRcbn0gZnJvbSAnLi4vLi4vdXRpbC9HZW9tZXRyeSc7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY2xhc3NlcyBhcyBzdmdDbGFzc2VzLFxuICBjcmVhdGUgYXMgc3ZnQ3JlYXRlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IHtcbiAgcm90YXRlLFxuICB0cmFuc2xhdGVcbn0gZnJvbSAnLi4vLi4vdXRpbC9TdmdUcmFuc2Zvcm1VdGlsJztcblxuaW1wb3J0IHtcbiAgZ2V0QXBwcm94SW50ZXJzZWN0aW9uXG59IGZyb20gJy4uLy4uL3V0aWwvTGluZUludGVyc2VjdGlvbic7XG5cbmV4cG9ydCB2YXIgQkVORFBPSU5UX0NMUyA9ICdkanMtYmVuZHBvaW50JztcbmV4cG9ydCB2YXIgU0VHTUVOVF9EUkFHR0VSX0NMUyA9ICdkanMtc2VnbWVudC1kcmFnZ2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2FudmFzQ29vcmRpbmF0ZXMoY2FudmFzLCBldmVudCkge1xuXG4gIHZhciBwb3NpdGlvbiA9IHRvUG9pbnQoZXZlbnQpLFxuICAgICAgY2xpZW50UmVjdCA9IGNhbnZhcy5fY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgb2Zmc2V0O1xuXG4gIC8vIGNhbnZhcyByZWxhdGl2ZSBwb3NpdGlvblxuXG4gIG9mZnNldCA9IHtcbiAgICB4OiBjbGllbnRSZWN0LmxlZnQsXG4gICAgeTogY2xpZW50UmVjdC50b3BcbiAgfTtcblxuICAvLyB1cGRhdGUgYWN0dWFsIGV2ZW50IHBheWxvYWQgd2l0aCBjYW52YXMgcmVsYXRpdmUgbWVhc3VyZXNcblxuICB2YXIgdmlld2JveCA9IGNhbnZhcy52aWV3Ym94KCk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB2aWV3Ym94LnggKyAocG9zaXRpb24ueCAtIG9mZnNldC54KSAvIHZpZXdib3guc2NhbGUsXG4gICAgeTogdmlld2JveC55ICsgKHBvc2l0aW9uLnkgLSBvZmZzZXQueSkgLyB2aWV3Ym94LnNjYWxlXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25uZWN0aW9uSW50ZXJzZWN0aW9uKGNhbnZhcywgd2F5cG9pbnRzLCBldmVudCkge1xuICB2YXIgbG9jYWxQb3NpdGlvbiA9IHRvQ2FudmFzQ29vcmRpbmF0ZXMoY2FudmFzLCBldmVudCksXG4gICAgICBpbnRlcnNlY3Rpb24gPSBnZXRBcHByb3hJbnRlcnNlY3Rpb24od2F5cG9pbnRzLCBsb2NhbFBvc2l0aW9uKTtcblxuICByZXR1cm4gaW50ZXJzZWN0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQmVuZHBvaW50KHBhcmVudEdmeCwgY2xzKSB7XG4gIHZhciBncm91cEdmeCA9IHN2Z0NyZWF0ZSgnZycpO1xuICBzdmdDbGFzc2VzKGdyb3VwR2Z4KS5hZGQoQkVORFBPSU5UX0NMUyk7XG5cbiAgc3ZnQXBwZW5kKHBhcmVudEdmeCwgZ3JvdXBHZngpO1xuXG4gIHZhciB2aXN1YWwgPSBzdmdDcmVhdGUoJ2NpcmNsZScpO1xuICBzdmdBdHRyKHZpc3VhbCwge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDRcbiAgfSk7XG4gIHN2Z0NsYXNzZXModmlzdWFsKS5hZGQoJ2Rqcy12aXN1YWwnKTtcblxuICBzdmdBcHBlbmQoZ3JvdXBHZngsIHZpc3VhbCk7XG5cbiAgdmFyIGhpdCA9IHN2Z0NyZWF0ZSgnY2lyY2xlJyk7XG4gIHN2Z0F0dHIoaGl0LCB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMTBcbiAgfSk7XG4gIHN2Z0NsYXNzZXMoaGl0KS5hZGQoJ2Rqcy1oaXQnKTtcblxuICBzdmdBcHBlbmQoZ3JvdXBHZngsIGhpdCk7XG5cbiAgaWYgKGNscykge1xuICAgIHN2Z0NsYXNzZXMoZ3JvdXBHZngpLmFkZChjbHMpO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwR2Z4O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXJhbGxlbERyYWdnZXIocGFyZW50R2Z4LCBzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQsIGFsaWdubWVudCkge1xuICB2YXIgZHJhZ2dlckdmeCA9IHN2Z0NyZWF0ZSgnZycpO1xuXG4gIHN2Z0FwcGVuZChwYXJlbnRHZngsIGRyYWdnZXJHZngpO1xuXG4gIHZhciB3aWR0aCA9IDE0LFxuICAgICAgaGVpZ2h0ID0gMyxcbiAgICAgIHBhZGRpbmcgPSAxMSxcbiAgICAgIGhpdFdpZHRoID0gY2FsY3VsYXRlSGl0V2lkdGgoc2VnbWVudFN0YXJ0LCBzZWdtZW50RW5kLCBhbGlnbm1lbnQpLFxuICAgICAgaGl0SGVpZ2h0ID0gaGVpZ2h0ICsgcGFkZGluZztcblxuICB2YXIgdmlzdWFsID0gc3ZnQ3JlYXRlKCdyZWN0Jyk7XG4gIHN2Z0F0dHIodmlzdWFsLCB7XG4gICAgeDogLXdpZHRoIC8gMixcbiAgICB5OiAtaGVpZ2h0IC8gMixcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfSk7XG4gIHN2Z0NsYXNzZXModmlzdWFsKS5hZGQoJ2Rqcy12aXN1YWwnKTtcblxuICBzdmdBcHBlbmQoZHJhZ2dlckdmeCwgdmlzdWFsKTtcblxuICB2YXIgaGl0ID0gc3ZnQ3JlYXRlKCdyZWN0Jyk7XG4gIHN2Z0F0dHIoaGl0LCB7XG4gICAgeDogLWhpdFdpZHRoIC8gMixcbiAgICB5OiAtaGl0SGVpZ2h0IC8gMixcbiAgICB3aWR0aDogaGl0V2lkdGgsXG4gICAgaGVpZ2h0OiBoaXRIZWlnaHRcbiAgfSk7XG4gIHN2Z0NsYXNzZXMoaGl0KS5hZGQoJ2Rqcy1oaXQnKTtcblxuICBzdmdBcHBlbmQoZHJhZ2dlckdmeCwgaGl0KTtcblxuICByb3RhdGUoZHJhZ2dlckdmeCwgYWxpZ25tZW50ID09PSAndicgPyA5MCA6IDAsIDAsIDApO1xuXG4gIHJldHVybiBkcmFnZ2VyR2Z4O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRTZWdtZW50RHJhZ2dlcihwYXJlbnRHZngsIHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCkge1xuXG4gIHZhciBncm91cEdmeCA9IHN2Z0NyZWF0ZSgnZycpLFxuICAgICAgbWlkID0gZ2V0TWlkUG9pbnQoc2VnbWVudFN0YXJ0LCBzZWdtZW50RW5kKSxcbiAgICAgIGFsaWdubWVudCA9IHBvaW50c0FsaWduZWQoc2VnbWVudFN0YXJ0LCBzZWdtZW50RW5kKTtcblxuICBzdmdBcHBlbmQocGFyZW50R2Z4LCBncm91cEdmeCk7XG5cbiAgY3JlYXRlUGFyYWxsZWxEcmFnZ2VyKGdyb3VwR2Z4LCBzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQsIGFsaWdubWVudCk7XG5cbiAgc3ZnQ2xhc3Nlcyhncm91cEdmeCkuYWRkKFNFR01FTlRfRFJBR0dFUl9DTFMpO1xuICBzdmdDbGFzc2VzKGdyb3VwR2Z4KS5hZGQoYWxpZ25tZW50ID09PSAnaCcgPyAnaG9yaXpvbnRhbCcgOiAndmVydGljYWwnKTtcblxuICB0cmFuc2xhdGUoZ3JvdXBHZngsIG1pZC54LCBtaWQueSk7XG5cbiAgcmV0dXJuIGdyb3VwR2Z4O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgcmVnaW9uIGZvciBzZWdtZW50IG1vdmUgd2hpY2ggaXMgMi8zIG9mIHRoZSBmdWxsIHNlZ21lbnQgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudExlbmd0aFxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVNlZ21lbnRNb3ZlUmVnaW9uKHNlZ21lbnRMZW5ndGgpIHtcbiAgcmV0dXJuIE1hdGguYWJzKE1hdGgucm91bmQoc2VnbWVudExlbmd0aCAqIDIgLyAzKSk7XG59XG5cbi8vIGhlbHBlciAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUhpdFdpZHRoKHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCwgYWxpZ25tZW50KSB7XG4gIHZhciBzZWdtZW50TGVuZ3RoWEF4aXMgPSBzZWdtZW50RW5kLnggLSBzZWdtZW50U3RhcnQueCxcbiAgICAgIHNlZ21lbnRMZW5ndGhZQXhpcyA9IHNlZ21lbnRFbmQueSAtIHNlZ21lbnRTdGFydC55O1xuXG4gIHJldHVybiBhbGlnbm1lbnQgPT09ICdoJyA/XG4gICAgY2FsY3VsYXRlU2VnbWVudE1vdmVSZWdpb24oc2VnbWVudExlbmd0aFhBeGlzKSA6XG4gICAgY2FsY3VsYXRlU2VnbWVudE1vdmVSZWdpb24oc2VnbWVudExlbmd0aFlBeGlzKTtcbn1cbiIsImltcG9ydCB7IGZvckVhY2ggfSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGV2ZW50IGFzIGRvbUV2ZW50LFxuICBxdWVyeSBhcyBkb21RdWVyeSxcbiAgcXVlcnlBbGwgYXMgZG9tUXVlcnlBbGxcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIEJFTkRQT0lOVF9DTFMsXG4gIFNFR01FTlRfRFJBR0dFUl9DTFMsXG4gIGFkZEJlbmRwb2ludCxcbiAgYWRkU2VnbWVudERyYWdnZXIsXG4gIGNhbGN1bGF0ZVNlZ21lbnRNb3ZlUmVnaW9uLFxuICBnZXRDb25uZWN0aW9uSW50ZXJzZWN0aW9uXG59IGZyb20gJy4vQmVuZHBvaW50VXRpbCc7XG5cbmltcG9ydCB7XG4gIGVzY2FwZUNTU1xufSBmcm9tICcuLi8uLi91dGlsL0VzY2FwZVV0aWwnO1xuXG5pbXBvcnQge1xuICBwb2ludHNBbGlnbmVkLFxuICBnZXRNaWRQb2ludFxufSBmcm9tICcuLi8uLi91dGlsL0dlb21ldHJ5JztcblxuaW1wb3J0IHtcbiAgaXNQcmltYXJ5QnV0dG9uXG59IGZyb20gJy4uLy4uL3V0aWwvTW91c2UnO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNsYXNzZXMgYXMgc3ZnQ2xhc3NlcyxcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZSxcbiAgcmVtb3ZlIGFzIHN2Z1JlbW92ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7XG4gIHRyYW5zbGF0ZVxufSBmcm9tICcuLi8uLi91dGlsL1N2Z1RyYW5zZm9ybVV0aWwnO1xuXG5cbi8qKlxuICogQSBzZXJ2aWNlIHRoYXQgYWRkcyBlZGl0YWJsZSBiZW5kcG9pbnRzIHRvIGNvbm5lY3Rpb25zLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCZW5kcG9pbnRzKFxuICAgIGV2ZW50QnVzLCBjYW52YXMsIGludGVyYWN0aW9uRXZlbnRzLFxuICAgIGJlbmRwb2ludE1vdmUsIGNvbm5lY3Rpb25TZWdtZW50TW92ZSkge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgaW50ZXJzZWN0aW9uIHBvaW50IGlzIGluc2lkZSBtaWRkbGUgcmVnaW9uIG9mIHNlZ21lbnQsIGFkanVzdGVkIGJ5XG4gICAqIG9wdGlvbmFsIHRocmVzaG9sZFxuICAgKi9cbiAgZnVuY3Rpb24gaXNJbnRlcnNlY3Rpb25NaWRkbGUoaW50ZXJzZWN0aW9uLCB3YXlwb2ludHMsIHRyZXNob2xkKSB7XG4gICAgdmFyIGlkeCA9IGludGVyc2VjdGlvbi5pbmRleCxcbiAgICAgICAgcCA9IGludGVyc2VjdGlvbi5wb2ludCxcbiAgICAgICAgcDAsIHAxLCBtaWQsIGFsaWduZWQsIHhEZWx0YSwgeURlbHRhO1xuXG4gICAgaWYgKGlkeCA8PSAwIHx8IGludGVyc2VjdGlvbi5iZW5kcG9pbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwMCA9IHdheXBvaW50c1tpZHggLSAxXTtcbiAgICBwMSA9IHdheXBvaW50c1tpZHhdO1xuICAgIG1pZCA9IGdldE1pZFBvaW50KHAwLCBwMSksXG4gICAgYWxpZ25lZCA9IHBvaW50c0FsaWduZWQocDAsIHAxKTtcbiAgICB4RGVsdGEgPSBNYXRoLmFicyhwLnggLSBtaWQueCk7XG4gICAgeURlbHRhID0gTWF0aC5hYnMocC55IC0gbWlkLnkpO1xuXG4gICAgcmV0dXJuIGFsaWduZWQgJiYgeERlbHRhIDw9IHRyZXNob2xkICYmIHlEZWx0YSA8PSB0cmVzaG9sZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSB0aHJlc2hvbGQgZnJvbSBhIGNvbm5lY3Rpb24ncyBtaWRkbGUgd2hpY2ggZml0cyB0aGUgdHdvLXRoaXJkLXJlZ2lvblxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY3VsYXRlSW50ZXJzZWN0aW9uVGhyZXNob2xkKGNvbm5lY3Rpb24sIGludGVyc2VjdGlvbikge1xuICAgIHZhciB3YXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cyxcbiAgICAgICAgcmVsZXZhbnRTZWdtZW50LCBhbGlnbm1lbnQsIHNlZ21lbnRMZW5ndGgsIHRocmVzaG9sZDtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24uaW5kZXggPD0gMCB8fCBpbnRlcnNlY3Rpb24uYmVuZHBvaW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzZWdtZW50IHJlbGF0aXZlIHRvIGNvbm5lY3Rpb24gaW50ZXJzZWN0aW9uXG4gICAgcmVsZXZhbnRTZWdtZW50ID0ge1xuICAgICAgc3RhcnQ6IHdheXBvaW50c1tpbnRlcnNlY3Rpb24uaW5kZXggLSAxXSxcbiAgICAgIGVuZDogd2F5cG9pbnRzW2ludGVyc2VjdGlvbi5pbmRleF1cbiAgICB9O1xuXG4gICAgYWxpZ25tZW50ID0gcG9pbnRzQWxpZ25lZChyZWxldmFudFNlZ21lbnQuc3RhcnQsIHJlbGV2YW50U2VnbWVudC5lbmQpO1xuXG4gICAgaWYgKCFhbGlnbm1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChhbGlnbm1lbnQgPT09ICdoJykge1xuICAgICAgc2VnbWVudExlbmd0aCA9IHJlbGV2YW50U2VnbWVudC5lbmQueCAtIHJlbGV2YW50U2VnbWVudC5zdGFydC54O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWdtZW50TGVuZ3RoID0gcmVsZXZhbnRTZWdtZW50LmVuZC55IC0gcmVsZXZhbnRTZWdtZW50LnN0YXJ0Lnk7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRocmVzaG9sZCByZWxhdGl2ZSB0byAyLzMgb2Ygc2VnbWVudCBsZW5ndGhcbiAgICB0aHJlc2hvbGQgPSBjYWxjdWxhdGVTZWdtZW50TW92ZVJlZ2lvbihzZWdtZW50TGVuZ3RoKSAvIDI7XG5cbiAgICByZXR1cm4gdGhyZXNob2xkO1xuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZhdGVCZW5kcG9pbnRNb3ZlKGV2ZW50LCBjb25uZWN0aW9uKSB7XG4gICAgdmFyIHdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzLFxuICAgICAgICBpbnRlcnNlY3Rpb24gPSBnZXRDb25uZWN0aW9uSW50ZXJzZWN0aW9uKGNhbnZhcywgd2F5cG9pbnRzLCBldmVudCksXG4gICAgICAgIHRocmVzaG9sZDtcblxuICAgIGlmICghaW50ZXJzZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyZXNob2xkID0gY2FsY3VsYXRlSW50ZXJzZWN0aW9uVGhyZXNob2xkKGNvbm5lY3Rpb24sIGludGVyc2VjdGlvbik7XG5cbiAgICBpZiAoaXNJbnRlcnNlY3Rpb25NaWRkbGUoaW50ZXJzZWN0aW9uLCB3YXlwb2ludHMsIHRocmVzaG9sZCkpIHtcbiAgICAgIGNvbm5lY3Rpb25TZWdtZW50TW92ZS5zdGFydChldmVudCwgY29ubmVjdGlvbiwgaW50ZXJzZWN0aW9uLmluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmVuZHBvaW50TW92ZS5zdGFydChldmVudCwgY29ubmVjdGlvbiwgaW50ZXJzZWN0aW9uLmluZGV4LCAhaW50ZXJzZWN0aW9uLmJlbmRwb2ludCk7XG4gICAgfVxuXG4gICAgLy8gd2UndmUgaGFuZGxlZCB0aGUgZXZlbnRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmRJbnRlcmFjdGlvbkV2ZW50cyhub2RlLCBldmVudE5hbWUsIGVsZW1lbnQpIHtcblxuICAgIGRvbUV2ZW50LmJpbmQobm9kZSwgZXZlbnROYW1lLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgaW50ZXJhY3Rpb25FdmVudHMudHJpZ2dlck1vdXNlRXZlbnQoZXZlbnROYW1lLCBldmVudCwgZWxlbWVudCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJlbmRwb2ludHNDb250YWluZXIoZWxlbWVudCwgY3JlYXRlKSB7XG5cbiAgICB2YXIgbGF5ZXIgPSBjYW52YXMuZ2V0TGF5ZXIoJ292ZXJsYXlzJyksXG4gICAgICAgIGdmeCA9IGRvbVF1ZXJ5KCcuZGpzLWJlbmRwb2ludHNbZGF0YS1lbGVtZW50LWlkPVwiJyArIGVzY2FwZUNTUyhlbGVtZW50LmlkKSArICdcIl0nLCBsYXllcik7XG5cbiAgICBpZiAoIWdmeCAmJiBjcmVhdGUpIHtcbiAgICAgIGdmeCA9IHN2Z0NyZWF0ZSgnZycpO1xuICAgICAgc3ZnQXR0cihnZngsIHsgJ2RhdGEtZWxlbWVudC1pZCc6IGVsZW1lbnQuaWQgfSk7XG4gICAgICBzdmdDbGFzc2VzKGdmeCkuYWRkKCdkanMtYmVuZHBvaW50cycpO1xuXG4gICAgICBzdmdBcHBlbmQobGF5ZXIsIGdmeCk7XG5cbiAgICAgIGJpbmRJbnRlcmFjdGlvbkV2ZW50cyhnZngsICdtb3VzZWRvd24nLCBlbGVtZW50KTtcbiAgICAgIGJpbmRJbnRlcmFjdGlvbkV2ZW50cyhnZngsICdjbGljaycsIGVsZW1lbnQpO1xuICAgICAgYmluZEludGVyYWN0aW9uRXZlbnRzKGdmeCwgJ2RibGNsaWNrJywgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdmeDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlZ21lbnREcmFnZ2VyKGlkeCwgcGFyZW50R2Z4KSB7XG4gICAgcmV0dXJuIGRvbVF1ZXJ5KFxuICAgICAgJy5kanMtc2VnbWVudC1kcmFnZ2VyW2RhdGEtc2VnbWVudC1pZHg9XCInICsgaWR4ICsgJ1wiXScsXG4gICAgICBwYXJlbnRHZnhcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQmVuZHBvaW50cyhnZngsIGNvbm5lY3Rpb24pIHtcbiAgICBjb25uZWN0aW9uLndheXBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKHAsIGlkeCkge1xuICAgICAgdmFyIGJlbmRwb2ludCA9IGFkZEJlbmRwb2ludChnZngpO1xuXG4gICAgICBzdmdBcHBlbmQoZ2Z4LCBiZW5kcG9pbnQpO1xuXG4gICAgICB0cmFuc2xhdGUoYmVuZHBvaW50LCBwLngsIHAueSk7XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgZmxvYXRpbmcgYmVuZHBvaW50XG4gICAgYWRkQmVuZHBvaW50KGdmeCwgJ2Zsb2F0aW5nJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTZWdtZW50RHJhZ2dlcnMoZ2Z4LCBjb25uZWN0aW9uKSB7XG5cbiAgICB2YXIgd2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHM7XG5cbiAgICB2YXIgc2VnbWVudFN0YXJ0LFxuICAgICAgICBzZWdtZW50RW5kLFxuICAgICAgICBzZWdtZW50RHJhZ2dlckdmeDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgd2F5cG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIHNlZ21lbnRTdGFydCA9IHdheXBvaW50c1tpIC0gMV07XG4gICAgICBzZWdtZW50RW5kID0gd2F5cG9pbnRzW2ldO1xuXG4gICAgICBpZiAocG9pbnRzQWxpZ25lZChzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQpKSB7XG4gICAgICAgIHNlZ21lbnREcmFnZ2VyR2Z4ID0gYWRkU2VnbWVudERyYWdnZXIoZ2Z4LCBzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQpO1xuXG4gICAgICAgIHN2Z0F0dHIoc2VnbWVudERyYWdnZXJHZngsIHsgJ2RhdGEtc2VnbWVudC1pZHgnOiBpIH0pO1xuXG4gICAgICAgIGJpbmRJbnRlcmFjdGlvbkV2ZW50cyhzZWdtZW50RHJhZ2dlckdmeCwgJ21vdXNlbW92ZScsIGNvbm5lY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyQmVuZHBvaW50cyhnZngpIHtcbiAgICBmb3JFYWNoKGRvbVF1ZXJ5QWxsKCcuJyArIEJFTkRQT0lOVF9DTFMsIGdmeCksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHN2Z1JlbW92ZShub2RlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyU2VnbWVudERyYWdnZXJzKGdmeCkge1xuICAgIGZvckVhY2goZG9tUXVlcnlBbGwoJy4nICsgU0VHTUVOVF9EUkFHR0VSX0NMUywgZ2Z4KSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgc3ZnUmVtb3ZlKG5vZGUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkSGFuZGxlcyhjb25uZWN0aW9uKSB7XG5cbiAgICB2YXIgZ2Z4ID0gZ2V0QmVuZHBvaW50c0NvbnRhaW5lcihjb25uZWN0aW9uKTtcblxuICAgIGlmICghZ2Z4KSB7XG4gICAgICBnZnggPSBnZXRCZW5kcG9pbnRzQ29udGFpbmVyKGNvbm5lY3Rpb24sIHRydWUpO1xuXG4gICAgICBjcmVhdGVCZW5kcG9pbnRzKGdmeCwgY29ubmVjdGlvbik7XG4gICAgICBjcmVhdGVTZWdtZW50RHJhZ2dlcnMoZ2Z4LCBjb25uZWN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2Z4O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSGFuZGxlcyhjb25uZWN0aW9uKSB7XG5cbiAgICB2YXIgZ2Z4ID0gZ2V0QmVuZHBvaW50c0NvbnRhaW5lcihjb25uZWN0aW9uKTtcblxuICAgIGlmIChnZngpIHtcbiAgICAgIGNsZWFyU2VnbWVudERyYWdnZXJzKGdmeCk7XG4gICAgICBjbGVhckJlbmRwb2ludHMoZ2Z4KTtcbiAgICAgIGNyZWF0ZVNlZ21lbnREcmFnZ2VycyhnZngsIGNvbm5lY3Rpb24pO1xuICAgICAgY3JlYXRlQmVuZHBvaW50cyhnZngsIGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZsb2F0aW5nQmVuZHBvaW50UG9zaXRpb24ocGFyZW50R2Z4LCBpbnRlcnNlY3Rpb24pIHtcbiAgICB2YXIgZmxvYXRpbmcgPSBkb21RdWVyeSgnLmZsb2F0aW5nJywgcGFyZW50R2Z4KSxcbiAgICAgICAgcG9pbnQgPSBpbnRlcnNlY3Rpb24ucG9pbnQ7XG5cbiAgICBpZiAoIWZsb2F0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJhbnNsYXRlKGZsb2F0aW5nLCBwb2ludC54LCBwb2ludC55KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VnbWVudERyYWdnZXJQb3NpdGlvbihwYXJlbnRHZngsIGludGVyc2VjdGlvbiwgd2F5cG9pbnRzKSB7XG5cbiAgICB2YXIgZHJhZ2dlckdmeCA9IGdldFNlZ21lbnREcmFnZ2VyKGludGVyc2VjdGlvbi5pbmRleCwgcGFyZW50R2Z4KSxcbiAgICAgICAgc2VnbWVudFN0YXJ0ID0gd2F5cG9pbnRzW2ludGVyc2VjdGlvbi5pbmRleCAtIDFdLFxuICAgICAgICBzZWdtZW50RW5kID0gd2F5cG9pbnRzW2ludGVyc2VjdGlvbi5pbmRleF0sXG4gICAgICAgIHBvaW50ID0gaW50ZXJzZWN0aW9uLnBvaW50LFxuICAgICAgICBtaWQgPSBnZXRNaWRQb2ludChzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQpLFxuICAgICAgICBhbGlnbm1lbnQgPSBwb2ludHNBbGlnbmVkKHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCksXG4gICAgICAgIGRyYWdnZXJWaXN1YWwsIHJlbGF0aXZlUG9zaXRpb247XG5cbiAgICBpZiAoIWRyYWdnZXJHZngpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkcmFnZ2VyVmlzdWFsID0gZ2V0RHJhZ2dlclZpc3VhbChkcmFnZ2VyR2Z4KTtcblxuICAgIHJlbGF0aXZlUG9zaXRpb24gPSB7XG4gICAgICB4OiBwb2ludC54IC0gbWlkLngsXG4gICAgICB5OiBwb2ludC55IC0gbWlkLnlcbiAgICB9O1xuXG4gICAgaWYgKGFsaWdubWVudCA9PT0gJ3YnKSB7XG5cbiAgICAgIC8vIHJvdGF0ZSBwb3NpdGlvblxuICAgICAgcmVsYXRpdmVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogcmVsYXRpdmVQb3NpdGlvbi55LFxuICAgICAgICB5OiByZWxhdGl2ZVBvc2l0aW9uLnhcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdHJhbnNsYXRlKGRyYWdnZXJWaXN1YWwsIHJlbGF0aXZlUG9zaXRpb24ueCwgcmVsYXRpdmVQb3NpdGlvbi55KTtcbiAgfVxuXG4gIGV2ZW50QnVzLm9uKCdjb25uZWN0aW9uLmNoYW5nZWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHVwZGF0ZUhhbmRsZXMoZXZlbnQuZWxlbWVudCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjb25uZWN0aW9uLnJlbW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGdmeCA9IGdldEJlbmRwb2ludHNDb250YWluZXIoZXZlbnQuZWxlbWVudCk7XG5cbiAgICBpZiAoZ2Z4KSB7XG4gICAgICBzdmdSZW1vdmUoZ2Z4KTtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm1hcmtlci51cGRhdGUnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC5lbGVtZW50LFxuICAgICAgICBiZW5kcG9pbnRzR2Z4O1xuXG4gICAgaWYgKCFlbGVtZW50LndheXBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJlbmRwb2ludHNHZnggPSBhZGRIYW5kbGVzKGVsZW1lbnQpO1xuXG4gICAgaWYgKGV2ZW50LmFkZCkge1xuICAgICAgc3ZnQ2xhc3NlcyhiZW5kcG9pbnRzR2Z4KS5hZGQoZXZlbnQubWFya2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ZnQ2xhc3NlcyhiZW5kcG9pbnRzR2Z4KS5yZW1vdmUoZXZlbnQubWFya2VyKTtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm1vdXNlbW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQsXG4gICAgICAgIHdheXBvaW50cyA9IGVsZW1lbnQud2F5cG9pbnRzLFxuICAgICAgICBiZW5kcG9pbnRzR2Z4LFxuICAgICAgICBpbnRlcnNlY3Rpb247XG5cbiAgICBpZiAod2F5cG9pbnRzKSB7XG4gICAgICBiZW5kcG9pbnRzR2Z4ID0gZ2V0QmVuZHBvaW50c0NvbnRhaW5lcihlbGVtZW50LCB0cnVlKTtcblxuICAgICAgaW50ZXJzZWN0aW9uID0gZ2V0Q29ubmVjdGlvbkludGVyc2VjdGlvbihjYW52YXMsIHdheXBvaW50cywgZXZlbnQub3JpZ2luYWxFdmVudCk7XG5cbiAgICAgIGlmICghaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlRmxvYXRpbmdCZW5kcG9pbnRQb3NpdGlvbihiZW5kcG9pbnRzR2Z4LCBpbnRlcnNlY3Rpb24pO1xuXG4gICAgICBpZiAoIWludGVyc2VjdGlvbi5iZW5kcG9pbnQpIHtcbiAgICAgICAgdXBkYXRlU2VnbWVudERyYWdnZXJQb3NpdGlvbihiZW5kcG9pbnRzR2Z4LCBpbnRlcnNlY3Rpb24sIHdheXBvaW50cyk7XG4gICAgICB9XG5cbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm1vdXNlZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICBpZiAoIWlzUHJpbWFyeUJ1dHRvbihldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQsXG4gICAgICAgIGVsZW1lbnQgPSBldmVudC5lbGVtZW50O1xuXG4gICAgaWYgKCFlbGVtZW50LndheXBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBhY3RpdmF0ZUJlbmRwb2ludE1vdmUob3JpZ2luYWxFdmVudCwgZWxlbWVudCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdzZWxlY3Rpb24uY2hhbmdlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIG5ld1NlbGVjdGlvbiA9IGV2ZW50Lm5ld1NlbGVjdGlvbixcbiAgICAgICAgcHJpbWFyeSA9IG5ld1NlbGVjdGlvblswXTtcblxuICAgIGlmIChwcmltYXJ5ICYmIHByaW1hcnkud2F5cG9pbnRzKSB7XG4gICAgICBhZGRIYW5kbGVzKHByaW1hcnkpO1xuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2VsZW1lbnQuaG92ZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudDtcblxuICAgIGlmIChlbGVtZW50LndheXBvaW50cykge1xuICAgICAgYWRkSGFuZGxlcyhlbGVtZW50KTtcbiAgICAgIGludGVyYWN0aW9uRXZlbnRzLnJlZ2lzdGVyRXZlbnQoZXZlbnQuZ2Z4LCAnbW91c2Vtb3ZlJywgJ2VsZW1lbnQubW91c2Vtb3ZlJyk7XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbignZWxlbWVudC5vdXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIGludGVyYWN0aW9uRXZlbnRzLnVucmVnaXN0ZXJFdmVudChldmVudC5nZngsICdtb3VzZW1vdmUnLCAnZWxlbWVudC5tb3VzZW1vdmUnKTtcbiAgfSk7XG5cbiAgLy8gdXBkYXRlIGJlbmRwb2ludCBjb250YWluZXIgZGF0YSBhdHRyaWJ1dGUgb24gZWxlbWVudCBJRCBjaGFuZ2VcbiAgZXZlbnRCdXMub24oJ2VsZW1lbnQudXBkYXRlSWQnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0LmVsZW1lbnQsXG4gICAgICAgIG5ld0lkID0gY29udGV4dC5uZXdJZDtcblxuICAgIGlmIChlbGVtZW50LndheXBvaW50cykge1xuICAgICAgdmFyIGJlbmRwb2ludENvbnRhaW5lciA9IGdldEJlbmRwb2ludHNDb250YWluZXIoZWxlbWVudCk7XG5cbiAgICAgIGlmIChiZW5kcG9pbnRDb250YWluZXIpIHtcbiAgICAgICAgc3ZnQXR0cihiZW5kcG9pbnRDb250YWluZXIsIHsgJ2RhdGEtZWxlbWVudC1pZCc6IG5ld0lkIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gQVBJXG5cbiAgdGhpcy5hZGRIYW5kbGVzID0gYWRkSGFuZGxlcztcbiAgdGhpcy51cGRhdGVIYW5kbGVzID0gdXBkYXRlSGFuZGxlcztcbiAgdGhpcy5nZXRCZW5kcG9pbnRzQ29udGFpbmVyID0gZ2V0QmVuZHBvaW50c0NvbnRhaW5lcjtcbiAgdGhpcy5nZXRTZWdtZW50RHJhZ2dlciA9IGdldFNlZ21lbnREcmFnZ2VyO1xufVxuXG5CZW5kcG9pbnRzLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnaW50ZXJhY3Rpb25FdmVudHMnLFxuICAnYmVuZHBvaW50TW92ZScsXG4gICdjb25uZWN0aW9uU2VnbWVudE1vdmUnXG5dO1xuXG5cblxuLy8gaGVscGVyIC8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gZ2V0RHJhZ2dlclZpc3VhbChkcmFnZ2VyR2Z4KSB7XG4gIHJldHVybiBkb21RdWVyeSgnLmRqcy12aXN1YWwnLCBkcmFnZ2VyR2Z4KTtcbn0iLCJpbXBvcnQge1xuICBwb2ludHNBbGlnbmVkLFxuICBwb2ludHNPbkxpbmVcbn0gZnJvbSAnLi4vLi4vdXRpbC9HZW9tZXRyeSc7XG5cbmltcG9ydCB7XG4gIGFkZFNlZ21lbnREcmFnZ2VyLFxuICBnZXRDb25uZWN0aW9uSW50ZXJzZWN0aW9uXG59IGZyb20gJy4vQmVuZHBvaW50VXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldE1pZCxcbiAgZ2V0T3JpZW50YXRpb25cbn0gZnJvbSAnLi4vLi4vbGF5b3V0L0xheW91dFV0aWwnO1xuXG52YXIgTUFSS0VSX0NPTk5FQ1RfSE9WRVIgPSAnY29ubmVjdC1ob3ZlcicsXG4gICAgTUFSS0VSX0NPTk5FQ1RfVVBEQVRJTkcgPSAnZGpzLXVwZGF0aW5nJztcblxuaW1wb3J0IHtcbiAgY2xhc3NlcyBhcyBzdmdDbGFzc2VzLFxuICByZW1vdmUgYXMgc3ZnUmVtb3ZlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IHtcbiAgdHJhbnNsYXRlXG59IGZyb20gJy4uLy4uL3V0aWwvU3ZnVHJhbnNmb3JtVXRpbCc7XG5cblxuZnVuY3Rpb24gYXhpc0FkZChwb2ludCwgYXhpcywgZGVsdGEpIHtcbiAgcmV0dXJuIGF4aXNTZXQocG9pbnQsIGF4aXMsIHBvaW50W2F4aXNdICsgZGVsdGEpO1xufVxuXG5mdW5jdGlvbiBheGlzU2V0KHBvaW50LCBheGlzLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHg6IChheGlzID09PSAneCcgPyB2YWx1ZSA6IHBvaW50LngpLFxuICAgIHk6IChheGlzID09PSAneScgPyB2YWx1ZSA6IHBvaW50LnkpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGF4aXNGZW5jZWQocG9zaXRpb24sIHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCwgYXhpcykge1xuXG4gIHZhciBtYXhWYWx1ZSA9IE1hdGgubWF4KHNlZ21lbnRTdGFydFtheGlzXSwgc2VnbWVudEVuZFtheGlzXSksXG4gICAgICBtaW5WYWx1ZSA9IE1hdGgubWluKHNlZ21lbnRTdGFydFtheGlzXSwgc2VnbWVudEVuZFtheGlzXSk7XG5cbiAgdmFyIHBhZGRpbmcgPSAyMDtcblxuICB2YXIgZmVuY2VkVmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heChtaW5WYWx1ZSArIHBhZGRpbmcsIHBvc2l0aW9uW2F4aXNdKSwgbWF4VmFsdWUgLSBwYWRkaW5nKTtcblxuICByZXR1cm4gYXhpc1NldChzZWdtZW50U3RhcnQsIGF4aXMsIGZlbmNlZFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZmxpcEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZG9ja2luZyBwb2ludCBvbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBDb21wdXRlIGEgcmVhc29uYWJsZSBkb2NraW5nLCBpZiBub24gZXhpc3RzLlxuICpcbiAqIEBwYXJhbSAge1BvaW50fSBwb2ludFxuICogQHBhcmFtICB7ZGpzLm1vZGVsLlNoYXBlfSByZWZlcmVuY2VFbGVtZW50XG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1vdmVBeGlzICh4fHkpXG4gKlxuICogQHJldHVybiB7UG9pbnR9XG4gKi9cbmZ1bmN0aW9uIGdldERvY2tpbmcocG9pbnQsIHJlZmVyZW5jZUVsZW1lbnQsIG1vdmVBeGlzKSB7XG5cbiAgdmFyIHJlZmVyZW5jZU1pZCxcbiAgICAgIGludmVyc2VBeGlzO1xuXG4gIGlmIChwb2ludC5vcmlnaW5hbCkge1xuICAgIHJldHVybiBwb2ludC5vcmlnaW5hbDtcbiAgfSBlbHNlIHtcbiAgICByZWZlcmVuY2VNaWQgPSBnZXRNaWQocmVmZXJlbmNlRWxlbWVudCk7XG4gICAgaW52ZXJzZUF4aXMgPSBmbGlwQXhpcyhtb3ZlQXhpcyk7XG5cbiAgICByZXR1cm4gYXhpc1NldChwb2ludCwgaW52ZXJzZUF4aXMsIHJlZmVyZW5jZU1pZFtpbnZlcnNlQXhpc10pO1xuICB9XG59XG5cbi8qKlxuICogQSBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIG1vdmluZyBvZiBiZW5kcG9pbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbm5lY3Rpb25TZWdtZW50TW92ZShcbiAgICBpbmplY3RvciwgZXZlbnRCdXMsIGNhbnZhcyxcbiAgICBkcmFnZ2luZywgZ3JhcGhpY3NGYWN0b3J5LCBtb2RlbGluZykge1xuXG4gIC8vIG9wdGlvbmFsIGNvbm5lY3Rpb24gZG9ja2luZyBpbnRlZ3JhdGlvblxuICB2YXIgY29ubmVjdGlvbkRvY2tpbmcgPSBpbmplY3Rvci5nZXQoJ2Nvbm5lY3Rpb25Eb2NraW5nJywgZmFsc2UpO1xuXG5cbiAgLy8gQVBJXG5cbiAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKGV2ZW50LCBjb25uZWN0aW9uLCBpZHgpIHtcblxuICAgIHZhciBjb250ZXh0LFxuICAgICAgICBnZnggPSBjYW52YXMuZ2V0R3JhcGhpY3MoY29ubmVjdGlvbiksXG4gICAgICAgIHNlZ21lbnRTdGFydEluZGV4ID0gaWR4IC0gMSxcbiAgICAgICAgc2VnbWVudEVuZEluZGV4ID0gaWR4LFxuICAgICAgICB3YXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cyxcbiAgICAgICAgc2VnbWVudFN0YXJ0ID0gd2F5cG9pbnRzW3NlZ21lbnRTdGFydEluZGV4XSxcbiAgICAgICAgc2VnbWVudEVuZCA9IHdheXBvaW50c1tzZWdtZW50RW5kSW5kZXhdLFxuICAgICAgICBpbnRlcnNlY3Rpb24gPSBnZXRDb25uZWN0aW9uSW50ZXJzZWN0aW9uKGNhbnZhcywgd2F5cG9pbnRzLCBldmVudCksXG4gICAgICAgIGRpcmVjdGlvbiwgYXhpcywgZHJhZ1Bvc2l0aW9uO1xuXG4gICAgZGlyZWN0aW9uID0gcG9pbnRzQWxpZ25lZChzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQpO1xuXG4gICAgLy8gZG8gbm90IG1vdmUgZGlhZ29uYWwgY29ubmVjdGlvblxuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdGhlIGF4aXMgd2hlcmUgd2UgYXJlIGdvaW5nIHRvIG1vdmUgdGhpbmdzXG4gICAgYXhpcyA9IGRpcmVjdGlvbiA9PT0gJ3YnID8gJ3gnIDogJ3knO1xuXG4gICAgaWYgKHNlZ21lbnRTdGFydEluZGV4ID09PSAwKSB7XG4gICAgICBzZWdtZW50U3RhcnQgPSBnZXREb2NraW5nKHNlZ21lbnRTdGFydCwgY29ubmVjdGlvbi5zb3VyY2UsIGF4aXMpO1xuICAgIH1cblxuICAgIGlmIChzZWdtZW50RW5kSW5kZXggPT09IHdheXBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICBzZWdtZW50RW5kID0gZ2V0RG9ja2luZyhzZWdtZW50RW5kLCBjb25uZWN0aW9uLnRhcmdldCwgYXhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgZHJhZ1Bvc2l0aW9uID0gaW50ZXJzZWN0aW9uLnBvaW50O1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIHNldCB0byBzZWdtZW50IGNlbnRlciBhcyBkZWZhdWx0XG4gICAgICBkcmFnUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IChzZWdtZW50U3RhcnQueCArIHNlZ21lbnRFbmQueCkgLyAyLFxuICAgICAgICB5OiAoc2VnbWVudFN0YXJ0LnkgKyBzZWdtZW50RW5kLnkpIC8gMlxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb250ZXh0ID0ge1xuICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgIHNlZ21lbnRTdGFydEluZGV4OiBzZWdtZW50U3RhcnRJbmRleCxcbiAgICAgIHNlZ21lbnRFbmRJbmRleDogc2VnbWVudEVuZEluZGV4LFxuICAgICAgc2VnbWVudFN0YXJ0OiBzZWdtZW50U3RhcnQsXG4gICAgICBzZWdtZW50RW5kOiBzZWdtZW50RW5kLFxuICAgICAgYXhpczogYXhpcyxcbiAgICAgIGRyYWdQb3NpdGlvbjogZHJhZ1Bvc2l0aW9uXG4gICAgfTtcblxuICAgIGRyYWdnaW5nLmluaXQoZXZlbnQsIGRyYWdQb3NpdGlvbiwgJ2Nvbm5lY3Rpb25TZWdtZW50Lm1vdmUnLCB7XG4gICAgICBjdXJzb3I6IGF4aXMgPT09ICd4JyA/ICdyZXNpemUtZXcnIDogJ3Jlc2l6ZS1ucycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgICAgIGNvbm5lY3Rpb25HZng6IGdmeCxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcm9wIGNvbm5lY3Rpb24gaWYgY29ubmVjdGlvbiBjcm9wcGluZyBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBuZXdXYXlwb2ludHNcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8UG9pbnQ+fSBjcm9wcGVkIGNvbm5lY3Rpb24gd2F5cG9pbnRzXG4gICAqL1xuICBmdW5jdGlvbiBjcm9wQ29ubmVjdGlvbihjb25uZWN0aW9uLCBuZXdXYXlwb2ludHMpIHtcblxuICAgIC8vIGNyb3AgY29ubmVjdGlvbiwgaWYgZG9ja2luZyBzZXJ2aWNlIGlzIHByb3ZpZGVkIG9ubHlcbiAgICBpZiAoIWNvbm5lY3Rpb25Eb2NraW5nKSB7XG4gICAgICByZXR1cm4gbmV3V2F5cG9pbnRzO1xuICAgIH1cblxuICAgIHZhciBvbGRXYXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cyxcbiAgICAgICAgY3JvcHBlZFdheXBvaW50cztcblxuICAgIC8vIHRlbXBvcmFyeSBzZXQgbmV3IHdheXBvaW50c1xuICAgIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gbmV3V2F5cG9pbnRzO1xuXG4gICAgY3JvcHBlZFdheXBvaW50cyA9IGNvbm5lY3Rpb25Eb2NraW5nLmdldENyb3BwZWRXYXlwb2ludHMoY29ubmVjdGlvbik7XG5cbiAgICAvLyByZXN0b3JlIG9sZCB3YXlwb2ludHNcbiAgICBjb25uZWN0aW9uLndheXBvaW50cyA9IG9sZFdheXBvaW50cztcblxuICAgIHJldHVybiBjcm9wcGVkV2F5cG9pbnRzO1xuICB9XG5cbiAgLy8gRFJBR0dJTkcgSU1QTEVNRU5UQVRJT05cblxuICBmdW5jdGlvbiByZWRyYXdDb25uZWN0aW9uKGRhdGEpIHtcbiAgICBncmFwaGljc0ZhY3RvcnkudXBkYXRlKCdjb25uZWN0aW9uJywgZGF0YS5jb25uZWN0aW9uLCBkYXRhLmNvbm5lY3Rpb25HZngpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRHJhZ2dlcihjb250ZXh0LCBzZWdtZW50T2Zmc2V0LCBldmVudCkge1xuXG4gICAgdmFyIG5ld1dheXBvaW50cyA9IGNvbnRleHQubmV3V2F5cG9pbnRzLFxuICAgICAgICBzZWdtZW50U3RhcnRJbmRleCA9IGNvbnRleHQuc2VnbWVudFN0YXJ0SW5kZXggKyBzZWdtZW50T2Zmc2V0LFxuICAgICAgICBzZWdtZW50U3RhcnQgPSBuZXdXYXlwb2ludHNbc2VnbWVudFN0YXJ0SW5kZXhdLFxuICAgICAgICBzZWdtZW50RW5kSW5kZXggPSBjb250ZXh0LnNlZ21lbnRFbmRJbmRleCArIHNlZ21lbnRPZmZzZXQsXG4gICAgICAgIHNlZ21lbnRFbmQgPSBuZXdXYXlwb2ludHNbc2VnbWVudEVuZEluZGV4XSxcbiAgICAgICAgYXhpcyA9IGZsaXBBeGlzKGNvbnRleHQuYXhpcyk7XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIGRyYWdnZXIgZG9lcyBub3QgbW92ZVxuICAgIC8vIG91dHNpZGUgdGhlIGNvbm5lY3Rpb25cbiAgICB2YXIgZHJhZ2dlclBvc2l0aW9uID0gYXhpc0ZlbmNlZChldmVudCwgc2VnbWVudFN0YXJ0LCBzZWdtZW50RW5kLCBheGlzKTtcblxuICAgIC8vIHVwZGF0ZSBkcmFnZ2VyXG4gICAgdHJhbnNsYXRlKGNvbnRleHQuZHJhZ2dlckdmeCwgZHJhZ2dlclBvc2l0aW9uLngsIGRyYWdnZXJQb3NpdGlvbi55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaWx0ZXIgd2F5cG9pbnRzIGZvciByZWR1bmRhbnQgb25lcyAoaS5lLiBvbiB0aGUgc2FtZSBheGlzKS5cbiAgICogUmV0dXJucyB0aGUgZmlsdGVyZWQgd2F5cG9pbnRzIGFuZCB0aGUgb2Zmc2V0IHJlbGF0ZWQgdG8gdGhlIHNlZ21lbnQgbW92ZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxQb2ludD59IHdheXBvaW50c1xuICAgKiBAcGFyYW0ge0ludGVnZXJ9IHNlZ21lbnRTdGFydEluZGV4IG9mIG1vdmVkIHNlZ21lbnQgc3RhcnRcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSB7IGZpbHRlcmVkV2F5cG9pbnRzLCBzZWdtZW50T2Zmc2V0IH1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbHRlclJlZHVuZGFudFdheXBvaW50cyh3YXlwb2ludHMsIHNlZ21lbnRTdGFydEluZGV4KSB7XG5cbiAgICB2YXIgc2VnbWVudE9mZnNldCA9IDA7XG5cbiAgICB2YXIgZmlsdGVyZWRXYXlwb2ludHMgPSB3YXlwb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHIsIGlkeCkge1xuICAgICAgaWYgKHBvaW50c09uTGluZSh3YXlwb2ludHNbaWR4IC0gMV0sIHdheXBvaW50c1tpZHggKyAxXSwgcikpIHtcblxuICAgICAgICAvLyByZW1vdmUgcG9pbnQgYW5kIGluY3JlbWVudCBvZmZzZXRcbiAgICAgICAgc2VnbWVudE9mZnNldCA9IGlkeCA8PSBzZWdtZW50U3RhcnRJbmRleCA/IHNlZ21lbnRPZmZzZXQgLSAxIDogc2VnbWVudE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBkb250IHJlbW92ZSBwb2ludFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2F5cG9pbnRzOiBmaWx0ZXJlZFdheXBvaW50cyxcbiAgICAgIHNlZ21lbnRPZmZzZXQ6IHNlZ21lbnRPZmZzZXRcbiAgICB9O1xuICB9XG5cbiAgZXZlbnRCdXMub24oJ2Nvbm5lY3Rpb25TZWdtZW50Lm1vdmUuc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBjb25uZWN0aW9uID0gZXZlbnQuY29ubmVjdGlvbixcbiAgICAgICAgbGF5ZXIgPSBjYW52YXMuZ2V0TGF5ZXIoJ292ZXJsYXlzJyk7XG5cbiAgICBjb250ZXh0Lm9yaWdpbmFsV2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHMuc2xpY2UoKTtcblxuICAgIC8vIGFkZCBkcmFnZ2VyIGdmeFxuICAgIGNvbnRleHQuZHJhZ2dlckdmeCA9IGFkZFNlZ21lbnREcmFnZ2VyKGxheWVyLCBjb250ZXh0LnNlZ21lbnRTdGFydCwgY29udGV4dC5zZWdtZW50RW5kKTtcbiAgICBzdmdDbGFzc2VzKGNvbnRleHQuZHJhZ2dlckdmeCkuYWRkKCdkanMtZHJhZ2dpbmcnKTtcblxuICAgIGNhbnZhcy5hZGRNYXJrZXIoY29ubmVjdGlvbiwgTUFSS0VSX0NPTk5FQ1RfVVBEQVRJTkcpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignY29ubmVjdGlvblNlZ21lbnQubW92ZS5tb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgICAgc2VnbWVudFN0YXJ0SW5kZXggPSBjb250ZXh0LnNlZ21lbnRTdGFydEluZGV4LFxuICAgICAgICBzZWdtZW50RW5kSW5kZXggPSBjb250ZXh0LnNlZ21lbnRFbmRJbmRleCxcbiAgICAgICAgc2VnbWVudFN0YXJ0ID0gY29udGV4dC5zZWdtZW50U3RhcnQsXG4gICAgICAgIHNlZ21lbnRFbmQgPSBjb250ZXh0LnNlZ21lbnRFbmQsXG4gICAgICAgIGF4aXMgPSBjb250ZXh0LmF4aXM7XG5cbiAgICB2YXIgbmV3V2F5cG9pbnRzID0gY29udGV4dC5vcmlnaW5hbFdheXBvaW50cy5zbGljZSgpLFxuICAgICAgICBuZXdTZWdtZW50U3RhcnQgPSBheGlzQWRkKHNlZ21lbnRTdGFydCwgYXhpcywgZXZlbnRbJ2QnICsgYXhpc10pLFxuICAgICAgICBuZXdTZWdtZW50RW5kID0gYXhpc0FkZChzZWdtZW50RW5kLCBheGlzLCBldmVudFsnZCcgKyBheGlzXSk7XG5cbiAgICAvLyBvcmlnaW5hbCB3YXlwb2ludCBjb3VudCBhbmQgYWRkZWQgLyByZW1vdmVkXG4gICAgLy8gZnJvbSBzdGFydCB3YXlwb2ludCBkZWx0YS4gV2UgdXNlIHRoZSBsYXRlclxuICAgIC8vIHRvIHJldHJpZXZlIHRoZSB1cGRhdGVkIHNlZ21lbnRTdGFydEluZGV4IC8gc2VnbWVudEVuZEluZGV4XG4gICAgdmFyIHdheXBvaW50Q291bnQgPSBuZXdXYXlwb2ludHMubGVuZ3RoLFxuICAgICAgICBzZWdtZW50T2Zmc2V0ID0gMDtcblxuICAgIC8vIG1vdmUgc2VnbWVudCBzdGFydCAvIGVuZCBieSBheGlzIGRlbHRhXG4gICAgbmV3V2F5cG9pbnRzW3NlZ21lbnRTdGFydEluZGV4XSA9IG5ld1NlZ21lbnRTdGFydDtcbiAgICBuZXdXYXlwb2ludHNbc2VnbWVudEVuZEluZGV4XSA9IG5ld1NlZ21lbnRFbmQ7XG5cbiAgICB2YXIgc291cmNlVG9TZWdtZW50T3JpZW50YXRpb24sXG4gICAgICAgIHRhcmdldFRvU2VnbWVudE9yaWVudGF0aW9uO1xuXG4gICAgLy8gaGFuZGxlIGZpcnN0IHNlZ21lbnRcbiAgICBpZiAoc2VnbWVudFN0YXJ0SW5kZXggPCAyKSB7XG4gICAgICBzb3VyY2VUb1NlZ21lbnRPcmllbnRhdGlvbiA9IGdldE9yaWVudGF0aW9uKGNvbm5lY3Rpb24uc291cmNlLCBuZXdTZWdtZW50U3RhcnQpO1xuXG4gICAgICAvLyBmaXJzdCBiZW5kcG9pbnQsIHJlbW92ZSBmaXJzdCBzZWdtZW50IGlmIGludGVyc2VjdGluZ1xuICAgICAgaWYgKHNlZ21lbnRTdGFydEluZGV4ID09PSAxKSB7XG5cbiAgICAgICAgaWYgKHNvdXJjZVRvU2VnbWVudE9yaWVudGF0aW9uID09PSAnaW50ZXJzZWN0Jykge1xuICAgICAgICAgIG5ld1dheXBvaW50cy5zaGlmdCgpO1xuICAgICAgICAgIG5ld1dheXBvaW50c1swXSA9IG5ld1NlZ21lbnRTdGFydDtcbiAgICAgICAgICBzZWdtZW50T2Zmc2V0LS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZG9ja2luZyBwb2ludCwgYWRkIHNlZ21lbnQgaWYgbm90IGludGVyc2VjdGluZyBhbnltb3JlXG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHNvdXJjZVRvU2VnbWVudE9yaWVudGF0aW9uICE9PSAnaW50ZXJzZWN0Jykge1xuICAgICAgICAgIG5ld1dheXBvaW50cy51bnNoaWZ0KHNlZ21lbnRTdGFydCk7XG4gICAgICAgICAgc2VnbWVudE9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGxhc3Qgc2VnbWVudFxuICAgIGlmIChzZWdtZW50RW5kSW5kZXggPiB3YXlwb2ludENvdW50IC0gMykge1xuICAgICAgdGFyZ2V0VG9TZWdtZW50T3JpZW50YXRpb24gPSBnZXRPcmllbnRhdGlvbihjb25uZWN0aW9uLnRhcmdldCwgbmV3U2VnbWVudEVuZCk7XG5cbiAgICAgIC8vIGxhc3QgYmVuZHBvaW50LCByZW1vdmUgbGFzdCBzZWdtZW50IGlmIGludGVyc2VjdGluZ1xuICAgICAgaWYgKHNlZ21lbnRFbmRJbmRleCA9PT0gd2F5cG9pbnRDb3VudCAtIDIpIHtcblxuICAgICAgICBpZiAodGFyZ2V0VG9TZWdtZW50T3JpZW50YXRpb24gPT09ICdpbnRlcnNlY3QnKSB7XG4gICAgICAgICAgbmV3V2F5cG9pbnRzLnBvcCgpO1xuICAgICAgICAgIG5ld1dheXBvaW50c1tuZXdXYXlwb2ludHMubGVuZ3RoIC0gMV0gPSBuZXdTZWdtZW50RW5kO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxhc3QgYmVuZHBvaW50LCByZW1vdmUgbGFzdCBzZWdtZW50IGlmIGludGVyc2VjdGluZ1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0YXJnZXRUb1NlZ21lbnRPcmllbnRhdGlvbiAhPT0gJ2ludGVyc2VjdCcpIHtcbiAgICAgICAgICBuZXdXYXlwb2ludHMucHVzaChzZWdtZW50RW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBjb25uZWN0aW9uIHdheXBvaW50c1xuICAgIGNvbnRleHQubmV3V2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHMgPSBjcm9wQ29ubmVjdGlvbihjb25uZWN0aW9uLCBuZXdXYXlwb2ludHMpO1xuXG4gICAgLy8gdXBkYXRlIGRyYWdnZXIgcG9zaXRpb25cbiAgICB1cGRhdGVEcmFnZ2VyKGNvbnRleHQsIHNlZ21lbnRPZmZzZXQsIGV2ZW50KTtcblxuICAgIC8vIHNhdmUgc2VnbWVudE9mZnNldCBpbiBjb250ZXh0XG4gICAgY29udGV4dC5uZXdTZWdtZW50U3RhcnRJbmRleCA9IHNlZ21lbnRTdGFydEluZGV4ICsgc2VnbWVudE9mZnNldDtcblxuICAgIC8vIHJlZHJhdyBjb25uZWN0aW9uXG4gICAgcmVkcmF3Q29ubmVjdGlvbihldmVudCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjb25uZWN0aW9uU2VnbWVudC5tb3ZlLmhvdmVyJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIGV2ZW50LmNvbnRleHQuaG92ZXIgPSBldmVudC5ob3ZlcjtcbiAgICBjYW52YXMuYWRkTWFya2VyKGV2ZW50LmhvdmVyLCBNQVJLRVJfQ09OTkVDVF9IT1ZFUik7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKFtcbiAgICAnY29ubmVjdGlvblNlZ21lbnQubW92ZS5vdXQnLFxuICAgICdjb25uZWN0aW9uU2VnbWVudC5tb3ZlLmNsZWFudXAnXG4gIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAvLyByZW1vdmUgY29ubmVjdCBtYXJrZXJcbiAgICAvLyBpZiBpdCB3YXMgYWRkZWRcbiAgICB2YXIgaG92ZXIgPSBldmVudC5jb250ZXh0LmhvdmVyO1xuXG4gICAgaWYgKGhvdmVyKSB7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGhvdmVyLCBNQVJLRVJfQ09OTkVDVF9IT1ZFUik7XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbignY29ubmVjdGlvblNlZ21lbnQubW92ZS5jbGVhbnVwJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbjtcblxuICAgIC8vIHJlbW92ZSBkcmFnZ2VyIGdmeFxuICAgIGlmIChjb250ZXh0LmRyYWdnZXJHZngpIHtcbiAgICAgIHN2Z1JlbW92ZShjb250ZXh0LmRyYWdnZXJHZngpO1xuICAgIH1cblxuICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoY29ubmVjdGlvbiwgTUFSS0VSX0NPTk5FQ1RfVVBEQVRJTkcpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbihbXG4gICAgJ2Nvbm5lY3Rpb25TZWdtZW50Lm1vdmUuY2FuY2VsJyxcbiAgICAnY29ubmVjdGlvblNlZ21lbnQubW92ZS5lbmQnXG4gIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uO1xuXG4gICAgY29ubmVjdGlvbi53YXlwb2ludHMgPSBjb250ZXh0Lm9yaWdpbmFsV2F5cG9pbnRzO1xuXG4gICAgcmVkcmF3Q29ubmVjdGlvbihldmVudCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjb25uZWN0aW9uU2VnbWVudC5tb3ZlLmVuZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICAgIG5ld1dheXBvaW50cyA9IGNvbnRleHQubmV3V2F5cG9pbnRzLFxuICAgICAgICBuZXdTZWdtZW50U3RhcnRJbmRleCA9IGNvbnRleHQubmV3U2VnbWVudFN0YXJ0SW5kZXg7XG5cbiAgICAvLyBlbnN1cmUgd2UgaGF2ZSBhY3R1YWwgcGl4ZWwgdmFsdWVzIGJlbmRwb2ludFxuICAgIC8vIGNvb3JkaW5hdGVzIChpbXBvcnRhbnQgd2hlbiB6b29tIGxldmVsIHdhcyA+IDEgZHVyaW5nIG1vdmUpXG4gICAgbmV3V2F5cG9pbnRzID0gbmV3V2F5cG9pbnRzLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW5hbDogcC5vcmlnaW5hbCxcbiAgICAgICAgeDogTWF0aC5yb3VuZChwLngpLFxuICAgICAgICB5OiBNYXRoLnJvdW5kKHAueSlcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBmaWx0ZXIgcmVkdW5hbnQgd2F5cG9pbnRzXG4gICAgdmFyIGZpbHRlcmVkID0gZmlsdGVyUmVkdW5kYW50V2F5cG9pbnRzKG5ld1dheXBvaW50cywgbmV3U2VnbWVudFN0YXJ0SW5kZXgpO1xuXG4gICAgLy8gZ2V0IGZpbHRlcmVkIHdheXBvaW50c1xuICAgIHZhciBmaWx0ZXJlZFdheXBvaW50cyA9IGZpbHRlcmVkLndheXBvaW50cyxcbiAgICAgICAgY3JvcHBlZFdheXBvaW50cyA9IGNyb3BDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGZpbHRlcmVkV2F5cG9pbnRzKSxcbiAgICAgICAgc2VnbWVudE9mZnNldCA9IGZpbHRlcmVkLnNlZ21lbnRPZmZzZXQ7XG5cbiAgICB2YXIgaGludHMgPSB7XG4gICAgICBzZWdtZW50TW92ZToge1xuICAgICAgICBzZWdtZW50U3RhcnRJbmRleDogY29udGV4dC5zZWdtZW50U3RhcnRJbmRleCxcbiAgICAgICAgbmV3U2VnbWVudFN0YXJ0SW5kZXg6IG5ld1NlZ21lbnRTdGFydEluZGV4ICsgc2VnbWVudE9mZnNldFxuICAgICAgfVxuICAgIH07XG5cbiAgICBtb2RlbGluZy51cGRhdGVXYXlwb2ludHMoY29ubmVjdGlvbiwgY3JvcHBlZFdheXBvaW50cywgaGludHMpO1xuICB9KTtcbn1cblxuQ29ubmVjdGlvblNlZ21lbnRNb3ZlLiRpbmplY3QgPSBbXG4gICdpbmplY3RvcicsXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnZHJhZ2dpbmcnLFxuICAnZ3JhcGhpY3NGYWN0b3J5JyxcbiAgJ21vZGVsaW5nJ1xuXTtcbiIsImltcG9ydCBEcmFnZ2luZ01vZHVsZSBmcm9tICcuLi9kcmFnZ2luZyc7XG5pbXBvcnQgUnVsZXNNb2R1bGUgZnJvbSAnLi4vcnVsZXMnO1xuXG5pbXBvcnQgQmVuZHBvaW50cyBmcm9tICcuL0JlbmRwb2ludHMnO1xuaW1wb3J0IEJlbmRwb2ludE1vdmUgZnJvbSAnLi9CZW5kcG9pbnRNb3ZlJztcbmltcG9ydCBCZW5kcG9pbnRNb3ZlUHJldmlldyBmcm9tICcuL0JlbmRwb2ludE1vdmVQcmV2aWV3JztcbmltcG9ydCBDb25uZWN0aW9uU2VnbWVudE1vdmUgZnJvbSAnLi9Db25uZWN0aW9uU2VnbWVudE1vdmUnO1xuaW1wb3J0IEJlbmRwb2ludFNuYXBwaW5nIGZyb20gJy4vQmVuZHBvaW50U25hcHBpbmcnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBEcmFnZ2luZ01vZHVsZSxcbiAgICBSdWxlc01vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAnYmVuZHBvaW50cycsICdiZW5kcG9pbnRTbmFwcGluZycsICdiZW5kcG9pbnRNb3ZlUHJldmlldycgXSxcbiAgYmVuZHBvaW50czogWyAndHlwZScsIEJlbmRwb2ludHMgXSxcbiAgYmVuZHBvaW50TW92ZTogWyAndHlwZScsIEJlbmRwb2ludE1vdmUgXSxcbiAgYmVuZHBvaW50TW92ZVByZXZpZXc6IFsgJ3R5cGUnLCBCZW5kcG9pbnRNb3ZlUHJldmlldyBdLFxuICBjb25uZWN0aW9uU2VnbWVudE1vdmU6IFsgJ3R5cGUnLCBDb25uZWN0aW9uU2VnbWVudE1vdmUgXSxcbiAgYmVuZHBvaW50U25hcHBpbmc6IFsgJ3R5cGUnLCBCZW5kcG9pbnRTbmFwcGluZyBdXG59O1xuIiwiaW1wb3J0IHtcbiAgZ2V0VHlwZSBhcyBnZXRFbGVtZW50VHlwZVxufSBmcm9tICcuLi8uLi91dGlsL0VsZW1lbnRzJztcblxuLyoqXG4gKiBBZGRzIGNoYW5nZSBzdXBwb3J0IHRvIHRoZSBkaWFncmFtLCBpbmNsdWRpbmdcbiAqXG4gKiA8dWw+XG4gKiAgIDxsaT5yZWRyYXdpbmcgc2hhcGVzIGFuZCBjb25uZWN0aW9ucyBvbiBjaGFuZ2U8L2xpPlxuICogPC91bD5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnl9IGVsZW1lbnRSZWdpc3RyeVxuICogQHBhcmFtIHtHcmFwaGljc0ZhY3Rvcnl9IGdyYXBoaWNzRmFjdG9yeVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDaGFuZ2VTdXBwb3J0KFxuICAgIGV2ZW50QnVzLCBjYW52YXMsIGVsZW1lbnRSZWdpc3RyeSxcbiAgICBncmFwaGljc0ZhY3RvcnkpIHtcblxuXG4gIC8vIHJlZHJhdyBzaGFwZXMgLyBjb25uZWN0aW9ucyBvbiBjaGFuZ2VcblxuICBldmVudEJ1cy5vbignZWxlbWVudC5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudDtcblxuICAgIC8vIGVsZW1lbnQgbWlnaHQgaGF2ZSBiZWVuIGRlbGV0ZWQgYW5kIHJlcGxhY2VkIGJ5IG5ldyBlbGVtZW50IHdpdGggc2FtZSBJRFxuICAgIC8vIHRodXMgY2hlY2sgZm9yIHBhcmVudCBvZiBlbGVtZW50IGV4Y2VwdCBmb3Igcm9vdCBlbGVtZW50XG4gICAgaWYgKGVsZW1lbnQucGFyZW50IHx8IGVsZW1lbnQgPT09IGNhbnZhcy5nZXRSb290RWxlbWVudCgpKSB7XG4gICAgICBldmVudC5nZnggPSBlbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gc2hhcGUgKyBnZnggbWF5IGhhdmUgYmVlbiBkZWxldGVkXG4gICAgaWYgKCFldmVudC5nZngpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudEJ1cy5maXJlKGdldEVsZW1lbnRUeXBlKGVsZW1lbnQpICsgJy5jaGFuZ2VkJywgZXZlbnQpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignZWxlbWVudHMuY2hhbmdlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgZWxlbWVudHMgPSBldmVudC5lbGVtZW50cztcblxuICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgZXZlbnRCdXMuZmlyZSgnZWxlbWVudC5jaGFuZ2VkJywgeyBlbGVtZW50OiBlIH0pO1xuICAgIH0pO1xuXG4gICAgZ3JhcGhpY3NGYWN0b3J5LnVwZGF0ZUNvbnRhaW5tZW50cyhlbGVtZW50cyk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdzaGFwZS5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBncmFwaGljc0ZhY3RvcnkudXBkYXRlKCdzaGFwZScsIGV2ZW50LmVsZW1lbnQsIGV2ZW50LmdmeCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjb25uZWN0aW9uLmNoYW5nZWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIGdyYXBoaWNzRmFjdG9yeS51cGRhdGUoJ2Nvbm5lY3Rpb24nLCBldmVudC5lbGVtZW50LCBldmVudC5nZngpO1xuICB9KTtcbn1cblxuQ2hhbmdlU3VwcG9ydC4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJyxcbiAgJ2VsZW1lbnRSZWdpc3RyeScsXG4gICdncmFwaGljc0ZhY3RvcnknXG5dOyIsImltcG9ydCBDaGFuZ2VTdXBwb3J0IGZyb20gJy4vQ2hhbmdlU3VwcG9ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ2NoYW5nZVN1cHBvcnQnXSxcbiAgY2hhbmdlU3VwcG9ydDogWyAndHlwZScsIENoYW5nZVN1cHBvcnQgXVxufTsiLCIvKipcbiAqIEEgY2xpcCBib2FyZCBzdHViXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENsaXBib2FyZCgpIHt9XG5cblxuQ2xpcGJvYXJkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2RhdGE7XG59O1xuXG5DbGlwYm9hcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5fZGF0YSA9IGRhdGE7XG59O1xuXG5DbGlwYm9hcmQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICBkZWxldGUgdGhpcy5fZGF0YTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cbkNsaXBib2FyZC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMuX2RhdGE7XG59OyIsImltcG9ydCBDbGlwYm9hcmQgZnJvbSAnLi9DbGlwYm9hcmQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNsaXBib2FyZDogWyAndHlwZScsIENsaXBib2FyZCBdXG59O1xuIiwiaW1wb3J0IHtcbiAgZ2V0TWlkXG59IGZyb20gJy4uLy4uL2xheW91dC9MYXlvdXRVdGlsJztcblxuaW1wb3J0IHtcbiAgaXNOaWwsXG4gIGlzT2JqZWN0XG59IGZyb20gJ21pbi1kYXNoJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb25uZWN0KGV2ZW50QnVzLCBkcmFnZ2luZywgbW9kZWxpbmcsIHJ1bGVzKSB7XG5cbiAgLy8gcnVsZXNcblxuICBmdW5jdGlvbiBjYW5Db25uZWN0KHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHJ1bGVzLmFsbG93ZWQoJ2Nvbm5lY3Rpb24uY3JlYXRlJywge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICB0YXJnZXQ6IHRhcmdldFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuQ29ubmVjdFJldmVyc2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gY2FuQ29ubmVjdCh0YXJnZXQsIHNvdXJjZSk7XG4gIH1cblxuXG4gIC8vIGV2ZW50IGhhbmRsZXJzXG5cbiAgZXZlbnRCdXMub24oJ2Nvbm5lY3QuaG92ZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgc3RhcnQgPSBjb250ZXh0LnN0YXJ0LFxuICAgICAgICBob3ZlciA9IGV2ZW50LmhvdmVyLFxuICAgICAgICBjYW5FeGVjdXRlO1xuXG4gICAgLy8gY2FjaGUgaG92ZXIgc3RhdGVcbiAgICBjb250ZXh0LmhvdmVyID0gaG92ZXI7XG5cbiAgICBjYW5FeGVjdXRlID0gY29udGV4dC5jYW5FeGVjdXRlID0gY2FuQ29ubmVjdChzdGFydCwgaG92ZXIpO1xuXG4gICAgLy8gaWdub3JlIGhvdmVyXG4gICAgaWYgKGlzTmlsKGNhbkV4ZWN1dGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNhbkV4ZWN1dGUgIT09IGZhbHNlKSB7XG4gICAgICBjb250ZXh0LnNvdXJjZSA9IHN0YXJ0O1xuICAgICAgY29udGV4dC50YXJnZXQgPSBob3ZlcjtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbkV4ZWN1dGUgPSBjb250ZXh0LmNhbkV4ZWN1dGUgPSBjYW5Db25uZWN0UmV2ZXJzZShzdGFydCwgaG92ZXIpO1xuXG4gICAgLy8gaWdub3JlIGhvdmVyXG4gICAgaWYgKGlzTmlsKGNhbkV4ZWN1dGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNhbkV4ZWN1dGUgIT09IGZhbHNlKSB7XG4gICAgICBjb250ZXh0LnNvdXJjZSA9IGhvdmVyO1xuICAgICAgY29udGV4dC50YXJnZXQgPSBzdGFydDtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKFsgJ2Nvbm5lY3Qub3V0JywgJ2Nvbm5lY3QuY2xlYW51cCcgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQ7XG5cbiAgICBjb250ZXh0LmhvdmVyID0gbnVsbDtcbiAgICBjb250ZXh0LnNvdXJjZSA9IG51bGw7XG4gICAgY29udGV4dC50YXJnZXQgPSBudWxsO1xuXG4gICAgY29udGV4dC5jYW5FeGVjdXRlID0gZmFsc2U7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjb25uZWN0LmVuZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBjYW5FeGVjdXRlID0gY29udGV4dC5jYW5FeGVjdXRlLFxuICAgICAgICBjb25uZWN0aW9uU3RhcnQgPSBjb250ZXh0LmNvbm5lY3Rpb25TdGFydCxcbiAgICAgICAgY29ubmVjdGlvbkVuZCA9IHtcbiAgICAgICAgICB4OiBldmVudC54LFxuICAgICAgICAgIHk6IGV2ZW50LnlcbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlID0gY29udGV4dC5zb3VyY2UsXG4gICAgICAgIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0O1xuXG4gICAgaWYgKCFjYW5FeGVjdXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGF0dHJzID0gbnVsbCxcbiAgICAgICAgaGludHMgPSB7XG4gICAgICAgICAgY29ubmVjdGlvblN0YXJ0OiBpc1JldmVyc2UoY29udGV4dCkgPyBjb25uZWN0aW9uRW5kIDogY29ubmVjdGlvblN0YXJ0LFxuICAgICAgICAgIGNvbm5lY3Rpb25FbmQ6IGlzUmV2ZXJzZShjb250ZXh0KSA/IGNvbm5lY3Rpb25TdGFydCA6IGNvbm5lY3Rpb25FbmRcbiAgICAgICAgfTtcblxuICAgIGlmIChpc09iamVjdChjYW5FeGVjdXRlKSkge1xuICAgICAgYXR0cnMgPSBjYW5FeGVjdXRlO1xuICAgIH1cblxuICAgIG1vZGVsaW5nLmNvbm5lY3Qoc291cmNlLCB0YXJnZXQsIGF0dHJzLCBoaW50cyk7XG4gIH0pO1xuXG5cbiAgLy8gQVBJXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGNvbm5lY3Qgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBzdGFydFxuICAgKiBAcGFyYW0ge1BvaW50fSBbY29ubmVjdGlvblN0YXJ0XVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdXRvQWN0aXZhdGU9ZmFsc2VdXG4gICAqL1xuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQsIHN0YXJ0LCBjb25uZWN0aW9uU3RhcnQsIGF1dG9BY3RpdmF0ZSkge1xuICAgIGlmICghaXNPYmplY3QoY29ubmVjdGlvblN0YXJ0KSkge1xuICAgICAgYXV0b0FjdGl2YXRlID0gY29ubmVjdGlvblN0YXJ0O1xuICAgICAgY29ubmVjdGlvblN0YXJ0ID0gZ2V0TWlkKHN0YXJ0KTtcbiAgICB9XG5cbiAgICBkcmFnZ2luZy5pbml0KGV2ZW50LCAnY29ubmVjdCcsIHtcbiAgICAgIGF1dG9BY3RpdmF0ZTogYXV0b0FjdGl2YXRlLFxuICAgICAgZGF0YToge1xuICAgICAgICBzaGFwZTogc3RhcnQsXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgY29ubmVjdGlvblN0YXJ0OiBjb25uZWN0aW9uU3RhcnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG5Db25uZWN0LiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdkcmFnZ2luZycsXG4gICdtb2RlbGluZycsXG4gICdydWxlcydcbl07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JldmVyc2UoY29udGV4dCkge1xuICB2YXIgaG92ZXIgPSBjb250ZXh0LmhvdmVyLFxuICAgICAgc291cmNlID0gY29udGV4dC5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBjb250ZXh0LnRhcmdldDtcblxuICByZXR1cm4gaG92ZXIgJiYgc291cmNlICYmIGhvdmVyID09PSBzb3VyY2UgJiYgc291cmNlICE9PSB0YXJnZXQ7XG59IiwiaW1wb3J0IHsgaXNSZXZlcnNlIH0gZnJvbSAnLi9Db25uZWN0JztcblxudmFyIEhJR0hfUFJJT1JJVFkgPSAxMTAwLFxuICAgIExPV19QUklPUklUWSA9IDkwMDtcblxudmFyIE1BUktFUl9PSyA9ICdjb25uZWN0LW9rJyxcbiAgICBNQVJLRVJfTk9UX09LID0gJ2Nvbm5lY3Qtbm90LW9rJztcblxuLyoqXG4gKiBTaG93cyBjb25uZWN0aW9uIHByZXZpZXcgZHVyaW5nIGNvbm5lY3QuXG4gKlxuICogQHBhcmFtIHtkaWRpLkluamVjdG9yfSBpbmplY3RvclxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29ubmVjdFByZXZpZXcoaW5qZWN0b3IsIGV2ZW50QnVzLCBjYW52YXMpIHtcbiAgdmFyIGNvbm5lY3Rpb25QcmV2aWV3ID0gaW5qZWN0b3IuZ2V0KCdjb25uZWN0aW9uUHJldmlldycsIGZhbHNlKTtcblxuICBjb25uZWN0aW9uUHJldmlldyAmJiBldmVudEJ1cy5vbignY29ubmVjdC5tb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGNhbkNvbm5lY3QgPSBjb250ZXh0LmNhbkV4ZWN1dGUsXG4gICAgICAgIGhvdmVyID0gY29udGV4dC5ob3ZlcixcbiAgICAgICAgc291cmNlID0gY29udGV4dC5zb3VyY2UsXG4gICAgICAgIHN0YXJ0ID0gY29udGV4dC5zdGFydCxcbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGNvbnRleHQuc3RhcnRQb3NpdGlvbixcbiAgICAgICAgY29ubmVjdGlvblN0YXJ0ID0gY29udGV4dC5jb25uZWN0aW9uU3RhcnQsXG4gICAgICAgIGNvbm5lY3Rpb25FbmQgPSBjb250ZXh0LmNvbm5lY3Rpb25FbmQsXG4gICAgICAgIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0O1xuXG4gICAgaWYgKCFjb25uZWN0aW9uU3RhcnQpIHtcbiAgICAgIGNvbm5lY3Rpb25TdGFydCA9IGlzUmV2ZXJzZShjb250ZXh0KSA/IHtcbiAgICAgICAgeDogZXZlbnQueCxcbiAgICAgICAgeTogZXZlbnQueVxuICAgICAgfSA6IHN0YXJ0UG9zaXRpb247XG4gICAgfVxuXG4gICAgaWYgKCFjb25uZWN0aW9uRW5kKSB7XG4gICAgICBjb25uZWN0aW9uRW5kID0gaXNSZXZlcnNlKGNvbnRleHQpID8gc3RhcnRQb3NpdGlvbiA6IHtcbiAgICAgICAgeDogZXZlbnQueCxcbiAgICAgICAgeTogZXZlbnQueVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25uZWN0aW9uUHJldmlldy5kcmF3UHJldmlldyhjb250ZXh0LCBjYW5Db25uZWN0LCB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSB8fCBzdGFydCxcbiAgICAgIHRhcmdldDogdGFyZ2V0IHx8IGhvdmVyLFxuICAgICAgY29ubmVjdGlvblN0YXJ0OiBjb25uZWN0aW9uU3RhcnQsXG4gICAgICBjb25uZWN0aW9uRW5kOiBjb25uZWN0aW9uRW5kXG4gICAgfSk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjb25uZWN0LmhvdmVyJywgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgaG92ZXIgPSBldmVudC5ob3ZlcixcbiAgICAgICAgY2FuRXhlY3V0ZSA9IGNvbnRleHQuY2FuRXhlY3V0ZTtcblxuICAgIC8vIGlnbm9yZSBob3ZlclxuICAgIGlmIChjYW5FeGVjdXRlID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FudmFzLmFkZE1hcmtlcihob3ZlciwgY2FuRXhlY3V0ZSA/IE1BUktFUl9PSyA6IE1BUktFUl9OT1RfT0spO1xuICB9KTtcblxuICBldmVudEJ1cy5vbihbXG4gICAgJ2Nvbm5lY3Qub3V0JyxcbiAgICAnY29ubmVjdC5jbGVhbnVwJ1xuICBdLCBISUdIX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBob3ZlciA9IGV2ZW50LmhvdmVyO1xuXG4gICAgaWYgKGhvdmVyKSB7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGhvdmVyLCBNQVJLRVJfT0spO1xuICAgICAgY2FudmFzLnJlbW92ZU1hcmtlcihob3ZlciwgTUFSS0VSX05PVF9PSyk7XG4gICAgfVxuICB9KTtcblxuICBjb25uZWN0aW9uUHJldmlldyAmJiBldmVudEJ1cy5vbignY29ubmVjdC5jbGVhbnVwJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBjb25uZWN0aW9uUHJldmlldy5jbGVhblVwKGV2ZW50LmNvbnRleHQpO1xuICB9KTtcbn1cblxuQ29ubmVjdFByZXZpZXcuJGluamVjdCA9IFtcbiAgJ2luamVjdG9yJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcydcbl07XG4iLCJpbXBvcnQgU2VsZWN0aW9uTW9kdWxlIGZyb20gJy4uL3NlbGVjdGlvbic7XG5pbXBvcnQgUnVsZXNNb2R1bGUgZnJvbSAnLi4vcnVsZXMnO1xuaW1wb3J0IERyYWdnaW5nTW9kdWxlIGZyb20gJy4uL2RyYWdnaW5nJztcblxuaW1wb3J0IENvbm5lY3QgZnJvbSAnLi9Db25uZWN0JztcbmltcG9ydCBDb25uZWN0UHJldmlldyBmcm9tICcuL0Nvbm5lY3RQcmV2aWV3JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIFNlbGVjdGlvbk1vZHVsZSxcbiAgICBSdWxlc01vZHVsZSxcbiAgICBEcmFnZ2luZ01vZHVsZVxuICBdLFxuICBfX2luaXRfXzogW1xuICAgICdjb25uZWN0UHJldmlldydcbiAgXSxcbiAgY29ubmVjdDogWyAndHlwZScsIENvbm5lY3QgXSxcbiAgY29ubmVjdFByZXZpZXc6IFsgJ3R5cGUnLCBDb25uZWN0UHJldmlldyBdXG59O1xuIiwiaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjbGFzc2VzIGFzIHN2Z0NsYXNzZXMsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXG4gIHJlbW92ZSBhcyBzdmdSZW1vdmUsXG4gIGNsZWFyIGFzIHN2Z0NsZWFyXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IHtcbiAgaXNPYmplY3Rcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRFbGVtZW50TGluZUludGVyc2VjdGlvbixcbiAgZ2V0TWlkXG59IGZyb20gJy4uLy4uL2xheW91dC9MYXlvdXRVdGlsJztcblxuXG52YXIgTUFSS0VSX0NPTk5FQ1RJT05fUFJFVklFVyA9ICdkanMtY29ubmVjdGlvbi1wcmV2aWV3JztcblxuLyoqXG4gKiBEcmF3cyBjb25uZWN0aW9uIHByZXZpZXcuIE9wdGlvbmFsbHksIHRoaXMgY2FuIHVzZSBsYXlvdXRlciBhbmQgY29ubmVjdGlvbiBkb2NraW5nIHRvIGRyYXdcbiAqIGJldHRlciBsb29raW5nIHByZXZpZXdzLlxuICpcbiAqIEBwYXJhbSB7ZGlkaS5JbmplY3Rvcn0gaW5qZWN0b3JcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqIEBwYXJhbSB7R3JhcGhpY3NGYWN0b3J5fSBncmFwaGljc0ZhY3RvcnlcbiAqIEBwYXJhbSB7RWxlbWVudEZhY3Rvcnl9IGVsZW1lbnRGYWN0b3J5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbm5lY3Rpb25QcmV2aWV3KFxuICAgIGluamVjdG9yLFxuICAgIGNhbnZhcyxcbiAgICBncmFwaGljc0ZhY3RvcnksXG4gICAgZWxlbWVudEZhY3Rvcnlcbikge1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gIHRoaXMuX2dyYXBoaWNzRmFjdG9yeSA9IGdyYXBoaWNzRmFjdG9yeTtcbiAgdGhpcy5fZWxlbWVudEZhY3RvcnkgPSBlbGVtZW50RmFjdG9yeTtcblxuICAvLyBvcHRpb25hbCBjb21wb25lbnRzXG4gIHRoaXMuX2Nvbm5lY3Rpb25Eb2NraW5nID0gaW5qZWN0b3IuZ2V0KCdjb25uZWN0aW9uRG9ja2luZycsIGZhbHNlKTtcbiAgdGhpcy5fbGF5b3V0ZXIgPSBpbmplY3Rvci5nZXQoJ2xheW91dGVyJywgZmFsc2UpO1xufVxuXG5Db25uZWN0aW9uUHJldmlldy4kaW5qZWN0ID0gW1xuICAnaW5qZWN0b3InLFxuICAnY2FudmFzJyxcbiAgJ2dyYXBoaWNzRmFjdG9yeScsXG4gICdlbGVtZW50RmFjdG9yeSdcbl07XG5cbi8qKlxuICogRHJhdyBjb25uZWN0aW9uIHByZXZpZXcuXG4gKlxuICogUHJvdmlkZSBhdCBsZWFzdCBvbmUgb2YgPHNvdXJjZSwgY29ubmVjdGlvblN0YXJ0PiBhbmQgPHRhcmdldCwgY29ubmVjdGlvbkVuZD4gdG8gY3JlYXRlIGEgcHJldmlldy5cbiAqIEluIHRoZSBjbGVhbiB1cCBzdGFnZSwgY2FsbCBgY29ubmVjdGlvblByZXZpZXcjY2xlYW5VcGAgd2l0aCB0aGUgY29udGV4dCB0byByZW1vdmUgcHJldmlldy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gY2FuQ29ubmVjdFxuICogQHBhcmFtIHtPYmplY3R9IGhpbnRzXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5zaGFwZX0gW2hpbnRzLnNvdXJjZV0gc291cmNlIGVsZW1lbnRcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLnNoYXBlfSBbaGludHMudGFyZ2V0XSB0YXJnZXQgZWxlbWVudFxuICogQHBhcmFtIHtQb2ludH0gW2hpbnRzLmNvbm5lY3Rpb25TdGFydF0gY29ubmVjdGlvbiBwcmV2aWV3IHN0YXJ0XG4gKiBAcGFyYW0ge1BvaW50fSBbaGludHMuY29ubmVjdGlvbkVuZF0gY29ubmVjdGlvbiBwcmV2aWV3IGVuZFxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IFtoaW50cy53YXlwb2ludHNdIHByb3ZpZGVkIHdheXBvaW50cyBmb3IgcHJldmlld1xuICogQHBhcmFtIHtib29sZWFufSBbaGludHMubm9MYXlvdXRdIHRydWUgaWYgcHJldmlldyBzaG91bGQgbm90IGJlIGxhaWQgb3V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoaW50cy5ub0Nyb3BwaW5nXSB0cnVlIGlmIHByZXZpZXcgc2hvdWxkIG5vdCBiZSBjcm9wcGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoaW50cy5ub05vb3BdIHRydWUgaWYgc2ltcGxlIGNvbm5lY3Rpb24gc2hvdWxkIG5vdCBiZSBkcmF3blxuICovXG5Db25uZWN0aW9uUHJldmlldy5wcm90b3R5cGUuZHJhd1ByZXZpZXcgPSBmdW5jdGlvbihjb250ZXh0LCBjYW5Db25uZWN0LCBoaW50cykge1xuXG4gIGhpbnRzID0gaGludHMgfHwge307XG5cbiAgdmFyIGNvbm5lY3Rpb25QcmV2aWV3R2Z4ID0gY29udGV4dC5jb25uZWN0aW9uUHJldmlld0dmeCxcbiAgICAgIGdldENvbm5lY3Rpb24gPSBjb250ZXh0LmdldENvbm5lY3Rpb24sXG4gICAgICBzb3VyY2UgPSBoaW50cy5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBoaW50cy50YXJnZXQsXG4gICAgICB3YXlwb2ludHMgPSBoaW50cy53YXlwb2ludHMsXG4gICAgICBjb25uZWN0aW9uU3RhcnQgPSBoaW50cy5jb25uZWN0aW9uU3RhcnQsXG4gICAgICBjb25uZWN0aW9uRW5kID0gaGludHMuY29ubmVjdGlvbkVuZCxcbiAgICAgIG5vTGF5b3V0ID0gaGludHMubm9MYXlvdXQsXG4gICAgICBub0Nyb3BwaW5nID0gaGludHMubm9Dcm9wcGluZyxcbiAgICAgIG5vTm9vcCA9IGhpbnRzLm5vTm9vcCxcbiAgICAgIGNvbm5lY3Rpb247XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghY29ubmVjdGlvblByZXZpZXdHZngpIHtcbiAgICBjb25uZWN0aW9uUHJldmlld0dmeCA9IGNvbnRleHQuY29ubmVjdGlvblByZXZpZXdHZnggPSB0aGlzLmNyZWF0ZUNvbm5lY3Rpb25QcmV2aWV3R2Z4KCk7XG4gIH1cblxuICBzdmdDbGVhcihjb25uZWN0aW9uUHJldmlld0dmeCk7XG5cbiAgaWYgKCFnZXRDb25uZWN0aW9uKSB7XG4gICAgZ2V0Q29ubmVjdGlvbiA9IGNvbnRleHQuZ2V0Q29ubmVjdGlvbiA9IGNhY2hlUmV0dXJuVmFsdWVzKGZ1bmN0aW9uKGNhbkNvbm5lY3QsIHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc2VsZi5nZXRDb25uZWN0aW9uKGNhbkNvbm5lY3QsIHNvdXJjZSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjYW5Db25uZWN0KSB7XG4gICAgY29ubmVjdGlvbiA9IGdldENvbm5lY3Rpb24oY2FuQ29ubmVjdCwgc291cmNlLCB0YXJnZXQpO1xuICB9XG5cbiAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgIW5vTm9vcCAmJiB0aGlzLmRyYXdOb29wUHJldmlldyhjb25uZWN0aW9uUHJldmlld0dmeCwgaGludHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gd2F5cG9pbnRzIHx8IFtdO1xuXG4gIC8vIG9wdGlvbmFsIGxheW91dFxuICBpZiAodGhpcy5fbGF5b3V0ZXIgJiYgIW5vTGF5b3V0KSB7XG4gICAgY29ubmVjdGlvbi53YXlwb2ludHMgPSB0aGlzLl9sYXlvdXRlci5sYXlvdXRDb25uZWN0aW9uKGNvbm5lY3Rpb24sIHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBjb25uZWN0aW9uU3RhcnQ6IGNvbm5lY3Rpb25TdGFydCxcbiAgICAgIGNvbm5lY3Rpb25FbmQ6IGNvbm5lY3Rpb25FbmQsXG4gICAgICB3YXlwb2ludHM6IGhpbnRzLndheXBvaW50cyB8fCBjb25uZWN0aW9uLndheXBvaW50c1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZmFsbGJhY2sgaWYgbm8gd2F5cG9pbnRzIHdlcmUgcHJvdmlkZWQgbm9yIGNyZWF0ZWQgd2l0aCBsYXlvdXRlclxuICBpZiAoIWNvbm5lY3Rpb24ud2F5cG9pbnRzIHx8ICFjb25uZWN0aW9uLndheXBvaW50cy5sZW5ndGgpIHtcbiAgICBjb25uZWN0aW9uLndheXBvaW50cyA9IFtcbiAgICAgIHNvdXJjZSA/IGdldE1pZChzb3VyY2UpIDogY29ubmVjdGlvblN0YXJ0LFxuICAgICAgdGFyZ2V0ID8gZ2V0TWlkKHRhcmdldCkgOiBjb25uZWN0aW9uRW5kXG4gICAgXTtcbiAgfVxuXG4gIC8vIG9wdGlvbmFsIGNyb3BwaW5nXG4gIGlmICh0aGlzLl9jb25uZWN0aW9uRG9ja2luZyAmJiAoc291cmNlIHx8IHRhcmdldCkgJiYgIW5vQ3JvcHBpbmcpIHtcbiAgICBjb25uZWN0aW9uLndheXBvaW50cyA9IHRoaXMuX2Nvbm5lY3Rpb25Eb2NraW5nLmdldENyb3BwZWRXYXlwb2ludHMoY29ubmVjdGlvbiwgc291cmNlLCB0YXJnZXQpO1xuICB9XG5cbiAgdGhpcy5fZ3JhcGhpY3NGYWN0b3J5LmRyYXdDb25uZWN0aW9uKGNvbm5lY3Rpb25QcmV2aWV3R2Z4LCBjb25uZWN0aW9uKTtcbn07XG5cbi8qKlxuICogRHJhdyBzaW1wbGUgY29ubmVjdGlvbiBiZXR3ZWVuIHNvdXJjZSBhbmQgdGFyZ2V0IG9yIHByb3ZpZGVkIHBvaW50cy5cbiAqXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGNvbm5lY3Rpb25QcmV2aWV3R2Z4IGNvbnRhaW5lciBmb3IgdGhlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBoaW50c1xuICogQHBhcmFtIHtkanMubW9kZWwuc2hhcGV9IFtoaW50cy5zb3VyY2VdIHNvdXJjZSBlbGVtZW50XG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5zaGFwZX0gW2hpbnRzLnRhcmdldF0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7UG9pbnR9IFtoaW50cy5jb25uZWN0aW9uU3RhcnRdIHJlcXVpcmVkIGlmIHNvdXJjZSBpcyBub3QgcHJvdmlkZWRcbiAqIEBwYXJhbSB7UG9pbnR9IFtoaW50cy5jb25uZWN0aW9uRW5kXSByZXF1aXJlZCBpZiB0YXJnZXQgaXMgbm90IHByb3ZpZGVkXG4gKi9cbkNvbm5lY3Rpb25QcmV2aWV3LnByb3RvdHlwZS5kcmF3Tm9vcFByZXZpZXcgPSBmdW5jdGlvbihjb25uZWN0aW9uUHJldmlld0dmeCwgaGludHMpIHtcbiAgdmFyIHNvdXJjZSA9IGhpbnRzLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IGhpbnRzLnRhcmdldCxcbiAgICAgIHN0YXJ0ID0gaGludHMuY29ubmVjdGlvblN0YXJ0IHx8IGdldE1pZChzb3VyY2UpLFxuICAgICAgZW5kID0gaGludHMuY29ubmVjdGlvbkVuZCB8fCBnZXRNaWQodGFyZ2V0KTtcblxuICB2YXIgd2F5cG9pbnRzID0gdGhpcy5jcm9wV2F5cG9pbnRzKHN0YXJ0LCBlbmQsIHNvdXJjZSwgdGFyZ2V0KTtcblxuICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY3JlYXRlTm9vcENvbm5lY3Rpb24od2F5cG9pbnRzWzBdLCB3YXlwb2ludHNbMV0pO1xuXG4gIHN2Z0FwcGVuZChjb25uZWN0aW9uUHJldmlld0dmeCwgY29ubmVjdGlvbik7XG59O1xuXG4vKipcbiAqIFJldHVybiBjcm9wcGVkIHdheXBvaW50cy5cbiAqXG4gKiBAcGFyYW0ge1BvaW50fSBzdGFydFxuICogQHBhcmFtIHtQb2ludH0gZW5kXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5zaGFwZX0gc291cmNlXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5zaGFwZX0gdGFyZ2V0XG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG5Db25uZWN0aW9uUHJldmlldy5wcm90b3R5cGUuY3JvcFdheXBvaW50cyA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHZhciBncmFwaGljc0ZhY3RvcnkgPSB0aGlzLl9ncmFwaGljc0ZhY3RvcnksXG4gICAgICBzb3VyY2VQYXRoID0gc291cmNlICYmIGdyYXBoaWNzRmFjdG9yeS5nZXRTaGFwZVBhdGgoc291cmNlKSxcbiAgICAgIHRhcmdldFBhdGggPSB0YXJnZXQgJiYgZ3JhcGhpY3NGYWN0b3J5LmdldFNoYXBlUGF0aCh0YXJnZXQpLFxuICAgICAgY29ubmVjdGlvblBhdGggPSBncmFwaGljc0ZhY3RvcnkuZ2V0Q29ubmVjdGlvblBhdGgoeyB3YXlwb2ludHM6IFsgc3RhcnQsIGVuZCBdIH0pO1xuXG4gIHN0YXJ0ID0gKHNvdXJjZSAmJiBnZXRFbGVtZW50TGluZUludGVyc2VjdGlvbihzb3VyY2VQYXRoLCBjb25uZWN0aW9uUGF0aCwgdHJ1ZSkpIHx8IHN0YXJ0O1xuICBlbmQgPSAodGFyZ2V0ICYmIGdldEVsZW1lbnRMaW5lSW50ZXJzZWN0aW9uKHRhcmdldFBhdGgsIGNvbm5lY3Rpb25QYXRoLCBmYWxzZSkpIHx8IGVuZDtcblxuICByZXR1cm4gWyBzdGFydCwgZW5kIF07XG59O1xuXG4vKipcbiAqIFJlbW92ZSBjb25uZWN0aW9uIHByZXZpZXcgY29udGFpbmVyIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IFtjb250ZXh0LmNvbm5lY3Rpb25QcmV2aWV3R2Z4XSBwcmV2aWV3IGNvbnRhaW5lclxuICovXG5Db25uZWN0aW9uUHJldmlldy5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jb25uZWN0aW9uUHJldmlld0dmeCkge1xuICAgIHN2Z1JlbW92ZShjb250ZXh0LmNvbm5lY3Rpb25QcmV2aWV3R2Z4KTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgY29ubmVjdGlvbiB0aGF0IGNvbm5lY3RzIHNvdXJjZSBhbmQgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IGNhbkNvbm5lY3RcbiAqXG4gKiBAcmV0dXJucyB7ZGpzLm1vZGVsLmNvbm5lY3Rpb259XG4gKi9cbkNvbm5lY3Rpb25QcmV2aWV3LnByb3RvdHlwZS5nZXRDb25uZWN0aW9uID0gZnVuY3Rpb24oY2FuQ29ubmVjdCkge1xuICB2YXIgYXR0cnMgPSBlbnN1cmVDb25uZWN0aW9uQXR0cnMoY2FuQ29ubmVjdCk7XG5cbiAgcmV0dXJuIHRoaXMuX2VsZW1lbnRGYWN0b3J5LmNyZWF0ZUNvbm5lY3Rpb24oYXR0cnMpO1xufTtcblxuXG4vKipcbiAqIEFkZCBhbmQgcmV0dXJuIHByZXZpZXcgZ3JhcGhpY3MuXG4gKlxuICogQHJldHVybnMge1NWR0VsZW1lbnR9XG4gKi9cbkNvbm5lY3Rpb25QcmV2aWV3LnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uUHJldmlld0dmeCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZ2Z4ID0gc3ZnQ3JlYXRlKCdnJyk7XG5cbiAgc3ZnQXR0cihnZngsIHtcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgfSk7XG5cbiAgc3ZnQ2xhc3NlcyhnZngpLmFkZChNQVJLRVJfQ09OTkVDVElPTl9QUkVWSUVXKTtcblxuICBzdmdBcHBlbmQodGhpcy5fY2FudmFzLmdldERlZmF1bHRMYXllcigpLCBnZngpO1xuXG4gIHJldHVybiBnZng7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIHNpbXBsZSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UG9pbnR9IHN0YXJ0XG4gKiBAcGFyYW0ge1BvaW50fSBlbmRcbiAqXG4gKiBAcmV0dXJucyB7U1ZHRWxlbWVudH1cbiAqL1xuQ29ubmVjdGlvblByZXZpZXcucHJvdG90eXBlLmNyZWF0ZU5vb3BDb25uZWN0aW9uID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICB2YXIgY29ubmVjdGlvbiA9IHN2Z0NyZWF0ZSgncG9seWxpbmUnKTtcblxuICBzdmdBdHRyKGNvbm5lY3Rpb24sIHtcbiAgICAnc3Ryb2tlJzogJyMzMzMnLFxuICAgICdzdHJva2VEYXNoYXJyYXknOiBbIDEgXSxcbiAgICAnc3Ryb2tlV2lkdGgnOiAyLFxuICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJ1xuICB9KTtcblxuICBzdmdBdHRyKGNvbm5lY3Rpb24sIHsgJ3BvaW50cyc6IFsgc3RhcnQueCwgc3RhcnQueSwgZW5kLngsIGVuZC55IF0gfSk7XG5cbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cblxuLyoqXG4gKiBSZXR1cm5zIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBjYWNoZWQgcmV0dXJuIHZhbHVlcyByZWZlcmVuY2VkIGJ5IHN0cmluZ2lmaWVkIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNhY2hlUmV0dXJuVmFsdWVzKGZuKSB7XG4gIHZhciByZXR1cm5WYWx1ZXMgPSB7fTtcblxuICAvKipcbiAgICogUmV0dXJuIGNhY2hlZCByZXR1cm4gdmFsdWUgcmVmZXJlbmNlZCBieSBzdHJpbmdpZmllZCBmaXJzdCBhcmd1bWVudC5cbiAgICpcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24oZmlyc3RBcmd1bWVudCkge1xuICAgIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShmaXJzdEFyZ3VtZW50KTtcblxuICAgIHZhciByZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlc1trZXldO1xuXG4gICAgaWYgKCFyZXR1cm5WYWx1ZSkge1xuICAgICAgcmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZXNba2V5XSA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xufVxuXG4vKipcbiAqIEVuc3VyZSBjb25uZWN0aW9uIGF0dHJpYnV0ZXMgaXMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IGNhbkNvbm5lY3RcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBlbnN1cmVDb25uZWN0aW9uQXR0cnMoY2FuQ29ubmVjdCkge1xuICBpZiAoaXNPYmplY3QoY2FuQ29ubmVjdCkpIHtcbiAgICByZXR1cm4gY2FuQ29ubmVjdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbiIsImltcG9ydCBDb25uZWN0aW9uUHJldmlldyBmcm9tICcuL0Nvbm5lY3Rpb25QcmV2aWV3JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAnY29ubmVjdGlvblByZXZpZXcnIF0sXG4gIGNvbm5lY3Rpb25QcmV2aWV3OiBbICd0eXBlJywgQ29ubmVjdGlvblByZXZpZXcgXVxufTtcbiIsImltcG9ydCB7XG4gIGFzc2lnbixcbiAgaXNGdW5jdGlvbixcbiAgaXNBcnJheSxcbiAgZm9yRWFjaCxcbiAgaXNEZWZpbmVkXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZGVsZWdhdGUgYXMgZG9tRGVsZWdhdGUsXG4gIGV2ZW50IGFzIGRvbUV2ZW50LFxuICBhdHRyIGFzIGRvbUF0dHIsXG4gIHF1ZXJ5IGFzIGRvbVF1ZXJ5LFxuICBjbGFzc2VzIGFzIGRvbUNsYXNzZXMsXG4gIGRvbWlmeSBhcyBkb21pZnlcbn0gZnJvbSAnbWluLWRvbSc7XG5cbnZhciBlbnRyeVNlbGVjdG9yID0gJy5lbnRyeSc7XG5cbnZhciBERUZBVUxUX1BSSU9SSVRZID0gMTAwMDtcblxuXG4vKipcbiAqIEEgY29udGV4dCBwYWQgdGhhdCBkaXNwbGF5cyBlbGVtZW50IHNwZWNpZmljLCBjb250ZXh0dWFsIGFjdGlvbnMgbmV4dFxuICogdG8gYSBkaWFncmFtIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtib29sZWFufE9iamVjdH0gW2NvbmZpZy5zY2FsZT17IG1pbjogMS4wLCBtYXg6IDEuNSB9XVxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuc2NhbGUubWluXVxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuc2NhbGUubWF4XVxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7T3ZlcmxheXN9IG92ZXJsYXlzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbnRleHRQYWQoY29uZmlnLCBldmVudEJ1cywgb3ZlcmxheXMpIHtcblxuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICB0aGlzLl9vdmVybGF5cyA9IG92ZXJsYXlzO1xuXG4gIHZhciBzY2FsZSA9IGlzRGVmaW5lZChjb25maWcgJiYgY29uZmlnLnNjYWxlKSA/IGNvbmZpZy5zY2FsZSA6IHtcbiAgICBtaW46IDEsXG4gICAgbWF4OiAxLjVcbiAgfTtcblxuICB0aGlzLl9vdmVybGF5c0NvbmZpZyA9IHtcbiAgICBwb3NpdGlvbjoge1xuICAgICAgcmlnaHQ6IC05LFxuICAgICAgdG9wOiAtNlxuICAgIH0sXG4gICAgc2NhbGU6IHNjYWxlXG4gIH07XG5cbiAgdGhpcy5fY3VycmVudCA9IG51bGw7XG5cbiAgdGhpcy5faW5pdCgpO1xufVxuXG5Db250ZXh0UGFkLiRpbmplY3QgPSBbXG4gICdjb25maWcuY29udGV4dFBhZCcsXG4gICdldmVudEJ1cycsXG4gICdvdmVybGF5cydcbl07XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgZXZlbnRzIG5lZWRlZCBmb3IgaW50ZXJhY3Rpb24gd2l0aCBvdGhlciBjb21wb25lbnRzXG4gKi9cbkNvbnRleHRQYWQucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGV2ZW50QnVzLm9uKCdzZWxlY3Rpb24uY2hhbmdlZCcsIGZ1bmN0aW9uKGUpIHtcblxuICAgIHZhciBzZWxlY3Rpb24gPSBlLm5ld1NlbGVjdGlvbjtcblxuICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoID09PSAxKSB7XG4gICAgICBzZWxmLm9wZW4oc2VsZWN0aW9uWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2VsZW1lbnRzLmRlbGV0ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnRzID0gZXZlbnQuZWxlbWVudHM7XG5cbiAgICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoc2VsZi5pc09wZW4oZSkpIHtcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignZWxlbWVudC5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQsXG4gICAgICAgIGN1cnJlbnQgPSBzZWxmLl9jdXJyZW50O1xuXG4gICAgLy8gZm9yY2UgcmVvcGVuIGlmIGVsZW1lbnQgZm9yIHdoaWNoIHdlIGFyZSBjdXJyZW50bHkgb3BlbmVkIGNoYW5nZWRcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICAgIHNlbGYub3BlbihlbGVtZW50LCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgcHJvdmlkZXIgd2l0aCB0aGUgY29udGV4dCBwYWRcbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXVxuICogQHBhcmFtICB7Q29udGV4dFBhZFByb3ZpZGVyfSBwcm92aWRlclxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBjb250ZXh0UGFkUHJvdmlkZXIgPSB7XG4gICogICBnZXRDb250ZXh0UGFkRW50cmllczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAqICAgICByZXR1cm4gZnVuY3Rpb24oZW50cmllcykge1xuICAqICAgICAgIHJldHVybiB7XG4gICogICAgICAgICAuLi5lbnRyaWVzLFxuICAqICAgICAgICAgJ2VudHJ5LTEnOiB7XG4gICogICAgICAgICAgIGxhYmVsOiAnTXkgRW50cnknLFxuICAqICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkgeyBhbGVydChcIkkgaGF2ZSBiZWVuIGNsaWNrZWQhXCIpOyB9XG4gICogICAgICAgICB9XG4gICogICAgICAgfTtcbiAgKiAgICAgfVxuICAqICAgfVxuICAqIH07XG4gICpcbiAqIGNvbnRleHRQYWQucmVnaXN0ZXJQcm92aWRlcig4MDAsIGNvbnRleHRQYWRQcm92aWRlcik7XG4gKi9cbkNvbnRleHRQYWQucHJvdG90eXBlLnJlZ2lzdGVyUHJvdmlkZXIgPSBmdW5jdGlvbihwcmlvcml0eSwgcHJvdmlkZXIpIHtcbiAgaWYgKCFwcm92aWRlcikge1xuICAgIHByb3ZpZGVyID0gcHJpb3JpdHk7XG4gICAgcHJpb3JpdHkgPSBERUZBVUxUX1BSSU9SSVRZO1xuICB9XG5cbiAgdGhpcy5fZXZlbnRCdXMub24oJ2NvbnRleHRQYWQuZ2V0UHJvdmlkZXJzJywgcHJpb3JpdHksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgZXZlbnQucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZXh0IHBhZCBlbnRyaWVzIGZvciBhIGdpdmVuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge2Rqcy5lbGVtZW50LkJhc2V9IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxDb250ZXh0UGFkRW50cnlEZXNjcmlwdG9yPn0gbGlzdCBvZiBlbnRyaWVzXG4gKi9cbkNvbnRleHRQYWQucHJvdG90eXBlLmdldEVudHJpZXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBwcm92aWRlcnMgPSB0aGlzLl9nZXRQcm92aWRlcnMoKTtcblxuICB2YXIgZW50cmllcyA9IHt9O1xuXG4gIC8vIGxvb3AgdGhyb3VnaCBhbGwgcHJvdmlkZXJzIGFuZCB0aGVpciBlbnRyaWVzLlxuICAvLyBncm91cCBlbnRyaWVzIGJ5IGlkIHNvIHRoYXQgb3ZlcnJpZGluZyBhbiBlbnRyeSBpcyBwb3NzaWJsZVxuICBmb3JFYWNoKHByb3ZpZGVycywgZnVuY3Rpb24ocHJvdmlkZXIpIHtcbiAgICB2YXIgZW50cmllc09yVXBkYXRlciA9IHByb3ZpZGVyLmdldENvbnRleHRQYWRFbnRyaWVzKGVsZW1lbnQpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZW50cmllc09yVXBkYXRlcikpIHtcbiAgICAgIGVudHJpZXMgPSBlbnRyaWVzT3JVcGRhdGVyKGVudHJpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoKGVudHJpZXNPclVwZGF0ZXIsIGZ1bmN0aW9uKGVudHJ5LCBpZCkge1xuICAgICAgICBlbnRyaWVzW2lkXSA9IGVudHJ5O1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZW50cmllcztcbn07XG5cblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGFjdGlvbiBhdmFpbGFibGUgb24gdGhlIG9wZW5lZCBjb250ZXh0IHBhZFxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gYWN0aW9uXG4gKiBAcGFyYW0gIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSAge2Jvb2xlYW59IFthdXRvQWN0aXZhdGU9ZmFsc2VdXG4gKi9cbkNvbnRleHRQYWQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihhY3Rpb24sIGV2ZW50LCBhdXRvQWN0aXZhdGUpIHtcblxuICB2YXIgZWxlbWVudCA9IHRoaXMuX2N1cnJlbnQuZWxlbWVudCxcbiAgICAgIGVudHJpZXMgPSB0aGlzLl9jdXJyZW50LmVudHJpZXMsXG4gICAgICBlbnRyeSxcbiAgICAgIGhhbmRsZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50LFxuICAgICAgYnV0dG9uID0gZXZlbnQuZGVsZWdhdGVUYXJnZXQgfHwgZXZlbnQudGFyZ2V0O1xuXG4gIGlmICghYnV0dG9uKSB7XG4gICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBlbnRyeSA9IGVudHJpZXNbZG9tQXR0cihidXR0b24sICdkYXRhLWFjdGlvbicpXTtcbiAgaGFuZGxlciA9IGVudHJ5LmFjdGlvbjtcblxuICBvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudDtcblxuICAvLyBzaW1wbGUgYWN0aW9uICh2aWEgY2FsbGJhY2sgZnVuY3Rpb24pXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgaWYgKGFjdGlvbiA9PT0gJ2NsaWNrJykge1xuICAgICAgcmV0dXJuIGhhbmRsZXIob3JpZ2luYWxFdmVudCwgZWxlbWVudCwgYXV0b0FjdGl2YXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGhhbmRsZXJbYWN0aW9uXSkge1xuICAgICAgcmV0dXJuIGhhbmRsZXJbYWN0aW9uXShvcmlnaW5hbEV2ZW50LCBlbGVtZW50LCBhdXRvQWN0aXZhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNpbGVuY2Ugb3RoZXIgYWN0aW9uc1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuXG4vKipcbiAqIE9wZW4gdGhlIGNvbnRleHQgcGFkIGZvciB0aGUgZ2l2ZW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgaWYgdHJ1ZSwgZm9yY2UgcmVvcGVuaW5nIHRoZSBjb250ZXh0IHBhZFxuICovXG5Db250ZXh0UGFkLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oZWxlbWVudCwgZm9yY2UpIHtcbiAgaWYgKCFmb3JjZSAmJiB0aGlzLmlzT3BlbihlbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuY2xvc2UoKTtcbiAgdGhpcy5fdXBkYXRlQW5kT3BlbihlbGVtZW50KTtcbn07XG5cbkNvbnRleHRQYWQucHJvdG90eXBlLl9nZXRQcm92aWRlcnMgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgZXZlbnQgPSB0aGlzLl9ldmVudEJ1cy5jcmVhdGVFdmVudCh7XG4gICAgdHlwZTogJ2NvbnRleHRQYWQuZ2V0UHJvdmlkZXJzJyxcbiAgICBwcm92aWRlcnM6IFtdXG4gIH0pO1xuXG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoZXZlbnQpO1xuXG4gIHJldHVybiBldmVudC5wcm92aWRlcnM7XG59O1xuXG5Db250ZXh0UGFkLnByb3RvdHlwZS5fdXBkYXRlQW5kT3BlbiA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICB2YXIgZW50cmllcyA9IHRoaXMuZ2V0RW50cmllcyhlbGVtZW50KSxcbiAgICAgIHBhZCA9IHRoaXMuZ2V0UGFkKGVsZW1lbnQpLFxuICAgICAgaHRtbCA9IHBhZC5odG1sO1xuXG4gIGZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnksIGlkKSB7XG4gICAgdmFyIGdyb3VwaW5nID0gZW50cnkuZ3JvdXAgfHwgJ2RlZmF1bHQnLFxuICAgICAgICBjb250cm9sID0gZG9taWZ5KGVudHJ5Lmh0bWwgfHwgJzxkaXYgY2xhc3M9XCJlbnRyeVwiIGRyYWdnYWJsZT1cInRydWVcIj48L2Rpdj4nKSxcbiAgICAgICAgY29udGFpbmVyO1xuXG4gICAgZG9tQXR0cihjb250cm9sLCAnZGF0YS1hY3Rpb24nLCBpZCk7XG5cbiAgICBjb250YWluZXIgPSBkb21RdWVyeSgnW2RhdGEtZ3JvdXA9JyArIGdyb3VwaW5nICsgJ10nLCBodG1sKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyID0gZG9taWZ5KCc8ZGl2IGNsYXNzPVwiZ3JvdXBcIiBkYXRhLWdyb3VwPVwiJyArIGdyb3VwaW5nICsgJ1wiPjwvZGl2PicpO1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIH1cblxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sKTtcblxuICAgIGlmIChlbnRyeS5jbGFzc05hbWUpIHtcbiAgICAgIGFkZENsYXNzZXMoY29udHJvbCwgZW50cnkuY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZW50cnkudGl0bGUpIHtcbiAgICAgIGRvbUF0dHIoY29udHJvbCwgJ3RpdGxlJywgZW50cnkudGl0bGUpO1xuICAgIH1cblxuICAgIGlmIChlbnRyeS5pbWFnZVVybCkge1xuICAgICAgY29udHJvbC5hcHBlbmRDaGlsZChkb21pZnkoJzxpbWcgc3JjPVwiJyArIGVudHJ5LmltYWdlVXJsICsgJ1wiPicpKTtcbiAgICB9XG4gIH0pO1xuXG4gIGRvbUNsYXNzZXMoaHRtbCkuYWRkKCdvcGVuJyk7XG5cbiAgdGhpcy5fY3VycmVudCA9IHtcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIHBhZDogcGFkLFxuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfTtcblxuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjb250ZXh0UGFkLm9wZW4nLCB7IGN1cnJlbnQ6IHRoaXMuX2N1cnJlbnQgfSk7XG59O1xuXG5cbkNvbnRleHRQYWQucHJvdG90eXBlLmdldFBhZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudC5wYWQ7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIG92ZXJsYXlzID0gdGhpcy5fb3ZlcmxheXM7XG5cbiAgdmFyIGh0bWwgPSBkb21pZnkoJzxkaXYgY2xhc3M9XCJkanMtY29udGV4dC1wYWRcIj48L2Rpdj4nKTtcblxuICB2YXIgb3ZlcmxheXNDb25maWcgPSBhc3NpZ24oe1xuICAgIGh0bWw6IGh0bWxcbiAgfSwgdGhpcy5fb3ZlcmxheXNDb25maWcpO1xuXG4gIGRvbURlbGVnYXRlLmJpbmQoaHRtbCwgZW50cnlTZWxlY3RvciwgJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBzZWxmLnRyaWdnZXIoJ2NsaWNrJywgZXZlbnQpO1xuICB9KTtcblxuICBkb21EZWxlZ2F0ZS5iaW5kKGh0bWwsIGVudHJ5U2VsZWN0b3IsICdkcmFnc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHNlbGYudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXZlbnQpO1xuICB9KTtcblxuICAvLyBzdG9wIHByb3BhZ2F0aW9uIG9mIG1vdXNlIGV2ZW50c1xuICBkb21FdmVudC5iaW5kKGh0bWwsICdtb3VzZWRvd24nLCBmdW5jdGlvbihldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcblxuICB0aGlzLl9vdmVybGF5SWQgPSBvdmVybGF5cy5hZGQoZWxlbWVudCwgJ2NvbnRleHQtcGFkJywgb3ZlcmxheXNDb25maWcpO1xuXG4gIHZhciBwYWQgPSBvdmVybGF5cy5nZXQodGhpcy5fb3ZlcmxheUlkKTtcblxuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjb250ZXh0UGFkLmNyZWF0ZScsIHsgZWxlbWVudDogZWxlbWVudCwgcGFkOiBwYWQgfSk7XG5cbiAgcmV0dXJuIHBhZDtcbn07XG5cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29udGV4dCBwYWRcbiAqL1xuQ29udGV4dFBhZC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmlzT3BlbigpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fb3ZlcmxheXMucmVtb3ZlKHRoaXMuX292ZXJsYXlJZCk7XG5cbiAgdGhpcy5fb3ZlcmxheUlkID0gbnVsbDtcblxuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjb250ZXh0UGFkLmNsb3NlJywgeyBjdXJyZW50OiB0aGlzLl9jdXJyZW50IH0pO1xuXG4gIHRoaXMuX2N1cnJlbnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBwYWQgaXMgb3Blbi4gSWYgZWxlbWVudCBpcyBnaXZlbiwgd2lsbCBjaGVja1xuICogaWYgcGFkIGlzIG9wZW5lZCB3aXRoIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5Db250ZXh0UGFkLnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiAhIXRoaXMuX2N1cnJlbnQgJiYgKCFlbGVtZW50ID8gdHJ1ZSA6IHRoaXMuX2N1cnJlbnQuZWxlbWVudCA9PT0gZWxlbWVudCk7XG59O1xuXG5cblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gYWRkQ2xhc3NlcyhlbGVtZW50LCBjbGFzc05hbWVzKSB7XG5cbiAgdmFyIGNsYXNzZXMgPSBkb21DbGFzc2VzKGVsZW1lbnQpO1xuXG4gIHZhciBhY3R1YWxDbGFzc05hbWVzID0gaXNBcnJheShjbGFzc05hbWVzKSA/IGNsYXNzTmFtZXMgOiBjbGFzc05hbWVzLnNwbGl0KC9cXHMrL2cpO1xuICBhY3R1YWxDbGFzc05hbWVzLmZvckVhY2goZnVuY3Rpb24oY2xzKSB7XG4gICAgY2xhc3Nlcy5hZGQoY2xzKTtcbiAgfSk7XG59IiwiaW1wb3J0IEludGVyYWN0aW9uRXZlbnRzTW9kdWxlIGZyb20gJy4uL2ludGVyYWN0aW9uLWV2ZW50cyc7XG5pbXBvcnQgT3ZlcmxheXNNb2R1bGUgZnJvbSAnLi4vb3ZlcmxheXMnO1xuXG5pbXBvcnQgQ29udGV4dFBhZCBmcm9tICcuL0NvbnRleHRQYWQnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBJbnRlcmFjdGlvbkV2ZW50c01vZHVsZSxcbiAgICBPdmVybGF5c01vZHVsZVxuICBdLFxuICBjb250ZXh0UGFkOiBbICd0eXBlJywgQ29udGV4dFBhZCBdXG59OyIsImltcG9ydCB7XG4gIGFzc2lnbixcbiAgZmluZCxcbiAgZm9yRWFjaCxcbiAgaXNBcnJheSxcbiAgaXNOdW1iZXIsXG4gIG1hcCxcbiAgbWF0Y2hQYXR0ZXJuLFxuICBvbWl0LFxuICBzb3J0Qnlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRCQm94LFxuICBnZXRQYXJlbnRzXG59IGZyb20gJy4uLy4uL3V0aWwvRWxlbWVudHMnO1xuXG5pbXBvcnQgeyBlYWNoRWxlbWVudCB9IGZyb20gJy4uLy4uL3V0aWwvRWxlbWVudHMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtGdW5jdGlvbn0gPGNvcHlQYXN0ZS5jYW5Db3B5RWxlbWVudHM+IGxpc3RlbmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBjb250ZXh0LmVsZW1lbnRzXG4gKlxuICogQHJldHVybnMge0FycmF5PGRqcy5tb2RlbC5CYXNlPnxib29sZWFufSAtIFJldHVybiBlbGVtZW50cyB0byBiZSBjb3BpZWQgb3IgZmFsc2UgdG8gZGlzYWxsb3dcbiAqIGNvcHlpbmcuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RnVuY3Rpb259IDxjb3B5UGFzdGUuY29weUVsZW1lbnQ+IGxpc3RlbmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0LmRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGNvbnRleHQuZWxlbWVudFxuICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGNvbnRleHQuZWxlbWVudHNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtGdW5jdGlvbn0gPGNvcHlQYXN0ZS5lbGVtZW50c0NvcGllZD4gbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQuZWxlbWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0LnRyZWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtGdW5jdGlvbn0gPGNvcHlQYXN0ZS5wYXN0ZUVsZW1lbnQ+IGxpc3RlbmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0LmNhY2hlIC0gQWxyZWFkeSBjcmVhdGVkIGVsZW1lbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQuZGVzY3JpcHRvclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSA8Y29weVBhc3RlLnBhc3RlRWxlbWVudHM+IGxpc3RlbmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0LmhpbnRzIC0gQWRkIGhpbnRzIGJlZm9yZSBwYXN0aW5nLlxuICovXG5cbi8qKlxuICogQ29weSBhbmQgcGFzdGUgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtDcmVhdGV9IGNyZWF0ZVxuICogQHBhcmFtIHtDbGlwYm9hcmR9IGNsaXBib2FyZFxuICogQHBhcmFtIHtFbGVtZW50RmFjdG9yeX0gZWxlbWVudEZhY3RvcnlcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge01vZGVsaW5nfSBtb2RlbGluZ1xuICogQHBhcmFtIHtNb3VzZX0gbW91c2VcbiAqIEBwYXJhbSB7UnVsZXN9IHJ1bGVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvcHlQYXN0ZShcbiAgICBjYW52YXMsXG4gICAgY3JlYXRlLFxuICAgIGNsaXBib2FyZCxcbiAgICBlbGVtZW50RmFjdG9yeSxcbiAgICBldmVudEJ1cyxcbiAgICBtb2RlbGluZyxcbiAgICBtb3VzZSxcbiAgICBydWxlc1xuKSB7XG5cbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICB0aGlzLl9jcmVhdGUgPSBjcmVhdGU7XG4gIHRoaXMuX2NsaXBib2FyZCA9IGNsaXBib2FyZDtcbiAgdGhpcy5fZWxlbWVudEZhY3RvcnkgPSBlbGVtZW50RmFjdG9yeTtcbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbiAgdGhpcy5fbW91c2UgPSBtb3VzZTtcbiAgdGhpcy5fcnVsZXMgPSBydWxlcztcblxuICBldmVudEJ1cy5vbignY29weVBhc3RlLmNvcHlFbGVtZW50JywgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gY29udGV4dC5kZXNjcmlwdG9yLFxuICAgICAgICBlbGVtZW50ID0gY29udGV4dC5lbGVtZW50LFxuICAgICAgICBlbGVtZW50cyA9IGNvbnRleHQuZWxlbWVudHM7XG5cbiAgICAvLyBkZWZhdWx0IHByaW9yaXR5IChwcmlvcml0eSA9IDEpXG4gICAgZGVzY3JpcHRvci5wcmlvcml0eSA9IDE7XG5cbiAgICBkZXNjcmlwdG9yLmlkID0gZWxlbWVudC5pZDtcblxuICAgIHZhciBwYXJlbnRDb3BpZWQgPSBmaW5kKGVsZW1lbnRzLCBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gZSA9PT0gZWxlbWVudC5wYXJlbnQ7XG4gICAgfSk7XG5cbiAgICAvLyBkbyBOT1QgcmVmZXJlbmNlIHBhcmVudCBpZiBwYXJlbnQgd2Fzbid0IGNvcGllZFxuICAgIGlmIChwYXJlbnRDb3BpZWQpIHtcbiAgICAgIGRlc2NyaXB0b3IucGFyZW50ID0gZWxlbWVudC5wYXJlbnQuaWQ7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoZXJzIChwcmlvcml0eSA9IDIpXG4gICAgaWYgKGlzQXR0YWNoZXIoZWxlbWVudCkpIHtcbiAgICAgIGRlc2NyaXB0b3IucHJpb3JpdHkgPSAyO1xuXG4gICAgICBkZXNjcmlwdG9yLmhvc3QgPSBlbGVtZW50Lmhvc3QuaWQ7XG4gICAgfVxuXG4gICAgLy8gY29ubmVjdGlvbnMgKHByaW9yaXR5ID0gMylcbiAgICBpZiAoaXNDb25uZWN0aW9uKGVsZW1lbnQpKSB7XG4gICAgICBkZXNjcmlwdG9yLnByaW9yaXR5ID0gMztcblxuICAgICAgZGVzY3JpcHRvci5zb3VyY2UgPSBlbGVtZW50LnNvdXJjZS5pZDtcbiAgICAgIGRlc2NyaXB0b3IudGFyZ2V0ID0gZWxlbWVudC50YXJnZXQuaWQ7XG5cbiAgICAgIGRlc2NyaXB0b3Iud2F5cG9pbnRzID0gY29weVdheXBvaW50cyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBsYWJlbHMgKHByaW9yaXR5ID0gNClcbiAgICBpZiAoaXNMYWJlbChlbGVtZW50KSkge1xuICAgICAgZGVzY3JpcHRvci5wcmlvcml0eSA9IDQ7XG5cbiAgICAgIGRlc2NyaXB0b3IubGFiZWxUYXJnZXQgPSBlbGVtZW50LmxhYmVsVGFyZ2V0LmlkO1xuICAgIH1cblxuICAgIGZvckVhY2goWyAneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcgXSwgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIGlmIChpc051bWJlcihlbGVtZW50WyBwcm9wZXJ0eSBdKSkge1xuICAgICAgICBkZXNjcmlwdG9yWyBwcm9wZXJ0eSBdID0gZWxlbWVudFsgcHJvcGVydHkgXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlc2NyaXB0b3IuaGlkZGVuID0gZWxlbWVudC5oaWRkZW47XG4gICAgZGVzY3JpcHRvci5jb2xsYXBzZWQgPSBlbGVtZW50LmNvbGxhcHNlZDtcblxuICB9KTtcblxuICBldmVudEJ1cy5vbignY29weVBhc3RlLnBhc3RlRWxlbWVudHMnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIGhpbnRzID0gY29udGV4dC5oaW50cztcblxuICAgIGFzc2lnbihoaW50cywge1xuICAgICAgY3JlYXRlRWxlbWVudHNCZWhhdmlvcjogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG59XG5cbkNvcHlQYXN0ZS4kaW5qZWN0ID0gW1xuICAnY2FudmFzJyxcbiAgJ2NyZWF0ZScsXG4gICdjbGlwYm9hcmQnLFxuICAnZWxlbWVudEZhY3RvcnknLFxuICAnZXZlbnRCdXMnLFxuICAnbW9kZWxpbmcnLFxuICAnbW91c2UnLFxuICAncnVsZXMnXG5dO1xuXG5cbi8qKlxuICogQ29weSBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZWxlbWVudHNcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5Db3B5UGFzdGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihlbGVtZW50cykge1xuICB2YXIgYWxsb3dlZCxcbiAgICAgIHRyZWU7XG5cbiAgaWYgKCFpc0FycmF5KGVsZW1lbnRzKSkge1xuICAgIGVsZW1lbnRzID0gZWxlbWVudHMgPyBbIGVsZW1lbnRzIF0gOiBbXTtcbiAgfVxuXG4gIGFsbG93ZWQgPSB0aGlzLl9ldmVudEJ1cy5maXJlKCdjb3B5UGFzdGUuY2FuQ29weUVsZW1lbnRzJywge1xuICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICB9KTtcblxuICBpZiAoYWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICB0cmVlID0ge307XG4gIH0gZWxzZSB7XG4gICAgdHJlZSA9IHRoaXMuY3JlYXRlVHJlZShpc0FycmF5KGFsbG93ZWQpID8gYWxsb3dlZCA6IGVsZW1lbnRzKTtcbiAgfVxuXG4gIC8vIHdlIHNldCBhbiBlbXB0eSB0cmVlLCBzZWxlY3Rpb24gb2YgZWxlbWVudHNcbiAgLy8gdG8gY29weSB3YXMgZW1wdHkuXG4gIHRoaXMuX2NsaXBib2FyZC5zZXQodHJlZSk7XG5cbiAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnY29weVBhc3RlLmVsZW1lbnRzQ29waWVkJywge1xuICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICB0cmVlOiB0cmVlXG4gIH0pO1xuXG4gIHJldHVybiB0cmVlO1xufTtcblxuLyoqXG4gKiBQYXN0ZSBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5iYXNlfSBbY29udGV4dC5lbGVtZW50XSAtIFBhcmVudC5cbiAqIEBwYXJhbSB7UG9pbnR9IFtjb250ZXh0LnBvaW50XSAtIFBvc2l0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0LmhpbnRzXSAtIEhpbnRzLlxuICovXG5Db3B5UGFzdGUucHJvdG90eXBlLnBhc3RlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgdHJlZSA9IHRoaXMuX2NsaXBib2FyZC5nZXQoKTtcblxuICBpZiAodGhpcy5fY2xpcGJvYXJkLmlzRW1wdHkoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBoaW50cyA9IGNvbnRleHQgJiYgY29udGV4dC5oaW50cyB8fCB7fTtcblxuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjb3B5UGFzdGUucGFzdGVFbGVtZW50cycsIHtcbiAgICBoaW50czogaGludHNcbiAgfSk7XG5cbiAgdmFyIGVsZW1lbnRzID0gdGhpcy5fY3JlYXRlRWxlbWVudHModHJlZSk7XG5cbiAgLy8gcGFzdGUgZGlyZWN0bHlcbiAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5lbGVtZW50ICYmIGNvbnRleHQucG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFzdGUoZWxlbWVudHMsIGNvbnRleHQuZWxlbWVudCwgY29udGV4dC5wb2ludCwgaGludHMpO1xuICB9XG5cbiAgdGhpcy5fY3JlYXRlLnN0YXJ0KHRoaXMuX21vdXNlLmdldExhc3RNb3ZlRXZlbnQoKSwgZWxlbWVudHMsIHtcbiAgICBoaW50czogaGludHMgfHwge31cbiAgfSk7XG59O1xuXG4vKipcbiAqIFBhc3RlIGVsZW1lbnRzIGRpcmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBlbGVtZW50c1xuICogQHBhcmFtIHtkanMubW9kZWwuYmFzZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtoaW50c11cbiAqL1xuQ29weVBhc3RlLnByb3RvdHlwZS5fcGFzdGUgPSBmdW5jdGlvbihlbGVtZW50cywgdGFyZ2V0LCBwb3NpdGlvbiwgaGludHMpIHtcblxuICAvLyBtYWtlIHN1cmUgZWFjaCBlbGVtZW50IGhhcyB4IGFuZCB5XG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoIWlzTnVtYmVyKGVsZW1lbnQueCkpIHtcbiAgICAgIGVsZW1lbnQueCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCFpc051bWJlcihlbGVtZW50LnkpKSB7XG4gICAgICBlbGVtZW50LnkgPSAwO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGJib3ggPSBnZXRCQm94KGVsZW1lbnRzKTtcblxuICAvLyBjZW50ZXIgZWxlbWVudHMgYXJvdW5kIGN1cnNvclxuICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKGlzQ29ubmVjdGlvbihlbGVtZW50KSkge1xuICAgICAgZWxlbWVudC53YXlwb2ludHMgPSBtYXAoZWxlbWVudC53YXlwb2ludHMsIGZ1bmN0aW9uKHdheXBvaW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogd2F5cG9pbnQueCAtIGJib3gueCAtIGJib3gud2lkdGggLyAyLFxuICAgICAgICAgIHk6IHdheXBvaW50LnkgLSBiYm94LnkgLSBiYm94LmhlaWdodCAvIDJcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzc2lnbihlbGVtZW50LCB7XG4gICAgICB4OiBlbGVtZW50LnggLSBiYm94LnggLSBiYm94LndpZHRoIC8gMixcbiAgICAgIHk6IGVsZW1lbnQueSAtIGJib3gueSAtIGJib3guaGVpZ2h0IC8gMlxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGhpcy5fbW9kZWxpbmcuY3JlYXRlRWxlbWVudHMoZWxlbWVudHMsIHBvc2l0aW9uLCB0YXJnZXQsIGFzc2lnbih7fSwgaGludHMpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGVsZW1lbnRzIGZyb20gdHJlZS5cbiAqL1xuQ29weVBhc3RlLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudHMgPSBmdW5jdGlvbih0cmVlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICB2YXIgY2FjaGUgPSB7fTtcblxuICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICBmb3JFYWNoKHRyZWUsIGZ1bmN0aW9uKGJyYW5jaCwgZGVwdGgpIHtcblxuICAgIGRlcHRoID0gcGFyc2VJbnQoZGVwdGgsIDEwKTtcblxuICAgIC8vIHNvcnQgYnkgcHJpb3JpdHlcbiAgICBicmFuY2ggPSBzb3J0QnkoYnJhbmNoLCAncHJpb3JpdHknKTtcblxuICAgIGZvckVhY2goYnJhbmNoLCBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG5cbiAgICAgIC8vIHJlbW92ZSBwcmlvcml0eVxuICAgICAgdmFyIGF0dHJzID0gYXNzaWduKHt9LCBvbWl0KGRlc2NyaXB0b3IsIFsgJ3ByaW9yaXR5JyBdKSk7XG5cbiAgICAgIGlmIChjYWNoZVsgZGVzY3JpcHRvci5wYXJlbnQgXSkge1xuICAgICAgICBhdHRycy5wYXJlbnQgPSBjYWNoZVsgZGVzY3JpcHRvci5wYXJlbnQgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBhdHRycy5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50QnVzLmZpcmUoJ2NvcHlQYXN0ZS5wYXN0ZUVsZW1lbnQnLCB7XG4gICAgICAgIGNhY2hlOiBjYWNoZSxcbiAgICAgICAgZGVzY3JpcHRvcjogYXR0cnNcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZWxlbWVudDtcblxuICAgICAgaWYgKGlzQ29ubmVjdGlvbihhdHRycykpIHtcbiAgICAgICAgYXR0cnMuc291cmNlID0gY2FjaGVbIGRlc2NyaXB0b3Iuc291cmNlIF07XG4gICAgICAgIGF0dHJzLnRhcmdldCA9IGNhY2hlWyBkZXNjcmlwdG9yLnRhcmdldCBdO1xuXG4gICAgICAgIGVsZW1lbnQgPSBjYWNoZVsgZGVzY3JpcHRvci5pZCBdID0gc2VsZi5jcmVhdGVDb25uZWN0aW9uKGF0dHJzKTtcblxuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTGFiZWwoYXR0cnMpKSB7XG4gICAgICAgIGF0dHJzLmxhYmVsVGFyZ2V0ID0gY2FjaGVbIGF0dHJzLmxhYmVsVGFyZ2V0IF07XG5cbiAgICAgICAgZWxlbWVudCA9IGNhY2hlWyBkZXNjcmlwdG9yLmlkIF0gPSBzZWxmLmNyZWF0ZUxhYmVsKGF0dHJzKTtcblxuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJzLmhvc3QpIHtcbiAgICAgICAgYXR0cnMuaG9zdCA9IGNhY2hlWyBhdHRycy5ob3N0IF07XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSBjYWNoZVsgZGVzY3JpcHRvci5pZCBdID0gc2VsZi5jcmVhdGVTaGFwZShhdHRycyk7XG5cbiAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgcmV0dXJuIGVsZW1lbnRzO1xufTtcblxuQ29weVBhc3RlLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLl9lbGVtZW50RmFjdG9yeS5jcmVhdGVDb25uZWN0aW9uKG9taXQoYXR0cnMsIFsgJ2lkJyBdKSk7XG5cbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG5Db3B5UGFzdGUucHJvdG90eXBlLmNyZWF0ZUxhYmVsID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgdmFyIGxhYmVsID0gdGhpcy5fZWxlbWVudEZhY3RvcnkuY3JlYXRlTGFiZWwob21pdChhdHRycywgWyAnaWQnIF0pKTtcblxuICByZXR1cm4gbGFiZWw7XG59O1xuXG5Db3B5UGFzdGUucHJvdG90eXBlLmNyZWF0ZVNoYXBlID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgdmFyIHNoYXBlID0gdGhpcy5fZWxlbWVudEZhY3RvcnkuY3JlYXRlU2hhcGUob21pdChhdHRycywgWyAnaWQnIF0pKTtcblxuICByZXR1cm4gc2hhcGU7XG59O1xuXG4vKipcbiAqIENoZWNrIHdldGhlciBlbGVtZW50IGhhcyByZWxhdGlvbnMgdG8gb3RoZXIgZWxlbWVudHMgZS5nLiBhdHRhY2hlcnMsIGxhYmVscyBhbmQgY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBlbGVtZW50XG4gKiBAcGFyYW0gIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkNvcHlQYXN0ZS5wcm90b3R5cGUuaGFzUmVsYXRpb25zID0gZnVuY3Rpb24oZWxlbWVudCwgZWxlbWVudHMpIHtcbiAgdmFyIGxhYmVsVGFyZ2V0LFxuICAgICAgc291cmNlLFxuICAgICAgdGFyZ2V0O1xuXG4gIGlmIChpc0Nvbm5lY3Rpb24oZWxlbWVudCkpIHtcbiAgICBzb3VyY2UgPSBmaW5kKGVsZW1lbnRzLCBtYXRjaFBhdHRlcm4oeyBpZDogZWxlbWVudC5zb3VyY2UuaWQgfSkpO1xuICAgIHRhcmdldCA9IGZpbmQoZWxlbWVudHMsIG1hdGNoUGF0dGVybih7IGlkOiBlbGVtZW50LnRhcmdldC5pZCB9KSk7XG5cbiAgICBpZiAoIXNvdXJjZSB8fCAhdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTGFiZWwoZWxlbWVudCkpIHtcbiAgICBsYWJlbFRhcmdldCA9IGZpbmQoZWxlbWVudHMsIG1hdGNoUGF0dGVybih7IGlkOiBlbGVtZW50LmxhYmVsVGFyZ2V0LmlkIH0pKTtcblxuICAgIGlmICghbGFiZWxUYXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgdHJlZS1saWtlIHN0cnVjdHVyZSBmcm9tIGVsZW1lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiB0cmVlOiB7XG4gICogIDA6IFtcbiAgKiAgICB7IGlkOiAnU2hhcGVfMScsIHByaW9yaXR5OiAxLCAuLi4gfSxcbiAgKiAgICB7IGlkOiAnU2hhcGVfMicsIHByaW9yaXR5OiAxLCAuLi4gfSxcbiAgKiAgICB7IGlkOiAnQ29ubmVjdGlvbl8xJywgc291cmNlOiAnU2hhcGVfMScsIHRhcmdldDogJ1NoYXBlXzInLCBwcmlvcml0eTogMywgLi4uIH0sXG4gICogICAgLi4uXG4gICogIF0sXG4gICogIDE6IFtcbiAgKiAgICB7IGlkOiAnU2hhcGVfMycsIHBhcmVudDogJ1NoYXBlMScsIHByaW9yaXR5OiAxLCAuLi4gfSxcbiAgKiAgICAuLi5cbiAgKiAgXVxuICAqIH07XG4gICpcbiAgKiBAcGFyYW0gIHtBcnJheTxkanMubW9kZWwuYmFzZT59IGVsZW1lbnRzXG4gICpcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICovXG5Db3B5UGFzdGUucHJvdG90eXBlLmNyZWF0ZVRyZWUgPSBmdW5jdGlvbihlbGVtZW50cykge1xuICB2YXIgcnVsZXMgPSB0aGlzLl9ydWxlcyxcbiAgICAgIHNlbGYgPSB0aGlzO1xuXG4gIHZhciB0cmVlID0ge30sXG4gICAgICBlbGVtZW50c0RhdGEgPSBbXTtcblxuICB2YXIgcGFyZW50cyA9IGdldFBhcmVudHMoZWxlbWVudHMpO1xuXG4gIGZ1bmN0aW9uIGNhbkNvcHkoZWxlbWVudCwgZWxlbWVudHMpIHtcbiAgICByZXR1cm4gcnVsZXMuYWxsb3dlZCgnZWxlbWVudC5jb3B5Jywge1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRWxlbWVudERhdGEoZWxlbWVudCwgZGVwdGgpIHtcblxuICAgIC8vICgxKSBjaGVjayB3ZXRoZXIgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkXG4gICAgdmFyIGZvdW5kRWxlbWVudERhdGEgPSBmaW5kKGVsZW1lbnRzRGF0YSwgZnVuY3Rpb24oZWxlbWVudHNEYXRhKSB7XG4gICAgICByZXR1cm4gZWxlbWVudCA9PT0gZWxlbWVudHNEYXRhLmVsZW1lbnQ7XG4gICAgfSk7XG5cbiAgICAvLyAoMikgYWRkIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgYWRkZWRcbiAgICBpZiAoIWZvdW5kRWxlbWVudERhdGEpIHtcbiAgICAgIGVsZW1lbnRzRGF0YS5wdXNoKHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgZGVwdGg6IGRlcHRoXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vICgzKSB1cGRhdGUgZGVwdGhcbiAgICBpZiAoZm91bmRFbGVtZW50RGF0YS5kZXB0aCA8IGRlcHRoKSB7XG4gICAgICBlbGVtZW50c0RhdGEgPSByZW1vdmVFbGVtZW50RGF0YShmb3VuZEVsZW1lbnREYXRhLCBlbGVtZW50c0RhdGEpO1xuXG4gICAgICBlbGVtZW50c0RhdGEucHVzaCh7XG4gICAgICAgIGVsZW1lbnQ6IGZvdW5kRWxlbWVudERhdGEuZWxlbWVudCxcbiAgICAgICAgZGVwdGg6IGRlcHRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVFbGVtZW50RGF0YShlbGVtZW50RGF0YSwgZWxlbWVudHNEYXRhKSB7XG4gICAgdmFyIGluZGV4ID0gZWxlbWVudHNEYXRhLmluZGV4T2YoZWxlbWVudERhdGEpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgZWxlbWVudHNEYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzRGF0YTtcbiAgfVxuXG4gIC8vICgxKSBhZGQgZWxlbWVudHNcbiAgZWFjaEVsZW1lbnQocGFyZW50cywgZnVuY3Rpb24oZWxlbWVudCwgX2luZGV4LCBkZXB0aCkge1xuXG4gICAgLy8gZG8gTk9UIGFkZCBleHRlcm5hbCBsYWJlbHMgZGlyZWN0bHlcbiAgICBpZiAoaXNMYWJlbChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFsd2F5cyBjb3B5IGV4dGVybmFsIGxhYmVsc1xuICAgIGZvckVhY2goZWxlbWVudC5sYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICBhZGRFbGVtZW50RGF0YShsYWJlbCwgZGVwdGgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkUmVsYXRlZEVsZW1lbnRzKGVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGggJiYgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgICAgIC8vIGFkZCBleHRlcm5hbCBsYWJlbHNcbiAgICAgICAgZm9yRWFjaChlbGVtZW50LmxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICBhZGRFbGVtZW50RGF0YShsYWJlbCwgZGVwdGgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBhZGRFbGVtZW50RGF0YShlbGVtZW50LCBkZXB0aCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3JFYWNoKFsgZWxlbWVudC5hdHRhY2hlcnMsIGVsZW1lbnQuaW5jb21pbmcsIGVsZW1lbnQub3V0Z29pbmcgXSwgYWRkUmVsYXRlZEVsZW1lbnRzKTtcblxuICAgIGFkZEVsZW1lbnREYXRhKGVsZW1lbnQsIGRlcHRoKTtcblxuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuO1xuICB9KTtcblxuICBlbGVtZW50cyA9IG1hcChlbGVtZW50c0RhdGEsIGZ1bmN0aW9uKGVsZW1lbnREYXRhKSB7XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhLmVsZW1lbnQ7XG4gIH0pO1xuXG4gIC8vICgyKSBjb3B5IGVsZW1lbnRzXG4gIGVsZW1lbnRzRGF0YSA9IG1hcChlbGVtZW50c0RhdGEsIGZ1bmN0aW9uKGVsZW1lbnREYXRhKSB7XG4gICAgZWxlbWVudERhdGEuZGVzY3JpcHRvciA9IHt9O1xuXG4gICAgc2VsZi5fZXZlbnRCdXMuZmlyZSgnY29weVBhc3RlLmNvcHlFbGVtZW50Jywge1xuICAgICAgZGVzY3JpcHRvcjogZWxlbWVudERhdGEuZGVzY3JpcHRvcixcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnREYXRhLmVsZW1lbnQsXG4gICAgICBlbGVtZW50czogZWxlbWVudHNcbiAgICB9KTtcblxuICAgIHJldHVybiBlbGVtZW50RGF0YTtcbiAgfSk7XG5cbiAgLy8gKDMpIHNvcnQgZWxlbWVudHMgYnkgcHJpb3JpdHlcbiAgZWxlbWVudHNEYXRhID0gc29ydEJ5KGVsZW1lbnRzRGF0YSwgZnVuY3Rpb24oZWxlbWVudERhdGEpIHtcbiAgICByZXR1cm4gZWxlbWVudERhdGEuZGVzY3JpcHRvci5wcmlvcml0eTtcbiAgfSk7XG5cbiAgZWxlbWVudHMgPSBtYXAoZWxlbWVudHNEYXRhLCBmdW5jdGlvbihlbGVtZW50RGF0YSkge1xuICAgIHJldHVybiBlbGVtZW50RGF0YS5lbGVtZW50O1xuICB9KTtcblxuICAvLyAoNCkgY3JlYXRlIHRyZWVcbiAgZm9yRWFjaChlbGVtZW50c0RhdGEsIGZ1bmN0aW9uKGVsZW1lbnREYXRhKSB7XG4gICAgdmFyIGRlcHRoID0gZWxlbWVudERhdGEuZGVwdGg7XG5cbiAgICBpZiAoIXNlbGYuaGFzUmVsYXRpb25zKGVsZW1lbnREYXRhLmVsZW1lbnQsIGVsZW1lbnRzKSkge1xuICAgICAgcmVtb3ZlRWxlbWVudChlbGVtZW50RGF0YS5lbGVtZW50LCBlbGVtZW50cyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNhbkNvcHkoZWxlbWVudERhdGEuZWxlbWVudCwgZWxlbWVudHMpKSB7XG4gICAgICByZW1vdmVFbGVtZW50KGVsZW1lbnREYXRhLmVsZW1lbnQsIGVsZW1lbnRzKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdHJlZVtkZXB0aF0pIHtcbiAgICAgIHRyZWVbZGVwdGhdID0gW107XG4gICAgfVxuXG4gICAgdHJlZVtkZXB0aF0ucHVzaChlbGVtZW50RGF0YS5kZXNjcmlwdG9yKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRyZWU7XG59O1xuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNBdHRhY2hlcihlbGVtZW50KSB7XG4gIHJldHVybiAhIWVsZW1lbnQuaG9zdDtcbn1cblxuZnVuY3Rpb24gaXNDb25uZWN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuICEhZWxlbWVudC53YXlwb2ludHM7XG59XG5cbmZ1bmN0aW9uIGlzTGFiZWwoZWxlbWVudCkge1xuICByZXR1cm4gISFlbGVtZW50LmxhYmVsVGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBjb3B5V2F5cG9pbnRzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIG1hcChlbGVtZW50LndheXBvaW50cywgZnVuY3Rpb24od2F5cG9pbnQpIHtcblxuICAgIHdheXBvaW50ID0gY29weVdheXBvaW50KHdheXBvaW50KTtcblxuICAgIGlmICh3YXlwb2ludC5vcmlnaW5hbCkge1xuICAgICAgd2F5cG9pbnQub3JpZ2luYWwgPSBjb3B5V2F5cG9pbnQod2F5cG9pbnQub3JpZ2luYWwpO1xuICAgIH1cblxuICAgIHJldHVybiB3YXlwb2ludDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvcHlXYXlwb2ludCh3YXlwb2ludCkge1xuICByZXR1cm4gYXNzaWduKHt9LCB3YXlwb2ludCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWxlbWVudCwgZWxlbWVudHMpIHtcbiAgdmFyIGluZGV4ID0gZWxlbWVudHMuaW5kZXhPZihlbGVtZW50KTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG59XG4iLCJpbXBvcnQgQ2xpcGJvYXJkTW9kdWxlIGZyb20gJy4uL2NsaXBib2FyZCc7XG5pbXBvcnQgQ3JlYXRlTW9kdWxlIGZyb20gJy4uL2NyZWF0ZSc7XG5pbXBvcnQgTW91c2VNb2R1bGUgZnJvbSAnLi4vbW91c2UnO1xuaW1wb3J0IFJ1bGVzTW9kdWxlIGZyb20gJy4uL3J1bGVzJztcblxuaW1wb3J0IENvcHlQYXN0ZSBmcm9tICcuL0NvcHlQYXN0ZSc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIENsaXBib2FyZE1vZHVsZSxcbiAgICBDcmVhdGVNb2R1bGUsXG4gICAgTW91c2VNb2R1bGUsXG4gICAgUnVsZXNNb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFsgJ2NvcHlQYXN0ZScgXSxcbiAgY29weVBhc3RlOiBbICd0eXBlJywgQ29weVBhc3RlIF1cbn07XG4iLCJ2YXIgTUFSS0VSX09LID0gJ2Ryb3Atb2snLFxuICAgIE1BUktFUl9OT1RfT0sgPSAnZHJvcC1ub3Qtb2snLFxuICAgIE1BUktFUl9BVFRBQ0ggPSAnYXR0YWNoLW9rJyxcbiAgICBNQVJLRVJfTkVXX1BBUkVOVCA9ICduZXctcGFyZW50JztcblxuaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmaWx0ZXIsXG4gIGZpbmQsXG4gIGZvckVhY2gsXG4gIGlzQXJyYXksXG4gIGlzTnVtYmVyLFxuICBtYXBcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgeyBnZXRCQm94IH0gZnJvbSAnLi4vLi4vdXRpbC9FbGVtZW50cyc7XG5cbnZhciBQUkVGSVggPSAnY3JlYXRlJztcblxudmFyIEhJR0hfUFJJT1JJVFkgPSAyMDAwO1xuXG5cbi8qKlxuICogQ3JlYXRlIG5ldyBlbGVtZW50cyB0aHJvdWdoIGRyYWcgYW5kIGRyb3AuXG4gKlxuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtEcmFnZ2luZ30gZHJhZ2dpbmdcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge01vZGVsaW5nfSBtb2RlbGluZ1xuICogQHBhcmFtIHtSdWxlc30gcnVsZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ3JlYXRlKFxuICAgIGNhbnZhcyxcbiAgICBkcmFnZ2luZyxcbiAgICBldmVudEJ1cyxcbiAgICBtb2RlbGluZyxcbiAgICBydWxlc1xuKSB7XG5cbiAgLy8gcnVsZXMgLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBDaGVjayB3ZXRoZXIgZWxlbWVudHMgY2FuIGJlIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBlbGVtZW50c1xuICAgKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb25cbiAgICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gW3NvdXJjZV1cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbHxPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBjYW5DcmVhdGUoZWxlbWVudHMsIHRhcmdldCwgcG9zaXRpb24sIHNvdXJjZSwgaGludHMpIHtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBjaGlsZCBlbGVtZW50cyBhbmQgZXh0ZXJuYWwgbGFiZWxzXG4gICAgZWxlbWVudHMgPSBmaWx0ZXIoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBsYWJlbFRhcmdldCA9IGVsZW1lbnQubGFiZWxUYXJnZXQ7XG5cbiAgICAgIHJldHVybiAhZWxlbWVudC5wYXJlbnQgJiYgIShpc0xhYmVsKGVsZW1lbnQpICYmIGVsZW1lbnRzLmluZGV4T2YobGFiZWxUYXJnZXQpICE9PSAtMSk7XG4gICAgfSk7XG5cbiAgICB2YXIgc2hhcGUgPSBmaW5kKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gIWlzQ29ubmVjdGlvbihlbGVtZW50KTtcbiAgICB9KTtcblxuICAgIHZhciBhdHRhY2ggPSBmYWxzZSxcbiAgICAgICAgY29ubmVjdCA9IGZhbHNlLFxuICAgICAgICBjcmVhdGUgPSBmYWxzZTtcblxuICAgIC8vICgxKSBhdHRhY2hpbmcgc2luZ2xlIHNoYXBlc1xuICAgIGlmIChpc1NpbmdsZVNoYXBlKGVsZW1lbnRzKSkge1xuICAgICAgYXR0YWNoID0gcnVsZXMuYWxsb3dlZCgnc2hhcGUuYXR0YWNoJywge1xuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghYXR0YWNoKSB7XG5cbiAgICAgIC8vICgyKSBjcmVhdGluZyBlbGVtZW50c1xuICAgICAgaWYgKGlzU2luZ2xlU2hhcGUoZWxlbWVudHMpKSB7XG4gICAgICAgIGNyZWF0ZSA9IHJ1bGVzLmFsbG93ZWQoJ3NoYXBlLmNyZWF0ZScsIHtcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JlYXRlID0gcnVsZXMuYWxsb3dlZCgnZWxlbWVudHMuY3JlYXRlJywge1xuICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgY29ubmVjdGlvblRhcmdldCA9IGhpbnRzLmNvbm5lY3Rpb25UYXJnZXQ7XG5cbiAgICAvLyAoMykgYXBwZW5kaW5nIHNpbmdsZSBzaGFwZXNcbiAgICBpZiAoY3JlYXRlIHx8IGF0dGFjaCkge1xuICAgICAgaWYgKHNoYXBlICYmIHNvdXJjZSkge1xuICAgICAgICBjb25uZWN0ID0gcnVsZXMuYWxsb3dlZCgnY29ubmVjdGlvbi5jcmVhdGUnLCB7XG4gICAgICAgICAgc291cmNlOiBjb25uZWN0aW9uVGFyZ2V0ID09PSBzb3VyY2UgPyBzaGFwZSA6IHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IGNvbm5lY3Rpb25UYXJnZXQgPT09IHNvdXJjZSA/IHNvdXJjZSA6IHNoYXBlLFxuICAgICAgICAgIGhpbnRzOiB7XG4gICAgICAgICAgICB0YXJnZXRQYXJlbnQ6IHRhcmdldCxcbiAgICAgICAgICAgIHRhcmdldEF0dGFjaDogYXR0YWNoXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXR0YWNoOiBhdHRhY2gsXG4gICAgICAgIGNvbm5lY3Q6IGNvbm5lY3RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaWdub3JlIHdldGhlciBvciBub3QgZWxlbWVudHMgY2FuIGJlIGNyZWF0ZWRcbiAgICBpZiAoY3JlYXRlID09PSBudWxsIHx8IGF0dGFjaCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TWFya2VyKGVsZW1lbnQsIG1hcmtlcikge1xuICAgIFsgTUFSS0VSX0FUVEFDSCwgTUFSS0VSX09LLCBNQVJLRVJfTk9UX09LLCBNQVJLRVJfTkVXX1BBUkVOVCBdLmZvckVhY2goZnVuY3Rpb24obSkge1xuXG4gICAgICBpZiAobSA9PT0gbWFya2VyKSB7XG4gICAgICAgIGNhbnZhcy5hZGRNYXJrZXIoZWxlbWVudCwgbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGVsZW1lbnQsIG0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gZXZlbnQgaGFuZGxpbmcgLy8vLy8vLy8vL1xuXG4gIGV2ZW50QnVzLm9uKFsgJ2NyZWF0ZS5tb3ZlJywgJ2NyZWF0ZS5ob3ZlcicgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGVsZW1lbnRzID0gY29udGV4dC5lbGVtZW50cyxcbiAgICAgICAgaG92ZXIgPSBldmVudC5ob3ZlcixcbiAgICAgICAgc291cmNlID0gY29udGV4dC5zb3VyY2UsXG4gICAgICAgIGhpbnRzID0gY29udGV4dC5oaW50cyB8fCB7fTtcblxuICAgIGlmICghaG92ZXIpIHtcbiAgICAgIGNvbnRleHQuY2FuRXhlY3V0ZSA9IGZhbHNlO1xuICAgICAgY29udGV4dC50YXJnZXQgPSBudWxsO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZW5zdXJlQ29uc3RyYWludHMoZXZlbnQpO1xuXG4gICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgeDogZXZlbnQueCxcbiAgICAgIHk6IGV2ZW50LnlcbiAgICB9O1xuXG4gICAgdmFyIGNhbkV4ZWN1dGUgPSBjb250ZXh0LmNhbkV4ZWN1dGUgPSBob3ZlciAmJiBjYW5DcmVhdGUoZWxlbWVudHMsIGhvdmVyLCBwb3NpdGlvbiwgc291cmNlLCBoaW50cyk7XG5cbiAgICBpZiAoaG92ZXIgJiYgY2FuRXhlY3V0ZSAhPT0gbnVsbCkge1xuICAgICAgY29udGV4dC50YXJnZXQgPSBob3ZlcjtcblxuICAgICAgaWYgKGNhbkV4ZWN1dGUgJiYgY2FuRXhlY3V0ZS5hdHRhY2gpIHtcbiAgICAgICAgc2V0TWFya2VyKGhvdmVyLCBNQVJLRVJfQVRUQUNIKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1hcmtlcihob3ZlciwgY2FuRXhlY3V0ZSA/IE1BUktFUl9ORVdfUEFSRU5UIDogTUFSS0VSX05PVF9PSyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbihbICdjcmVhdGUuZW5kJywgJ2NyZWF0ZS5vdXQnLCAnY3JlYXRlLmNsZWFudXAnIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGhvdmVyID0gZXZlbnQuaG92ZXI7XG5cbiAgICBpZiAoaG92ZXIpIHtcbiAgICAgIHNldE1hcmtlcihob3ZlciwgbnVsbCk7XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbignY3JlYXRlLmVuZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBzb3VyY2UgPSBjb250ZXh0LnNvdXJjZSxcbiAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBlbGVtZW50cyA9IGNvbnRleHQuZWxlbWVudHMsXG4gICAgICAgIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0LFxuICAgICAgICBjYW5FeGVjdXRlID0gY29udGV4dC5jYW5FeGVjdXRlLFxuICAgICAgICBhdHRhY2ggPSBjYW5FeGVjdXRlICYmIGNhbkV4ZWN1dGUuYXR0YWNoLFxuICAgICAgICBjb25uZWN0ID0gY2FuRXhlY3V0ZSAmJiBjYW5FeGVjdXRlLmNvbm5lY3QsXG4gICAgICAgIGhpbnRzID0gY29udGV4dC5oaW50cyB8fCB7fTtcblxuICAgIGlmIChjYW5FeGVjdXRlID09PSBmYWxzZSB8fCAhdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZW5zdXJlQ29uc3RyYWludHMoZXZlbnQpO1xuXG4gICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgeDogZXZlbnQueCxcbiAgICAgIHk6IGV2ZW50LnlcbiAgICB9O1xuXG4gICAgaWYgKGNvbm5lY3QpIHtcbiAgICAgIHNoYXBlID0gbW9kZWxpbmcuYXBwZW5kU2hhcGUoc291cmNlLCBzaGFwZSwgcG9zaXRpb24sIHRhcmdldCwge1xuICAgICAgICBhdHRhY2g6IGF0dGFjaCxcbiAgICAgICAgY29ubmVjdGlvbjogY29ubmVjdCA9PT0gdHJ1ZSA/IHt9IDogY29ubmVjdCxcbiAgICAgICAgY29ubmVjdGlvblRhcmdldDogaGludHMuY29ubmVjdGlvblRhcmdldFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnRzID0gbW9kZWxpbmcuY3JlYXRlRWxlbWVudHMoZWxlbWVudHMsIHBvc2l0aW9uLCB0YXJnZXQsIGFzc2lnbih7fSwgaGludHMsIHtcbiAgICAgICAgYXR0YWNoOiBhdHRhY2hcbiAgICAgIH0pKTtcblxuICAgICAgLy8gdXBkYXRlIHNoYXBlXG4gICAgICBzaGFwZSA9IGZpbmQoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuICFpc0Nvbm5lY3Rpb24oZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZWxlbWVudHMgYW5kIHNoYXBlXG4gICAgYXNzaWduKGNvbnRleHQsIHtcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgIHNoYXBlOiBzaGFwZVxuICAgIH0pO1xuXG4gICAgYXNzaWduKGV2ZW50LCB7XG4gICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICBzaGFwZTogc2hhcGVcbiAgICB9KTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHZhciBjb250ZXh0ID0gZHJhZ2dpbmcuY29udGV4dCgpO1xuXG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5wcmVmaXggPT09IFBSRUZJWCkge1xuICAgICAgZHJhZ2dpbmcuY2FuY2VsKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FuY2VsIG9uIDxlbGVtZW50cy5jaGFuZ2VkPiB0aGF0IGlzIG5vdCByZXN1bHQgb2YgPGRyYWcuZW5kPlxuICBldmVudEJ1cy5vbignY3JlYXRlLmluaXQnLCBmdW5jdGlvbigpIHtcbiAgICBldmVudEJ1cy5vbignZWxlbWVudHMuY2hhbmdlZCcsIGNhbmNlbCk7XG5cbiAgICBldmVudEJ1cy5vbmNlKFsgJ2NyZWF0ZS5jYW5jZWwnLCAnY3JlYXRlLmVuZCcgXSwgSElHSF9QUklPUklUWSwgZnVuY3Rpb24oKSB7XG4gICAgICBldmVudEJ1cy5vZmYoJ2VsZW1lbnRzLmNoYW5nZWQnLCBjYW5jZWwpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBBUEkgLy8vLy8vLy8vL1xuXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbihldmVudCwgZWxlbWVudHMsIGNvbnRleHQpIHtcbiAgICBpZiAoIWlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50cyA9IFsgZWxlbWVudHMgXTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBmaW5kKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gIWlzQ29ubmVjdGlvbihlbGVtZW50KTtcbiAgICB9KTtcblxuICAgIGlmICghc2hhcGUpIHtcblxuICAgICAgLy8gYXQgbGVhc3Qgb25lIHNoYXBlIGlzIHJlcXVpcmVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGFzc2lnbih7XG4gICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICBoaW50czoge30sXG4gICAgICBzaGFwZTogc2hhcGVcbiAgICB9LCBjb250ZXh0IHx8IHt9KTtcblxuICAgIC8vIG1ha2Ugc3VyZSBlYWNoIGVsZW1lbnQgaGFzIHggYW5kIHlcbiAgICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBpZiAoIWlzTnVtYmVyKGVsZW1lbnQueCkpIHtcbiAgICAgICAgZWxlbWVudC54ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc051bWJlcihlbGVtZW50LnkpKSB7XG4gICAgICAgIGVsZW1lbnQueSA9IDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgYmJveCA9IGdldEJCb3goZWxlbWVudHMpO1xuXG4gICAgLy8gY2VudGVyIGVsZW1lbnRzIGFyb3VuZCBjdXJzb3JcbiAgICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBpZiAoaXNDb25uZWN0aW9uKGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnQud2F5cG9pbnRzID0gbWFwKGVsZW1lbnQud2F5cG9pbnRzLCBmdW5jdGlvbih3YXlwb2ludCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB3YXlwb2ludC54IC0gYmJveC54IC0gYmJveC53aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiB3YXlwb2ludC55IC0gYmJveC55IC0gYmJveC5oZWlnaHQgLyAyXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGFzc2lnbihlbGVtZW50LCB7XG4gICAgICAgIHg6IGVsZW1lbnQueCAtIGJib3gueCAtIGJib3gud2lkdGggLyAyLFxuICAgICAgICB5OiBlbGVtZW50LnkgLSBiYm94LnkgLSBiYm94LmhlaWdodCAvIDJcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZHJhZ2dpbmcuaW5pdChldmVudCwgUFJFRklYLCB7XG4gICAgICBjdXJzb3I6ICdncmFiYmluZycsXG4gICAgICBhdXRvQWN0aXZhdGU6IHRydWUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbkNyZWF0ZS4kaW5qZWN0ID0gW1xuICAnY2FudmFzJyxcbiAgJ2RyYWdnaW5nJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ3J1bGVzJ1xuXTtcblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGVuc3VyZUNvbnN0cmFpbnRzKGV2ZW50KSB7XG4gIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgIGNyZWF0ZUNvbnN0cmFpbnRzID0gY29udGV4dC5jcmVhdGVDb25zdHJhaW50cztcblxuICBpZiAoIWNyZWF0ZUNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNyZWF0ZUNvbnN0cmFpbnRzLmxlZnQpIHtcbiAgICBldmVudC54ID0gTWF0aC5tYXgoZXZlbnQueCwgY3JlYXRlQ29uc3RyYWludHMubGVmdCk7XG4gIH1cblxuICBpZiAoY3JlYXRlQ29uc3RyYWludHMucmlnaHQpIHtcbiAgICBldmVudC54ID0gTWF0aC5taW4oZXZlbnQueCwgY3JlYXRlQ29uc3RyYWludHMucmlnaHQpO1xuICB9XG5cbiAgaWYgKGNyZWF0ZUNvbnN0cmFpbnRzLnRvcCkge1xuICAgIGV2ZW50LnkgPSBNYXRoLm1heChldmVudC55LCBjcmVhdGVDb25zdHJhaW50cy50b3ApO1xuICB9XG5cbiAgaWYgKGNyZWF0ZUNvbnN0cmFpbnRzLmJvdHRvbSkge1xuICAgIGV2ZW50LnkgPSBNYXRoLm1pbihldmVudC55LCBjcmVhdGVDb25zdHJhaW50cy5ib3R0b20pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ29ubmVjdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiAhIWVsZW1lbnQud2F5cG9pbnRzO1xufVxuXG5mdW5jdGlvbiBpc1NpbmdsZVNoYXBlKGVsZW1lbnRzKSB7XG4gIHJldHVybiBlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGggPT09IDEgJiYgIWlzQ29ubmVjdGlvbihlbGVtZW50c1swXSk7XG59XG5cbmZ1bmN0aW9uIGlzTGFiZWwoZWxlbWVudCkge1xuICByZXR1cm4gISFlbGVtZW50LmxhYmVsVGFyZ2V0O1xufVxuIiwiaW1wb3J0IHtcclxuICB0cmFuc2xhdGVcclxufSBmcm9tICcuLi8uLi91dGlsL1N2Z1RyYW5zZm9ybVV0aWwnO1xyXG5cclxuaW1wb3J0IHsgZ2V0VmlzdWFsIH0gZnJvbSAnLi4vLi4vdXRpbC9HcmFwaGljc1V0aWwnO1xyXG5cclxuaW1wb3J0IHtcclxuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxyXG4gIGF0dHIgYXMgc3ZnQXR0cixcclxuICBjcmVhdGUgYXMgc3ZnQ3JlYXRlLFxyXG4gIHJlbW92ZSBhcyBzdmdSZW1vdmVcclxufSBmcm9tICd0aW55LXN2Zyc7XHJcblxyXG52YXIgTE9XX1BSSU9SSVRZID0gNzUwO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENyZWF0ZVByZXZpZXcoXHJcbiAgICBjYW52YXMsXHJcbiAgICBldmVudEJ1cyxcclxuICAgIGdyYXBoaWNzRmFjdG9yeSxcclxuICAgIHByZXZpZXdTdXBwb3J0LFxyXG4gICAgc3R5bGVzXHJcbikge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZURyYWdHcm91cChlbGVtZW50cykge1xyXG4gICAgdmFyIGRyYWdHcm91cCA9IHN2Z0NyZWF0ZSgnZycpO1xyXG5cclxuICAgIHN2Z0F0dHIoZHJhZ0dyb3VwLCBzdHlsZXMuY2xzKCdkanMtZHJhZy1ncm91cCcsIFsgJ25vLWV2ZW50cycgXSkpO1xyXG5cclxuICAgIHZhciBjaGlsZHJlbkdmeCA9IHN2Z0NyZWF0ZSgnZycpO1xyXG5cclxuICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xyXG5cclxuICAgICAgLy8gY3JlYXRlIGdyYXBoaWNzXHJcbiAgICAgIHZhciBnZng7XHJcblxyXG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbGVtZW50LndheXBvaW50cykge1xyXG4gICAgICAgIGdmeCA9IGdyYXBoaWNzRmFjdG9yeS5fY3JlYXRlQ29udGFpbmVyKCdjb25uZWN0aW9uJywgY2hpbGRyZW5HZngpO1xyXG5cclxuICAgICAgICBncmFwaGljc0ZhY3RvcnkuZHJhd0Nvbm5lY3Rpb24oZ2V0VmlzdWFsKGdmeCksIGVsZW1lbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdmeCA9IGdyYXBoaWNzRmFjdG9yeS5fY3JlYXRlQ29udGFpbmVyKCdzaGFwZScsIGNoaWxkcmVuR2Z4KTtcclxuXHJcbiAgICAgICAgZ3JhcGhpY3NGYWN0b3J5LmRyYXdTaGFwZShnZXRWaXN1YWwoZ2Z4KSwgZWxlbWVudCk7XHJcblxyXG4gICAgICAgIHRyYW5zbGF0ZShnZngsIGVsZW1lbnQueCwgZWxlbWVudC55KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWRkIHByZXZpZXdcclxuICAgICAgcHJldmlld1N1cHBvcnQuYWRkRHJhZ2dlcihlbGVtZW50LCBkcmFnR3JvdXAsIGdmeCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZHJhZ0dyb3VwO1xyXG4gIH1cclxuXHJcbiAgZXZlbnRCdXMub24oJ2NyZWF0ZS5tb3ZlJywgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xyXG5cclxuICAgIHZhciBob3ZlciA9IGV2ZW50LmhvdmVyLFxyXG4gICAgICAgIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxyXG4gICAgICAgIGVsZW1lbnRzID0gY29udGV4dC5lbGVtZW50cyxcclxuICAgICAgICBkcmFnR3JvdXAgPSBjb250ZXh0LmRyYWdHcm91cDtcclxuXHJcbiAgICAvLyBsYXppbHkgY3JlYXRlIHByZXZpZXdzXHJcbiAgICBpZiAoIWRyYWdHcm91cCkge1xyXG4gICAgICBkcmFnR3JvdXAgPSBjb250ZXh0LmRyYWdHcm91cCA9IGNyZWF0ZURyYWdHcm91cChlbGVtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRlZmF1bHRMYXllcjtcclxuXHJcbiAgICBpZiAoaG92ZXIpIHtcclxuICAgICAgaWYgKCFkcmFnR3JvdXAucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIGRlZmF1bHRMYXllciA9IGNhbnZhcy5nZXREZWZhdWx0TGF5ZXIoKTtcclxuXHJcbiAgICAgICAgc3ZnQXBwZW5kKGRlZmF1bHRMYXllciwgZHJhZ0dyb3VwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJhbnNsYXRlKGRyYWdHcm91cCwgZXZlbnQueCwgZXZlbnQueSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdmdSZW1vdmUoZHJhZ0dyb3VwKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgZXZlbnRCdXMub24oJ2NyZWF0ZS5jbGVhbnVwJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcclxuICAgICAgICBkcmFnR3JvdXAgPSBjb250ZXh0LmRyYWdHcm91cDtcclxuXHJcbiAgICBpZiAoZHJhZ0dyb3VwKSB7XHJcbiAgICAgIHN2Z1JlbW92ZShkcmFnR3JvdXApO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5DcmVhdGVQcmV2aWV3LiRpbmplY3QgPSBbXHJcbiAgJ2NhbnZhcycsXHJcbiAgJ2V2ZW50QnVzJyxcclxuICAnZ3JhcGhpY3NGYWN0b3J5JyxcclxuICAncHJldmlld1N1cHBvcnQnLFxyXG4gICdzdHlsZXMnXHJcbl07XHJcbiIsImltcG9ydCBEcmFnZ2luZ01vZHVsZSBmcm9tICcuLi9kcmFnZ2luZyc7XG5pbXBvcnQgUHJldmlld1N1cHBvcnRNb2R1bGUgZnJvbSAnLi4vcHJldmlldy1zdXBwb3J0JztcbmltcG9ydCBSdWxlc01vZHVsZSBmcm9tICcuLi9ydWxlcyc7XG5pbXBvcnQgU2VsZWN0aW9uTW9kdWxlIGZyb20gJy4uL3NlbGVjdGlvbic7XG5cbmltcG9ydCBDcmVhdGUgZnJvbSAnLi9DcmVhdGUnO1xuaW1wb3J0IENyZWF0ZVByZXZpZXcgZnJvbSAnLi9DcmVhdGVQcmV2aWV3JztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgRHJhZ2dpbmdNb2R1bGUsXG4gICAgUHJldmlld1N1cHBvcnRNb2R1bGUsXG4gICAgUnVsZXNNb2R1bGUsXG4gICAgU2VsZWN0aW9uTW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbXG4gICAgJ2NyZWF0ZScsXG4gICAgJ2NyZWF0ZVByZXZpZXcnXG4gIF0sXG4gIGNyZWF0ZTogWyAndHlwZScsIENyZWF0ZSBdLFxuICBjcmVhdGVQcmV2aWV3OiBbICd0eXBlJywgQ3JlYXRlUHJldmlldyBdXG59O1xuIiwidmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBldmVudCBhcyBkb21FdmVudFxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgZ2V0T3JpZ2luYWwsXG4gIHRvUG9pbnQsXG4gIHN0b3BQcm9wYWdhdGlvblxufSBmcm9tICcuLi8uLi91dGlsL0V2ZW50JztcblxuaW1wb3J0IHtcbiAgc2V0IGFzIGN1cnNvclNldCxcbiAgdW5zZXQgYXMgY3Vyc29yVW5zZXRcbn0gZnJvbSAnLi4vLi4vdXRpbC9DdXJzb3InO1xuXG5pbXBvcnQge1xuICBpbnN0YWxsIGFzIGluc3RhbGxDbGlja1RyYXBcbn0gZnJvbSAnLi4vLi4vdXRpbC9DbGlja1RyYXAnO1xuXG5pbXBvcnQge1xuICBkZWx0YSBhcyBkZWx0YVBvc1xufSBmcm9tICcuLi8uLi91dGlsL1Bvc2l0aW9uVXRpbCc7XG5cbnZhciBEUkFHX0FDVElWRV9DTFMgPSAnZGpzLWRyYWctYWN0aXZlJztcblxuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcblxuICAvLyBjaGVjayBmb3IgVG91Y2hFdmVudCBiZWluZyBhdmFpbGFibGUgZmlyc3RcbiAgLy8gKGkuZS4gbm90IGF2YWlsYWJsZSBvbiBkZXNrdG9wIEZpcmVmb3gpXG4gIHJldHVybiB0eXBlb2YgVG91Y2hFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50O1xufVxuXG5mdW5jdGlvbiBnZXRMZW5ndGgocG9pbnQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwb2ludC54LCAyKSArIE1hdGgucG93KHBvaW50LnksIDIpKTtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciB0aGF0IGZpcmVzIGNhbnZhcyBsb2NhbGl6ZWQgZHJhZyBldmVudHMgYW5kIHJlYWxpemVzXG4gKiB0aGUgZ2VuZXJhbCBcImRyYWctYW5kLWRyb3BcIiBsb29rIGFuZCBmZWVsLlxuICpcbiAqIENhbGxpbmcge0BsaW5rIERyYWdnaW5nI2FjdGl2YXRlfSBhY3RpdmF0ZXMgZHJhZ2dpbmcgb24gYSBjYW52YXMuXG4gKlxuICogSXQgcHJvdmlkZXMgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAgICogZW1pdHMgbGlmZSBjeWNsZSBldmVudHMsIG5hbWVzcGFjZWQgd2l0aCBhIHByZWZpeCBhc3NpZ25lZFxuICogICAgIGR1cmluZyBkcmFnZ2luZyBhY3RpdmF0aW9uXG4gKiAgICogc2V0cyBhbmQgcmVzdG9yZXMgdGhlIGN1cnNvclxuICogICAqIHNldHMgYW5kIHJlc3RvcmVzIHRoZSBzZWxlY3Rpb24gaWYgZWxlbWVudHMgc3RpbGwgZXhpc3RcbiAqICAgKiBlbnN1cmVzIHRoZXJlIGNhbiBiZSBvbmx5IG9uZSBkcmFnIG9wZXJhdGlvbiBhY3RpdmUgYXQgYSB0aW1lXG4gKlxuICogRHJhZ2dpbmcgbWF5IGJlIGNhbmNlbGVkIG1hbnVhbGx5IGJ5IGNhbGxpbmcge0BsaW5rIERyYWdnaW5nI2NhbmNlbH1cbiAqIG9yIGJ5IHByZXNzaW5nIEVTQy5cbiAqXG4gKlxuICogIyMgTGlmZS1jeWNsZSBldmVudHNcbiAqXG4gKiBEcmFnZ2luZyBjYW4gYmUgaW4gdGhyZWUgZGlmZmVyZW50IHN0YXRlcywgb2ZmLCBpbml0aWFsaXplZFxuICogYW5kIGFjdGl2ZS5cbiAqXG4gKiAoMSkgb2ZmOiBubyBkcmFnZ2luZyBvcGVyYXRpb24gaXMgaW4gcHJvZ3Jlc3NcbiAqICgyKSBpbml0aWFsaXplZDogYSBuZXcgZHJhZyBvcGVyYXRpb24gZ290IGluaXRpYWxpemVkIGJ1dCBub3QgeWV0XG4gKiAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKGkuZS4gYmVjYXVzZSBvZiBubyBpbml0aWFsIG1vdmUpXG4gKiAoMykgc3RhcnRlZDogZHJhZ2dpbmcgaXMgaW4gcHJvZ3Jlc3NcbiAqXG4gKiBFdmVudHVhbGx5IGRyYWdnaW5nIHdpbGwgYmUgb2ZmIGFnYWluIGFmdGVyIGEgZHJhZyBvcGVyYXRpb24gaGFzXG4gKiBiZWVuIGVuZGVkIG9yIGNhbmNlbGVkIHZpYSB1c2VyIGNsaWNrIG9yIEVTQyBrZXkgcHJlc3MuXG4gKlxuICogVG8gaW5kaWNhdGUgdHJhbnNpdGlvbnMgYmV0d2VlbiB0aGVzZSBzdGF0ZXMgZHJhZ2dpbmcgZW1pdHMgZ2VuZXJpY1xuICogbGlmZS1jeWNsZSBldmVudHMgd2l0aCB0aGUgYGRyYWcuYCBwcmVmaXggX2FuZF8gZXZlbnRzIG5hbWVzcGFjZWRcbiAqIHRvIGEgcHJlZml4IGNob29zZW4gYnkgYSB1c2VyIGR1cmluZyBkcmFnIGluaXRpYWxpemF0aW9uLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBlbWl0dGVkIChhcHByb3ByaWF0ZWx5IHByZWZpeGVkKSB2aWFcbiAqIHRoZSB7QGxpbmsgRXZlbnRCdXN9LlxuICpcbiAqICogYGluaXRgXG4gKiAqIGBzdGFydGBcbiAqICogYG1vdmVgXG4gKiAqIGBlbmRgXG4gKiAqIGBlbmRlZGAgKGRyYWdnaW5nIGFscmVhZHkgaW4gb2ZmIHN0YXRlKVxuICogKiBgY2FuY2VsYCAob25seSBpZiBwcmV2aW91c2x5IHN0YXJ0ZWQpXG4gKiAqIGBjYW5jZWxlZGAgKGRyYWdnaW5nIGFscmVhZHkgaW4gb2ZmIHN0YXRlLCBvbmx5IGlmIHByZXZpb3VzbHkgc3RhcnRlZClcbiAqICogYGNsZWFudXBgXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gTXlEcmFnQ29tcG9uZW50KGV2ZW50QnVzLCBkcmFnZ2luZykge1xuICpcbiAqICAgZXZlbnRCdXMub24oJ215ZHJhZy5zdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgICAgY29uc29sZS5sb2coJ3llcywgd2Ugc3RhcnQgZHJhZ2dpbmcnKTtcbiAqICAgfSk7XG4gKlxuICogICBldmVudEJ1cy5vbignbXlkcmFnLm1vdmUnLCBmdW5jdGlvbihldmVudCkge1xuICogICAgIGNvbnNvbGUubG9nKCdjYW52YXMgbG9jYWwgY29vcmRpbmF0ZXMnLCBldmVudC54LCBldmVudC55LCBldmVudC5keCwgZXZlbnQuZHkpO1xuICpcbiAqICAgICAvLyBsb2NhbCBkcmFnIGRhdGEgaXMgcGFzc2VkIHdpdGggdGhlIGV2ZW50XG4gKiAgICAgZXZlbnQuY29udGV4dC5mb287IC8vIFwiQkFSXCJcbiAqXG4gKiAgICAgLy8gdGhlIG9yaWdpbmFsIG1vdXNlIGV2ZW50LCB0b29cbiAqICAgICBldmVudC5vcmlnaW5hbEV2ZW50OyAvLyBNb3VzZUV2ZW50KC4uLilcbiAqICAgfSk7XG4gKlxuICogICBldmVudEJ1cy5vbignZWxlbWVudC5jbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgICAgZHJhZ2dpbmcuaW5pdChldmVudCwgJ215ZHJhZycsIHtcbiAqICAgICAgIGN1cnNvcjogJ2dyYWJiaW5nJyxcbiAqICAgICAgIGRhdGE6IHtcbiAqICAgICAgICAgY29udGV4dDoge1xuICogICAgICAgICAgIGZvbzogXCJCQVJcIlxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKiAgIH0pO1xuICogfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEcmFnZ2luZyhldmVudEJ1cywgY2FudmFzLCBzZWxlY3Rpb24sIGVsZW1lbnRSZWdpc3RyeSkge1xuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICB0aHJlc2hvbGQ6IDUsXG4gICAgdHJhcENsaWNrOiB0cnVlXG4gIH07XG5cbiAgLy8gdGhlIGN1cnJlbnRseSBhY3RpdmUgZHJhZyBvcGVyYXRpb25cbiAgLy8gZHJhZ2dpbmcgaXMgYWN0aXZlIGFzIHNvb24gYXMgdGhpcyBjb250ZXh0IGV4aXN0cy5cbiAgLy9cbiAgLy8gaXQgaXMgdmlzdWFsbHkgX2FjdGl2ZV8gb25seSB3aGVuIGEgY29udGV4dC5hY3RpdmUgZmxhZyBpcyBzZXQgdG8gdHJ1ZS5cbiAgdmFyIGNvbnRleHQ7XG5cbiAgLyogY29udmVydCBhIGdsb2JhbCBldmVudCBpbnRvIGxvY2FsIGNvb3JkaW5hdGVzICovXG4gIGZ1bmN0aW9uIHRvTG9jYWxQb2ludChnbG9iYWxQb3NpdGlvbikge1xuXG4gICAgdmFyIHZpZXdib3ggPSBjYW52YXMudmlld2JveCgpO1xuXG4gICAgdmFyIGNsaWVudFJlY3QgPSBjYW52YXMuX2NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB2aWV3Ym94LnggKyAoZ2xvYmFsUG9zaXRpb24ueCAtIGNsaWVudFJlY3QubGVmdCkgLyB2aWV3Ym94LnNjYWxlLFxuICAgICAgeTogdmlld2JveC55ICsgKGdsb2JhbFBvc2l0aW9uLnkgLSBjbGllbnRSZWN0LnRvcCkgLyB2aWV3Ym94LnNjYWxlXG4gICAgfTtcbiAgfVxuXG4gIC8vIGhlbHBlcnNcblxuICBmdW5jdGlvbiBmaXJlKHR5cGUsIGRyYWdDb250ZXh0KSB7XG4gICAgZHJhZ0NvbnRleHQgPSBkcmFnQ29udGV4dCB8fCBjb250ZXh0O1xuXG4gICAgdmFyIGV2ZW50ID0gZXZlbnRCdXMuY3JlYXRlRXZlbnQoXG4gICAgICBhc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICBkcmFnQ29udGV4dC5wYXlsb2FkLFxuICAgICAgICBkcmFnQ29udGV4dC5kYXRhLFxuICAgICAgICB7IGlzVG91Y2g6IGRyYWdDb250ZXh0LmlzVG91Y2ggfVxuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBkZWZhdWx0IGludGVncmF0aW9uXG4gICAgaWYgKGV2ZW50QnVzLmZpcmUoJ2RyYWcuJyArIHR5cGUsIGV2ZW50KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRCdXMuZmlyZShkcmFnQ29udGV4dC5wcmVmaXggKyAnLicgKyB0eXBlLCBldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByZXZpb3VzU2VsZWN0aW9uKSB7XG4gICAgdmFyIGV4aXN0aW5nU2VsZWN0aW9uID0gcHJldmlvdXNTZWxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50UmVnaXN0cnkuZ2V0KGVsZW1lbnQuaWQpO1xuICAgIH0pO1xuXG4gICAgZXhpc3RpbmdTZWxlY3Rpb24ubGVuZ3RoICYmIHNlbGVjdGlvbi5zZWxlY3QoZXhpc3RpbmdTZWxlY3Rpb24pO1xuICB9XG5cbiAgLy8gZXZlbnQgbGlzdGVuZXJzXG5cbiAgZnVuY3Rpb24gbW92ZShldmVudCwgYWN0aXZhdGUpIHtcbiAgICB2YXIgcGF5bG9hZCA9IGNvbnRleHQucGF5bG9hZCxcbiAgICAgICAgZGlzcGxhY2VtZW50ID0gY29udGV4dC5kaXNwbGFjZW1lbnQ7XG5cbiAgICB2YXIgZ2xvYmFsU3RhcnQgPSBjb250ZXh0Lmdsb2JhbFN0YXJ0LFxuICAgICAgICBnbG9iYWxDdXJyZW50ID0gdG9Qb2ludChldmVudCksXG4gICAgICAgIGdsb2JhbERlbHRhID0gZGVsdGFQb3MoZ2xvYmFsQ3VycmVudCwgZ2xvYmFsU3RhcnQpO1xuXG4gICAgdmFyIGxvY2FsU3RhcnQgPSBjb250ZXh0LmxvY2FsU3RhcnQsXG4gICAgICAgIGxvY2FsQ3VycmVudCA9IHRvTG9jYWxQb2ludChnbG9iYWxDdXJyZW50KSxcbiAgICAgICAgbG9jYWxEZWx0YSA9IGRlbHRhUG9zKGxvY2FsQ3VycmVudCwgbG9jYWxTdGFydCk7XG5cblxuICAgIC8vIGFjdGl2YXRlIGNvbnRleHQgZXhwbGljaXRseSBvciBvbmNlIHRocmVzaG9sZCBpcyByZWFjaGVkXG4gICAgaWYgKCFjb250ZXh0LmFjdGl2ZSAmJiAoYWN0aXZhdGUgfHwgZ2V0TGVuZ3RoKGdsb2JhbERlbHRhKSA+IGNvbnRleHQudGhyZXNob2xkKSkge1xuXG4gICAgICAvLyBmaXJlIHN0YXJ0IGV2ZW50IHdpdGggb3JpZ2luYWxcbiAgICAgIC8vIHN0YXJ0aW5nIGNvb3JkaW5hdGVzXG5cbiAgICAgIGFzc2lnbihwYXlsb2FkLCB7XG4gICAgICAgIHg6IHJvdW5kKGxvY2FsU3RhcnQueCArIGRpc3BsYWNlbWVudC54KSxcbiAgICAgICAgeTogcm91bmQobG9jYWxTdGFydC55ICsgZGlzcGxhY2VtZW50LnkpLFxuICAgICAgICBkeDogMCxcbiAgICAgICAgZHk6IDBcbiAgICAgIH0sIHsgb3JpZ2luYWxFdmVudDogZXZlbnQgfSk7XG5cbiAgICAgIGlmIChmYWxzZSA9PT0gZmlyZSgnc3RhcnQnKSkge1xuICAgICAgICByZXR1cm4gY2FuY2VsKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuYWN0aXZlID0gdHJ1ZTtcblxuICAgICAgLy8gdW5zZXQgc2VsZWN0aW9uIGFuZCByZW1lbWJlciBvbGQgc2VsZWN0aW9uXG4gICAgICAvLyB0aGUgcHJldmlvdXMgKG9sZCkgc2VsZWN0aW9uIHdpbGwgYWx3YXlzIHBhc3NlZFxuICAgICAgLy8gd2l0aCB0aGUgZXZlbnQgdmlhIHRoZSBldmVudC5wcmV2aW91c1NlbGVjdGlvbiBwcm9wZXJ0eVxuICAgICAgaWYgKCFjb250ZXh0LmtlZXBTZWxlY3Rpb24pIHtcbiAgICAgICAgcGF5bG9hZC5wcmV2aW91c1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5nZXQoKTtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChudWxsKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWxsb3cgY3VzdG9tIGN1cnNvclxuICAgICAgaWYgKGNvbnRleHQuY3Vyc29yKSB7XG4gICAgICAgIGN1cnNvclNldChjb250ZXh0LmN1cnNvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIGluZGljYXRlIGRyYWdnaW5nIHZpYSBtYXJrZXIgb24gcm9vdCBlbGVtZW50XG4gICAgICBjYW52YXMuYWRkTWFya2VyKGNhbnZhcy5nZXRSb290RWxlbWVudCgpLCBEUkFHX0FDVElWRV9DTFMpO1xuICAgIH1cblxuICAgIHN0b3BQcm9wYWdhdGlvbihldmVudCk7XG5cbiAgICBpZiAoY29udGV4dC5hY3RpdmUpIHtcblxuICAgICAgLy8gdXBkYXRlIHBheWxvYWQgd2l0aCBhY3R1YWwgY29vcmRpbmF0ZXNcbiAgICAgIGFzc2lnbihwYXlsb2FkLCB7XG4gICAgICAgIHg6IHJvdW5kKGxvY2FsQ3VycmVudC54ICsgZGlzcGxhY2VtZW50LngpLFxuICAgICAgICB5OiByb3VuZChsb2NhbEN1cnJlbnQueSArIGRpc3BsYWNlbWVudC55KSxcbiAgICAgICAgZHg6IHJvdW5kKGxvY2FsRGVsdGEueCksXG4gICAgICAgIGR5OiByb3VuZChsb2NhbERlbHRhLnkpXG4gICAgICB9LCB7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50IH0pO1xuXG4gICAgICAvLyBlbWl0IG1vdmUgZXZlbnRcbiAgICAgIGZpcmUoJ21vdmUnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmQoZXZlbnQpIHtcbiAgICB2YXIgcHJldmlvdXNDb250ZXh0LFxuICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG5cbiAgICBpZiAoY29udGV4dC5hY3RpdmUpIHtcblxuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGNvbnRleHQucGF5bG9hZC5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG5cbiAgICAgICAgLy8gc3VwcHJlc3Mgb3JpZ2luYWwgZXZlbnQgKGNsaWNrLCAuLi4pXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UganVzdCBlbmRlZCBhIGRyYWcgb3BlcmF0aW9uXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbihldmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGltcGxlbWVudGF0aW9ucyBtYXkgc3RvcCByZXN0b3JpbmcgdGhlXG4gICAgICAvLyBvcmlnaW5hbCBzdGF0ZSAoc2VsZWN0aW9ucywgLi4uKSBieSBwcmV2ZW50aW5nIHRoZVxuICAgICAgLy8gZW5kIGV2ZW50cyBkZWZhdWx0IGFjdGlvblxuICAgICAgcmV0dXJuVmFsdWUgPSBmaXJlKCdlbmQnKTtcbiAgICB9XG5cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICBmaXJlKCdyZWplY3RlZCcpO1xuICAgIH1cblxuICAgIHByZXZpb3VzQ29udGV4dCA9IGNsZWFudXAocmV0dXJuVmFsdWUgIT09IHRydWUpO1xuXG4gICAgLy8gbGFzdCBldmVudCB0byBiZSBmaXJlZCB3aGVuIGFsbCBkcmFnIG9wZXJhdGlvbnMgYXJlIGRvbmVcbiAgICAvLyBhdCB0aGlzIHBvaW50IGluIHRpbWUgbm8gZHJhZyBvcGVyYXRpb24gaXMgaW4gcHJvZ3Jlc3MgYW55bW9yZVxuICAgIGZpcmUoJ2VuZGVkJywgcHJldmlvdXNDb250ZXh0KTtcbiAgfVxuXG5cbiAgLy8gY2FuY2VsIGFjdGl2ZSBkcmFnIG9wZXJhdGlvbiBpZiB0aGUgdXNlciBwcmVzc2VzXG4gIC8vIHRoZSBFU0Mga2V5IG9uIHRoZSBrZXlib2FyZFxuXG4gIGZ1bmN0aW9uIGNoZWNrQ2FuY2VsKGV2ZW50KSB7XG5cbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDI3KSB7XG4gICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG5cbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gcHJldmVudCBnaG9zdCBjbGljayB0aGF0IG1pZ2h0IG9jY3VyIGFmdGVyIGEgZmluaXNoZWRcbiAgLy8gZHJhZyBhbmQgZHJvcCBzZXNzaW9uXG5cbiAgZnVuY3Rpb24gdHJhcENsaWNrQW5kRW5kKGV2ZW50KSB7XG5cbiAgICB2YXIgdW50cmFwO1xuXG4gICAgLy8gdHJhcCB0aGUgY2xpY2sgaW4gY2FzZSB3ZSBhcmUgcGFydCBvZiBhbiBhY3RpdmVcbiAgICAvLyBkcmFnIG9wZXJhdGlvbi4gVGhpcyB3aWxsIGVmZmVjdGl2ZWx5IHByZXZlbnRcbiAgICAvLyB0aGUgZ2hvc3QgY2xpY2sgdGhhdCBjYW5ub3QgYmUgY2FuY2VsZWQgb3RoZXJ3aXNlLlxuICAgIGlmIChjb250ZXh0LmFjdGl2ZSkge1xuXG4gICAgICB1bnRyYXAgPSBpbnN0YWxsQ2xpY2tUcmFwKGV2ZW50QnVzKTtcblxuICAgICAgLy8gcmVtb3ZlIHRyYXAgYWZ0ZXIgbWluaW1hbCBkZWxheVxuICAgICAgc2V0VGltZW91dCh1bnRyYXAsIDQwMCk7XG5cbiAgICAgIC8vIHByZXZlbnQgZGVmYXVsdCBhY3Rpb24gKGNsaWNrKVxuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgIH1cblxuICAgIGVuZChldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFwVG91Y2goZXZlbnQpIHtcbiAgICBtb3ZlKGV2ZW50KTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSB0aGUgZHJhZyBldmVudHMgaG92ZXIgKGRqcy5tb2RlbC5CYXNlKSBhbmQgaG92ZXJHZnggKFNuYXA8U1ZHRWxlbWVudD4pXG4gIC8vIHByb3BlcnRpZXMgZHVyaW5nIGhvdmVyIGFuZCBvdXQgYW5kIGZpcmUge3ByZWZpeH0uaG92ZXIgYW5kIHtwcmVmaXh9Lm91dCBwcm9wZXJ0aWVzXG4gIC8vIHJlc3BlY3RpdmVseVxuXG4gIGZ1bmN0aW9uIGhvdmVyKGV2ZW50KSB7XG4gICAgdmFyIHBheWxvYWQgPSBjb250ZXh0LnBheWxvYWQ7XG5cbiAgICBwYXlsb2FkLmhvdmVyR2Z4ID0gZXZlbnQuZ2Z4O1xuICAgIHBheWxvYWQuaG92ZXIgPSBldmVudC5lbGVtZW50O1xuXG4gICAgZmlyZSgnaG92ZXInKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG91dChldmVudCkge1xuICAgIGZpcmUoJ291dCcpO1xuXG4gICAgdmFyIHBheWxvYWQgPSBjb250ZXh0LnBheWxvYWQ7XG5cbiAgICBwYXlsb2FkLmhvdmVyR2Z4ID0gbnVsbDtcbiAgICBwYXlsb2FkLmhvdmVyID0gbnVsbDtcbiAgfVxuXG5cbiAgLy8gbGlmZS1jeWNsZSBtZXRob2RzXG5cbiAgZnVuY3Rpb24gY2FuY2VsKHJlc3RvcmUpIHtcbiAgICB2YXIgcHJldmlvdXNDb250ZXh0O1xuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhc0FjdGl2ZSA9IGNvbnRleHQuYWN0aXZlO1xuXG4gICAgaWYgKHdhc0FjdGl2ZSkge1xuICAgICAgZmlyZSgnY2FuY2VsJyk7XG4gICAgfVxuXG4gICAgcHJldmlvdXNDb250ZXh0ID0gY2xlYW51cChyZXN0b3JlKTtcblxuICAgIGlmICh3YXNBY3RpdmUpIHtcblxuICAgICAgLy8gbGFzdCBldmVudCB0byBiZSBmaXJlZCB3aGVuIGFsbCBkcmFnIG9wZXJhdGlvbnMgYXJlIGRvbmVcbiAgICAgIC8vIGF0IHRoaXMgcG9pbnQgaW4gdGltZSBubyBkcmFnIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzcyBhbnltb3JlXG4gICAgICBmaXJlKCdjYW5jZWxlZCcsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cChyZXN0b3JlKSB7XG4gICAgdmFyIHByZXZpb3VzQ29udGV4dCxcbiAgICAgICAgZW5kRHJhZztcblxuICAgIGZpcmUoJ2NsZWFudXAnKTtcblxuICAgIC8vIHJlc2V0IGN1cnNvclxuICAgIGN1cnNvclVuc2V0KCk7XG5cbiAgICBpZiAoY29udGV4dC50cmFwQ2xpY2spIHtcbiAgICAgIGVuZERyYWcgPSB0cmFwQ2xpY2tBbmRFbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZERyYWcgPSBlbmQ7XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgZG9tIGxpc3RlbmVyc1xuICAgIGRvbUV2ZW50LnVuYmluZChkb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdmUpO1xuXG4gICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCAnZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xuICAgIGRvbUV2ZW50LnVuYmluZChkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xuXG4gICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCAnbW91c2Vkb3duJywgZW5kRHJhZywgdHJ1ZSk7XG4gICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCAnbW91c2V1cCcsIGVuZERyYWcsIHRydWUpO1xuXG4gICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCAna2V5dXAnLCBjaGVja0NhbmNlbCk7XG5cbiAgICBkb21FdmVudC51bmJpbmQoZG9jdW1lbnQsICd0b3VjaHN0YXJ0JywgdHJhcFRvdWNoLCB0cnVlKTtcbiAgICBkb21FdmVudC51bmJpbmQoZG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIGNhbmNlbCwgdHJ1ZSk7XG4gICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCAndG91Y2htb3ZlJywgbW92ZSwgdHJ1ZSk7XG4gICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCAndG91Y2hlbmQnLCBlbmQsIHRydWUpO1xuXG4gICAgZXZlbnRCdXMub2ZmKCdlbGVtZW50LmhvdmVyJywgaG92ZXIpO1xuICAgIGV2ZW50QnVzLm9mZignZWxlbWVudC5vdXQnLCBvdXQpO1xuXG4gICAgLy8gcmVtb3ZlIGRyYWcgbWFya2VyIG9uIHJvb3QgZWxlbWVudFxuICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoY2FudmFzLmdldFJvb3RFbGVtZW50KCksIERSQUdfQUNUSVZFX0NMUyk7XG5cbiAgICAvLyByZXN0b3JlIHNlbGVjdGlvbiwgdW5sZXNzIGl0IGhhcyBjaGFuZ2VkXG4gICAgdmFyIHByZXZpb3VzU2VsZWN0aW9uID0gY29udGV4dC5wYXlsb2FkLnByZXZpb3VzU2VsZWN0aW9uO1xuXG4gICAgaWYgKHJlc3RvcmUgIT09IGZhbHNlICYmIHByZXZpb3VzU2VsZWN0aW9uICYmICFzZWxlY3Rpb24uZ2V0KCkubGVuZ3RoKSB7XG4gICAgICByZXN0b3JlU2VsZWN0aW9uKHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICpcbiAgICogSWYgYGxvY2FsUG9zaXRpb25gIGlzIGdpdmVuLCBkcmFnIGV2ZW50cyB3aWxsIGJlIGVtaXR0ZWRcbiAgICogcmVsYXRpdmUgdG8gaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudHxUb3VjaEV2ZW50fSBbZXZlbnRdXG4gICAqIEBwYXJhbSB7UG9pbnR9IFtsb2NhbFBvc2l0aW9uXSBhY3R1YWwgZGlhZ3JhbSBsb2NhbCBwb3NpdGlvbiB0aGlzIGRyYWcgb3BlcmF0aW9uIHNob3VsZCBzdGFydCBhdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIGZ1bmN0aW9uIGluaXQoZXZlbnQsIHJlbGF0aXZlVG8sIHByZWZpeCwgb3B0aW9ucykge1xuXG4gICAgLy8gb25seSBvbmUgZHJhZyBvcGVyYXRpb24gbWF5IGJlIGFjdGl2ZSwgYXQgYSB0aW1lXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGNhbmNlbChmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZWxhdGl2ZVRvID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IHByZWZpeDtcbiAgICAgIHByZWZpeCA9IHJlbGF0aXZlVG87XG4gICAgICByZWxhdGl2ZVRvID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YSB8fCB7fSxcbiAgICAgICAgb3JpZ2luYWxFdmVudCxcbiAgICAgICAgZ2xvYmFsU3RhcnQsXG4gICAgICAgIGxvY2FsU3RhcnQsXG4gICAgICAgIGVuZERyYWcsXG4gICAgICAgIGlzVG91Y2g7XG5cbiAgICBpZiAob3B0aW9ucy50cmFwQ2xpY2spIHtcbiAgICAgIGVuZERyYWcgPSB0cmFwQ2xpY2tBbmRFbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZERyYWcgPSBlbmQ7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBvcmlnaW5hbEV2ZW50ID0gZ2V0T3JpZ2luYWwoZXZlbnQpIHx8IGV2ZW50O1xuICAgICAgZ2xvYmFsU3RhcnQgPSB0b1BvaW50KGV2ZW50KTtcblxuICAgICAgc3RvcFByb3BhZ2F0aW9uKGV2ZW50KTtcblxuICAgICAgLy8gcHJldmVudCBkZWZhdWx0IGJyb3dzZXIgZHJhZ2dpbmcgYmVoYXZpb3JcbiAgICAgIGlmIChvcmlnaW5hbEV2ZW50LnR5cGUgPT09ICdkcmFnc3RhcnQnKSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0KG9yaWdpbmFsRXZlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcmlnaW5hbEV2ZW50ID0gbnVsbDtcbiAgICAgIGdsb2JhbFN0YXJ0ID0geyB4OiAwLCB5OiAwIH07XG4gICAgfVxuXG4gICAgbG9jYWxTdGFydCA9IHRvTG9jYWxQb2ludChnbG9iYWxTdGFydCk7XG5cbiAgICBpZiAoIXJlbGF0aXZlVG8pIHtcbiAgICAgIHJlbGF0aXZlVG8gPSBsb2NhbFN0YXJ0O1xuICAgIH1cblxuICAgIGlzVG91Y2ggPSBpc1RvdWNoRXZlbnQob3JpZ2luYWxFdmVudCk7XG5cbiAgICBjb250ZXh0ID0gYXNzaWduKHtcbiAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHBheWxvYWQ6IHt9LFxuICAgICAgZ2xvYmFsU3RhcnQ6IGdsb2JhbFN0YXJ0LFxuICAgICAgZGlzcGxhY2VtZW50OiBkZWx0YVBvcyhyZWxhdGl2ZVRvLCBsb2NhbFN0YXJ0KSxcbiAgICAgIGxvY2FsU3RhcnQ6IGxvY2FsU3RhcnQsXG4gICAgICBpc1RvdWNoOiBpc1RvdWNoXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBza2lwIGRvbSByZWdpc3RyYXRpb24gaWYgdHJpZ2dlclxuICAgIC8vIGlzIHNldCB0byBtYW51YWwgKGR1cmluZyB0ZXN0aW5nKVxuICAgIGlmICghb3B0aW9ucy5tYW51YWwpIHtcblxuICAgICAgLy8gYWRkIGRvbSBsaXN0ZW5lcnNcblxuICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgZG9tRXZlbnQuYmluZChkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCB0cmFwVG91Y2gsIHRydWUpO1xuICAgICAgICBkb21FdmVudC5iaW5kKGRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBjYW5jZWwsIHRydWUpO1xuICAgICAgICBkb21FdmVudC5iaW5kKGRvY3VtZW50LCAndG91Y2htb3ZlJywgbW92ZSwgdHJ1ZSk7XG4gICAgICAgIGRvbUV2ZW50LmJpbmQoZG9jdW1lbnQsICd0b3VjaGVuZCcsIGVuZCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIGFzc3VtZSB3ZSB1c2UgdGhlIG1vdXNlIHRvIGludGVyYWN0IHBlciBkZWZhdWx0XG4gICAgICAgIGRvbUV2ZW50LmJpbmQoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtb3ZlKTtcblxuICAgICAgICAvLyBwcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBkcmFnIGFuZCB0ZXh0IHNlbGVjdGlvbiBiZWhhdmlvclxuICAgICAgICBkb21FdmVudC5iaW5kKGRvY3VtZW50LCAnZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xuICAgICAgICBkb21FdmVudC5iaW5kKGRvY3VtZW50LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG5cbiAgICAgICAgZG9tRXZlbnQuYmluZChkb2N1bWVudCwgJ21vdXNlZG93bicsIGVuZERyYWcsIHRydWUpO1xuICAgICAgICBkb21FdmVudC5iaW5kKGRvY3VtZW50LCAnbW91c2V1cCcsIGVuZERyYWcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBkb21FdmVudC5iaW5kKGRvY3VtZW50LCAna2V5dXAnLCBjaGVja0NhbmNlbCk7XG5cbiAgICAgIGV2ZW50QnVzLm9uKCdlbGVtZW50LmhvdmVyJywgaG92ZXIpO1xuICAgICAgZXZlbnRCdXMub24oJ2VsZW1lbnQub3V0Jywgb3V0KTtcbiAgICB9XG5cbiAgICBmaXJlKCdpbml0Jyk7XG5cbiAgICBpZiAob3B0aW9ucy5hdXRvQWN0aXZhdGUpIHtcbiAgICAgIG1vdmUoZXZlbnQsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbmNlbCBvbiBkaWFncmFtIGRlc3RydWN0aW9uXG4gIGV2ZW50QnVzLm9uKCdkaWFncmFtLmRlc3Ryb3knLCBjYW5jZWwpO1xuXG5cbiAgLy8gQVBJXG5cbiAgdGhpcy5pbml0ID0gaW5pdDtcbiAgdGhpcy5tb3ZlID0gbW92ZTtcbiAgdGhpcy5ob3ZlciA9IGhvdmVyO1xuICB0aGlzLm91dCA9IG91dDtcbiAgdGhpcy5lbmQgPSBlbmQ7XG5cbiAgdGhpcy5jYW5jZWwgPSBjYW5jZWw7XG5cbiAgLy8gZm9yIGludHJvc3BlY3Rpb25cblxuICB0aGlzLmNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfTtcblxuICB0aGlzLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgYXNzaWduKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgfTtcbn1cblxuRHJhZ2dpbmcuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcycsXG4gICdzZWxlY3Rpb24nLFxuICAnZWxlbWVudFJlZ2lzdHJ5J1xuXTtcbiIsImltcG9ydCBIb3ZlckZpeE1vZHVsZSBmcm9tICcuLi9ob3Zlci1maXgnO1xuaW1wb3J0IFNlbGVjdGlvbk1vZHVsZSBmcm9tICcuLi9zZWxlY3Rpb24nO1xuXG5pbXBvcnQgRHJhZ2dpbmcgZnJvbSAnLi9EcmFnZ2luZyc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIEhvdmVyRml4TW9kdWxlLFxuICAgIFNlbGVjdGlvbk1vZHVsZSxcbiAgXSxcbiAgZHJhZ2dpbmc6IFsgJ3R5cGUnLCBEcmFnZ2luZyBdLFxufTsiLCJpbXBvcnQge1xuICBmb3JFYWNoLFxuICBpc0FycmF5XG59IGZyb20gJ21pbi1kYXNoJztcblxudmFyIE5PVF9SRUdJU1RFUkVEX0VSUk9SID0gJ2lzIG5vdCBhIHJlZ2lzdGVyZWQgYWN0aW9uJyxcbiAgICBJU19SRUdJU1RFUkVEX0VSUk9SID0gJ2lzIGFscmVhZHkgcmVnaXN0ZXJlZCc7XG5cblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gbW9kZWxpbmcgYWN0aW9ucyBieSBkZWNvdXBsaW5nXG4gKiB0aGUgb25lIHdobyByZXF1ZXN0cyB0aGUgYWN0aW9uIHRvIGJlIHRyaWdnZXJlZCBhbmQgdGhlIHRyaWdnZXIgaXRzZWxmLlxuICpcbiAqIEl0J3MgcG9zc2libGUgdG8gYWRkIG5ldyBhY3Rpb25zIGJ5IHJlZ2lzdGVyaW5nIHRoZW0gd2l0aCDCtHJlZ2lzdGVyQWN0aW9uwrRcbiAqIGFuZCBsaWtld2lzZSB1bnJlZ2lzdGVyIGV4aXN0aW5nIG9uZXMgd2l0aCDCtHVucmVnaXN0ZXJBY3Rpb27CtC5cbiAqXG4gKlxuICogIyMgTGlmZS1DeWNsZSBhbmQgY29uZmlndXJhdGlvblxuICpcbiAqIFRoZSBlZGl0b3IgYWN0aW9ucyB3aWxsIHdhaXQgZm9yIGRpYWdyYW0gaW5pdGlhbGl6YXRpb24gYmVmb3JlXG4gKiByZWdpc3RlcmluZyBkZWZhdWx0IGFjdGlvbnMgX2FuZF8gZmlyaW5nIGFuIGBlZGl0b3JBY3Rpb25zLmluaXRgIGV2ZW50LlxuICpcbiAqIEludGVyZXN0ZWQgcGFydGllcyBtYXkgbGlzdGVuIHRvIHRoZSBgZWRpdG9yQWN0aW9ucy5pbml0YCBldmVudCB3aXRoXG4gKiBsb3cgcHJpb3JpdHkgdG8gY2hlY2ssIHdoaWNoIGFjdGlvbnMgZ290IHJlZ2lzdGVyZWQuIE90aGVyIGNvbXBvbmVudHNcbiAqIG1heSB1c2UgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIHRoZWlyIG93biBhY3Rpb25zIHZpYSBgcmVnaXN0ZXJBY3Rpb25gLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0luamVjdG9yfSBpbmplY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFZGl0b3JBY3Rpb25zKGV2ZW50QnVzLCBpbmplY3Rvcikge1xuXG4gIC8vIGluaXRpYWxpemUgYWN0aW9uc1xuICB0aGlzLl9hY3Rpb25zID0ge307XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGV2ZW50QnVzLm9uKCdkaWFncmFtLmluaXQnLCBmdW5jdGlvbigpIHtcblxuICAgIC8vIGFsbCBkaWFncmFtIG1vZHVsZXMgZ290IGxvYWRlZDsgY2hlY2sgd2hpY2ggb25lc1xuICAgIC8vIGFyZSBhdmFpbGFibGUgYW5kIHJlZ2lzdGVyIHRoZSByZXNwZWN0aXZlIGRlZmF1bHQgYWN0aW9uc1xuICAgIHNlbGYuX3JlZ2lzdGVyRGVmYXVsdEFjdGlvbnMoaW5qZWN0b3IpO1xuXG4gICAgLy8gYXNrIGludGVyZXN0ZWQgcGFydGllcyB0byByZWdpc3RlciBhdmFpbGFibGUgZWRpdG9yXG4gICAgLy8gYWN0aW9ucyBvbiBkaWFncmFtIGluaXRpYWxpemF0aW9uXG4gICAgZXZlbnRCdXMuZmlyZSgnZWRpdG9yQWN0aW9ucy5pbml0Jywge1xuICAgICAgZWRpdG9yQWN0aW9uczogc2VsZlxuICAgIH0pO1xuICB9KTtcblxufVxuXG5FZGl0b3JBY3Rpb25zLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdpbmplY3Rvcidcbl07XG5cbi8qKlxuICogUmVnaXN0ZXIgZGVmYXVsdCBhY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7SW5qZWN0b3J9IGluamVjdG9yXG4gKi9cbkVkaXRvckFjdGlvbnMucHJvdG90eXBlLl9yZWdpc3RlckRlZmF1bHRBY3Rpb25zID0gZnVuY3Rpb24oaW5qZWN0b3IpIHtcblxuICAvLyAoMSkgcmV0cmlldmUgb3B0aW9uYWwgY29tcG9uZW50cyB0byBpbnRlZ3JhdGUgd2l0aFxuXG4gIHZhciBjb21tYW5kU3RhY2sgPSBpbmplY3Rvci5nZXQoJ2NvbW1hbmRTdGFjaycsIGZhbHNlKTtcbiAgdmFyIG1vZGVsaW5nID0gaW5qZWN0b3IuZ2V0KCdtb2RlbGluZycsIGZhbHNlKTtcbiAgdmFyIHNlbGVjdGlvbiA9IGluamVjdG9yLmdldCgnc2VsZWN0aW9uJywgZmFsc2UpO1xuICB2YXIgem9vbVNjcm9sbCA9IGluamVjdG9yLmdldCgnem9vbVNjcm9sbCcsIGZhbHNlKTtcbiAgdmFyIGNvcHlQYXN0ZSA9IGluamVjdG9yLmdldCgnY29weVBhc3RlJywgZmFsc2UpO1xuICB2YXIgY2FudmFzID0gaW5qZWN0b3IuZ2V0KCdjYW52YXMnLCBmYWxzZSk7XG4gIHZhciBydWxlcyA9IGluamVjdG9yLmdldCgncnVsZXMnLCBmYWxzZSk7XG4gIHZhciBrZXlib2FyZE1vdmUgPSBpbmplY3Rvci5nZXQoJ2tleWJvYXJkTW92ZScsIGZhbHNlKTtcbiAgdmFyIGtleWJvYXJkTW92ZVNlbGVjdGlvbiA9IGluamVjdG9yLmdldCgna2V5Ym9hcmRNb3ZlU2VsZWN0aW9uJywgZmFsc2UpO1xuXG4gIC8vICgyKSBjaGVjayBjb21wb25lbnRzIGFuZCByZWdpc3RlciBhY3Rpb25zXG5cbiAgaWYgKGNvbW1hbmRTdGFjaykge1xuICAgIHRoaXMucmVnaXN0ZXIoJ3VuZG8nLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbW1hbmRTdGFjay51bmRvKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyKCdyZWRvJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb21tYW5kU3RhY2sucmVkbygpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGNvcHlQYXN0ZSAmJiBzZWxlY3Rpb24pIHtcbiAgICB0aGlzLnJlZ2lzdGVyKCdjb3B5JywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZWN0ZWRFbGVtZW50cyA9IHNlbGVjdGlvbi5nZXQoKTtcblxuICAgICAgY29weVBhc3RlLmNvcHkoc2VsZWN0ZWRFbGVtZW50cyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoY29weVBhc3RlKSB7XG4gICAgdGhpcy5yZWdpc3RlcigncGFzdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvcHlQYXN0ZS5wYXN0ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHpvb21TY3JvbGwpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKCdzdGVwWm9vbScsIGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgIHpvb21TY3JvbGwuc3RlcFpvb20ob3B0cy52YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoY2FudmFzKSB7XG4gICAgdGhpcy5yZWdpc3Rlcignem9vbScsIGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgIGNhbnZhcy56b29tKG9wdHMudmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKG1vZGVsaW5nICYmIHNlbGVjdGlvbiAmJiBydWxlcykge1xuICAgIHRoaXMucmVnaXN0ZXIoJ3JlbW92ZVNlbGVjdGlvbicsIGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgc2VsZWN0ZWRFbGVtZW50cyA9IHNlbGVjdGlvbi5nZXQoKTtcblxuICAgICAgaWYgKCFzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhbGxvd2VkID0gcnVsZXMuYWxsb3dlZCgnZWxlbWVudHMuZGVsZXRlJywgeyBlbGVtZW50czogc2VsZWN0ZWRFbGVtZW50cyB9KSxcbiAgICAgICAgICByZW1vdmFibGVFbGVtZW50cztcblxuICAgICAgaWYgKGFsbG93ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXkoYWxsb3dlZCkpIHtcbiAgICAgICAgcmVtb3ZhYmxlRWxlbWVudHMgPSBhbGxvd2VkO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92YWJsZUVsZW1lbnRzID0gc2VsZWN0ZWRFbGVtZW50cztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92YWJsZUVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBtb2RlbGluZy5yZW1vdmVFbGVtZW50cyhyZW1vdmFibGVFbGVtZW50cy5zbGljZSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChrZXlib2FyZE1vdmUpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKCdtb3ZlQ2FudmFzJywgZnVuY3Rpb24ob3B0cykge1xuICAgICAga2V5Ym9hcmRNb3ZlLm1vdmVDYW52YXMob3B0cyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoa2V5Ym9hcmRNb3ZlU2VsZWN0aW9uKSB7XG4gICAgdGhpcy5yZWdpc3RlcignbW92ZVNlbGVjdGlvbicsIGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgIGtleWJvYXJkTW92ZVNlbGVjdGlvbi5tb3ZlU2VsZWN0aW9uKG9wdHMuZGlyZWN0aW9uLCBvcHRzLmFjY2VsZXJhdGVkKTtcbiAgICB9KTtcbiAgfVxuXG59O1xuXG5cbi8qKlxuICogVHJpZ2dlcnMgYSByZWdpc3RlcmVkIGFjdGlvblxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gYWN0aW9uXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHNcbiAqXG4gKiBAcmV0dXJuIHtVbmtub3dufSBSZXR1cm5zIHdoYXQgdGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXIgcmV0dXJuc1xuICovXG5FZGl0b3JBY3Rpb25zLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oYWN0aW9uLCBvcHRzKSB7XG4gIGlmICghdGhpcy5fYWN0aW9uc1thY3Rpb25dKSB7XG4gICAgdGhyb3cgZXJyb3IoYWN0aW9uLCBOT1RfUkVHSVNURVJFRF9FUlJPUik7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fYWN0aW9uc1thY3Rpb25dKG9wdHMpO1xufTtcblxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGNvbGxlY3Rpb25zIG9mIGFjdGlvbnMuXG4gKiBUaGUga2V5IG9mIHRoZSBvYmplY3Qgd2lsbCBiZSB0aGUgbmFtZSBvZiB0aGUgYWN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiDCtMK0wrRcbiAqIHZhciBhY3Rpb25zID0ge1xuICogICBzcGFjZVRvb2w6IGZ1bmN0aW9uKCkge1xuICogICAgIHNwYWNlVG9vbC5hY3RpdmF0ZVNlbGVjdGlvbigpO1xuICogICB9LFxuICogICBsYXNzb1Rvb2w6IGZ1bmN0aW9uKCkge1xuICogICAgIGxhc3NvVG9vbC5hY3RpdmF0ZVNlbGVjdGlvbigpO1xuICogICB9XG4gKiBdO1xuICpcbiAqIGVkaXRvckFjdGlvbnMucmVnaXN0ZXIoYWN0aW9ucyk7XG4gKlxuICogZWRpdG9yQWN0aW9ucy5pc1JlZ2lzdGVyZWQoJ3NwYWNlVG9vbCcpOyAvLyB0cnVlXG4gKiDCtMK0wrRcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGFjdGlvbnNcbiAqL1xuRWRpdG9yQWN0aW9ucy5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihhY3Rpb25zLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25zID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0aGlzLl9yZWdpc3RlckFjdGlvbihhY3Rpb25zLCBsaXN0ZW5lcik7XG4gIH1cblxuICBmb3JFYWNoKGFjdGlvbnMsIGZ1bmN0aW9uKGxpc3RlbmVyLCBhY3Rpb24pIHtcbiAgICBzZWxmLl9yZWdpc3RlckFjdGlvbihhY3Rpb24sIGxpc3RlbmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRvIGFuIGFjdGlvbiBrZXlcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGFjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKi9cbkVkaXRvckFjdGlvbnMucHJvdG90eXBlLl9yZWdpc3RlckFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgbGlzdGVuZXIpIHtcbiAgaWYgKHRoaXMuaXNSZWdpc3RlcmVkKGFjdGlvbikpIHtcbiAgICB0aHJvdyBlcnJvcihhY3Rpb24sIElTX1JFR0lTVEVSRURfRVJST1IpO1xuICB9XG5cbiAgdGhpcy5fYWN0aW9uc1thY3Rpb25dID0gbGlzdGVuZXI7XG59O1xuXG4vKipcbiAqIFVucmVnaXN0ZXIgYW4gZXhpc3RpbmcgYWN0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICovXG5FZGl0b3JBY3Rpb25zLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gIGlmICghdGhpcy5pc1JlZ2lzdGVyZWQoYWN0aW9uKSkge1xuICAgIHRocm93IGVycm9yKGFjdGlvbiwgTk9UX1JFR0lTVEVSRURfRVJST1IpO1xuICB9XG5cbiAgdGhpcy5fYWN0aW9uc1thY3Rpb25dID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYWN0aW9ucyB0aGF0IGFyZSBjdXJyZW50bHkgcmVnaXN0ZXJlZFxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRWRpdG9yQWN0aW9ucy5wcm90b3R5cGUuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fYWN0aW9ucyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3ZXRoZXIgdGhlIGdpdmVuIGFjdGlvbiBpcyByZWdpc3RlcmVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkVkaXRvckFjdGlvbnMucHJvdG90eXBlLmlzUmVnaXN0ZXJlZCA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gISF0aGlzLl9hY3Rpb25zW2FjdGlvbl07XG59O1xuXG5cbmZ1bmN0aW9uIGVycm9yKGFjdGlvbiwgbWVzc2FnZSkge1xuICByZXR1cm4gbmV3IEVycm9yKGFjdGlvbiArICcgJyArIG1lc3NhZ2UpO1xufVxuIiwiaW1wb3J0IEVkaXRvckFjdGlvbnMgZnJvbSAnLi9FZGl0b3JBY3Rpb25zJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAnZWRpdG9yQWN0aW9ucycgXSxcbiAgZWRpdG9yQWN0aW9uczogWyAndHlwZScsIEVkaXRvckFjdGlvbnMgXVxufTtcbiIsImltcG9ydCB7XG4gIGhhc1ByaW1hcnlNb2RpZmllclxufSBmcm9tICcuLi8uLi91dGlsL01vdXNlJztcblxuaW1wb3J0IHsgaXNLZXkgfSBmcm9tICcuLi8uLi9mZWF0dXJlcy9rZXlib2FyZC9LZXlib2FyZFV0aWwnO1xuXG52YXIgSElHSF9QUklPUklUWSA9IDE1MDA7XG52YXIgSEFORF9DVVJTT1IgPSAnZ3JhYic7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSGFuZFRvb2woXG4gICAgZXZlbnRCdXMsIGNhbnZhcywgZHJhZ2dpbmcsXG4gICAgaW5qZWN0b3IsIHRvb2xNYW5hZ2VyLCBtb3VzZSkge1xuXG4gIHRoaXMuX2RyYWdnaW5nID0gZHJhZ2dpbmc7XG4gIHRoaXMuX21vdXNlID0gbW91c2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAga2V5Ym9hcmQgPSBpbmplY3Rvci5nZXQoJ2tleWJvYXJkJywgZmFsc2UpO1xuXG4gIHRvb2xNYW5hZ2VyLnJlZ2lzdGVyVG9vbCgnaGFuZCcsIHtcbiAgICB0b29sOiAnaGFuZCcsXG4gICAgZHJhZ2dpbmc6ICdoYW5kLm1vdmUnXG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm1vdXNlZG93bicsIEhJR0hfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICBpZiAoIWhhc1ByaW1hcnlNb2RpZmllcihldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLmFjdGl2YXRlTW92ZShldmVudC5vcmlnaW5hbEV2ZW50LCB0cnVlKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG5cbiAga2V5Ym9hcmQgJiYga2V5Ym9hcmQuYWRkTGlzdGVuZXIoSElHSF9QUklPUklUWSwgZnVuY3Rpb24oZSkge1xuICAgIGlmICghaXNTcGFjZShlLmtleUV2ZW50KSB8fCBzZWxmLmlzQWN0aXZlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuX21vdXNlLmdldExhc3RNb3ZlRXZlbnQoKTtcblxuICAgIHNlbGYuYWN0aXZhdGVNb3ZlKG1vdXNlRXZlbnQsICEhbW91c2VFdmVudCk7XG4gIH0sICdrZXlib2FyZC5rZXlkb3duJyk7XG5cbiAga2V5Ym9hcmQgJiYga2V5Ym9hcmQuYWRkTGlzdGVuZXIoSElHSF9QUklPUklUWSwgZnVuY3Rpb24oZSkge1xuICAgIGlmICghaXNTcGFjZShlLmtleUV2ZW50KSB8fCAhc2VsZi5pc0FjdGl2ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi50b2dnbGUoKTtcbiAgfSwgJ2tleWJvYXJkLmtleXVwJyk7XG5cbiAgZXZlbnRCdXMub24oJ2hhbmQuZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQub3JpZ2luYWxFdmVudC50YXJnZXQ7XG5cbiAgICAvLyBvbmx5IHJlYWN0aXZlIG9uIGRpYWdyYW0gY2xpY2tcbiAgICAvLyBvbiBzb21lIG9jY2FzaW9ucywgZXZlbnQuaG92ZXIgaXMgbm90IHNldCBhbmQgd2UgaGF2ZSB0byBjaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGFuIHN2Z1xuICAgIGlmICghZXZlbnQuaG92ZXIgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGV2ZW50QnVzLm9uY2UoJ2hhbmQuZW5kZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuYWN0aXZhdGVNb3ZlKGV2ZW50Lm9yaWdpbmFsRXZlbnQsIHsgcmVhY3RpdmF0ZTogdHJ1ZSB9KTtcbiAgICB9KTtcblxuICB9KTtcblxuICBldmVudEJ1cy5vbignaGFuZC5tb3ZlLm1vdmUnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBzY2FsZSA9IGNhbnZhcy52aWV3Ym94KCkuc2NhbGU7XG5cbiAgICBjYW52YXMuc2Nyb2xsKHtcbiAgICAgIGR4OiBldmVudC5keCAqIHNjYWxlLFxuICAgICAgZHk6IGV2ZW50LmR5ICogc2NhbGVcbiAgICB9KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2hhbmQubW92ZS5lbmQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgcmVhY3RpdmF0ZSA9IGNvbnRleHQucmVhY3RpdmF0ZTtcblxuICAgIC8vIERvbid0IHJlYWN0aXZhdGUgaWYgdGhlIHVzZXIgaXMgdXNpbmcgdGhlIGtleWJvYXJkIGtleWJpbmRpbmdcbiAgICBpZiAoIWhhc1ByaW1hcnlNb2RpZmllcihldmVudCkgJiYgcmVhY3RpdmF0ZSkge1xuXG4gICAgICBldmVudEJ1cy5vbmNlKCdoYW5kLm1vdmUuZW5kZWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBzZWxmLmFjdGl2YXRlSGFuZChldmVudC5vcmlnaW5hbEV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcblxufVxuXG5IYW5kVG9vbC4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJyxcbiAgJ2RyYWdnaW5nJyxcbiAgJ2luamVjdG9yJyxcbiAgJ3Rvb2xNYW5hZ2VyJyxcbiAgJ21vdXNlJ1xuXTtcblxuXG5IYW5kVG9vbC5wcm90b3R5cGUuYWN0aXZhdGVNb3ZlID0gZnVuY3Rpb24oZXZlbnQsIGF1dG9BY3RpdmF0ZSwgY29udGV4dCkge1xuICBpZiAodHlwZW9mIGF1dG9BY3RpdmF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjb250ZXh0ID0gYXV0b0FjdGl2YXRlO1xuICAgIGF1dG9BY3RpdmF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5fZHJhZ2dpbmcuaW5pdChldmVudCwgJ2hhbmQubW92ZScsIHtcbiAgICBhdXRvQWN0aXZhdGU6IGF1dG9BY3RpdmF0ZSxcbiAgICBjdXJzb3I6IEhBTkRfQ1VSU09SLFxuICAgIGRhdGE6IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQgfHwge31cbiAgICB9XG4gIH0pO1xufTtcblxuSGFuZFRvb2wucHJvdG90eXBlLmFjdGl2YXRlSGFuZCA9IGZ1bmN0aW9uKGV2ZW50LCBhdXRvQWN0aXZhdGUsIHJlYWN0aXZhdGUpIHtcbiAgdGhpcy5fZHJhZ2dpbmcuaW5pdChldmVudCwgJ2hhbmQnLCB7XG4gICAgdHJhcENsaWNrOiBmYWxzZSxcbiAgICBhdXRvQWN0aXZhdGU6IGF1dG9BY3RpdmF0ZSxcbiAgICBjdXJzb3I6IEhBTkRfQ1VSU09SLFxuICAgIGRhdGE6IHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgcmVhY3RpdmF0ZTogcmVhY3RpdmF0ZVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5IYW5kVG9vbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJhZ2dpbmcuY2FuY2VsKCk7XG4gIH1cblxuICB2YXIgbW91c2VFdmVudCA9IHRoaXMuX21vdXNlLmdldExhc3RNb3ZlRXZlbnQoKTtcblxuICB0aGlzLmFjdGl2YXRlSGFuZChtb3VzZUV2ZW50LCAhIW1vdXNlRXZlbnQpO1xufTtcblxuSGFuZFRvb2wucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5fZHJhZ2dpbmcuY29udGV4dCgpO1xuXG4gIGlmIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIC9eKGhhbmR8aGFuZFxcLm1vdmUpJC8udGVzdChjb250ZXh0LnByZWZpeCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNTcGFjZShrZXlFdmVudCkge1xuICByZXR1cm4gaXNLZXkoJyAnLCBrZXlFdmVudCk7XG59IiwiaW1wb3J0IFRvb2xNYW5hZ2VyTW9kdWxlIGZyb20gJy4uL3Rvb2wtbWFuYWdlcic7XG5pbXBvcnQgTW91c2VNb2R1bGUgZnJvbSAnLi4vbW91c2UnO1xuXG5pbXBvcnQgSGFuZFRvb2wgZnJvbSAnLi9IYW5kVG9vbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBUb29sTWFuYWdlck1vZHVsZSxcbiAgICBNb3VzZU1vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAnaGFuZFRvb2wnIF0sXG4gIGhhbmRUb29sOiBbICd0eXBlJywgSGFuZFRvb2wgXVxufTtcbiIsImltcG9ydCB7XG4gIGNsb3Nlc3QgYXMgZG9tQ2xvc2VzdFxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgdG9Qb2ludFxufSBmcm9tICcuLi8uLi91dGlsL0V2ZW50JztcblxudmFyIEhJR0hfUFJJT1JJVFkgPSAxNTAwO1xuXG5cbi8qKlxuICogQnJvd3NlcnMgbWF5IHN3YWxsb3cgY2VydGFpbiBldmVudHMgKGhvdmVyLCBvdXQgLi4uKSBpZiB1c2VycyBhcmUgdG9cbiAqIGZhc3Qgd2l0aCB0aGUgbW91c2UuXG4gKlxuICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc0NDg0Njgvd2h5LWNhbnQtaS1yZWxpYWJseS1jYXB0dXJlLWEtbW91c2VvdXQtZXZlbnRcbiAqXG4gKiBUaGUgZml4IGltcGxlbWVudGVkIGluIHRoaXMgY29tcG9uZW50IGVuc3VyZSB0aGF0IHdlXG4gKlxuICogMSkgaGF2ZSBhIGhvdmVyIHN0YXRlIGFmdGVyIGEgc3VjY2Vzc2Z1bCBkcmFnLm1vdmUgZXZlbnRcbiAqIDIpIGhhdmUgYW4gb3V0IGV2ZW50IHdoZW4gZHJhZ2dpbmcgbGVhdmVzIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnRSZWdpc3RyeX0gZWxlbWVudFJlZ2lzdHJ5XG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtJbmplY3Rvcn0gaW5qZWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG92ZXJGaXgoZWxlbWVudFJlZ2lzdHJ5LCBldmVudEJ1cywgaW5qZWN0b3IpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGRyYWdnaW5nID0gaW5qZWN0b3IuZ2V0KCdkcmFnZ2luZycsIGZhbHNlKTtcblxuICAvKipcbiAgICogTWFrZSBzdXJlIHdlIGFyZSBnb2QgZGFtbiBob3ZlcmluZyFcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZHJhZ2dpbmcgZXZlbnRcbiAgICovXG4gIGZ1bmN0aW9uIGVuc3VyZUhvdmVyKGV2ZW50KSB7XG5cbiAgICBpZiAoZXZlbnQuaG92ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cbiAgICB2YXIgZ2Z4ID0gc2VsZi5fZmluZFRhcmdldEdmeChvcmlnaW5hbEV2ZW50KTtcblxuICAgIHZhciBlbGVtZW50ID0gZ2Z4ICYmIGVsZW1lbnRSZWdpc3RyeS5nZXQoZ2Z4KTtcblxuICAgIGlmIChnZnggJiYgZWxlbWVudCkge1xuXG4gICAgICAvLyAxKSBjYW5jZWwgY3VycmVudCBtb3VzZW1vdmVcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAvLyAyKSBlbWl0IGZha2UgaG92ZXIgZm9yIG5ldyB0YXJnZXRcbiAgICAgIGRyYWdnaW5nLmhvdmVyKHsgZWxlbWVudDogZWxlbWVudCwgZ2Z4OiBnZnggfSk7XG5cbiAgICAgIC8vIDMpIHJlLXRyaWdnZXIgbW92ZSBldmVudFxuICAgICAgZHJhZ2dpbmcubW92ZShvcmlnaW5hbEV2ZW50KTtcbiAgICB9XG4gIH1cblxuXG4gIGlmIChkcmFnZ2luZykge1xuXG4gICAgLyoqXG4gICAgICogV2Ugd2FpdCBmb3IgYSBzcGVjaWZpYyBzZXF1ZW5jZSBvZiBldmVudHMgYmVmb3JlXG4gICAgICogZW1pdHRpbmcgYSBmYWtlIGRyYWcuaG92ZXIgZXZlbnQuXG4gICAgICpcbiAgICAgKiBFdmVudCBTZXF1ZW5jZTpcbiAgICAgKlxuICAgICAqIGRyYWcuc3RhcnRcbiAgICAgKiBkcmFnLm1vdmUgPj4gZW5zdXJlIHdlIGFyZSBob3ZlcmluZ1xuICAgICAqL1xuICAgIGV2ZW50QnVzLm9uKCdkcmFnLnN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgZXZlbnRCdXMub25jZSgnZHJhZy5tb3ZlJywgSElHSF9QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICBlbnN1cmVIb3ZlcihldmVudCk7XG5cbiAgICAgIH0pO1xuXG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXZSBtYWtlIHN1cmUgdGhhdCBlbGVtZW50Lm91dCBpcyBhbHdheXMgZmlyZWQsIGV2ZW4gaWYgdGhlXG4gICAqIGJyb3dzZXIgc3dhbGxvd3MgYW4gZWxlbWVudC5vdXQgZXZlbnQuXG4gICAqXG4gICAqIEV2ZW50IHNlcXVlbmNlOlxuICAgKlxuICAgKiBlbGVtZW50LmhvdmVyXG4gICAqIChlbGVtZW50Lm91dCA+PiBzb21ldGltZXMgc3dhbGxvd2VkKVxuICAgKiBlbGVtZW50LmhvdmVyID4+IGVuc3VyZSB3ZSBmaXJlZCBlbGVtZW50Lm91dFxuICAgKi9cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBob3ZlckdmeDtcbiAgICB2YXIgaG92ZXI7XG5cbiAgICBldmVudEJ1cy5vbignZWxlbWVudC5ob3ZlcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgIC8vICgxKSByZW1lbWJlciBjdXJyZW50IGhvdmVyIGVsZW1lbnRcbiAgICAgIGhvdmVyR2Z4ID0gZXZlbnQuZ2Z4O1xuICAgICAgaG92ZXIgPSBldmVudC5lbGVtZW50O1xuICAgIH0pO1xuXG4gICAgZXZlbnRCdXMub24oJ2VsZW1lbnQuaG92ZXInLCBISUdIX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAvLyAoMykgYW0gSSBvbiBhbiBlbGVtZW50IHN0aWxsP1xuICAgICAgaWYgKGhvdmVyKSB7XG5cbiAgICAgICAgLy8gKDQpIHRoYXQgaXMgYSBwcm9ibGVtLCBnb3R0YSBcInNpbXVsYXRlIHRoZSBvdXRcIlxuICAgICAgICBldmVudEJ1cy5maXJlKCdlbGVtZW50Lm91dCcsIHtcbiAgICAgICAgICBlbGVtZW50OiBob3ZlcixcbiAgICAgICAgICBnZng6IGhvdmVyR2Z4XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBldmVudEJ1cy5vbignZWxlbWVudC5vdXQnLCBmdW5jdGlvbigpIHtcblxuICAgICAgLy8gKDIpIHVuc2V0IGhvdmVyIHN0YXRlIGlmIHdlIGNvcnJlY3RseSBvdXRlZCB1cyAqR0cqXG4gICAgICBob3ZlckdmeCA9IG51bGw7XG4gICAgICBob3ZlciA9IG51bGw7XG4gICAgfSk7XG5cbiAgfSkoKTtcblxuICB0aGlzLl9maW5kVGFyZ2V0R2Z4ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcG9zaXRpb24sXG4gICAgICAgIHRhcmdldDtcblxuICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwb3NpdGlvbiA9IHRvUG9pbnQoZXZlbnQpO1xuXG4gICAgLy8gZGFtbiBleHBlbnNpdmUgb3BlcmF0aW9uLCBvdWNoIVxuICAgIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG5cbiAgICByZXR1cm4gZ2V0R2Z4KHRhcmdldCk7XG4gIH07XG5cbn1cblxuSG92ZXJGaXguJGluamVjdCA9IFtcbiAgJ2VsZW1lbnRSZWdpc3RyeScsXG4gICdldmVudEJ1cycsXG4gICdpbmplY3Rvcidcbl07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gZ2V0R2Z4KHRhcmdldCkge1xuICByZXR1cm4gZG9tQ2xvc2VzdCh0YXJnZXQsICdzdmcsIC5kanMtZWxlbWVudCcsIHRydWUpO1xufSIsImltcG9ydCBIb3ZlckZpeCBmcm9tICcuL0hvdmVyRml4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogW1xuICAgICdob3ZlckZpeCdcbiAgXSxcbiAgaG92ZXJGaXg6IFsgJ3R5cGUnLCBIb3ZlckZpeCBdLFxufTsiLCJpbXBvcnQge1xuICBmb3JFYWNoLFxuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBkZWxlZ2F0ZSBhcyBkb21EZWxlZ2F0ZSxcbiAgcXVlcnkgYXMgZG9tUXVlcnksXG4gIHF1ZXJ5QWxsIGFzIGRvbVF1ZXJ5QWxsXG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQge1xuICBpc1ByaW1hcnlCdXR0b24sXG4gIGlzQXV4aWxpYXJ5QnV0dG9uXG59IGZyb20gJy4uLy4uL3V0aWwvTW91c2UnO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXG4gIHJlbW92ZSBhcyBzdmdSZW1vdmVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVMaW5lLFxuICB1cGRhdGVMaW5lXG59IGZyb20gJy4uLy4uL3V0aWwvUmVuZGVyVXRpbCc7XG5cbmZ1bmN0aW9uIGFsbG93QWxsKGV2ZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbmZ1bmN0aW9uIGFsbG93UHJpbWFyeUFuZEF1eGlsaWFyeShldmVudCkge1xuICByZXR1cm4gaXNQcmltYXJ5QnV0dG9uKGV2ZW50KSB8fCBpc0F1eGlsaWFyeUJ1dHRvbihldmVudCk7XG59XG5cbnZhciBMT1dfUFJJT1JJVFkgPSA1MDA7XG5cblxuLyoqXG4gKiBBIHBsdWdpbiB0aGF0IHByb3ZpZGVzIGludGVyYWN0aW9uIGV2ZW50cyBmb3IgZGlhZ3JhbSBlbGVtZW50cy5cbiAqXG4gKiBJdCBlbWl0cyB0aGUgZm9sbG93aW5nIGV2ZW50czpcbiAqXG4gKiAgICogZWxlbWVudC5jbGlja1xuICogICAqIGVsZW1lbnQuY29udGV4dG1lbnVcbiAqICAgKiBlbGVtZW50LmRibGNsaWNrXG4gKiAgICogZWxlbWVudC5ob3ZlclxuICogICAqIGVsZW1lbnQubW91c2Vkb3duXG4gKiAgICogZWxlbWVudC5tb3VzZW1vdmVcbiAqICAgKiBlbGVtZW50Lm1vdXNldXBcbiAqICAgKiBlbGVtZW50Lm91dFxuICpcbiAqIEVhY2ggZXZlbnQgaXMgYSB0dXBsZSB7IGVsZW1lbnQsIGdmeCwgb3JpZ2luYWxFdmVudCB9LlxuICpcbiAqIENhbmNlbGluZyB0aGUgZXZlbnQgdmlhIEV2ZW50I3ByZXZlbnREZWZhdWx0KClcbiAqIHByZXZlbnRzIHRoZSBvcmlnaW5hbCBET00gb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEludGVyYWN0aW9uRXZlbnRzKGV2ZW50QnVzLCBlbGVtZW50UmVnaXN0cnksIHN0eWxlcykge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvKipcbiAgICogRmlyZSBhbiBpbnRlcmFjdGlvbiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgbG9jYWwgZXZlbnQgbmFtZSwgZS5nLiBlbGVtZW50LmNsaWNrLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50fSBldmVudCBuYXRpdmUgZXZlbnRcbiAgICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gW2VsZW1lbnRdIHRoZSBkaWFncmFtIGVsZW1lbnQgdG8gZW1pdCB0aGUgZXZlbnQgb247XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0cyB0byB0aGUgZXZlbnQgdGFyZ2V0XG4gICAqL1xuICBmdW5jdGlvbiBmaXJlKHR5cGUsIGV2ZW50LCBlbGVtZW50KSB7XG5cbiAgICBpZiAoaXNJZ25vcmVkKHR5cGUsIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQsIGdmeCwgcmV0dXJuVmFsdWU7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHRhcmdldCA9IGV2ZW50LmRlbGVnYXRlVGFyZ2V0IHx8IGV2ZW50LnRhcmdldDtcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBnZnggPSB0YXJnZXQ7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50UmVnaXN0cnkuZ2V0KGdmeCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdmeCA9IGVsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWdmeCB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVyblZhbHVlID0gZXZlbnRCdXMuZmlyZSh0eXBlLCB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgZ2Z4OiBnZngsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuXG4gICAgaWYgKHJldHVyblZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE8obmlra3UpOiBkb2N1bWVudCB0aGlzXG4gIHZhciBoYW5kbGVycyA9IHt9O1xuXG4gIGZ1bmN0aW9uIG1vdXNlSGFuZGxlcihsb2NhbEV2ZW50TmFtZSkge1xuICAgIHJldHVybiBoYW5kbGVyc1tsb2NhbEV2ZW50TmFtZV07XG4gIH1cblxuICBmdW5jdGlvbiBpc0lnbm9yZWQobG9jYWxFdmVudE5hbWUsIGV2ZW50KSB7XG5cbiAgICB2YXIgZmlsdGVyID0gaWdub3JlZEZpbHRlcnNbbG9jYWxFdmVudE5hbWVdIHx8IGlzUHJpbWFyeUJ1dHRvbjtcblxuICAgIC8vIG9ubHkgcmVhY3Qgb24gbGVmdCBtb3VzZSBidXR0b24gaW50ZXJhY3Rpb25zXG4gICAgLy8gZXhjZXB0IGZvciBpbnRlcmFjdGlvbiBldmVudHMgdGhhdCBhcmUgZW5hYmxlZFxuICAgIC8vIGZvciBzZWN1bmRhcnkgbW91c2UgYnV0dG9uXG4gICAgcmV0dXJuICFmaWx0ZXIoZXZlbnQpO1xuICB9XG5cbiAgdmFyIGJpbmRpbmdzID0ge1xuICAgIGNsaWNrOiAnZWxlbWVudC5jbGljaycsXG4gICAgY29udGV4dG1lbnU6ICdlbGVtZW50LmNvbnRleHRtZW51JyxcbiAgICBkYmxjbGljazogJ2VsZW1lbnQuZGJsY2xpY2snLFxuICAgIG1vdXNlZG93bjogJ2VsZW1lbnQubW91c2Vkb3duJyxcbiAgICBtb3VzZW1vdmU6ICdlbGVtZW50Lm1vdXNlbW92ZScsXG4gICAgbW91c2VvdmVyOiAnZWxlbWVudC5ob3ZlcicsXG4gICAgbW91c2VvdXQ6ICdlbGVtZW50Lm91dCcsXG4gICAgbW91c2V1cDogJ2VsZW1lbnQubW91c2V1cCcsXG4gIH07XG5cbiAgdmFyIGlnbm9yZWRGaWx0ZXJzID0ge1xuICAgICdlbGVtZW50LmNvbnRleHRtZW51JzogYWxsb3dBbGwsXG4gICAgJ2VsZW1lbnQubW91c2Vkb3duJzogYWxsb3dQcmltYXJ5QW5kQXV4aWxpYXJ5LFxuICAgICdlbGVtZW50Lm1vdXNldXAnOiBhbGxvd1ByaW1hcnlBbmRBdXhpbGlhcnksXG4gICAgJ2VsZW1lbnQuY2xpY2snOiBhbGxvd1ByaW1hcnlBbmRBdXhpbGlhcnksXG4gICAgJ2VsZW1lbnQuZGJsY2xpY2snOiBhbGxvd1ByaW1hcnlBbmRBdXhpbGlhcnlcbiAgfTtcblxuXG4gIC8vIG1hbnVhbCBldmVudCB0cmlnZ2VyIC8vLy8vLy8vLy9cblxuICAvKipcbiAgICogVHJpZ2dlciBhbiBpbnRlcmFjdGlvbiBldmVudCAoYmFzZWQgb24gYSBuYXRpdmUgZG9tIGV2ZW50KVxuICAgKiBvbiB0aGUgdGFyZ2V0IHNoYXBlIG9yIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgdGhlIG5hbWUgb2YgdGhlIHRyaWdnZXJlZCBET00gZXZlbnRcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSB0YXJnZXRFbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiB0cmlnZ2VyTW91c2VFdmVudChldmVudE5hbWUsIGV2ZW50LCB0YXJnZXRFbGVtZW50KSB7XG5cbiAgICAvLyBpLmUuIGVsZW1lbnQubW91c2Vkb3duLi4uXG4gICAgdmFyIGxvY2FsRXZlbnROYW1lID0gYmluZGluZ3NbZXZlbnROYW1lXTtcblxuICAgIGlmICghbG9jYWxFdmVudE5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5tYXBwZWQgRE9NIGV2ZW50IG5hbWUgPCcgKyBldmVudE5hbWUgKyAnPicpO1xuICAgIH1cblxuICAgIHJldHVybiBmaXJlKGxvY2FsRXZlbnROYW1lLCBldmVudCwgdGFyZ2V0RWxlbWVudCk7XG4gIH1cblxuXG4gIHZhciBFTEVNRU5UX1NFTEVDVE9SID0gJ3N2ZywgLmRqcy1lbGVtZW50JztcblxuICAvLyBldmVudCBoYW5kbGluZyAvLy8vLy8vXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJFdmVudChub2RlLCBldmVudCwgbG9jYWxFdmVudCwgaWdub3JlZEZpbHRlcikge1xuXG4gICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tsb2NhbEV2ZW50XSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBmaXJlKGxvY2FsRXZlbnQsIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgaWYgKGlnbm9yZWRGaWx0ZXIpIHtcbiAgICAgIGlnbm9yZWRGaWx0ZXJzW2xvY2FsRXZlbnRdID0gaWdub3JlZEZpbHRlcjtcbiAgICB9XG5cbiAgICBoYW5kbGVyLiRkZWxlZ2F0ZSA9IGRvbURlbGVnYXRlLmJpbmQobm9kZSwgRUxFTUVOVF9TRUxFQ1RPUiwgZXZlbnQsIGhhbmRsZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5yZWdpc3RlckV2ZW50KG5vZGUsIGV2ZW50LCBsb2NhbEV2ZW50KSB7XG5cbiAgICB2YXIgaGFuZGxlciA9IG1vdXNlSGFuZGxlcihsb2NhbEV2ZW50KTtcblxuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvbURlbGVnYXRlLnVuYmluZChub2RlLCBldmVudCwgaGFuZGxlci4kZGVsZWdhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMoc3ZnKSB7XG4gICAgZm9yRWFjaChiaW5kaW5ncywgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgIHJlZ2lzdGVyRXZlbnQoc3ZnLCBrZXksIHZhbCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyRXZlbnRzKHN2Zykge1xuICAgIGZvckVhY2goYmluZGluZ3MsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICB1bnJlZ2lzdGVyRXZlbnQoc3ZnLCBrZXksIHZhbCk7XG4gICAgfSk7XG4gIH1cblxuICBldmVudEJ1cy5vbignY2FudmFzLmRlc3Ryb3knLCBmdW5jdGlvbihldmVudCkge1xuICAgIHVucmVnaXN0ZXJFdmVudHMoZXZlbnQuc3ZnKTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2NhbnZhcy5pbml0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZWdpc3RlckV2ZW50cyhldmVudC5zdmcpO1xuICB9KTtcblxuXG4gIC8vIGhpdCBib3ggdXBkYXRpbmcgLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGV2ZW50QnVzLm9uKFsgJ3NoYXBlLmFkZGVkJywgJ2Nvbm5lY3Rpb24uYWRkZWQnIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC5lbGVtZW50LFxuICAgICAgICBnZnggPSBldmVudC5nZng7XG5cbiAgICBldmVudEJ1cy5maXJlKCdpbnRlcmFjdGlvbkV2ZW50cy5jcmVhdGVIaXQnLCB7IGVsZW1lbnQ6IGVsZW1lbnQsIGdmeDogZ2Z4IH0pO1xuICB9KTtcblxuICAvLyBVcGRhdGUgZGpzLWhpdCBvbiBjaGFuZ2UuXG4gIC8vIEEgbG93IHByaW9ydGl0eSBpcyBuZWNlc3NhcnksIGJlY2F1c2UgZGpzLWhpdCBvZiBsYWJlbHMgaGFzIHRvIGJlIHVwZGF0ZWRcbiAgLy8gYWZ0ZXIgdGhlIGxhYmVsIGJvdW5kcyBoYXZlIGJlZW4gdXBkYXRlZCBpbiB0aGUgcmVuZGVyZXIuXG4gIGV2ZW50QnVzLm9uKFtcbiAgICAnc2hhcGUuY2hhbmdlZCcsXG4gICAgJ2Nvbm5lY3Rpb24uY2hhbmdlZCdcbiAgXSwgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC5lbGVtZW50LFxuICAgICAgICBnZnggPSBldmVudC5nZng7XG5cbiAgICBldmVudEJ1cy5maXJlKCdpbnRlcmFjdGlvbkV2ZW50cy51cGRhdGVIaXQnLCB7IGVsZW1lbnQ6IGVsZW1lbnQsIGdmeDogZ2Z4IH0pO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignaW50ZXJhY3Rpb25FdmVudHMuY3JlYXRlSGl0JywgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudCxcbiAgICAgICAgZ2Z4ID0gZXZlbnQuZ2Z4O1xuXG4gICAgc2VsZi5jcmVhdGVEZWZhdWx0SGl0KGVsZW1lbnQsIGdmeCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdpbnRlcmFjdGlvbkV2ZW50cy51cGRhdGVIaXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudCxcbiAgICAgICAgZ2Z4ID0gZXZlbnQuZ2Z4O1xuXG4gICAgc2VsZi51cGRhdGVEZWZhdWx0SGl0KGVsZW1lbnQsIGdmeCk7XG4gIH0pO1xuXG5cbiAgLy8gaGl0IHN0eWxlcyAvLy8vLy8vLy8vLy9cblxuICB2YXIgU1RST0tFX0hJVF9TVFlMRSA9IGNyZWF0ZUhpdFN0eWxlKCdkanMtaGl0IGRqcy1oaXQtc3Ryb2tlJyk7XG5cbiAgdmFyIENMSUNLX1NUUk9LRV9ISVRfU1RZTEUgPSBjcmVhdGVIaXRTdHlsZSgnZGpzLWhpdCBkanMtaGl0LWNsaWNrLXN0cm9rZScpO1xuXG4gIHZhciBBTExfSElUX1NUWUxFID0gY3JlYXRlSGl0U3R5bGUoJ2Rqcy1oaXQgZGpzLWhpdC1hbGwnKTtcblxuICB2YXIgSElUX1RZUEVTID0ge1xuICAgICdhbGwnOiBBTExfSElUX1NUWUxFLFxuICAgICdjbGljay1zdHJva2UnOiBDTElDS19TVFJPS0VfSElUX1NUWUxFLFxuICAgICdzdHJva2UnOiBTVFJPS0VfSElUX1NUWUxFXG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlSGl0U3R5bGUoY2xhc3NOYW1lcywgYXR0cnMpIHtcblxuICAgIGF0dHJzID0gYXNzaWduKHtcbiAgICAgIHN0cm9rZTogJ3doaXRlJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAxNVxuICAgIH0sIGF0dHJzIHx8IHt9KTtcblxuICAgIHJldHVybiBzdHlsZXMuY2xzKGNsYXNzTmFtZXMsIFsgJ25vLWZpbGwnLCAnbm8tYm9yZGVyJyBdLCBhdHRycyk7XG4gIH1cblxuXG4gIC8vIHN0eWxlIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gYXBwbHlTdHlsZShoaXQsIHR5cGUpIHtcblxuICAgIHZhciBhdHRycyA9IEhJVF9UWVBFU1t0eXBlXTtcblxuICAgIGlmICghYXR0cnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBoaXQgdHlwZSA8JyArIHR5cGUgKyAnPicpO1xuICAgIH1cblxuICAgIHN2Z0F0dHIoaGl0LCBhdHRycyk7XG5cbiAgICByZXR1cm4gaGl0O1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kSGl0KGdmeCwgaGl0KSB7XG4gICAgc3ZnQXBwZW5kKGdmeCwgaGl0KTtcbiAgfVxuXG5cbiAgLy8gQVBJXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBoaW50cyBvbiB0aGUgZ2l2ZW4gZ3JhcGhpY3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ2Z4XG4gICAqL1xuICB0aGlzLnJlbW92ZUhpdHMgPSBmdW5jdGlvbihnZngpIHtcbiAgICB2YXIgaGl0cyA9IGRvbVF1ZXJ5QWxsKCcuZGpzLWhpdCcsIGdmeCk7XG5cbiAgICBmb3JFYWNoKGhpdHMsIHN2Z1JlbW92ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBkZWZhdWx0IGhpdCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBnZnhcbiAgICpcbiAgICogQHJldHVybiB7U1ZHRWxlbWVudH0gY3JlYXRlZCBoaXRcbiAgICovXG4gIHRoaXMuY3JlYXRlRGVmYXVsdEhpdCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGdmeCkge1xuICAgIHZhciB3YXlwb2ludHMgPSBlbGVtZW50LndheXBvaW50cyxcbiAgICAgICAgaXNGcmFtZSA9IGVsZW1lbnQuaXNGcmFtZSxcbiAgICAgICAgYm94VHlwZTtcblxuICAgIGlmICh3YXlwb2ludHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVdheXBvaW50c0hpdChnZngsIHdheXBvaW50cyk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgYm94VHlwZSA9IGlzRnJhbWUgPyAnc3Ryb2tlJyA6ICdhbGwnO1xuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVCb3hIaXQoZ2Z4LCBib3hUeXBlLCB7XG4gICAgICAgIHdpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBoaXRzIGZvciB0aGUgZ2l2ZW4gd2F5cG9pbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxuICAgKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gd2F5cG9pbnRzXG4gICAqXG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9XG4gICAqL1xuICB0aGlzLmNyZWF0ZVdheXBvaW50c0hpdCA9IGZ1bmN0aW9uKGdmeCwgd2F5cG9pbnRzKSB7XG5cbiAgICB2YXIgaGl0ID0gY3JlYXRlTGluZSh3YXlwb2ludHMpO1xuXG4gICAgYXBwbHlTdHlsZShoaXQsICdzdHJva2UnKTtcblxuICAgIGFwcGVuZEhpdChnZngsIGhpdCk7XG5cbiAgICByZXR1cm4gaGl0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgaGl0cyBmb3IgYSBib3guXG4gICAqXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ2Z4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoaXRUeXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyc1xuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICAgKi9cbiAgdGhpcy5jcmVhdGVCb3hIaXQgPSBmdW5jdGlvbihnZngsIHR5cGUsIGF0dHJzKSB7XG5cbiAgICBhdHRycyA9IGFzc2lnbih7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sIGF0dHJzKTtcblxuICAgIHZhciBoaXQgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcblxuICAgIGFwcGx5U3R5bGUoaGl0LCB0eXBlKTtcblxuICAgIHN2Z0F0dHIoaGl0LCBhdHRycyk7XG5cbiAgICBhcHBlbmRIaXQoZ2Z4LCBoaXQpO1xuXG4gICAgcmV0dXJuIGhpdDtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGRlZmF1bHQgaGl0IG9mIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICAgKiBAcGFyYW0gIHtTVkdFbGVtZW50fSBnZnhcbiAgICpcbiAgICogQHJldHVybiB7U1ZHRWxlbWVudH0gdXBkYXRlZCBoaXRcbiAgICovXG4gIHRoaXMudXBkYXRlRGVmYXVsdEhpdCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGdmeCkge1xuXG4gICAgdmFyIGhpdCA9IGRvbVF1ZXJ5KCcuZGpzLWhpdCcsIGdmeCk7XG5cbiAgICBpZiAoIWhpdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LndheXBvaW50cykge1xuICAgICAgdXBkYXRlTGluZShoaXQsIGVsZW1lbnQud2F5cG9pbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ZnQXR0cihoaXQsIHtcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBoaXQ7XG4gIH07XG5cbiAgdGhpcy5maXJlID0gZmlyZTtcblxuICB0aGlzLnRyaWdnZXJNb3VzZUV2ZW50ID0gdHJpZ2dlck1vdXNlRXZlbnQ7XG5cbiAgdGhpcy5tb3VzZUhhbmRsZXIgPSBtb3VzZUhhbmRsZXI7XG5cbiAgdGhpcy5yZWdpc3RlckV2ZW50ID0gcmVnaXN0ZXJFdmVudDtcbiAgdGhpcy51bnJlZ2lzdGVyRXZlbnQgPSB1bnJlZ2lzdGVyRXZlbnQ7XG59XG5cblxuSW50ZXJhY3Rpb25FdmVudHMuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2VsZW1lbnRSZWdpc3RyeScsXG4gICdzdHlsZXMnXG5dO1xuXG5cbi8qKlxuICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IHRoZSBtb3VzZSBob3ZlcmVkIG92ZXIgYW4gZWxlbWVudFxuICpcbiAqIEBldmVudCBlbGVtZW50LmhvdmVyXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gZ2Z4XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50XG4gKi9cblxuLyoqXG4gKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgdGhlIG1vdXNlIGhhcyBsZWZ0IGFuIGVsZW1lbnRcbiAqXG4gKiBAZXZlbnQgZWxlbWVudC5vdXRcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnhcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnRcbiAqL1xuXG4vKipcbiAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgbW91c2UgaGFzIGNsaWNrZWQgYW4gZWxlbWVudFxuICpcbiAqIEBldmVudCBlbGVtZW50LmNsaWNrXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gZ2Z4XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50XG4gKi9cblxuLyoqXG4gKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgdGhlIG1vdXNlIGhhcyBkb3VibGUgY2xpY2tlZCBhbiBlbGVtZW50XG4gKlxuICogQGV2ZW50IGVsZW1lbnQuZGJsY2xpY2tcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnhcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnRcbiAqL1xuXG4vKipcbiAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgbW91c2UgaGFzIGdvbmUgZG93biBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBldmVudCBlbGVtZW50Lm1vdXNlZG93blxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IGdmeFxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudFxuICovXG5cbi8qKlxuICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IHRoZSBtb3VzZSBoYXMgZ29uZSB1cCBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBldmVudCBlbGVtZW50Lm1vdXNldXBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnhcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnRcbiAqL1xuXG4vKipcbiAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgY29udGV4dCBtZW51IGFjdGlvbiBpcyB0cmlnZ2VyZWRcbiAqIHZpYSBtb3VzZSBvciB0b3VjaCBjb250cm9scy5cbiAqXG4gKiBAZXZlbnQgZWxlbWVudC5jb250ZXh0bWVudVxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IGdmeFxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudFxuICovIiwiaW1wb3J0IEludGVyYWN0aW9uRXZlbnRzIGZyb20gJy4vSW50ZXJhY3Rpb25FdmVudHMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdpbnRlcmFjdGlvbkV2ZW50cycgXSxcbiAgaW50ZXJhY3Rpb25FdmVudHM6IFsgJ3R5cGUnLCBJbnRlcmFjdGlvbkV2ZW50cyBdXG59OyIsImltcG9ydCB7XG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxudmFyIERFRkFVTFRfQ09ORklHID0ge1xuICBtb3ZlU3BlZWQ6IDEsXG4gIG1vdmVTcGVlZEFjY2VsZXJhdGVkOiAxMFxufTtcblxudmFyIEhJR0hFUl9QUklPUklUWSA9IDE1MDA7XG5cbnZhciBMRUZUID0gJ2xlZnQnO1xudmFyIFVQID0gJ3VwJztcbnZhciBSSUdIVCA9ICdyaWdodCc7XG52YXIgRE9XTiA9ICdkb3duJztcblxudmFyIEtFWV9UT19ESVJFQ1RJT04gPSB7XG4gIEFycm93TGVmdDogTEVGVCxcbiAgTGVmdDogTEVGVCxcbiAgQXJyb3dVcDogVVAsXG4gIFVwOiBVUCxcbiAgQXJyb3dSaWdodDogUklHSFQsXG4gIFJpZ2h0OiBSSUdIVCxcbiAgQXJyb3dEb3duOiBET1dOLFxuICBEb3duOiBET1dOXG59O1xuXG52YXIgRElSRUNUSU9OU19ERUxUQSA9IHtcbiAgbGVmdDogZnVuY3Rpb24oc3BlZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogLXNwZWVkLFxuICAgICAgeTogMFxuICAgIH07XG4gIH0sXG4gIHVwOiBmdW5jdGlvbihzcGVlZCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogLXNwZWVkXG4gICAgfTtcbiAgfSxcbiAgcmlnaHQ6IGZ1bmN0aW9uKHNwZWVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHNwZWVkLFxuICAgICAgeTogMFxuICAgIH07XG4gIH0sXG4gIGRvd246IGZ1bmN0aW9uKHNwZWVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiBzcGVlZFxuICAgIH07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBFbmFibGVzIHRvIG1vdmUgc2VsZWN0aW9uIHdpdGgga2V5Ym9hcmQgYXJyb3dzLlxuICogVXNlIHdpdGggU2hpZnQgZm9yIG1vZGlmaWVkIHNwZWVkIChkZWZhdWx0PTEsIHdpdGggU2hpZnQ9MTApLlxuICogUHJlc3NlZCBDbWQvQ3RybCB0dXJucyB0aGUgZmVhdHVyZSBvZmYuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubW92ZVNwZWVkPTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tb3ZlU3BlZWRBY2NlbGVyYXRlZD0xMF1cbiAqIEBwYXJhbSB7S2V5Ym9hcmR9IGtleWJvYXJkXG4gKiBAcGFyYW0ge01vZGVsaW5nfSBtb2RlbGluZ1xuICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbGVjdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBLZXlib2FyZE1vdmVTZWxlY3Rpb24oXG4gICAgY29uZmlnLFxuICAgIGtleWJvYXJkLFxuICAgIG1vZGVsaW5nLFxuICAgIHJ1bGVzLFxuICAgIHNlbGVjdGlvblxuKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuX2NvbmZpZyA9IGFzc2lnbih7fSwgREVGQVVMVF9DT05GSUcsIGNvbmZpZyB8fCB7fSk7XG5cbiAga2V5Ym9hcmQuYWRkTGlzdGVuZXIoSElHSEVSX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGtleUV2ZW50ID0gZXZlbnQua2V5RXZlbnQ7XG5cbiAgICB2YXIgZGlyZWN0aW9uID0gS0VZX1RPX0RJUkVDVElPTltrZXlFdmVudC5rZXldO1xuXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5Ym9hcmQuaXNDbWQoa2V5RXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFjY2VsZXJhdGVkID0ga2V5Ym9hcmQuaXNTaGlmdChrZXlFdmVudCk7XG5cbiAgICBzZWxmLm1vdmVTZWxlY3Rpb24oZGlyZWN0aW9uLCBhY2NlbGVyYXRlZCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogTW92ZSBzZWxlY3RlZCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLFxuICAgKiBvcHRpb25hbGx5IHNwZWNpZnlpbmcgYWNjZWxlcmF0ZWQgbW92ZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBbYWNjZWxlcmF0ZWQ9ZmFsc2VdXG4gICAqL1xuICB0aGlzLm1vdmVTZWxlY3Rpb24gPSBmdW5jdGlvbihkaXJlY3Rpb24sIGFjY2VsZXJhdGVkKSB7XG5cbiAgICB2YXIgc2VsZWN0ZWRFbGVtZW50cyA9IHNlbGVjdGlvbi5nZXQoKTtcblxuICAgIGlmICghc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3BlZWQgPSB0aGlzLl9jb25maWdbXG4gICAgICBhY2NlbGVyYXRlZCA/XG4gICAgICAgICdtb3ZlU3BlZWRBY2NlbGVyYXRlZCcgOlxuICAgICAgICAnbW92ZVNwZWVkJ1xuICAgIF07XG5cbiAgICB2YXIgZGVsdGEgPSBESVJFQ1RJT05TX0RFTFRBW2RpcmVjdGlvbl0oc3BlZWQpO1xuXG4gICAgdmFyIGNhbk1vdmUgPSBydWxlcy5hbGxvd2VkKCdlbGVtZW50cy5tb3ZlJywge1xuICAgICAgc2hhcGVzOiBzZWxlY3RlZEVsZW1lbnRzXG4gICAgfSk7XG5cbiAgICBpZiAoY2FuTW92ZSkge1xuICAgICAgbW9kZWxpbmcubW92ZUVsZW1lbnRzKHNlbGVjdGVkRWxlbWVudHMsIGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbn1cblxuS2V5Ym9hcmRNb3ZlU2VsZWN0aW9uLiRpbmplY3QgPSBbXG4gICdjb25maWcua2V5Ym9hcmRNb3ZlU2VsZWN0aW9uJyxcbiAgJ2tleWJvYXJkJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ3J1bGVzJyxcbiAgJ3NlbGVjdGlvbidcbl07IiwiaW1wb3J0IEtleWJvYXJkTW9kdWxlIGZyb20gJy4uL2tleWJvYXJkJztcbmltcG9ydCBTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnLi4vc2VsZWN0aW9uJztcblxuaW1wb3J0IEtleWJvYXJkTW92ZVNlbGVjdGlvbiBmcm9tICcuL0tleWJvYXJkTW92ZVNlbGVjdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBLZXlib2FyZE1vZHVsZSxcbiAgICBTZWxlY3Rpb25Nb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFtcbiAgICAna2V5Ym9hcmRNb3ZlU2VsZWN0aW9uJ1xuICBdLFxuICBrZXlib2FyZE1vdmVTZWxlY3Rpb246IFsgJ3R5cGUnLCBLZXlib2FyZE1vdmVTZWxlY3Rpb24gXVxufTtcbiIsImltcG9ydCB7XG4gIGlzRnVuY3Rpb25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBldmVudCBhcyBkb21FdmVudCxcbiAgbWF0Y2hlcyBhcyBkb21NYXRjaGVzXG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQge1xuICBoYXNNb2RpZmllcixcbiAgaXNDbWQsXG4gIGlzS2V5LFxuICBpc1NoaWZ0XG59IGZyb20gJy4vS2V5Ym9hcmRVdGlsJztcblxudmFyIEtFWURPV05fRVZFTlQgPSAna2V5Ym9hcmQua2V5ZG93bicsXG4gICAgS0VZVVBfRVZFTlQgPSAna2V5Ym9hcmQua2V5dXAnO1xuXG52YXIgREVGQVVMVF9QUklPUklUWSA9IDEwMDA7XG5cblxuLyoqXG4gKiBBIGtleWJvYXJkIGFic3RyYWN0aW9uIHRoYXQgbWF5IGJlIGFjdGl2YXRlZCBhbmRcbiAqIGRlYWN0aXZhdGVkIGJ5IHVzZXJzIGF0IHdpbGwsIGNvbnN1bWluZyBrZXkgZXZlbnRzXG4gKiBhbmQgdHJpZ2dlcmluZyBkaWFncmFtIGFjdGlvbnMuXG4gKlxuICogRm9yIGtleXMgcHJlc3NlZCBkb3duLCBrZXlib2FyZCBmaXJlcyBga2V5Ym9hcmQua2V5ZG93bmAgZXZlbnQuXG4gKiBUaGUgZXZlbnQgY29udGV4dCBjb250YWlucyBvbmUgZmllbGQgd2hpY2ggaXMgYEtleWJvYXJkRXZlbnRgIGV2ZW50LlxuICpcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBmaXJlcyB0aGUgZm9sbG93aW5nIGtleSBldmVudHMgdGhhdCBhbGxvd1xuICogb3RoZXIgY29tcG9uZW50cyB0byBob29rIGludG8ga2V5IGhhbmRsaW5nOlxuICpcbiAqICAtIGtleWJvYXJkLmJpbmRcbiAqICAtIGtleWJvYXJkLnVuYmluZFxuICogIC0ga2V5Ym9hcmQuaW5pdFxuICogIC0ga2V5Ym9hcmQuZGVzdHJveVxuICpcbiAqIEFsbCBldmVudHMgY29udGFpbiBvbmUgZmllbGQgd2hpY2ggaXMgbm9kZS5cbiAqXG4gKiBBIGRlZmF1bHQgYmluZGluZyBmb3IgdGhlIGtleWJvYXJkIG1heSBiZSBzcGVjaWZpZWQgdmlhIHRoZVxuICogYGtleWJvYXJkLmJpbmRUb2AgY29uZmlndXJhdGlvbiBvcHRpb24uXG4gKlxuICogQHBhcmFtIHtDb25maWd9IGNvbmZpZ1xuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gS2V5Ym9hcmQoY29uZmlnLCBldmVudEJ1cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5fY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuXG4gIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5fa2V5ZG93bkhhbmRsZXIuYmluZCh0aGlzKTtcbiAgdGhpcy5fa2V5dXBIYW5kbGVyID0gdGhpcy5fa2V5dXBIYW5kbGVyLmJpbmQodGhpcyk7XG5cbiAgLy8gcHJvcGVybHkgY2xlYW4gZG9tIHJlZ2lzdHJhdGlvbnNcbiAgZXZlbnRCdXMub24oJ2RpYWdyYW0uZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2ZpcmUoJ2Rlc3Ryb3knKTtcblxuICAgIHNlbGYudW5iaW5kKCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdkaWFncmFtLmluaXQnLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9maXJlKCdpbml0Jyk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdhdHRhY2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5iaW5kVG8pIHtcbiAgICAgIHNlbGYuYmluZChjb25maWcuYmluZFRvKTtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdkZXRhY2gnLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLnVuYmluZCgpO1xuICB9KTtcbn1cblxuS2V5Ym9hcmQuJGluamVjdCA9IFtcbiAgJ2NvbmZpZy5rZXlib2FyZCcsXG4gICdldmVudEJ1cydcbl07XG5cbktleWJvYXJkLnByb3RvdHlwZS5fa2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICB0aGlzLl9rZXlIYW5kbGVyKGV2ZW50LCBLRVlET1dOX0VWRU5UKTtcbn07XG5cbktleWJvYXJkLnByb3RvdHlwZS5fa2V5dXBIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdGhpcy5fa2V5SGFuZGxlcihldmVudCwgS0VZVVBfRVZFTlQpO1xufTtcblxuS2V5Ym9hcmQucHJvdG90eXBlLl9rZXlIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQsIHR5cGUpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCxcbiAgICAgIGV2ZW50QnVzUmVzdWx0O1xuXG4gIGlmIChpc0lucHV0KHRhcmdldCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICBrZXlFdmVudDogZXZlbnRcbiAgfTtcblxuICBldmVudEJ1c1Jlc3VsdCA9IHRoaXMuX2V2ZW50QnVzLmZpcmUodHlwZSB8fCBLRVlET1dOX0VWRU5ULCBjb250ZXh0KTtcblxuICBpZiAoZXZlbnRCdXNSZXN1bHQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG5LZXlib2FyZC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUga2V5Ym9hcmQgaXMgb25seSBib3VuZCBvbmNlIHRvIHRoZSBET01cbiAgdGhpcy51bmJpbmQoKTtcblxuICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAvLyBiaW5kIGtleSBldmVudHNcbiAgZG9tRXZlbnQuYmluZChub2RlLCAna2V5ZG93bicsIHRoaXMuX2tleWRvd25IYW5kbGVyLCB0cnVlKTtcbiAgZG9tRXZlbnQuYmluZChub2RlLCAna2V5dXAnLCB0aGlzLl9rZXl1cEhhbmRsZXIsIHRydWUpO1xuXG4gIHRoaXMuX2ZpcmUoJ2JpbmQnKTtcbn07XG5cbktleWJvYXJkLnByb3RvdHlwZS5nZXRCaW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlO1xufTtcblxuS2V5Ym9hcmQucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuX25vZGU7XG5cbiAgaWYgKG5vZGUpIHtcbiAgICB0aGlzLl9maXJlKCd1bmJpbmQnKTtcblxuICAgIC8vIHVuYmluZCBrZXkgZXZlbnRzXG4gICAgZG9tRXZlbnQudW5iaW5kKG5vZGUsICdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkhhbmRsZXIsIHRydWUpO1xuICAgIGRvbUV2ZW50LnVuYmluZChub2RlLCAna2V5dXAnLCB0aGlzLl9rZXl1cEhhbmRsZXIsIHRydWUpO1xuICB9XG5cbiAgdGhpcy5fbm9kZSA9IG51bGw7XG59O1xuXG5LZXlib2FyZC5wcm90b3R5cGUuX2ZpcmUgPSBmdW5jdGlvbihldmVudCkge1xuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdrZXlib2FyZC4nICsgZXZlbnQsIHsgbm9kZTogdGhpcy5fbm9kZSB9KTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZnVuY3Rpb24gdGhhdCBpcyBub3RpZmllZCB3aXRoIGBLZXlib2FyZEV2ZW50YCB3aGVuZXZlclxuICogdGhlIGtleWJvYXJkIGlzIGJvdW5kIGFuZCB0aGUgdXNlciBwcmVzc2VzIGEga2V5LiBJZiBubyBwcmlvcml0eSBpc1xuICogcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHZhbHVlIG9mIDEwMDAgaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5XVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKi9cbktleWJvYXJkLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHByaW9yaXR5LCBsaXN0ZW5lciwgdHlwZSkge1xuICBpZiAoaXNGdW5jdGlvbihwcmlvcml0eSkpIHtcbiAgICB0eXBlID0gbGlzdGVuZXI7XG4gICAgbGlzdGVuZXIgPSBwcmlvcml0eTtcbiAgICBwcmlvcml0eSA9IERFRkFVTFRfUFJJT1JJVFk7XG4gIH1cblxuICB0aGlzLl9ldmVudEJ1cy5vbih0eXBlIHx8IEtFWURPV05fRVZFTlQsIHByaW9yaXR5LCBsaXN0ZW5lcik7XG59O1xuXG5LZXlib2FyZC5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lciwgdHlwZSkge1xuICB0aGlzLl9ldmVudEJ1cy5vZmYodHlwZSB8fCBLRVlET1dOX0VWRU5ULCBsaXN0ZW5lcik7XG59O1xuXG5LZXlib2FyZC5wcm90b3R5cGUuaGFzTW9kaWZpZXIgPSBoYXNNb2RpZmllcjtcbktleWJvYXJkLnByb3RvdHlwZS5pc0NtZCA9IGlzQ21kO1xuS2V5Ym9hcmQucHJvdG90eXBlLmlzU2hpZnQgPSBpc1NoaWZ0O1xuS2V5Ym9hcmQucHJvdG90eXBlLmlzS2V5ID0gaXNLZXk7XG5cblxuXG4vLyBoZWxwZXJzIC8vLy8vLy9cblxuZnVuY3Rpb24gaXNJbnB1dCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCAmJiAoZG9tTWF0Y2hlcyh0YXJnZXQsICdpbnB1dCwgdGV4dGFyZWEnKSB8fCB0YXJnZXQuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xufVxuIiwiaW1wb3J0IHtcbiAgaXNDbWQsXG4gIGlzS2V5LFxuICBpc1NoaWZ0XG59IGZyb20gJy4vS2V5Ym9hcmRVdGlsJztcblxudmFyIExPV19QUklPUklUWSA9IDUwMDtcblxuZXhwb3J0IHZhciBLRVlDT0RFX0MgPSA2NztcbmV4cG9ydCB2YXIgS0VZQ09ERV9WID0gODY7XG5leHBvcnQgdmFyIEtFWUNPREVfWSA9IDg5O1xuZXhwb3J0IHZhciBLRVlDT0RFX1ogPSA5MDtcblxuZXhwb3J0IHZhciBLRVlTX0NPUFkgPSBbJ2MnLCAnQycsIEtFWUNPREVfQyBdO1xuZXhwb3J0IHZhciBLRVlTX1BBU1RFID0gWyAndicsICdWJywgS0VZQ09ERV9WIF07XG5leHBvcnQgdmFyIEtFWVNfUkVETyA9IFsgJ3knLCAnWScsIEtFWUNPREVfWSBdO1xuZXhwb3J0IHZhciBLRVlTX1VORE8gPSBbICd6JywgJ1onLCBLRVlDT0RFX1ogXTtcblxuXG4vKipcbiAqIEFkZHMgZGVmYXVsdCBrZXlib2FyZCBiaW5kaW5ncy5cbiAqXG4gKiBUaGlzIGRvZXMgbm90IHB1bGwgaW4gYW55IGZlYXR1cmVzIHdpbGwgYmluZCBvbmx5IGFjdGlvbnMgdGhhdFxuICogaGF2ZSBwcmV2aW91c2x5IGJlZW4gcmVnaXN0ZXJlZCBhZ2FpbnN0IHRoZSBlZGl0b3JBY3Rpb25zIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtLZXlib2FyZH0ga2V5Ym9hcmRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gS2V5Ym9hcmRCaW5kaW5ncyhldmVudEJ1cywga2V5Ym9hcmQpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRCdXMub24oJ2VkaXRvckFjdGlvbnMuaW5pdCcsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBlZGl0b3JBY3Rpb25zID0gZXZlbnQuZWRpdG9yQWN0aW9ucztcblxuICAgIHNlbGYucmVnaXN0ZXJCaW5kaW5ncyhrZXlib2FyZCwgZWRpdG9yQWN0aW9ucyk7XG4gIH0pO1xufVxuXG5LZXlib2FyZEJpbmRpbmdzLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdrZXlib2FyZCdcbl07XG5cblxuLyoqXG4gKiBSZWdpc3RlciBhdmFpbGFibGUga2V5Ym9hcmQgYmluZGluZ3MuXG4gKlxuICogQHBhcmFtIHtLZXlib2FyZH0ga2V5Ym9hcmRcbiAqIEBwYXJhbSB7RWRpdG9yQWN0aW9uc30gZWRpdG9yQWN0aW9uc1xuICovXG5LZXlib2FyZEJpbmRpbmdzLnByb3RvdHlwZS5yZWdpc3RlckJpbmRpbmdzID0gZnVuY3Rpb24oa2V5Ym9hcmQsIGVkaXRvckFjdGlvbnMpIHtcblxuICAvKipcbiAgICogQWRkIGtleWJvYXJkIGJpbmRpbmcgaWYgcmVzcGVjdGl2ZSBlZGl0b3IgYWN0aW9uXG4gICAqIGlzIHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGF0IGltcGxlbWVudHMgdGhlIGtleSBiaW5kaW5nXG4gICAqL1xuICBmdW5jdGlvbiBhZGRMaXN0ZW5lcihhY3Rpb24sIGZuKSB7XG5cbiAgICBpZiAoZWRpdG9yQWN0aW9ucy5pc1JlZ2lzdGVyZWQoYWN0aW9uKSkge1xuICAgICAga2V5Ym9hcmQuYWRkTGlzdGVuZXIoZm4pO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gdW5kb1xuICAvLyAoQ1RSTHxDTUQpICsgWlxuICBhZGRMaXN0ZW5lcigndW5kbycsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBldmVudCA9IGNvbnRleHQua2V5RXZlbnQ7XG5cbiAgICBpZiAoaXNDbWQoZXZlbnQpICYmICFpc1NoaWZ0KGV2ZW50KSAmJiBpc0tleShLRVlTX1VORE8sIGV2ZW50KSkge1xuICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCd1bmRvJyk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcmVkb1xuICAvLyBDVFJMICsgWVxuICAvLyBDTUQgKyBTSElGVCArIFpcbiAgYWRkTGlzdGVuZXIoJ3JlZG8nLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgaWYgKGlzQ21kKGV2ZW50KSAmJiAoaXNLZXkoS0VZU19SRURPLCBldmVudCkgfHwgKGlzS2V5KEtFWVNfVU5ETywgZXZlbnQpICYmIGlzU2hpZnQoZXZlbnQpKSkpIHtcbiAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcigncmVkbycpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNvcHlcbiAgLy8gQ1RSTC9DTUQgKyBDXG4gIGFkZExpc3RlbmVyKCdjb3B5JywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudDtcblxuICAgIGlmIChpc0NtZChldmVudCkgJiYgaXNLZXkoS0VZU19DT1BZLCBldmVudCkpIHtcbiAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcignY29weScpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHBhc3RlXG4gIC8vIENUUkwvQ01EICsgVlxuICBhZGRMaXN0ZW5lcigncGFzdGUnLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgaWYgKGlzQ21kKGV2ZW50KSAmJiBpc0tleShLRVlTX1BBU1RFLCBldmVudCkpIHtcbiAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcigncGFzdGUnKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyB6b29tIGluIG9uZSBzdGVwXG4gIC8vIENUUkwvQ01EICsgK1xuICBhZGRMaXN0ZW5lcignc3RlcFpvb20nLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgLy8gcXVpcms6IGl0IGhhcyB0byBiZSB0cmlnZ2VyZWQgYnkgYD1gIGFzIHdlbGwgdG8gd29yayBvbiBpbnRlcm5hdGlvbmFsIGtleWJvYXJkIGxheW91dFxuICAgIC8vIGNmOiBodHRwczovL2dpdGh1Yi5jb20vYnBtbi1pby9icG1uLWpzL2lzc3Vlcy8xMzYyI2lzc3VlY29tbWVudC03MjI5ODk3NTRcbiAgICBpZiAoaXNLZXkoWyAnKycsICdBZGQnLCAnPScgXSwgZXZlbnQpICYmIGlzQ21kKGV2ZW50KSkge1xuICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdzdGVwWm9vbScsIHsgdmFsdWU6IDEgfSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gem9vbSBvdXQgb25lIHN0ZXBcbiAgLy8gQ1RSTCArIC1cbiAgYWRkTGlzdGVuZXIoJ3N0ZXBab29tJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudDtcblxuICAgIGlmIChpc0tleShbICctJywgJ1N1YnRyYWN0JyBdLCBldmVudCkgJiYgaXNDbWQoZXZlbnQpKSB7XG4gICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ3N0ZXBab29tJywgeyB2YWx1ZTogLTEgfSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gem9vbSB0byB0aGUgZGVmYXVsdCBsZXZlbFxuICAvLyBDVFJMICsgMFxuICBhZGRMaXN0ZW5lcignem9vbScsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBldmVudCA9IGNvbnRleHQua2V5RXZlbnQ7XG5cbiAgICBpZiAoaXNLZXkoJzAnLCBldmVudCkgJiYgaXNDbWQoZXZlbnQpKSB7XG4gICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ3pvb20nLCB7IHZhbHVlOiAxIH0pO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGRlbGV0ZSBzZWxlY3RlZCBlbGVtZW50XG4gIC8vIERFTFxuICBhZGRMaXN0ZW5lcigncmVtb3ZlU2VsZWN0aW9uJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudDtcblxuICAgIGlmIChpc0tleShbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJyBdLCBldmVudCkpIHtcbiAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcigncmVtb3ZlU2VsZWN0aW9uJyk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59OyIsImltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdtaW4tZGFzaCc7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGV2ZW50IHdhcyB0cmlnZ2VyZWQgd2l0aCBhbnkgbW9kaWZpZXJcclxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc01vZGlmaWVyKGV2ZW50KSB7XHJcbiAgcmV0dXJuIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0NtZChldmVudCkge1xyXG5cclxuICAvLyBlbnN1cmUgd2UgZG9uJ3QgcmVhY3QgdG8gQWx0R3JcclxuICAvLyAobWFwcGVkIHRvIENUUkwgKyBBTFQpXHJcbiAgaWYgKGV2ZW50LmFsdEtleSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBrZXkgcHJlc3NlZCBpcyBvbmUgb2YgcHJvdmlkZWQga2V5cy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0ga2V5c1xyXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNLZXkoa2V5cywgZXZlbnQpIHtcclxuICBrZXlzID0gaXNBcnJheShrZXlzKSA/IGtleXMgOiBbIGtleXMgXTtcclxuXHJcbiAgcmV0dXJuIGtleXMuaW5kZXhPZihldmVudC5rZXkpICE9PSAtMSB8fCBrZXlzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgIT09IC0xO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU2hpZnQoZXZlbnQpIHtcclxuICByZXR1cm4gZXZlbnQuc2hpZnRLZXk7XHJcbn0iLCJpbXBvcnQgS2V5Ym9hcmQgZnJvbSAnLi9LZXlib2FyZCc7XG5pbXBvcnQgS2V5Ym9hcmRCaW5kaW5ncyBmcm9tICcuL0tleWJvYXJkQmluZGluZ3MnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdrZXlib2FyZCcsICdrZXlib2FyZEJpbmRpbmdzJyBdLFxuICBrZXlib2FyZDogWyAndHlwZScsIEtleWJvYXJkIF0sXG4gIGtleWJvYXJkQmluZGluZ3M6IFsgJ3R5cGUnLCBLZXlib2FyZEJpbmRpbmdzIF1cbn07XG4iLCJpbXBvcnQge1xuICBmb3JFYWNoLFxuICBmaWx0ZXJcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG52YXIgTE9XX1BSSU9SSVRZID0gMjUwLFxuICAgIEhJR0hfUFJJT1JJVFkgPSAxNDAwO1xuXG5pbXBvcnQge1xuICBhZGQgYXMgY29sbGVjdGlvbkFkZCxcbiAgaW5kZXhPZiBhcyBjb2xsZWN0aW9uSWR4XG59IGZyb20gJy4uLy4uL3V0aWwvQ29sbGVjdGlvbnMnO1xuXG5pbXBvcnQgeyBzYXZlQ2xlYXIgfSBmcm9tICcuLi8uLi91dGlsL1JlbW92YWwnO1xuXG5pbXBvcnQgQ29tbWFuZEludGVyY2VwdG9yIGZyb20gJy4uLy4uL2NvbW1hbmQvQ29tbWFuZEludGVyY2VwdG9yJztcblxuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IG1ha2VzIHN1cmUgbGFiZWxzIGFyZSBwcm9wZXJseSBtb3ZlZCB3aXRoXG4gKiB0aGVpciBsYWJlbCB0YXJnZXRzLlxuICpcbiAqIEBwYXJhbSB7ZGlkaS5JbmplY3Rvcn0gaW5qZWN0b3JcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge01vZGVsaW5nfSBtb2RlbGluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYWJlbFN1cHBvcnQoaW5qZWN0b3IsIGV2ZW50QnVzLCBtb2RlbGluZykge1xuXG4gIENvbW1hbmRJbnRlcmNlcHRvci5jYWxsKHRoaXMsIGV2ZW50QnVzKTtcblxuICB2YXIgbW92ZVByZXZpZXcgPSBpbmplY3Rvci5nZXQoJ21vdmVQcmV2aWV3JywgZmFsc2UpO1xuXG4gIC8vIHJlbW92ZSBsYWJlbHMgZnJvbSB0aGUgY29sbGVjdGlvbiB0aGF0IGFyZSBiZWluZ1xuICAvLyBtb3ZlZCB3aXRoIG90aGVyIGVsZW1lbnRzIGFueXdheVxuICBldmVudEJ1cy5vbignc2hhcGUubW92ZS5zdGFydCcsIEhJR0hfUFJJT1JJVFksIGZ1bmN0aW9uKGUpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBzaGFwZXMgPSBjb250ZXh0LnNoYXBlcyxcbiAgICAgICAgdmFsaWRhdGVkU2hhcGVzID0gY29udGV4dC52YWxpZGF0ZWRTaGFwZXM7XG5cbiAgICBjb250ZXh0LnNoYXBlcyA9IHJlbW92ZUxhYmVscyhzaGFwZXMpO1xuICAgIGNvbnRleHQudmFsaWRhdGVkU2hhcGVzID0gcmVtb3ZlTGFiZWxzKHZhbGlkYXRlZFNoYXBlcyk7XG4gIH0pO1xuXG4gIC8vIGFkZCBsYWJlbHMgdG8gdmlzdWFsJ3MgZ3JvdXBcbiAgbW92ZVByZXZpZXcgJiYgZXZlbnRCdXMub24oJ3NoYXBlLm1vdmUuc3RhcnQnLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGUpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBzaGFwZXMgPSBjb250ZXh0LnNoYXBlcztcblxuICAgIHZhciBsYWJlbHMgPSBbXTtcblxuICAgIGZvckVhY2goc2hhcGVzLCBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICAgIGZvckVhY2goZWxlbWVudC5sYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG5cbiAgICAgICAgaWYgKCFsYWJlbC5oaWRkZW4gJiYgY29udGV4dC5zaGFwZXMuaW5kZXhPZihsYWJlbCkgPT09IC0xKSB7XG4gICAgICAgICAgbGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQubGFiZWxUYXJnZXQpIHtcbiAgICAgICAgICBsYWJlbHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmb3JFYWNoKGxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgIG1vdmVQcmV2aWV3Lm1ha2VEcmFnZ2FibGUoY29udGV4dCwgbGFiZWwsIHRydWUpO1xuICAgIH0pO1xuXG4gIH0pO1xuXG4gIC8vIGFkZCBhbGwgbGFiZWxzIHRvIG1vdmUgY2xvc3VyZVxuICB0aGlzLnByZUV4ZWN1dGVkKCdlbGVtZW50cy5tb3ZlJywgSElHSF9QUklPUklUWSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBjbG9zdXJlID0gY29udGV4dC5jbG9zdXJlLFxuICAgICAgICBlbmNsb3NlZEVsZW1lbnRzID0gY2xvc3VyZS5lbmNsb3NlZEVsZW1lbnRzO1xuXG4gICAgdmFyIGVuY2xvc2VkTGFiZWxzID0gW107XG5cbiAgICAvLyBmaW5kIGxhYmVscyB0aGF0IGFyZSBub3QgcGFydCBvZlxuICAgIC8vIG1vdmUgY2xvc3VyZSB5ZXQgYW5kIGFkZCB0aGVtXG4gICAgZm9yRWFjaChlbmNsb3NlZEVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBmb3JFYWNoKGVsZW1lbnQubGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuXG4gICAgICAgIGlmICghZW5jbG9zZWRFbGVtZW50c1tsYWJlbC5pZF0pIHtcbiAgICAgICAgICBlbmNsb3NlZExhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjbG9zdXJlLmFkZEFsbChlbmNsb3NlZExhYmVscyk7XG4gIH0pO1xuXG5cbiAgdGhpcy5wcmVFeGVjdXRlKFtcbiAgICAnY29ubmVjdGlvbi5kZWxldGUnLFxuICAgICdzaGFwZS5kZWxldGUnXG4gIF0sIGZ1bmN0aW9uKGUpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBlbGVtZW50ID0gY29udGV4dC5jb25uZWN0aW9uIHx8IGNvbnRleHQuc2hhcGU7XG5cbiAgICBzYXZlQ2xlYXIoZWxlbWVudC5sYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICBtb2RlbGluZy5yZW1vdmVTaGFwZShsYWJlbCwgeyBuZXN0ZWQ6IHRydWUgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG5cbiAgdGhpcy5leGVjdXRlKCdzaGFwZS5kZWxldGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGUuY29udGV4dCxcbiAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBsYWJlbFRhcmdldCA9IHNoYXBlLmxhYmVsVGFyZ2V0O1xuXG4gICAgLy8gdW5zZXQgbGFiZWxUYXJnZXRcbiAgICBpZiAobGFiZWxUYXJnZXQpIHtcbiAgICAgIGNvbnRleHQubGFiZWxUYXJnZXRJbmRleCA9IGNvbGxlY3Rpb25JZHgobGFiZWxUYXJnZXQubGFiZWxzLCBzaGFwZSk7XG4gICAgICBjb250ZXh0LmxhYmVsVGFyZ2V0ID0gbGFiZWxUYXJnZXQ7XG5cbiAgICAgIHNoYXBlLmxhYmVsVGFyZ2V0ID0gbnVsbDtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMucmV2ZXJ0KCdzaGFwZS5kZWxldGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGUuY29udGV4dCxcbiAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBsYWJlbFRhcmdldCA9IGNvbnRleHQubGFiZWxUYXJnZXQsXG4gICAgICAgIGxhYmVsVGFyZ2V0SW5kZXggPSBjb250ZXh0LmxhYmVsVGFyZ2V0SW5kZXg7XG5cbiAgICAvLyByZXN0b3JlIGxhYmVsVGFyZ2V0XG4gICAgaWYgKGxhYmVsVGFyZ2V0KSB7XG4gICAgICBjb2xsZWN0aW9uQWRkKGxhYmVsVGFyZ2V0LmxhYmVscywgc2hhcGUsIGxhYmVsVGFyZ2V0SW5kZXgpO1xuXG4gICAgICBzaGFwZS5sYWJlbFRhcmdldCA9IGxhYmVsVGFyZ2V0O1xuICAgIH1cbiAgfSk7XG5cbn1cblxuaW5oZXJpdHMoTGFiZWxTdXBwb3J0LCBDb21tYW5kSW50ZXJjZXB0b3IpO1xuXG5MYWJlbFN1cHBvcnQuJGluamVjdCA9IFtcbiAgJ2luamVjdG9yJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ21vZGVsaW5nJ1xuXTtcblxuXG4vKipcbiAqIFJldHVybiBhIGZpbHRlcmVkIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCBkbyBub3RcbiAqIGNvbnRhaW4gYXR0YWNoZWQgZWxlbWVudHMgd2l0aCBob3N0cyBiZWluZyBwYXJ0XG4gKiBvZiB0aGUgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSAge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZWxlbWVudHNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGZpbHRlcmVkXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxhYmVscyhlbGVtZW50cykge1xuXG4gIHJldHVybiBmaWx0ZXIoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgIC8vIGZpbHRlciBvdXQgbGFiZWxzIHRoYXQgYXJlIG1vdmUgdG9nZXRoZXJcbiAgICAvLyB3aXRoIHRoZWlyIGxhYmVsIHRhcmdldHNcbiAgICByZXR1cm4gZWxlbWVudHMuaW5kZXhPZihlbGVtZW50LmxhYmVsVGFyZ2V0KSA9PT0gLTE7XG4gIH0pO1xufVxuIiwiaW1wb3J0IExhYmVsU3VwcG9ydCBmcm9tICcuL0xhYmVsU3VwcG9ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ2xhYmVsU3VwcG9ydCddLFxuICBsYWJlbFN1cHBvcnQ6IFsgJ3R5cGUnLCBMYWJlbFN1cHBvcnQgXVxufTtcbiIsImltcG9ydCB7IHZhbHVlcyB9IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHsgZ2V0RW5jbG9zZWRFbGVtZW50cyB9IGZyb20gJy4uLy4uL3V0aWwvRWxlbWVudHMnO1xuXG5pbXBvcnQge1xuICBoYXNTZWNvbmRhcnlNb2RpZmllclxufSBmcm9tICcuLi8uLi91dGlsL01vdXNlJztcblxuaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjcmVhdGUgYXMgc3ZnQ3JlYXRlLFxuICByZW1vdmUgYXMgc3ZnUmVtb3ZlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxudmFyIExBU1NPX1RPT0xfQ1VSU09SID0gJ2Nyb3NzaGFpcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGFzc29Ub29sKFxuICAgIGV2ZW50QnVzLCBjYW52YXMsIGRyYWdnaW5nLFxuICAgIGVsZW1lbnRSZWdpc3RyeSwgc2VsZWN0aW9uLCB0b29sTWFuYWdlcixcbiAgICBtb3VzZSkge1xuXG4gIHRoaXMuX3NlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgdGhpcy5fZHJhZ2dpbmcgPSBkcmFnZ2luZztcbiAgdGhpcy5fbW91c2UgPSBtb3VzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gbGFzc28gdmlzdWFscyBpbXBsZW1lbnRhdGlvblxuXG4gIC8qKlxuICAqIEEgaGVscGVyIHRoYXQgcmVhbGl6ZXMgdGhlIHNlbGVjdGlvbiBib3ggdmlzdWFsXG4gICovXG4gIHZhciB2aXN1YWxzID0ge1xuXG4gICAgY3JlYXRlOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gY2FudmFzLmdldERlZmF1bHRMYXllcigpLFxuICAgICAgICAgIGZyYW1lO1xuXG4gICAgICBmcmFtZSA9IGNvbnRleHQuZnJhbWUgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcbiAgICAgIHN2Z0F0dHIoZnJhbWUsIHtcbiAgICAgICAgY2xhc3M6ICdkanMtbGFzc28tb3ZlcmxheScsXG4gICAgICAgIHdpZHRoOiAgMSxcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9KTtcblxuICAgICAgc3ZnQXBwZW5kKGNvbnRhaW5lciwgZnJhbWUpO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBmcmFtZSA9IGNvbnRleHQuZnJhbWUsXG4gICAgICAgICAgYmJveCA9IGNvbnRleHQuYmJveDtcblxuICAgICAgc3ZnQXR0cihmcmFtZSwge1xuICAgICAgICB4OiBiYm94LngsXG4gICAgICAgIHk6IGJib3gueSxcbiAgICAgICAgd2lkdGg6IGJib3gud2lkdGgsXG4gICAgICAgIGhlaWdodDogYmJveC5oZWlnaHRcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgICAgaWYgKGNvbnRleHQuZnJhbWUpIHtcbiAgICAgICAgc3ZnUmVtb3ZlKGNvbnRleHQuZnJhbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0b29sTWFuYWdlci5yZWdpc3RlclRvb2woJ2xhc3NvJywge1xuICAgIHRvb2w6ICdsYXNzby5zZWxlY3Rpb24nLFxuICAgIGRyYWdnaW5nOiAnbGFzc28nXG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdsYXNzby5zZWxlY3Rpb24uZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQub3JpZ2luYWxFdmVudC50YXJnZXQ7XG5cbiAgICAvLyBvbmx5IHJlYWN0aXZlIG9uIGRpYWdyYW0gY2xpY2tcbiAgICAvLyBvbiBzb21lIG9jY2FzaW9ucywgZXZlbnQuaG92ZXIgaXMgbm90IHNldCBhbmQgd2UgaGF2ZSB0byBjaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGFuIHN2Z1xuICAgIGlmICghZXZlbnQuaG92ZXIgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50QnVzLm9uY2UoJ2xhc3NvLnNlbGVjdGlvbi5lbmRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5hY3RpdmF0ZUxhc3NvKGV2ZW50Lm9yaWdpbmFsRXZlbnQsIHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBsYXNzbyBpbnRlcmFjdGlvbiBpbXBsZW1lbnRhdGlvblxuXG4gIGV2ZW50QnVzLm9uKCdsYXNzby5lbmQnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGJib3ggPSB0b0JCb3goZXZlbnQpO1xuXG4gICAgdmFyIGVsZW1lbnRzID0gZWxlbWVudFJlZ2lzdHJ5LmZpbHRlcihmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9KTtcblxuICAgIHNlbGYuc2VsZWN0KGVsZW1lbnRzLCBiYm94KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2xhc3NvLnN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dDtcblxuICAgIGNvbnRleHQuYmJveCA9IHRvQkJveChldmVudCk7XG4gICAgdmlzdWFscy5jcmVhdGUoY29udGV4dCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdsYXNzby5tb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dDtcblxuICAgIGNvbnRleHQuYmJveCA9IHRvQkJveChldmVudCk7XG4gICAgdmlzdWFscy51cGRhdGUoY29udGV4dCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdsYXNzby5jbGVhbnVwJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dDtcblxuICAgIHZpc3VhbHMucmVtb3ZlKGNvbnRleHQpO1xuICB9KTtcblxuXG4gIC8vIGV2ZW50IGludGVncmF0aW9uXG5cbiAgZXZlbnRCdXMub24oJ2VsZW1lbnQubW91c2Vkb3duJywgMTUwMCwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIGlmICghaGFzU2Vjb25kYXJ5TW9kaWZpZXIoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5hY3RpdmF0ZUxhc3NvKGV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuXG4gICAgLy8gd2UndmUgaGFuZGxlZCB0aGUgZXZlbnRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbkxhc3NvVG9vbC4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJyxcbiAgJ2RyYWdnaW5nJyxcbiAgJ2VsZW1lbnRSZWdpc3RyeScsXG4gICdzZWxlY3Rpb24nLFxuICAndG9vbE1hbmFnZXInLFxuICAnbW91c2UnXG5dO1xuXG5cbkxhc3NvVG9vbC5wcm90b3R5cGUuYWN0aXZhdGVMYXNzbyA9IGZ1bmN0aW9uKGV2ZW50LCBhdXRvQWN0aXZhdGUpIHtcblxuICB0aGlzLl9kcmFnZ2luZy5pbml0KGV2ZW50LCAnbGFzc28nLCB7XG4gICAgYXV0b0FjdGl2YXRlOiBhdXRvQWN0aXZhdGUsXG4gICAgY3Vyc29yOiBMQVNTT19UT09MX0NVUlNPUixcbiAgICBkYXRhOiB7XG4gICAgICBjb250ZXh0OiB7fVxuICAgIH1cbiAgfSk7XG59O1xuXG5MYXNzb1Rvb2wucHJvdG90eXBlLmFjdGl2YXRlU2VsZWN0aW9uID0gZnVuY3Rpb24oZXZlbnQsIGF1dG9BY3RpdmF0ZSkge1xuXG4gIHRoaXMuX2RyYWdnaW5nLmluaXQoZXZlbnQsICdsYXNzby5zZWxlY3Rpb24nLCB7XG4gICAgdHJhcENsaWNrOiBmYWxzZSxcbiAgICBhdXRvQWN0aXZhdGU6IGF1dG9BY3RpdmF0ZSxcbiAgICBjdXJzb3I6IExBU1NPX1RPT0xfQ1VSU09SLFxuICAgIGRhdGE6IHtcbiAgICAgIGNvbnRleHQ6IHt9XG4gICAgfVxuICB9KTtcbn07XG5cbkxhc3NvVG9vbC5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oZWxlbWVudHMsIGJib3gpIHtcbiAgdmFyIHNlbGVjdGVkRWxlbWVudHMgPSBnZXRFbmNsb3NlZEVsZW1lbnRzKGVsZW1lbnRzLCBiYm94KTtcblxuICB0aGlzLl9zZWxlY3Rpb24uc2VsZWN0KHZhbHVlcyhzZWxlY3RlZEVsZW1lbnRzKSk7XG59O1xuXG5MYXNzb1Rvb2wucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RyYWdnaW5nLmNhbmNlbCgpO1xuICB9XG5cbiAgdmFyIG1vdXNlRXZlbnQgPSB0aGlzLl9tb3VzZS5nZXRMYXN0TW92ZUV2ZW50KCk7XG5cbiAgdGhpcy5hY3RpdmF0ZVNlbGVjdGlvbihtb3VzZUV2ZW50LCAhIW1vdXNlRXZlbnQpO1xufTtcblxuTGFzc29Ub29sLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMuX2RyYWdnaW5nLmNvbnRleHQoKTtcblxuICByZXR1cm4gY29udGV4dCAmJiAvXmxhc3NvLy50ZXN0KGNvbnRleHQucHJlZml4KTtcbn07XG5cblxuXG5mdW5jdGlvbiB0b0JCb3goZXZlbnQpIHtcblxuICB2YXIgc3RhcnQgPSB7XG5cbiAgICB4OiBldmVudC54IC0gZXZlbnQuZHgsXG4gICAgeTogZXZlbnQueSAtIGV2ZW50LmR5XG4gIH07XG5cbiAgdmFyIGVuZCA9IHtcbiAgICB4OiBldmVudC54LFxuICAgIHk6IGV2ZW50LnlcbiAgfTtcblxuICB2YXIgYmJveDtcblxuICBpZiAoKHN0YXJ0LnggPD0gZW5kLnggJiYgc3RhcnQueSA8IGVuZC55KSB8fFxuICAgICAgKHN0YXJ0LnggPCBlbmQueCAmJiBzdGFydC55IDw9IGVuZC55KSkge1xuXG4gICAgYmJveCA9IHtcbiAgICAgIHg6IHN0YXJ0LngsXG4gICAgICB5OiBzdGFydC55LFxuICAgICAgd2lkdGg6ICBlbmQueCAtIHN0YXJ0LngsXG4gICAgICBoZWlnaHQ6IGVuZC55IC0gc3RhcnQueVxuICAgIH07XG4gIH0gZWxzZSBpZiAoKHN0YXJ0LnggPj0gZW5kLnggJiYgc3RhcnQueSA8IGVuZC55KSB8fFxuICAgICAgICAgICAgIChzdGFydC54ID4gZW5kLnggJiYgc3RhcnQueSA8PSBlbmQueSkpIHtcblxuICAgIGJib3ggPSB7XG4gICAgICB4OiBlbmQueCxcbiAgICAgIHk6IHN0YXJ0LnksXG4gICAgICB3aWR0aDogIHN0YXJ0LnggLSBlbmQueCxcbiAgICAgIGhlaWdodDogZW5kLnkgLSBzdGFydC55XG4gICAgfTtcbiAgfSBlbHNlIGlmICgoc3RhcnQueCA8PSBlbmQueCAmJiBzdGFydC55ID4gZW5kLnkpIHx8XG4gICAgICAgICAgICAgKHN0YXJ0LnggPCBlbmQueCAmJiBzdGFydC55ID49IGVuZC55KSkge1xuXG4gICAgYmJveCA9IHtcbiAgICAgIHg6IHN0YXJ0LngsXG4gICAgICB5OiBlbmQueSxcbiAgICAgIHdpZHRoOiAgZW5kLnggLSBzdGFydC54LFxuICAgICAgaGVpZ2h0OiBzdGFydC55IC0gZW5kLnlcbiAgICB9O1xuICB9IGVsc2UgaWYgKChzdGFydC54ID49IGVuZC54ICYmIHN0YXJ0LnkgPiBlbmQueSkgfHxcbiAgICAgICAgICAgICAoc3RhcnQueCA+IGVuZC54ICYmIHN0YXJ0LnkgPj0gZW5kLnkpKSB7XG5cbiAgICBiYm94ID0ge1xuICAgICAgeDogZW5kLngsXG4gICAgICB5OiBlbmQueSxcbiAgICAgIHdpZHRoOiAgc3RhcnQueCAtIGVuZC54LFxuICAgICAgaGVpZ2h0OiBzdGFydC55IC0gZW5kLnlcbiAgICB9O1xuICB9IGVsc2Uge1xuXG4gICAgYmJveCA9IHtcbiAgICAgIHg6IGVuZC54LFxuICAgICAgeTogZW5kLnksXG4gICAgICB3aWR0aDogIDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICB9XG4gIHJldHVybiBiYm94O1xufVxuIiwiaW1wb3J0IFRvb2xNYW5hZ2VyTW9kdWxlIGZyb20gJy4uL3Rvb2wtbWFuYWdlcic7XG5pbXBvcnQgTW91c2VNb2R1bGUgZnJvbSAnLi4vbW91c2UnO1xuXG5pbXBvcnQgTGFzc29Ub29sIGZyb20gJy4vTGFzc29Ub29sJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIFRvb2xNYW5hZ2VyTW9kdWxlLFxuICAgIE1vdXNlTW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbICdsYXNzb1Rvb2wnIF0sXG4gIGxhc3NvVG9vbDogWyAndHlwZScsIExhc3NvVG9vbCBdXG59O1xuIiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmb3JFYWNoLFxuICBpc0FycmF5XG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgQmFzZVxufSBmcm9tICcuLi8uLi9tb2RlbCc7XG5cbmltcG9ydCBBbGlnbkVsZW1lbnRzSGFuZGxlciBmcm9tICcuL2NtZC9BbGlnbkVsZW1lbnRzSGFuZGxlcic7XG5pbXBvcnQgQXBwZW5kU2hhcGVIYW5kbGVyIGZyb20gJy4vY21kL0FwcGVuZFNoYXBlSGFuZGxlcic7XG5pbXBvcnQgQ3JlYXRlQ29ubmVjdGlvbkhhbmRsZXIgZnJvbSAnLi9jbWQvQ3JlYXRlQ29ubmVjdGlvbkhhbmRsZXInO1xuaW1wb3J0IENyZWF0ZUVsZW1lbnRzSGFuZGxlciBmcm9tICcuL2NtZC9DcmVhdGVFbGVtZW50c0hhbmRsZXInO1xuaW1wb3J0IENyZWF0ZUxhYmVsSGFuZGxlciBmcm9tICcuL2NtZC9DcmVhdGVMYWJlbEhhbmRsZXInO1xuaW1wb3J0IENyZWF0ZVNoYXBlSGFuZGxlciBmcm9tICcuL2NtZC9DcmVhdGVTaGFwZUhhbmRsZXInO1xuaW1wb3J0IERlbGV0ZUNvbm5lY3Rpb25IYW5kbGVyIGZyb20gJy4vY21kL0RlbGV0ZUNvbm5lY3Rpb25IYW5kbGVyJztcbmltcG9ydCBEZWxldGVFbGVtZW50c0hhbmRsZXIgZnJvbSAnLi9jbWQvRGVsZXRlRWxlbWVudHNIYW5kbGVyJztcbmltcG9ydCBEZWxldGVTaGFwZUhhbmRsZXIgZnJvbSAnLi9jbWQvRGVsZXRlU2hhcGVIYW5kbGVyJztcbmltcG9ydCBEaXN0cmlidXRlRWxlbWVudHNIYW5kbGVyIGZyb20gJy4vY21kL0Rpc3RyaWJ1dGVFbGVtZW50c0hhbmRsZXInO1xuaW1wb3J0IExheW91dENvbm5lY3Rpb25IYW5kbGVyIGZyb20gJy4vY21kL0xheW91dENvbm5lY3Rpb25IYW5kbGVyJztcbmltcG9ydCBNb3ZlQ29ubmVjdGlvbkhhbmRsZXIgZnJvbSAnLi9jbWQvTW92ZUNvbm5lY3Rpb25IYW5kbGVyJztcbmltcG9ydCBNb3ZlRWxlbWVudHNIYW5kbGVyIGZyb20gJy4vY21kL01vdmVFbGVtZW50c0hhbmRsZXInO1xuaW1wb3J0IE1vdmVTaGFwZUhhbmRsZXIgZnJvbSAnLi9jbWQvTW92ZVNoYXBlSGFuZGxlcic7XG5pbXBvcnQgUmVjb25uZWN0Q29ubmVjdGlvbkhhbmRsZXIgZnJvbSAnLi9jbWQvUmVjb25uZWN0Q29ubmVjdGlvbkhhbmRsZXInO1xuaW1wb3J0IFJlcGxhY2VTaGFwZUhhbmRsZXIgZnJvbSAnLi9jbWQvUmVwbGFjZVNoYXBlSGFuZGxlcic7XG5pbXBvcnQgUmVzaXplU2hhcGVIYW5kbGVyIGZyb20gJy4vY21kL1Jlc2l6ZVNoYXBlSGFuZGxlcic7XG5pbXBvcnQgU3BhY2VUb29sSGFuZGxlciBmcm9tICcuL2NtZC9TcGFjZVRvb2xIYW5kbGVyJztcbmltcG9ydCBUb2dnbGVTaGFwZUNvbGxhcHNlSGFuZGxlciBmcm9tICcuL2NtZC9Ub2dnbGVTaGFwZUNvbGxhcHNlSGFuZGxlcic7XG5pbXBvcnQgVXBkYXRlQXR0YWNobWVudEhhbmRsZXIgZnJvbSAnLi9jbWQvVXBkYXRlQXR0YWNobWVudEhhbmRsZXInO1xuaW1wb3J0IFVwZGF0ZVdheXBvaW50c0hhbmRsZXIgZnJvbSAnLi9jbWQvVXBkYXRlV2F5cG9pbnRzSGFuZGxlcic7XG5cblxuLyoqXG4gKiBUaGUgYmFzaWMgbW9kZWxpbmcgZW50cnkgcG9pbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7RWxlbWVudEZhY3Rvcnl9IGVsZW1lbnRGYWN0b3J5XG4gKiBAcGFyYW0ge0NvbW1hbmRTdGFja30gY29tbWFuZFN0YWNrXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1vZGVsaW5nKGV2ZW50QnVzLCBlbGVtZW50RmFjdG9yeSwgY29tbWFuZFN0YWNrKSB7XG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX2VsZW1lbnRGYWN0b3J5ID0gZWxlbWVudEZhY3Rvcnk7XG4gIHRoaXMuX2NvbW1hbmRTdGFjayA9IGNvbW1hbmRTdGFjaztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRCdXMub24oJ2RpYWdyYW0uaW5pdCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gcmVnaXN0ZXIgbW9kZWxpbmcgaGFuZGxlcnNcbiAgICBzZWxmLnJlZ2lzdGVySGFuZGxlcnMoY29tbWFuZFN0YWNrKTtcbiAgfSk7XG59XG5cbk1vZGVsaW5nLiRpbmplY3QgPSBbICdldmVudEJ1cycsICdlbGVtZW50RmFjdG9yeScsICdjb21tYW5kU3RhY2snIF07XG5cblxuTW9kZWxpbmcucHJvdG90eXBlLmdldEhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgJ3NoYXBlLmFwcGVuZCc6IEFwcGVuZFNoYXBlSGFuZGxlcixcbiAgICAnc2hhcGUuY3JlYXRlJzogQ3JlYXRlU2hhcGVIYW5kbGVyLFxuICAgICdzaGFwZS5kZWxldGUnOiBEZWxldGVTaGFwZUhhbmRsZXIsXG4gICAgJ3NoYXBlLm1vdmUnOiBNb3ZlU2hhcGVIYW5kbGVyLFxuICAgICdzaGFwZS5yZXNpemUnOiBSZXNpemVTaGFwZUhhbmRsZXIsXG4gICAgJ3NoYXBlLnJlcGxhY2UnOiBSZXBsYWNlU2hhcGVIYW5kbGVyLFxuICAgICdzaGFwZS50b2dnbGVDb2xsYXBzZSc6IFRvZ2dsZVNoYXBlQ29sbGFwc2VIYW5kbGVyLFxuXG4gICAgJ3NwYWNlVG9vbCc6IFNwYWNlVG9vbEhhbmRsZXIsXG5cbiAgICAnbGFiZWwuY3JlYXRlJzogQ3JlYXRlTGFiZWxIYW5kbGVyLFxuXG4gICAgJ2Nvbm5lY3Rpb24uY3JlYXRlJzogQ3JlYXRlQ29ubmVjdGlvbkhhbmRsZXIsXG4gICAgJ2Nvbm5lY3Rpb24uZGVsZXRlJzogRGVsZXRlQ29ubmVjdGlvbkhhbmRsZXIsXG4gICAgJ2Nvbm5lY3Rpb24ubW92ZSc6IE1vdmVDb25uZWN0aW9uSGFuZGxlcixcbiAgICAnY29ubmVjdGlvbi5sYXlvdXQnOiBMYXlvdXRDb25uZWN0aW9uSGFuZGxlcixcblxuICAgICdjb25uZWN0aW9uLnVwZGF0ZVdheXBvaW50cyc6IFVwZGF0ZVdheXBvaW50c0hhbmRsZXIsXG5cbiAgICAnY29ubmVjdGlvbi5yZWNvbm5lY3QnOiBSZWNvbm5lY3RDb25uZWN0aW9uSGFuZGxlcixcblxuICAgICdlbGVtZW50cy5jcmVhdGUnOiBDcmVhdGVFbGVtZW50c0hhbmRsZXIsXG4gICAgJ2VsZW1lbnRzLm1vdmUnOiBNb3ZlRWxlbWVudHNIYW5kbGVyLFxuICAgICdlbGVtZW50cy5kZWxldGUnOiBEZWxldGVFbGVtZW50c0hhbmRsZXIsXG5cbiAgICAnZWxlbWVudHMuZGlzdHJpYnV0ZSc6IERpc3RyaWJ1dGVFbGVtZW50c0hhbmRsZXIsXG4gICAgJ2VsZW1lbnRzLmFsaWduJzogQWxpZ25FbGVtZW50c0hhbmRsZXIsXG5cbiAgICAnZWxlbWVudC51cGRhdGVBdHRhY2htZW50JzogVXBkYXRlQXR0YWNobWVudEhhbmRsZXJcbiAgfTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgaGFuZGxlcnMgd2l0aCB0aGUgY29tbWFuZCBzdGFja1xuICpcbiAqIEBwYXJhbSB7Q29tbWFuZFN0YWNrfSBjb21tYW5kU3RhY2tcbiAqL1xuTW9kZWxpbmcucHJvdG90eXBlLnJlZ2lzdGVySGFuZGxlcnMgPSBmdW5jdGlvbihjb21tYW5kU3RhY2spIHtcbiAgZm9yRWFjaCh0aGlzLmdldEhhbmRsZXJzKCksIGZ1bmN0aW9uKGhhbmRsZXIsIGlkKSB7XG4gICAgY29tbWFuZFN0YWNrLnJlZ2lzdGVySGFuZGxlcihpZCwgaGFuZGxlcik7XG4gIH0pO1xufTtcblxuXG4vLyBtb2RlbGluZyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuTW9kZWxpbmcucHJvdG90eXBlLm1vdmVTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLCBkZWx0YSwgbmV3UGFyZW50LCBuZXdQYXJlbnRJbmRleCwgaGludHMpIHtcblxuICBpZiAodHlwZW9mIG5ld1BhcmVudEluZGV4ID09PSAnb2JqZWN0Jykge1xuICAgIGhpbnRzID0gbmV3UGFyZW50SW5kZXg7XG4gICAgbmV3UGFyZW50SW5kZXggPSBudWxsO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgc2hhcGU6IHNoYXBlLFxuICAgIGRlbHRhOiAgZGVsdGEsXG4gICAgbmV3UGFyZW50OiBuZXdQYXJlbnQsXG4gICAgbmV3UGFyZW50SW5kZXg6IG5ld1BhcmVudEluZGV4LFxuICAgIGhpbnRzOiBoaW50cyB8fCB7fVxuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdzaGFwZS5tb3ZlJywgY29udGV4dCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSBhdHRhY2htZW50IG9mIHRoZSBnaXZlbiBzaGFwZS5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlLkJhc2V9IHNoYXBlXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBbbmV3SG9zdF1cbiAqL1xuTW9kZWxpbmcucHJvdG90eXBlLnVwZGF0ZUF0dGFjaG1lbnQgPSBmdW5jdGlvbihzaGFwZSwgbmV3SG9zdCkge1xuICB2YXIgY29udGV4dCA9IHtcbiAgICBzaGFwZTogc2hhcGUsXG4gICAgbmV3SG9zdDogbmV3SG9zdFxuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdlbGVtZW50LnVwZGF0ZUF0dGFjaG1lbnQnLCBjb250ZXh0KTtcbn07XG5cblxuLyoqXG4gKiBNb3ZlIGEgbnVtYmVyIG9mIHNoYXBlcyB0byBhIG5ldyB0YXJnZXQsIGVpdGhlciBzZXR0aW5nIGl0IGFzXG4gKiB0aGUgbmV3IHBhcmVudCBvciBhdHRhY2hpbmcgaXQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxkanMubW9kZS5CYXNlPn0gc2hhcGVzXG4gKiBAcGFyYW0ge1BvaW50fSBkZWx0YVxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gW3RhcmdldF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGludHNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoaW50cy5hdHRhY2g9ZmFsc2VdXG4gKi9cbk1vZGVsaW5nLnByb3RvdHlwZS5tb3ZlRWxlbWVudHMgPSBmdW5jdGlvbihzaGFwZXMsIGRlbHRhLCB0YXJnZXQsIGhpbnRzKSB7XG5cbiAgaGludHMgPSBoaW50cyB8fCB7fTtcblxuICB2YXIgYXR0YWNoID0gaGludHMuYXR0YWNoO1xuXG4gIHZhciBuZXdQYXJlbnQgPSB0YXJnZXQsXG4gICAgICBuZXdIb3N0O1xuXG4gIGlmIChhdHRhY2ggPT09IHRydWUpIHtcbiAgICBuZXdIb3N0ID0gdGFyZ2V0O1xuICAgIG5ld1BhcmVudCA9IHRhcmdldC5wYXJlbnQ7XG4gIH0gZWxzZVxuXG4gIGlmIChhdHRhY2ggPT09IGZhbHNlKSB7XG4gICAgbmV3SG9zdCA9IG51bGw7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICBzaGFwZXM6IHNoYXBlcyxcbiAgICBkZWx0YTogZGVsdGEsXG4gICAgbmV3UGFyZW50OiBuZXdQYXJlbnQsXG4gICAgbmV3SG9zdDogbmV3SG9zdCxcbiAgICBoaW50czogaGludHNcbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnZWxlbWVudHMubW92ZScsIGNvbnRleHQpO1xufTtcblxuXG5Nb2RlbGluZy5wcm90b3R5cGUubW92ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uLCBkZWx0YSwgbmV3UGFyZW50LCBuZXdQYXJlbnRJbmRleCwgaGludHMpIHtcblxuICBpZiAodHlwZW9mIG5ld1BhcmVudEluZGV4ID09PSAnb2JqZWN0Jykge1xuICAgIGhpbnRzID0gbmV3UGFyZW50SW5kZXg7XG4gICAgbmV3UGFyZW50SW5kZXggPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICBjb25uZWN0aW9uOiBjb25uZWN0aW9uLFxuICAgIGRlbHRhOiBkZWx0YSxcbiAgICBuZXdQYXJlbnQ6IG5ld1BhcmVudCxcbiAgICBuZXdQYXJlbnRJbmRleDogbmV3UGFyZW50SW5kZXgsXG4gICAgaGludHM6IGhpbnRzIHx8IHt9XG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2Nvbm5lY3Rpb24ubW92ZScsIGNvbnRleHQpO1xufTtcblxuXG5Nb2RlbGluZy5wcm90b3R5cGUubGF5b3V0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIGhpbnRzKSB7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgaGludHM6IGhpbnRzIHx8IHt9XG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2Nvbm5lY3Rpb24ubGF5b3V0JywgY29udGV4dCk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gc291cmNlXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSB0YXJnZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyZW50SW5kZXhdXG4gKiBAcGFyYW0ge09iamVjdHxkanMubW9kZWwuQ29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gaGludHNcbiAqXG4gKiBAcmV0dXJuIHtkanMubW9kZWwuQ29ubmVjdGlvbn0gdGhlIGNyZWF0ZWQgY29ubmVjdGlvbi5cbiAqL1xuTW9kZWxpbmcucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCwgcGFyZW50SW5kZXgsIGNvbm5lY3Rpb24sIHBhcmVudCwgaGludHMpIHtcblxuICBpZiAodHlwZW9mIHBhcmVudEluZGV4ID09PSAnb2JqZWN0Jykge1xuICAgIGhpbnRzID0gcGFyZW50O1xuICAgIHBhcmVudCA9IGNvbm5lY3Rpb247XG4gICAgY29ubmVjdGlvbiA9IHBhcmVudEluZGV4O1xuICAgIHBhcmVudEluZGV4ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29ubmVjdGlvbiA9IHRoaXMuX2NyZWF0ZSgnY29ubmVjdGlvbicsIGNvbm5lY3Rpb24pO1xuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHBhcmVudEluZGV4OiBwYXJlbnRJbmRleCxcbiAgICBjb25uZWN0aW9uOiBjb25uZWN0aW9uLFxuICAgIGhpbnRzOiBoaW50c1xuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdjb25uZWN0aW9uLmNyZWF0ZScsIGNvbnRleHQpO1xuXG4gIHJldHVybiBjb250ZXh0LmNvbm5lY3Rpb247XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgc2hhcGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5TaGFwZXxPYmplY3R9IHNoYXBlXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvblxuICogQHBhcmFtIHtkanMubW9kZWwuU2hhcGV8ZGpzLm1vZGVsLlJvb3R9IHRhcmdldFxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJlbnRJbmRleF0gcG9zaXRpb24gaW4gcGFyZW50cyBjaGlsZHJlbiBsaXN0XG4gKiBAcGFyYW0ge09iamVjdH0gW2hpbnRzXVxuICogQHBhcmFtIHtib29sZWFufSBbaGludHMuYXR0YWNoXSB3aGV0aGVyIHRvIGF0dGFjaCB0byB0YXJnZXQgb3IgYmVjb21lIGEgY2hpbGRcbiAqXG4gKiBAcmV0dXJuIHtkanMubW9kZWwuU2hhcGV9IHRoZSBjcmVhdGVkIHNoYXBlXG4gKi9cbk1vZGVsaW5nLnByb3RvdHlwZS5jcmVhdGVTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLCBwb3NpdGlvbiwgdGFyZ2V0LCBwYXJlbnRJbmRleCwgaGludHMpIHtcblxuICBpZiAodHlwZW9mIHBhcmVudEluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgIGhpbnRzID0gcGFyZW50SW5kZXg7XG4gICAgcGFyZW50SW5kZXggPSB1bmRlZmluZWQ7XG4gIH1cblxuICBoaW50cyA9IGhpbnRzIHx8IHt9O1xuXG4gIHZhciBhdHRhY2ggPSBoaW50cy5hdHRhY2gsXG4gICAgICBwYXJlbnQsXG4gICAgICBob3N0O1xuXG4gIHNoYXBlID0gdGhpcy5fY3JlYXRlKCdzaGFwZScsIHNoYXBlKTtcblxuICBpZiAoYXR0YWNoKSB7XG4gICAgcGFyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgICBob3N0ID0gdGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIHBhcmVudCA9IHRhcmdldDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICBzaGFwZTogc2hhcGUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcGFyZW50SW5kZXg6IHBhcmVudEluZGV4LFxuICAgIGhvc3Q6IGhvc3QsXG4gICAgaGludHM6IGhpbnRzXG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ3NoYXBlLmNyZWF0ZScsIGNvbnRleHQpO1xuXG4gIHJldHVybiBjb250ZXh0LnNoYXBlO1xufTtcblxuXG5Nb2RlbGluZy5wcm90b3R5cGUuY3JlYXRlRWxlbWVudHMgPSBmdW5jdGlvbihlbGVtZW50cywgcG9zaXRpb24sIHBhcmVudCwgcGFyZW50SW5kZXgsIGhpbnRzKSB7XG4gIGlmICghaXNBcnJheShlbGVtZW50cykpIHtcbiAgICBlbGVtZW50cyA9IFsgZWxlbWVudHMgXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyZW50SW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgaGludHMgPSBwYXJlbnRJbmRleDtcbiAgICBwYXJlbnRJbmRleCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGhpbnRzID0gaGludHMgfHwge307XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwYXJlbnRJbmRleDogcGFyZW50SW5kZXgsXG4gICAgaGludHM6IGhpbnRzXG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2VsZW1lbnRzLmNyZWF0ZScsIGNvbnRleHQpO1xuXG4gIHJldHVybiBjb250ZXh0LmVsZW1lbnRzO1xufTtcblxuXG5Nb2RlbGluZy5wcm90b3R5cGUuY3JlYXRlTGFiZWwgPSBmdW5jdGlvbihsYWJlbFRhcmdldCwgcG9zaXRpb24sIGxhYmVsLCBwYXJlbnQpIHtcblxuICBsYWJlbCA9IHRoaXMuX2NyZWF0ZSgnbGFiZWwnLCBsYWJlbCk7XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgbGFiZWxUYXJnZXQ6IGxhYmVsVGFyZ2V0LFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICBwYXJlbnQ6IHBhcmVudCB8fCBsYWJlbFRhcmdldC5wYXJlbnQsXG4gICAgc2hhcGU6IGxhYmVsXG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2xhYmVsLmNyZWF0ZScsIGNvbnRleHQpO1xuXG4gIHJldHVybiBjb250ZXh0LnNoYXBlO1xufTtcblxuXG4vKipcbiAqIEFwcGVuZCBzaGFwZSB0byBnaXZlbiBzb3VyY2UsIGRyYXdpbmcgYSBjb25uZWN0aW9uXG4gKiBiZXR3ZWVuIHNvdXJjZSBhbmQgdGhlIG5ld2x5IGNyZWF0ZWQgc2hhcGUuXG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuU2hhcGV9IHNvdXJjZVxuICogQHBhcmFtIHtkanMubW9kZWwuU2hhcGV8T2JqZWN0fSBzaGFwZVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb25cbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLlNoYXBlfSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGludHNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoaW50cy5hdHRhY2hdXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5Db25uZWN0aW9ufE9iamVjdH0gW2hpbnRzLmNvbm5lY3Rpb25dXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBbaGludHMuY29ubmVjdGlvblBhcmVudF1cbiAqXG4gKiBAcmV0dXJuIHtkanMubW9kZWwuU2hhcGV9IHRoZSBuZXdseSBjcmVhdGVkIHNoYXBlXG4gKi9cbk1vZGVsaW5nLnByb3RvdHlwZS5hcHBlbmRTaGFwZSA9IGZ1bmN0aW9uKHNvdXJjZSwgc2hhcGUsIHBvc2l0aW9uLCB0YXJnZXQsIGhpbnRzKSB7XG5cbiAgaGludHMgPSBoaW50cyB8fCB7fTtcblxuICBzaGFwZSA9IHRoaXMuX2NyZWF0ZSgnc2hhcGUnLCBzaGFwZSk7XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHNoYXBlOiBzaGFwZSxcbiAgICBjb25uZWN0aW9uOiBoaW50cy5jb25uZWN0aW9uLFxuICAgIGNvbm5lY3Rpb25QYXJlbnQ6IGhpbnRzLmNvbm5lY3Rpb25QYXJlbnQsXG4gICAgaGludHM6IGhpbnRzXG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ3NoYXBlLmFwcGVuZCcsIGNvbnRleHQpO1xuXG4gIHJldHVybiBjb250ZXh0LnNoYXBlO1xufTtcblxuXG5Nb2RlbGluZy5wcm90b3R5cGUucmVtb3ZlRWxlbWVudHMgPSBmdW5jdGlvbihlbGVtZW50cykge1xuICB2YXIgY29udGV4dCA9IHtcbiAgICBlbGVtZW50czogZWxlbWVudHNcbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnZWxlbWVudHMuZGVsZXRlJywgY29udGV4dCk7XG59O1xuXG5cbk1vZGVsaW5nLnByb3RvdHlwZS5kaXN0cmlidXRlRWxlbWVudHMgPSBmdW5jdGlvbihncm91cHMsIGF4aXMsIGRpbWVuc2lvbikge1xuICB2YXIgY29udGV4dCA9IHtcbiAgICBncm91cHM6IGdyb3VwcyxcbiAgICBheGlzOiBheGlzLFxuICAgIGRpbWVuc2lvbjogZGltZW5zaW9uXG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2VsZW1lbnRzLmRpc3RyaWJ1dGUnLCBjb250ZXh0KTtcbn07XG5cblxuTW9kZWxpbmcucHJvdG90eXBlLnJlbW92ZVNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIGhpbnRzKSB7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIHNoYXBlOiBzaGFwZSxcbiAgICBoaW50czogaGludHMgfHwge31cbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnc2hhcGUuZGVsZXRlJywgY29udGV4dCk7XG59O1xuXG5cbk1vZGVsaW5nLnByb3RvdHlwZS5yZW1vdmVDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgaGludHMpIHtcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICBoaW50czogaGludHMgfHwge31cbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnY29ubmVjdGlvbi5kZWxldGUnLCBjb250ZXh0KTtcbn07XG5cbk1vZGVsaW5nLnByb3RvdHlwZS5yZXBsYWNlU2hhcGUgPSBmdW5jdGlvbihvbGRTaGFwZSwgbmV3U2hhcGUsIGhpbnRzKSB7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIG9sZFNoYXBlOiBvbGRTaGFwZSxcbiAgICBuZXdEYXRhOiBuZXdTaGFwZSxcbiAgICBoaW50czogaGludHMgfHwge31cbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnc2hhcGUucmVwbGFjZScsIGNvbnRleHQpO1xuXG4gIHJldHVybiBjb250ZXh0Lm5ld1NoYXBlO1xufTtcblxuTW9kZWxpbmcucHJvdG90eXBlLmFsaWduRWxlbWVudHMgPSBmdW5jdGlvbihlbGVtZW50cywgYWxpZ25tZW50KSB7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICBhbGlnbm1lbnQ6IGFsaWdubWVudFxuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdlbGVtZW50cy5hbGlnbicsIGNvbnRleHQpO1xufTtcblxuTW9kZWxpbmcucHJvdG90eXBlLnJlc2l6ZVNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIG5ld0JvdW5kcywgbWluQm91bmRzLCBoaW50cykge1xuICB2YXIgY29udGV4dCA9IHtcbiAgICBzaGFwZTogc2hhcGUsXG4gICAgbmV3Qm91bmRzOiBuZXdCb3VuZHMsXG4gICAgbWluQm91bmRzOiBtaW5Cb3VuZHMsXG4gICAgaGludHM6IGhpbnRzXG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ3NoYXBlLnJlc2l6ZScsIGNvbnRleHQpO1xufTtcblxuTW9kZWxpbmcucHJvdG90eXBlLmNyZWF0ZVNwYWNlID0gZnVuY3Rpb24obW92aW5nU2hhcGVzLCByZXNpemluZ1NoYXBlcywgZGVsdGEsIGRpcmVjdGlvbiwgc3RhcnQpIHtcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgZGVsdGE6IGRlbHRhLFxuICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgIG1vdmluZ1NoYXBlczogbW92aW5nU2hhcGVzLFxuICAgIHJlc2l6aW5nU2hhcGVzOiByZXNpemluZ1NoYXBlcyxcbiAgICBzdGFydDogc3RhcnRcbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnc3BhY2VUb29sJywgY29udGV4dCk7XG59O1xuXG5Nb2RlbGluZy5wcm90b3R5cGUudXBkYXRlV2F5cG9pbnRzID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgbmV3V2F5cG9pbnRzLCBoaW50cykge1xuICB2YXIgY29udGV4dCA9IHtcbiAgICBjb25uZWN0aW9uOiBjb25uZWN0aW9uLFxuICAgIG5ld1dheXBvaW50czogbmV3V2F5cG9pbnRzLFxuICAgIGhpbnRzOiBoaW50cyB8fCB7fVxuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdjb25uZWN0aW9uLnVwZGF0ZVdheXBvaW50cycsIGNvbnRleHQpO1xufTtcblxuTW9kZWxpbmcucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIHNvdXJjZSwgdGFyZ2V0LCBkb2NraW5nT3JQb2ludHMsIGhpbnRzKSB7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgbmV3U291cmNlOiBzb3VyY2UsXG4gICAgbmV3VGFyZ2V0OiB0YXJnZXQsXG4gICAgZG9ja2luZ09yUG9pbnRzOiBkb2NraW5nT3JQb2ludHMsXG4gICAgaGludHM6IGhpbnRzIHx8IHt9XG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2Nvbm5lY3Rpb24ucmVjb25uZWN0JywgY29udGV4dCk7XG59O1xuXG5Nb2RlbGluZy5wcm90b3R5cGUucmVjb25uZWN0U3RhcnQgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBuZXdTb3VyY2UsIGRvY2tpbmdPclBvaW50cywgaGludHMpIHtcbiAgaWYgKCFoaW50cykge1xuICAgIGhpbnRzID0ge307XG4gIH1cblxuICB0aGlzLnJlY29ubmVjdChjb25uZWN0aW9uLCBuZXdTb3VyY2UsIGNvbm5lY3Rpb24udGFyZ2V0LCBkb2NraW5nT3JQb2ludHMsIGFzc2lnbihoaW50cywge1xuICAgIGRvY2tpbmc6ICdzb3VyY2UnXG4gIH0pKTtcbn07XG5cbk1vZGVsaW5nLnByb3RvdHlwZS5yZWNvbm5lY3RFbmQgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBuZXdUYXJnZXQsIGRvY2tpbmdPclBvaW50cywgaGludHMpIHtcbiAgaWYgKCFoaW50cykge1xuICAgIGhpbnRzID0ge307XG4gIH1cblxuICB0aGlzLnJlY29ubmVjdChjb25uZWN0aW9uLCBjb25uZWN0aW9uLnNvdXJjZSwgbmV3VGFyZ2V0LCBkb2NraW5nT3JQb2ludHMsIGFzc2lnbihoaW50cywge1xuICAgIGRvY2tpbmc6ICd0YXJnZXQnXG4gIH0pKTtcbn07XG5cbk1vZGVsaW5nLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oc291cmNlLCB0YXJnZXQsIGF0dHJzLCBoaW50cykge1xuICByZXR1cm4gdGhpcy5jcmVhdGVDb25uZWN0aW9uKHNvdXJjZSwgdGFyZ2V0LCBhdHRycyB8fCB7fSwgc291cmNlLnBhcmVudCwgaGludHMpO1xufTtcblxuTW9kZWxpbmcucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbih0eXBlLCBhdHRycykge1xuICBpZiAoYXR0cnMgaW5zdGFuY2VvZiBCYXNlKSB7XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50RmFjdG9yeS5jcmVhdGUodHlwZSwgYXR0cnMpO1xuICB9XG59O1xuXG5Nb2RlbGluZy5wcm90b3R5cGUudG9nZ2xlQ29sbGFwc2UgPSBmdW5jdGlvbihzaGFwZSwgaGludHMpIHtcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgc2hhcGU6IHNoYXBlLFxuICAgIGhpbnRzOiBoaW50cyB8fCB7fVxuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdzaGFwZS50b2dnbGVDb2xsYXBzZScsIGNvbnRleHQpO1xufTtcbiIsImltcG9ydCB7IGZvckVhY2ggfSBmcm9tICdtaW4tZGFzaCc7XG5cbi8qKlxuICogQSBoYW5kbGVyIHRoYXQgYWxpZ24gZWxlbWVudHMgaW4gYSBjZXJ0YWluIHdheS5cbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFsaWduRWxlbWVudHMobW9kZWxpbmcsIGNhbnZhcykge1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG59XG5cbkFsaWduRWxlbWVudHMuJGluamVjdCA9IFsgJ21vZGVsaW5nJywgJ2NhbnZhcycgXTtcblxuXG5BbGlnbkVsZW1lbnRzLnByb3RvdHlwZS5wcmVFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgbW9kZWxpbmcgPSB0aGlzLl9tb2RlbGluZztcblxuICB2YXIgZWxlbWVudHMgPSBjb250ZXh0LmVsZW1lbnRzLFxuICAgICAgYWxpZ25tZW50ID0gY29udGV4dC5hbGlnbm1lbnQ7XG5cblxuICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGRlbHRhID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuXG4gICAgaWYgKGFsaWdubWVudC5sZWZ0KSB7XG4gICAgICBkZWx0YS54ID0gYWxpZ25tZW50LmxlZnQgLSBlbGVtZW50Lng7XG5cbiAgICB9IGVsc2UgaWYgKGFsaWdubWVudC5yaWdodCkge1xuICAgICAgZGVsdGEueCA9IChhbGlnbm1lbnQucmlnaHQgLSBlbGVtZW50LndpZHRoKSAtIGVsZW1lbnQueDtcblxuICAgIH0gZWxzZSBpZiAoYWxpZ25tZW50LmNlbnRlcikge1xuICAgICAgZGVsdGEueCA9IChhbGlnbm1lbnQuY2VudGVyIC0gTWF0aC5yb3VuZChlbGVtZW50LndpZHRoIC8gMikpIC0gZWxlbWVudC54O1xuXG4gICAgfSBlbHNlIGlmIChhbGlnbm1lbnQudG9wKSB7XG4gICAgICBkZWx0YS55ID0gYWxpZ25tZW50LnRvcCAtIGVsZW1lbnQueTtcblxuICAgIH0gZWxzZSBpZiAoYWxpZ25tZW50LmJvdHRvbSkge1xuICAgICAgZGVsdGEueSA9IChhbGlnbm1lbnQuYm90dG9tIC0gZWxlbWVudC5oZWlnaHQpIC0gZWxlbWVudC55O1xuXG4gICAgfSBlbHNlIGlmIChhbGlnbm1lbnQubWlkZGxlKSB7XG4gICAgICBkZWx0YS55ID0gKGFsaWdubWVudC5taWRkbGUgLSBNYXRoLnJvdW5kKGVsZW1lbnQuaGVpZ2h0IC8gMikpIC0gZWxlbWVudC55O1xuICAgIH1cblxuICAgIG1vZGVsaW5nLm1vdmVFbGVtZW50cyhbIGVsZW1lbnQgXSwgZGVsdGEsIGVsZW1lbnQucGFyZW50KTtcbiAgfSk7XG59O1xuXG5BbGlnbkVsZW1lbnRzLnByb3RvdHlwZS5wb3N0RXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxufTtcbiIsImltcG9ydCB7IHNvbWUgfSBmcm9tICdtaW4tZGFzaCc7XG5cblxuLyoqXG4gKiBBIGhhbmRsZXIgdGhhdCBpbXBsZW1lbnRzIHJldmVyc2libGUgYXBwZW5kaW5nIG9mIHNoYXBlc1xuICogdG8gYSBzb3VyY2Ugc2hhcGUuXG4gKlxuICogQHBhcmFtIHtjYW52YXN9IENhbnZhc1xuICogQHBhcmFtIHtlbGVtZW50RmFjdG9yeX0gRWxlbWVudEZhY3RvcnlcbiAqIEBwYXJhbSB7bW9kZWxpbmd9IE1vZGVsaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcGVuZFNoYXBlSGFuZGxlcihtb2RlbGluZykge1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xufVxuXG5BcHBlbmRTaGFwZUhhbmRsZXIuJGluamVjdCA9IFsgJ21vZGVsaW5nJyBdO1xuXG5cbi8vIGFwaSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNoYXBlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudERlc2NyaXB0b3J9IGNvbnRleHQuc2hhcGUgdGhlIG5ldyBzaGFwZVxuICogQHBhcmFtIHtFbGVtZW50RGVzY3JpcHRvcn0gY29udGV4dC5zb3VyY2UgdGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7RWxlbWVudERlc2NyaXB0b3J9IGNvbnRleHQucGFyZW50IHRoZSBwYXJlbnQgb2JqZWN0XG4gKiBAcGFyYW0ge1BvaW50fSBjb250ZXh0LnBvc2l0aW9uIHBvc2l0aW9uIG9mIHRoZSBuZXcgZWxlbWVudFxuICovXG5BcHBlbmRTaGFwZUhhbmRsZXIucHJvdG90eXBlLnByZUV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIHNvdXJjZSA9IGNvbnRleHQuc291cmNlO1xuXG4gIGlmICghc291cmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSBjb250ZXh0LnRhcmdldCB8fCBzb3VyY2UucGFyZW50LFxuICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gIHNoYXBlID0gY29udGV4dC5zaGFwZSA9XG4gICAgdGhpcy5fbW9kZWxpbmcuY3JlYXRlU2hhcGUoXG4gICAgICBzaGFwZSxcbiAgICAgIGNvbnRleHQucG9zaXRpb24sXG4gICAgICB0YXJnZXQsIHsgYXR0YWNoOiBoaW50cy5hdHRhY2ggfSk7XG5cbiAgY29udGV4dC5zaGFwZSA9IHNoYXBlO1xufTtcblxuQXBwZW5kU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5wb3N0RXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIGhpbnRzID0gY29udGV4dC5oaW50cyB8fCB7fTtcblxuICBpZiAoIWV4aXN0c0Nvbm5lY3Rpb24oY29udGV4dC5zb3VyY2UsIGNvbnRleHQuc2hhcGUpKSB7XG5cbiAgICAvLyBjcmVhdGUgY29ubmVjdGlvblxuICAgIGlmIChoaW50cy5jb25uZWN0aW9uVGFyZ2V0ID09PSBjb250ZXh0LnNvdXJjZSkge1xuICAgICAgdGhpcy5fbW9kZWxpbmcuY29ubmVjdChjb250ZXh0LnNoYXBlLCBjb250ZXh0LnNvdXJjZSwgY29udGV4dC5jb25uZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbW9kZWxpbmcuY29ubmVjdChjb250ZXh0LnNvdXJjZSwgY29udGV4dC5zaGFwZSwgY29udGV4dC5jb25uZWN0aW9uKTtcbiAgICB9XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZXhpc3RzQ29ubmVjdGlvbihzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gc29tZShzb3VyY2Uub3V0Z29pbmcsIGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gYy50YXJnZXQgPT09IHRhcmdldDtcbiAgfSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ3JlYXRlQ29ubmVjdGlvbkhhbmRsZXIoY2FudmFzLCBsYXlvdXRlcikge1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gIHRoaXMuX2xheW91dGVyID0gbGF5b3V0ZXI7XG59XG5cbkNyZWF0ZUNvbm5lY3Rpb25IYW5kbGVyLiRpbmplY3QgPSBbICdjYW52YXMnLCAnbGF5b3V0ZXInIF07XG5cblxuLy8gYXBpIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vKipcbiAqIEFwcGVuZHMgYSBzaGFwZSB0byBhIHRhcmdldCBzaGFwZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge2Rqcy5lbGVtZW50LkJhc2V9IGNvbnRleHQuc291cmNlIHRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge2Rqcy5lbGVtZW50LkJhc2V9IGNvbnRleHQudGFyZ2V0IHRoZSBwYXJlbnQgb2JqZWN0XG4gKiBAcGFyYW0ge1BvaW50fSBjb250ZXh0LnBvc2l0aW9uIHBvc2l0aW9uIG9mIHRoZSBuZXcgZWxlbWVudFxuICovXG5DcmVhdGVDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgIHNvdXJjZSA9IGNvbnRleHQuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gY29udGV4dC50YXJnZXQsXG4gICAgICBwYXJlbnQgPSBjb250ZXh0LnBhcmVudCxcbiAgICAgIHBhcmVudEluZGV4ID0gY29udGV4dC5wYXJlbnRJbmRleCxcbiAgICAgIGhpbnRzID0gY29udGV4dC5oaW50cztcblxuICBpZiAoIXNvdXJjZSB8fCAhdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgYW5kIHRhcmdldCByZXF1aXJlZCcpO1xuICB9XG5cbiAgaWYgKCFwYXJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcmVudCByZXF1aXJlZCcpO1xuICB9XG5cbiAgY29ubmVjdGlvbi5zb3VyY2UgPSBzb3VyY2U7XG4gIGNvbm5lY3Rpb24udGFyZ2V0ID0gdGFyZ2V0O1xuXG4gIGlmICghY29ubmVjdGlvbi53YXlwb2ludHMpIHtcbiAgICBjb25uZWN0aW9uLndheXBvaW50cyA9IHRoaXMuX2xheW91dGVyLmxheW91dENvbm5lY3Rpb24oY29ubmVjdGlvbiwgaGludHMpO1xuICB9XG5cbiAgLy8gYWRkIGNvbm5lY3Rpb25cbiAgdGhpcy5fY2FudmFzLmFkZENvbm5lY3Rpb24oY29ubmVjdGlvbiwgcGFyZW50LCBwYXJlbnRJbmRleCk7XG5cbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG5DcmVhdGVDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbjtcblxuICB0aGlzLl9jYW52YXMucmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcblxuICBjb25uZWN0aW9uLnNvdXJjZSA9IG51bGw7XG4gIGNvbm5lY3Rpb24udGFyZ2V0ID0gbnVsbDtcblxuICByZXR1cm4gY29ubmVjdGlvbjtcbn07IiwiaW1wb3J0IHtcclxuICBhc3NpZ24sXHJcbiAgZm9yRWFjaCxcclxuICBpc051bWJlcixcclxuICBtYXAsXHJcbiAgcGljayxcclxuICB2YWx1ZXNcclxufSBmcm9tICdtaW4tZGFzaCc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGdldEJCb3gsXHJcbiAgZ2V0UGFyZW50c1xyXG59IGZyb20gJy4uLy4uLy4uL3V0aWwvRWxlbWVudHMnO1xyXG5cclxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENyZWF0ZUVsZW1lbnRzSGFuZGxlcihtb2RlbGluZykge1xyXG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XHJcbn1cclxuXHJcbkNyZWF0ZUVsZW1lbnRzSGFuZGxlci4kaW5qZWN0ID0gW1xyXG4gICdtb2RlbGluZydcclxuXTtcclxuXHJcbkNyZWF0ZUVsZW1lbnRzSGFuZGxlci5wcm90b3R5cGUucHJlRXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICB2YXIgZWxlbWVudHMgPSBjb250ZXh0LmVsZW1lbnRzLFxyXG4gICAgICBwYXJlbnQgPSBjb250ZXh0LnBhcmVudCxcclxuICAgICAgcGFyZW50SW5kZXggPSBjb250ZXh0LnBhcmVudEluZGV4LFxyXG4gICAgICBwb3NpdGlvbiA9IGNvbnRleHQucG9zaXRpb24sXHJcbiAgICAgIGhpbnRzID0gY29udGV4dC5oaW50cztcclxuXHJcbiAgdmFyIG1vZGVsaW5nID0gdGhpcy5fbW9kZWxpbmc7XHJcblxyXG4gIC8vIG1ha2Ugc3VyZSBlYWNoIGVsZW1lbnQgaGFzIHggYW5kIHlcclxuICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICBpZiAoIWlzTnVtYmVyKGVsZW1lbnQueCkpIHtcclxuICAgICAgZWxlbWVudC54ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzTnVtYmVyKGVsZW1lbnQueSkpIHtcclxuICAgICAgZWxlbWVudC55ID0gMDtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgdmFyIGJib3ggPSBnZXRCQm94KGVsZW1lbnRzKTtcclxuXHJcbiAgLy8gY2VudGVyIGVsZW1lbnRzIGFyb3VuZCBwb3NpdGlvblxyXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGlmIChpc0Nvbm5lY3Rpb24oZWxlbWVudCkpIHtcclxuICAgICAgZWxlbWVudC53YXlwb2ludHMgPSBtYXAoZWxlbWVudC53YXlwb2ludHMsIGZ1bmN0aW9uKHdheXBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHg6IHJvdW5kKHdheXBvaW50LnggLSBiYm94LnggLSBiYm94LndpZHRoIC8gMiArIHBvc2l0aW9uLngpLFxyXG4gICAgICAgICAgeTogcm91bmQod2F5cG9pbnQueSAtIGJib3gueSAtIGJib3guaGVpZ2h0IC8gMiArIHBvc2l0aW9uLnkpXHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXNzaWduKGVsZW1lbnQsIHtcclxuICAgICAgeDogcm91bmQoZWxlbWVudC54IC0gYmJveC54IC0gYmJveC53aWR0aCAvIDIgKyBwb3NpdGlvbi54KSxcclxuICAgICAgeTogcm91bmQoZWxlbWVudC55IC0gYmJveC55IC0gYmJveC5oZWlnaHQgLyAyICsgcG9zaXRpb24ueSlcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICB2YXIgcGFyZW50cyA9IGdldFBhcmVudHMoZWxlbWVudHMpO1xyXG5cclxuICB2YXIgY2FjaGUgPSB7fTtcclxuXHJcbiAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgaWYgKGlzQ29ubmVjdGlvbihlbGVtZW50KSkge1xyXG4gICAgICBjYWNoZVsgZWxlbWVudC5pZCBdID0gaXNOdW1iZXIocGFyZW50SW5kZXgpID9cclxuICAgICAgICBtb2RlbGluZy5jcmVhdGVDb25uZWN0aW9uKFxyXG4gICAgICAgICAgY2FjaGVbIGVsZW1lbnQuc291cmNlLmlkIF0sXHJcbiAgICAgICAgICBjYWNoZVsgZWxlbWVudC50YXJnZXQuaWQgXSxcclxuICAgICAgICAgIHBhcmVudEluZGV4LFxyXG4gICAgICAgICAgZWxlbWVudCxcclxuICAgICAgICAgIGVsZW1lbnQucGFyZW50IHx8IHBhcmVudCxcclxuICAgICAgICAgIGhpbnRzXHJcbiAgICAgICAgKSA6XHJcbiAgICAgICAgbW9kZWxpbmcuY3JlYXRlQ29ubmVjdGlvbihcclxuICAgICAgICAgIGNhY2hlWyBlbGVtZW50LnNvdXJjZS5pZCBdLFxyXG4gICAgICAgICAgY2FjaGVbIGVsZW1lbnQudGFyZ2V0LmlkIF0sXHJcbiAgICAgICAgICBlbGVtZW50LFxyXG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgfHwgcGFyZW50LFxyXG4gICAgICAgICAgaGludHNcclxuICAgICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjcmVhdGVTaGFwZUhpbnRzID0gYXNzaWduKHt9LCBoaW50cyk7XHJcblxyXG4gICAgaWYgKHBhcmVudHMuaW5kZXhPZihlbGVtZW50KSA9PT0gLTEpIHtcclxuICAgICAgY3JlYXRlU2hhcGVIaW50cy5hdXRvUmVzaXplID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY2FjaGVbIGVsZW1lbnQuaWQgXSA9IGlzTnVtYmVyKHBhcmVudEluZGV4KSA/XHJcbiAgICAgIG1vZGVsaW5nLmNyZWF0ZVNoYXBlKFxyXG4gICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgcGljayhlbGVtZW50LCBbICd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JyBdKSxcclxuICAgICAgICBlbGVtZW50LnBhcmVudCB8fCBwYXJlbnQsXHJcbiAgICAgICAgcGFyZW50SW5kZXgsXHJcbiAgICAgICAgY3JlYXRlU2hhcGVIaW50c1xyXG4gICAgICApIDpcclxuICAgICAgbW9kZWxpbmcuY3JlYXRlU2hhcGUoXHJcbiAgICAgICAgZWxlbWVudCxcclxuICAgICAgICBwaWNrKGVsZW1lbnQsIFsgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnIF0pLFxyXG4gICAgICAgIGVsZW1lbnQucGFyZW50IHx8IHBhcmVudCxcclxuICAgICAgICBjcmVhdGVTaGFwZUhpbnRzXHJcbiAgICAgICk7XHJcbiAgfSk7XHJcblxyXG4gIGNvbnRleHQuZWxlbWVudHMgPSB2YWx1ZXMoY2FjaGUpO1xyXG59O1xyXG5cclxuLy8gaGVscGVycyAvLy8vLy8vLy8vXHJcblxyXG5mdW5jdGlvbiBpc0Nvbm5lY3Rpb24oZWxlbWVudCkge1xyXG4gIHJldHVybiAhIWVsZW1lbnQud2F5cG9pbnRzO1xyXG59IiwiaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IENyZWF0ZVNoYXBlSGFuZGxlciBmcm9tICcuL0NyZWF0ZVNoYXBlSGFuZGxlcic7XG5cblxuLyoqXG4gKiBBIGhhbmRsZXIgdGhhdCBhdHRhY2hlcyBhIGxhYmVsIHRvIGEgZ2l2ZW4gdGFyZ2V0IHNoYXBlLlxuICpcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ3JlYXRlTGFiZWxIYW5kbGVyKGNhbnZhcykge1xuICBDcmVhdGVTaGFwZUhhbmRsZXIuY2FsbCh0aGlzLCBjYW52YXMpO1xufVxuXG5pbmhlcml0cyhDcmVhdGVMYWJlbEhhbmRsZXIsIENyZWF0ZVNoYXBlSGFuZGxlcik7XG5cbkNyZWF0ZUxhYmVsSGFuZGxlci4kaW5qZWN0ID0gWyAnY2FudmFzJyBdO1xuXG5cbi8vIGFwaSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxudmFyIG9yaWdpbmFsRXhlY3V0ZSA9IENyZWF0ZVNoYXBlSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbGFiZWwgdG8gYSB0YXJnZXQgc2hhcGUuXG4gKlxuICogQG1ldGhvZCBDcmVhdGVMYWJlbEhhbmRsZXIjZXhlY3V0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnREZXNjcmlwdG9yfSBjb250ZXh0LnRhcmdldCB0aGUgZWxlbWVudCB0aGUgbGFiZWwgaXMgYXR0YWNoZWQgdG9cbiAqIEBwYXJhbSB7RWxlbWVudERlc2NyaXB0b3J9IGNvbnRleHQucGFyZW50IHRoZSBwYXJlbnQgb2JqZWN0XG4gKiBAcGFyYW0ge1BvaW50fSBjb250ZXh0LnBvc2l0aW9uIHBvc2l0aW9uIG9mIHRoZSBuZXcgZWxlbWVudFxuICovXG5DcmVhdGVMYWJlbEhhbmRsZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGxhYmVsID0gY29udGV4dC5zaGFwZTtcblxuICBlbnN1cmVWYWxpZERpbWVuc2lvbnMobGFiZWwpO1xuXG4gIGxhYmVsLmxhYmVsVGFyZ2V0ID0gY29udGV4dC5sYWJlbFRhcmdldDtcblxuICByZXR1cm4gb3JpZ2luYWxFeGVjdXRlLmNhbGwodGhpcywgY29udGV4dCk7XG59O1xuXG52YXIgb3JpZ2luYWxSZXZlcnQgPSBDcmVhdGVTaGFwZUhhbmRsZXIucHJvdG90eXBlLnJldmVydDtcblxuLyoqXG4gKiBVbmRvIGFwcGVuZCBieSByZW1vdmluZyB0aGUgc2hhcGVcbiAqL1xuQ3JlYXRlTGFiZWxIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnRleHQuc2hhcGUubGFiZWxUYXJnZXQgPSBudWxsO1xuXG4gIHJldHVybiBvcmlnaW5hbFJldmVydC5jYWxsKHRoaXMsIGNvbnRleHQpO1xufTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gZW5zdXJlVmFsaWREaW1lbnNpb25zKGxhYmVsKSB7XG5cbiAgLy8gbWFrZSBzdXJlIGEgbGFiZWwgaGFzIHZhbGlkIHsgd2lkdGgsIGhlaWdodCB9IGRpbWVuc2lvbnNcbiAgWyAnd2lkdGgnLCAnaGVpZ2h0JyBdLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIGlmICh0eXBlb2YgbGFiZWxbcHJvcF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsYWJlbFtwcm9wXSA9IDA7XG4gICAgfVxuICB9KTtcbn0iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdtaW4tZGFzaCc7XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5cblxuLyoqXG4gKiBBIGhhbmRsZXIgdGhhdCBpbXBsZW1lbnRzIHJldmVyc2libGUgYWRkaXRpb24gb2Ygc2hhcGVzLlxuICpcbiAqIEBwYXJhbSB7Y2FudmFzfSBDYW52YXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ3JlYXRlU2hhcGVIYW5kbGVyKGNhbnZhcykge1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG59XG5cbkNyZWF0ZVNoYXBlSGFuZGxlci4kaW5qZWN0ID0gWyAnY2FudmFzJyBdO1xuXG5cbi8vIGFwaSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLyoqXG4gKiBBcHBlbmRzIGEgc2hhcGUgdG8gYSB0YXJnZXQgc2hhcGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gY29udGV4dC5wYXJlbnQgdGhlIHBhcmVudCBvYmplY3RcbiAqIEBwYXJhbSB7UG9pbnR9IGNvbnRleHQucG9zaXRpb24gcG9zaXRpb24gb2YgdGhlIG5ldyBlbGVtZW50XG4gKi9cbkNyZWF0ZVNoYXBlSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgcG9zaXRpb25PckJvdW5kcyA9IGNvbnRleHQucG9zaXRpb24sXG4gICAgICBwYXJlbnQgPSBjb250ZXh0LnBhcmVudCxcbiAgICAgIHBhcmVudEluZGV4ID0gY29udGV4dC5wYXJlbnRJbmRleDtcblxuICBpZiAoIXBhcmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFyZW50IHJlcXVpcmVkJyk7XG4gIH1cblxuICBpZiAoIXBvc2l0aW9uT3JCb3VuZHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aW9uIHJlcXVpcmVkJyk7XG4gIH1cblxuICAvLyAoMSkgYWRkIGF0IGV2ZW50IGNlbnRlciBwb3NpdGlvbiBfb3JfIGF0IGdpdmVuIGJvdW5kc1xuICBpZiAocG9zaXRpb25PckJvdW5kcy53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzaWduKHNoYXBlLCBwb3NpdGlvbk9yQm91bmRzKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NpZ24oc2hhcGUsIHtcbiAgICAgIHg6IHBvc2l0aW9uT3JCb3VuZHMueCAtIHJvdW5kKHNoYXBlLndpZHRoIC8gMiksXG4gICAgICB5OiBwb3NpdGlvbk9yQm91bmRzLnkgLSByb3VuZChzaGFwZS5oZWlnaHQgLyAyKVxuICAgIH0pO1xuICB9XG5cbiAgLy8gKDIpIGFkZCB0byBjYW52YXNcbiAgdGhpcy5fY2FudmFzLmFkZFNoYXBlKHNoYXBlLCBwYXJlbnQsIHBhcmVudEluZGV4KTtcblxuICByZXR1cm4gc2hhcGU7XG59O1xuXG5cbi8qKlxuICogVW5kbyBhcHBlbmQgYnkgcmVtb3ZpbmcgdGhlIHNoYXBlXG4gKi9cbkNyZWF0ZVNoYXBlSGFuZGxlci5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGU7XG5cbiAgLy8gKDMpIHJlbW92ZSBmb3JtIGNhbnZhc1xuICB0aGlzLl9jYW52YXMucmVtb3ZlU2hhcGUoc2hhcGUpO1xuXG4gIHJldHVybiBzaGFwZTtcbn07IiwiaW1wb3J0IHtcbiAgYWRkIGFzIGNvbGxlY3Rpb25BZGQsXG4gIGluZGV4T2YgYXMgY29sbGVjdGlvbklkeFxufSBmcm9tICcuLi8uLi8uLi91dGlsL0NvbGxlY3Rpb25zJztcblxuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IGltcGxlbWVudHMgcmV2ZXJzaWJsZSBkZWxldGlvbiBvZiBDb25uZWN0aW9ucy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGVsZXRlQ29ubmVjdGlvbkhhbmRsZXIoY2FudmFzLCBtb2RlbGluZykge1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG59XG5cbkRlbGV0ZUNvbm5lY3Rpb25IYW5kbGVyLiRpbmplY3QgPSBbXG4gICdjYW52YXMnLFxuICAnbW9kZWxpbmcnXG5dO1xuXG5cbkRlbGV0ZUNvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgcGFyZW50ID0gY29ubmVjdGlvbi5wYXJlbnQ7XG5cbiAgY29udGV4dC5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgLy8gcmVtZW1iZXIgY29udGFpbm1lbnRcbiAgY29udGV4dC5wYXJlbnRJbmRleCA9IGNvbGxlY3Rpb25JZHgocGFyZW50LmNoaWxkcmVuLCBjb25uZWN0aW9uKTtcblxuICBjb250ZXh0LnNvdXJjZSA9IGNvbm5lY3Rpb24uc291cmNlO1xuICBjb250ZXh0LnRhcmdldCA9IGNvbm5lY3Rpb24udGFyZ2V0O1xuXG4gIHRoaXMuX2NhbnZhcy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuXG4gIGNvbm5lY3Rpb24uc291cmNlID0gbnVsbDtcbiAgY29ubmVjdGlvbi50YXJnZXQgPSBudWxsO1xuXG4gIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuLyoqXG4gKiBDb21tYW5kIHJldmVydCBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuRGVsZXRlQ29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgIHBhcmVudCA9IGNvbnRleHQucGFyZW50LFxuICAgICAgcGFyZW50SW5kZXggPSBjb250ZXh0LnBhcmVudEluZGV4O1xuXG4gIGNvbm5lY3Rpb24uc291cmNlID0gY29udGV4dC5zb3VyY2U7XG4gIGNvbm5lY3Rpb24udGFyZ2V0ID0gY29udGV4dC50YXJnZXQ7XG5cbiAgLy8gcmVzdG9yZSBjb250YWlubWVudFxuICBjb2xsZWN0aW9uQWRkKHBhcmVudC5jaGlsZHJlbiwgY29ubmVjdGlvbiwgcGFyZW50SW5kZXgpO1xuXG4gIHRoaXMuX2NhbnZhcy5hZGRDb25uZWN0aW9uKGNvbm5lY3Rpb24sIHBhcmVudCk7XG5cbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuIiwiaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gJ21pbi1kYXNoJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWxldGVFbGVtZW50c0hhbmRsZXIobW9kZWxpbmcsIGVsZW1lbnRSZWdpc3RyeSkge1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuICB0aGlzLl9lbGVtZW50UmVnaXN0cnkgPSBlbGVtZW50UmVnaXN0cnk7XG59XG5cbkRlbGV0ZUVsZW1lbnRzSGFuZGxlci4kaW5qZWN0ID0gW1xuICAnbW9kZWxpbmcnLFxuICAnZWxlbWVudFJlZ2lzdHJ5J1xuXTtcblxuXG5EZWxldGVFbGVtZW50c0hhbmRsZXIucHJvdG90eXBlLnBvc3RFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBtb2RlbGluZyA9IHRoaXMuX21vZGVsaW5nLFxuICAgICAgZWxlbWVudFJlZ2lzdHJ5ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LFxuICAgICAgZWxlbWVudHMgPSBjb250ZXh0LmVsZW1lbnRzO1xuXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYmVlbiByZW1vdmVkIHdpdGggcHJldmlvdXNcbiAgICAvLyByZW1vdmUgb3BlcmF0aW9ucyBhbHJlYWR5IChlLmcuIGluIGNhc2Ugb2YgbmVzdGluZylcbiAgICBpZiAoIWVsZW1lbnRSZWdpc3RyeS5nZXQoZWxlbWVudC5pZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC53YXlwb2ludHMpIHtcbiAgICAgIG1vZGVsaW5nLnJlbW92ZUNvbm5lY3Rpb24oZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsaW5nLnJlbW92ZVNoYXBlKGVsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG59OyIsImltcG9ydCB7XG4gIGFkZCBhcyBjb2xsZWN0aW9uQWRkLFxuICBpbmRleE9mIGFzIGNvbGxlY3Rpb25JZHhcbn0gZnJvbSAnLi4vLi4vLi4vdXRpbC9Db2xsZWN0aW9ucyc7XG5cbmltcG9ydCB7IHNhdmVDbGVhciB9IGZyb20gJy4uLy4uLy4uL3V0aWwvUmVtb3ZhbCc7XG5cblxuLyoqXG4gKiBBIGhhbmRsZXIgdGhhdCBpbXBsZW1lbnRzIHJldmVyc2libGUgZGVsZXRpb24gb2Ygc2hhcGVzLlxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGVsZXRlU2hhcGVIYW5kbGVyKGNhbnZhcywgbW9kZWxpbmcpIHtcbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xufVxuXG5EZWxldGVTaGFwZUhhbmRsZXIuJGluamVjdCA9IFsgJ2NhbnZhcycsICdtb2RlbGluZycgXTtcblxuXG4vKipcbiAqIC0gUmVtb3ZlIGNvbm5lY3Rpb25zXG4gKiAtIFJlbW92ZSBhbGwgZGlyZWN0IGNoaWxkcmVuXG4gKi9cbkRlbGV0ZVNoYXBlSGFuZGxlci5wcm90b3R5cGUucHJlRXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgbW9kZWxpbmcgPSB0aGlzLl9tb2RlbGluZztcblxuICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlO1xuXG4gIC8vIHJlbW92ZSBjb25uZWN0aW9uc1xuICBzYXZlQ2xlYXIoc2hhcGUuaW5jb21pbmcsIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcblxuICAgIC8vIFRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBjb25uZWN0aW9uIGlzbid0IHJlbW92ZWQgdHdpY2VcbiAgICAvLyBGb3IgZXhhbXBsZSBpZiBhIGNvbnRhaW5lciBpcyByZW1vdmVkXG4gICAgbW9kZWxpbmcucmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uLCB7IG5lc3RlZDogdHJ1ZSB9KTtcbiAgfSk7XG5cbiAgc2F2ZUNsZWFyKHNoYXBlLm91dGdvaW5nLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgbW9kZWxpbmcucmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uLCB7IG5lc3RlZDogdHJ1ZSB9KTtcbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIGNoaWxkIHNoYXBlcyBhbmQgY29ubmVjdGlvbnNcbiAgc2F2ZUNsZWFyKHNoYXBlLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgIGlmIChpc0Nvbm5lY3Rpb24oY2hpbGQpKSB7XG4gICAgICBtb2RlbGluZy5yZW1vdmVDb25uZWN0aW9uKGNoaWxkLCB7IG5lc3RlZDogdHJ1ZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWxpbmcucmVtb3ZlU2hhcGUoY2hpbGQsIHsgbmVzdGVkOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzaGFwZSBhbmQgcmVtZW1iZXIgdGhlIHBhcmVudFxuICovXG5EZWxldGVTaGFwZUhhbmRsZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cbiAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgIG9sZFBhcmVudCA9IHNoYXBlLnBhcmVudDtcblxuICBjb250ZXh0Lm9sZFBhcmVudCA9IG9sZFBhcmVudDtcblxuICAvLyByZW1vdmUgY29udGFpbm1lbnRcbiAgY29udGV4dC5vbGRQYXJlbnRJbmRleCA9IGNvbGxlY3Rpb25JZHgob2xkUGFyZW50LmNoaWxkcmVuLCBzaGFwZSk7XG5cbiAgLy8gcmVtb3ZlIHNoYXBlXG4gIGNhbnZhcy5yZW1vdmVTaGFwZShzaGFwZSk7XG5cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuXG4vKipcbiAqIENvbW1hbmQgcmV2ZXJ0IGltcGxlbWVudGF0aW9uXG4gKi9cbkRlbGV0ZVNoYXBlSGFuZGxlci5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cbiAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgIG9sZFBhcmVudCA9IGNvbnRleHQub2xkUGFyZW50LFxuICAgICAgb2xkUGFyZW50SW5kZXggPSBjb250ZXh0Lm9sZFBhcmVudEluZGV4O1xuXG4gIC8vIHJlc3RvcmUgY29udGFpbm1lbnRcbiAgY29sbGVjdGlvbkFkZChvbGRQYXJlbnQuY2hpbGRyZW4sIHNoYXBlLCBvbGRQYXJlbnRJbmRleCk7XG5cbiAgY2FudmFzLmFkZFNoYXBlKHNoYXBlLCBvbGRQYXJlbnQpO1xuXG4gIHJldHVybiBzaGFwZTtcbn07XG5cbmZ1bmN0aW9uIGlzQ29ubmVjdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LndheXBvaW50cztcbn1cbiIsImltcG9ydCB7XG4gIGZvckVhY2gsXG4gIHNvcnRCeVxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxuLyoqXG4gKiBBIGhhbmRsZXIgdGhhdCBkaXN0cmlidXRlcyBlbGVtZW50cyBldmVubHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERpc3RyaWJ1dGVFbGVtZW50cyhtb2RlbGluZykge1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xufVxuXG5EaXN0cmlidXRlRWxlbWVudHMuJGluamVjdCA9IFsgJ21vZGVsaW5nJyBdO1xuXG52YXIgT0ZGX0FYSVMgPSB7XG4gIHg6ICd5JyxcbiAgeTogJ3gnXG59O1xuXG5EaXN0cmlidXRlRWxlbWVudHMucHJvdG90eXBlLnByZUV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBtb2RlbGluZyA9IHRoaXMuX21vZGVsaW5nO1xuXG4gIHZhciBncm91cHMgPSBjb250ZXh0Lmdyb3VwcyxcbiAgICAgIGF4aXMgPSBjb250ZXh0LmF4aXMsXG4gICAgICBkaW1lbnNpb24gPSBjb250ZXh0LmRpbWVuc2lvbjtcblxuICBmdW5jdGlvbiB1cGRhdGVSYW5nZShncm91cCwgZWxlbWVudCkge1xuICAgIGdyb3VwLnJhbmdlLm1pbiA9IE1hdGgubWluKGVsZW1lbnRbYXhpc10sIGdyb3VwLnJhbmdlLm1pbik7XG4gICAgZ3JvdXAucmFuZ2UubWF4ID0gTWF0aC5tYXgoZWxlbWVudFtheGlzXSArIGVsZW1lbnRbZGltZW5zaW9uXSwgZ3JvdXAucmFuZ2UubWF4KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRlcihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnRbYXhpc10gKyBlbGVtZW50W2RpbWVuc2lvbl0gLyAyO1xuICB9XG5cbiAgZnVuY3Rpb24gbGFzdElkeChhcnIpIHtcbiAgICByZXR1cm4gYXJyLmxlbmd0aCAtIDE7XG4gIH1cblxuICBmdW5jdGlvbiByYW5nZURpZmYocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UubWF4IC0gcmFuZ2UubWluO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudGVyRWxlbWVudChyZWZDZW50ZXIsIGVsZW1lbnQpIHtcbiAgICB2YXIgZGVsdGEgPSB7IHk6IDAgfTtcblxuICAgIGRlbHRhW2F4aXNdID0gcmVmQ2VudGVyIC0gY2VudGVyKGVsZW1lbnQpO1xuXG4gICAgaWYgKGRlbHRhW2F4aXNdKSB7XG5cbiAgICAgIGRlbHRhW09GRl9BWElTW2F4aXNdXSA9IDA7XG5cbiAgICAgIG1vZGVsaW5nLm1vdmVFbGVtZW50cyhbIGVsZW1lbnQgXSwgZGVsdGEsIGVsZW1lbnQucGFyZW50KTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmlyc3RHcm91cCA9IGdyb3Vwc1swXSxcbiAgICAgIGxhc3RHcm91cElkeCA9IGxhc3RJZHgoZ3JvdXBzKSxcbiAgICAgIGxhc3RHcm91cCA9IGdyb3Vwc1sgbGFzdEdyb3VwSWR4IF07XG5cbiAgdmFyIG1hcmdpbixcbiAgICAgIHNwYWNlSW5CZXR3ZWVuLFxuICAgICAgZ3JvdXBzU2l6ZSA9IDA7IC8vIHRoZSBzaXplIG9mIGVhY2ggcmFuZ2VcblxuICBmb3JFYWNoKGdyb3VwcywgZnVuY3Rpb24oZ3JvdXAsIGlkeCkge1xuICAgIHZhciBzb3J0ZWRFbGVtZW50cyxcbiAgICAgICAgcmVmRWxlbSxcbiAgICAgICAgcmVmQ2VudGVyO1xuXG4gICAgaWYgKGdyb3VwLmVsZW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGlmIChpZHggJiYgaWR4ICE9PSBncm91cHMubGVuZ3RoIC0gMSkge1xuICAgICAgICB1cGRhdGVSYW5nZShncm91cCwgZ3JvdXAuZWxlbWVudHNbMF0pO1xuXG4gICAgICAgIGdyb3Vwc1NpemUgKz0gcmFuZ2VEaWZmKGdyb3VwLnJhbmdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzb3J0ZWRFbGVtZW50cyA9IHNvcnRCeShncm91cC5lbGVtZW50cywgYXhpcyk7XG5cbiAgICByZWZFbGVtID0gc29ydGVkRWxlbWVudHNbMF07XG5cbiAgICBpZiAoaWR4ID09PSBsYXN0R3JvdXBJZHgpIHtcbiAgICAgIHJlZkVsZW0gPSBzb3J0ZWRFbGVtZW50c1tsYXN0SWR4KHNvcnRlZEVsZW1lbnRzKV07XG4gICAgfVxuXG4gICAgcmVmQ2VudGVyID0gY2VudGVyKHJlZkVsZW0pO1xuXG4gICAgLy8gd2FubmEgdXBkYXRlIHRoZSByYW5nZXMgYWZ0ZXIgdGhlIHNoYXBlcyBoYXZlIGJlZW4gY2VudGVyZWRcbiAgICBncm91cC5yYW5nZSA9IG51bGw7XG5cbiAgICBmb3JFYWNoKHNvcnRlZEVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICAgIGNlbnRlckVsZW1lbnQocmVmQ2VudGVyLCBlbGVtZW50KTtcblxuICAgICAgaWYgKGdyb3VwLnJhbmdlID09PSBudWxsKSB7XG4gICAgICAgIGdyb3VwLnJhbmdlID0ge1xuICAgICAgICAgIG1pbjogZWxlbWVudFtheGlzXSxcbiAgICAgICAgICBtYXg6IGVsZW1lbnRbYXhpc10gKyBlbGVtZW50W2RpbWVuc2lvbl1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSBncm91cCdzIHJhbmdlIGFmdGVyIGNlbnRlcmluZyB0aGUgcmFuZ2UgZWxlbWVudHNcbiAgICAgIHVwZGF0ZVJhbmdlKGdyb3VwLCBlbGVtZW50KTtcbiAgICB9KTtcblxuICAgIGlmIChpZHggJiYgaWR4ICE9PSBncm91cHMubGVuZ3RoIC0gMSkge1xuICAgICAgZ3JvdXBzU2l6ZSArPSByYW5nZURpZmYoZ3JvdXAucmFuZ2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgc3BhY2VJbkJldHdlZW4gPSBNYXRoLmFicyhsYXN0R3JvdXAucmFuZ2UubWluIC0gZmlyc3RHcm91cC5yYW5nZS5tYXgpO1xuXG4gIG1hcmdpbiA9IE1hdGgucm91bmQoKHNwYWNlSW5CZXR3ZWVuIC0gZ3JvdXBzU2l6ZSkgLyAoZ3JvdXBzLmxlbmd0aCAtIDEpKTtcblxuICBpZiAobWFyZ2luIDwgZ3JvdXBzLmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3JFYWNoKGdyb3VwcywgZnVuY3Rpb24oZ3JvdXAsIGdyb3VwSWR4KSB7XG4gICAgdmFyIGRlbHRhID0ge30sXG4gICAgICAgIHByZXZHcm91cDtcblxuICAgIGlmIChncm91cCA9PT0gZmlyc3RHcm91cCB8fCBncm91cCA9PT0gbGFzdEdyb3VwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJldkdyb3VwID0gZ3JvdXBzW2dyb3VwSWR4IC0gMV07XG5cbiAgICBncm91cC5yYW5nZS5tYXggPSAwO1xuXG4gICAgZm9yRWFjaChncm91cC5lbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCwgaWR4KSB7XG4gICAgICBkZWx0YVtPRkZfQVhJU1theGlzXV0gPSAwO1xuICAgICAgZGVsdGFbYXhpc10gPSAocHJldkdyb3VwLnJhbmdlLm1heCAtIGVsZW1lbnRbYXhpc10pICsgbWFyZ2luO1xuXG4gICAgICBpZiAoZ3JvdXAucmFuZ2UubWluICE9PSBlbGVtZW50W2F4aXNdKSB7XG4gICAgICAgIGRlbHRhW2F4aXNdICs9IGVsZW1lbnRbYXhpc10gLSBncm91cC5yYW5nZS5taW47XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWx0YVtheGlzXSkge1xuICAgICAgICBtb2RlbGluZy5tb3ZlRWxlbWVudHMoWyBlbGVtZW50IF0sIGRlbHRhLCBlbGVtZW50LnBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIGdyb3VwLnJhbmdlLm1heCA9IE1hdGgubWF4KGVsZW1lbnRbYXhpc10gKyBlbGVtZW50W2RpbWVuc2lvbl0sIGlkeCA/IGdyb3VwLnJhbmdlLm1heCA6IDApO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbkRpc3RyaWJ1dGVFbGVtZW50cy5wcm90b3R5cGUucG9zdEV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbn07XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdtaW4tZGFzaCc7XG5cblxuLyoqXG4gKiBBIGhhbmRsZXIgdGhhdCBpbXBsZW1lbnRzIHJldmVyc2libGUgbW92aW5nIG9mIHNoYXBlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGF5b3V0Q29ubmVjdGlvbkhhbmRsZXIobGF5b3V0ZXIsIGNhbnZhcykge1xuICB0aGlzLl9sYXlvdXRlciA9IGxheW91dGVyO1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG59XG5cbkxheW91dENvbm5lY3Rpb25IYW5kbGVyLiRpbmplY3QgPSBbICdsYXlvdXRlcicsICdjYW52YXMnIF07XG5cbkxheW91dENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uO1xuXG4gIHZhciBvbGRXYXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cztcblxuICBhc3NpZ24oY29udGV4dCwge1xuICAgIG9sZFdheXBvaW50czogb2xkV2F5cG9pbnRzXG4gIH0pO1xuXG4gIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gdGhpcy5fbGF5b3V0ZXIubGF5b3V0Q29ubmVjdGlvbihjb25uZWN0aW9uLCBjb250ZXh0LmhpbnRzKTtcblxuICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG5cbkxheW91dENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb247XG5cbiAgY29ubmVjdGlvbi53YXlwb2ludHMgPSBjb250ZXh0Lm9sZFdheXBvaW50cztcblxuICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG4iLCJpbXBvcnQgeyBmb3JFYWNoIH0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbmltcG9ydCB7XG4gIGFkZCBhcyBjb2xsZWN0aW9uQWRkLFxuICByZW1vdmUgYXMgY29sbGVjdGlvblJlbW92ZVxufSBmcm9tICcuLi8uLi8uLi91dGlsL0NvbGxlY3Rpb25zJztcblxuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IGltcGxlbWVudHMgcmV2ZXJzaWJsZSBtb3Zpbmcgb2YgY29ubmVjdGlvbnMuXG4gKlxuICogVGhlIGhhbmRsZXIgZGlmZmVycyBmcm9tIHRoZSBsYXlvdXQgY29ubmVjdGlvbiBoYW5kbGVyIGluIGEgc2Vuc2VcbiAqIHRoYXQgaXQgcHJlc2VydmVzIHRoZSBjb25uZWN0aW9uIGxheW91dC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW92ZUNvbm5lY3Rpb25IYW5kbGVyKCkgeyB9XG5cblxuTW92ZUNvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgZGVsdGEgPSBjb250ZXh0LmRlbHRhO1xuXG4gIHZhciBuZXdQYXJlbnQgPSBjb250ZXh0Lm5ld1BhcmVudCB8fCBjb25uZWN0aW9uLnBhcmVudCxcbiAgICAgIG5ld1BhcmVudEluZGV4ID0gY29udGV4dC5uZXdQYXJlbnRJbmRleCxcbiAgICAgIG9sZFBhcmVudCA9IGNvbm5lY3Rpb24ucGFyZW50O1xuXG4gIC8vIHNhdmUgb2xkIHBhcmVudCBpbiBjb250ZXh0XG4gIGNvbnRleHQub2xkUGFyZW50ID0gb2xkUGFyZW50O1xuICBjb250ZXh0Lm9sZFBhcmVudEluZGV4ID0gY29sbGVjdGlvblJlbW92ZShvbGRQYXJlbnQuY2hpbGRyZW4sIGNvbm5lY3Rpb24pO1xuXG4gIC8vIGFkZCB0byBuZXcgcGFyZW50IGF0IHBvc2l0aW9uXG4gIGNvbGxlY3Rpb25BZGQobmV3UGFyZW50LmNoaWxkcmVuLCBjb25uZWN0aW9uLCBuZXdQYXJlbnRJbmRleCk7XG5cbiAgLy8gdXBkYXRlIHBhcmVudFxuICBjb25uZWN0aW9uLnBhcmVudCA9IG5ld1BhcmVudDtcblxuICAvLyB1cGRhdGUgd2F5cG9pbnQgcG9zaXRpb25zXG4gIGZvckVhY2goY29ubmVjdGlvbi53YXlwb2ludHMsIGZ1bmN0aW9uKHApIHtcbiAgICBwLnggKz0gZGVsdGEueDtcbiAgICBwLnkgKz0gZGVsdGEueTtcblxuICAgIGlmIChwLm9yaWdpbmFsKSB7XG4gICAgICBwLm9yaWdpbmFsLnggKz0gZGVsdGEueDtcbiAgICAgIHAub3JpZ2luYWwueSArPSBkZWx0YS55O1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG5Nb3ZlQ29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgIG5ld1BhcmVudCA9IGNvbm5lY3Rpb24ucGFyZW50LFxuICAgICAgb2xkUGFyZW50ID0gY29udGV4dC5vbGRQYXJlbnQsXG4gICAgICBvbGRQYXJlbnRJbmRleCA9IGNvbnRleHQub2xkUGFyZW50SW5kZXgsXG4gICAgICBkZWx0YSA9IGNvbnRleHQuZGVsdGE7XG5cbiAgLy8gcmVtb3ZlIGZyb20gbmV3UGFyZW50XG4gIGNvbGxlY3Rpb25SZW1vdmUobmV3UGFyZW50LmNoaWxkcmVuLCBjb25uZWN0aW9uKTtcblxuICAvLyByZXN0b3JlIHByZXZpb3VzIGxvY2F0aW9uIGluIG9sZCBwYXJlbnRcbiAgY29sbGVjdGlvbkFkZChvbGRQYXJlbnQuY2hpbGRyZW4sIGNvbm5lY3Rpb24sIG9sZFBhcmVudEluZGV4KTtcblxuICAvLyByZXN0b3JlIHBhcmVudFxuICBjb25uZWN0aW9uLnBhcmVudCA9IG9sZFBhcmVudDtcblxuICAvLyByZXZlcnQgdG8gb2xkIHdheXBvaW50IHBvc2l0aW9uc1xuICBmb3JFYWNoKGNvbm5lY3Rpb24ud2F5cG9pbnRzLCBmdW5jdGlvbihwKSB7XG4gICAgcC54IC09IGRlbHRhLng7XG4gICAgcC55IC09IGRlbHRhLnk7XG5cbiAgICBpZiAocC5vcmlnaW5hbCkge1xuICAgICAgcC5vcmlnaW5hbC54IC09IGRlbHRhLng7XG4gICAgICBwLm9yaWdpbmFsLnkgLT0gZGVsdGEueTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb25uZWN0aW9uO1xufTsiLCJpbXBvcnQgTW92ZUhlbHBlciBmcm9tICcuL2hlbHBlci9Nb3ZlSGVscGVyJztcblxuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IGltcGxlbWVudHMgcmV2ZXJzaWJsZSBtb3Zpbmcgb2Ygc2hhcGVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNb3ZlRWxlbWVudHNIYW5kbGVyKG1vZGVsaW5nKSB7XG4gIHRoaXMuX2hlbHBlciA9IG5ldyBNb3ZlSGVscGVyKG1vZGVsaW5nKTtcbn1cblxuTW92ZUVsZW1lbnRzSGFuZGxlci4kaW5qZWN0ID0gWyAnbW9kZWxpbmcnIF07XG5cbk1vdmVFbGVtZW50c0hhbmRsZXIucHJvdG90eXBlLnByZUV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnRleHQuY2xvc3VyZSA9IHRoaXMuX2hlbHBlci5nZXRDbG9zdXJlKGNvbnRleHQuc2hhcGVzKTtcbn07XG5cbk1vdmVFbGVtZW50c0hhbmRsZXIucHJvdG90eXBlLnBvc3RFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBoaW50cyA9IGNvbnRleHQuaGludHMsXG4gICAgICBwcmltYXJ5U2hhcGU7XG5cbiAgaWYgKGhpbnRzICYmIGhpbnRzLnByaW1hcnlTaGFwZSkge1xuICAgIHByaW1hcnlTaGFwZSA9IGhpbnRzLnByaW1hcnlTaGFwZTtcbiAgICBoaW50cy5vbGRQYXJlbnQgPSBwcmltYXJ5U2hhcGUucGFyZW50O1xuICB9XG5cbiAgdGhpcy5faGVscGVyLm1vdmVDbG9zdXJlKFxuICAgIGNvbnRleHQuY2xvc3VyZSxcbiAgICBjb250ZXh0LmRlbHRhLFxuICAgIGNvbnRleHQubmV3UGFyZW50LFxuICAgIGNvbnRleHQubmV3SG9zdCxcbiAgICBwcmltYXJ5U2hhcGVcbiAgKTtcbn07IiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmb3JFYWNoLFxuICBwaWNrXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IE1vdmVIZWxwZXIgZnJvbSAnLi9oZWxwZXIvTW92ZUhlbHBlcic7XG5cbmltcG9ydCB7XG4gIGFkZCBhcyBjb2xsZWN0aW9uQWRkLFxuICByZW1vdmUgYXMgY29sbGVjdGlvblJlbW92ZVxufSBmcm9tICcuLi8uLi8uLi91dGlsL0NvbGxlY3Rpb25zJztcblxuaW1wb3J0IHtcbiAgZ2V0TW92ZWRTb3VyY2VBbmNob3IsXG4gIGdldE1vdmVkVGFyZ2V0QW5jaG9yXG59IGZyb20gJy4vaGVscGVyL0FuY2hvcnNIZWxwZXInO1xuXG5cbi8qKlxuICogQSBoYW5kbGVyIHRoYXQgaW1wbGVtZW50cyByZXZlcnNpYmxlIG1vdmluZyBvZiBzaGFwZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1vdmVTaGFwZUhhbmRsZXIobW9kZWxpbmcpIHtcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcblxuICB0aGlzLl9oZWxwZXIgPSBuZXcgTW92ZUhlbHBlcihtb2RlbGluZyk7XG59XG5cbk1vdmVTaGFwZUhhbmRsZXIuJGluamVjdCA9IFsgJ21vZGVsaW5nJyBdO1xuXG5cbk1vdmVTaGFwZUhhbmRsZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgIGRlbHRhID0gY29udGV4dC5kZWx0YSxcbiAgICAgIG5ld1BhcmVudCA9IGNvbnRleHQubmV3UGFyZW50IHx8IHNoYXBlLnBhcmVudCxcbiAgICAgIG5ld1BhcmVudEluZGV4ID0gY29udGV4dC5uZXdQYXJlbnRJbmRleCxcbiAgICAgIG9sZFBhcmVudCA9IHNoYXBlLnBhcmVudDtcblxuICBjb250ZXh0Lm9sZEJvdW5kcyA9IHBpY2soc2hhcGUsIFsgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXSk7XG5cbiAgLy8gc2F2ZSBvbGQgcGFyZW50IGluIGNvbnRleHRcbiAgY29udGV4dC5vbGRQYXJlbnQgPSBvbGRQYXJlbnQ7XG4gIGNvbnRleHQub2xkUGFyZW50SW5kZXggPSBjb2xsZWN0aW9uUmVtb3ZlKG9sZFBhcmVudC5jaGlsZHJlbiwgc2hhcGUpO1xuXG4gIC8vIGFkZCB0byBuZXcgcGFyZW50IGF0IHBvc2l0aW9uXG4gIGNvbGxlY3Rpb25BZGQobmV3UGFyZW50LmNoaWxkcmVuLCBzaGFwZSwgbmV3UGFyZW50SW5kZXgpO1xuXG4gIC8vIHVwZGF0ZSBzaGFwZSBwYXJlbnQgKyBwb3NpdGlvblxuICBhc3NpZ24oc2hhcGUsIHtcbiAgICBwYXJlbnQ6IG5ld1BhcmVudCxcbiAgICB4OiBzaGFwZS54ICsgZGVsdGEueCxcbiAgICB5OiBzaGFwZS55ICsgZGVsdGEueVxuICB9KTtcblxuICByZXR1cm4gc2hhcGU7XG59O1xuXG5Nb3ZlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5wb3N0RXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgZGVsdGEgPSBjb250ZXh0LmRlbHRhLFxuICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzO1xuXG4gIHZhciBtb2RlbGluZyA9IHRoaXMuX21vZGVsaW5nO1xuXG4gIGlmIChoaW50cy5sYXlvdXQgIT09IGZhbHNlKSB7XG5cbiAgICBmb3JFYWNoKHNoYXBlLmluY29taW5nLCBmdW5jdGlvbihjKSB7XG4gICAgICBtb2RlbGluZy5sYXlvdXRDb25uZWN0aW9uKGMsIHtcbiAgICAgICAgY29ubmVjdGlvbkVuZDogZ2V0TW92ZWRUYXJnZXRBbmNob3IoYywgc2hhcGUsIGRlbHRhKVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmb3JFYWNoKHNoYXBlLm91dGdvaW5nLCBmdW5jdGlvbihjKSB7XG4gICAgICBtb2RlbGluZy5sYXlvdXRDb25uZWN0aW9uKGMsIHtcbiAgICAgICAgY29ubmVjdGlvblN0YXJ0OiBnZXRNb3ZlZFNvdXJjZUFuY2hvcihjLCBzaGFwZSwgZGVsdGEpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChoaW50cy5yZWN1cnNlICE9PSBmYWxzZSkge1xuICAgIHRoaXMubW92ZUNoaWxkcmVuKGNvbnRleHQpO1xuICB9XG59O1xuXG5Nb3ZlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgIG9sZFBhcmVudCA9IGNvbnRleHQub2xkUGFyZW50LFxuICAgICAgb2xkUGFyZW50SW5kZXggPSBjb250ZXh0Lm9sZFBhcmVudEluZGV4LFxuICAgICAgZGVsdGEgPSBjb250ZXh0LmRlbHRhO1xuXG4gIC8vIHJlc3RvcmUgcHJldmlvdXMgbG9jYXRpb24gaW4gb2xkIHBhcmVudFxuICBjb2xsZWN0aW9uQWRkKG9sZFBhcmVudC5jaGlsZHJlbiwgc2hhcGUsIG9sZFBhcmVudEluZGV4KTtcblxuICAvLyByZXZlcnQgdG8gb2xkIHBvc2l0aW9uIGFuZCBwYXJlbnRcbiAgYXNzaWduKHNoYXBlLCB7XG4gICAgcGFyZW50OiBvbGRQYXJlbnQsXG4gICAgeDogc2hhcGUueCAtIGRlbHRhLngsXG4gICAgeTogc2hhcGUueSAtIGRlbHRhLnlcbiAgfSk7XG5cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuTW92ZVNoYXBlSGFuZGxlci5wcm90b3R5cGUubW92ZUNoaWxkcmVuID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBkZWx0YSA9IGNvbnRleHQuZGVsdGEsXG4gICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGU7XG5cbiAgdGhpcy5faGVscGVyLm1vdmVSZWN1cnNpdmUoc2hhcGUuY2hpbGRyZW4sIGRlbHRhLCBudWxsKTtcbn07XG5cbk1vdmVTaGFwZUhhbmRsZXIucHJvdG90eXBlLmdldE5ld1BhcmVudCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIGNvbnRleHQubmV3UGFyZW50IHx8IGNvbnRleHQuc2hhcGUucGFyZW50O1xufTtcbiIsImltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdtaW4tZGFzaCc7XG5cblxuLyoqXG4gKiBSZWNvbm5lY3QgY29ubmVjdGlvbiBoYW5kbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJlY29ubmVjdENvbm5lY3Rpb25IYW5kbGVyKG1vZGVsaW5nKSB7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG59XG5cblJlY29ubmVjdENvbm5lY3Rpb25IYW5kbGVyLiRpbmplY3QgPSBbICdtb2RlbGluZycgXTtcblxuUmVjb25uZWN0Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBuZXdTb3VyY2UgPSBjb250ZXh0Lm5ld1NvdXJjZSxcbiAgICAgIG5ld1RhcmdldCA9IGNvbnRleHQubmV3VGFyZ2V0LFxuICAgICAgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgIGRvY2tpbmdPclBvaW50cyA9IGNvbnRleHQuZG9ja2luZ09yUG9pbnRzO1xuXG4gIGlmICghbmV3U291cmNlICYmICFuZXdUYXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25ld1NvdXJjZSBvciBuZXdUYXJnZXQgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGRvY2tpbmdPclBvaW50cykpIHtcbiAgICBjb250ZXh0Lm9sZFdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzO1xuICAgIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gZG9ja2luZ09yUG9pbnRzO1xuICB9XG5cbiAgaWYgKG5ld1NvdXJjZSkge1xuICAgIGNvbnRleHQub2xkU291cmNlID0gY29ubmVjdGlvbi5zb3VyY2U7XG4gICAgY29ubmVjdGlvbi5zb3VyY2UgPSBuZXdTb3VyY2U7XG4gIH1cblxuICBpZiAobmV3VGFyZ2V0KSB7XG4gICAgY29udGV4dC5vbGRUYXJnZXQgPSBjb25uZWN0aW9uLnRhcmdldDtcbiAgICBjb25uZWN0aW9uLnRhcmdldCA9IG5ld1RhcmdldDtcbiAgfVxuXG4gIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuUmVjb25uZWN0Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnBvc3RFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgIG5ld1NvdXJjZSA9IGNvbnRleHQubmV3U291cmNlLFxuICAgICAgbmV3VGFyZ2V0ID0gY29udGV4dC5uZXdUYXJnZXQsXG4gICAgICBkb2NraW5nT3JQb2ludHMgPSBjb250ZXh0LmRvY2tpbmdPclBvaW50cyxcbiAgICAgIGhpbnRzID0gY29udGV4dC5oaW50cyB8fCB7fTtcblxuICB2YXIgbGF5b3V0Q29ubmVjdGlvbkhpbnRzID0ge307XG5cbiAgaWYgKGhpbnRzLmNvbm5lY3Rpb25TdGFydCkge1xuICAgIGxheW91dENvbm5lY3Rpb25IaW50cy5jb25uZWN0aW9uU3RhcnQgPSBoaW50cy5jb25uZWN0aW9uU3RhcnQ7XG4gIH1cblxuICBpZiAoaGludHMuY29ubmVjdGlvbkVuZCkge1xuICAgIGxheW91dENvbm5lY3Rpb25IaW50cy5jb25uZWN0aW9uRW5kID0gaGludHMuY29ubmVjdGlvbkVuZDtcbiAgfVxuXG4gIGlmIChoaW50cy5sYXlvdXRDb25uZWN0aW9uID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChuZXdTb3VyY2UgJiYgKCFuZXdUYXJnZXQgfHwgaGludHMuZG9ja2luZyA9PT0gJ3NvdXJjZScpKSB7XG4gICAgbGF5b3V0Q29ubmVjdGlvbkhpbnRzLmNvbm5lY3Rpb25TdGFydCA9IGxheW91dENvbm5lY3Rpb25IaW50cy5jb25uZWN0aW9uU3RhcnRcbiAgICAgIHx8IGdldERvY2tpbmcoaXNBcnJheShkb2NraW5nT3JQb2ludHMpID8gZG9ja2luZ09yUG9pbnRzWyAwIF0gOiBkb2NraW5nT3JQb2ludHMpO1xuICB9XG5cbiAgaWYgKG5ld1RhcmdldCAmJiAoIW5ld1NvdXJjZSB8fCBoaW50cy5kb2NraW5nID09PSAndGFyZ2V0JykpIHtcbiAgICBsYXlvdXRDb25uZWN0aW9uSGludHMuY29ubmVjdGlvbkVuZCA9IGxheW91dENvbm5lY3Rpb25IaW50cy5jb25uZWN0aW9uRW5kXG4gICAgICB8fCBnZXREb2NraW5nKGlzQXJyYXkoZG9ja2luZ09yUG9pbnRzKSA/IGRvY2tpbmdPclBvaW50c1sgZG9ja2luZ09yUG9pbnRzLmxlbmd0aCAtIDEgXSA6IGRvY2tpbmdPclBvaW50cyk7XG4gIH1cblxuICBpZiAoaGludHMubmV3V2F5cG9pbnRzKSB7XG4gICAgbGF5b3V0Q29ubmVjdGlvbkhpbnRzLndheXBvaW50cyA9IGhpbnRzLm5ld1dheXBvaW50cztcbiAgfVxuXG4gIHRoaXMuX21vZGVsaW5nLmxheW91dENvbm5lY3Rpb24oY29ubmVjdGlvbiwgbGF5b3V0Q29ubmVjdGlvbkhpbnRzKTtcbn07XG5cblJlY29ubmVjdENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBvbGRTb3VyY2UgPSBjb250ZXh0Lm9sZFNvdXJjZSxcbiAgICAgIG9sZFRhcmdldCA9IGNvbnRleHQub2xkVGFyZ2V0LFxuICAgICAgb2xkV2F5cG9pbnRzID0gY29udGV4dC5vbGRXYXlwb2ludHMsXG4gICAgICBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uO1xuXG4gIGlmIChvbGRTb3VyY2UpIHtcbiAgICBjb25uZWN0aW9uLnNvdXJjZSA9IG9sZFNvdXJjZTtcbiAgfVxuXG4gIGlmIChvbGRUYXJnZXQpIHtcbiAgICBjb25uZWN0aW9uLnRhcmdldCA9IG9sZFRhcmdldDtcbiAgfVxuXG4gIGlmIChvbGRXYXlwb2ludHMpIHtcbiAgICBjb25uZWN0aW9uLndheXBvaW50cyA9IG9sZFdheXBvaW50cztcbiAgfVxuXG4gIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBnZXREb2NraW5nKHBvaW50KSB7XG4gIHJldHVybiBwb2ludC5vcmlnaW5hbCB8fCBwb2ludDtcbn0iLCJpbXBvcnQgeyBmb3JFYWNoIH0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRSZXNpemVkU291cmNlQW5jaG9yLFxuICBnZXRSZXNpemVkVGFyZ2V0QW5jaG9yXG59IGZyb20gJy4vaGVscGVyL0FuY2hvcnNIZWxwZXInO1xuXG4vKipcbiAqIFJlcGxhY2Ugc2hhcGUgYnkgYWRkaW5nIG5ldyBzaGFwZSBhbmQgcmVtb3Zpbmcgb2xkIHNoYXBlLiBJbmNvbWluZyBhbmQgb3V0Z29pbmcgY29ubmVjdGlvbnMgd2lsbFxuICogYmUga2VwdCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKiBAcGFyYW0ge1J1bGVzfSBydWxlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZXBsYWNlU2hhcGVIYW5kbGVyKG1vZGVsaW5nLCBydWxlcykge1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuICB0aGlzLl9ydWxlcyA9IHJ1bGVzO1xufVxuXG5SZXBsYWNlU2hhcGVIYW5kbGVyLiRpbmplY3QgPSBbICdtb2RlbGluZycsICdydWxlcycgXTtcblxuXG4vKipcbiAqIEFkZCBuZXcgc2hhcGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLlNoYXBlfSBjb250ZXh0Lm9sZFNoYXBlXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dC5uZXdEYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dC5uZXdEYXRhLnR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZXh0Lm5ld0RhdGEueFxuICogQHBhcmFtIHtudW1iZXJ9IGNvbnRleHQubmV3RGF0YS55XG4gKiBAcGFyYW0ge09iamVjdH0gW2hpbnRzXVxuICovXG5SZXBsYWNlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5wcmVFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBtb2RlbGluZyA9IHRoaXMuX21vZGVsaW5nLFxuICAgICAgcnVsZXMgPSB0aGlzLl9ydWxlcztcblxuICB2YXIgb2xkU2hhcGUgPSBjb250ZXh0Lm9sZFNoYXBlLFxuICAgICAgbmV3RGF0YSA9IGNvbnRleHQubmV3RGF0YSxcbiAgICAgIGhpbnRzID0gY29udGV4dC5oaW50cyB8fCB7fSxcbiAgICAgIG5ld1NoYXBlO1xuXG4gIGZ1bmN0aW9uIGNhblJlY29ubmVjdChzb3VyY2UsIHRhcmdldCwgY29ubmVjdGlvbikge1xuICAgIHJldHVybiBydWxlcy5hbGxvd2VkKCdjb25uZWN0aW9uLnJlY29ubmVjdCcsIHtcbiAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgfSk7XG4gIH1cblxuICAvLyAoMSkgYWRkIG5ldyBzaGFwZSBhdCBnaXZlbiBwb3NpdGlvblxuICB2YXIgcG9zaXRpb24gPSB7XG4gICAgeDogbmV3RGF0YS54LFxuICAgIHk6IG5ld0RhdGEueVxuICB9O1xuXG4gIHZhciBvbGRCb3VuZHMgPSB7XG4gICAgeDogb2xkU2hhcGUueCxcbiAgICB5OiBvbGRTaGFwZS55LFxuICAgIHdpZHRoOiBvbGRTaGFwZS53aWR0aCxcbiAgICBoZWlnaHQ6IG9sZFNoYXBlLmhlaWdodFxuICB9O1xuXG4gIG5ld1NoYXBlID0gY29udGV4dC5uZXdTaGFwZSA9XG4gICAgY29udGV4dC5uZXdTaGFwZSB8fFxuICAgIHNlbGYuY3JlYXRlU2hhcGUobmV3RGF0YSwgcG9zaXRpb24sIG9sZFNoYXBlLnBhcmVudCwgaGludHMpO1xuXG4gIC8vICgyKSB1cGRhdGUgaG9zdFxuICBpZiAob2xkU2hhcGUuaG9zdCkge1xuICAgIG1vZGVsaW5nLnVwZGF0ZUF0dGFjaG1lbnQobmV3U2hhcGUsIG9sZFNoYXBlLmhvc3QpO1xuICB9XG5cbiAgLy8gKDMpIGFkb3B0IGFsbCBjaGlsZHJlbiBmcm9tIG9sZCBzaGFwZVxuICB2YXIgY2hpbGRyZW47XG5cbiAgaWYgKGhpbnRzLm1vdmVDaGlsZHJlbiAhPT0gZmFsc2UpIHtcbiAgICBjaGlsZHJlbiA9IG9sZFNoYXBlLmNoaWxkcmVuLnNsaWNlKCk7XG5cbiAgICBtb2RlbGluZy5tb3ZlRWxlbWVudHMoY2hpbGRyZW4sIHsgeDogMCwgeTogMCB9LCBuZXdTaGFwZSwgaGludHMpO1xuICB9XG5cbiAgLy8gKDQpIHJlY29ubmVjdCBjb25uZWN0aW9ucyB0byBuZXcgc2hhcGUgaWYgcG9zc2libGVcbiAgdmFyIGluY29taW5nID0gb2xkU2hhcGUuaW5jb21pbmcuc2xpY2UoKSxcbiAgICAgIG91dGdvaW5nID0gb2xkU2hhcGUub3V0Z29pbmcuc2xpY2UoKTtcblxuICBmb3JFYWNoKGluY29taW5nLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgdmFyIHNvdXJjZSA9IGNvbm5lY3Rpb24uc291cmNlLFxuICAgICAgICBhbGxvd2VkID0gY2FuUmVjb25uZWN0KHNvdXJjZSwgbmV3U2hhcGUsIGNvbm5lY3Rpb24pO1xuXG4gICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgIHNlbGYucmVjb25uZWN0RW5kKFxuICAgICAgICBjb25uZWN0aW9uLCBuZXdTaGFwZSxcbiAgICAgICAgZ2V0UmVzaXplZFRhcmdldEFuY2hvcihjb25uZWN0aW9uLCBuZXdTaGFwZSwgb2xkQm91bmRzKSxcbiAgICAgICAgaGludHNcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICBmb3JFYWNoKG91dGdvaW5nLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgdmFyIHRhcmdldCA9IGNvbm5lY3Rpb24udGFyZ2V0LFxuICAgICAgICBhbGxvd2VkID0gY2FuUmVjb25uZWN0KG5ld1NoYXBlLCB0YXJnZXQsIGNvbm5lY3Rpb24pO1xuXG4gICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgIHNlbGYucmVjb25uZWN0U3RhcnQoXG4gICAgICAgIGNvbm5lY3Rpb24sIG5ld1NoYXBlLFxuICAgICAgICBnZXRSZXNpemVkU291cmNlQW5jaG9yKGNvbm5lY3Rpb24sIG5ld1NoYXBlLCBvbGRCb3VuZHMpLFxuICAgICAgICBoaW50c1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBvbGQgc2hhcGUuXG4gKi9cblJlcGxhY2VTaGFwZUhhbmRsZXIucHJvdG90eXBlLnBvc3RFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgb2xkU2hhcGUgPSBjb250ZXh0Lm9sZFNoYXBlO1xuXG4gIHRoaXMuX21vZGVsaW5nLnJlbW92ZVNoYXBlKG9sZFNoYXBlKTtcbn07XG5cblxuUmVwbGFjZVNoYXBlSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHt9O1xuXG5cblJlcGxhY2VTaGFwZUhhbmRsZXIucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHt9O1xuXG5cblJlcGxhY2VTaGFwZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIHBvc2l0aW9uLCB0YXJnZXQsIGhpbnRzKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlbGluZy5jcmVhdGVTaGFwZShzaGFwZSwgcG9zaXRpb24sIHRhcmdldCwgaGludHMpO1xufTtcblxuXG5SZXBsYWNlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5yZWNvbm5lY3RTdGFydCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIG5ld1NvdXJjZSwgZG9ja2luZ1BvaW50LCBoaW50cykge1xuICB0aGlzLl9tb2RlbGluZy5yZWNvbm5lY3RTdGFydChjb25uZWN0aW9uLCBuZXdTb3VyY2UsIGRvY2tpbmdQb2ludCwgaGludHMpO1xufTtcblxuXG5SZXBsYWNlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5yZWNvbm5lY3RFbmQgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBuZXdUYXJnZXQsIGRvY2tpbmdQb2ludCwgaGludHMpIHtcbiAgdGhpcy5fbW9kZWxpbmcucmVjb25uZWN0RW5kKGNvbm5lY3Rpb24sIG5ld1RhcmdldCwgZG9ja2luZ1BvaW50LCBoaW50cyk7XG59O1xuIiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmb3JFYWNoXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZ2V0UmVzaXplZFNvdXJjZUFuY2hvcixcbiAgZ2V0UmVzaXplZFRhcmdldEFuY2hvclxufSBmcm9tICcuL2hlbHBlci9BbmNob3JzSGVscGVyJztcblxuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IGltcGxlbWVudHMgcmV2ZXJzaWJsZSByZXNpemluZyBvZiBzaGFwZXMuXG4gKlxuICogQHBhcmFtIHtNb2RlbGluZ30gbW9kZWxpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmVzaXplU2hhcGVIYW5kbGVyKG1vZGVsaW5nKSB7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG59XG5cblJlc2l6ZVNoYXBlSGFuZGxlci4kaW5qZWN0ID0gWyAnbW9kZWxpbmcnIF07XG5cbi8qKlxuICoge1xuICogICBzaGFwZTogey4uLi59XG4gKiAgIG5ld0JvdW5kczoge1xuICogICAgIHdpZHRoOiAgMjAsXG4gKiAgICAgaGVpZ2h0OiA0MCxcbiAqICAgICB4OiAgICAgICA1LFxuICogICAgIHk6ICAgICAgMTBcbiAqICAgfVxuICpcbiAqIH1cbiAqL1xuUmVzaXplU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgbmV3Qm91bmRzID0gY29udGV4dC5uZXdCb3VuZHMsXG4gICAgICBtaW5Cb3VuZHMgPSBjb250ZXh0Lm1pbkJvdW5kcztcblxuICBpZiAobmV3Qm91bmRzLnggPT09IHVuZGVmaW5lZCB8fCBuZXdCb3VuZHMueSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBuZXdCb3VuZHMud2lkdGggPT09IHVuZGVmaW5lZCB8fCBuZXdCb3VuZHMuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25ld0JvdW5kcyBtdXN0IGhhdmUge3gsIHksIHdpZHRoLCBoZWlnaHR9IHByb3BlcnRpZXMnKTtcbiAgfVxuXG4gIGlmIChtaW5Cb3VuZHMgJiYgKG5ld0JvdW5kcy53aWR0aCA8IG1pbkJvdW5kcy53aWR0aFxuICAgIHx8IG5ld0JvdW5kcy5oZWlnaHQgPCBtaW5Cb3VuZHMuaGVpZ2h0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignd2lkdGggYW5kIGhlaWdodCBjYW5ub3QgYmUgbGVzcyB0aGFuIG1pbmltdW0gaGVpZ2h0IGFuZCB3aWR0aCcpO1xuICB9IGVsc2UgaWYgKCFtaW5Cb3VuZHNcbiAgICAmJiBuZXdCb3VuZHMud2lkdGggPCAxMCB8fCBuZXdCb3VuZHMuaGVpZ2h0IDwgMTApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpZHRoIGFuZCBoZWlnaHQgY2Fubm90IGJlIGxlc3MgdGhhbiAxMHB4Jyk7XG4gIH1cblxuICAvLyBzYXZlIG9sZCBiYm94IGluIGNvbnRleHRcbiAgY29udGV4dC5vbGRCb3VuZHMgPSB7XG4gICAgd2lkdGg6ICBzaGFwZS53aWR0aCxcbiAgICBoZWlnaHQ6IHNoYXBlLmhlaWdodCxcbiAgICB4OiAgICAgIHNoYXBlLngsXG4gICAgeTogICAgICBzaGFwZS55XG4gIH07XG5cbiAgLy8gdXBkYXRlIHNoYXBlXG4gIGFzc2lnbihzaGFwZSwge1xuICAgIHdpZHRoOiAgbmV3Qm91bmRzLndpZHRoLFxuICAgIGhlaWdodDogbmV3Qm91bmRzLmhlaWdodCxcbiAgICB4OiAgICAgIG5ld0JvdW5kcy54LFxuICAgIHk6ICAgICAgbmV3Qm91bmRzLnlcbiAgfSk7XG5cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuUmVzaXplU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5wb3N0RXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIG1vZGVsaW5nID0gdGhpcy5fbW9kZWxpbmc7XG5cbiAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgIG9sZEJvdW5kcyA9IGNvbnRleHQub2xkQm91bmRzLFxuICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gIGlmIChoaW50cy5sYXlvdXQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaChzaGFwZS5pbmNvbWluZywgZnVuY3Rpb24oYykge1xuICAgIG1vZGVsaW5nLmxheW91dENvbm5lY3Rpb24oYywge1xuICAgICAgY29ubmVjdGlvbkVuZDogZ2V0UmVzaXplZFRhcmdldEFuY2hvcihjLCBzaGFwZSwgb2xkQm91bmRzKVxuICAgIH0pO1xuICB9KTtcblxuICBmb3JFYWNoKHNoYXBlLm91dGdvaW5nLCBmdW5jdGlvbihjKSB7XG4gICAgbW9kZWxpbmcubGF5b3V0Q29ubmVjdGlvbihjLCB7XG4gICAgICBjb25uZWN0aW9uU3RhcnQ6IGdldFJlc2l6ZWRTb3VyY2VBbmNob3IoYywgc2hhcGUsIG9sZEJvdW5kcylcbiAgICB9KTtcbiAgfSk7XG5cbn07XG5cblJlc2l6ZVNoYXBlSGFuZGxlci5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICBvbGRCb3VuZHMgPSBjb250ZXh0Lm9sZEJvdW5kcztcblxuICAvLyByZXN0b3JlIHByZXZpb3VzIGJib3hcbiAgYXNzaWduKHNoYXBlLCB7XG4gICAgd2lkdGg6ICBvbGRCb3VuZHMud2lkdGgsXG4gICAgaGVpZ2h0OiBvbGRCb3VuZHMuaGVpZ2h0LFxuICAgIHg6ICAgICAgb2xkQm91bmRzLngsXG4gICAgeTogICAgICBvbGRCb3VuZHMueVxuICB9KTtcblxuICByZXR1cm4gc2hhcGU7XG59O1xuIiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmb3JFYWNoLFxuICBtYXBcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRXYXlwb2ludHNVcGRhdGluZ0Nvbm5lY3Rpb25zLFxuICByZXNpemVCb3VuZHNcbn0gZnJvbSAnLi4vLi4vc3BhY2UtdG9vbC9TcGFjZVV0aWwnO1xuXG5pbXBvcnQge1xuICBnZXRNb3ZlZFNvdXJjZUFuY2hvcixcbiAgZ2V0TW92ZWRUYXJnZXRBbmNob3IsXG4gIGdldFJlc2l6ZWRTb3VyY2VBbmNob3IsXG4gIGdldFJlc2l6ZWRUYXJnZXRBbmNob3Jcbn0gZnJvbSAnLi9oZWxwZXIvQW5jaG9yc0hlbHBlcic7XG5cblxuLyoqXG4gKiBBZGQgb3IgcmVtb3ZlIHNwYWNlIGJ5IG1vdmluZyBhbmQgcmVzaXppbmcgc2hhcGVzIGFuZCB1cGRhdGluZyBjb25uZWN0aW9uIHdheXBvaW50cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3BhY2VUb29sSGFuZGxlcihtb2RlbGluZykge1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xufVxuXG5TcGFjZVRvb2xIYW5kbGVyLiRpbmplY3QgPSBbICdtb2RlbGluZycgXTtcblxuU3BhY2VUb29sSGFuZGxlci5wcm90b3R5cGUucHJlRXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIGRlbHRhID0gY29udGV4dC5kZWx0YSxcbiAgICAgIGRpcmVjdGlvbiA9IGNvbnRleHQuZGlyZWN0aW9uLFxuICAgICAgbW92aW5nU2hhcGVzID0gY29udGV4dC5tb3ZpbmdTaGFwZXMsXG4gICAgICByZXNpemluZ1NoYXBlcyA9IGNvbnRleHQucmVzaXppbmdTaGFwZXMsXG4gICAgICBzdGFydCA9IGNvbnRleHQuc3RhcnQsXG4gICAgICBvbGRCb3VuZHMgPSB7fTtcblxuICAvLyAoMSkgbW92ZSBzaGFwZXNcbiAgdGhpcy5tb3ZlU2hhcGVzKG1vdmluZ1NoYXBlcywgZGVsdGEpO1xuXG4gIC8vICgyYSkgc2F2ZSBvbGQgYm91bmRzIG9mIHJlc2l6ZWQgc2hhcGVzXG4gIGZvckVhY2gocmVzaXppbmdTaGFwZXMsIGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgb2xkQm91bmRzW3NoYXBlLmlkXSA9IGdldEJvdW5kcyhzaGFwZSk7XG4gIH0pO1xuXG4gIC8vICgyYikgcmVzaXplIHNoYXBlc1xuICB0aGlzLnJlc2l6ZVNoYXBlcyhyZXNpemluZ1NoYXBlcywgZGVsdGEsIGRpcmVjdGlvbik7XG5cbiAgLy8gKDMpIHVwZGF0ZSBjb25uZWN0aW9uIHdheXBvaW50c1xuICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25XYXlwb2ludHMoXG4gICAgZ2V0V2F5cG9pbnRzVXBkYXRpbmdDb25uZWN0aW9ucyhtb3ZpbmdTaGFwZXMsIHJlc2l6aW5nU2hhcGVzKSxcbiAgICBkZWx0YSxcbiAgICBkaXJlY3Rpb24sXG4gICAgc3RhcnQsXG4gICAgbW92aW5nU2hhcGVzLFxuICAgIHJlc2l6aW5nU2hhcGVzLFxuICAgIG9sZEJvdW5kc1xuICApO1xufTtcblxuU3BhY2VUb29sSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKCkge307XG5TcGFjZVRvb2xIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbigpIHt9O1xuXG5TcGFjZVRvb2xIYW5kbGVyLnByb3RvdHlwZS5tb3ZlU2hhcGVzID0gZnVuY3Rpb24oc2hhcGVzLCBkZWx0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZm9yRWFjaChzaGFwZXMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBzZWxmLl9tb2RlbGluZy5tb3ZlU2hhcGUoZWxlbWVudCwgZGVsdGEsIG51bGwsIHtcbiAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxuICAgICAgbGF5b3V0OiBmYWxzZSxcbiAgICAgIHJlY3Vyc2U6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xufTtcblxuU3BhY2VUb29sSGFuZGxlci5wcm90b3R5cGUucmVzaXplU2hhcGVzID0gZnVuY3Rpb24oc2hhcGVzLCBkZWx0YSwgZGlyZWN0aW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3JFYWNoKHNoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcbiAgICB2YXIgbmV3Qm91bmRzID0gcmVzaXplQm91bmRzKHNoYXBlLCBkaXJlY3Rpb24sIGRlbHRhKTtcblxuICAgIHNlbGYuX21vZGVsaW5nLnJlc2l6ZVNoYXBlKHNoYXBlLCBuZXdCb3VuZHMsIG51bGwsIHtcbiAgICAgIGF0dGFjaFN1cHBvcnQ6IGZhbHNlLFxuICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXG4gICAgICBsYXlvdXQ6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgY29ubmVjdGlvbnMgd2F5cG9pbnRzIGFjY29yZGluZyB0byB0aGUgcnVsZXM6XG4gKiAgIDEuIEJvdGggc291cmNlIGFuZCB0YXJnZXQgYXJlIG1vdmVkL3Jlc2l6ZWQgPT4gbW92ZSB3YXlwb2ludHMgYnkgdGhlIGRlbHRhXG4gKiAgIDIuIE9ubHkgb25lIG9mIHNvdXJjZSBhbmQgdGFyZ2V0IGlzIG1vdmVkL3Jlc2l6ZWQgPT4gcmUtbGF5b3V0IGNvbm5lY3Rpb24gd2l0aCBtb3ZlZCBzdGFydC9lbmRcbiAqL1xuU3BhY2VUb29sSGFuZGxlci5wcm90b3R5cGUudXBkYXRlQ29ubmVjdGlvbldheXBvaW50cyA9IGZ1bmN0aW9uKFxuICAgIGNvbm5lY3Rpb25zLFxuICAgIGRlbHRhLFxuICAgIGRpcmVjdGlvbixcbiAgICBzdGFydCxcbiAgICBtb3ZpbmdTaGFwZXMsXG4gICAgcmVzaXppbmdTaGFwZXMsXG4gICAgb2xkQm91bmRzXG4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgYWZmZWN0ZWRTaGFwZXMgPSBtb3ZpbmdTaGFwZXMuY29uY2F0KHJlc2l6aW5nU2hhcGVzKTtcblxuICBmb3JFYWNoKGNvbm5lY3Rpb25zLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgdmFyIHNvdXJjZSA9IGNvbm5lY3Rpb24uc291cmNlLFxuICAgICAgICB0YXJnZXQgPSBjb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgd2F5cG9pbnRzID0gY29weVdheXBvaW50cyhjb25uZWN0aW9uKSxcbiAgICAgICAgYXhpcyA9IGdldEF4aXNGcm9tRGlyZWN0aW9uKGRpcmVjdGlvbiksXG4gICAgICAgIGxheW91dEhpbnRzID0ge1xuICAgICAgICAgIGxhYmVsQmVoYXZpb3I6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICBpZiAoaW5jbHVkZXMoYWZmZWN0ZWRTaGFwZXMsIHNvdXJjZSkgJiYgaW5jbHVkZXMoYWZmZWN0ZWRTaGFwZXMsIHRhcmdldCkpIHtcblxuICAgICAgLy8gbW92ZSB3YXlwb2ludHNcbiAgICAgIHdheXBvaW50cyA9IG1hcCh3YXlwb2ludHMsIGZ1bmN0aW9uKHdheXBvaW50KSB7XG4gICAgICAgIGlmIChzaG91bGRNb3ZlV2F5cG9pbnQod2F5cG9pbnQsIHN0YXJ0LCBkaXJlY3Rpb24pKSB7XG5cbiAgICAgICAgICAvLyBtb3ZlIHdheXBvaW50XG4gICAgICAgICAgd2F5cG9pbnRbIGF4aXMgXSA9IHdheXBvaW50WyBheGlzIF0gKyBkZWx0YVsgYXhpcyBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdheXBvaW50Lm9yaWdpbmFsICYmIHNob3VsZE1vdmVXYXlwb2ludCh3YXlwb2ludC5vcmlnaW5hbCwgc3RhcnQsIGRpcmVjdGlvbikpIHtcblxuICAgICAgICAgIC8vIG1vdmUgd2F5cG9pbnQgb3JpZ2luYWxcbiAgICAgICAgICB3YXlwb2ludC5vcmlnaW5hbFsgYXhpcyBdID0gd2F5cG9pbnQub3JpZ2luYWxbIGF4aXMgXSArIGRlbHRhWyBheGlzIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd2F5cG9pbnQ7XG4gICAgICB9KTtcblxuICAgICAgc2VsZi5fbW9kZWxpbmcudXBkYXRlV2F5cG9pbnRzKGNvbm5lY3Rpb24sIHdheXBvaW50cywge1xuICAgICAgICBsYWJlbEJlaGF2aW9yOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpbmNsdWRlcyhhZmZlY3RlZFNoYXBlcywgc291cmNlKSB8fCBpbmNsdWRlcyhhZmZlY3RlZFNoYXBlcywgdGFyZ2V0KSkge1xuXG4gICAgICAvLyByZS1sYXlvdXQgY29ubmVjdGlvbiB3aXRoIG1vdmVkIHN0YXJ0L2VuZFxuICAgICAgaWYgKGluY2x1ZGVzKG1vdmluZ1NoYXBlcywgc291cmNlKSkge1xuICAgICAgICBsYXlvdXRIaW50cy5jb25uZWN0aW9uU3RhcnQgPSBnZXRNb3ZlZFNvdXJjZUFuY2hvcihjb25uZWN0aW9uLCBzb3VyY2UsIGRlbHRhKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZXMobW92aW5nU2hhcGVzLCB0YXJnZXQpKSB7XG4gICAgICAgIGxheW91dEhpbnRzLmNvbm5lY3Rpb25FbmQgPSBnZXRNb3ZlZFRhcmdldEFuY2hvcihjb25uZWN0aW9uLCB0YXJnZXQsIGRlbHRhKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZXMocmVzaXppbmdTaGFwZXMsIHNvdXJjZSkpIHtcbiAgICAgICAgbGF5b3V0SGludHMuY29ubmVjdGlvblN0YXJ0ID0gZ2V0UmVzaXplZFNvdXJjZUFuY2hvcihcbiAgICAgICAgICBjb25uZWN0aW9uLCBzb3VyY2UsIG9sZEJvdW5kc1tzb3VyY2UuaWRdXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVzKHJlc2l6aW5nU2hhcGVzLCB0YXJnZXQpKSB7XG4gICAgICAgIGxheW91dEhpbnRzLmNvbm5lY3Rpb25FbmQgPSBnZXRSZXNpemVkVGFyZ2V0QW5jaG9yKFxuICAgICAgICAgIGNvbm5lY3Rpb24sIHRhcmdldCwgb2xkQm91bmRzW3RhcmdldC5pZF1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fbW9kZWxpbmcubGF5b3V0Q29ubmVjdGlvbihjb25uZWN0aW9uLCBsYXlvdXRIaW50cyk7XG4gICAgfVxuICB9KTtcbn07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGNvcHlXYXlwb2ludCh3YXlwb2ludCkge1xuICByZXR1cm4gYXNzaWduKHt9LCB3YXlwb2ludCk7XG59XG5cbmZ1bmN0aW9uIGNvcHlXYXlwb2ludHMoY29ubmVjdGlvbikge1xuICByZXR1cm4gbWFwKGNvbm5lY3Rpb24ud2F5cG9pbnRzLCBmdW5jdGlvbih3YXlwb2ludCkge1xuXG4gICAgd2F5cG9pbnQgPSBjb3B5V2F5cG9pbnQod2F5cG9pbnQpO1xuXG4gICAgaWYgKHdheXBvaW50Lm9yaWdpbmFsKSB7XG4gICAgICB3YXlwb2ludC5vcmlnaW5hbCA9IGNvcHlXYXlwb2ludCh3YXlwb2ludC5vcmlnaW5hbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdheXBvaW50O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gIGNhc2UgJ24nOlxuICAgIHJldHVybiAneSc7XG4gIGNhc2UgJ3cnOlxuICAgIHJldHVybiAneCc7XG4gIGNhc2UgJ3MnOlxuICAgIHJldHVybiAneSc7XG4gIGNhc2UgJ2UnOlxuICAgIHJldHVybiAneCc7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkTW92ZVdheXBvaW50KHdheXBvaW50LCBzdGFydCwgZGlyZWN0aW9uKSB7XG4gIHZhciByZWxldmFudEF4aXMgPSBnZXRBeGlzRnJvbURpcmVjdGlvbihkaXJlY3Rpb24pO1xuXG4gIGlmICgvZXxzLy50ZXN0KGRpcmVjdGlvbikpIHtcbiAgICByZXR1cm4gd2F5cG9pbnRbIHJlbGV2YW50QXhpcyBdID4gc3RhcnQ7XG4gIH0gZWxzZSBpZiAoL258dy8udGVzdChkaXJlY3Rpb24pKSB7XG4gICAgcmV0dXJuIHdheXBvaW50WyByZWxldmFudEF4aXMgXSA8IHN0YXJ0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzKGFycmF5LCBpdGVtKSB7XG4gIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRzKHNoYXBlKSB7XG4gIHJldHVybiB7XG4gICAgeDogc2hhcGUueCxcbiAgICB5OiBzaGFwZS55LFxuICAgIGhlaWdodDogc2hhcGUuaGVpZ2h0LFxuICAgIHdpZHRoOiBzaGFwZS53aWR0aFxuICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmb3JFYWNoXG59IGZyb20gJ21pbi1kYXNoJztcblxuLyoqXG4gKiBBIGhhbmRsZXIgdGhhdCB0b2dnbGVzIHRoZSBjb2xsYXBzZWQgc3RhdGUgb2YgYW4gZWxlbWVudFxuICogYW5kIHRoZSB2aXNpYmlsaXR5IG9mIGFsbCBpdHMgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtNb2RlbGluZ30gbW9kZWxpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVG9nZ2xlU2hhcGVDb2xsYXBzZUhhbmRsZXIobW9kZWxpbmcpIHtcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbn1cblxuVG9nZ2xlU2hhcGVDb2xsYXBzZUhhbmRsZXIuJGluamVjdCA9IFsgJ21vZGVsaW5nJyBdO1xuXG5cblRvZ2dsZVNoYXBlQ29sbGFwc2VIYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICBjaGlsZHJlbiA9IHNoYXBlLmNoaWxkcmVuO1xuXG4gIC8vIHJlY3Vyc2l2ZWx5IHJlbWVtYmVyIHByZXZpb3VzIHZpc2liaWxpdHkgb2YgY2hpbGRyZW5cbiAgY29udGV4dC5vbGRDaGlsZHJlblZpc2liaWxpdHkgPSBnZXRFbGVtZW50c1Zpc2liaWxpdHlSZWN1cnNpdmUoY2hpbGRyZW4pO1xuXG4gIC8vIHRvZ2dsZSBzdGF0ZVxuICBzaGFwZS5jb2xsYXBzZWQgPSAhc2hhcGUuY29sbGFwc2VkO1xuXG4gIC8vIHJlY3Vyc2l2ZWx5IGhpZGUvc2hvdyBjaGlsZHJlblxuICB2YXIgcmVzdWx0ID0gc2V0SGlkZGVuUmVjdXJzaXZlKGNoaWxkcmVuLCBzaGFwZS5jb2xsYXBzZWQpO1xuXG4gIHJldHVybiBbc2hhcGVdLmNvbmNhdChyZXN1bHQpO1xufTtcblxuXG5Ub2dnbGVTaGFwZUNvbGxhcHNlSGFuZGxlci5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICBvbGRDaGlsZHJlblZpc2liaWxpdHkgPSBjb250ZXh0Lm9sZENoaWxkcmVuVmlzaWJpbGl0eTtcblxuICB2YXIgY2hpbGRyZW4gPSBzaGFwZS5jaGlsZHJlbjtcblxuICAvLyByZWN1cnNpdmVseSBzZXQgb2xkIHZpc2FiaWxpdHkgb2YgY2hpbGRyZW5cbiAgdmFyIHJlc3VsdCA9IHJlc3RvcmVWaXNpYmlsaXR5UmVjdXJzaXZlKGNoaWxkcmVuLCBvbGRDaGlsZHJlblZpc2liaWxpdHkpO1xuXG4gIC8vIHJldG9nZ2xlIHN0YXRlXG4gIHNoYXBlLmNvbGxhcHNlZCA9ICFzaGFwZS5jb2xsYXBzZWQ7XG5cbiAgcmV0dXJuIFtzaGFwZV0uY29uY2F0KHJlc3VsdCk7XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFJldHVybiBhIG1hcCB7IGVsZW1lbnRJZCAtPiBoaWRkZW5TdGF0ZX0uXG4gKlxuICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuU2hhcGU+fSBlbGVtZW50c1xuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudHNWaXNpYmlsaXR5UmVjdXJzaXZlKGVsZW1lbnRzKSB7XG5cbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXN1bHRbZWxlbWVudC5pZF0gPSBlbGVtZW50LmhpZGRlbjtcblxuICAgIGlmIChlbGVtZW50LmNoaWxkcmVuKSB7XG4gICAgICByZXN1bHQgPSBhc3NpZ24oe30sIHJlc3VsdCwgZ2V0RWxlbWVudHNWaXNpYmlsaXR5UmVjdXJzaXZlKGVsZW1lbnQuY2hpbGRyZW4pKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gc2V0SGlkZGVuUmVjdXJzaXZlKGVsZW1lbnRzLCBuZXdIaWRkZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgZWxlbWVudC5oaWRkZW4gPSBuZXdIaWRkZW47XG5cbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4pIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoc2V0SGlkZGVuUmVjdXJzaXZlKGVsZW1lbnQuY2hpbGRyZW4sIGVsZW1lbnQuY29sbGFwc2VkIHx8IG5ld0hpZGRlbikpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZVZpc2liaWxpdHlSZWN1cnNpdmUoZWxlbWVudHMsIGxhc3RTdGF0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmhpZGRlbiA9IGxhc3RTdGF0ZVtlbGVtZW50LmlkXTtcblxuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChyZXN0b3JlVmlzaWJpbGl0eVJlY3Vyc2l2ZShlbGVtZW50LmNoaWxkcmVuLCBsYXN0U3RhdGUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQge1xuICBhZGQgYXMgY29sbGVjdGlvbkFkZCxcbiAgcmVtb3ZlIGFzIGNvbGxlY3Rpb25SZW1vdmVcbn0gZnJvbSAnLi4vLi4vLi4vdXRpbC9Db2xsZWN0aW9ucyc7XG5cbi8qKlxuICogQSBoYW5kbGVyIHRoYXQgaW1wbGVtZW50cyByZXZlcnNpYmxlIGF0dGFjaGluZy9kZXRhY2hpbmcgb2Ygc2hhcGVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBVcGRhdGVBdHRhY2htZW50SGFuZGxlcihtb2RlbGluZykge1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xufVxuXG5VcGRhdGVBdHRhY2htZW50SGFuZGxlci4kaW5qZWN0ID0gWyAnbW9kZWxpbmcnIF07XG5cblxuVXBkYXRlQXR0YWNobWVudEhhbmRsZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICBuZXdIb3N0ID0gY29udGV4dC5uZXdIb3N0LFxuICAgICAgb2xkSG9zdCA9IHNoYXBlLmhvc3Q7XG5cbiAgLy8gKDApIGRldGFjaCBmcm9tIG9sZCBob3N0XG4gIGNvbnRleHQub2xkSG9zdCA9IG9sZEhvc3Q7XG4gIGNvbnRleHQuYXR0YWNoZXJJZHggPSByZW1vdmVBdHRhY2hlcihvbGRIb3N0LCBzaGFwZSk7XG5cbiAgLy8gKDEpIGF0dGFjaCB0byBuZXcgaG9zdFxuICBhZGRBdHRhY2hlcihuZXdIb3N0LCBzaGFwZSk7XG5cbiAgLy8gKDIpIHVwZGF0ZSBob3N0XG4gIHNoYXBlLmhvc3QgPSBuZXdIb3N0O1xuXG4gIHJldHVybiBzaGFwZTtcbn07XG5cblVwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICBuZXdIb3N0ID0gY29udGV4dC5uZXdIb3N0LFxuICAgICAgb2xkSG9zdCA9IGNvbnRleHQub2xkSG9zdCxcbiAgICAgIGF0dGFjaGVySWR4ID0gY29udGV4dC5hdHRhY2hlcklkeDtcblxuICAvLyAoMikgdXBkYXRlIGhvc3RcbiAgc2hhcGUuaG9zdCA9IG9sZEhvc3Q7XG5cbiAgLy8gKDEpIGF0dGFjaCB0byBuZXcgaG9zdFxuICByZW1vdmVBdHRhY2hlcihuZXdIb3N0LCBzaGFwZSk7XG5cbiAgLy8gKDApIGRldGFjaCBmcm9tIG9sZCBob3N0XG4gIGFkZEF0dGFjaGVyKG9sZEhvc3QsIHNoYXBlLCBhdHRhY2hlcklkeCk7XG5cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuXG5mdW5jdGlvbiByZW1vdmVBdHRhY2hlcihob3N0LCBhdHRhY2hlcikge1xuXG4gIC8vIHJlbW92ZSBhdHRhY2hlciBmcm9tIGhvc3RcbiAgcmV0dXJuIGNvbGxlY3Rpb25SZW1vdmUoaG9zdCAmJiBob3N0LmF0dGFjaGVycywgYXR0YWNoZXIpO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRhY2hlcihob3N0LCBhdHRhY2hlciwgaWR4KSB7XG5cbiAgaWYgKCFob3N0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGF0dGFjaGVycyA9IGhvc3QuYXR0YWNoZXJzO1xuXG4gIGlmICghYXR0YWNoZXJzKSB7XG4gICAgaG9zdC5hdHRhY2hlcnMgPSBhdHRhY2hlcnMgPSBbXTtcbiAgfVxuXG4gIGNvbGxlY3Rpb25BZGQoYXR0YWNoZXJzLCBhdHRhY2hlciwgaWR4KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFVwZGF0ZVdheXBvaW50c0hhbmRsZXIoKSB7IH1cblxuVXBkYXRlV2F5cG9pbnRzSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgIG5ld1dheXBvaW50cyA9IGNvbnRleHQubmV3V2F5cG9pbnRzO1xuXG4gIGNvbnRleHQub2xkV2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHM7XG5cbiAgY29ubmVjdGlvbi53YXlwb2ludHMgPSBuZXdXYXlwb2ludHM7XG5cbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG5VcGRhdGVXYXlwb2ludHNIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICBvbGRXYXlwb2ludHMgPSBjb250ZXh0Lm9sZFdheXBvaW50cztcblxuICBjb25uZWN0aW9uLndheXBvaW50cyA9IG9sZFdheXBvaW50cztcblxuICByZXR1cm4gY29ubmVjdGlvbjtcbn07IiwiaW1wb3J0IHtcbiAgZ2V0TmV3QXR0YWNoUG9pbnRcbn0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbC9BdHRhY2hVdGlsJztcblxuaW1wb3J0IHtcbiAgZ2V0T3JpZW50YXRpb25cbn0gZnJvbSAnLi4vLi4vLi4vLi4vbGF5b3V0L0xheW91dFV0aWwnO1xuXG5pbXBvcnQge1xuICBmaWx0ZXIsXG4gIG1hcFxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlc2l6ZWRTb3VyY2VBbmNob3IoY29ubmVjdGlvbiwgc2hhcGUsIG9sZEJvdW5kcykge1xuXG4gIHZhciB3YXlwb2ludHMgPSBzYWZlR2V0V2F5cG9pbnRzKGNvbm5lY3Rpb24pLFxuICAgICAgd2F5cG9pbnRzSW5zaWRlTmV3Qm91bmRzID0gZ2V0V2F5cG9pbnRzSW5zaWRlQm91bmRzKHdheXBvaW50cywgc2hhcGUpLFxuICAgICAgb2xkQW5jaG9yID0gd2F5cG9pbnRzWzBdO1xuXG4gIC8vIG5ldyBhbmNob3IgaXMgdGhlIGxhc3Qgd2F5cG9pbnQgZW5jbG9zZWQgYmUgcmVzaXplZCBzb3VyY2VcbiAgaWYgKHdheXBvaW50c0luc2lkZU5ld0JvdW5kcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gd2F5cG9pbnRzSW5zaWRlTmV3Qm91bmRzWyB3YXlwb2ludHNJbnNpZGVOZXdCb3VuZHMubGVuZ3RoIC0gMSBdO1xuICB9XG5cbiAgcmV0dXJuIGdldE5ld0F0dGFjaFBvaW50KG9sZEFuY2hvci5vcmlnaW5hbCB8fCBvbGRBbmNob3IsIG9sZEJvdW5kcywgc2hhcGUpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXNpemVkVGFyZ2V0QW5jaG9yKGNvbm5lY3Rpb24sIHNoYXBlLCBvbGRCb3VuZHMpIHtcblxuICB2YXIgd2F5cG9pbnRzID0gc2FmZUdldFdheXBvaW50cyhjb25uZWN0aW9uKSxcbiAgICAgIHdheXBvaW50c0luc2lkZU5ld0JvdW5kcyA9IGdldFdheXBvaW50c0luc2lkZUJvdW5kcyh3YXlwb2ludHMsIHNoYXBlKSxcbiAgICAgIG9sZEFuY2hvciA9IHdheXBvaW50c1t3YXlwb2ludHMubGVuZ3RoIC0gMV07XG5cbiAgLy8gbmV3IGFuY2hvciBpcyB0aGUgZmlyc3Qgd2F5cG9pbnQgZW5jbG9zZWQgYmUgcmVzaXplZCB0YXJnZXRcbiAgaWYgKHdheXBvaW50c0luc2lkZU5ld0JvdW5kcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gd2F5cG9pbnRzSW5zaWRlTmV3Qm91bmRzWyAwIF07XG4gIH1cblxuICByZXR1cm4gZ2V0TmV3QXR0YWNoUG9pbnQob2xkQW5jaG9yLm9yaWdpbmFsIHx8IG9sZEFuY2hvciwgb2xkQm91bmRzLCBzaGFwZSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vdmVkU291cmNlQW5jaG9yKGNvbm5lY3Rpb24sIHNvdXJjZSwgbW92ZURlbHRhKSB7XG5cbiAgdmFyIHdheXBvaW50cyA9IHNhZmVHZXRXYXlwb2ludHMoY29ubmVjdGlvbiksXG4gICAgICBvbGRCb3VuZHMgPSBzdWJ0cmFjdChzb3VyY2UsIG1vdmVEZWx0YSksXG4gICAgICBvbGRBbmNob3IgPSB3YXlwb2ludHNbIDAgXTtcblxuICByZXR1cm4gZ2V0TmV3QXR0YWNoUG9pbnQob2xkQW5jaG9yLm9yaWdpbmFsIHx8IG9sZEFuY2hvciwgb2xkQm91bmRzLCBzb3VyY2UpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb3ZlZFRhcmdldEFuY2hvcihjb25uZWN0aW9uLCB0YXJnZXQsIG1vdmVEZWx0YSkge1xuXG4gIHZhciB3YXlwb2ludHMgPSBzYWZlR2V0V2F5cG9pbnRzKGNvbm5lY3Rpb24pLFxuICAgICAgb2xkQm91bmRzID0gc3VidHJhY3QodGFyZ2V0LCBtb3ZlRGVsdGEpLFxuICAgICAgb2xkQW5jaG9yID0gd2F5cG9pbnRzWyB3YXlwb2ludHMubGVuZ3RoIC0gMSBdO1xuXG4gIHJldHVybiBnZXROZXdBdHRhY2hQb2ludChvbGRBbmNob3Iub3JpZ2luYWwgfHwgb2xkQW5jaG9yLCBvbGRCb3VuZHMsIHRhcmdldCk7XG59XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KGJvdW5kcywgZGVsdGEpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBib3VuZHMueCAtIGRlbHRhLngsXG4gICAgeTogYm91bmRzLnkgLSBkZWx0YS55LFxuICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXG4gICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0XG4gIH07XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gd2F5cG9pbnRzIG9mIGdpdmVuIGNvbm5lY3Rpb247IHRocm93IGlmIG5vbiBleGlzdHMgKHNob3VsZCBub3QgaGFwcGVuISEpLlxuICpcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICpcbiAqIEByZXR1cm4ge0FycmF5PFBvaW50Pn1cbiAqL1xuZnVuY3Rpb24gc2FmZUdldFdheXBvaW50cyhjb25uZWN0aW9uKSB7XG5cbiAgdmFyIHdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzO1xuXG4gIGlmICghd2F5cG9pbnRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29ubmVjdGlvbiMnICsgY29ubmVjdGlvbi5pZCArICc6IG5vIHdheXBvaW50cycpO1xuICB9XG5cbiAgcmV0dXJuIHdheXBvaW50cztcbn1cblxuZnVuY3Rpb24gZ2V0V2F5cG9pbnRzSW5zaWRlQm91bmRzKHdheXBvaW50cywgYm91bmRzKSB7XG4gIHZhciBvcmlnaW5hbFdheXBvaW50cyA9IG1hcCh3YXlwb2ludHMsIGdldE9yaWdpbmFsKTtcblxuICByZXR1cm4gZmlsdGVyKG9yaWdpbmFsV2F5cG9pbnRzLCBmdW5jdGlvbih3YXlwb2ludCkge1xuICAgIHJldHVybiBpc0luc2lkZUJvdW5kcyh3YXlwb2ludCwgYm91bmRzKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHBvaW50IGlzIGluc2lkZSBib3VuZHMsIGluY2wuIGVkZ2VzLlxuICpcbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gKiBAcGFyYW0ge0JvdW5kc30gYm91bmRzXG4gKi9cbmZ1bmN0aW9uIGlzSW5zaWRlQm91bmRzKHBvaW50LCBib3VuZHMpIHtcbiAgcmV0dXJuIGdldE9yaWVudGF0aW9uKGJvdW5kcywgcG9pbnQsIDEpID09PSAnaW50ZXJzZWN0Jztcbn1cblxuZnVuY3Rpb24gZ2V0T3JpZ2luYWwocG9pbnQpIHtcbiAgcmV0dXJuIHBvaW50Lm9yaWdpbmFsIHx8IHBvaW50O1xufVxuIiwiaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZ2V0Q2xvc3VyZVxufSBmcm9tICcuLi8uLi8uLi8uLi91dGlsL0VsZW1lbnRzJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNb3ZlQ2xvc3VyZSgpIHtcblxuICB0aGlzLmFsbFNoYXBlcyA9IHt9O1xuICB0aGlzLmFsbENvbm5lY3Rpb25zID0ge307XG5cbiAgdGhpcy5lbmNsb3NlZEVsZW1lbnRzID0ge307XG4gIHRoaXMuZW5jbG9zZWRDb25uZWN0aW9ucyA9IHt9O1xuXG4gIHRoaXMudG9wTGV2ZWwgPSB7fTtcbn1cblxuXG5Nb3ZlQ2xvc3VyZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZWxlbWVudCwgaXNUb3BMZXZlbCkge1xuICByZXR1cm4gdGhpcy5hZGRBbGwoWyBlbGVtZW50IF0sIGlzVG9wTGV2ZWwpO1xufTtcblxuXG5Nb3ZlQ2xvc3VyZS5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24oZWxlbWVudHMsIGlzVG9wTGV2ZWwpIHtcblxuICB2YXIgbmV3Q2xvc3VyZSA9IGdldENsb3N1cmUoZWxlbWVudHMsICEhaXNUb3BMZXZlbCwgdGhpcyk7XG5cbiAgYXNzaWduKHRoaXMsIG5ld0Nsb3N1cmUpO1xuXG4gIHJldHVybiB0aGlzO1xufTsiLCJpbXBvcnQge1xuICBmb3JFYWNoXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZ2V0TW92ZWRTb3VyY2VBbmNob3IsXG4gIGdldE1vdmVkVGFyZ2V0QW5jaG9yXG59IGZyb20gJy4vQW5jaG9yc0hlbHBlcic7XG5cbmltcG9ydCBNb3ZlQ2xvc3VyZSBmcm9tICcuL01vdmVDbG9zdXJlJztcblxuXG4vKipcbiAqIEEgaGVscGVyIHRoYXQgaXMgYWJsZSB0byBjYXJyeSBvdXQgc2VyaWFsaXplZCBtb3ZlXG4gKiBvcGVyYXRpb25zIG9uIG11bHRpcGxlIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1vdmVIZWxwZXIobW9kZWxpbmcpIHtcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbn1cblxuLyoqXG4gKiBNb3ZlIHRoZSBzcGVjaWZpZWQgZWxlbWVudHMgYW5kIGFsbCBjaGlsZHJlbiBieSB0aGUgZ2l2ZW4gZGVsdGEuXG4gKlxuICogVGhpcyBtb3ZlcyBhbGwgZW5jbG9zZWQgY29ubmVjdGlvbnMsIHRvbyBhbmQgbGF5b3V0cyBhbGwgYWZmZWN0ZWRcbiAqIGV4dGVybmFsIGNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSAge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZWxlbWVudHNcbiAqIEBwYXJhbSAge1BvaW50fSBkZWx0YVxuICogQHBhcmFtICB7ZGpzLm1vZGVsLkJhc2V9IG5ld1BhcmVudCBhcHBsaWVkIHRvIHRoZSBmaXJzdCBsZXZlbCBvZiBzaGFwZXNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGxpc3Qgb2YgdG91Y2hlZCBlbGVtZW50c1xuICovXG5Nb3ZlSGVscGVyLnByb3RvdHlwZS5tb3ZlUmVjdXJzaXZlID0gZnVuY3Rpb24oZWxlbWVudHMsIGRlbHRhLCBuZXdQYXJlbnQpIHtcbiAgaWYgKCFlbGVtZW50cykge1xuICAgIHJldHVybiBbXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlQ2xvc3VyZSh0aGlzLmdldENsb3N1cmUoZWxlbWVudHMpLCBkZWx0YSwgbmV3UGFyZW50KTtcbiAgfVxufTtcblxuLyoqXG4gKiBNb3ZlIHRoZSBnaXZlbiBjbG9zdXJlIG9mIGVsbWVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY2xvc3VyZVxuICogQHBhcmFtIHtQb2ludH0gZGVsdGFcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IFtuZXdQYXJlbnRdXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBbbmV3SG9zdF1cbiAqL1xuTW92ZUhlbHBlci5wcm90b3R5cGUubW92ZUNsb3N1cmUgPSBmdW5jdGlvbihjbG9zdXJlLCBkZWx0YSwgbmV3UGFyZW50LCBuZXdIb3N0LCBwcmltYXJ5U2hhcGUpIHtcbiAgdmFyIG1vZGVsaW5nID0gdGhpcy5fbW9kZWxpbmc7XG5cbiAgdmFyIGFsbFNoYXBlcyA9IGNsb3N1cmUuYWxsU2hhcGVzLFxuICAgICAgYWxsQ29ubmVjdGlvbnMgPSBjbG9zdXJlLmFsbENvbm5lY3Rpb25zLFxuICAgICAgZW5jbG9zZWRDb25uZWN0aW9ucyA9IGNsb3N1cmUuZW5jbG9zZWRDb25uZWN0aW9ucyxcbiAgICAgIHRvcExldmVsID0gY2xvc3VyZS50b3BMZXZlbCxcbiAgICAgIGtlZXBQYXJlbnQgPSBmYWxzZTtcblxuICBpZiAocHJpbWFyeVNoYXBlICYmIHByaW1hcnlTaGFwZS5wYXJlbnQgPT09IG5ld1BhcmVudCkge1xuICAgIGtlZXBQYXJlbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gbW92ZSBhbGwgc2hhcGVzXG4gIGZvckVhY2goYWxsU2hhcGVzLCBmdW5jdGlvbihzaGFwZSkge1xuXG4gICAgLy8gbW92ZSB0aGUgZWxlbWVudCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGRlbHRhXG4gICAgbW9kZWxpbmcubW92ZVNoYXBlKHNoYXBlLCBkZWx0YSwgdG9wTGV2ZWxbc2hhcGUuaWRdICYmICFrZWVwUGFyZW50ICYmIG5ld1BhcmVudCwge1xuICAgICAgcmVjdXJzZTogZmFsc2UsXG4gICAgICBsYXlvdXQ6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIG1vdmUgYWxsIGNoaWxkIGNvbm5lY3Rpb25zIC8gbGF5b3V0IGV4dGVybmFsIGNvbm5lY3Rpb25zXG4gIGZvckVhY2goYWxsQ29ubmVjdGlvbnMsIGZ1bmN0aW9uKGMpIHtcblxuICAgIHZhciBzb3VyY2VNb3ZlZCA9ICEhYWxsU2hhcGVzW2Muc291cmNlLmlkXSxcbiAgICAgICAgdGFyZ2V0TW92ZWQgPSAhIWFsbFNoYXBlc1tjLnRhcmdldC5pZF07XG5cbiAgICBpZiAoZW5jbG9zZWRDb25uZWN0aW9uc1tjLmlkXSAmJiBzb3VyY2VNb3ZlZCAmJiB0YXJnZXRNb3ZlZCkge1xuICAgICAgbW9kZWxpbmcubW92ZUNvbm5lY3Rpb24oYywgZGVsdGEsIHRvcExldmVsW2MuaWRdICYmICFrZWVwUGFyZW50ICYmIG5ld1BhcmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsaW5nLmxheW91dENvbm5lY3Rpb24oYywge1xuICAgICAgICBjb25uZWN0aW9uU3RhcnQ6IHNvdXJjZU1vdmVkICYmIGdldE1vdmVkU291cmNlQW5jaG9yKGMsIGMuc291cmNlLCBkZWx0YSksXG4gICAgICAgIGNvbm5lY3Rpb25FbmQ6IHRhcmdldE1vdmVkICYmIGdldE1vdmVkVGFyZ2V0QW5jaG9yKGMsIGMudGFyZ2V0LCBkZWx0YSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNsb3N1cmUgZm9yIHRoZSBzZWxlY3RlZCBlbGVtZW50c1xuICpcbiAqIEBwYXJhbSAge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZWxlbWVudHNcbiAqIEByZXR1cm4ge01vdmVDbG9zdXJlfSBjbG9zdXJlXG4gKi9cbk1vdmVIZWxwZXIucHJvdG90eXBlLmdldENsb3N1cmUgPSBmdW5jdGlvbihlbGVtZW50cykge1xuICByZXR1cm4gbmV3IE1vdmVDbG9zdXJlKCkuYWRkQWxsKGVsZW1lbnRzLCB0cnVlKTtcbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW91c2UoZXZlbnRCdXMpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIHRoaXMuX2xhc3RNb3ZlRXZlbnQgPSBudWxsO1xyXG5cclxuICBmdW5jdGlvbiBzZXRMYXN0TW92ZUV2ZW50KG1vdXNlbW92ZUV2ZW50KSB7XHJcbiAgICBzZWxmLl9sYXN0TW92ZUV2ZW50ID0gbW91c2Vtb3ZlRXZlbnQ7XHJcbiAgfVxyXG5cclxuICBldmVudEJ1cy5vbignY2FudmFzLmluaXQnLCBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICB2YXIgc3ZnID0gc2VsZi5fc3ZnID0gY29udGV4dC5zdmc7XHJcblxyXG4gICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHNldExhc3RNb3ZlRXZlbnQpO1xyXG4gIH0pO1xyXG5cclxuICBldmVudEJ1cy5vbignY2FudmFzLmRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgIHNlbGYuX2xhc3RNb3VzZUV2ZW50ID0gbnVsbDtcclxuXHJcbiAgICBzZWxmLl9zdmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc2V0TGFzdE1vdmVFdmVudCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbk1vdXNlLiRpbmplY3QgPSBbICdldmVudEJ1cycgXTtcclxuXHJcbk1vdXNlLnByb3RvdHlwZS5nZXRMYXN0TW92ZUV2ZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMuX2xhc3RNb3ZlRXZlbnQgfHwgY3JlYXRlTW92ZUV2ZW50KDAsIDApO1xyXG59O1xyXG5cclxuLy8gaGVscGVycyAvLy8vLy8vLy8vXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW92ZUV2ZW50KHgsIHkpIHtcclxuICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xyXG5cclxuICB2YXIgc2NyZWVuWCA9IHgsXHJcbiAgICAgIHNjcmVlblkgPSB5LFxyXG4gICAgICBjbGllbnRYID0geCxcclxuICAgICAgY2xpZW50WSA9IHk7XHJcblxyXG4gIGlmIChldmVudC5pbml0TW91c2VFdmVudCkge1xyXG4gICAgZXZlbnQuaW5pdE1vdXNlRXZlbnQoXHJcbiAgICAgICdtb3VzZW1vdmUnLFxyXG4gICAgICB0cnVlLFxyXG4gICAgICB0cnVlLFxyXG4gICAgICB3aW5kb3csXHJcbiAgICAgIDAsXHJcbiAgICAgIHNjcmVlblgsXHJcbiAgICAgIHNjcmVlblksXHJcbiAgICAgIGNsaWVudFgsXHJcbiAgICAgIGNsaWVudFksXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgZmFsc2UsXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgICAwLFxyXG4gICAgICBudWxsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGV2ZW50O1xyXG59IiwiaW1wb3J0IE1vdXNlIGZyb20gJy4vTW91c2UnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdtb3VzZScgXSxcbiAgbW91c2U6IFsgJ3R5cGUnLCBNb3VzZSBdXG59O1xuIiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmaWx0ZXIsXG4gIGdyb3VwQnksXG4gIGlzT2JqZWN0XG59IGZyb20gJ21pbi1kYXNoJztcblxudmFyIExPV19QUklPUklUWSA9IDUwMCxcbiAgICBNRURJVU1fUFJJT1JJVFkgPSAxMjUwLFxuICAgIEhJR0hfUFJJT1JJVFkgPSAxNTAwO1xuXG5pbXBvcnQgeyBnZXRPcmlnaW5hbCBhcyBnZXRPcmlnaW5hbEV2ZW50IH0gZnJvbSAnLi4vLi4vdXRpbC9FdmVudCc7XG5cbmltcG9ydCB7XG4gIGlzUHJpbWFyeUJ1dHRvblxufSBmcm9tICcuLi8uLi91dGlsL01vdXNlJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuZnVuY3Rpb24gbWlkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50LnggKyByb3VuZChlbGVtZW50LndpZHRoIC8gMiksXG4gICAgeTogZWxlbWVudC55ICsgcm91bmQoZWxlbWVudC5oZWlnaHQgLyAyKVxuICB9O1xufVxuXG4vKipcbiAqIEEgcGx1Z2luIHRoYXQgbWFrZXMgc2hhcGVzIGRyYWdnYWJsZSAvIGRyb3BwYWJsZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtEcmFnZ2luZ30gZHJhZ2dpbmdcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsZWN0aW9uXG4gKiBAcGFyYW0ge1J1bGVzfSBydWxlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNb3ZlRXZlbnRzKFxuICAgIGV2ZW50QnVzLCBkcmFnZ2luZywgbW9kZWxpbmcsXG4gICAgc2VsZWN0aW9uLCBydWxlcykge1xuXG4gIC8vIHJ1bGVzXG5cbiAgZnVuY3Rpb24gY2FuTW92ZShzaGFwZXMsIGRlbHRhLCBwb3NpdGlvbiwgdGFyZ2V0KSB7XG5cbiAgICByZXR1cm4gcnVsZXMuYWxsb3dlZCgnZWxlbWVudHMubW92ZScsIHtcbiAgICAgIHNoYXBlczogc2hhcGVzLFxuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICB9KTtcbiAgfVxuXG5cbiAgLy8gbW92ZSBldmVudHNcblxuICAvLyBhc3NpZ24gYSBoaWdoIHByaW9yaXR5IHRvIHRoaXMgaGFuZGxlciB0byBzZXR1cCB0aGUgZW52aXJvbm1lbnRcbiAgLy8gb3RoZXJzIG1heSBob29rIHVwIGxhdGVyLCBlLmcuIGF0IGRlZmF1bHQgcHJpb3JpdHkgYW5kIG1vZGlmeVxuICAvLyB0aGUgbW92ZSBlbnZpcm9ubWVudC5cbiAgLy9cbiAgLy8gVGhpcyBzZXRzIHVwIHRoZSBjb250ZXh0IHdpdGhcbiAgLy9cbiAgLy8gKiBzaGFwZTogdGhlIHByaW1hcnkgc2hhcGUgYmVpbmcgbW92ZWRcbiAgLy8gKiBzaGFwZXM6IGEgbGlzdCBvZiBzaGFwZXMgdG8gYmUgbW92ZWRcbiAgLy8gKiB2YWxpZGF0ZWRTaGFwZXM6IGEgbGlzdCBvZiBzaGFwZXMgdGhhdCBhcmUgYmVpbmcgY2hlY2tlZFxuICAvLyAgICAgICAgICAgICAgICAgICAgYWdhaW5zdCB0aGUgcnVsZXMgYmVmb3JlIGFuZCBkdXJpbmcgbW92ZVxuICAvL1xuICBldmVudEJ1cy5vbignc2hhcGUubW92ZS5zdGFydCcsIEhJR0hfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIHNoYXBlID0gZXZlbnQuc2hhcGUsXG4gICAgICAgIHNoYXBlcyA9IHNlbGVjdGlvbi5nZXQoKS5zbGljZSgpO1xuXG4gICAgLy8gbW92ZSBvbmx5IHNpbmdsZSBzaGFwZSBpZiB0aGUgZHJhZ2dlZCBlbGVtZW50XG4gICAgLy8gaXMgbm90IHBhcnQgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgaWYgKHNoYXBlcy5pbmRleE9mKHNoYXBlKSA9PT0gLTEpIHtcbiAgICAgIHNoYXBlcyA9IFsgc2hhcGUgXTtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgd2UgcmVtb3ZlIG5lc3RlZCBlbGVtZW50cyBpbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGFuZCBhZGQgYXR0YWNoZXJzIGZvciBhIHByb3BlciBkcmFnZ2VyXG4gICAgc2hhcGVzID0gcmVtb3ZlTmVzdGVkKHNoYXBlcyk7XG5cbiAgICAvLyBhdHRhY2ggc2hhcGVzIHRvIGRyYWcgY29udGV4dFxuICAgIGFzc2lnbihjb250ZXh0LCB7XG4gICAgICBzaGFwZXM6IHNoYXBlcyxcbiAgICAgIHZhbGlkYXRlZFNoYXBlczogc2hhcGVzLFxuICAgICAgc2hhcGU6IHNoYXBlXG4gICAgfSk7XG4gIH0pO1xuXG5cbiAgLy8gYXNzaWduIGEgaGlnaCBwcmlvcml0eSB0byB0aGlzIGhhbmRsZXIgdG8gc2V0dXAgdGhlIGVudmlyb25tZW50XG4gIC8vIG90aGVycyBtYXkgaG9vayB1cCBsYXRlciwgZS5nLiBhdCBkZWZhdWx0IHByaW9yaXR5IGFuZCBtb2RpZnlcbiAgLy8gdGhlIG1vdmUgZW52aXJvbm1lbnRcbiAgLy9cbiAgZXZlbnRCdXMub24oJ3NoYXBlLm1vdmUuc3RhcnQnLCBNRURJVU1fUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIHZhbGlkYXRlZFNoYXBlcyA9IGNvbnRleHQudmFsaWRhdGVkU2hhcGVzLFxuICAgICAgICBjYW5FeGVjdXRlO1xuXG4gICAgY2FuRXhlY3V0ZSA9IGNvbnRleHQuY2FuRXhlY3V0ZSA9IGNhbk1vdmUodmFsaWRhdGVkU2hhcGVzKTtcblxuICAgIC8vIGNoZWNrIGlmIHdlIGNhbiBtb3ZlIHRoZSBlbGVtZW50c1xuICAgIGlmICghY2FuRXhlY3V0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYXNzaWduIGEgbG93IHByaW9yaXR5IHRvIHRoaXMgaGFuZGxlclxuICAvLyB0byBsZXQgb3RoZXJzIG1vZGlmeSB0aGUgbW92ZSBldmVudCBiZWZvcmUgd2UgdXBkYXRlXG4gIC8vIHRoZSBjb250ZXh0XG4gIC8vXG4gIGV2ZW50QnVzLm9uKCdzaGFwZS5tb3ZlLm1vdmUnLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIHZhbGlkYXRlZFNoYXBlcyA9IGNvbnRleHQudmFsaWRhdGVkU2hhcGVzLFxuICAgICAgICBob3ZlciA9IGV2ZW50LmhvdmVyLFxuICAgICAgICBkZWx0YSA9IHsgeDogZXZlbnQuZHgsIHk6IGV2ZW50LmR5IH0sXG4gICAgICAgIHBvc2l0aW9uID0geyB4OiBldmVudC54LCB5OiBldmVudC55IH0sXG4gICAgICAgIGNhbkV4ZWN1dGU7XG5cbiAgICAvLyBjaGVjayBpZiB3ZSBjYW4gbW92ZSB0aGUgZWxlbWVudHNcbiAgICBjYW5FeGVjdXRlID0gY2FuTW92ZSh2YWxpZGF0ZWRTaGFwZXMsIGRlbHRhLCBwb3NpdGlvbiwgaG92ZXIpO1xuXG4gICAgY29udGV4dC5kZWx0YSA9IGRlbHRhO1xuICAgIGNvbnRleHQuY2FuRXhlY3V0ZSA9IGNhbkV4ZWN1dGU7XG5cbiAgICAvLyBzaW1wbHkgaWdub3JlIG1vdmUgb3ZlclxuICAgIGlmIChjYW5FeGVjdXRlID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnRhcmdldCA9IG51bGw7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnRhcmdldCA9IGhvdmVyO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignc2hhcGUubW92ZS5lbmQnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0O1xuXG4gICAgdmFyIGRlbHRhID0gY29udGV4dC5kZWx0YSxcbiAgICAgICAgY2FuRXhlY3V0ZSA9IGNvbnRleHQuY2FuRXhlY3V0ZSxcbiAgICAgICAgaXNBdHRhY2ggPSBjYW5FeGVjdXRlID09PSAnYXR0YWNoJyxcbiAgICAgICAgc2hhcGVzID0gY29udGV4dC5zaGFwZXM7XG5cbiAgICBpZiAoY2FuRXhlY3V0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgd2UgaGF2ZSBhY3R1YWwgcGl4ZWwgdmFsdWVzIGRlbHRhc1xuICAgIC8vIChpbXBvcnRhbnQgd2hlbiB6b29tIGxldmVsIHdhcyA+IDEgZHVyaW5nIG1vdmUpXG4gICAgZGVsdGEueCA9IHJvdW5kKGRlbHRhLngpO1xuICAgIGRlbHRhLnkgPSByb3VuZChkZWx0YS55KTtcblxuICAgIGlmIChkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHtcblxuICAgICAgLy8gZGlkbid0IG1vdmVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtb2RlbGluZy5tb3ZlRWxlbWVudHMoc2hhcGVzLCBkZWx0YSwgY29udGV4dC50YXJnZXQsIHtcbiAgICAgIHByaW1hcnlTaGFwZTogY29udGV4dC5zaGFwZSxcbiAgICAgIGF0dGFjaDogaXNBdHRhY2hcbiAgICB9KTtcbiAgfSk7XG5cblxuICAvLyBtb3ZlIGFjdGl2YXRpb25cblxuICBldmVudEJ1cy5vbignZWxlbWVudC5tb3VzZWRvd24nLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgaWYgKCFpc1ByaW1hcnlCdXR0b24oZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBnZXRPcmlnaW5hbEV2ZW50KGV2ZW50KTtcblxuICAgIGlmICghb3JpZ2luYWxFdmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHN1cHBseSBET00gbW91c2Vkb3duIGV2ZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXJ0KG9yaWdpbmFsRXZlbnQsIGV2ZW50LmVsZW1lbnQpO1xuICB9KTtcblxuICAvKipcbiAgICogU3RhcnQgbW92ZS5cbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge2Rqcy5tb2RlbC5TaGFwZX0gc2hhcGVcbiAgICogQHBhcmFtIHtib29sZWFufSBbYWN0aXZhdGVdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAgICovXG4gIGZ1bmN0aW9uIHN0YXJ0KGV2ZW50LCBlbGVtZW50LCBhY3RpdmF0ZSwgY29udGV4dCkge1xuICAgIGlmIChpc09iamVjdChhY3RpdmF0ZSkpIHtcbiAgICAgIGNvbnRleHQgPSBhY3RpdmF0ZTtcbiAgICAgIGFjdGl2YXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZG8gbm90IG1vdmUgY29ubmVjdGlvbnMgb3IgdGhlIHJvb3QgZWxlbWVudFxuICAgIGlmIChlbGVtZW50LndheXBvaW50cyB8fCAhZWxlbWVudC5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVmZXJlbmNlUG9pbnQgPSBtaWQoZWxlbWVudCk7XG5cbiAgICBkcmFnZ2luZy5pbml0KGV2ZW50LCByZWZlcmVuY2VQb2ludCwgJ3NoYXBlLm1vdmUnLCB7XG4gICAgICBjdXJzb3I6ICdncmFiYmluZycsXG4gICAgICBhdXRvQWN0aXZhdGU6IGFjdGl2YXRlLFxuICAgICAgZGF0YToge1xuICAgICAgICBzaGFwZTogZWxlbWVudCxcbiAgICAgICAgY29udGV4dDogY29udGV4dCB8fCB7fVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gd2UndmUgaGFuZGxlZCB0aGUgZXZlbnRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEFQSVxuXG4gIHRoaXMuc3RhcnQgPSBzdGFydDtcbn1cblxuTW92ZUV2ZW50cy4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnZHJhZ2dpbmcnLFxuICAnbW9kZWxpbmcnLFxuICAnc2VsZWN0aW9uJyxcbiAgJ3J1bGVzJ1xuXTtcblxuXG4vKipcbiAqIFJldHVybiBhIGZpbHRlcmVkIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCBkbyBub3QgY29udGFpblxuICogdGhvc2UgbmVzdGVkIGludG8gb3RoZXJzLlxuICpcbiAqIEBwYXJhbSAge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZWxlbWVudHNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGZpbHRlcmVkXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZU5lc3RlZChlbGVtZW50cykge1xuXG4gIHZhciBpZHMgPSBncm91cEJ5KGVsZW1lbnRzLCAnaWQnKTtcblxuICByZXR1cm4gZmlsdGVyKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgd2hpbGUgKChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQpKSB7XG5cbiAgICAgIC8vIHBhcmVudCBpbiBzZWxlY3Rpb25cbiAgICAgIGlmIChpZHNbZWxlbWVudC5pZF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbiIsImltcG9ydCB7XG4gIGZsYXR0ZW4sXG4gIGZvckVhY2gsXG4gIGZpbHRlcixcbiAgZmluZCxcbiAgZ3JvdXBCeSxcbiAgbWFwLFxuICBtYXRjaFBhdHRlcm4sXG4gIHNpemVcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBzZWxmQW5kQWxsQ2hpbGRyZW5cbn0gZnJvbSAnLi4vLi4vdXRpbC9FbGVtZW50cyc7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZSxcbiAgcmVtb3ZlIGFzIHN2Z1JlbW92ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWwvU3ZnVHJhbnNmb3JtVXRpbCc7XG5cbnZhciBMT1dfUFJJT1JJVFkgPSA0OTk7XG5cbnZhciBNQVJLRVJfRFJBR0dJTkcgPSAnZGpzLWRyYWdnaW5nJyxcbiAgICBNQVJLRVJfT0sgPSAnZHJvcC1vaycsXG4gICAgTUFSS0VSX05PVF9PSyA9ICdkcm9wLW5vdC1vaycsXG4gICAgTUFSS0VSX05FV19QQVJFTlQgPSAnbmV3LXBhcmVudCcsXG4gICAgTUFSS0VSX0FUVEFDSCA9ICdhdHRhY2gtb2snO1xuXG5cbi8qKlxuICogUHJvdmlkZXMgcHJldmlld3MgZm9yIG1vdmluZyBzaGFwZXMgd2hlbiBtb3ZpbmcuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqIEBwYXJhbSB7U3R5bGVzfSBzdHlsZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW92ZVByZXZpZXcoXG4gICAgZXZlbnRCdXMsIGNhbnZhcywgc3R5bGVzLCBwcmV2aWV3U3VwcG9ydCkge1xuXG4gIGZ1bmN0aW9uIGdldFZpc3VhbERyYWdTaGFwZXMoc2hhcGVzKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gZ2V0QWxsRHJhZ2dlZEVsZW1lbnRzKHNoYXBlcyk7XG5cbiAgICB2YXIgZmlsdGVyZWRFbGVtZW50cyA9IHJlbW92ZUVkZ2VzKGVsZW1lbnRzKTtcblxuICAgIHJldHVybiBmaWx0ZXJlZEVsZW1lbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QWxsRHJhZ2dlZEVsZW1lbnRzKHNoYXBlcykge1xuICAgIHZhciBhbGxTaGFwZXMgPSBzZWxmQW5kQWxsQ2hpbGRyZW4oc2hhcGVzLCB0cnVlKTtcblxuICAgIHZhciBhbGxDb25uZWN0aW9ucyA9IG1hcChhbGxTaGFwZXMsIGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICByZXR1cm4gKHNoYXBlLmluY29taW5nIHx8IFtdKS5jb25jYXQoc2hhcGUub3V0Z29pbmcgfHwgW10pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZsYXR0ZW4oYWxsU2hhcGVzLmNvbmNhdChhbGxDb25uZWN0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgZHJvcCBtYXJrZXIgb24gYW4gZWxlbWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIHNldE1hcmtlcihlbGVtZW50LCBtYXJrZXIpIHtcblxuICAgIFsgTUFSS0VSX0FUVEFDSCwgTUFSS0VSX09LLCBNQVJLRVJfTk9UX09LLCBNQVJLRVJfTkVXX1BBUkVOVCBdLmZvckVhY2goZnVuY3Rpb24obSkge1xuXG4gICAgICBpZiAobSA9PT0gbWFya2VyKSB7XG4gICAgICAgIGNhbnZhcy5hZGRNYXJrZXIoZWxlbWVudCwgbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGVsZW1lbnQsIG0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYW4gZWxlbWVudCBkcmFnZ2FibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtib29sZWFufSBhZGRNYXJrZXJcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VEcmFnZ2FibGUoY29udGV4dCwgZWxlbWVudCwgYWRkTWFya2VyKSB7XG5cbiAgICBwcmV2aWV3U3VwcG9ydC5hZGREcmFnZ2VyKGVsZW1lbnQsIGNvbnRleHQuZHJhZ0dyb3VwKTtcblxuICAgIGlmIChhZGRNYXJrZXIpIHtcbiAgICAgIGNhbnZhcy5hZGRNYXJrZXIoZWxlbWVudCwgTUFSS0VSX0RSQUdHSU5HKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5hbGxEcmFnZ2VkRWxlbWVudHMpIHtcbiAgICAgIGNvbnRleHQuYWxsRHJhZ2dlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuYWxsRHJhZ2dlZEVsZW1lbnRzID0gWyBlbGVtZW50IF07XG4gICAgfVxuICB9XG5cbiAgLy8gYXNzaWduIGEgbG93IHByaW9yaXR5IHRvIHRoaXMgaGFuZGxlclxuICAvLyB0byBsZXQgb3RoZXJzIG1vZGlmeSB0aGUgbW92ZSBjb250ZXh0IGJlZm9yZVxuICAvLyB3ZSBkcmF3IHRoaW5nc1xuICBldmVudEJ1cy5vbignc2hhcGUubW92ZS5zdGFydCcsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGRyYWdTaGFwZXMgPSBjb250ZXh0LnNoYXBlcyxcbiAgICAgICAgYWxsRHJhZ2dlZEVsZW1lbnRzID0gY29udGV4dC5hbGxEcmFnZ2VkRWxlbWVudHM7XG5cbiAgICB2YXIgdmlzdWFsbHlEcmFnZ2VkU2hhcGVzID0gZ2V0VmlzdWFsRHJhZ1NoYXBlcyhkcmFnU2hhcGVzKTtcblxuICAgIGlmICghY29udGV4dC5kcmFnR3JvdXApIHtcbiAgICAgIHZhciBkcmFnR3JvdXAgPSBzdmdDcmVhdGUoJ2cnKTtcblxuICAgICAgc3ZnQXR0cihkcmFnR3JvdXAsIHN0eWxlcy5jbHMoJ2Rqcy1kcmFnLWdyb3VwJywgWyAnbm8tZXZlbnRzJyBdKSk7XG5cbiAgICAgIHZhciBkZWZhdWx0TGF5ZXIgPSBjYW52YXMuZ2V0RGVmYXVsdExheWVyKCk7XG5cbiAgICAgIHN2Z0FwcGVuZChkZWZhdWx0TGF5ZXIsIGRyYWdHcm91cCk7XG5cbiAgICAgIGNvbnRleHQuZHJhZ0dyb3VwID0gZHJhZ0dyb3VwO1xuICAgIH1cblxuICAgIC8vIGFkZCBwcmV2aWV3c1xuICAgIHZpc3VhbGx5RHJhZ2dlZFNoYXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICBwcmV2aWV3U3VwcG9ydC5hZGREcmFnZ2VyKHNoYXBlLCBjb250ZXh0LmRyYWdHcm91cCk7XG4gICAgfSk7XG5cbiAgICAvLyBjYWNoZSBhbGwgZHJhZ2dlZCBlbGVtZW50cyAvIGdmeFxuICAgIC8vIHNvIHRoYXQgd2UgY2FuIHF1aWNrbHkgdW5kbyB0aGVpciBzdGF0ZSBjaGFuZ2VzIGxhdGVyXG4gICAgaWYgKCFhbGxEcmFnZ2VkRWxlbWVudHMpIHtcbiAgICAgIGFsbERyYWdnZWRFbGVtZW50cyA9IGdldEFsbERyYWdnZWRFbGVtZW50cyhkcmFnU2hhcGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxsRHJhZ2dlZEVsZW1lbnRzID0gZmxhdHRlbihbXG4gICAgICAgIGFsbERyYWdnZWRFbGVtZW50cyxcbiAgICAgICAgZ2V0QWxsRHJhZ2dlZEVsZW1lbnRzKGRyYWdTaGFwZXMpXG4gICAgICBdKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgZHJhZ2dpbmcgbWFya2VyXG4gICAgZm9yRWFjaChhbGxEcmFnZ2VkRWxlbWVudHMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGNhbnZhcy5hZGRNYXJrZXIoZSwgTUFSS0VSX0RSQUdHSU5HKTtcbiAgICB9KTtcblxuICAgIGNvbnRleHQuYWxsRHJhZ2dlZEVsZW1lbnRzID0gYWxsRHJhZ2dlZEVsZW1lbnRzO1xuXG4gICAgLy8gZGV0ZXJtaW5lLCBpZiBhbnkgb2YgdGhlIGRyYWdnZWQgZWxlbWVudHMgaGF2ZSBkaWZmZXJlbnQgcGFyZW50c1xuICAgIGNvbnRleHQuZGlmZmVyZW50UGFyZW50cyA9IGhhdmVEaWZmZXJlbnRQYXJlbnRzKGRyYWdTaGFwZXMpO1xuICB9KTtcblxuICAvLyB1cGRhdGUgcHJldmlld3NcbiAgZXZlbnRCdXMub24oJ3NoYXBlLm1vdmUubW92ZScsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgZHJhZ0dyb3VwID0gY29udGV4dC5kcmFnR3JvdXAsXG4gICAgICAgIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0LFxuICAgICAgICBwYXJlbnQgPSBjb250ZXh0LnNoYXBlLnBhcmVudCxcbiAgICAgICAgY2FuRXhlY3V0ZSA9IGNvbnRleHQuY2FuRXhlY3V0ZTtcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGlmIChjYW5FeGVjdXRlID09PSAnYXR0YWNoJykge1xuICAgICAgICBzZXRNYXJrZXIodGFyZ2V0LCBNQVJLRVJfQVRUQUNIKTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5jYW5FeGVjdXRlICYmIHRhcmdldCAmJiB0YXJnZXQuaWQgIT09IHBhcmVudC5pZCkge1xuICAgICAgICBzZXRNYXJrZXIodGFyZ2V0LCBNQVJLRVJfTkVXX1BBUkVOVCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRNYXJrZXIodGFyZ2V0LCBjb250ZXh0LmNhbkV4ZWN1dGUgPyBNQVJLRVJfT0sgOiBNQVJLRVJfTk9UX09LKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cmFuc2xhdGUoZHJhZ0dyb3VwLCBldmVudC5keCwgZXZlbnQuZHkpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbihbICdzaGFwZS5tb3ZlLm91dCcsICdzaGFwZS5tb3ZlLmNsZWFudXAnIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICB0YXJnZXQgPSBjb250ZXh0LnRhcmdldDtcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHNldE1hcmtlcih0YXJnZXQsIG51bGwpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIHByZXZpZXdzXG4gIGV2ZW50QnVzLm9uKCdzaGFwZS5tb3ZlLmNsZWFudXAnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBhbGxEcmFnZ2VkRWxlbWVudHMgPSBjb250ZXh0LmFsbERyYWdnZWRFbGVtZW50cyxcbiAgICAgICAgZHJhZ0dyb3VwID0gY29udGV4dC5kcmFnR3JvdXA7XG5cblxuICAgIC8vIHJlbW92ZSBkcmFnZ2luZyBtYXJrZXJcbiAgICBmb3JFYWNoKGFsbERyYWdnZWRFbGVtZW50cywgZnVuY3Rpb24oZSkge1xuICAgICAgY2FudmFzLnJlbW92ZU1hcmtlcihlLCBNQVJLRVJfRFJBR0dJTkcpO1xuICAgIH0pO1xuXG4gICAgaWYgKGRyYWdHcm91cCkge1xuICAgICAgc3ZnUmVtb3ZlKGRyYWdHcm91cCk7XG4gICAgfVxuICB9KTtcblxuXG4gIC8vIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIE1ha2UgYW4gZWxlbWVudCBkcmFnZ2FibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtib29sZWFufSBhZGRNYXJrZXJcbiAgICovXG4gIHRoaXMubWFrZURyYWdnYWJsZSA9IG1ha2VEcmFnZ2FibGU7XG59XG5cbk1vdmVQcmV2aWV3LiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnc3R5bGVzJyxcbiAgJ3ByZXZpZXdTdXBwb3J0J1xuXTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiByZXR1cm5zIGVsZW1lbnRzIG1pbnVzIGFsbCBjb25uZWN0aW9uc1xuICogd2hlcmUgc291cmNlIG9yIHRhcmdldCBpcyBub3QgZWxlbWVudHNcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRWRnZXMoZWxlbWVudHMpIHtcblxuICB2YXIgZmlsdGVyZWRFbGVtZW50cyA9IGZpbHRlcihlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgaWYgKCFpc0Nvbm5lY3Rpb24oZWxlbWVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGZpbmQoZWxlbWVudHMsIG1hdGNoUGF0dGVybih7IGlkOiBlbGVtZW50LnNvdXJjZS5pZCB9KSkgJiZcbiAgICAgICAgZmluZChlbGVtZW50cywgbWF0Y2hQYXR0ZXJuKHsgaWQ6IGVsZW1lbnQudGFyZ2V0LmlkIH0pKVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmaWx0ZXJlZEVsZW1lbnRzO1xufVxuXG5mdW5jdGlvbiBoYXZlRGlmZmVyZW50UGFyZW50cyhlbGVtZW50cykge1xuICByZXR1cm4gc2l6ZShncm91cEJ5KGVsZW1lbnRzLCBmdW5jdGlvbihlKSB7IHJldHVybiBlLnBhcmVudCAmJiBlLnBhcmVudC5pZDsgfSkpICE9PSAxO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBlbGVtZW50IGlzIGEgY29ubmVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gaXNDb25uZWN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQud2F5cG9pbnRzO1xufVxuIiwiaW1wb3J0IEludGVyYWN0aW9uRXZlbnRzTW9kdWxlIGZyb20gJy4uL2ludGVyYWN0aW9uLWV2ZW50cyc7XG5pbXBvcnQgU2VsZWN0aW9uTW9kdWxlIGZyb20gJy4uL3NlbGVjdGlvbic7XG5pbXBvcnQgT3V0bGluZU1vZHVsZSBmcm9tICcuLi9vdXRsaW5lJztcbmltcG9ydCBSdWxlc01vZHVsZSBmcm9tICcuLi9ydWxlcyc7XG5pbXBvcnQgRHJhZ2dpbmdNb2R1bGUgZnJvbSAnLi4vZHJhZ2dpbmcnO1xuaW1wb3J0IFByZXZpZXdTdXBwb3J0TW9kdWxlIGZyb20gJy4uL3ByZXZpZXctc3VwcG9ydCc7XG5cbmltcG9ydCBNb3ZlIGZyb20gJy4vTW92ZSc7XG5pbXBvcnQgTW92ZVByZXZpZXcgZnJvbSAnLi9Nb3ZlUHJldmlldyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBJbnRlcmFjdGlvbkV2ZW50c01vZHVsZSxcbiAgICBTZWxlY3Rpb25Nb2R1bGUsXG4gICAgT3V0bGluZU1vZHVsZSxcbiAgICBSdWxlc01vZHVsZSxcbiAgICBEcmFnZ2luZ01vZHVsZSxcbiAgICBQcmV2aWV3U3VwcG9ydE1vZHVsZVxuICBdLFxuICBfX2luaXRfXzogW1xuICAgICdtb3ZlJyxcbiAgICAnbW92ZVByZXZpZXcnXG4gIF0sXG4gIG1vdmU6IFsgJ3R5cGUnLCBNb3ZlIF0sXG4gIG1vdmVQcmV2aWV3OiBbICd0eXBlJywgTW92ZVByZXZpZXcgXVxufTtcbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBDb21tYW5kSW50ZXJjZXB0b3IgZnJvbSAnLi4vLi4vY29tbWFuZC9Db21tYW5kSW50ZXJjZXB0b3InO1xuXG5cbi8qKlxuICogQW4gYWJzdHJhY3QgcHJvdmlkZXIgdGhhdCBhbGxvd3MgbW9kZWxlcnMgdG8gaW1wbGVtZW50IGEgY3VzdG9tXG4gKiBvcmRlcmluZyBvZiBkaWFncmFtIGVsZW1lbnRzIG9uIHRoZSBjYW52YXMuXG4gKlxuICogSXQgbWFrZXMgc3VyZSB0aGF0IHRoZSBvcmRlciBpcyBhbHdheXMgcHJlc2VydmVkIGR1cmluZyBlbGVtZW50XG4gKiBjcmVhdGlvbiBhbmQgbW92ZSBvcGVyYXRpb25zLlxuICpcbiAqIEluIG9yZGVyIHRvIHVzZSB0aGlzIGJlaGF2aW9yLCBpbmhlcml0IGZyb20gaXQgYW5kIG92ZXJyaWRlXG4gKiB0aGUgbWV0aG9kIHtAbGluayBPcmRlcmluZ1Byb3ZpZGVyI2dldE9yZGVyaW5nfS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uIEN1c3RvbU9yZGVyaW5nUHJvdmlkZXIoZXZlbnRCdXMpIHtcbiAqICAgT3JkZXJpbmdQcm92aWRlci5jYWxsKHRoaXMsIGV2ZW50QnVzKTtcbiAqXG4gKiAgIHRoaXMuZ2V0T3JkZXJpbmcgPSBmdW5jdGlvbihlbGVtZW50LCBuZXdQYXJlbnQpIHtcbiAqICAgICAvLyBhbHdheXMgaW5zZXJ0IGVsZW1lbnRzIGF0IHRoZSBmcm9udFxuICogICAgIC8vIHdoZW4gbW92aW5nXG4gKiAgICAgcmV0dXJuIHtcbiAqICAgICAgIGluZGV4OiAwLFxuICogICAgICAgcGFyZW50OiBuZXdQYXJlbnRcbiAqICAgICB9O1xuICogICB9O1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gT3JkZXJpbmdQcm92aWRlcihldmVudEJ1cykge1xuXG4gIENvbW1hbmRJbnRlcmNlcHRvci5jYWxsKHRoaXMsIGV2ZW50QnVzKTtcblxuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnByZUV4ZWN1dGUoWyAnc2hhcGUuY3JlYXRlJywgJ2Nvbm5lY3Rpb24uY3JlYXRlJyBdLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBlbGVtZW50ID0gY29udGV4dC5zaGFwZSB8fCBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICAgIHBhcmVudCA9IGNvbnRleHQucGFyZW50O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gc2VsZi5nZXRPcmRlcmluZyhlbGVtZW50LCBwYXJlbnQpO1xuXG4gICAgaWYgKG9yZGVyaW5nKSB7XG5cbiAgICAgIGlmIChvcmRlcmluZy5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250ZXh0LnBhcmVudCA9IG9yZGVyaW5nLnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wYXJlbnRJbmRleCA9IG9yZGVyaW5nLmluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5wcmVFeGVjdXRlKFsgJ3NoYXBlLm1vdmUnLCAnY29ubmVjdGlvbi5tb3ZlJyBdLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBlbGVtZW50ID0gY29udGV4dC5zaGFwZSB8fCBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICAgIHBhcmVudCA9IGNvbnRleHQubmV3UGFyZW50IHx8IGVsZW1lbnQucGFyZW50O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gc2VsZi5nZXRPcmRlcmluZyhlbGVtZW50LCBwYXJlbnQpO1xuXG4gICAgaWYgKG9yZGVyaW5nKSB7XG5cbiAgICAgIGlmIChvcmRlcmluZy5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250ZXh0Lm5ld1BhcmVudCA9IG9yZGVyaW5nLnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5uZXdQYXJlbnRJbmRleCA9IG9yZGVyaW5nLmluZGV4O1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgY3VzdG9tIG9yZGVyaW5nIG9mIHRoZSBlbGVtZW50LCBib3RoIGluIHRlcm1zXG4gKiBvZiBwYXJlbnQgZWxlbWVudCBhbmQgaW5kZXggaW4gdGhlIG5ldyBwYXJlbnQuXG4gKlxuICogSW1wbGVtZW50b3JzIG9mIHRoaXMgbWV0aG9kIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoXG4gKiBgcGFyZW50YCBfYW5kXyBgaW5kZXhgIGluIGl0LlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLlNoYXBlfSBuZXdQYXJlbnRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IG9yZGVyaW5nIGRlc2NyaXB0b3JcbiAqL1xuT3JkZXJpbmdQcm92aWRlci5wcm90b3R5cGUuZ2V0T3JkZXJpbmcgPSBmdW5jdGlvbihlbGVtZW50LCBuZXdQYXJlbnQpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5pbmhlcml0cyhPcmRlcmluZ1Byb3ZpZGVyLCBDb21tYW5kSW50ZXJjZXB0b3IpOyIsImltcG9ydCB7IGdldEJCb3ggfSBmcm9tICcuLi8uLi91dGlsL0VsZW1lbnRzJztcblxudmFyIExPV19QUklPUklUWSA9IDUwMDtcblxuaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjcmVhdGUgYXMgc3ZnQ3JlYXRlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IHtcbiAgcXVlcnkgYXMgZG9tUXVlcnlcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxuLyoqXG4gKiBAY2xhc3NcbiAqXG4gKiBBIHBsdWdpbiB0aGF0IGFkZHMgYW4gb3V0bGluZSB0byBzaGFwZXMgYW5kIGNvbm5lY3Rpb25zIHRoYXQgbWF5IGJlIGFjdGl2YXRlZCBhbmQgc3R5bGVkXG4gKiB2aWEgQ1NTIGNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7U3R5bGVzfSBzdHlsZXNcbiAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gT3V0bGluZShldmVudEJ1cywgc3R5bGVzLCBlbGVtZW50UmVnaXN0cnkpIHtcblxuICB0aGlzLm9mZnNldCA9IDY7XG5cbiAgdmFyIE9VVExJTkVfU1RZTEUgPSBzdHlsZXMuY2xzKCdkanMtb3V0bGluZScsIFsgJ25vLWZpbGwnIF0pO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjcmVhdGVPdXRsaW5lKGdmeCwgYm91bmRzKSB7XG4gICAgdmFyIG91dGxpbmUgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcblxuICAgIHN2Z0F0dHIob3V0bGluZSwgYXNzaWduKHtcbiAgICAgIHg6IDEwLFxuICAgICAgeTogMTAsXG4gICAgICB3aWR0aDogMTAwLFxuICAgICAgaGVpZ2h0OiAxMDBcbiAgICB9LCBPVVRMSU5FX1NUWUxFKSk7XG5cbiAgICBzdmdBcHBlbmQoZ2Z4LCBvdXRsaW5lKTtcblxuICAgIHJldHVybiBvdXRsaW5lO1xuICB9XG5cbiAgLy8gQSBsb3cgcHJpb3J0aXR5IGlzIG5lY2Vzc2FyeSwgYmVjYXVzZSBvdXRsaW5lcyBvZiBsYWJlbHMgaGF2ZSB0byBiZSB1cGRhdGVkXG4gIC8vIGFmdGVyIHRoZSBsYWJlbCBib3VuZHMgaGF2ZSBiZWVuIHVwZGF0ZWQgaW4gdGhlIHJlbmRlcmVyLlxuICBldmVudEJ1cy5vbihbICdzaGFwZS5hZGRlZCcsICdzaGFwZS5jaGFuZ2VkJyBdLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC5lbGVtZW50LFxuICAgICAgICBnZnggPSBldmVudC5nZng7XG5cbiAgICB2YXIgb3V0bGluZSA9IGRvbVF1ZXJ5KCcuZGpzLW91dGxpbmUnLCBnZngpO1xuXG4gICAgaWYgKCFvdXRsaW5lKSB7XG4gICAgICBvdXRsaW5lID0gY3JlYXRlT3V0bGluZShnZngsIGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHNlbGYudXBkYXRlU2hhcGVPdXRsaW5lKG91dGxpbmUsIGVsZW1lbnQpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbihbICdjb25uZWN0aW9uLmFkZGVkJywgJ2Nvbm5lY3Rpb24uY2hhbmdlZCcgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQsXG4gICAgICAgIGdmeCA9IGV2ZW50LmdmeDtcblxuICAgIHZhciBvdXRsaW5lID0gZG9tUXVlcnkoJy5kanMtb3V0bGluZScsIGdmeCk7XG5cbiAgICBpZiAoIW91dGxpbmUpIHtcbiAgICAgIG91dGxpbmUgPSBjcmVhdGVPdXRsaW5lKGdmeCwgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgc2VsZi51cGRhdGVDb25uZWN0aW9uT3V0bGluZShvdXRsaW5lLCBlbGVtZW50KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBvdXRsaW5lIG9mIGEgc2hhcGUgcmVzcGVjdGluZyB0aGUgZGltZW5zaW9uIG9mIHRoZVxuICogZWxlbWVudCBhbmQgYW4gb3V0bGluZSBvZmZzZXQuXG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gb3V0bGluZVxuICogQHBhcmFtICB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqL1xuT3V0bGluZS5wcm90b3R5cGUudXBkYXRlU2hhcGVPdXRsaW5lID0gZnVuY3Rpb24ob3V0bGluZSwgZWxlbWVudCkge1xuXG4gIHN2Z0F0dHIob3V0bGluZSwge1xuICAgIHg6IC10aGlzLm9mZnNldCxcbiAgICB5OiAtdGhpcy5vZmZzZXQsXG4gICAgd2lkdGg6IGVsZW1lbnQud2lkdGggKyB0aGlzLm9mZnNldCAqIDIsXG4gICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodCArIHRoaXMub2Zmc2V0ICogMlxuICB9KTtcblxufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG91dGxpbmUgb2YgYSBjb25uZWN0aW9uIHJlc3BlY3RpbmcgdGhlIGJvdW5kaW5nIGJveCBvZlxuICogdGhlIGNvbm5lY3Rpb24gYW5kIGFuIG91dGxpbmUgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IG91dGxpbmVcbiAqIEBwYXJhbSAge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKi9cbk91dGxpbmUucHJvdG90eXBlLnVwZGF0ZUNvbm5lY3Rpb25PdXRsaW5lID0gZnVuY3Rpb24ob3V0bGluZSwgY29ubmVjdGlvbikge1xuXG4gIHZhciBiYm94ID0gZ2V0QkJveChjb25uZWN0aW9uKTtcblxuICBzdmdBdHRyKG91dGxpbmUsIHtcbiAgICB4OiBiYm94LnggLSB0aGlzLm9mZnNldCxcbiAgICB5OiBiYm94LnkgLSB0aGlzLm9mZnNldCxcbiAgICB3aWR0aDogYmJveC53aWR0aCArIHRoaXMub2Zmc2V0ICogMixcbiAgICBoZWlnaHQ6IGJib3guaGVpZ2h0ICsgdGhpcy5vZmZzZXQgKiAyXG4gIH0pO1xuXG59O1xuXG5cbk91dGxpbmUuJGluamVjdCA9IFsnZXZlbnRCdXMnLCAnc3R5bGVzJywgJ2VsZW1lbnRSZWdpc3RyeSddOyIsImltcG9ydCBPdXRsaW5lIGZyb20gJy4vT3V0bGluZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ291dGxpbmUnIF0sXG4gIG91dGxpbmU6IFsgJ3R5cGUnLCBPdXRsaW5lIF1cbn07IiwiaW1wb3J0IHtcbiAgaXNBcnJheSxcbiAgaXNTdHJpbmcsXG4gIGlzT2JqZWN0LFxuICBhc3NpZ24sXG4gIGZvckVhY2gsXG4gIGZpbmQsXG4gIGZpbHRlcixcbiAgbWF0Y2hQYXR0ZXJuLFxuICBpc0RlZmluZWRcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBkb21pZnksXG4gIGNsYXNzZXMgYXMgZG9tQ2xhc3NlcyxcbiAgYXR0ciBhcyBkb21BdHRyLFxuICByZW1vdmUgYXMgZG9tUmVtb3ZlLFxuICBjbGVhciBhcyBkb21DbGVhclxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgZ2V0QkJveFxufSBmcm9tICcuLi8uLi91dGlsL0VsZW1lbnRzJztcblxuaW1wb3J0IElkcyBmcm9tICcuLi8uLi91dGlsL0lkR2VuZXJhdG9yJztcblxuLy8gZG9jdW1lbnQgd2lkZSB1bmlxdWUgb3ZlcmxheSBpZHNcbnZhciBpZHMgPSBuZXcgSWRzKCdvdicpO1xuXG52YXIgTE9XX1BSSU9SSVRZID0gNTAwO1xuXG5cbi8qKlxuICogQSBzZXJ2aWNlIHRoYXQgYWxsb3dzIHVzZXJzIHRvIGF0dGFjaCBvdmVybGF5cyB0byBkaWFncmFtIGVsZW1lbnRzLlxuICpcbiAqIFRoZSBvdmVybGF5IHNlcnZpY2Ugd2lsbCB0YWtlIGNhcmUgb2Ygb3ZlcmxheSBwb3NpdGlvbmluZyBkdXJpbmcgdXBkYXRlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGFkZCBhIHBpbmsgYmFkZ2Ugb24gdGhlIHRvcCBsZWZ0IG9mIHRoZSBzaGFwZVxuICogb3ZlcmxheXMuYWRkKHNvbWVTaGFwZSwge1xuICogICBwb3NpdGlvbjoge1xuICogICAgIHRvcDogLTUsXG4gKiAgICAgbGVmdDogLTVcbiAqICAgfSxcbiAqICAgaHRtbDogJzxkaXYgc3R5bGU9XCJ3aWR0aDogMTBweDsgYmFja2dyb3VuZDogZnVjaHNpYTsgY29sb3I6IHdoaXRlO1wiPjA8L2Rpdj4nXG4gKiB9KTtcbiAqXG4gKiAvLyBvciBhZGQgdmlhIHNoYXBlIGlkXG4gKlxuICogb3ZlcmxheXMuYWRkKCdzb21lLWVsZW1lbnQtaWQnLCB7XG4gKiAgIHBvc2l0aW9uOiB7XG4gKiAgICAgdG9wOiAtNSxcbiAqICAgICBsZWZ0OiAtNVxuICogICB9XG4gKiAgIGh0bWw6ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDEwcHg7IGJhY2tncm91bmQ6IGZ1Y2hzaWE7IGNvbG9yOiB3aGl0ZTtcIj4wPC9kaXY+J1xuICogfSk7XG4gKlxuICogLy8gb3IgYWRkIHdpdGggb3B0aW9uYWwgdHlwZVxuICpcbiAqIG92ZXJsYXlzLmFkZChzb21lU2hhcGUsICdiYWRnZScsIHtcbiAqICAgcG9zaXRpb246IHtcbiAqICAgICB0b3A6IC01LFxuICogICAgIGxlZnQ6IC01XG4gKiAgIH1cbiAqICAgaHRtbDogJzxkaXYgc3R5bGU9XCJ3aWR0aDogMTBweDsgYmFja2dyb3VuZDogZnVjaHNpYTsgY29sb3I6IHdoaXRlO1wiPjA8L2Rpdj4nXG4gKiB9KTtcbiAqXG4gKlxuICogLy8gcmVtb3ZlIGFuIG92ZXJsYXlcbiAqXG4gKiB2YXIgaWQgPSBvdmVybGF5cy5hZGQoLi4uKTtcbiAqIG92ZXJsYXlzLnJlbW92ZShpZCk7XG4gKlxuICpcbiAqIFlvdSBtYXkgY29uZmlndXJlIG92ZXJsYXkgZGVmYXVsdHMgZHVyaW5nIHRvb2wgYnkgcHJvdmlkaW5nIGEgYGNvbmZpZ2AgbW9kdWxlXG4gKiB3aXRoIGBvdmVybGF5cy5kZWZhdWx0c2AgYXMgYW4gZW50cnk6XG4gKlxuICoge1xuICogICBvdmVybGF5czoge1xuICogICAgIGRlZmF1bHRzOiB7XG4gKiAgICAgICBzaG93OiB7XG4gKiAgICAgICAgIG1pblpvb206IDAuNyxcbiAqICAgICAgICAgbWF4Wm9vbTogNS4wXG4gKiAgICAgICB9LFxuICogICAgICAgc2NhbGU6IHtcbiAqICAgICAgICAgbWluOiAxXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKiBAcGFyYW0ge0VsZW1lbnRSZWdpc3RyeX0gZWxlbWVudFJlZ2lzdHJ5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE92ZXJsYXlzKGNvbmZpZywgZXZlbnRCdXMsIGNhbnZhcywgZWxlbWVudFJlZ2lzdHJ5KSB7XG5cbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICB0aGlzLl9lbGVtZW50UmVnaXN0cnkgPSBlbGVtZW50UmVnaXN0cnk7XG5cbiAgdGhpcy5faWRzID0gaWRzO1xuXG4gIHRoaXMuX292ZXJsYXlEZWZhdWx0cyA9IGFzc2lnbih7XG5cbiAgICAvLyBubyBzaG93IGNvbnN0cmFpbnRzXG4gICAgc2hvdzogbnVsbCxcblxuICAgIC8vIGFsd2F5cyBzY2FsZVxuICAgIHNjYWxlOiB0cnVlXG4gIH0sIGNvbmZpZyAmJiBjb25maWcuZGVmYXVsdHMpO1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIG92ZXJsYXlJZCAtPiBvdmVybGF5XG4gICAqL1xuICB0aGlzLl9vdmVybGF5cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGVsZW1lbnRJZCAtPiBvdmVybGF5IGNvbnRhaW5lclxuICAgKi9cbiAgdGhpcy5fb3ZlcmxheUNvbnRhaW5lcnMgPSBbXTtcblxuICAvLyByb290IGh0bWwgZWxlbWVudCBmb3IgYWxsIG92ZXJsYXlzXG4gIHRoaXMuX292ZXJsYXlSb290ID0gY3JlYXRlUm9vdChjYW52YXMuZ2V0Q29udGFpbmVyKCkpO1xuXG4gIHRoaXMuX2luaXQoKTtcbn1cblxuXG5PdmVybGF5cy4kaW5qZWN0ID0gW1xuICAnY29uZmlnLm92ZXJsYXlzJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcycsXG4gICdlbGVtZW50UmVnaXN0cnknXG5dO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3ZlcmxheSB3aXRoIHRoZSBzcGVjaWZpZWQgaWQgb3IgYSBsaXN0IG9mIG92ZXJsYXlzXG4gKiBmb3IgYW4gZWxlbWVudCB3aXRoIGEgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIHJldHVybiB0aGUgc2luZ2xlIG92ZXJsYXkgd2l0aCB0aGUgZ2l2ZW4gaWRcbiAqIG92ZXJsYXlzLmdldCgnc29tZS1pZCcpO1xuICpcbiAqIC8vIHJldHVybiBhbGwgb3ZlcmxheXMgZm9yIHRoZSBzaGFwZVxuICogb3ZlcmxheXMuZ2V0KHsgZWxlbWVudDogc29tZVNoYXBlIH0pO1xuICpcbiAqIC8vIHJldHVybiBhbGwgb3ZlcmxheXMgb24gc2hhcGUgd2l0aCB0eXBlICdiYWRnZSdcbiAqIG92ZXJsYXlzLmdldCh7IGVsZW1lbnQ6IHNvbWVTaGFwZSwgdHlwZTogJ2JhZGdlJyB9KTtcbiAqXG4gKiAvLyBzaGFwZSBjYW4gYWxzbyBiZSBzcGVjaWZpZWQgYXMgaWRcbiAqIG92ZXJsYXlzLmdldCh7IGVsZW1lbnQ6ICdlbGVtZW50LWlkJywgdHlwZTogJ2JhZGdlJyB9KTtcbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNlYXJjaFxuICogQHBhcmFtIHtzdHJpbmd9IFtzZWFyY2guaWRdXG4gKiBAcGFyYW0ge3N0cmluZ3xkanMubW9kZWwuQmFzZX0gW3NlYXJjaC5lbGVtZW50XVxuICogQHBhcmFtIHtzdHJpbmd9IFtzZWFyY2gudHlwZV1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R8QXJyYXk8T2JqZWN0Pn0gdGhlIG92ZXJsYXkocylcbiAqL1xuT3ZlcmxheXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNlYXJjaCkge1xuXG4gIGlmIChpc1N0cmluZyhzZWFyY2gpKSB7XG4gICAgc2VhcmNoID0geyBpZDogc2VhcmNoIH07XG4gIH1cblxuICBpZiAoaXNTdHJpbmcoc2VhcmNoLmVsZW1lbnQpKSB7XG4gICAgc2VhcmNoLmVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0KHNlYXJjaC5lbGVtZW50KTtcbiAgfVxuXG4gIGlmIChzZWFyY2guZWxlbWVudCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9nZXRPdmVybGF5Q29udGFpbmVyKHNlYXJjaC5lbGVtZW50LCB0cnVlKTtcblxuICAgIC8vIHJldHVybiBhIGxpc3Qgb2Ygb3ZlcmxheXMgd2hlbiBzZWFyY2hpbmcgYnkgZWxlbWVudCAoK3R5cGUpXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIHNlYXJjaC50eXBlID8gZmlsdGVyKGNvbnRhaW5lci5vdmVybGF5cywgbWF0Y2hQYXR0ZXJuKHsgdHlwZTogc2VhcmNoLnR5cGUgfSkpIDogY29udGFpbmVyLm92ZXJsYXlzLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0gZWxzZVxuICBpZiAoc2VhcmNoLnR5cGUpIHtcbiAgICByZXR1cm4gZmlsdGVyKHRoaXMuX292ZXJsYXlzLCBtYXRjaFBhdHRlcm4oeyB0eXBlOiBzZWFyY2gudHlwZSB9KSk7XG4gIH0gZWxzZSB7XG5cbiAgICAvLyByZXR1cm4gc2luZ2xlIGVsZW1lbnQgd2hlbiBzZWFyY2hpbmcgYnkgaWRcbiAgICByZXR1cm4gc2VhcmNoLmlkID8gdGhpcy5fb3ZlcmxheXNbc2VhcmNoLmlkXSA6IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkcyBhIEhUTUwgb3ZlcmxheSB0byBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGRqcy5tb2RlbC5CYXNlfSAgIGVsZW1lbnQgICBhdHRhY2ggb3ZlcmxheSB0byB0aGlzIHNoYXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbdHlwZV0gICAgb3B0aW9uYWwgdHlwZSB0byBhc3NpZ24gdG8gdGhlIG92ZXJsYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgICAgIG92ZXJsYXkgICB0aGUgb3ZlcmxheSBjb25maWd1cmF0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8RE9NRWxlbWVudH0gICAgICAgb3ZlcmxheS5odG1sICAgICAgICAgICAgICAgICBodG1sIGVsZW1lbnQgdG8gdXNlIGFzIGFuIG92ZXJsYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgICAgIFtvdmVybGF5LnNob3ddICAgICAgICAgICAgICAgc2hvdyBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgICBbb3ZlcmxheS5zaG93Lm1pblpvb21dICAgICAgIG1pbmltYWwgem9vbSBsZXZlbCB0byBzaG93IHRoZSBvdmVybGF5XG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgICBbb3ZlcmxheS5zaG93Lm1heFpvb21dICAgICAgIG1heGltdW0gem9vbSBsZXZlbCB0byBzaG93IHRoZSBvdmVybGF5XG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICAgICBvdmVybGF5LnBvc2l0aW9uICAgICAgICAgICAgIHdoZXJlIHRvIGF0dGFjaCB0aGUgb3ZlcmxheVxuICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgW292ZXJsYXkucG9zaXRpb24ubGVmdF0gICAgICByZWxhdGl2ZSB0byBlbGVtZW50IGJib3ggbGVmdCBhdHRhY2htZW50XG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgICBbb3ZlcmxheS5wb3NpdGlvbi50b3BdICAgICAgIHJlbGF0aXZlIHRvIGVsZW1lbnQgYmJveCB0b3AgYXR0YWNobWVudFxuICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgW292ZXJsYXkucG9zaXRpb24uYm90dG9tXSAgICByZWxhdGl2ZSB0byBlbGVtZW50IGJib3ggYm90dG9tIGF0dGFjaG1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgICAgIFtvdmVybGF5LnBvc2l0aW9uLnJpZ2h0XSAgICAgcmVsYXRpdmUgdG8gZWxlbWVudCBiYm94IHJpZ2h0IGF0dGFjaG1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9ICAgICAgICAgIFtvdmVybGF5LnNjYWxlPXRydWVdICAgICAgICAgZmFsc2UgdG8gcHJlc2VydmUgdGhlIHNhbWUgc2l6ZSByZWdhcmRsZXNzIG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdyYW0gem9vbVxuICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgW292ZXJsYXkuc2NhbGUubWluXVxuICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgW292ZXJsYXkuc2NhbGUubWF4XVxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICAgICAgIGlkIHRoYXQgbWF5IGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBvdmVybGF5IGZvciB1cGRhdGUgb3IgcmVtb3ZhbFxuICovXG5PdmVybGF5cy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgb3ZlcmxheSkge1xuXG4gIGlmIChpc09iamVjdCh0eXBlKSkge1xuICAgIG92ZXJsYXkgPSB0eXBlO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG5cbiAgaWYgKCFlbGVtZW50LmlkKSB7XG4gICAgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5nZXQoZWxlbWVudCk7XG4gIH1cblxuICBpZiAoIW92ZXJsYXkucG9zaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmaXkgb3ZlcmxheSBwb3NpdGlvbicpO1xuICB9XG5cbiAgaWYgKCFvdmVybGF5Lmh0bWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmaXkgb3ZlcmxheSBodG1sJyk7XG4gIH1cblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZWxlbWVudCBzcGVjaWZpZWQnKTtcbiAgfVxuXG4gIHZhciBpZCA9IHRoaXMuX2lkcy5uZXh0KCk7XG5cbiAgb3ZlcmxheSA9IGFzc2lnbih7fSwgdGhpcy5fb3ZlcmxheURlZmF1bHRzLCBvdmVybGF5LCB7XG4gICAgaWQ6IGlkLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBodG1sOiBvdmVybGF5Lmh0bWxcbiAgfSk7XG5cbiAgdGhpcy5fYWRkT3ZlcmxheShvdmVybGF5KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGFuIG92ZXJsYXkgd2l0aCB0aGUgZ2l2ZW4gaWQgb3IgYWxsIG92ZXJsYXlzIG1hdGNoaW5nIHRoZSBnaXZlbiBmaWx0ZXIuXG4gKlxuICogQHNlZSBPdmVybGF5cyNnZXQgZm9yIGZpbHRlciBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaWRdXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZpbHRlcl1cbiAqL1xuT3ZlcmxheXMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGZpbHRlcikge1xuXG4gIHZhciBvdmVybGF5cyA9IHRoaXMuZ2V0KGZpbHRlcikgfHwgW107XG5cbiAgaWYgKCFpc0FycmF5KG92ZXJsYXlzKSkge1xuICAgIG92ZXJsYXlzID0gWyBvdmVybGF5cyBdO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZvckVhY2gob3ZlcmxheXMsIGZ1bmN0aW9uKG92ZXJsYXkpIHtcblxuICAgIHZhciBjb250YWluZXIgPSBzZWxmLl9nZXRPdmVybGF5Q29udGFpbmVyKG92ZXJsYXkuZWxlbWVudCwgdHJ1ZSk7XG5cbiAgICBpZiAob3ZlcmxheSkge1xuICAgICAgZG9tUmVtb3ZlKG92ZXJsYXkuaHRtbCk7XG4gICAgICBkb21SZW1vdmUob3ZlcmxheS5odG1sQ29udGFpbmVyKTtcblxuICAgICAgZGVsZXRlIG92ZXJsYXkuaHRtbENvbnRhaW5lcjtcbiAgICAgIGRlbGV0ZSBvdmVybGF5LmVsZW1lbnQ7XG5cbiAgICAgIGRlbGV0ZSBzZWxmLl9vdmVybGF5c1tvdmVybGF5LmlkXTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICB2YXIgaWR4ID0gY29udGFpbmVyLm92ZXJsYXlzLmluZGV4T2Yob3ZlcmxheSk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBjb250YWluZXIub3ZlcmxheXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxufTtcblxuXG5PdmVybGF5cy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBzZXRWaXNpYmxlKHRoaXMuX292ZXJsYXlSb290KTtcbn07XG5cblxuT3ZlcmxheXMucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgc2V0VmlzaWJsZSh0aGlzLl9vdmVybGF5Um9vdCwgZmFsc2UpO1xufTtcblxuT3ZlcmxheXMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX292ZXJsYXlzID0ge307XG5cbiAgdGhpcy5fb3ZlcmxheUNvbnRhaW5lcnMgPSBbXTtcblxuICBkb21DbGVhcih0aGlzLl9vdmVybGF5Um9vdCk7XG59O1xuXG5PdmVybGF5cy5wcm90b3R5cGUuX3VwZGF0ZU92ZXJsYXlDb250YWluZXIgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgdmFyIGVsZW1lbnQgPSBjb250YWluZXIuZWxlbWVudCxcbiAgICAgIGh0bWwgPSBjb250YWluZXIuaHRtbDtcblxuICAvLyB1cGRhdGUgY29udGFpbmVyIGxlZnQsdG9wIGFjY29yZGluZyB0byB0aGUgZWxlbWVudHMgeCx5IGNvb3JkaW5hdGVzXG4gIC8vIHRoaXMgZW5zdXJlcyB3ZSBjYW4gYXR0YWNoIGNoaWxkIGVsZW1lbnRzIHJlbGF0aXZlIHRvIHRoaXMgY29udGFpbmVyXG5cbiAgdmFyIHggPSBlbGVtZW50LngsXG4gICAgICB5ID0gZWxlbWVudC55O1xuXG4gIGlmIChlbGVtZW50LndheXBvaW50cykge1xuICAgIHZhciBiYm94ID0gZ2V0QkJveChlbGVtZW50KTtcbiAgICB4ID0gYmJveC54O1xuICAgIHkgPSBiYm94Lnk7XG4gIH1cblxuICBzZXRQb3NpdGlvbihodG1sLCB4LCB5KTtcblxuICBkb21BdHRyKGNvbnRhaW5lci5odG1sLCAnZGF0YS1jb250YWluZXItaWQnLCBlbGVtZW50LmlkKTtcbn07XG5cblxuT3ZlcmxheXMucHJvdG90eXBlLl91cGRhdGVPdmVybGF5ID0gZnVuY3Rpb24ob3ZlcmxheSkge1xuXG4gIHZhciBwb3NpdGlvbiA9IG92ZXJsYXkucG9zaXRpb24sXG4gICAgICBodG1sQ29udGFpbmVyID0gb3ZlcmxheS5odG1sQ29udGFpbmVyLFxuICAgICAgZWxlbWVudCA9IG92ZXJsYXkuZWxlbWVudDtcblxuICAvLyB1cGRhdGUgb3ZlcmxheSBodG1sIHJlbGF0aXZlIHRvIHNoYXBlIGJlY2F1c2VcbiAgLy8gaXQgaXMgYWxyZWFkeSBwb3NpdGlvbmVkIG9uIHRoZSBlbGVtZW50XG5cbiAgLy8gdXBkYXRlIHJlbGF0aXZlXG4gIHZhciBsZWZ0ID0gcG9zaXRpb24ubGVmdCxcbiAgICAgIHRvcCA9IHBvc2l0aW9uLnRvcDtcblxuICBpZiAocG9zaXRpb24ucmlnaHQgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgdmFyIHdpZHRoO1xuXG4gICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgICB3aWR0aCA9IGdldEJCb3goZWxlbWVudCkud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gZWxlbWVudC53aWR0aDtcbiAgICB9XG5cbiAgICBsZWZ0ID0gcG9zaXRpb24ucmlnaHQgKiAtMSArIHdpZHRoO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9uLmJvdHRvbSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICB2YXIgaGVpZ2h0O1xuXG4gICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgICBoZWlnaHQgPSBnZXRCQm94KGVsZW1lbnQpLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gZWxlbWVudC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgdG9wID0gcG9zaXRpb24uYm90dG9tICogLTEgKyBoZWlnaHQ7XG4gIH1cblxuICBzZXRQb3NpdGlvbihodG1sQ29udGFpbmVyLCBsZWZ0IHx8IDAsIHRvcCB8fCAwKTtcbn07XG5cblxuT3ZlcmxheXMucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5Q29udGFpbmVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgaHRtbCA9IGRvbWlmeSgnPGRpdiBjbGFzcz1cImRqcy1vdmVybGF5c1wiIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlXCIgLz4nKTtcblxuICB0aGlzLl9vdmVybGF5Um9vdC5hcHBlbmRDaGlsZChodG1sKTtcblxuICB2YXIgY29udGFpbmVyID0ge1xuICAgIGh0bWw6IGh0bWwsXG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBvdmVybGF5czogW11cbiAgfTtcblxuICB0aGlzLl91cGRhdGVPdmVybGF5Q29udGFpbmVyKGNvbnRhaW5lcik7XG5cbiAgdGhpcy5fb3ZlcmxheUNvbnRhaW5lcnMucHVzaChjb250YWluZXIpO1xuXG4gIHJldHVybiBjb250YWluZXI7XG59O1xuXG5cbk92ZXJsYXlzLnByb3RvdHlwZS5fdXBkYXRlUm9vdCA9IGZ1bmN0aW9uKHZpZXdib3gpIHtcbiAgdmFyIHNjYWxlID0gdmlld2JveC5zY2FsZSB8fCAxO1xuXG4gIHZhciBtYXRyaXggPSAnbWF0cml4KCcgK1xuICBbXG4gICAgc2NhbGUsXG4gICAgMCxcbiAgICAwLFxuICAgIHNjYWxlLFxuICAgIC0xICogdmlld2JveC54ICogc2NhbGUsXG4gICAgLTEgKiB2aWV3Ym94LnkgKiBzY2FsZVxuICBdLmpvaW4oJywnKSArXG4gICcpJztcblxuICBzZXRUcmFuc2Zvcm0odGhpcy5fb3ZlcmxheVJvb3QsIG1hdHJpeCk7XG59O1xuXG5cbk92ZXJsYXlzLnByb3RvdHlwZS5fZ2V0T3ZlcmxheUNvbnRhaW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHJhdykge1xuICB2YXIgY29udGFpbmVyID0gZmluZCh0aGlzLl9vdmVybGF5Q29udGFpbmVycywgZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBjLmVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gIH0pO1xuXG5cbiAgaWYgKCFjb250YWluZXIgJiYgIXJhdykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVPdmVybGF5Q29udGFpbmVyKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn07XG5cblxuT3ZlcmxheXMucHJvdG90eXBlLl9hZGRPdmVybGF5ID0gZnVuY3Rpb24ob3ZlcmxheSkge1xuXG4gIHZhciBpZCA9IG92ZXJsYXkuaWQsXG4gICAgICBlbGVtZW50ID0gb3ZlcmxheS5lbGVtZW50LFxuICAgICAgaHRtbCA9IG92ZXJsYXkuaHRtbCxcbiAgICAgIGh0bWxDb250YWluZXIsXG4gICAgICBvdmVybGF5Q29udGFpbmVyO1xuXG4gIC8vIHVud3JhcCBqcXVlcnkgKGZvciB0aG9zZSB3aG8gbmVlZCBpdClcbiAgaWYgKGh0bWwuZ2V0ICYmIGh0bWwuY29uc3RydWN0b3IucHJvdG90eXBlLmpxdWVyeSkge1xuICAgIGh0bWwgPSBodG1sLmdldCgwKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBwcm9wZXIgaHRtbCBlbGVtZW50cyBmcm9tXG4gIC8vIG92ZXJsYXkgSFRNTCBzdHJpbmdzXG4gIGlmIChpc1N0cmluZyhodG1sKSkge1xuICAgIGh0bWwgPSBkb21pZnkoaHRtbCk7XG4gIH1cblxuICBvdmVybGF5Q29udGFpbmVyID0gdGhpcy5fZ2V0T3ZlcmxheUNvbnRhaW5lcihlbGVtZW50KTtcblxuICBodG1sQ29udGFpbmVyID0gZG9taWZ5KCc8ZGl2IGNsYXNzPVwiZGpzLW92ZXJsYXlcIiBkYXRhLW92ZXJsYXktaWQ9XCInICsgaWQgKyAnXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGVcIj4nKTtcblxuICBodG1sQ29udGFpbmVyLmFwcGVuZENoaWxkKGh0bWwpO1xuXG4gIGlmIChvdmVybGF5LnR5cGUpIHtcbiAgICBkb21DbGFzc2VzKGh0bWxDb250YWluZXIpLmFkZCgnZGpzLW92ZXJsYXktJyArIG92ZXJsYXkudHlwZSk7XG4gIH1cblxuICBvdmVybGF5Lmh0bWxDb250YWluZXIgPSBodG1sQ29udGFpbmVyO1xuXG4gIG92ZXJsYXlDb250YWluZXIub3ZlcmxheXMucHVzaChvdmVybGF5KTtcbiAgb3ZlcmxheUNvbnRhaW5lci5odG1sLmFwcGVuZENoaWxkKGh0bWxDb250YWluZXIpO1xuXG4gIHRoaXMuX292ZXJsYXlzW2lkXSA9IG92ZXJsYXk7XG5cbiAgdGhpcy5fdXBkYXRlT3ZlcmxheShvdmVybGF5KTtcbiAgdGhpcy5fdXBkYXRlT3ZlcmxheVZpc2liaWx0eShvdmVybGF5LCB0aGlzLl9jYW52YXMudmlld2JveCgpKTtcbn07XG5cblxuT3ZlcmxheXMucHJvdG90eXBlLl91cGRhdGVPdmVybGF5VmlzaWJpbHR5ID0gZnVuY3Rpb24ob3ZlcmxheSwgdmlld2JveCkge1xuICB2YXIgc2hvdyA9IG92ZXJsYXkuc2hvdyxcbiAgICAgIG1pblpvb20gPSBzaG93ICYmIHNob3cubWluWm9vbSxcbiAgICAgIG1heFpvb20gPSBzaG93ICYmIHNob3cubWF4Wm9vbSxcbiAgICAgIGh0bWxDb250YWluZXIgPSBvdmVybGF5Lmh0bWxDb250YWluZXIsXG4gICAgICB2aXNpYmxlID0gdHJ1ZTtcblxuICBpZiAoc2hvdykge1xuICAgIGlmIChcbiAgICAgIChpc0RlZmluZWQobWluWm9vbSkgJiYgbWluWm9vbSA+IHZpZXdib3guc2NhbGUpIHx8XG4gICAgICAoaXNEZWZpbmVkKG1heFpvb20pICYmIG1heFpvb20gPCB2aWV3Ym94LnNjYWxlKVxuICAgICkge1xuICAgICAgdmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHNldFZpc2libGUoaHRtbENvbnRhaW5lciwgdmlzaWJsZSk7XG4gIH1cblxuICB0aGlzLl91cGRhdGVPdmVybGF5U2NhbGUob3ZlcmxheSwgdmlld2JveCk7XG59O1xuXG5cbk92ZXJsYXlzLnByb3RvdHlwZS5fdXBkYXRlT3ZlcmxheVNjYWxlID0gZnVuY3Rpb24ob3ZlcmxheSwgdmlld2JveCkge1xuICB2YXIgc2hvdWxkU2NhbGUgPSBvdmVybGF5LnNjYWxlLFxuICAgICAgbWluU2NhbGUsXG4gICAgICBtYXhTY2FsZSxcbiAgICAgIGh0bWxDb250YWluZXIgPSBvdmVybGF5Lmh0bWxDb250YWluZXI7XG5cbiAgdmFyIHNjYWxlLCB0cmFuc2Zvcm0gPSAnJztcblxuICBpZiAoc2hvdWxkU2NhbGUgIT09IHRydWUpIHtcblxuICAgIGlmIChzaG91bGRTY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgIG1pblNjYWxlID0gMTtcbiAgICAgIG1heFNjYWxlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluU2NhbGUgPSBzaG91bGRTY2FsZS5taW47XG4gICAgICBtYXhTY2FsZSA9IHNob3VsZFNjYWxlLm1heDtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKG1pblNjYWxlKSAmJiB2aWV3Ym94LnNjYWxlIDwgbWluU2NhbGUpIHtcbiAgICAgIHNjYWxlID0gKDEgLyB2aWV3Ym94LnNjYWxlIHx8IDEpICogbWluU2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmaW5lZChtYXhTY2FsZSkgJiYgdmlld2JveC5zY2FsZSA+IG1heFNjYWxlKSB7XG4gICAgICBzY2FsZSA9ICgxIC8gdmlld2JveC5zY2FsZSB8fCAxKSAqIG1heFNjYWxlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0RlZmluZWQoc2NhbGUpKSB7XG4gICAgdHJhbnNmb3JtID0gJ3NjYWxlKCcgKyBzY2FsZSArICcsJyArIHNjYWxlICsgJyknO1xuICB9XG5cbiAgc2V0VHJhbnNmb3JtKGh0bWxDb250YWluZXIsIHRyYW5zZm9ybSk7XG59O1xuXG5cbk92ZXJsYXlzLnByb3RvdHlwZS5fdXBkYXRlT3ZlcmxheXNWaXNpYmlsdHkgPSBmdW5jdGlvbih2aWV3Ym94KSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZvckVhY2godGhpcy5fb3ZlcmxheXMsIGZ1bmN0aW9uKG92ZXJsYXkpIHtcbiAgICBzZWxmLl91cGRhdGVPdmVybGF5VmlzaWJpbHR5KG92ZXJsYXksIHZpZXdib3gpO1xuICB9KTtcbn07XG5cblxuT3ZlcmxheXMucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cbiAgLy8gc2Nyb2xsL3pvb20gaW50ZWdyYXRpb25cblxuICBmdW5jdGlvbiB1cGRhdGVWaWV3Ym94KHZpZXdib3gpIHtcbiAgICBzZWxmLl91cGRhdGVSb290KHZpZXdib3gpO1xuICAgIHNlbGYuX3VwZGF0ZU92ZXJsYXlzVmlzaWJpbHR5KHZpZXdib3gpO1xuXG4gICAgc2VsZi5zaG93KCk7XG4gIH1cblxuICBldmVudEJ1cy5vbignY2FudmFzLnZpZXdib3guY2hhbmdpbmcnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHNlbGYuaGlkZSgpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignY2FudmFzLnZpZXdib3guY2hhbmdlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdXBkYXRlVmlld2JveChldmVudC52aWV3Ym94KTtcbiAgfSk7XG5cblxuICAvLyByZW1vdmUgaW50ZWdyYXRpb25cblxuICBldmVudEJ1cy5vbihbICdzaGFwZS5yZW1vdmUnLCAnY29ubmVjdGlvbi5yZW1vdmUnIF0sIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGUuZWxlbWVudDtcbiAgICB2YXIgb3ZlcmxheXMgPSBzZWxmLmdldCh7IGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG5cbiAgICBmb3JFYWNoKG92ZXJsYXlzLCBmdW5jdGlvbihvKSB7XG4gICAgICBzZWxmLnJlbW92ZShvLmlkKTtcbiAgICB9KTtcblxuICAgIHZhciBjb250YWluZXIgPSBzZWxmLl9nZXRPdmVybGF5Q29udGFpbmVyKGVsZW1lbnQpO1xuXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgZG9tUmVtb3ZlKGNvbnRhaW5lci5odG1sKTtcbiAgICAgIHZhciBpID0gc2VsZi5fb3ZlcmxheUNvbnRhaW5lcnMuaW5kZXhPZihjb250YWluZXIpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIHNlbGYuX292ZXJsYXlDb250YWluZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG5cbiAgLy8gbW92ZSBpbnRlZ3JhdGlvblxuXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50LmNoYW5nZWQnLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGUuZWxlbWVudDtcblxuICAgIHZhciBjb250YWluZXIgPSBzZWxmLl9nZXRPdmVybGF5Q29udGFpbmVyKGVsZW1lbnQsIHRydWUpO1xuXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgZm9yRWFjaChjb250YWluZXIub3ZlcmxheXMsIGZ1bmN0aW9uKG92ZXJsYXkpIHtcbiAgICAgICAgc2VsZi5fdXBkYXRlT3ZlcmxheShvdmVybGF5KTtcbiAgICAgIH0pO1xuXG4gICAgICBzZWxmLl91cGRhdGVPdmVybGF5Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuICB9KTtcblxuXG4gIC8vIG1hcmtlciBpbnRlZ3JhdGlvbiwgc2ltcGx5IGFkZCB0aGVtIG9uIHRoZSBvdmVybGF5cyBhcyBjbGFzc2VzLCB0b28uXG5cbiAgZXZlbnRCdXMub24oJ2VsZW1lbnQubWFya2VyLnVwZGF0ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY29udGFpbmVyID0gc2VsZi5fZ2V0T3ZlcmxheUNvbnRhaW5lcihlLmVsZW1lbnQsIHRydWUpO1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGRvbUNsYXNzZXMoY29udGFpbmVyLmh0bWwpW2UuYWRkID8gJ2FkZCcgOiAncmVtb3ZlJ10oZS5tYXJrZXIpO1xuICAgIH1cbiAgfSk7XG5cblxuICAvLyBjbGVhciBvdmVybGF5cyB3aXRoIGRpYWdyYW1cblxuICBldmVudEJ1cy5vbignZGlhZ3JhbS5jbGVhcicsIHRoaXMuY2xlYXIsIHRoaXMpO1xufTtcblxuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gY3JlYXRlUm9vdChwYXJlbnROb2RlKSB7XG4gIHZhciByb290ID0gZG9taWZ5KFxuICAgICc8ZGl2IGNsYXNzPVwiZGpzLW92ZXJsYXktY29udGFpbmVyXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAwOyBoZWlnaHQ6IDA7XCIgLz4nXG4gICk7XG5cbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocm9vdCwgcGFyZW50Tm9kZS5maXJzdENoaWxkKTtcblxuICByZXR1cm4gcm9vdDtcbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHgsIHkpIHtcbiAgYXNzaWduKGVsLnN0eWxlLCB7IGxlZnQ6IHggKyAncHgnLCB0b3A6IHkgKyAncHgnIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRWaXNpYmxlKGVsLCB2aXNpYmxlKSB7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID09PSBmYWxzZSA/ICdub25lJyA6ICcnO1xufVxuXG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIHRyYW5zZm9ybSkge1xuXG4gIGVsLnN0eWxlWyd0cmFuc2Zvcm0tb3JpZ2luJ10gPSAndG9wIGxlZnQnO1xuXG4gIFsgJycsICctbXMtJywgJy13ZWJraXQtJyBdLmZvckVhY2goZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgZWwuc3R5bGVbcHJlZml4ICsgJ3RyYW5zZm9ybSddID0gdHJhbnNmb3JtO1xuICB9KTtcbn0iLCJpbXBvcnQgT3ZlcmxheXMgZnJvbSAnLi9PdmVybGF5cyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ292ZXJsYXlzJyBdLFxuICBvdmVybGF5czogWyAndHlwZScsIE92ZXJsYXlzIF1cbn07IiwiaW1wb3J0IHtcbiAgaXNBcnJheSxcbiAgaXNGdW5jdGlvbixcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGRvbWlmeSxcbiAgcXVlcnkgYXMgZG9tUXVlcnksXG4gIGF0dHIgYXMgZG9tQXR0cixcbiAgY2xlYXIgYXMgZG9tQ2xlYXIsXG4gIGNsYXNzZXMgYXMgZG9tQ2xhc3NlcyxcbiAgbWF0Y2hlcyBhcyBkb21NYXRjaGVzLFxuICBkZWxlZ2F0ZSBhcyBkb21EZWxlZ2F0ZSxcbiAgZXZlbnQgYXMgZG9tRXZlbnRcbn0gZnJvbSAnbWluLWRvbSc7XG5cblxudmFyIFRPR0dMRV9TRUxFQ1RPUiA9ICcuZGpzLXBhbGV0dGUtdG9nZ2xlJyxcbiAgICBFTlRSWV9TRUxFQ1RPUiA9ICcuZW50cnknLFxuICAgIEVMRU1FTlRfU0VMRUNUT1IgPSBUT0dHTEVfU0VMRUNUT1IgKyAnLCAnICsgRU5UUllfU0VMRUNUT1I7XG5cbnZhciBQQUxFVFRFX09QRU5fQ0xTID0gJ29wZW4nLFxuICAgIFBBTEVUVEVfVFdPX0NPTFVNTl9DTFMgPSAndHdvLWNvbHVtbic7XG5cbnZhciBERUZBVUxUX1BSSU9SSVRZID0gMTAwMDtcblxuXG4vKipcbiAqIEEgcGFsZXR0ZSBjb250YWluaW5nIG1vZGVsaW5nIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWxldHRlKGV2ZW50QnVzLCBjYW52YXMpIHtcblxuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGV2ZW50QnVzLm9uKCd0b29sLW1hbmFnZXIudXBkYXRlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgdG9vbCA9IGV2ZW50LnRvb2w7XG5cbiAgICBzZWxmLnVwZGF0ZVRvb2xIaWdobGlnaHQodG9vbCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdpMThuLmNoYW5nZWQnLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl91cGRhdGUoKTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2RpYWdyYW0uaW5pdCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgc2VsZi5fZGlhZ3JhbUluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIHNlbGYuX3JlYnVpbGQoKTtcbiAgfSk7XG59XG5cblBhbGV0dGUuJGluamVjdCA9IFsgJ2V2ZW50QnVzJywgJ2NhbnZhcycgXTtcblxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgcHJvdmlkZXIgd2l0aCB0aGUgcGFsZXR0ZVxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gW3ByaW9yaXR5PTEwMDBdXG4gKiBAcGFyYW0gIHtQYWxldHRlUHJvdmlkZXJ9IHByb3ZpZGVyXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHBhbGV0dGVQcm92aWRlciA9IHtcbiAqICAgZ2V0UGFsZXR0ZUVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICogICAgIHJldHVybiBmdW5jdGlvbihlbnRyaWVzKSB7XG4gKiAgICAgICByZXR1cm4ge1xuICogICAgICAgICAuLi5lbnRyaWVzLFxuICogICAgICAgICAnZW50cnktMSc6IHtcbiAqICAgICAgICAgICBsYWJlbDogJ015IEVudHJ5JyxcbiAqICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkgeyBhbGVydChcIkkgaGF2ZSBiZWVuIGNsaWNrZWQhXCIpOyB9XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH07XG4gKiAgICAgfVxuICogICB9XG4gKiB9O1xuICpcbiAqIHBhbGV0dGUucmVnaXN0ZXJQcm92aWRlcig4MDAsIHBhbGV0dGVQcm92aWRlcik7XG4gKi9cblBhbGV0dGUucHJvdG90eXBlLnJlZ2lzdGVyUHJvdmlkZXIgPSBmdW5jdGlvbihwcmlvcml0eSwgcHJvdmlkZXIpIHtcbiAgaWYgKCFwcm92aWRlcikge1xuICAgIHByb3ZpZGVyID0gcHJpb3JpdHk7XG4gICAgcHJpb3JpdHkgPSBERUZBVUxUX1BSSU9SSVRZO1xuICB9XG5cbiAgdGhpcy5fZXZlbnRCdXMub24oJ3BhbGV0dGUuZ2V0UHJvdmlkZXJzJywgcHJpb3JpdHksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgZXZlbnQucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICB9KTtcblxuICB0aGlzLl9yZWJ1aWxkKCk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFsZXR0ZSBlbnRyaWVzXG4gKlxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgUGFsZXR0ZUVudHJ5RGVzY3JpcHRvcj59IG1hcCBvZiBlbnRyaWVzXG4gKi9cblBhbGV0dGUucHJvdG90eXBlLmdldEVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByb3ZpZGVycyA9IHRoaXMuX2dldFByb3ZpZGVycygpO1xuXG4gIHJldHVybiBwcm92aWRlcnMucmVkdWNlKGFkZFBhbGV0dGVFbnRyaWVzLCB7fSk7XG59O1xuXG5QYWxldHRlLnByb3RvdHlwZS5fcmVidWlsZCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICghdGhpcy5fZGlhZ3JhbUluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHByb3ZpZGVycyA9IHRoaXMuX2dldFByb3ZpZGVycygpO1xuXG4gIGlmICghcHJvdmlkZXJzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghdGhpcy5fY29udGFpbmVyKSB7XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVcbiAqL1xuUGFsZXR0ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgdmFyIHBhcmVudENvbnRhaW5lciA9IHRoaXMuX2dldFBhcmVudENvbnRhaW5lcigpO1xuXG4gIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb21pZnkoUGFsZXR0ZS5IVE1MX01BUktVUCk7XG5cbiAgcGFyZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgZG9tRGVsZWdhdGUuYmluZChjb250YWluZXIsIEVMRU1FTlRfU0VMRUNUT1IsICdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQuZGVsZWdhdGVUYXJnZXQ7XG5cbiAgICBpZiAoZG9tTWF0Y2hlcyh0YXJnZXQsIFRPR0dMRV9TRUxFQ1RPUikpIHtcbiAgICAgIHJldHVybiBzZWxmLnRvZ2dsZSgpO1xuICAgIH1cblxuICAgIHNlbGYudHJpZ2dlcignY2xpY2snLCBldmVudCk7XG4gIH0pO1xuXG4gIC8vIHByZXZlbnQgZHJhZyBwcm9wYWdhdGlvblxuICBkb21FdmVudC5iaW5kKGNvbnRhaW5lciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pO1xuXG4gIC8vIHByZXZlbnQgZHJhZyBwcm9wYWdhdGlvblxuICBkb21EZWxlZ2F0ZS5iaW5kKGNvbnRhaW5lciwgRU5UUllfU0VMRUNUT1IsICdkcmFnc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHNlbGYudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXZlbnQpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignY2FudmFzLnJlc2l6ZWQnLCB0aGlzLl9sYXlvdXRDaGFuZ2VkLCB0aGlzKTtcblxuICBldmVudEJ1cy5maXJlKCdwYWxldHRlLmNyZWF0ZScsIHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICB9KTtcbn07XG5cblBhbGV0dGUucHJvdG90eXBlLl9nZXRQcm92aWRlcnMgPSBmdW5jdGlvbihpZCkge1xuXG4gIHZhciBldmVudCA9IHRoaXMuX2V2ZW50QnVzLmNyZWF0ZUV2ZW50KHtcbiAgICB0eXBlOiAncGFsZXR0ZS5nZXRQcm92aWRlcnMnLFxuICAgIHByb3ZpZGVyczogW11cbiAgfSk7XG5cbiAgdGhpcy5fZXZlbnRCdXMuZmlyZShldmVudCk7XG5cbiAgcmV0dXJuIGV2ZW50LnByb3ZpZGVycztcbn07XG5cbi8qKlxuICogVXBkYXRlIHBhbGV0dGUgc3RhdGUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBbc3RhdGVdIHsgb3BlbiwgdHdvQ29sdW1uIH1cbiAqL1xuUGFsZXR0ZS5wcm90b3R5cGUuX3RvZ2dsZVN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcblxuICBzdGF0ZSA9IHN0YXRlIHx8IHt9O1xuXG4gIHZhciBwYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRDb250YWluZXIoKSxcbiAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuICB2YXIgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICB2YXIgdHdvQ29sdW1uO1xuXG4gIHZhciBjbHMgPSBkb21DbGFzc2VzKGNvbnRhaW5lcik7XG5cbiAgaWYgKCd0d29Db2x1bW4nIGluIHN0YXRlKSB7XG4gICAgdHdvQ29sdW1uID0gc3RhdGUudHdvQ29sdW1uO1xuICB9IGVsc2Uge1xuICAgIHR3b0NvbHVtbiA9IHRoaXMuX25lZWRzQ29sbGFwc2UocGFyZW50LmNsaWVudEhlaWdodCwgdGhpcy5fZW50cmllcyB8fCB7fSk7XG4gIH1cblxuICAvLyBhbHdheXMgdXBkYXRlIHR3byBjb2x1bW5cbiAgY2xzLnRvZ2dsZShQQUxFVFRFX1RXT19DT0xVTU5fQ0xTLCB0d29Db2x1bW4pO1xuXG4gIGlmICgnb3BlbicgaW4gc3RhdGUpIHtcbiAgICBjbHMudG9nZ2xlKFBBTEVUVEVfT1BFTl9DTFMsIHN0YXRlLm9wZW4pO1xuICB9XG5cbiAgZXZlbnRCdXMuZmlyZSgncGFsZXR0ZS5jaGFuZ2VkJywge1xuICAgIHR3b0NvbHVtbjogdHdvQ29sdW1uLFxuICAgIG9wZW46IHRoaXMuaXNPcGVuKClcbiAgfSk7XG59O1xuXG5QYWxldHRlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGVudHJpZXNDb250YWluZXIgPSBkb21RdWVyeSgnLmRqcy1wYWxldHRlLWVudHJpZXMnLCB0aGlzLl9jb250YWluZXIpLFxuICAgICAgZW50cmllcyA9IHRoaXMuX2VudHJpZXMgPSB0aGlzLmdldEVudHJpZXMoKTtcblxuICBkb21DbGVhcihlbnRyaWVzQ29udGFpbmVyKTtcblxuICBmb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5LCBpZCkge1xuXG4gICAgdmFyIGdyb3VwaW5nID0gZW50cnkuZ3JvdXAgfHwgJ2RlZmF1bHQnO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IGRvbVF1ZXJ5KCdbZGF0YS1ncm91cD0nICsgZ3JvdXBpbmcgKyAnXScsIGVudHJpZXNDb250YWluZXIpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIgPSBkb21pZnkoJzxkaXYgY2xhc3M9XCJncm91cFwiIGRhdGEtZ3JvdXA9XCInICsgZ3JvdXBpbmcgKyAnXCI+PC9kaXY+Jyk7XG4gICAgICBlbnRyaWVzQ29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgdmFyIGh0bWwgPSBlbnRyeS5odG1sIHx8IChcbiAgICAgIGVudHJ5LnNlcGFyYXRvciA/XG4gICAgICAgICc8aHIgY2xhc3M9XCJzZXBhcmF0b3JcIiAvPicgOlxuICAgICAgICAnPGRpdiBjbGFzcz1cImVudHJ5XCIgZHJhZ2dhYmxlPVwidHJ1ZVwiPjwvZGl2PicpO1xuXG5cbiAgICB2YXIgY29udHJvbCA9IGRvbWlmeShodG1sKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udHJvbCk7XG5cbiAgICBpZiAoIWVudHJ5LnNlcGFyYXRvcikge1xuICAgICAgZG9tQXR0cihjb250cm9sLCAnZGF0YS1hY3Rpb24nLCBpZCk7XG5cbiAgICAgIGlmIChlbnRyeS50aXRsZSkge1xuICAgICAgICBkb21BdHRyKGNvbnRyb2wsICd0aXRsZScsIGVudHJ5LnRpdGxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVudHJ5LmNsYXNzTmFtZSkge1xuICAgICAgICBhZGRDbGFzc2VzKGNvbnRyb2wsIGVudHJ5LmNsYXNzTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeS5pbWFnZVVybCkge1xuICAgICAgICBjb250cm9sLmFwcGVuZENoaWxkKGRvbWlmeSgnPGltZyBzcmM9XCInICsgZW50cnkuaW1hZ2VVcmwgKyAnXCI+JykpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gb3BlbiBhZnRlciB1cGRhdGVcbiAgdGhpcy5vcGVuKCk7XG59O1xuXG5cbi8qKlxuICogVHJpZ2dlciBhbiBhY3Rpb24gYXZhaWxhYmxlIG9uIHRoZSBwYWxldHRlXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBhY3Rpb25cbiAqIEBwYXJhbSAge0V2ZW50fSBldmVudFxuICovXG5QYWxldHRlLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oYWN0aW9uLCBldmVudCwgYXV0b0FjdGl2YXRlKSB7XG4gIHZhciBlbnRyaWVzID0gdGhpcy5fZW50cmllcyxcbiAgICAgIGVudHJ5LFxuICAgICAgaGFuZGxlcixcbiAgICAgIG9yaWdpbmFsRXZlbnQsXG4gICAgICBidXR0b24gPSBldmVudC5kZWxlZ2F0ZVRhcmdldCB8fCBldmVudC50YXJnZXQ7XG5cbiAgaWYgKCFidXR0b24pIHtcbiAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIGVudHJ5ID0gZW50cmllc1tkb21BdHRyKGJ1dHRvbiwgJ2RhdGEtYWN0aW9uJyldO1xuXG4gIC8vIHdoZW4gdXNlciBjbGlja3Mgb24gdGhlIHBhbGV0dGUgYW5kIG5vdCBvbiBhbiBhY3Rpb25cbiAgaWYgKCFlbnRyeSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGhhbmRsZXIgPSBlbnRyeS5hY3Rpb247XG5cbiAgb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQ7XG5cbiAgLy8gc2ltcGxlIGFjdGlvbiAodmlhIGNhbGxiYWNrIGZ1bmN0aW9uKVxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIGlmIChhY3Rpb24gPT09ICdjbGljaycpIHtcbiAgICAgIGhhbmRsZXIob3JpZ2luYWxFdmVudCwgYXV0b0FjdGl2YXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGhhbmRsZXJbYWN0aW9uXSkge1xuICAgICAgaGFuZGxlclthY3Rpb25dKG9yaWdpbmFsRXZlbnQsIGF1dG9BY3RpdmF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2lsZW5jZSBvdGhlciBhY3Rpb25zXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG5QYWxldHRlLnByb3RvdHlwZS5fbGF5b3V0Q2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl90b2dnbGVTdGF0ZSh7fSk7XG59O1xuXG4vKipcbiAqIERvIHdlIG5lZWQgdG8gY29sbGFwc2UgdG8gdHdvIGNvbHVtbnM/XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGF2YWlsYWJsZUhlaWdodFxuICogQHBhcmFtIHtPYmplY3R9IGVudHJpZXNcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5QYWxldHRlLnByb3RvdHlwZS5fbmVlZHNDb2xsYXBzZSA9IGZ1bmN0aW9uKGF2YWlsYWJsZUhlaWdodCwgZW50cmllcykge1xuXG4gIC8vIHRvcCBtYXJnaW4gKyBib3R0b20gdG9nZ2xlICsgYm90dG9tIG1hcmdpblxuICAvLyBpbXBsZW1lbnRvcnMgbXVzdCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5XG4gIC8vIGNoYW5nZSB0aGUgcGFsZXR0ZSBzdHlsZXNcbiAgdmFyIG1hcmdpbiA9IDIwICsgMTAgKyAyMDtcblxuICB2YXIgZW50cmllc0hlaWdodCA9IE9iamVjdC5rZXlzKGVudHJpZXMpLmxlbmd0aCAqIDQ2O1xuXG4gIHJldHVybiBhdmFpbGFibGVIZWlnaHQgPCBlbnRyaWVzSGVpZ2h0ICsgbWFyZ2luO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgcGFsZXR0ZVxuICovXG5QYWxldHRlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXG4gIHRoaXMuX3RvZ2dsZVN0YXRlKHtcbiAgICBvcGVuOiBmYWxzZSxcbiAgICB0d29Db2x1bW46IGZhbHNlXG4gIH0pO1xufTtcblxuXG4vKipcbiAqIE9wZW4gdGhlIHBhbGV0dGVcbiAqL1xuUGFsZXR0ZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl90b2dnbGVTdGF0ZSh7IG9wZW46IHRydWUgfSk7XG59O1xuXG5cblBhbGV0dGUucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKG9wZW4pIHtcbiAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcGVuKCk7XG4gIH1cbn07XG5cblBhbGV0dGUucHJvdG90eXBlLmlzQWN0aXZlVG9vbCA9IGZ1bmN0aW9uKHRvb2wpIHtcbiAgcmV0dXJuIHRvb2wgJiYgdGhpcy5fYWN0aXZlVG9vbCA9PT0gdG9vbDtcbn07XG5cblBhbGV0dGUucHJvdG90eXBlLnVwZGF0ZVRvb2xIaWdobGlnaHQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBlbnRyaWVzQ29udGFpbmVyLFxuICAgICAgdG9vbHNDb250YWluZXI7XG5cbiAgaWYgKCF0aGlzLl90b29sc0NvbnRhaW5lcikge1xuICAgIGVudHJpZXNDb250YWluZXIgPSBkb21RdWVyeSgnLmRqcy1wYWxldHRlLWVudHJpZXMnLCB0aGlzLl9jb250YWluZXIpO1xuXG4gICAgdGhpcy5fdG9vbHNDb250YWluZXIgPSBkb21RdWVyeSgnW2RhdGEtZ3JvdXA9dG9vbHNdJywgZW50cmllc0NvbnRhaW5lcik7XG4gIH1cblxuICB0b29sc0NvbnRhaW5lciA9IHRoaXMuX3Rvb2xzQ29udGFpbmVyO1xuXG4gIGZvckVhY2godG9vbHNDb250YWluZXIuY2hpbGRyZW4sIGZ1bmN0aW9uKHRvb2wpIHtcbiAgICB2YXIgYWN0aW9uTmFtZSA9IHRvb2wuZ2V0QXR0cmlidXRlKCdkYXRhLWFjdGlvbicpO1xuXG4gICAgaWYgKCFhY3Rpb25OYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvb2xDbGFzc2VzID0gZG9tQ2xhc3Nlcyh0b29sKTtcblxuICAgIGFjdGlvbk5hbWUgPSBhY3Rpb25OYW1lLnJlcGxhY2UoJy10b29sJywgJycpO1xuXG4gICAgaWYgKHRvb2xDbGFzc2VzLmNvbnRhaW5zKCdlbnRyeScpICYmIGFjdGlvbk5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHRvb2xDbGFzc2VzLmFkZCgnaGlnaGxpZ2h0ZWQtZW50cnknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9vbENsYXNzZXMucmVtb3ZlKCdoaWdobGlnaHRlZC1lbnRyeScpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHBhbGV0dGUgaXMgb3BlbmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogcGFsZXR0ZS5vcGVuKCk7XG4gKlxuICogaWYgKHBhbGV0dGUuaXNPcGVuKCkpIHtcbiAqICAgLy8geWVzLCB3ZSBhcmUgb3BlblxuICogfVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgcGFsZXR0ZSBpcyBvcGVuZWRcbiAqL1xuUGFsZXR0ZS5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBkb21DbGFzc2VzKHRoaXMuX2NvbnRhaW5lcikuaGFzKFBBTEVUVEVfT1BFTl9DTFMpO1xufTtcblxuLyoqXG4gKiBHZXQgY29udGFpbmVyIHRoZSBwYWxldHRlIGxpdmVzIGluLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cblBhbGV0dGUucHJvdG90eXBlLl9nZXRQYXJlbnRDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NhbnZhcy5nZXRDb250YWluZXIoKTtcbn07XG5cblxuLyogbWFya3VwIGRlZmluaXRpb24gKi9cblxuUGFsZXR0ZS5IVE1MX01BUktVUCA9XG4gICc8ZGl2IGNsYXNzPVwiZGpzLXBhbGV0dGVcIj4nICtcbiAgICAnPGRpdiBjbGFzcz1cImRqcy1wYWxldHRlLWVudHJpZXNcIj48L2Rpdj4nICtcbiAgICAnPGRpdiBjbGFzcz1cImRqcy1wYWxldHRlLXRvZ2dsZVwiPjwvZGl2PicgK1xuICAnPC9kaXY+JztcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gYWRkQ2xhc3NlcyhlbGVtZW50LCBjbGFzc05hbWVzKSB7XG5cbiAgdmFyIGNsYXNzZXMgPSBkb21DbGFzc2VzKGVsZW1lbnQpO1xuXG4gIHZhciBhY3R1YWxDbGFzc05hbWVzID0gaXNBcnJheShjbGFzc05hbWVzKSA/IGNsYXNzTmFtZXMgOiBjbGFzc05hbWVzLnNwbGl0KC9cXHMrL2cpO1xuICBhY3R1YWxDbGFzc05hbWVzLmZvckVhY2goZnVuY3Rpb24oY2xzKSB7XG4gICAgY2xhc3Nlcy5hZGQoY2xzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFBhbGV0dGVFbnRyaWVzKGVudHJpZXMsIHByb3ZpZGVyKSB7XG5cbiAgdmFyIGVudHJpZXNPclVwZGF0ZXIgPSBwcm92aWRlci5nZXRQYWxldHRlRW50cmllcygpO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGVudHJpZXNPclVwZGF0ZXIpKSB7XG4gICAgcmV0dXJuIGVudHJpZXNPclVwZGF0ZXIoZW50cmllcyk7XG4gIH1cblxuICBmb3JFYWNoKGVudHJpZXNPclVwZGF0ZXIsIGZ1bmN0aW9uKGVudHJ5LCBpZCkge1xuICAgIGVudHJpZXNbaWRdID0gZW50cnk7XG4gIH0pO1xuXG4gIHJldHVybiBlbnRyaWVzO1xufSIsImltcG9ydCBQYWxldHRlIGZyb20gJy4vUGFsZXR0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ3BhbGV0dGUnIF0sXG4gIHBhbGV0dGU6IFsgJ3R5cGUnLCBQYWxldHRlIF1cbn07XG4iLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZvckVhY2gsXG4gIGlzRnVuY3Rpb24sXG4gIGlzRGVmaW5lZCxcbiAgb21pdCxcbiAgc2l6ZVxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGRlbGVnYXRlIGFzIGRvbURlbGVnYXRlLFxuICBkb21pZnkgYXMgZG9taWZ5LFxuICBjbGFzc2VzIGFzIGRvbUNsYXNzZXMsXG4gIGF0dHIgYXMgZG9tQXR0cixcbiAgcmVtb3ZlIGFzIGRvbVJlbW92ZVxufSBmcm9tICdtaW4tZG9tJztcblxudmFyIERBVEFfUkVGID0gJ2RhdGEtaWQnO1xuXG52YXIgQ0xPU0VfRVZFTlRTID0gW1xuICAnY29udGV4dFBhZC5jbG9zZScsXG4gICdjYW52YXMudmlld2JveC5jaGFuZ2luZycsXG4gICdjb21tYW5kU3RhY2suY2hhbmdlZCdcbl07XG5cbnZhciBERUZBVUxUX1BSSU9SSVRZID0gMTAwMDtcblxuXG4vKipcbiAqIEEgcG9wdXAgbWVudSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgYSBsaXN0IG9mIGFjdGlvbnMgYW55d2hlcmUgaW4gdGhlIGNhbnZhcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbY29uZmlnLnNjYWxlPXsgbWluOiAxLjAsIG1heDogMS41IH1dXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5zY2FsZS5taW5dXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5zY2FsZS5tYXhdXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvcHVwTWVudShjb25maWcsIGV2ZW50QnVzLCBjYW52YXMpIHtcblxuICB2YXIgc2NhbGUgPSBpc0RlZmluZWQoY29uZmlnICYmIGNvbmZpZy5zY2FsZSkgPyBjb25maWcuc2NhbGUgOiB7XG4gICAgbWluOiAxLFxuICAgIG1heDogMS41XG4gIH07XG5cbiAgdGhpcy5fY29uZmlnID0ge1xuICAgIHNjYWxlOiBzY2FsZVxuICB9O1xuXG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fcHJvdmlkZXJzID0ge307XG4gIHRoaXMuX2N1cnJlbnQgPSB7fTtcbn1cblxuUG9wdXBNZW51LiRpbmplY3QgPSBbXG4gICdjb25maWcucG9wdXBNZW51JyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcydcbl07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgcG9wdXAgbWVudSBwcm92aWRlclxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MTAwMF1cbiAqIEBwYXJhbSAge09iamVjdH0gcHJvdmlkZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcG9wdXBNZW51UHJvdmlkZXIgPSB7XG4gKiAgIGdldFBvcHVwTWVudUVudHJpZXM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAqICAgICByZXR1cm4ge1xuICogICAgICAgJ2VudHJ5LTEnOiB7XG4gKiAgICAgICAgIGxhYmVsOiAnTXkgRW50cnknLFxuICogICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkgeyBhbGVydChcIkkgaGF2ZSBiZWVuIGNsaWNrZWQhXCIpOyB9XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9O1xuICpcbiAqIHBvcHVwTWVudS5yZWdpc3RlclByb3ZpZGVyKCdteU1lbnVJRCcsIHBvcHVwTWVudVByb3ZpZGVyKTtcbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS5yZWdpc3RlclByb3ZpZGVyID0gZnVuY3Rpb24oaWQsIHByaW9yaXR5LCBwcm92aWRlcikge1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgcHJvdmlkZXIgPSBwcmlvcml0eTtcbiAgICBwcmlvcml0eSA9IERFRkFVTFRfUFJJT1JJVFk7XG4gIH1cblxuICB0aGlzLl9ldmVudEJ1cy5vbigncG9wdXBNZW51LmdldFByb3ZpZGVycy4nICsgaWQsIHByaW9yaXR5LCBmdW5jdGlvbihldmVudCkge1xuICAgIGV2ZW50LnByb3ZpZGVycy5wdXNoKHByb3ZpZGVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgcG9wdXAgbWVudSBoYXMgZW50cmllcy5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGVtcHR5XG4gKi9cblBvcHVwTWVudS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3ZpZGVySWQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IHBhcmFtZXRlciBpcyBtaXNzaW5nJyk7XG4gIH1cblxuICBpZiAoIXByb3ZpZGVySWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3ZpZGVySWQgcGFyYW1ldGVyIGlzIG1pc3NpbmcnKTtcbiAgfVxuXG4gIHZhciBwcm92aWRlcnMgPSB0aGlzLl9nZXRQcm92aWRlcnMocHJvdmlkZXJJZCk7XG5cbiAgaWYgKCFwcm92aWRlcnMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5fZ2V0RW50cmllcyhlbGVtZW50LCBwcm92aWRlcnMpLFxuICAgICAgaGVhZGVyRW50cmllcyA9IHRoaXMuX2dldEhlYWRlckVudHJpZXMoZWxlbWVudCwgcHJvdmlkZXJzKTtcblxuICB2YXIgaGFzRW50cmllcyA9IHNpemUoZW50cmllcykgPiAwLFxuICAgICAgaGFzSGVhZGVyRW50cmllcyA9IGhlYWRlckVudHJpZXMgJiYgc2l6ZShoZWFkZXJFbnRyaWVzKSA+IDA7XG5cbiAgcmV0dXJuICFoYXNFbnRyaWVzICYmICFoYXNIZWFkZXJFbnRyaWVzO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBlbnRyaWVzIGFuZCBvcGVuIHBvcHVwIG1lbnUgYXQgZ2l2ZW4gcG9zaXRpb25cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGVsZW1lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gaWQgcHJvdmlkZXIgaWRcbiAqIEBwYXJhbSAge09iamVjdH0gcG9zaXRpb25cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBvcHVwIG1lbnUgaW5zdGFuY2VcbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oZWxlbWVudCwgaWQsIHBvc2l0aW9uKSB7XG5cbiAgdmFyIHByb3ZpZGVycyA9IHRoaXMuX2dldFByb3ZpZGVycyhpZCk7XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IGlzIG1pc3NpbmcnKTtcbiAgfVxuXG4gIGlmICghcHJvdmlkZXJzIHx8ICFwcm92aWRlcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyByZWdpc3RlcmVkIHByb3ZpZGVycyBmb3I6ICcgKyBpZCk7XG4gIH1cblxuICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgcG9zaXRpb24gYXJndW1lbnQgaXMgbWlzc2luZycpO1xuICB9XG5cbiAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICB0aGlzLl9lbWl0KCdvcGVuJyk7XG5cbiAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50ID0ge1xuICAgIGNsYXNzTmFtZTogaWQsXG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfTtcblxuICB2YXIgZW50cmllcyA9IHRoaXMuX2dldEVudHJpZXMoZWxlbWVudCwgcHJvdmlkZXJzKSxcbiAgICAgIGhlYWRlckVudHJpZXMgPSB0aGlzLl9nZXRIZWFkZXJFbnRyaWVzKGVsZW1lbnQsIHByb3ZpZGVycyk7XG5cbiAgY3VycmVudC5lbnRyaWVzID0gYXNzaWduKHt9LCBlbnRyaWVzLCBoZWFkZXJFbnRyaWVzKTtcblxuICBjdXJyZW50LmNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lcigpO1xuXG4gIGlmIChzaXplKGhlYWRlckVudHJpZXMpKSB7XG4gICAgY3VycmVudC5jb250YWluZXIuYXBwZW5kQ2hpbGQoXG4gICAgICB0aGlzLl9jcmVhdGVFbnRyaWVzKGhlYWRlckVudHJpZXMsICdkanMtcG9wdXAtaGVhZGVyJylcbiAgICApO1xuICB9XG5cbiAgaWYgKHNpemUoZW50cmllcykpIHtcbiAgICBjdXJyZW50LmNvbnRhaW5lci5hcHBlbmRDaGlsZChcbiAgICAgIHRoaXMuX2NyZWF0ZUVudHJpZXMoZW50cmllcywgJ2Rqcy1wb3B1cC1ib2R5JylcbiAgICApO1xuICB9XG5cbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcyxcbiAgICAgIHBhcmVudCA9IGNhbnZhcy5nZXRDb250YWluZXIoKTtcblxuICB0aGlzLl9hdHRhY2hDb250YWluZXIoY3VycmVudC5jb250YWluZXIsIHBhcmVudCwgcG9zaXRpb24uY3Vyc29yKTtcbiAgdGhpcy5fYmluZEF1dG9DbG9zZSgpO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHBvcHVwIG1lbnUgYW5kIHVuYmluZHMgdGhlIGV2ZW50IGhhbmRsZXJzLlxuICovXG5Qb3B1cE1lbnUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKCF0aGlzLmlzT3BlbigpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fZW1pdCgnY2xvc2UnKTtcblxuICB0aGlzLl91bmJpbmRBdXRvQ2xvc2UoKTtcbiAgZG9tUmVtb3ZlKHRoaXMuX2N1cnJlbnQuY29udGFpbmVyKTtcbiAgdGhpcy5fY3VycmVudC5jb250YWluZXIgPSBudWxsO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBvcGVuIHBvcHVwIG1lbnUgZXhpc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBvcGVuXG4gKi9cblBvcHVwTWVudS5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIXRoaXMuX2N1cnJlbnQuY29udGFpbmVyO1xufTtcblxuXG4vKipcbiAqIFRyaWdnZXIgYW4gYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCBhbiBlbnRyeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGFjdGlvbiBjYWxsYmFjaywgaWYgYW55XG4gKi9cblBvcHVwTWVudS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgLy8gc2lsZW5jZSBvdGhlciBhY3Rpb25zXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgdmFyIGVsZW1lbnQgPSBldmVudC5kZWxlZ2F0ZVRhcmdldCB8fCBldmVudC50YXJnZXQsXG4gICAgICBlbnRyeUlkID0gZG9tQXR0cihlbGVtZW50LCBEQVRBX1JFRik7XG5cbiAgdmFyIGVudHJ5ID0gdGhpcy5fZ2V0RW50cnkoZW50cnlJZCk7XG5cbiAgaWYgKGVudHJ5LmFjdGlvbikge1xuICAgIHJldHVybiBlbnRyeS5hY3Rpb24uY2FsbChudWxsLCBldmVudCwgZW50cnkpO1xuICB9XG59O1xuXG5Qb3B1cE1lbnUucHJvdG90eXBlLl9nZXRQcm92aWRlcnMgPSBmdW5jdGlvbihpZCkge1xuXG4gIHZhciBldmVudCA9IHRoaXMuX2V2ZW50QnVzLmNyZWF0ZUV2ZW50KHtcbiAgICB0eXBlOiAncG9wdXBNZW51LmdldFByb3ZpZGVycy4nICsgaWQsXG4gICAgcHJvdmlkZXJzOiBbXVxuICB9KTtcblxuICB0aGlzLl9ldmVudEJ1cy5maXJlKGV2ZW50KTtcblxuICByZXR1cm4gZXZlbnQucHJvdmlkZXJzO1xufTtcblxuUG9wdXBNZW51LnByb3RvdHlwZS5fZ2V0RW50cmllcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3ZpZGVycykge1xuXG4gIHZhciBlbnRyaWVzID0ge307XG5cbiAgZm9yRWFjaChwcm92aWRlcnMsIGZ1bmN0aW9uKHByb3ZpZGVyKSB7XG5cbiAgICAvLyBoYW5kbGUgbGVnYWN5IG1ldGhvZFxuICAgIGlmICghcHJvdmlkZXIuZ2V0UG9wdXBNZW51RW50cmllcykge1xuICAgICAgZm9yRWFjaChwcm92aWRlci5nZXRFbnRyaWVzKGVsZW1lbnQpLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICB2YXIgaWQgPSBlbnRyeS5pZDtcblxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmVyeSBlbnRyeSBtdXN0IGhhdmUgdGhlIGlkIHByb3BlcnR5IHNldCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW50cmllc1tpZF0gPSBvbWl0KGVudHJ5LCBbICdpZCcgXSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbnRyaWVzT3JVcGRhdGVyID0gcHJvdmlkZXIuZ2V0UG9wdXBNZW51RW50cmllcyhlbGVtZW50KTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGVudHJpZXNPclVwZGF0ZXIpKSB7XG4gICAgICBlbnRyaWVzID0gZW50cmllc09yVXBkYXRlcihlbnRyaWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yRWFjaChlbnRyaWVzT3JVcGRhdGVyLCBmdW5jdGlvbihlbnRyeSwgaWQpIHtcbiAgICAgICAgZW50cmllc1tpZF0gPSBlbnRyeTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVudHJpZXM7XG59O1xuXG5Qb3B1cE1lbnUucHJvdG90eXBlLl9nZXRIZWFkZXJFbnRyaWVzID0gZnVuY3Rpb24oZWxlbWVudCwgcHJvdmlkZXJzKSB7XG5cbiAgdmFyIGVudHJpZXMgPSB7fTtcblxuICBmb3JFYWNoKHByb3ZpZGVycywgZnVuY3Rpb24ocHJvdmlkZXIpIHtcblxuICAgIC8vIGhhbmRsZSBsZWdhY3kgbWV0aG9kXG4gICAgaWYgKCFwcm92aWRlci5nZXRQb3B1cE1lbnVIZWFkZXJFbnRyaWVzKSB7XG4gICAgICBpZiAoIXByb3ZpZGVyLmdldEhlYWRlckVudHJpZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3JFYWNoKHByb3ZpZGVyLmdldEhlYWRlckVudHJpZXMoZWxlbWVudCksIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHZhciBpZCA9IGVudHJ5LmlkO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V2ZXJ5IGVudHJ5IG11c3QgaGF2ZSB0aGUgaWQgcHJvcGVydHkgc2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBlbnRyaWVzW2lkXSA9IG9taXQoZW50cnksIFsgJ2lkJyBdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVudHJpZXNPclVwZGF0ZXIgPSBwcm92aWRlci5nZXRQb3B1cE1lbnVIZWFkZXJFbnRyaWVzKGVsZW1lbnQpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZW50cmllc09yVXBkYXRlcikpIHtcbiAgICAgIGVudHJpZXMgPSBlbnRyaWVzT3JVcGRhdGVyKGVudHJpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoKGVudHJpZXNPclVwZGF0ZXIsIGZ1bmN0aW9uKGVudHJ5LCBpZCkge1xuICAgICAgICBlbnRyaWVzW2lkXSA9IGVudHJ5O1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZW50cmllcztcblxuXG59O1xuXG4vKipcbiAqIEdldHMgYW4gZW50cnkgaW5zdGFuY2UgKGVpdGhlciBlbnRyeSBvciBoZWFkZXJFbnRyeSkgYnkgaWQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBlbnRyeUlkXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBlbnRyeSBpbnN0YW5jZVxuICovXG5Qb3B1cE1lbnUucHJvdG90eXBlLl9nZXRFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5SWQpIHtcblxuICB2YXIgZW50cnkgPSB0aGlzLl9jdXJyZW50LmVudHJpZXNbZW50cnlJZF07XG5cbiAgaWYgKCFlbnRyeSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZW50cnkgbm90IGZvdW5kJyk7XG4gIH1cblxuICByZXR1cm4gZW50cnk7XG59O1xuXG5Qb3B1cE1lbnUucHJvdG90eXBlLl9lbWl0ID0gZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ3BvcHVwTWVudS4nICsgZXZlbnROYW1lKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgcG9wdXAgbWVudSBjb250YWluZXIuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBhIERPTSBjb250YWluZXJcbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS5fY3JlYXRlQ29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250YWluZXIgPSBkb21pZnkoJzxkaXYgY2xhc3M9XCJkanMtcG9wdXBcIj4nKSxcbiAgICAgIHBvc2l0aW9uID0gdGhpcy5fY3VycmVudC5wb3NpdGlvbixcbiAgICAgIGNsYXNzTmFtZSA9IHRoaXMuX2N1cnJlbnQuY2xhc3NOYW1lO1xuXG4gIGFzc2lnbihjb250YWluZXIuc3R5bGUsIHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBsZWZ0OiBwb3NpdGlvbi54ICsgJ3B4JyxcbiAgICB0b3A6IHBvc2l0aW9uLnkgKyAncHgnLFxuICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nXG4gIH0pO1xuXG4gIGRvbUNsYXNzZXMoY29udGFpbmVyKS5hZGQoY2xhc3NOYW1lKTtcblxuICByZXR1cm4gY29udGFpbmVyO1xufTtcblxuXG4vKipcbiAqIEF0dGFjaGVzIHRoZSBjb250YWluZXIgdG8gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKi9cblBvcHVwTWVudS5wcm90b3R5cGUuX2F0dGFjaENvbnRhaW5lciA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcGFyZW50LCBjdXJzb3IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIEV2ZW50IGhhbmRsZXJcbiAgZG9tRGVsZWdhdGUuYmluZChjb250YWluZXIsICcuZW50cnknICwnY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgIHNlbGYudHJpZ2dlcihldmVudCk7XG4gIH0pO1xuXG4gIHRoaXMuX3VwZGF0ZVNjYWxlKGNvbnRhaW5lcik7XG5cbiAgLy8gQXR0YWNoIHRvIERPTVxuICBwYXJlbnQuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICBpZiAoY3Vyc29yKSB7XG4gICAgdGhpcy5fYXNzdXJlSXNJbmJvdW5kcyhjb250YWluZXIsIGN1cnNvcik7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHBvcHVwIHN0eWxlLnRyYW5zZm9ybSB3aXRoIHJlc3BlY3QgdG8gdGhlIGNvbmZpZyBhbmQgem9vbSBsZXZlbC5cbiAqXG4gKiBAbWV0aG9kIF91cGRhdGVTY2FsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJcbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS5fdXBkYXRlU2NhbGUgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgdmFyIHpvb20gPSB0aGlzLl9jYW52YXMuem9vbSgpO1xuXG4gIHZhciBzY2FsZUNvbmZpZyA9IHRoaXMuX2NvbmZpZy5zY2FsZSxcbiAgICAgIG1pblNjYWxlLFxuICAgICAgbWF4U2NhbGUsXG4gICAgICBzY2FsZSA9IHpvb207XG5cbiAgaWYgKHNjYWxlQ29uZmlnICE9PSB0cnVlKSB7XG5cbiAgICBpZiAoc2NhbGVDb25maWcgPT09IGZhbHNlKSB7XG4gICAgICBtaW5TY2FsZSA9IDE7XG4gICAgICBtYXhTY2FsZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pblNjYWxlID0gc2NhbGVDb25maWcubWluO1xuICAgICAgbWF4U2NhbGUgPSBzY2FsZUNvbmZpZy5tYXg7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmaW5lZChtaW5TY2FsZSkgJiYgem9vbSA8IG1pblNjYWxlKSB7XG4gICAgICBzY2FsZSA9IG1pblNjYWxlO1xuICAgIH1cblxuICAgIGlmIChpc0RlZmluZWQobWF4U2NhbGUpICYmIHpvb20gPiBtYXhTY2FsZSkge1xuICAgICAgc2NhbGUgPSBtYXhTY2FsZTtcbiAgICB9XG5cbiAgfVxuXG4gIHNldFRyYW5zZm9ybShjb250YWluZXIsICdzY2FsZSgnICsgc2NhbGUgKyAnKScpO1xufTtcblxuXG4vKipcbiAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBtZW51IGlzIGFsd2F5cyBmdWxseSBzaG93blxuICpcbiAqIEBtZXRob2QgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRhaW5lclxuICogQHBhcmFtICB7UG9zaXRpb259IGN1cnNvciB7eCwgeX1cbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS5fYXNzdXJlSXNJbmJvdW5kcyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgY3Vyc29yKSB7XG4gIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXMsXG4gICAgICBjbGllbnRSZWN0ID0gY2FudmFzLl9jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgdmFyIGNvbnRhaW5lclggPSBjb250YWluZXIub2Zmc2V0TGVmdCxcbiAgICAgIGNvbnRhaW5lclkgPSBjb250YWluZXIub2Zmc2V0VG9wLFxuICAgICAgY29udGFpbmVyV2lkdGggPSBjb250YWluZXIuc2Nyb2xsV2lkdGgsXG4gICAgICBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXIuc2Nyb2xsSGVpZ2h0LFxuICAgICAgb3ZlckF4aXMgPSB7fSxcbiAgICAgIGxlZnQsIHRvcDtcblxuICB2YXIgY3Vyc29yUG9zaXRpb24gPSB7XG4gICAgeDogY3Vyc29yLnggLSBjbGllbnRSZWN0LmxlZnQsXG4gICAgeTogY3Vyc29yLnkgLSBjbGllbnRSZWN0LnRvcFxuICB9O1xuXG4gIGlmIChjb250YWluZXJYICsgY29udGFpbmVyV2lkdGggPiBjbGllbnRSZWN0LndpZHRoKSB7XG4gICAgb3ZlckF4aXMueCA9IHRydWU7XG4gIH1cblxuICBpZiAoY29udGFpbmVyWSArIGNvbnRhaW5lckhlaWdodCA+IGNsaWVudFJlY3QuaGVpZ2h0KSB7XG4gICAgb3ZlckF4aXMueSA9IHRydWU7XG4gIH1cblxuICBpZiAob3ZlckF4aXMueCAmJiBvdmVyQXhpcy55KSB7XG4gICAgbGVmdCA9IGN1cnNvclBvc2l0aW9uLnggLSBjb250YWluZXJXaWR0aCArICdweCc7XG4gICAgdG9wID0gY3Vyc29yUG9zaXRpb24ueSAtIGNvbnRhaW5lckhlaWdodCArICdweCc7XG4gIH0gZWxzZSBpZiAob3ZlckF4aXMueCkge1xuICAgIGxlZnQgPSBjdXJzb3JQb3NpdGlvbi54IC0gY29udGFpbmVyV2lkdGggKyAncHgnO1xuICAgIHRvcCA9IGN1cnNvclBvc2l0aW9uLnkgKyAncHgnO1xuICB9IGVsc2UgaWYgKG92ZXJBeGlzLnkgJiYgY3Vyc29yUG9zaXRpb24ueSA8IGNvbnRhaW5lckhlaWdodCkge1xuICAgIGxlZnQgPSBjdXJzb3JQb3NpdGlvbi54ICsgJ3B4JztcbiAgICB0b3AgPSAxMCArICdweCc7XG4gIH0gZWxzZSBpZiAob3ZlckF4aXMueSkge1xuICAgIGxlZnQgPSBjdXJzb3JQb3NpdGlvbi54ICsgJ3B4JztcbiAgICB0b3AgPSBjdXJzb3JQb3NpdGlvbi55IC0gY29udGFpbmVySGVpZ2h0ICsgJ3B4JztcbiAgfVxuXG4gIGFzc2lnbihjb250YWluZXIuc3R5bGUsIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfSwgeyB2aXNpYmlsaXR5OiAndmlzaWJsZScsICd6LWluZGV4JzogMTAwMCB9KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbGlzdCBvZiBlbnRyaWVzIGFuZCByZXR1cm5zIHRoZW0gYXMgYSBET00gY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZW50cmllcyBhbiBhcnJheSBvZiBlbnRyeSBvYmplY3RzXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBjbGFzcyBuYW1lIG9mIHRoZSBlbnRyeSBjb250YWluZXJcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgRE9NIGNvbnRhaW5lclxuICovXG5Qb3B1cE1lbnUucHJvdG90eXBlLl9jcmVhdGVFbnRyaWVzID0gZnVuY3Rpb24oZW50cmllcywgY2xhc3NOYW1lKSB7XG5cbiAgdmFyIGVudHJpZXNDb250YWluZXIgPSBkb21pZnkoJzxkaXY+JyksXG4gICAgICBzZWxmID0gdGhpcztcblxuICBkb21DbGFzc2VzKGVudHJpZXNDb250YWluZXIpLmFkZChjbGFzc05hbWUpO1xuXG4gIGZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnksIGlkKSB7XG4gICAgdmFyIGVudHJ5Q29udGFpbmVyID0gc2VsZi5fY3JlYXRlRW50cnkoZW50cnksIGlkKTtcbiAgICBlbnRyaWVzQ29udGFpbmVyLmFwcGVuZENoaWxkKGVudHJ5Q29udGFpbmVyKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVudHJpZXNDb250YWluZXI7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHNpbmdsZSBlbnRyeSBhbmQgcmV0dXJucyBpdCBhcyBhIERPTSBjb250YWluZXIuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBlbnRyeVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gYSBET00gY29udGFpbmVyXG4gKi9cblBvcHVwTWVudS5wcm90b3R5cGUuX2NyZWF0ZUVudHJ5ID0gZnVuY3Rpb24oZW50cnksIGlkKSB7XG5cbiAgdmFyIGVudHJ5Q29udGFpbmVyID0gZG9taWZ5KCc8ZGl2PicpLFxuICAgICAgZW50cnlDbGFzc2VzID0gZG9tQ2xhc3NlcyhlbnRyeUNvbnRhaW5lcik7XG5cbiAgZW50cnlDbGFzc2VzLmFkZCgnZW50cnknKTtcblxuICBpZiAoZW50cnkuY2xhc3NOYW1lKSB7XG4gICAgZW50cnkuY2xhc3NOYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgIGVudHJ5Q2xhc3Nlcy5hZGQoY2xhc3NOYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRvbUF0dHIoZW50cnlDb250YWluZXIsIERBVEFfUkVGLCBpZCk7XG5cbiAgaWYgKGVudHJ5LmxhYmVsKSB7XG4gICAgdmFyIGxhYmVsID0gZG9taWZ5KCc8c3Bhbj4nKTtcbiAgICBsYWJlbC50ZXh0Q29udGVudCA9IGVudHJ5LmxhYmVsO1xuICAgIGVudHJ5Q29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgfVxuXG4gIGlmIChlbnRyeS5pbWFnZVVybCkge1xuICAgIGVudHJ5Q29udGFpbmVyLmFwcGVuZENoaWxkKGRvbWlmeSgnPGltZyBzcmM9XCInICsgZW50cnkuaW1hZ2VVcmwgKyAnXCIgLz4nKSk7XG4gIH1cblxuICBpZiAoZW50cnkuYWN0aXZlID09PSB0cnVlKSB7XG4gICAgZW50cnlDbGFzc2VzLmFkZCgnYWN0aXZlJyk7XG4gIH1cblxuICBpZiAoZW50cnkuZGlzYWJsZWQgPT09IHRydWUpIHtcbiAgICBlbnRyeUNsYXNzZXMuYWRkKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgaWYgKGVudHJ5LnRpdGxlKSB7XG4gICAgZW50cnlDb250YWluZXIudGl0bGUgPSBlbnRyeS50aXRsZTtcbiAgfVxuXG4gIHJldHVybiBlbnRyeUNvbnRhaW5lcjtcbn07XG5cblxuLyoqXG4gKiBTZXQgdXAgbGlzdGVuZXIgdG8gY2xvc2UgcG9wdXAgYXV0b21hdGljYWxseSBvbiBjZXJ0YWluIGV2ZW50cy5cbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS5fYmluZEF1dG9DbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9ldmVudEJ1cy5vbmNlKENMT1NFX0VWRU5UUywgdGhpcy5jbG9zZSwgdGhpcyk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIHRoZSBhdXRvLWNsb3NpbmcgbGlzdGVuZXIuXG4gKi9cblBvcHVwTWVudS5wcm90b3R5cGUuX3VuYmluZEF1dG9DbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9ldmVudEJ1cy5vZmYoQ0xPU0VfRVZFTlRTLCB0aGlzLmNsb3NlLCB0aGlzKTtcbn07XG5cblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbGVtZW50LCB0cmFuc2Zvcm0pIHtcbiAgZWxlbWVudC5zdHlsZVsndHJhbnNmb3JtLW9yaWdpbiddID0gJ3RvcCBsZWZ0JztcblxuICBbICcnLCAnLW1zLScsICctd2Via2l0LScgXS5mb3JFYWNoKGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIGVsZW1lbnQuc3R5bGVbcHJlZml4ICsgJ3RyYW5zZm9ybSddID0gdHJhbnNmb3JtO1xuICB9KTtcbn0iLCJpbXBvcnQgUG9wdXBNZW51IGZyb20gJy4vUG9wdXBNZW51JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAncG9wdXBNZW51JyBdLFxuICBwb3B1cE1lbnU6IFsgJ3R5cGUnLCBQb3B1cE1lbnUgXVxufTtcbiIsImltcG9ydCB7XHJcbiAgZm9yRWFjaFxyXG59IGZyb20gJ21pbi1kYXNoJztcclxuXHJcbmltcG9ydCB7XHJcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcclxuICBhdHRyIGFzIHN2Z0F0dHIsXHJcbiAgY2xhc3NlcyBhcyBzdmdDbGFzc2VzLFxyXG4gIGNsb25lIGFzIHN2Z0Nsb25lLFxyXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXHJcbiAgcmVtb3ZlIGFzIHN2Z1JlbW92ZVxyXG59IGZyb20gJ3Rpbnktc3ZnJztcclxuXHJcbmltcG9ydCB7IHF1ZXJ5IGFzIGRvbVF1ZXJ5IH0gZnJvbSAnbWluLWRvbSc7XHJcblxyXG5pbXBvcnQgeyBnZXRWaXN1YWwgfSBmcm9tICcuLi8uLi91dGlsL0dyYXBoaWNzVXRpbCc7XHJcblxyXG52YXIgTUFSS0VSX1RZUEVTID0gW1xyXG4gICdtYXJrZXItc3RhcnQnLFxyXG4gICdtYXJrZXItbWlkJyxcclxuICAnbWFya2VyLWVuZCdcclxuXTtcclxuXHJcbnZhciBOT0RFU19DQU5fSEFWRV9NQVJLRVIgPSBbXHJcbiAgJ2NpcmNsZScsXHJcbiAgJ2VsbGlwc2UnLFxyXG4gICdsaW5lJyxcclxuICAncGF0aCcsXHJcbiAgJ3BvbHlnb24nLFxyXG4gICdwb2x5bGluZScsXHJcbiAgJ3JlY3QnXHJcbl07XHJcblxyXG5cclxuLyoqXHJcbiAqIEFkZHMgc3VwcG9ydCBmb3IgcHJldmlld3Mgb2YgbW92aW5nL3Jlc2l6aW5nIGVsZW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUHJldmlld1N1cHBvcnQoZWxlbWVudFJlZ2lzdHJ5LCBldmVudEJ1cywgY2FudmFzLCBzdHlsZXMpIHtcclxuICB0aGlzLl9lbGVtZW50UmVnaXN0cnkgPSBlbGVtZW50UmVnaXN0cnk7XHJcbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xyXG4gIHRoaXMuX3N0eWxlcyA9IHN0eWxlcztcclxuXHJcbiAgdGhpcy5fY2xvbmVkTWFya2VycyA9IHt9O1xyXG5cclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIGV2ZW50QnVzLm9uKCdkcmFnLmNsZWFudXAnLCBmdW5jdGlvbigpIHtcclxuICAgIGZvckVhY2goc2VsZi5fY2xvbmVkTWFya2VycywgZnVuY3Rpb24oY2xvbmVkTWFya2VyKSB7XHJcbiAgICAgIHN2Z1JlbW92ZShjbG9uZWRNYXJrZXIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc2VsZi5fY2xvbmVkTWFya2VycyA9IHt9O1xyXG4gIH0pO1xyXG59XHJcblxyXG5QcmV2aWV3U3VwcG9ydC4kaW5qZWN0ID0gW1xyXG4gICdlbGVtZW50UmVnaXN0cnknLFxyXG4gICdldmVudEJ1cycsXHJcbiAgJ2NhbnZhcycsXHJcbiAgJ3N0eWxlcydcclxuXTtcclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBncmFwaGljcyBvZiBhbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XHJcbiAqXHJcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9XHJcbiAqL1xyXG5QcmV2aWV3U3VwcG9ydC5wcm90b3R5cGUuZ2V0R2Z4ID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gIHJldHVybiB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhIG1vdmUgcHJldmlldyBvZiBhIGdpdmVuIHNoYXBlIHRvIGEgZ2l2ZW4gc3ZnIGdyb3VwLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ3JvdXBcclxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBbZ2Z4XVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fSBkcmFnZ2VyXHJcbiAqL1xyXG5QcmV2aWV3U3VwcG9ydC5wcm90b3R5cGUuYWRkRHJhZ2dlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGdyb3VwLCBnZngpIHtcclxuICBnZnggPSBnZnggfHwgdGhpcy5nZXRHZngoZWxlbWVudCk7XHJcblxyXG4gIHZhciBkcmFnZ2VyID0gc3ZnQ2xvbmUoZ2Z4KTtcclxuICB2YXIgYmJveCA9IGdmeC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgdGhpcy5fY2xvbmVNYXJrZXJzKGdldFZpc3VhbChkcmFnZ2VyKSk7XHJcblxyXG4gIHN2Z0F0dHIoZHJhZ2dlciwgdGhpcy5fc3R5bGVzLmNscygnZGpzLWRyYWdnZXInLCBbXSwge1xyXG4gICAgeDogYmJveC50b3AsXHJcbiAgICB5OiBiYm94LmxlZnRcclxuICB9KSk7XHJcblxyXG4gIHN2Z0FwcGVuZChncm91cCwgZHJhZ2dlcik7XHJcblxyXG4gIHJldHVybiBkcmFnZ2VyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSByZXNpemUgcHJldmlldyBvZiBhIGdpdmVuIHNoYXBlIHRvIGEgZ2l2ZW4gc3ZnIGdyb3VwLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ3JvdXBcclxuICpcclxuICogQHJldHVybiB7U1ZHRWxlbWVudH0gZnJhbWVcclxuICovXHJcblByZXZpZXdTdXBwb3J0LnByb3RvdHlwZS5hZGRGcmFtZSA9IGZ1bmN0aW9uKHNoYXBlLCBncm91cCkge1xyXG5cclxuICB2YXIgZnJhbWUgPSBzdmdDcmVhdGUoJ3JlY3QnLCB7XHJcbiAgICBjbGFzczogJ2Rqcy1yZXNpemUtb3ZlcmxheScsXHJcbiAgICB3aWR0aDogIHNoYXBlLndpZHRoLFxyXG4gICAgaGVpZ2h0OiBzaGFwZS5oZWlnaHQsXHJcbiAgICB4OiBzaGFwZS54LFxyXG4gICAgeTogc2hhcGUueVxyXG4gIH0pO1xyXG5cclxuICBzdmdBcHBlbmQoZ3JvdXAsIGZyYW1lKTtcclxuXHJcbiAgcmV0dXJuIGZyYW1lO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsb25lIGFsbCBtYXJrZXJzIHJlZmVyZW5jZWQgYnkgYSBub2RlIGFuZCBpdHMgY2hpbGQgbm9kZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ2Z4XHJcbiAqL1xyXG5QcmV2aWV3U3VwcG9ydC5wcm90b3R5cGUuX2Nsb25lTWFya2VycyA9IGZ1bmN0aW9uKGdmeCkge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgaWYgKGdmeC5jaGlsZE5vZGVzKSB7XHJcblxyXG4gICAgLy8gVE9ETzogdXNlIGZvckVhY2ggb25jZSB3ZSBkcm9wIFBoYW50b21KU1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZnguY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgLy8gcmVjdXJzaXZlbHkgY2xvbmUgbWFya2VycyBvZiBjaGlsZCBub2Rlc1xyXG4gICAgICBzZWxmLl9jbG9uZU1hcmtlcnMoZ2Z4LmNoaWxkTm9kZXNbIGkgXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIWNhbkhhdmVNYXJrZXIoZ2Z4KSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgTUFSS0VSX1RZUEVTLmZvckVhY2goZnVuY3Rpb24obWFya2VyVHlwZSkge1xyXG4gICAgaWYgKHN2Z0F0dHIoZ2Z4LCBtYXJrZXJUeXBlKSkge1xyXG4gICAgICB2YXIgbWFya2VyID0gZ2V0TWFya2VyKGdmeCwgbWFya2VyVHlwZSwgc2VsZi5fY2FudmFzLmdldENvbnRhaW5lcigpKTtcclxuXHJcbiAgICAgIHNlbGYuX2Nsb25lTWFya2VyKGdmeCwgbWFya2VyLCBtYXJrZXJUeXBlKTtcclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbG9uZSBtYXJrZXIgcmVmZXJlbmNlZCBieSBhbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxyXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IG1hcmtlclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya2VyVHlwZVxyXG4gKi9cclxuUHJldmlld1N1cHBvcnQucHJvdG90eXBlLl9jbG9uZU1hcmtlciA9IGZ1bmN0aW9uKGdmeCwgbWFya2VyLCBtYXJrZXJUeXBlKSB7XHJcbiAgdmFyIG1hcmtlcklkID0gbWFya2VyLmlkO1xyXG5cclxuICB2YXIgY2xvbmVkTWFya2VyID0gdGhpcy5fY2xvbmVkTWFya2Vyc1sgbWFya2VySWQgXTtcclxuXHJcbiAgaWYgKCFjbG9uZWRNYXJrZXIpIHtcclxuICAgIGNsb25lZE1hcmtlciA9IHN2Z0Nsb25lKG1hcmtlcik7XHJcblxyXG4gICAgdmFyIGNsb25lZE1hcmtlcklkID0gbWFya2VySWQgKyAnLWNsb25lJztcclxuXHJcbiAgICBjbG9uZWRNYXJrZXIuaWQgPSBjbG9uZWRNYXJrZXJJZDtcclxuXHJcbiAgICBzdmdDbGFzc2VzKGNsb25lZE1hcmtlcilcclxuICAgICAgLmFkZCgnZGpzLWRyYWdnZXInKVxyXG4gICAgICAuYWRkKCdkanMtZHJhZ2dlci1tYXJrZXInKTtcclxuXHJcbiAgICB0aGlzLl9jbG9uZWRNYXJrZXJzWyBtYXJrZXJJZCBdID0gY2xvbmVkTWFya2VyO1xyXG5cclxuICAgIHZhciBkZWZzID0gZG9tUXVlcnkoJ2RlZnMnLCB0aGlzLl9jYW52YXMuX3N2Zyk7XHJcblxyXG4gICAgaWYgKCFkZWZzKSB7XHJcbiAgICAgIGRlZnMgPSBzdmdDcmVhdGUoJ2RlZnMnKTtcclxuXHJcbiAgICAgIHN2Z0FwcGVuZCh0aGlzLl9jYW52YXMuX3N2ZywgZGVmcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc3ZnQXBwZW5kKGRlZnMsIGNsb25lZE1hcmtlcik7XHJcbiAgfVxyXG5cclxuICB2YXIgcmVmZXJlbmNlID0gaWRUb1JlZmVyZW5jZSh0aGlzLl9jbG9uZWRNYXJrZXJzWyBtYXJrZXJJZCBdLmlkKTtcclxuXHJcbiAgc3ZnQXR0cihnZngsIG1hcmtlclR5cGUsIHJlZmVyZW5jZSk7XHJcbn07XHJcblxyXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBHZXQgbWFya2VyIG9mIGdpdmVuIHR5cGUgcmVmZXJlbmNlZCBieSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmtlclR5cGVcclxuICogQHBhcmFtIHtOb2RlfSBbcGFyZW50Tm9kZV1cclxuICpcclxuICogQHBhcmFtIHtOb2RlfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWFya2VyKG5vZGUsIG1hcmtlclR5cGUsIHBhcmVudE5vZGUpIHtcclxuICB2YXIgaWQgPSByZWZlcmVuY2VUb0lkKHN2Z0F0dHIobm9kZSwgbWFya2VyVHlwZSkpO1xyXG5cclxuICByZXR1cm4gZG9tUXVlcnkoJ21hcmtlciMnICsgaWQsIHBhcmVudE5vZGUgfHwgZG9jdW1lbnQpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IElEIG9mIGZyYWdtZW50IHdpdGhpbiBjdXJyZW50IGRvY3VtZW50IGZyb20gaXRzIGZ1bmN0aW9uYWwgSVJJIHJlZmVyZW5jZS5cclxuICogUmVmZXJlbmNlcyBtYXkgdXNlIHNpbmdsZSBvciBkb3VibGUgcXVvdGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVmZXJlbmNlXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiByZWZlcmVuY2VUb0lkKHJlZmVyZW5jZSkge1xyXG4gIHJldHVybiByZWZlcmVuY2UubWF0Y2goL3VybFxcKFsnXCJdPyMoW14nXCJdKilbJ1wiXT9cXCkvKVsxXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBmdW5jdGlvbmFsIElSSSByZWZlcmVuY2UgZm9yIGdpdmVuIElEIG9mIGZyYWdtZW50IHdpdGhpbiBjdXJyZW50IGRvY3VtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGlkVG9SZWZlcmVuY2UoaWQpIHtcclxuICByZXR1cm4gJ3VybCgjJyArIGlkICsgJyknO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgd2V0aGVyIG5vZGUgdHlwZSBjYW4gaGF2ZSBtYXJrZXIgYXR0cmlidXRlcy5cclxuICpcclxuICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gY2FuSGF2ZU1hcmtlcihub2RlKSB7XHJcbiAgcmV0dXJuIE5PREVTX0NBTl9IQVZFX01BUktFUi5pbmRleE9mKG5vZGUubm9kZU5hbWUpICE9PSAtMTtcclxufSIsImltcG9ydCBQcmV2aWV3U3VwcG9ydCBmcm9tICcuL1ByZXZpZXdTdXBwb3J0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAncHJldmlld1N1cHBvcnQnIF0sXG4gIHByZXZpZXdTdXBwb3J0OiBbICd0eXBlJywgUHJldmlld1N1cHBvcnQgXVxufTtcbiIsImltcG9ydCB7XG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5cbi8qKlxuICogU2VydmljZSB0aGF0IGFsbG93IHJlcGxhY2luZyBvZiBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmVwbGFjZShtb2RlbGluZykge1xuXG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG59XG5cblJlcGxhY2UuJGluamVjdCA9IFsgJ21vZGVsaW5nJyBdO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gb2xkRWxlbWVudCAtIEVsZW1lbnQgdG8gYmUgcmVwbGFjZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSAgbmV3RWxlbWVudERhdGEgLSBDb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBuZXcgZWxlbWVudCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSB0aGUgbmV3IGJvdW5kcyBhbmQgdHlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSAgb3B0aW9ucyAtIEN1c3RvbSBvcHRpb25zIHRoYXQgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgY29udGV4dC4gSXQgY2FuIGJlIHVzZWQgdG8gaW5qZWN0IGRhdGFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgaXMgbmVlZGVkIGluIHRoZSBjb21tYW5kIGNoYWluLiBGb3IgZXhhbXBsZSBpdCBjb3VsZCBiZSB1c2VkIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudGJ1cy5vbignY29tbWFuZFN0YWNrLnNoYXBlLnJlcGxhY2UucG9zdEV4ZWN1dGUnKSB0byBjaGFuZ2Ugc2hhcGUgYXR0cmlidXRlcyBhZnRlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUgY3JlYXRpb24uXG4gKi9cblJlcGxhY2UucHJvdG90eXBlLnJlcGxhY2VFbGVtZW50ID0gZnVuY3Rpb24ob2xkRWxlbWVudCwgbmV3RWxlbWVudERhdGEsIG9wdGlvbnMpIHtcblxuICBpZiAob2xkRWxlbWVudC53YXlwb2ludHMpIHtcblxuICAgIC8vIFRPRE8obmlra3UpOiB3ZSBkbyBub3QgcmVwbGFjZSBjb25uZWN0aW9ucywgeWV0XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbW9kZWxpbmcgPSB0aGlzLl9tb2RlbGluZztcblxuICB2YXIgd2lkdGggPSBuZXdFbGVtZW50RGF0YS53aWR0aCB8fCBvbGRFbGVtZW50LndpZHRoLFxuICAgICAgaGVpZ2h0ID0gbmV3RWxlbWVudERhdGEuaGVpZ2h0IHx8IG9sZEVsZW1lbnQuaGVpZ2h0LFxuICAgICAgeCA9IG5ld0VsZW1lbnREYXRhLnggfHwgb2xkRWxlbWVudC54LFxuICAgICAgeSA9IG5ld0VsZW1lbnREYXRhLnkgfHwgb2xkRWxlbWVudC55LFxuICAgICAgY2VudGVyWCA9IHJvdW5kKHggKyB3aWR0aCAvIDIpLFxuICAgICAgY2VudGVyWSA9IHJvdW5kKHkgKyBoZWlnaHQgLyAyKTtcblxuICAvLyBtb2RlbGluZyBBUEkgcmVxdWlyZXMgY2VudGVyIGNvb3JkaW5hdGVzLFxuICAvLyBhY2NvdW50IGZvciB0aGF0IHdoZW4gaGFuZGxpbmcgc2hhcGUgYm91bmRzXG5cbiAgcmV0dXJuIG1vZGVsaW5nLnJlcGxhY2VTaGFwZShcbiAgICBvbGRFbGVtZW50LFxuICAgIGFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgbmV3RWxlbWVudERhdGEsXG4gICAgICB7XG4gICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH1cbiAgICApLFxuICAgIG9wdGlvbnNcbiAgKTtcbn07XG4iLCJpbXBvcnQgUmVwbGFjZSBmcm9tICcuL1JlcGxhY2UnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdyZXBsYWNlJyBdLFxuICByZXBsYWNlOiBbICd0eXBlJywgUmVwbGFjZSBdXG59OyIsImltcG9ydCB7XG4gIHBpY2ssXG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIHJlc2l6ZUJvdW5kcyxcbiAgZW5zdXJlQ29uc3RyYWludHMsXG4gIGNvbXB1dGVDaGlsZHJlbkJCb3gsXG4gIGdldE1pblJlc2l6ZUJvdW5kc1xufSBmcm9tICcuL1Jlc2l6ZVV0aWwnO1xuXG5pbXBvcnQge1xuICBhc1RSQkwsXG4gIGdldE1pZCxcbiAgcm91bmRCb3VuZHNcbn0gZnJvbSAnLi4vLi4vbGF5b3V0L0xheW91dFV0aWwnO1xuXG52YXIgREVGQVVMVF9NSU5fV0lEVEggPSAxMDtcblxuXG4vKipcbiAqIEEgY29tcG9uZW50IHRoYXQgcHJvdmlkZXMgcmVzaXppbmcgb2Ygc2hhcGVzIG9uIHRoZSBjYW52YXMuXG4gKlxuICogVGhlIGZvbGxvd2luZyBjb21wb25lbnRzIGFyZSBwYXJ0IG9mIHNoYXBlIHJlc2l6ZTpcbiAqXG4gKiAgKiBhZGRpbmcgcmVzaXplIGhhbmRsZXMsXG4gKiAgKiBjcmVhdGluZyBhIHZpc3VhbCBkdXJpbmcgcmVzaXplXG4gKiAgKiBjaGVja2luZyByZXNpemUgcnVsZXNcbiAqICAqIGNvbW1pdHRpbmcgYSBjaGFuZ2Ugb25jZSBmaW5pc2hlZFxuICpcbiAqXG4gKiAjIyBDdXN0b21pemluZ1xuICpcbiAqIEl0J3MgcG9zc2libGUgdG8gY3VzdG9taXplIHRoZSByZXNpemluZyBiZWhhdmlvdXIgYnkgaW50ZXJjZXB0aW5nICdyZXNpemUuc3RhcnQnXG4gKiBhbmQgcHJvdmlkaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVycyB0aHJvdWdoIHRoZSAnY29udGV4dCc6XG4gKlxuICogICAqIG1pbkRpbWVuc2lvbnMgKHsgd2lkdGgsIGhlaWdodCB9KTogbWluaW11bSBzaGFwZSBkaW1lbnNpb25zXG4gKlxuICogICAqIGNoaWxkcmVuQm94UGFkZGluZyAoeyBsZWZ0LCB0b3AsIGJvdHRvbSwgcmlnaHQgfSB8fCBudW1iZXIpOlxuICogICAgIGdhcCBiZXR3ZWVuIHRoZSBtaW5pbXVtIGJvdW5kaW5nIGJveCBhbmQgdGhlIGNvbnRhaW5lclxuICpcbiAqIGYuZXg6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZXZlbnRCdXMub24oJ3Jlc2l6ZS5zdGFydCcsIDE1MDAsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAqXG4gKiAgY29udGV4dC5taW5EaW1lbnNpb25zID0geyB3aWR0aDogMTQwLCBoZWlnaHQ6IDEyMCB9O1xuICpcbiAqICAvLyBQYXNzaW5nIGdlbmVyYWwgcGFkZGluZ1xuICogIGNvbnRleHQuY2hpbGRyZW5Cb3hQYWRkaW5nID0gMzA7XG4gKlxuICogIC8vIFBhc3NpbmcgcGFkZGluZyB0byBhIHNwZWNpZmljIHNpZGVcbiAqICBjb250ZXh0LmNoaWxkcmVuQm94UGFkZGluZy5sZWZ0ID0gMjA7XG4gKiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZXNpemUoZXZlbnRCdXMsIHJ1bGVzLCBtb2RlbGluZywgZHJhZ2dpbmcpIHtcblxuICB0aGlzLl9kcmFnZ2luZyA9IGRyYWdnaW5nO1xuICB0aGlzLl9ydWxlcyA9IHJ1bGVzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcmVzaXplIG1vdmUgYnkgc3BlY2lmaWVkIGRlbHRhLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcGFyYW0ge1BvaW50fSBkZWx0YVxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlTW92ZShjb250ZXh0LCBkZWx0YSkge1xuXG4gICAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgICAgZGlyZWN0aW9uID0gY29udGV4dC5kaXJlY3Rpb24sXG4gICAgICAgIHJlc2l6ZUNvbnN0cmFpbnRzID0gY29udGV4dC5yZXNpemVDb25zdHJhaW50cyxcbiAgICAgICAgbmV3Qm91bmRzO1xuXG4gICAgY29udGV4dC5kZWx0YSA9IGRlbHRhO1xuXG4gICAgbmV3Qm91bmRzID0gcmVzaXplQm91bmRzKHNoYXBlLCBkaXJlY3Rpb24sIGRlbHRhKTtcblxuICAgIC8vIGVuc3VyZSBjb25zdHJhaW50cyBkdXJpbmcgcmVzaXplXG4gICAgY29udGV4dC5uZXdCb3VuZHMgPSBlbnN1cmVDb25zdHJhaW50cyhuZXdCb3VuZHMsIHJlc2l6ZUNvbnN0cmFpbnRzKTtcblxuICAgIC8vIHVwZGF0ZSArIGNhY2hlIGV4ZWN1dGFibGUgc3RhdGVcbiAgICBjb250ZXh0LmNhbkV4ZWN1dGUgPSBzZWxmLmNhblJlc2l6ZShjb250ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcmVzaXplIHN0YXJ0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0KGNvbnRleHQpIHtcblxuICAgIHZhciByZXNpemVDb25zdHJhaW50cyA9IGNvbnRleHQucmVzaXplQ29uc3RyYWludHMsXG5cbiAgICAgICAgLy8gZXZhbHVhdGUgbWluQm91bmRzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICBtaW5Cb3VuZHMgPSBjb250ZXh0Lm1pbkJvdW5kcztcblxuICAgIGlmIChyZXNpemVDb25zdHJhaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1pbkJvdW5kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW5Cb3VuZHMgPSBzZWxmLmNvbXB1dGVNaW5SZXNpemVCb3goY29udGV4dCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5yZXNpemVDb25zdHJhaW50cyA9IHtcbiAgICAgIG1pbjogYXNUUkJMKG1pbkJvdW5kcylcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSByZXNpemUgZW5kLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZUVuZChjb250ZXh0KSB7XG4gICAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgICAgY2FuRXhlY3V0ZSA9IGNvbnRleHQuY2FuRXhlY3V0ZSxcbiAgICAgICAgbmV3Qm91bmRzID0gY29udGV4dC5uZXdCb3VuZHM7XG5cbiAgICBpZiAoY2FuRXhlY3V0ZSkge1xuXG4gICAgICAvLyBlbnN1cmUgd2UgaGF2ZSBhY3R1YWwgcGl4ZWwgdmFsdWVzIGZvciBuZXcgYm91bmRzXG4gICAgICAvLyAoaW1wb3J0YW50IHdoZW4gem9vbSBsZXZlbCB3YXMgPiAxIGR1cmluZyBtb3ZlKVxuICAgICAgbmV3Qm91bmRzID0gcm91bmRCb3VuZHMobmV3Qm91bmRzKTtcblxuICAgICAgaWYgKCFib3VuZHNDaGFuZ2VkKHNoYXBlLCBuZXdCb3VuZHMpKSB7XG5cbiAgICAgICAgLy8gbm8gcmVzaXplIG5lY2Vzc2FyeVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHBlcmZvcm0gdGhlIGFjdHVhbCByZXNpemVcbiAgICAgIG1vZGVsaW5nLnJlc2l6ZVNoYXBlKHNoYXBlLCBuZXdCb3VuZHMpO1xuICAgIH1cbiAgfVxuXG5cbiAgZXZlbnRCdXMub24oJ3Jlc2l6ZS5zdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaGFuZGxlU3RhcnQoZXZlbnQuY29udGV4dCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdyZXNpemUubW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGRlbHRhID0ge1xuICAgICAgeDogZXZlbnQuZHgsXG4gICAgICB5OiBldmVudC5keVxuICAgIH07XG5cbiAgICBoYW5kbGVNb3ZlKGV2ZW50LmNvbnRleHQsIGRlbHRhKTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ3Jlc2l6ZS5lbmQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIGhhbmRsZUVuZChldmVudC5jb250ZXh0KTtcbiAgfSk7XG5cbn1cblxuXG5SZXNpemUucHJvdG90eXBlLmNhblJlc2l6ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIHJ1bGVzID0gdGhpcy5fcnVsZXM7XG5cbiAgdmFyIGN0eCA9IHBpY2soY29udGV4dCwgWyAnbmV3Qm91bmRzJywgJ3NoYXBlJywgJ2RlbHRhJywgJ2RpcmVjdGlvbicgXSk7XG5cbiAgcmV0dXJuIHJ1bGVzLmFsbG93ZWQoJ3NoYXBlLnJlc2l6ZScsIGN0eCk7XG59O1xuXG4vKipcbiAqIEFjdGl2YXRlIGEgcmVzaXplIG9wZXJhdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHNwZWNpZnkgYWRkaXRpb25hbCBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGFuZCBtdXN0IHNwZWNpZnkgYVxuICogcmVzaXplIGRpcmVjdGlvbiBkdXJpbmcgYWN0aXZhdGlvbiBvZiB0aGUgcmVzaXplIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLlNoYXBlfSBzaGFwZVxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBjb250ZXh0T3JEaXJlY3Rpb25cbiAqL1xuUmVzaXplLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGV2ZW50LCBzaGFwZSwgY29udGV4dE9yRGlyZWN0aW9uKSB7XG4gIHZhciBkcmFnZ2luZyA9IHRoaXMuX2RyYWdnaW5nLFxuICAgICAgY29udGV4dCxcbiAgICAgIGRpcmVjdGlvbjtcblxuICBpZiAodHlwZW9mIGNvbnRleHRPckRpcmVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICBjb250ZXh0T3JEaXJlY3Rpb24gPSB7XG4gICAgICBkaXJlY3Rpb246IGNvbnRleHRPckRpcmVjdGlvblxuICAgIH07XG4gIH1cblxuICBjb250ZXh0ID0gYXNzaWduKHsgc2hhcGU6IHNoYXBlIH0sIGNvbnRleHRPckRpcmVjdGlvbik7XG5cbiAgZGlyZWN0aW9uID0gY29udGV4dC5kaXJlY3Rpb247XG5cbiAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBhIGRpcmVjdGlvbiAobnx3fHN8ZXxud3xzZXxuZXxzdyknKTtcbiAgfVxuXG4gIGRyYWdnaW5nLmluaXQoZXZlbnQsIGdldFJlZmVyZW5jZVBvaW50KHNoYXBlLCBkaXJlY3Rpb24pLCAncmVzaXplJywge1xuICAgIGF1dG9BY3RpdmF0ZTogdHJ1ZSxcbiAgICBjdXJzb3I6IGdldEN1cnNvcihkaXJlY3Rpb24pLFxuICAgIGRhdGE6IHtcbiAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9XG4gIH0pO1xufTtcblxuUmVzaXplLnByb3RvdHlwZS5jb21wdXRlTWluUmVzaXplQm94ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgZGlyZWN0aW9uID0gY29udGV4dC5kaXJlY3Rpb24sXG4gICAgICBtaW5EaW1lbnNpb25zLFxuICAgICAgY2hpbGRyZW5Cb3VuZHM7XG5cbiAgbWluRGltZW5zaW9ucyA9IGNvbnRleHQubWluRGltZW5zaW9ucyB8fCB7XG4gICAgd2lkdGg6IERFRkFVTFRfTUlOX1dJRFRILFxuICAgIGhlaWdodDogREVGQVVMVF9NSU5fV0lEVEhcbiAgfTtcblxuICAvLyBnZXQgY2hpbGRyZW4gYm91bmRzXG4gIGNoaWxkcmVuQm91bmRzID0gY29tcHV0ZUNoaWxkcmVuQkJveChzaGFwZSwgY29udGV4dC5jaGlsZHJlbkJveFBhZGRpbmcpO1xuXG4gIC8vIGdldCBjb3JyZWN0IG1pbmltdW0gYm91bmRzIGZyb20gZ2l2ZW4gcmVzaXplIGRpcmVjdGlvblxuICAvLyBiYXNpY2FsbHkgZW5zdXJlcyB0aGF0IHRoZSBtaW5Cb3VuZHMgaXMgbWF4KGNoaWxkcmVuQm91bmRzLCBtaW5EaW1lbnNpb25zKVxuICByZXR1cm4gZ2V0TWluUmVzaXplQm91bmRzKGRpcmVjdGlvbiwgc2hhcGUsIG1pbkRpbWVuc2lvbnMsIGNoaWxkcmVuQm91bmRzKTtcbn07XG5cblxuUmVzaXplLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdydWxlcycsXG4gICdtb2RlbGluZycsXG4gICdkcmFnZ2luZydcbl07XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBib3VuZHNDaGFuZ2VkKHNoYXBlLCBuZXdCb3VuZHMpIHtcbiAgcmV0dXJuIHNoYXBlLnggIT09IG5ld0JvdW5kcy54IHx8XG4gICAgc2hhcGUueSAhPT0gbmV3Qm91bmRzLnkgfHxcbiAgICBzaGFwZS53aWR0aCAhPT0gbmV3Qm91bmRzLndpZHRoIHx8XG4gICAgc2hhcGUuaGVpZ2h0ICE9PSBuZXdCb3VuZHMuaGVpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlUG9pbnQoc2hhcGUsIGRpcmVjdGlvbikge1xuICB2YXIgbWlkID0gZ2V0TWlkKHNoYXBlKSxcbiAgICAgIHRyYmwgPSBhc1RSQkwoc2hhcGUpO1xuXG4gIHZhciByZWZlcmVuY2VQb2ludCA9IHtcbiAgICB4OiBtaWQueCxcbiAgICB5OiBtaWQueVxuICB9O1xuXG4gIGlmIChkaXJlY3Rpb24uaW5kZXhPZignbicpICE9PSAtMSkge1xuICAgIHJlZmVyZW5jZVBvaW50LnkgPSB0cmJsLnRvcDtcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24uaW5kZXhPZigncycpICE9PSAtMSkge1xuICAgIHJlZmVyZW5jZVBvaW50LnkgPSB0cmJsLmJvdHRvbTtcbiAgfVxuXG4gIGlmIChkaXJlY3Rpb24uaW5kZXhPZignZScpICE9PSAtMSkge1xuICAgIHJlZmVyZW5jZVBvaW50LnggPSB0cmJsLnJpZ2h0O1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCd3JykgIT09IC0xKSB7XG4gICAgcmVmZXJlbmNlUG9pbnQueCA9IHRyYmwubGVmdDtcbiAgfVxuXG4gIHJldHVybiByZWZlcmVuY2VQb2ludDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3Vyc29yKGRpcmVjdGlvbikge1xuICB2YXIgcHJlZml4ID0gJ3Jlc2l6ZS0nO1xuXG4gIGlmIChkaXJlY3Rpb24gPT09ICduJyB8fCBkaXJlY3Rpb24gPT09ICdzJykge1xuICAgIHJldHVybiBwcmVmaXggKyAnbnMnO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2UnIHx8IGRpcmVjdGlvbiA9PT0gJ3cnKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdldyc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbncnIHx8IGRpcmVjdGlvbiA9PT0gJ3NlJykge1xuICAgIHJldHVybiBwcmVmaXggKyAnbndzZSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArICduZXN3JztcbiAgfVxufSIsImltcG9ydCB7XG4gIGJpbmQsXG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNsYXNzZXMgYXMgc3ZnQ2xhc3NlcyxcbiAgY2xlYXIgYXMgc3ZnQ2xlYXIsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQge1xuICBldmVudCBhcyBkb21FdmVudFxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgaXNQcmltYXJ5QnV0dG9uXG59IGZyb20gJy4uLy4uL3V0aWwvTW91c2UnO1xuXG5pbXBvcnQge1xuICB0cmFuc2Zvcm1cbn0gZnJvbSAnLi4vLi4vdXRpbC9TdmdUcmFuc2Zvcm1VdGlsJztcblxuaW1wb3J0IHsgZ2V0UmVmZXJlbmNlUG9pbnQgfSBmcm9tICcuL1Jlc2l6ZSc7XG5cbnZhciBIQU5ETEVfT0ZGU0VUID0gLTYsXG4gICAgSEFORExFX1NJWkUgPSA0LFxuICAgIEhBTkRMRV9ISVRfU0laRSA9IDIwO1xuXG52YXIgQ0xTX1JFU0laRVIgPSAnZGpzLXJlc2l6ZXInO1xuXG52YXIgZGlyZWN0aW9ucyA9IFsgJ24nLCAndycsICdzJywgJ2UnLCAnbncnLCAnbmUnLCAnc2UnLCAnc3cnIF07XG5cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyByZXNwb25zaWJsZSBmb3IgYWRkaW5nIHJlc2l6ZSBoYW5kbGVzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsZWN0aW9uXG4gKiBAcGFyYW0ge1Jlc2l6ZX0gcmVzaXplXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJlc2l6ZUhhbmRsZXMoZXZlbnRCdXMsIGNhbnZhcywgc2VsZWN0aW9uLCByZXNpemUpIHtcblxuICB0aGlzLl9yZXNpemUgPSByZXNpemU7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRCdXMub24oJ3NlbGVjdGlvbi5jaGFuZ2VkJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBuZXdTZWxlY3Rpb24gPSBlLm5ld1NlbGVjdGlvbjtcblxuICAgIC8vIHJlbW92ZSBvbGQgc2VsZWN0aW9uIG1hcmtlcnNcbiAgICBzZWxmLnJlbW92ZVJlc2l6ZXJzKCk7XG5cbiAgICAvLyBhZGQgbmV3IHNlbGVjdGlvbiBtYXJrZXJzIE9OTFkgaWYgc2luZ2xlIHNlbGVjdGlvblxuICAgIGlmIChuZXdTZWxlY3Rpb24ubGVuZ3RoID09PSAxKSB7XG4gICAgICBmb3JFYWNoKG5ld1NlbGVjdGlvbiwgYmluZChzZWxmLmFkZFJlc2l6ZXIsIHNlbGYpKTtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdzaGFwZS5jaGFuZ2VkJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBzaGFwZSA9IGUuZWxlbWVudDtcblxuICAgIGlmIChzZWxlY3Rpb24uaXNTZWxlY3RlZChzaGFwZSkpIHtcbiAgICAgIHNlbGYucmVtb3ZlUmVzaXplcnMoKTtcblxuICAgICAgc2VsZi5hZGRSZXNpemVyKHNoYXBlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cblJlc2l6ZUhhbmRsZXMucHJvdG90eXBlLm1ha2VEcmFnZ2FibGUgPSBmdW5jdGlvbihlbGVtZW50LCBnZngsIGRpcmVjdGlvbikge1xuICB2YXIgcmVzaXplID0gdGhpcy5fcmVzaXplO1xuXG4gIGZ1bmN0aW9uIHN0YXJ0UmVzaXplKGV2ZW50KSB7XG5cbiAgICAvLyBvbmx5IHRyaWdnZXIgb24gbGVmdCBtb3VzZSBidXR0b25cbiAgICBpZiAoaXNQcmltYXJ5QnV0dG9uKGV2ZW50KSkge1xuICAgICAgcmVzaXplLmFjdGl2YXRlKGV2ZW50LCBlbGVtZW50LCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGRvbUV2ZW50LmJpbmQoZ2Z4LCAnbW91c2Vkb3duJywgc3RhcnRSZXNpemUpO1xuICBkb21FdmVudC5iaW5kKGdmeCwgJ3RvdWNoc3RhcnQnLCBzdGFydFJlc2l6ZSk7XG59O1xuXG5cblJlc2l6ZUhhbmRsZXMucHJvdG90eXBlLl9jcmVhdGVSZXNpemVyID0gZnVuY3Rpb24oZWxlbWVudCwgeCwgeSwgZGlyZWN0aW9uKSB7XG4gIHZhciByZXNpemVyc1BhcmVudCA9IHRoaXMuX2dldFJlc2l6ZXJzUGFyZW50KCk7XG5cbiAgdmFyIG9mZnNldCA9IGdldEhhbmRsZU9mZnNldChkaXJlY3Rpb24pO1xuXG4gIHZhciBncm91cCA9IHN2Z0NyZWF0ZSgnZycpO1xuXG4gIHN2Z0NsYXNzZXMoZ3JvdXApLmFkZChDTFNfUkVTSVpFUik7XG4gIHN2Z0NsYXNzZXMoZ3JvdXApLmFkZChDTFNfUkVTSVpFUiArICctJyArIGVsZW1lbnQuaWQpO1xuICBzdmdDbGFzc2VzKGdyb3VwKS5hZGQoQ0xTX1JFU0laRVIgKyAnLScgKyBkaXJlY3Rpb24pO1xuXG4gIHN2Z0FwcGVuZChyZXNpemVyc1BhcmVudCwgZ3JvdXApO1xuXG4gIHZhciB2aXN1YWwgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcblxuICBzdmdBdHRyKHZpc3VhbCwge1xuICAgIHg6IC1IQU5ETEVfU0laRSAvIDIgKyBvZmZzZXQueCxcbiAgICB5OiAtSEFORExFX1NJWkUgLyAyICsgb2Zmc2V0LnksXG4gICAgd2lkdGg6IEhBTkRMRV9TSVpFLFxuICAgIGhlaWdodDogSEFORExFX1NJWkVcbiAgfSk7XG5cbiAgc3ZnQ2xhc3Nlcyh2aXN1YWwpLmFkZChDTFNfUkVTSVpFUiArICctdmlzdWFsJyk7XG5cbiAgc3ZnQXBwZW5kKGdyb3VwLCB2aXN1YWwpO1xuXG4gIHZhciBoaXQgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcblxuICBzdmdBdHRyKGhpdCwge1xuICAgIHg6IC1IQU5ETEVfSElUX1NJWkUgLyAyICsgb2Zmc2V0LngsXG4gICAgeTogLUhBTkRMRV9ISVRfU0laRSAvIDIgKyBvZmZzZXQueSxcbiAgICB3aWR0aDogSEFORExFX0hJVF9TSVpFLFxuICAgIGhlaWdodDogSEFORExFX0hJVF9TSVpFXG4gIH0pO1xuXG4gIHN2Z0NsYXNzZXMoaGl0KS5hZGQoQ0xTX1JFU0laRVIgKyAnLWhpdCcpO1xuXG4gIHN2Z0FwcGVuZChncm91cCwgaGl0KTtcblxuICB0cmFuc2Zvcm0oZ3JvdXAsIHgsIHkpO1xuXG4gIHJldHVybiBncm91cDtcbn07XG5cblJlc2l6ZUhhbmRsZXMucHJvdG90eXBlLmNyZWF0ZVJlc2l6ZXIgPSBmdW5jdGlvbihlbGVtZW50LCBkaXJlY3Rpb24pIHtcbiAgdmFyIHBvaW50ID0gZ2V0UmVmZXJlbmNlUG9pbnQoZWxlbWVudCwgZGlyZWN0aW9uKTtcblxuICB2YXIgcmVzaXplciA9IHRoaXMuX2NyZWF0ZVJlc2l6ZXIoZWxlbWVudCwgcG9pbnQueCwgcG9pbnQueSwgZGlyZWN0aW9uKTtcblxuICB0aGlzLm1ha2VEcmFnZ2FibGUoZWxlbWVudCwgcmVzaXplciwgZGlyZWN0aW9uKTtcbn07XG5cbi8vIHJlc2l6ZSBoYW5kbGVzIGltcGxlbWVudGF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBZGQgcmVzaXplcnMgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5TaGFwZX0gc2hhcGVcbiAqL1xuUmVzaXplSGFuZGxlcy5wcm90b3R5cGUuYWRkUmVzaXplciA9IGZ1bmN0aW9uKHNoYXBlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgcmVzaXplID0gdGhpcy5fcmVzaXplO1xuXG4gIGlmICghcmVzaXplLmNhblJlc2l6ZSh7IHNoYXBlOiBzaGFwZSB9KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2goZGlyZWN0aW9ucywgZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgc2VsZi5jcmVhdGVSZXNpemVyKHNoYXBlLCBkaXJlY3Rpb24pO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCByZXNpemVyc1xuICovXG5SZXNpemVIYW5kbGVzLnByb3RvdHlwZS5yZW1vdmVSZXNpemVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzaXplcnNQYXJlbnQgPSB0aGlzLl9nZXRSZXNpemVyc1BhcmVudCgpO1xuXG4gIHN2Z0NsZWFyKHJlc2l6ZXJzUGFyZW50KTtcbn07XG5cblJlc2l6ZUhhbmRsZXMucHJvdG90eXBlLl9nZXRSZXNpemVyc1BhcmVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzLmdldExheWVyKCdyZXNpemVycycpO1xufTtcblxuUmVzaXplSGFuZGxlcy4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJyxcbiAgJ3NlbGVjdGlvbicsXG4gICdyZXNpemUnXG5dO1xuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cblxuZnVuY3Rpb24gZ2V0SGFuZGxlT2Zmc2V0KGRpcmVjdGlvbikge1xuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChkaXJlY3Rpb24uaW5kZXhPZignZScpICE9PSAtMSkge1xuICAgIG9mZnNldC54ID0gLUhBTkRMRV9PRkZTRVQ7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uLmluZGV4T2YoJ3cnKSAhPT0gLTEpIHtcbiAgICBvZmZzZXQueCA9IEhBTkRMRV9PRkZTRVQ7XG4gIH1cblxuICBpZiAoZGlyZWN0aW9uLmluZGV4T2YoJ3MnKSAhPT0gLTEpIHtcbiAgICBvZmZzZXQueSA9IC1IQU5ETEVfT0ZGU0VUO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCduJykgIT09IC0xKSB7XG4gICAgb2Zmc2V0LnkgPSBIQU5ETEVfT0ZGU0VUO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn0iLCJ2YXIgTUFSS0VSX1JFU0laSU5HID0gJ2Rqcy1yZXNpemluZycsXG4gICAgTUFSS0VSX1JFU0laRV9OT1RfT0sgPSAncmVzaXplLW5vdC1vayc7XG5cbnZhciBMT1dfUFJJT1JJVFkgPSA1MDA7XG5cbmltcG9ydCB7XG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgcmVtb3ZlIGFzIHN2Z1JlbW92ZSxcbiAgY2xhc3NlcyBhcyBzdmdDbGFzc2VzXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuXG4vKipcbiAqIFByb3ZpZGVzIHByZXZpZXdzIGZvciByZXNpemluZyBzaGFwZXMgd2hlbiByZXNpemluZy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtQcmV2aWV3U3VwcG9ydH0gcHJldmlld1N1cHBvcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmVzaXplUHJldmlldyhldmVudEJ1cywgY2FudmFzLCBwcmV2aWV3U3VwcG9ydCkge1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgcmVzaXplciBmcmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYW1lKGNvbnRleHQpIHtcblxuICAgIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIGJvdW5kcyA9IGNvbnRleHQubmV3Qm91bmRzLFxuICAgICAgICBmcmFtZSA9IGNvbnRleHQuZnJhbWU7XG5cbiAgICBpZiAoIWZyYW1lKSB7XG4gICAgICBmcmFtZSA9IGNvbnRleHQuZnJhbWUgPSBwcmV2aWV3U3VwcG9ydC5hZGRGcmFtZShzaGFwZSwgY2FudmFzLmdldERlZmF1bHRMYXllcigpKTtcblxuICAgICAgY2FudmFzLmFkZE1hcmtlcihzaGFwZSwgTUFSS0VSX1JFU0laSU5HKTtcbiAgICB9XG5cbiAgICBpZiAoYm91bmRzLndpZHRoID4gNSkge1xuICAgICAgc3ZnQXR0cihmcmFtZSwgeyB4OiBib3VuZHMueCwgd2lkdGg6IGJvdW5kcy53aWR0aCB9KTtcbiAgICB9XG5cbiAgICBpZiAoYm91bmRzLmhlaWdodCA+IDUpIHtcbiAgICAgIHN2Z0F0dHIoZnJhbWUsIHsgeTogYm91bmRzLnksIGhlaWdodDogYm91bmRzLmhlaWdodCB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5jYW5FeGVjdXRlKSB7XG4gICAgICBzdmdDbGFzc2VzKGZyYW1lKS5yZW1vdmUoTUFSS0VSX1JFU0laRV9OT1RfT0spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdmdDbGFzc2VzKGZyYW1lKS5hZGQoTUFSS0VSX1JFU0laRV9OT1RfT0spO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgcmVzaXplciBmcmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUZyYW1lKGNvbnRleHQpIHtcbiAgICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBmcmFtZSA9IGNvbnRleHQuZnJhbWU7XG5cbiAgICBpZiAoZnJhbWUpIHtcbiAgICAgIHN2Z1JlbW92ZShjb250ZXh0LmZyYW1lKTtcbiAgICB9XG5cbiAgICBjYW52YXMucmVtb3ZlTWFya2VyKHNoYXBlLCBNQVJLRVJfUkVTSVpJTkcpO1xuICB9XG5cbiAgLy8gYWRkIGFuZCB1cGRhdGUgcHJldmlld3NcbiAgZXZlbnRCdXMub24oJ3Jlc2l6ZS5tb3ZlJywgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuICAgIHVwZGF0ZUZyYW1lKGV2ZW50LmNvbnRleHQpO1xuICB9KTtcblxuICAvLyByZW1vdmUgcHJldmlld3NcbiAgZXZlbnRCdXMub24oJ3Jlc2l6ZS5jbGVhbnVwJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZW1vdmVGcmFtZShldmVudC5jb250ZXh0KTtcbiAgfSk7XG5cbn1cblxuUmVzaXplUHJldmlldy4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJyxcbiAgJ3ByZXZpZXdTdXBwb3J0J1xuXTsiLCJpbXBvcnQge1xuICBmaWx0ZXIsXG4gIGlzTnVtYmVyXG59IGZyb20gJ21pbi1kYXNoJztcblxudmFyIG1heCA9IE1hdGgubWF4LFxuICAgIG1pbiA9IE1hdGgubWluO1xuXG52YXIgREVGQVVMVF9DSElMRF9CT1hfUEFERElORyA9IDIwO1xuXG5pbXBvcnQge1xuICBnZXRCQm94XG59IGZyb20gJy4uLy4uL3V0aWwvRWxlbWVudHMnO1xuXG5pbXBvcnQge1xuICBhc1RSQkwsXG4gIGFzQm91bmRzXG59IGZyb20gJy4uLy4uL2xheW91dC9MYXlvdXRVdGlsJztcblxuXG4vKipcbiAqIFN1YnN0cmFjdCBhIFRSQkwgZnJvbSBhbm90aGVyXG4gKlxuICogQHBhcmFtICB7VFJCTH0gdHJibEFcbiAqIEBwYXJhbSAge1RSQkx9IHRyYmxCXG4gKlxuICogQHJldHVybiB7VFJCTH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnN0cmFjdFRSQkwodHJibEEsIHRyYmxCKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiB0cmJsQS50b3AgLSB0cmJsQi50b3AsXG4gICAgcmlnaHQ6IHRyYmxBLnJpZ2h0IC0gdHJibEIucmlnaHQsXG4gICAgYm90dG9tOiB0cmJsQS5ib3R0b20gLSB0cmJsQi5ib3R0b20sXG4gICAgbGVmdDogdHJibEEubGVmdCAtIHRyYmxCLmxlZnRcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNpemUgdGhlIGdpdmVuIGJvdW5kcyBieSB0aGUgc3BlY2lmaWVkIGRlbHRhIGZyb20gYSBnaXZlbiBhbmNob3IgcG9pbnQuXG4gKlxuICogQHBhcmFtIHtCb3VuZHN9IGJvdW5kcyB0aGUgYm91bmRpbmcgYm94IHRoYXQgc2hvdWxkIGJlIHJlc2l6ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlIGVsZW1lbnQgaXMgcmVzaXplZCAobncsIG5lLCBzZSwgc3cpXG4gKiBAcGFyYW0ge1BvaW50fSBkZWx0YSBvZiB0aGUgcmVzaXplIG9wZXJhdGlvblxuICpcbiAqIEByZXR1cm4ge0JvdW5kc30gcmVzaXplZCBib3VuZGluZyBib3hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZUJvdW5kcyhib3VuZHMsIGRpcmVjdGlvbiwgZGVsdGEpIHtcbiAgdmFyIGR4ID0gZGVsdGEueCxcbiAgICAgIGR5ID0gZGVsdGEueTtcblxuICB2YXIgbmV3Qm91bmRzID0ge1xuICAgIHg6IGJvdW5kcy54LFxuICAgIHk6IGJvdW5kcy55LFxuICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXG4gICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0XG4gIH07XG5cbiAgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCduJykgIT09IC0xKSB7XG4gICAgbmV3Qm91bmRzLnkgPSBib3VuZHMueSArIGR5O1xuICAgIG5ld0JvdW5kcy5oZWlnaHQgPSBib3VuZHMuaGVpZ2h0IC0gZHk7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uLmluZGV4T2YoJ3MnKSAhPT0gLTEpIHtcbiAgICBuZXdCb3VuZHMuaGVpZ2h0ID0gYm91bmRzLmhlaWdodCArIGR5O1xuICB9XG5cbiAgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCdlJykgIT09IC0xKSB7XG4gICAgbmV3Qm91bmRzLndpZHRoID0gYm91bmRzLndpZHRoICsgZHg7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uLmluZGV4T2YoJ3cnKSAhPT0gLTEpIHtcbiAgICBuZXdCb3VuZHMueCA9IGJvdW5kcy54ICsgZHg7XG4gICAgbmV3Qm91bmRzLndpZHRoID0gYm91bmRzLndpZHRoIC0gZHg7XG4gIH1cblxuICByZXR1cm4gbmV3Qm91bmRzO1xufVxuXG5cbi8qKlxuICogUmVzaXplIHRoZSBnaXZlbiBib3VuZHMgYnkgYXBwbHlpbmcgdGhlIHBhc3NlZFxuICogeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfSBkZWx0YS5cbiAqXG4gKiBAcGFyYW0ge0JvdW5kc30gYm91bmRzXG4gKiBAcGFyYW0ge1RSQkx9IHRyYmxSZXNpemVcbiAqXG4gKiBAcmV0dXJuIHtCb3VuZHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNpemVUUkJMKGJvdW5kcywgcmVzaXplKSB7XG4gIHJldHVybiB7XG4gICAgeDogYm91bmRzLnggKyAocmVzaXplLmxlZnQgfHwgMCksXG4gICAgeTogYm91bmRzLnkgKyAocmVzaXplLnRvcCB8fCAwKSxcbiAgICB3aWR0aDogYm91bmRzLndpZHRoIC0gKHJlc2l6ZS5sZWZ0IHx8IDApICsgKHJlc2l6ZS5yaWdodCB8fCAwKSxcbiAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQgLSAocmVzaXplLnRvcCB8fCAwKSArIChyZXNpemUuYm90dG9tIHx8IDApXG4gIH07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYXR0YWNoUG9pbnQoYm91bmRzLCBuZXdCb3VuZHMsIHBvaW50KSB7XG5cbiAgdmFyIHN4ID0gYm91bmRzLndpZHRoIC8gbmV3Qm91bmRzLndpZHRoLFxuICAgICAgc3kgPSBib3VuZHMuaGVpZ2h0IC8gbmV3Qm91bmRzLmhlaWdodDtcblxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoKG5ld0JvdW5kcy54ICsgbmV3Qm91bmRzLndpZHRoIC8gMikpIC0gTWF0aC5mbG9vcigoKGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMikgLSBwb2ludC54KSAvIHN4KSxcbiAgICB5OiBNYXRoLnJvdW5kKChuZXdCb3VuZHMueSArIG5ld0JvdW5kcy5oZWlnaHQgLyAyKSkgLSBNYXRoLmZsb29yKCgoYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IC8gMikgLSBwb2ludC55KSAvIHN5KVxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIGFwcGx5Q29uc3RyYWludHMoYXR0ciwgdHJibCwgcmVzaXplQ29uc3RyYWludHMpIHtcblxuICB2YXIgdmFsdWUgPSB0cmJsW2F0dHJdLFxuICAgICAgbWluVmFsdWUgPSByZXNpemVDb25zdHJhaW50cy5taW4gJiYgcmVzaXplQ29uc3RyYWludHMubWluW2F0dHJdLFxuICAgICAgbWF4VmFsdWUgPSByZXNpemVDb25zdHJhaW50cy5tYXggJiYgcmVzaXplQ29uc3RyYWludHMubWF4W2F0dHJdO1xuXG4gIGlmIChpc051bWJlcihtaW5WYWx1ZSkpIHtcbiAgICB2YWx1ZSA9ICgvdG9wfGxlZnQvLnRlc3QoYXR0cikgPyBtaW4gOiBtYXgpKHZhbHVlLCBtaW5WYWx1ZSk7XG4gIH1cblxuICBpZiAoaXNOdW1iZXIobWF4VmFsdWUpKSB7XG4gICAgdmFsdWUgPSAoL3RvcHxsZWZ0Ly50ZXN0KGF0dHIpID8gbWF4IDogbWluKSh2YWx1ZSwgbWF4VmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQ29uc3RyYWludHMoY3VycmVudEJvdW5kcywgcmVzaXplQ29uc3RyYWludHMpIHtcblxuICBpZiAoIXJlc2l6ZUNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRCb3VuZHM7XG4gIH1cblxuICB2YXIgY3VycmVudFRyYmwgPSBhc1RSQkwoY3VycmVudEJvdW5kcyk7XG5cbiAgcmV0dXJuIGFzQm91bmRzKHtcbiAgICB0b3A6IGFwcGx5Q29uc3RyYWludHMoJ3RvcCcsIGN1cnJlbnRUcmJsLCByZXNpemVDb25zdHJhaW50cyksXG4gICAgcmlnaHQ6IGFwcGx5Q29uc3RyYWludHMoJ3JpZ2h0JywgY3VycmVudFRyYmwsIHJlc2l6ZUNvbnN0cmFpbnRzKSxcbiAgICBib3R0b206IGFwcGx5Q29uc3RyYWludHMoJ2JvdHRvbScsIGN1cnJlbnRUcmJsLCByZXNpemVDb25zdHJhaW50cyksXG4gICAgbGVmdDogYXBwbHlDb25zdHJhaW50cygnbGVmdCcsIGN1cnJlbnRUcmJsLCByZXNpemVDb25zdHJhaW50cylcbiAgfSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1pblJlc2l6ZUJvdW5kcyhkaXJlY3Rpb24sIGN1cnJlbnRCb3VuZHMsIG1pbkRpbWVuc2lvbnMsIGNoaWxkcmVuQm91bmRzKSB7XG5cbiAgdmFyIGN1cnJlbnRCb3ggPSBhc1RSQkwoY3VycmVudEJvdW5kcyk7XG5cbiAgdmFyIG1pbkJveCA9IHtcbiAgICB0b3A6IC9uLy50ZXN0KGRpcmVjdGlvbikgPyBjdXJyZW50Qm94LmJvdHRvbSAtIG1pbkRpbWVuc2lvbnMuaGVpZ2h0IDogY3VycmVudEJveC50b3AsXG4gICAgbGVmdDogL3cvLnRlc3QoZGlyZWN0aW9uKSA/IGN1cnJlbnRCb3gucmlnaHQgLSBtaW5EaW1lbnNpb25zLndpZHRoIDogY3VycmVudEJveC5sZWZ0LFxuICAgIGJvdHRvbTogL3MvLnRlc3QoZGlyZWN0aW9uKSA/IGN1cnJlbnRCb3gudG9wICsgbWluRGltZW5zaW9ucy5oZWlnaHQgOiBjdXJyZW50Qm94LmJvdHRvbSxcbiAgICByaWdodDogL2UvLnRlc3QoZGlyZWN0aW9uKSA/IGN1cnJlbnRCb3gubGVmdCArIG1pbkRpbWVuc2lvbnMud2lkdGggOiBjdXJyZW50Qm94LnJpZ2h0XG4gIH07XG5cbiAgdmFyIGNoaWxkcmVuQm94ID0gY2hpbGRyZW5Cb3VuZHMgPyBhc1RSQkwoY2hpbGRyZW5Cb3VuZHMpIDogbWluQm94O1xuXG4gIHZhciBjb21iaW5lZEJveCA9IHtcbiAgICB0b3A6IG1pbihtaW5Cb3gudG9wLCBjaGlsZHJlbkJveC50b3ApLFxuICAgIGxlZnQ6IG1pbihtaW5Cb3gubGVmdCwgY2hpbGRyZW5Cb3gubGVmdCksXG4gICAgYm90dG9tOiBtYXgobWluQm94LmJvdHRvbSwgY2hpbGRyZW5Cb3guYm90dG9tKSxcbiAgICByaWdodDogbWF4KG1pbkJveC5yaWdodCwgY2hpbGRyZW5Cb3gucmlnaHQpXG4gIH07XG5cbiAgcmV0dXJuIGFzQm91bmRzKGNvbWJpbmVkQm94KTtcbn1cblxuZnVuY3Rpb24gYXNQYWRkaW5nKG1heUJlUGFkZGluZywgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgbWF5QmVQYWRkaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBtYXlCZVBhZGRpbmc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQ0hJTERfQk9YX1BBRERJTkc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFBhZGRpbmcoYmJveCwgcGFkZGluZykge1xuICB2YXIgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tO1xuXG4gIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ29iamVjdCcpIHtcbiAgICBsZWZ0ID0gYXNQYWRkaW5nKHBhZGRpbmcubGVmdCk7XG4gICAgcmlnaHQgPSBhc1BhZGRpbmcocGFkZGluZy5yaWdodCk7XG4gICAgdG9wID0gYXNQYWRkaW5nKHBhZGRpbmcudG9wKTtcbiAgICBib3R0b20gPSBhc1BhZGRpbmcocGFkZGluZy5ib3R0b20pO1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSByaWdodCA9IHRvcCA9IGJvdHRvbSA9IGFzUGFkZGluZyhwYWRkaW5nKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogYmJveC54IC0gbGVmdCxcbiAgICB5OiBiYm94LnkgLSB0b3AsXG4gICAgd2lkdGg6IGJib3gud2lkdGggKyBsZWZ0ICsgcmlnaHQsXG4gICAgaGVpZ2h0OiBiYm94LmhlaWdodCArIHRvcCArIGJvdHRvbVxuICB9O1xufVxuXG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIGVsZW1lbnQgcGFydCBvZiB0aGUgcmVzaXplXG4gKiB0YXJnZXRzIG1pbiBib3VuZGFyeSBib3g/XG4gKlxuICogVGhpcyBpcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aGljaCBleGNsdWRlc1xuICogY29ubmVjdGlvbnMgYW5kIGxhYmVscy5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGlzQkJveENoaWxkKGVsZW1lbnQpIHtcblxuICAvLyBleGNsdWRlIGNvbm5lY3Rpb25zXG4gIGlmIChlbGVtZW50LndheXBvaW50cykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGV4Y2x1ZGUgbGFiZWxzXG4gIGlmIChlbGVtZW50LnR5cGUgPT09ICdsYWJlbCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gY2hpbGRyZW4gYm91bmRpbmcgY29tcHV0ZWQgZnJvbSBhIHNoYXBlcyBjaGlsZHJlblxuICogb3IgYSBsaXN0IG9mIHByZWZpbHRlcmVkIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSAge2Rqcy5tb2RlbC5TaGFwZXxBcnJheTxkanMubW9kZWwuU2hhcGU+fSBzaGFwZU9yQ2hpbGRyZW5cbiAqIEBwYXJhbSAge251bWJlcnxPYmplY3R9IHBhZGRpbmdcbiAqXG4gKiBAcmV0dXJuIHtCb3VuZHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQ2hpbGRyZW5CQm94KHNoYXBlT3JDaGlsZHJlbiwgcGFkZGluZykge1xuXG4gIHZhciBlbGVtZW50cztcblxuICAvLyBjb21wdXRlIGJhc2VkIG9uIHNoYXBlXG4gIGlmIChzaGFwZU9yQ2hpbGRyZW4ubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcblxuICAgIC8vIGdyYWIgYWxsIHRoZSBjaGlsZHJlbiB0aGF0IGFyZSBwYXJ0IG9mIHRoZVxuICAgIC8vIHBhcmVudHMgY2hpbGRyZW4gYm94XG4gICAgZWxlbWVudHMgPSBmaWx0ZXIoc2hhcGVPckNoaWxkcmVuLmNoaWxkcmVuLCBpc0JCb3hDaGlsZCk7XG5cbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50cyA9IHNoYXBlT3JDaGlsZHJlbjtcbiAgfVxuXG4gIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWRkUGFkZGluZyhnZXRCQm94KGVsZW1lbnRzKSwgcGFkZGluZyk7XG4gIH1cbn1cbiIsImltcG9ydCBSdWxlc01vZHVsZSBmcm9tICcuLi9ydWxlcyc7XG5pbXBvcnQgRHJhZ2dpbmdNb2R1bGUgZnJvbSAnLi4vZHJhZ2dpbmcnO1xuaW1wb3J0IFByZXZpZXdTdXBwb3J0TW9kdWxlIGZyb20gJy4uL3ByZXZpZXctc3VwcG9ydCc7XG5cbmltcG9ydCBSZXNpemUgZnJvbSAnLi9SZXNpemUnO1xuaW1wb3J0IFJlc2l6ZVByZXZpZXcgZnJvbSAnLi9SZXNpemVQcmV2aWV3JztcbmltcG9ydCBSZXNpemVIYW5kbGVzIGZyb20gJy4vUmVzaXplSGFuZGxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBSdWxlc01vZHVsZSxcbiAgICBEcmFnZ2luZ01vZHVsZSxcbiAgICBQcmV2aWV3U3VwcG9ydE1vZHVsZVxuICBdLFxuICBfX2luaXRfXzogW1xuICAgICdyZXNpemUnLFxuICAgICdyZXNpemVQcmV2aWV3JyxcbiAgICAncmVzaXplSGFuZGxlcydcbiAgXSxcbiAgcmVzaXplOiBbICd0eXBlJywgUmVzaXplIF0sXG4gIHJlc2l6ZVByZXZpZXc6IFsgJ3R5cGUnLCBSZXNpemVQcmV2aWV3IF0sXG4gIHJlc2l6ZUhhbmRsZXM6IFsgJ3R5cGUnLCBSZXNpemVIYW5kbGVzIF1cbn07XG4iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgQ29tbWFuZEludGVyY2VwdG9yIGZyb20gJy4uLy4uL2NvbW1hbmQvQ29tbWFuZEludGVyY2VwdG9yJztcblxuLyoqXG4gKiBBIGJhc2ljIHByb3ZpZGVyIHRoYXQgbWF5IGJlIGV4dGVuZGVkIHRvIGltcGxlbWVudCBtb2RlbGluZyBydWxlcy5cbiAqXG4gKiBFeHRlbnNpb25zIHNob3VsZCBpbXBsZW1lbnQgdGhlIGluaXQgbWV0aG9kIHRvIGFjdHVhbGx5IGFkZCB0aGVpciBjdXN0b21cbiAqIG1vZGVsaW5nIGNoZWNrcy4gQ2hlY2tzIG1heSBiZSBhZGRlZCB2aWEgdGhlICNhZGRSdWxlKGFjdGlvbiwgZm4pIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSdWxlUHJvdmlkZXIoZXZlbnRCdXMpIHtcbiAgQ29tbWFuZEludGVyY2VwdG9yLmNhbGwodGhpcywgZXZlbnRCdXMpO1xuXG4gIHRoaXMuaW5pdCgpO1xufVxuXG5SdWxlUHJvdmlkZXIuJGluamVjdCA9IFsgJ2V2ZW50QnVzJyBdO1xuXG5pbmhlcml0cyhSdWxlUHJvdmlkZXIsIENvbW1hbmRJbnRlcmNlcHRvcik7XG5cblxuLyoqXG4gKiBBZGRzIGEgbW9kZWxpbmcgcnVsZSBmb3IgdGhlIGdpdmVuIGFjdGlvbiwgaW1wbGVtZW50ZWQgdGhyb3VnaFxuICogYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBtb2RlbGluZyBzcGVjaWZpYyBhY3Rpb24gY29udGV4dFxuICogdG8gcGVyZm9ybSBpdHMgY2hlY2suIEl0IG11c3QgcmV0dXJuIGBmYWxzZWAgdG8gZGlzYWxsb3cgdGhlXG4gKiBhY3Rpb24gZnJvbSBoYXBwZW5pbmcgb3IgYHRydWVgIHRvIGFsbG93IHRoZSBhY3Rpb24uXG4gKlxuICogQSBydWxlIHByb3ZpZGVyIG1heSBwYXNzIG92ZXIgdGhlIGV2YWx1YXRpb24gdG8gbG93ZXIgcHJpb3JpdHlcbiAqIHJ1bGVzIGJ5IHJldHVybmluZyByZXR1cm4gbm90aGluZyAob3IgPGNvZGU+dW5kZWZpbmVkPC9jb2RlPikuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBSZXNpemFibGVSdWxlcy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICpcbiAqICAgXFwvKipcbiAqICAgICogUmV0dXJuIGB0cnVlYCwgYGZhbHNlYCBvciBub3RoaW5nIHRvIGRlbm90ZVxuICogICAgKiBfYWxsb3dlZF8sIF9ub3QgYWxsb3dlZF8gYW5kIF9jb250aW51ZSBldmFsdWF0aW5nXy5cbiAqICAgICpcXC9cbiAqICAgdGhpcy5hZGRSdWxlKCdzaGFwZS5yZXNpemUnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gKlxuICogICAgIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGU7XG4gKlxuICogICAgIGlmICghY29udGV4dC5uZXdCb3VuZHMpIHtcbiAqICAgICAgIC8vIGNoZWNrIGdlbmVyYWwgcmVzaXphYmlsaXR5XG4gKiAgICAgICBpZiAoIXNoYXBlLnJlc2l6YWJsZSkge1xuICogICAgICAgICByZXR1cm4gZmFsc2U7XG4gKiAgICAgICB9XG4gKlxuICogICAgICAgLy8gbm90IHJldHVybmluZyBhbnl0aGluZyAocmVhZDogdW5kZWZpbmVkKVxuICogICAgICAgLy8gd2lsbCBjb250aW51ZSB0aGUgZXZhbHVhdGlvbiBvZiBvdGhlciBydWxlc1xuICogICAgICAgLy8gKHdpdGggbG93ZXIgcHJpb3JpdHkpXG4gKiAgICAgICByZXR1cm47XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIC8vIGVsZW1lbnQgbXVzdCBoYXZlIG1pbmltdW0gc2l6ZSBvZiAxMCoxMCBwb2ludHNcbiAqICAgICAgIHJldHVybiBjb250ZXh0Lm5ld0JvdW5kcy53aWR0aCA+IDEwICYmIGNvbnRleHQubmV3Qm91bmRzLmhlaWdodCA+IDEwO1xuICogICAgIH1cbiAqICAgfSk7XG4gKiB9O1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IGFjdGlvbnMgdGhlIGlkZW50aWZpZXIgZm9yIHRoZSBtb2RlbGluZyBhY3Rpb24gdG8gY2hlY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHldIHRoZSBwcmlvcml0eSBhdCB3aGljaCB0aGlzIHJ1bGUgaXMgYmVpbmcgYXBwbGllZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdGhlIGFjdHVhbCBjaGVja1xuICovXG5SdWxlUHJvdmlkZXIucHJvdG90eXBlLmFkZFJ1bGUgPSBmdW5jdGlvbihhY3Rpb25zLCBwcmlvcml0eSwgZm4pIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25zID09PSAnc3RyaW5nJykge1xuICAgIGFjdGlvbnMgPSBbIGFjdGlvbnMgXTtcbiAgfVxuXG4gIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcblxuICAgIHNlbGYuY2FuRXhlY3V0ZShhY3Rpb24sIHByaW9yaXR5LCBmdW5jdGlvbihjb250ZXh0LCBhY3Rpb24sIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZm4oY29udGV4dCk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gYWRkIG5ldyBydWxlcyBkdXJpbmcgcHJvdmlkZXIgaW5pdGlhbGl6YXRpb24uXG4gKi9cblJ1bGVQcm92aWRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge307IiwiLyoqXG4gKiBBIHNlcnZpY2UgdGhhdCBwcm92aWRlcyBydWxlcyBmb3IgY2VydGFpbiBkaWFncmFtIGFjdGlvbnMuXG4gKlxuICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbCBob29rIGludG8gdGhlIHtAbGluayBDb21tYW5kU3RhY2t9XG4gKiB0byBwZXJmb3JtIHRoZSBhY3R1YWwgcnVsZSBldmFsdWF0aW9uLiBNYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGVcbiAqIGBjb21tYW5kU3RhY2tgIHNlcnZpY2Ugd2l0aCB0aGlzIG1vZHVsZSBpZiB5b3UgcGxhbiB0byB1c2UgaXQuXG4gKlxuICogVG9nZXRoZXIgd2l0aCB0aGlzIGltcGxlbWVudGF0aW9uIHlvdSBtYXkgdXNlIHRoZSB7QGxpbmsgUnVsZVByb3ZpZGVyfVxuICogdG8gaW1wbGVtZW50IHlvdXIgb3duIHJ1bGUgY2hlY2tlcnMuXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgbWVudCB0byBiZSBlYXNpbHkgcmVwbGFjZWQsIHRodXMgdGhlIHRpbnkgZm9vdCBwcmludC5cbiAqXG4gKiBAcGFyYW0ge0luamVjdG9yfSBpbmplY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSdWxlcyhpbmplY3Rvcikge1xuICB0aGlzLl9jb21tYW5kU3RhY2sgPSBpbmplY3Rvci5nZXQoJ2NvbW1hbmRTdGFjaycsIGZhbHNlKTtcbn1cblxuUnVsZXMuJGluamVjdCA9IFsgJ2luamVjdG9yJyBdO1xuXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIGdpdmVuIG1vZGVsaW5nIGFjdGlvbiBjYW4gYmUgZXhlY3V0ZWRcbiAqIGluIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIHdpbGwgcmVzcG9uZCB3aXRoIGFsbG93IHVubGVzcyBhbnlvbmVcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbiB0aGUgYWN0aW9uIHRvIGJlIGNoZWNrZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gdGhlIGNvbnRleHQgdG8gY2hlY2sgdGhlIGFjdGlvbiBpblxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHJldHVybnMgdHJ1ZSwgZmFsc2Ugb3IgbnVsbCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGVcbiAqICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiBpcyBhbGxvd2VkLCBub3QgYWxsb3dlZCBvciBzaG91bGQgYmUgaWdub3JlZC5cbiAqL1xuUnVsZXMucHJvdG90eXBlLmFsbG93ZWQgPSBmdW5jdGlvbihhY3Rpb24sIGNvbnRleHQpIHtcbiAgdmFyIGFsbG93ZWQgPSB0cnVlO1xuXG4gIHZhciBjb21tYW5kU3RhY2sgPSB0aGlzLl9jb21tYW5kU3RhY2s7XG5cbiAgaWYgKGNvbW1hbmRTdGFjaykge1xuICAgIGFsbG93ZWQgPSBjb21tYW5kU3RhY2suY2FuRXhlY3V0ZShhY3Rpb24sIGNvbnRleHQpO1xuICB9XG5cbiAgLy8gbWFwIHVuZGVmaW5lZCB0byB0cnVlLCBpLmUuIG5vIHJ1bGVzXG4gIHJldHVybiBhbGxvd2VkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYWxsb3dlZDtcbn07IiwiaW1wb3J0IFJ1bGVzIGZyb20gJy4vUnVsZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdydWxlcycgXSxcbiAgcnVsZXM6IFsgJ3R5cGUnLCBSdWxlcyBdXG59O1xuIiwiaW1wb3J0IHtcbiAgaXNBcnJheSxcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxuLyoqXG4gKiBBIHNlcnZpY2UgdGhhdCBvZmZlcnMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluIGEgZGlhZ3JhbS5cbiAqIE9mZmVycyB0aGUgYXBpIHRvIGNvbnRyb2wgdGhlIHNlbGVjdGlvbiwgdG9vLlxuICpcbiAqIEBjbGFzc1xuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzIHRoZSBldmVudCBidXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2VsZWN0aW9uKGV2ZW50QnVzKSB7XG5cbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcblxuICB0aGlzLl9zZWxlY3RlZEVsZW1lbnRzID0gW107XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGV2ZW50QnVzLm9uKFsgJ3NoYXBlLnJlbW92ZScsICdjb25uZWN0aW9uLnJlbW92ZScgXSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS5lbGVtZW50O1xuICAgIHNlbGYuZGVzZWxlY3QoZWxlbWVudCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKFsgJ2RpYWdyYW0uY2xlYXInIF0sIGZ1bmN0aW9uKGUpIHtcbiAgICBzZWxmLnNlbGVjdChudWxsKTtcbiAgfSk7XG59XG5cblNlbGVjdGlvbi4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnIF07XG5cblxuU2VsZWN0aW9uLnByb3RvdHlwZS5kZXNlbGVjdCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIHNlbGVjdGVkRWxlbWVudHMgPSB0aGlzLl9zZWxlY3RlZEVsZW1lbnRzO1xuXG4gIHZhciBpZHggPSBzZWxlY3RlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCk7XG5cbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICB2YXIgb2xkU2VsZWN0aW9uID0gc2VsZWN0ZWRFbGVtZW50cy5zbGljZSgpO1xuXG4gICAgc2VsZWN0ZWRFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcblxuICAgIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ3NlbGVjdGlvbi5jaGFuZ2VkJywgeyBvbGRTZWxlY3Rpb246IG9sZFNlbGVjdGlvbiwgbmV3U2VsZWN0aW9uOiBzZWxlY3RlZEVsZW1lbnRzIH0pO1xuICB9XG59O1xuXG5cblNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zZWxlY3RlZEVsZW1lbnRzO1xufTtcblxuU2VsZWN0aW9uLnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbn07XG5cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzZWxlY3RzIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9uIHRoZSBkaWFncmFtLlxuICpcbiAqIEJ5IHBhc3NpbmcgYW4gYWRkaXRpb25hbCBhZGQgcGFyYW1ldGVyIHlvdSBjYW4gZGVjaWRlIHdoZXRoZXIgb3Igbm90IHRoZSBlbGVtZW50KHMpXG4gKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGFscmVhZHkgZXhpc3Rpbmcgc2VsZWN0aW9uIG9yIG5vdC5cbiAqXG4gKiBAbWV0aG9kIFNlbGVjdGlvbiNzZWxlY3RcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8T2JqZWN0W119IGVsZW1lbnRzIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gYmUgc2VsZWN0ZWRcbiAqIEBwYXJhbSAge2Jvb2xlYW59IFthZGRdIHdoZXRoZXIgdGhlIGVsZW1lbnQocykgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgZGVmYXVsdHMgdG8gZmFsc2VcbiAqL1xuU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihlbGVtZW50cywgYWRkKSB7XG4gIHZhciBzZWxlY3RlZEVsZW1lbnRzID0gdGhpcy5fc2VsZWN0ZWRFbGVtZW50cyxcbiAgICAgIG9sZFNlbGVjdGlvbiA9IHNlbGVjdGVkRWxlbWVudHMuc2xpY2UoKTtcblxuICBpZiAoIWlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgZWxlbWVudHMgPSBlbGVtZW50cyA/IFsgZWxlbWVudHMgXSA6IFtdO1xuICB9XG5cbiAgLy8gc2VsZWN0aW9uIG1heSBiZSBjbGVhcmVkIGJ5IHBhc3NpbmcgYW4gZW1wdHkgYXJyYXkgb3IgbnVsbFxuICAvLyB0byB0aGUgbWV0aG9kXG4gIGlmIChhZGQpIHtcbiAgICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpICE9PSAtMSkge1xuXG4gICAgICAgIC8vIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NlbGVjdGVkRWxlbWVudHMgPSBzZWxlY3RlZEVsZW1lbnRzID0gZWxlbWVudHMuc2xpY2UoKTtcbiAgfVxuXG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ3NlbGVjdGlvbi5jaGFuZ2VkJywgeyBvbGRTZWxlY3Rpb246IG9sZFNlbGVjdGlvbiwgbmV3U2VsZWN0aW9uOiBzZWxlY3RlZEVsZW1lbnRzIH0pO1xufTtcbiIsImltcG9ydCB7XG4gIGhhc1ByaW1hcnlNb2RpZmllcixcbiAgaGFzU2Vjb25kYXJ5TW9kaWZpZXIsXG4gIGlzUHJpbWFyeUJ1dHRvblxufSBmcm9tICcuLi8uLi91dGlsL01vdXNlJztcblxuaW1wb3J0IHtcbiAgZmluZCxcbiAgaXNBcnJheVxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2VsZWN0aW9uQmVoYXZpb3IoZXZlbnRCdXMsIHNlbGVjdGlvbiwgY2FudmFzLCBlbGVtZW50UmVnaXN0cnkpIHtcblxuICAvLyBTZWxlY3QgZWxlbWVudHMgb24gY3JlYXRlXG4gIGV2ZW50QnVzLm9uKCdjcmVhdGUuZW5kJywgNTAwLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgY2FuRXhlY3V0ZSA9IGNvbnRleHQuY2FuRXhlY3V0ZSxcbiAgICAgICAgZWxlbWVudHMgPSBjb250ZXh0LmVsZW1lbnRzLFxuICAgICAgICBoaW50cyA9IGNvbnRleHQuaGludHMgfHwge30sXG4gICAgICAgIGF1dG9TZWxlY3QgPSBoaW50cy5hdXRvU2VsZWN0O1xuXG4gICAgaWYgKGNhbkV4ZWN1dGUpIHtcbiAgICAgIGlmIChhdXRvU2VsZWN0ID09PSBmYWxzZSkge1xuXG4gICAgICAgIC8vIFNlbGVjdCBubyBlbGVtZW50c1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KGF1dG9TZWxlY3QpKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoYXV0b1NlbGVjdCk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFNlbGVjdCBhbGwgZWxlbWVudHMgYnkgZGVmYXVsdFxuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KGVsZW1lbnRzLmZpbHRlcihpc1Nob3duKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBTZWxlY3QgY29ubmVjdGlvbiB0YXJnZXRzIG9uIGNvbm5lY3RcbiAgZXZlbnRCdXMub24oJ2Nvbm5lY3QuZW5kJywgNTAwLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgY2FuRXhlY3V0ZSA9IGNvbnRleHQuY2FuRXhlY3V0ZSxcbiAgICAgICAgaG92ZXIgPSBjb250ZXh0LmhvdmVyO1xuXG4gICAgaWYgKGNhbkV4ZWN1dGUgJiYgaG92ZXIpIHtcbiAgICAgIHNlbGVjdGlvbi5zZWxlY3QoaG92ZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU2VsZWN0IHNoYXBlcyBvbiBtb3ZlXG4gIGV2ZW50QnVzLm9uKCdzaGFwZS5tb3ZlLmVuZCcsIDUwMCwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSBldmVudC5wcmV2aW91c1NlbGVjdGlvbiB8fCBbXTtcblxuICAgIHZhciBzaGFwZSA9IGVsZW1lbnRSZWdpc3RyeS5nZXQoZXZlbnQuY29udGV4dC5zaGFwZS5pZCk7XG5cbiAgICAvLyBBbHdheXMgc2VsZWN0IG1haW4gc2hhcGUgb24gbW92ZVxuICAgIHZhciBpc1NlbGVjdGVkID0gZmluZChwcmV2aW91c1NlbGVjdGlvbiwgZnVuY3Rpb24oc2VsZWN0ZWRTaGFwZSkge1xuICAgICAgcmV0dXJuIHNoYXBlLmlkID09PSBzZWxlY3RlZFNoYXBlLmlkO1xuICAgIH0pO1xuXG4gICAgaWYgKCFpc1NlbGVjdGVkKSB7XG4gICAgICBzZWxlY3Rpb24uc2VsZWN0KHNoYXBlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFNlbGVjdCBlbGVtZW50cyBvbiBjbGlja1xuICBldmVudEJ1cy5vbignZWxlbWVudC5jbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICBpZiAoIWlzUHJpbWFyeUJ1dHRvbihldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudCA9PT0gY2FudmFzLmdldFJvb3RFbGVtZW50KCkpIHtcbiAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBpc1NlbGVjdGVkID0gc2VsZWN0aW9uLmlzU2VsZWN0ZWQoZWxlbWVudCksXG4gICAgICAgIGlzTXVsdGlTZWxlY3QgPSBzZWxlY3Rpb24uZ2V0KCkubGVuZ3RoID4gMTtcblxuICAgIC8vIEFkZCB0byBzZWxlY3Rpb24gaWYgQ1RSTCBvciBTSElGVCBwcmVzc2VkXG4gICAgdmFyIGFkZCA9IGhhc1ByaW1hcnlNb2RpZmllcihldmVudCkgfHwgaGFzU2Vjb25kYXJ5TW9kaWZpZXIoZXZlbnQpO1xuXG4gICAgaWYgKGlzU2VsZWN0ZWQgJiYgaXNNdWx0aVNlbGVjdCkge1xuICAgICAgaWYgKGFkZCkge1xuXG4gICAgICAgIC8vIERlc2VsZWN0IGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5kZXNlbGVjdChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gU2VsZWN0IGVsZW1lbnQgb25seVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uLnNlbGVjdChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1NlbGVjdGVkKSB7XG5cbiAgICAgIC8vIFNlbGVjdCBlbGVtZW50XG4gICAgICBzZWxlY3Rpb24uc2VsZWN0KGVsZW1lbnQsIGFkZCk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gRGVzZWxlY3QgZWxlbWVudFxuICAgICAgc2VsZWN0aW9uLmRlc2VsZWN0KGVsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG59XG5cblNlbGVjdGlvbkJlaGF2aW9yLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdzZWxlY3Rpb24nLFxuICAnY2FudmFzJyxcbiAgJ2VsZW1lbnRSZWdpc3RyeSdcbl07XG5cblxuZnVuY3Rpb24gaXNTaG93bihlbGVtZW50KSB7XG4gIHJldHVybiAhZWxlbWVudC5oaWRkZW47XG59XG4iLCJpbXBvcnQge1xuICBmb3JFYWNoXG59IGZyb20gJ21pbi1kYXNoJztcblxudmFyIE1BUktFUl9IT1ZFUiA9ICdob3ZlcicsXG4gICAgTUFSS0VSX1NFTEVDVEVEID0gJ3NlbGVjdGVkJztcblxuXG4vKipcbiAqIEEgcGx1Z2luIHRoYXQgYWRkcyBhIHZpc2libGUgc2VsZWN0aW9uIFVJIHRvIHNoYXBlcyBhbmQgY29ubmVjdGlvbnNcbiAqIGJ5IGFwcGVuZGluZyB0aGUgPGNvZGU+aG92ZXI8L2NvZGU+IGFuZCA8Y29kZT5zZWxlY3RlZDwvY29kZT4gY2xhc3NlcyB0byB0aGVtLlxuICpcbiAqIEBjbGFzc1xuICpcbiAqIE1ha2VzIGVsZW1lbnRzIHNlbGVjdGFibGUsIHRvby5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudHNcbiAqIEBwYXJhbSB7U2VsZWN0aW9uU2VydmljZX0gc2VsZWN0aW9uXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNlbGVjdGlvblZpc3VhbHMoZXZlbnRzLCBjYW52YXMsIHNlbGVjdGlvbiwgc3R5bGVzKSB7XG5cbiAgdGhpcy5fbXVsdGlTZWxlY3Rpb25Cb3ggPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFkZE1hcmtlcihlLCBjbHMpIHtcbiAgICBjYW52YXMuYWRkTWFya2VyKGUsIGNscyk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVNYXJrZXIoZSwgY2xzKSB7XG4gICAgY2FudmFzLnJlbW92ZU1hcmtlcihlLCBjbHMpO1xuICB9XG5cbiAgZXZlbnRzLm9uKCdlbGVtZW50LmhvdmVyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBhZGRNYXJrZXIoZXZlbnQuZWxlbWVudCwgTUFSS0VSX0hPVkVSKTtcbiAgfSk7XG5cbiAgZXZlbnRzLm9uKCdlbGVtZW50Lm91dCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmVtb3ZlTWFya2VyKGV2ZW50LmVsZW1lbnQsIE1BUktFUl9IT1ZFUik7XG4gIH0pO1xuXG4gIGV2ZW50cy5vbignc2VsZWN0aW9uLmNoYW5nZWQnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgZnVuY3Rpb24gZGVzZWxlY3Qocykge1xuICAgICAgcmVtb3ZlTWFya2VyKHMsIE1BUktFUl9TRUxFQ1RFRCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0KHMpIHtcbiAgICAgIGFkZE1hcmtlcihzLCBNQVJLRVJfU0VMRUNURUQpO1xuICAgIH1cblxuICAgIHZhciBvbGRTZWxlY3Rpb24gPSBldmVudC5vbGRTZWxlY3Rpb24sXG4gICAgICAgIG5ld1NlbGVjdGlvbiA9IGV2ZW50Lm5ld1NlbGVjdGlvbjtcblxuICAgIGZvckVhY2gob2xkU2VsZWN0aW9uLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAobmV3U2VsZWN0aW9uLmluZGV4T2YoZSkgPT09IC0xKSB7XG4gICAgICAgIGRlc2VsZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yRWFjaChuZXdTZWxlY3Rpb24sIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChvbGRTZWxlY3Rpb24uaW5kZXhPZihlKSA9PT0gLTEpIHtcbiAgICAgICAgc2VsZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuU2VsZWN0aW9uVmlzdWFscy4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJyxcbiAgJ3NlbGVjdGlvbicsXG4gICdzdHlsZXMnXG5dOyIsImltcG9ydCBJbnRlcmFjdGlvbkV2ZW50c01vZHVsZSBmcm9tICcuLi9pbnRlcmFjdGlvbi1ldmVudHMnO1xuaW1wb3J0IE91dGxpbmVNb2R1bGUgZnJvbSAnLi4vb3V0bGluZSc7XG5cbmltcG9ydCBTZWxlY3Rpb24gZnJvbSAnLi9TZWxlY3Rpb24nO1xuaW1wb3J0IFNlbGVjdGlvblZpc3VhbHMgZnJvbSAnLi9TZWxlY3Rpb25WaXN1YWxzJztcbmltcG9ydCBTZWxlY3Rpb25CZWhhdmlvciBmcm9tICcuL1NlbGVjdGlvbkJlaGF2aW9yJztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdzZWxlY3Rpb25WaXN1YWxzJywgJ3NlbGVjdGlvbkJlaGF2aW9yJyBdLFxuICBfX2RlcGVuZHNfXzogW1xuICAgIEludGVyYWN0aW9uRXZlbnRzTW9kdWxlLFxuICAgIE91dGxpbmVNb2R1bGVcbiAgXSxcbiAgc2VsZWN0aW9uOiBbICd0eXBlJywgU2VsZWN0aW9uIF0sXG4gIHNlbGVjdGlvblZpc3VhbHM6IFsgJ3R5cGUnLCBTZWxlY3Rpb25WaXN1YWxzIF0sXG4gIHNlbGVjdGlvbkJlaGF2aW9yOiBbICd0eXBlJywgU2VsZWN0aW9uQmVoYXZpb3IgXVxufTtcbiIsImltcG9ydCBTbmFwQ29udGV4dCBmcm9tICcuL1NuYXBDb250ZXh0JztcclxuXHJcbmltcG9ydCB7XHJcbiAgZ2V0Q2hpbGRyZW4sXHJcbiAgaXNTbmFwcGVkLFxyXG4gIG1pZFxyXG59IGZyb20gJy4vU25hcFV0aWwnO1xyXG5cclxuaW1wb3J0IHsgaXNDbWQgfSBmcm9tICcuLi9rZXlib2FyZC9LZXlib2FyZFV0aWwnO1xyXG5cclxuaW1wb3J0IHtcclxuICBmb3JFYWNoLFxyXG4gIGlzTnVtYmVyXHJcbn0gZnJvbSAnbWluLWRhc2gnO1xyXG5cclxudmFyIEhJR0hFUl9QUklPUklUWSA9IDEyNTA7XHJcblxyXG5cclxuLyoqXHJcbiAqIFNuYXAgZHVyaW5nIGNyZWF0ZSBhbmQgbW92ZS5cclxuICpcclxuICogQHBhcmFtIHtFdmVudEJ1c30gZWxlbWVudFJlZ2lzdHJ5XHJcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXHJcbiAqIEBwYXJhbSB7U25hcHBpbmd9IHNuYXBwaW5nXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDcmVhdGVNb3ZlU25hcHBpbmcoZWxlbWVudFJlZ2lzdHJ5LCBldmVudEJ1cywgc25hcHBpbmcpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIHRoaXMuX2VsZW1lbnRSZWdpc3RyeSA9IGVsZW1lbnRSZWdpc3RyeTtcclxuXHJcbiAgZXZlbnRCdXMub24oW1xyXG4gICAgJ2NyZWF0ZS5zdGFydCcsXHJcbiAgICAnc2hhcGUubW92ZS5zdGFydCdcclxuICBdLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgc2VsZi5pbml0U25hcChldmVudCk7XHJcbiAgfSk7XHJcblxyXG4gIGV2ZW50QnVzLm9uKFtcclxuICAgICdjcmVhdGUubW92ZScsXHJcbiAgICAnY3JlYXRlLmVuZCcsXHJcbiAgICAnc2hhcGUubW92ZS5tb3ZlJyxcclxuICAgICdzaGFwZS5tb3ZlLmVuZCdcclxuICBdLCBISUdIRVJfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXHJcbiAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxyXG4gICAgICAgIHNuYXBDb250ZXh0ID0gY29udGV4dC5zbmFwQ29udGV4dCxcclxuICAgICAgICB0YXJnZXQgPSBjb250ZXh0LnRhcmdldDtcclxuXHJcbiAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudCAmJiBpc0NtZChldmVudC5vcmlnaW5hbEV2ZW50KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzU25hcHBlZChldmVudCkgfHwgIXRhcmdldCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNuYXBQb2ludHMgPSBzbmFwQ29udGV4dC5wb2ludHNGb3JUYXJnZXQodGFyZ2V0KTtcclxuXHJcbiAgICBpZiAoIXNuYXBQb2ludHMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgc25hcFBvaW50cyA9IHNlbGYuYWRkU25hcFRhcmdldFBvaW50cyhzbmFwUG9pbnRzLCBzaGFwZSwgdGFyZ2V0KTtcclxuXHJcbiAgICAgIHNuYXBQb2ludHMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHNuYXBwaW5nLnNuYXAoZXZlbnQsIHNuYXBQb2ludHMpO1xyXG4gIH0pO1xyXG5cclxuICBldmVudEJ1cy5vbihbXHJcbiAgICAnY3JlYXRlLmNsZWFudXAnLFxyXG4gICAgJ3NoYXBlLm1vdmUuY2xlYW51cCdcclxuICBdLCBmdW5jdGlvbigpIHtcclxuICAgIHNuYXBwaW5nLmhpZGUoKTtcclxuICB9KTtcclxufVxyXG5cclxuQ3JlYXRlTW92ZVNuYXBwaW5nLiRpbmplY3QgPSBbXHJcbiAgJ2VsZW1lbnRSZWdpc3RyeScsXHJcbiAgJ2V2ZW50QnVzJyxcclxuICAnc25hcHBpbmcnXHJcbl07XHJcblxyXG5DcmVhdGVNb3ZlU25hcHBpbmcucHJvdG90eXBlLmluaXRTbmFwID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICB2YXIgZWxlbWVudFJlZ2lzdHJ5ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5O1xyXG5cclxuICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXHJcbiAgICAgIHNoYXBlID0gY29udGV4dC5zaGFwZSxcclxuICAgICAgc25hcENvbnRleHQgPSBjb250ZXh0LnNuYXBDb250ZXh0O1xyXG5cclxuICBpZiAoIXNuYXBDb250ZXh0KSB7XHJcbiAgICBzbmFwQ29udGV4dCA9IGNvbnRleHQuc25hcENvbnRleHQgPSBuZXcgU25hcENvbnRleHQoKTtcclxuICB9XHJcblxyXG4gIHZhciBzaGFwZU1pZDtcclxuXHJcbiAgaWYgKGVsZW1lbnRSZWdpc3RyeS5nZXQoc2hhcGUuaWQpKSB7XHJcblxyXG4gICAgLy8gbW92ZVxyXG4gICAgc2hhcGVNaWQgPSBtaWQoc2hhcGUsIGV2ZW50KTtcclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIGNyZWF0ZVxyXG4gICAgc2hhcGVNaWQgPSB7XHJcbiAgICAgIHg6IGV2ZW50LnggKyBtaWQoc2hhcGUpLngsXHJcbiAgICAgIHk6IGV2ZW50LnkgKyBtaWQoc2hhcGUpLnlcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB2YXIgc2hhcGVUb3BMZWZ0ID0ge1xyXG4gICAgICAgIHg6IHNoYXBlTWlkLnggLSBzaGFwZS53aWR0aCAvIDIsXHJcbiAgICAgICAgeTogc2hhcGVNaWQueSAtIHNoYXBlLmhlaWdodCAvIDJcclxuICAgICAgfSxcclxuICAgICAgc2hhcGVCb3R0b21SaWdodCA9IHtcclxuICAgICAgICB4OiBzaGFwZU1pZC54ICsgc2hhcGUud2lkdGggLyAyLFxyXG4gICAgICAgIHk6IHNoYXBlTWlkLnkgKyBzaGFwZS5oZWlnaHQgLyAyXHJcbiAgICAgIH07XHJcblxyXG4gIHNuYXBDb250ZXh0LnNldFNuYXBPcmlnaW4oJ21pZCcsIHtcclxuICAgIHg6IHNoYXBlTWlkLnggLSBldmVudC54LFxyXG4gICAgeTogc2hhcGVNaWQueSAtIGV2ZW50LnlcclxuICB9KTtcclxuXHJcbiAgLy8gc25hcCBsYWJlbHMgdG8gbWlkIG9ubHlcclxuICBpZiAoaXNMYWJlbChzaGFwZSkpIHtcclxuICAgIHJldHVybiBzbmFwQ29udGV4dDtcclxuICB9XHJcblxyXG4gIHNuYXBDb250ZXh0LnNldFNuYXBPcmlnaW4oJ3RvcC1sZWZ0Jywge1xyXG4gICAgeDogc2hhcGVUb3BMZWZ0LnggLSBldmVudC54LFxyXG4gICAgeTogc2hhcGVUb3BMZWZ0LnkgLSBldmVudC55XHJcbiAgfSk7XHJcblxyXG4gIHNuYXBDb250ZXh0LnNldFNuYXBPcmlnaW4oJ2JvdHRvbS1yaWdodCcsIHtcclxuICAgIHg6IHNoYXBlQm90dG9tUmlnaHQueCAtIGV2ZW50LngsXHJcbiAgICB5OiBzaGFwZUJvdHRvbVJpZ2h0LnkgLSBldmVudC55XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBzbmFwQ29udGV4dDtcclxufTtcclxuXHJcbkNyZWF0ZU1vdmVTbmFwcGluZy5wcm90b3R5cGUuYWRkU25hcFRhcmdldFBvaW50cyA9IGZ1bmN0aW9uKHNuYXBQb2ludHMsIHNoYXBlLCB0YXJnZXQpIHtcclxuICB2YXIgc25hcFRhcmdldHMgPSB0aGlzLmdldFNuYXBUYXJnZXRzKHNoYXBlLCB0YXJnZXQpO1xyXG5cclxuICBmb3JFYWNoKHNuYXBUYXJnZXRzLCBmdW5jdGlvbihzbmFwVGFyZ2V0KSB7XHJcblxyXG4gICAgLy8gaGFuZGxlIGxhYmVsc1xyXG4gICAgaWYgKGlzTGFiZWwoc25hcFRhcmdldCkpIHtcclxuXHJcbiAgICAgIGlmIChpc0xhYmVsKHNoYXBlKSkge1xyXG4gICAgICAgIHNuYXBQb2ludHMuYWRkKCdtaWQnLCBtaWQoc25hcFRhcmdldCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaGFuZGxlIGNvbm5lY3Rpb25zXHJcbiAgICBpZiAoaXNDb25uZWN0aW9uKHNuYXBUYXJnZXQpKSB7XHJcblxyXG4gICAgICAvLyBpZ25vcmUgc2luZ2xlIHNlZ21lbnQgY29ubmVjdGlvbnNcclxuICAgICAgaWYgKHNuYXBUYXJnZXQud2F5cG9pbnRzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGlnbm9yZSBmaXJzdCBhbmQgbGFzdCB3YXlwb2ludFxyXG4gICAgICB2YXIgd2F5cG9pbnRzID0gc25hcFRhcmdldC53YXlwb2ludHMuc2xpY2UoMSwgLTEpO1xyXG5cclxuICAgICAgZm9yRWFjaCh3YXlwb2ludHMsIGZ1bmN0aW9uKHdheXBvaW50KSB7XHJcbiAgICAgICAgc25hcFBvaW50cy5hZGQoJ21pZCcsIHdheXBvaW50KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaGFuZGxlIHNoYXBlc1xyXG4gICAgc25hcFBvaW50cy5hZGQoJ21pZCcsIG1pZChzbmFwVGFyZ2V0KSk7XHJcbiAgfSk7XHJcblxyXG4gIGlmICghaXNOdW1iZXIoc2hhcGUueCkgfHwgIWlzTnVtYmVyKHNoYXBlLnkpKSB7XHJcbiAgICByZXR1cm4gc25hcFBvaW50cztcclxuICB9XHJcblxyXG4gIC8vIHNuYXAgdG8gb3JpZ2luYWwgcG9zaXRpb24gd2hlbiBtb3ZpbmdcclxuICBpZiAodGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChzaGFwZS5pZCkpIHtcclxuICAgIHNuYXBQb2ludHMuYWRkKCdtaWQnLCBtaWQoc2hhcGUpKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzbmFwUG9pbnRzO1xyXG59O1xyXG5cclxuQ3JlYXRlTW92ZVNuYXBwaW5nLnByb3RvdHlwZS5nZXRTbmFwVGFyZ2V0cyA9IGZ1bmN0aW9uKHNoYXBlLCB0YXJnZXQpIHtcclxuICByZXR1cm4gZ2V0Q2hpbGRyZW4odGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgIHJldHVybiAhaXNIaWRkZW4oY2hpbGQpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuLy8gaGVscGVycyAvLy8vLy8vLy8vXHJcblxyXG5mdW5jdGlvbiBpc0Nvbm5lY3Rpb24oZWxlbWVudCkge1xyXG4gIHJldHVybiAhIWVsZW1lbnQud2F5cG9pbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0hpZGRlbihlbGVtZW50KSB7XHJcbiAgcmV0dXJuICEhZWxlbWVudC5oaWRkZW47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTGFiZWwoZWxlbWVudCkge1xyXG4gIHJldHVybiAhIWVsZW1lbnQubGFiZWxUYXJnZXQ7XHJcbn0iLCJpbXBvcnQgU25hcENvbnRleHQgZnJvbSAnLi9TbmFwQ29udGV4dCc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGJvdHRvbVJpZ2h0LFxyXG4gIGdldENoaWxkcmVuLFxyXG4gIGlzU25hcHBlZCxcclxuICBzZXRTbmFwcGVkLFxyXG4gIHRvcExlZnQsXHJcbn0gZnJvbSAnLi9TbmFwVXRpbCc7XHJcblxyXG5pbXBvcnQgeyBpc0NtZCB9IGZyb20gJy4uL2tleWJvYXJkL0tleWJvYXJkVXRpbCc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGFzVFJCTCxcclxuICBnZXRNaWRcclxufSBmcm9tICcuLi8uLi9sYXlvdXQvTGF5b3V0VXRpbCc7XHJcblxyXG5pbXBvcnQgeyBmb3JFYWNoIH0gZnJvbSAnbWluLWRhc2gnO1xyXG5cclxudmFyIEhJR0hFUl9QUklPUklUWSA9IDEyNTA7XHJcblxyXG5cclxuLyoqXHJcbiAqIFNuYXAgZHVyaW5nIHJlc2l6ZS5cclxuICpcclxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcclxuICogQHBhcmFtIHtTbmFwcGluZ30gc25hcHBpbmdcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJlc2l6ZVNuYXBwaW5nKGV2ZW50QnVzLCBzbmFwcGluZykge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgZXZlbnRCdXMub24oWyAncmVzaXplLnN0YXJ0JyBdLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgc2VsZi5pbml0U25hcChldmVudCk7XHJcbiAgfSk7XHJcblxyXG4gIGV2ZW50QnVzLm9uKFtcclxuICAgICdyZXNpemUubW92ZScsXHJcbiAgICAncmVzaXplLmVuZCcsXHJcbiAgXSwgSElHSEVSX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxyXG4gICAgICAgIHNoYXBlID0gY29udGV4dC5zaGFwZSxcclxuICAgICAgICBwYXJlbnQgPSBzaGFwZS5wYXJlbnQsXHJcbiAgICAgICAgZGlyZWN0aW9uID0gY29udGV4dC5kaXJlY3Rpb24sXHJcbiAgICAgICAgc25hcENvbnRleHQgPSBjb250ZXh0LnNuYXBDb250ZXh0O1xyXG5cclxuICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50ICYmIGlzQ21kKGV2ZW50Lm9yaWdpbmFsRXZlbnQpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNTbmFwcGVkKGV2ZW50KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNuYXBQb2ludHMgPSBzbmFwQ29udGV4dC5wb2ludHNGb3JUYXJnZXQocGFyZW50KTtcclxuXHJcbiAgICBpZiAoIXNuYXBQb2ludHMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgc25hcFBvaW50cyA9IHNlbGYuYWRkU25hcFRhcmdldFBvaW50cyhzbmFwUG9pbnRzLCBzaGFwZSwgcGFyZW50LCBkaXJlY3Rpb24pO1xyXG5cclxuICAgICAgc25hcFBvaW50cy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzSG9yaXpvbnRhbChkaXJlY3Rpb24pKSB7XHJcbiAgICAgIHNldFNuYXBwZWQoZXZlbnQsICd4JywgZXZlbnQueCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzVmVydGljYWwoZGlyZWN0aW9uKSkge1xyXG4gICAgICBzZXRTbmFwcGVkKGV2ZW50LCAneScsIGV2ZW50LnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNuYXBwaW5nLnNuYXAoZXZlbnQsIHNuYXBQb2ludHMpO1xyXG4gIH0pO1xyXG5cclxuICBldmVudEJ1cy5vbihbICdyZXNpemUuY2xlYW51cCcgXSwgZnVuY3Rpb24oKSB7XHJcbiAgICBzbmFwcGluZy5oaWRlKCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcblJlc2l6ZVNuYXBwaW5nLnByb3RvdHlwZS5pbml0U25hcCA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxyXG4gICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXHJcbiAgICAgIGRpcmVjdGlvbiA9IGNvbnRleHQuZGlyZWN0aW9uLFxyXG4gICAgICBzbmFwQ29udGV4dCA9IGNvbnRleHQuc25hcENvbnRleHQ7XHJcblxyXG4gIGlmICghc25hcENvbnRleHQpIHtcclxuICAgIHNuYXBDb250ZXh0ID0gY29udGV4dC5zbmFwQ29udGV4dCA9IG5ldyBTbmFwQ29udGV4dCgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHNuYXBPcmlnaW4gPSBnZXRTbmFwT3JpZ2luKHNoYXBlLCBkaXJlY3Rpb24pO1xyXG5cclxuICBzbmFwQ29udGV4dC5zZXRTbmFwT3JpZ2luKCdjb3JuZXInLCB7XHJcbiAgICB4OiBzbmFwT3JpZ2luLnggLSBldmVudC54LFxyXG4gICAgeTogc25hcE9yaWdpbi55IC0gZXZlbnQueVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gc25hcENvbnRleHQ7XHJcbn07XHJcblxyXG5SZXNpemVTbmFwcGluZy5wcm90b3R5cGUuYWRkU25hcFRhcmdldFBvaW50cyA9IGZ1bmN0aW9uKHNuYXBQb2ludHMsIHNoYXBlLCB0YXJnZXQsIGRpcmVjdGlvbikge1xyXG4gIHZhciBzbmFwVGFyZ2V0cyA9IHRoaXMuZ2V0U25hcFRhcmdldHMoc2hhcGUsIHRhcmdldCk7XHJcblxyXG4gIGZvckVhY2goc25hcFRhcmdldHMsIGZ1bmN0aW9uKHNuYXBUYXJnZXQpIHtcclxuICAgIHNuYXBQb2ludHMuYWRkKCdjb3JuZXInLCBib3R0b21SaWdodChzbmFwVGFyZ2V0KSk7XHJcbiAgICBzbmFwUG9pbnRzLmFkZCgnY29ybmVyJywgdG9wTGVmdChzbmFwVGFyZ2V0KSk7XHJcbiAgfSk7XHJcblxyXG4gIHNuYXBQb2ludHMuYWRkKCdjb3JuZXInLCBnZXRTbmFwT3JpZ2luKHNoYXBlLCBkaXJlY3Rpb24pKTtcclxuXHJcbiAgcmV0dXJuIHNuYXBQb2ludHM7XHJcbn07XHJcblxyXG5SZXNpemVTbmFwcGluZy4kaW5qZWN0ID0gW1xyXG4gICdldmVudEJ1cycsXHJcbiAgJ3NuYXBwaW5nJ1xyXG5dO1xyXG5cclxuUmVzaXplU25hcHBpbmcucHJvdG90eXBlLmdldFNuYXBUYXJnZXRzID0gZnVuY3Rpb24oc2hhcGUsIHRhcmdldCkge1xyXG4gIHJldHVybiBnZXRDaGlsZHJlbih0YXJnZXQpLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgcmV0dXJuICFpc0F0dGFjaGVkKGNoaWxkLCBzaGFwZSlcclxuICAgICAgJiYgIWlzQ29ubmVjdGlvbihjaGlsZClcclxuICAgICAgJiYgIWlzSGlkZGVuKGNoaWxkKVxyXG4gICAgICAmJiAhaXNMYWJlbChjaGlsZCk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cclxuXHJcbmZ1bmN0aW9uIGdldFNuYXBPcmlnaW4oc2hhcGUsIGRpcmVjdGlvbikge1xyXG4gIHZhciBtaWQgPSBnZXRNaWQoc2hhcGUpLFxyXG4gICAgICB0cmJsID0gYXNUUkJMKHNoYXBlKTtcclxuXHJcbiAgdmFyIHNuYXBPcmlnaW4gPSB7XHJcbiAgICB4OiBtaWQueCxcclxuICAgIHk6IG1pZC55XHJcbiAgfTtcclxuXHJcbiAgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCduJykgIT09IC0xKSB7XHJcbiAgICBzbmFwT3JpZ2luLnkgPSB0cmJsLnRvcDtcclxuICB9IGVsc2UgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCdzJykgIT09IC0xKSB7XHJcbiAgICBzbmFwT3JpZ2luLnkgPSB0cmJsLmJvdHRvbTtcclxuICB9XHJcblxyXG4gIGlmIChkaXJlY3Rpb24uaW5kZXhPZignZScpICE9PSAtMSkge1xyXG4gICAgc25hcE9yaWdpbi54ID0gdHJibC5yaWdodDtcclxuICB9IGVsc2UgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCd3JykgIT09IC0xKSB7XHJcbiAgICBzbmFwT3JpZ2luLnggPSB0cmJsLmxlZnQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc25hcE9yaWdpbjtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNBdHRhY2hlZChlbGVtZW50LCBob3N0KSB7XHJcbiAgcmV0dXJuIGVsZW1lbnQuaG9zdCA9PT0gaG9zdDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNDb25uZWN0aW9uKGVsZW1lbnQpIHtcclxuICByZXR1cm4gISFlbGVtZW50LndheXBvaW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNIaWRkZW4oZWxlbWVudCkge1xyXG4gIHJldHVybiAhIWVsZW1lbnQuaGlkZGVuO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0xhYmVsKGVsZW1lbnQpIHtcclxuICByZXR1cm4gISFlbGVtZW50LmxhYmVsVGFyZ2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0hvcml6b250YWwoZGlyZWN0aW9uKSB7XHJcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ24nIHx8IGRpcmVjdGlvbiA9PT0gJ3MnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikge1xyXG4gIHJldHVybiBkaXJlY3Rpb24gPT09ICdlJyB8fCBkaXJlY3Rpb24gPT09ICd3JztcclxufSIsImltcG9ydCB7XG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBzbmFwVG9cbn0gZnJvbSAnLi9TbmFwVXRpbCc7XG5cblxuLyoqXG4gKiBBIHNuYXAgY29udGV4dCwgY29udGFpbmluZyB0aGUgKHBvc3NpYmx5IGluY29tcGxldGUpXG4gKiBtYXBwaW5ncyBvZiBkcm9wIHRhcmdldHMgKHRvIGlkZW50aWZ5IHRoZSBzbmFwcGluZylcbiAqIHRvIGNvbXB1dGVkIHNuYXAgcG9pbnRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTbmFwQ29udGV4dCgpIHtcblxuICAvKipcbiAgICogTWFwPFN0cmluZywgU25hcFBvaW50cz4gbWFwcGluZyBkcm9wIHRhcmdldHMgdG9cbiAgICogYSBsaXN0IG9mIHBvc3NpYmxlIHNuYXBwaW5ncy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuX3RhcmdldHMgPSB7fTtcblxuICAvKipcbiAgICogTWFwPFN0cmluZywgUG9pbnQ+IGluaXRpYWwgcG9zaXRpb25pbmcgb2YgZWxlbWVudFxuICAgKiByZWdhcmRpbmcgdmFyaW91cyBzbmFwIGRpcmVjdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLl9zbmFwT3JpZ2lucyA9IHt9O1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHNuYXAgbG9jYXRpb25zXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgKi9cbiAgdGhpcy5fc25hcExvY2F0aW9ucyA9IFtdO1xuXG4gIC8qKlxuICAgKiBNYXA8U3RyaW5nLCBBcnJheTxQb2ludD4+IG9mIGRlZmF1bHQgc25hcHBpbmcgbG9jYXRpb25zXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLl9kZWZhdWx0U25hcHMgPSB7fTtcbn1cblxuXG5TbmFwQ29udGV4dC5wcm90b3R5cGUuZ2V0U25hcE9yaWdpbiA9IGZ1bmN0aW9uKHNuYXBMb2NhdGlvbikge1xuICByZXR1cm4gdGhpcy5fc25hcE9yaWdpbnNbc25hcExvY2F0aW9uXTtcbn07XG5cblxuU25hcENvbnRleHQucHJvdG90eXBlLnNldFNuYXBPcmlnaW4gPSBmdW5jdGlvbihzbmFwTG9jYXRpb24sIGluaXRpYWxWYWx1ZSkge1xuICB0aGlzLl9zbmFwT3JpZ2luc1tzbmFwTG9jYXRpb25dID0gaW5pdGlhbFZhbHVlO1xuXG4gIGlmICh0aGlzLl9zbmFwTG9jYXRpb25zLmluZGV4T2Yoc25hcExvY2F0aW9uKSA9PT0gLTEpIHtcbiAgICB0aGlzLl9zbmFwTG9jYXRpb25zLnB1c2goc25hcExvY2F0aW9uKTtcbiAgfVxufTtcblxuXG5TbmFwQ29udGV4dC5wcm90b3R5cGUuYWRkRGVmYXVsdFNuYXAgPSBmdW5jdGlvbih0eXBlLCBwb2ludCkge1xuXG4gIHZhciBzbmFwVmFsdWVzID0gdGhpcy5fZGVmYXVsdFNuYXBzW3R5cGVdO1xuXG4gIGlmICghc25hcFZhbHVlcykge1xuICAgIHNuYXBWYWx1ZXMgPSB0aGlzLl9kZWZhdWx0U25hcHNbdHlwZV0gPSBbXTtcbiAgfVxuXG4gIHNuYXBWYWx1ZXMucHVzaChwb2ludCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIG51bWJlciBvZiBpbml0aWFsaXplZCBzbmFwcywgaS5lLiBzbmFwIGxvY2F0aW9ucyBzdWNoIGFzXG4gKiB0b3AtbGVmdCwgbWlkLCBib3R0b20tcmlnaHQgYW5kIHNvIGZvcnRoLlxuICpcbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IHNuYXBMb2NhdGlvbnNcbiAqL1xuU25hcENvbnRleHQucHJvdG90eXBlLmdldFNuYXBMb2NhdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NuYXBMb2NhdGlvbnM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc25hcCBsb2NhdGlvbnMgZm9yIHRoaXMgY29udGV4dC5cbiAqXG4gKiBUaGUgb3JkZXIgb2YgbG9jYXRpb25zIGRldGVybWluZXMgcHJlY2VkZW5jZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNuYXBMb2NhdGlvbnNcbiAqL1xuU25hcENvbnRleHQucHJvdG90eXBlLnNldFNuYXBMb2NhdGlvbnMgPSBmdW5jdGlvbihzbmFwTG9jYXRpb25zKSB7XG4gIHRoaXMuX3NuYXBMb2NhdGlvbnMgPSBzbmFwTG9jYXRpb25zO1xufTtcblxuLyoqXG4gKiBHZXQgc25hcCBwb2ludHMgZm9yIGEgZ2l2ZW4gdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gdGFyZ2V0XG4gKi9cblNuYXBDb250ZXh0LnByb3RvdHlwZS5wb2ludHNGb3JUYXJnZXQgPSBmdW5jdGlvbih0YXJnZXQpIHtcblxuICB2YXIgdGFyZ2V0SWQgPSB0YXJnZXQuaWQgfHwgdGFyZ2V0O1xuXG4gIHZhciBzbmFwUG9pbnRzID0gdGhpcy5fdGFyZ2V0c1t0YXJnZXRJZF07XG5cbiAgaWYgKCFzbmFwUG9pbnRzKSB7XG4gICAgc25hcFBvaW50cyA9IHRoaXMuX3RhcmdldHNbdGFyZ2V0SWRdID0gbmV3IFNuYXBQb2ludHMoKTtcbiAgICBzbmFwUG9pbnRzLmluaXREZWZhdWx0cyh0aGlzLl9kZWZhdWx0U25hcHMpO1xuICB9XG5cbiAgcmV0dXJuIHNuYXBQb2ludHM7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgc25hcCBwb2ludHMgYW5kIGluaXRpYWxpemVzIHRoZW0gd2l0aCB0aGVcbiAqIGdpdmVuIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgQXJyYXk8UG9pbnQ+Pn0gW2RlZmF1bHRQb2ludHNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTbmFwUG9pbnRzKGRlZmF1bHRTbmFwcykge1xuXG4gIC8qKlxuICAgKiBNYXA8U3RyaW5nLCBNYXA8KHh8eSksIEFycmF5PG51bWJlcj4+PiBtYXBwaW5nIHNuYXAgbG9jYXRpb25zLFxuICAgKiBpLmUuIHRvcC1sZWZ0LCBib3R0b20tcmlnaHQsIGNlbnRlciB0byBhY3R1YWwgc25hcCB2YWx1ZXMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLl9zbmFwVmFsdWVzID0ge307XG59XG5cblNuYXBQb2ludHMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHNuYXBMb2NhdGlvbiwgcG9pbnQpIHtcblxuICB2YXIgc25hcFZhbHVlcyA9IHRoaXMuX3NuYXBWYWx1ZXNbc25hcExvY2F0aW9uXTtcblxuICBpZiAoIXNuYXBWYWx1ZXMpIHtcbiAgICBzbmFwVmFsdWVzID0gdGhpcy5fc25hcFZhbHVlc1tzbmFwTG9jYXRpb25dID0geyB4OiBbXSwgeTogW10gfTtcbiAgfVxuXG4gIGlmIChzbmFwVmFsdWVzLnguaW5kZXhPZihwb2ludC54KSA9PT0gLTEpIHtcbiAgICBzbmFwVmFsdWVzLngucHVzaChwb2ludC54KTtcbiAgfVxuXG4gIGlmIChzbmFwVmFsdWVzLnkuaW5kZXhPZihwb2ludC55KSA9PT0gLTEpIHtcbiAgICBzbmFwVmFsdWVzLnkucHVzaChwb2ludC55KTtcbiAgfVxufTtcblxuXG5TbmFwUG9pbnRzLnByb3RvdHlwZS5zbmFwID0gZnVuY3Rpb24ocG9pbnQsIHNuYXBMb2NhdGlvbiwgYXhpcywgdG9sZXJhbmNlKSB7XG4gIHZhciBzbmFwcGluZ1ZhbHVlcyA9IHRoaXMuX3NuYXBWYWx1ZXNbc25hcExvY2F0aW9uXTtcblxuICByZXR1cm4gc25hcHBpbmdWYWx1ZXMgJiYgc25hcFRvKHBvaW50W2F4aXNdLCBzbmFwcGluZ1ZhbHVlc1theGlzXSwgdG9sZXJhbmNlKTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG51bWJlciBvZiBkZWZhdWx0IHNuYXBwaW5nIHBvaW50cy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRlZmF1bHRTbmFwc1xuICovXG5TbmFwUG9pbnRzLnByb3RvdHlwZS5pbml0RGVmYXVsdHMgPSBmdW5jdGlvbihkZWZhdWx0U25hcHMpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZm9yRWFjaChkZWZhdWx0U25hcHMgfHwge30sIGZ1bmN0aW9uKHNuYXBQb2ludHMsIHNuYXBMb2NhdGlvbikge1xuICAgIGZvckVhY2goc25hcFBvaW50cywgZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIHNlbGYuYWRkKHNuYXBMb2NhdGlvbiwgcG9pbnQpO1xuICAgIH0pO1xuICB9KTtcbn07IiwidmFyIGFicyA9IE1hdGguYWJzLFxuICAgIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuXG4vKipcbiAqIFNuYXAgdmFsdWUgdG8gYSBjb2xsZWN0aW9uIG9mIHJlZmVyZW5jZSB2YWx1ZXMuXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtICB7QXJyYXk8bnVtYmVyPn0gdmFsdWVzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt0b2xlcmFuY2U9MTBdXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgdmFsdWUgd2Ugc25hcHBlZCB0byBvciBudWxsLCBpZiBub25lIHNuYXBwZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuYXBUbyh2YWx1ZSwgdmFsdWVzLCB0b2xlcmFuY2UpIHtcbiAgdG9sZXJhbmNlID0gdG9sZXJhbmNlID09PSB1bmRlZmluZWQgPyAxMCA6IHRvbGVyYW5jZTtcblxuICB2YXIgaWR4LCBzbmFwVmFsdWU7XG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCB2YWx1ZXMubGVuZ3RoOyBpZHgrKykge1xuICAgIHNuYXBWYWx1ZSA9IHZhbHVlc1tpZHhdO1xuXG4gICAgaWYgKGFicyhzbmFwVmFsdWUgLSB2YWx1ZSkgPD0gdG9sZXJhbmNlKSB7XG4gICAgICByZXR1cm4gc25hcFZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB0b3BMZWZ0KGJvdW5kcykge1xuICByZXR1cm4ge1xuICAgIHg6IGJvdW5kcy54LFxuICAgIHk6IGJvdW5kcy55XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b3BSaWdodChib3VuZHMpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBib3VuZHMueCArIGJvdW5kcy53aWR0aCxcbiAgICB5OiBib3VuZHMueVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm90dG9tTGVmdChib3VuZHMpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBib3VuZHMueCxcbiAgICB5OiBib3VuZHMueSArIGJvdW5kcy5oZWlnaHRcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJvdHRvbVJpZ2h0KGJvdW5kcykge1xuICByZXR1cm4ge1xuICAgIHg6IGJvdW5kcy54ICsgYm91bmRzLndpZHRoLFxuICAgIHk6IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWlkKGJvdW5kcywgZGVmYXVsdFZhbHVlKSB7XG5cbiAgaWYgKCFib3VuZHMgfHwgaXNOYU4oYm91bmRzLngpIHx8IGlzTmFOKGJvdW5kcy55KSkge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMiksXG4gICAgeTogcm91bmQoYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IC8gMilcbiAgfTtcbn1cblxuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBzbmFwIHN0YXRlIG9mIHRoZSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0gIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gYXhpc1xuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRoZSBzbmFwcGVkIHN0YXRlXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTbmFwcGVkKGV2ZW50LCBheGlzKSB7XG4gIHZhciBzbmFwcGVkID0gZXZlbnQuc25hcHBlZDtcblxuICBpZiAoIXNuYXBwZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGF4aXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHNuYXBwZWRbYXhpc107XG4gIH1cblxuICByZXR1cm4gc25hcHBlZC54ICYmIHNuYXBwZWQueTtcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgZ2l2ZW4gZXZlbnQgYXMgc25hcHBlZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBtYXkgY2hhbmdlIHRoZSB4IGFuZC9vciB5IHBvc2l0aW9uIG9mIHRoZSBzaGFwZVxuICogZnJvbSB0aGUgZ2l2ZW4gZXZlbnQhXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzXG4gKiBAcGFyYW0ge251bWJlcnxib29sZWFufSB2YWx1ZVxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gb2xkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRTbmFwcGVkKGV2ZW50LCBheGlzLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIGF4aXMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdheGlzIG11c3QgYmUgaW4gW3gsIHldJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgTnVtYmVyIG9yIGZhbHNlJyk7XG4gIH1cblxuICB2YXIgZGVsdGEsXG4gICAgICBwcmV2aW91c1ZhbHVlID0gZXZlbnRbYXhpc107XG5cbiAgdmFyIHNuYXBwZWQgPSBldmVudC5zbmFwcGVkID0gKGV2ZW50LnNuYXBwZWQgfHwge30pO1xuXG5cbiAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgIHNuYXBwZWRbYXhpc10gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBzbmFwcGVkW2F4aXNdID0gdHJ1ZTtcblxuICAgIGRlbHRhID0gdmFsdWUgLSBwcmV2aW91c1ZhbHVlO1xuXG4gICAgZXZlbnRbYXhpc10gKz0gZGVsdGE7XG4gICAgZXZlbnRbJ2QnICsgYXhpc10gKz0gZGVsdGE7XG4gIH1cblxuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBHZXQgY2hpbGRyZW4gb2YgYSBzaGFwZS5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5TaGFwZX0gcGFyZW50XG4gKlxuICogQHJldHVybnMge0FycmF5PGRqcy5tb2RlbC5TaGFwZXxkanMubW9kZWwuQ29ubmVjdGlvbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGlsZHJlbihwYXJlbnQpIHtcbiAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbiB8fCBbXTtcbn0iLCJpbXBvcnQge1xuICBiaW5kLFxuICBkZWJvdW5jZSxcbiAgZm9yRWFjaCxcbiAgaXNOdW1iZXIsXG4gIGlzT2JqZWN0XG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgaXNTbmFwcGVkLFxuICBzZXRTbmFwcGVkXG59IGZyb20gJy4vU25hcFV0aWwnO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNsYXNzZXMgYXMgc3ZnQ2xhc3NlcyxcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbnZhciBTTkFQX1RPTEVSQU5DRSA9IDc7XG5cbmV4cG9ydCB2YXIgU05BUF9MSU5FX0hJREVfREVMQVkgPSAxMDAwO1xuXG5cbi8qKlxuICogR2VuZXJpYyBzbmFwcGluZyBmZWF0dXJlLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNuYXBwaW5nKGNhbnZhcykge1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG5cbiAgLy8gZGVsYXkgaGlkZSBieSAxMDAwIHNlY29uZHMgc2luY2UgbGFzdCBzbmFwXG4gIHRoaXMuX2FzeW5jSGlkZSA9IGRlYm91bmNlKGJpbmQodGhpcy5oaWRlLCB0aGlzKSwgU05BUF9MSU5FX0hJREVfREVMQVkpO1xufVxuXG5TbmFwcGluZy4kaW5qZWN0ID0gWyAnY2FudmFzJyBdO1xuXG4vKipcbiAqIFNuYXAgYW4gZXZlbnQgdG8gZ2l2ZW4gc25hcCBwb2ludHMuXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7U25hcFBvaW50c30gc25hcFBvaW50c1xuICovXG5TbmFwcGluZy5wcm90b3R5cGUuc25hcCA9IGZ1bmN0aW9uKGV2ZW50LCBzbmFwUG9pbnRzKSB7XG4gIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgIHNuYXBDb250ZXh0ID0gY29udGV4dC5zbmFwQ29udGV4dCxcbiAgICAgIHNuYXBMb2NhdGlvbnMgPSBzbmFwQ29udGV4dC5nZXRTbmFwTG9jYXRpb25zKCk7XG5cbiAgdmFyIHNuYXBwaW5nID0ge1xuICAgIHg6IGlzU25hcHBlZChldmVudCwgJ3gnKSxcbiAgICB5OiBpc1NuYXBwZWQoZXZlbnQsICd5JylcbiAgfTtcblxuICBmb3JFYWNoKHNuYXBMb2NhdGlvbnMsIGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG4gICAgdmFyIHNuYXBPcmlnaW4gPSBzbmFwQ29udGV4dC5nZXRTbmFwT3JpZ2luKGxvY2F0aW9uKTtcblxuICAgIHZhciBzbmFwQ3VycmVudCA9IHtcbiAgICAgIHg6IGV2ZW50LnggKyBzbmFwT3JpZ2luLngsXG4gICAgICB5OiBldmVudC55ICsgc25hcE9yaWdpbi55XG4gICAgfTtcblxuICAgIC8vIHNuYXAgYm90aCBheGlzIGlmIG5vdCBzbmFwcGVkIGFscmVhZHlcbiAgICBmb3JFYWNoKFsgJ3gnLCAneScgXSwgZnVuY3Rpb24oYXhpcykge1xuICAgICAgdmFyIGxvY2F0aW9uU25hcHBpbmc7XG5cbiAgICAgIGlmICghc25hcHBpbmdbYXhpc10pIHtcbiAgICAgICAgbG9jYXRpb25TbmFwcGluZyA9IHNuYXBQb2ludHMuc25hcChzbmFwQ3VycmVudCwgbG9jYXRpb24sIGF4aXMsIFNOQVBfVE9MRVJBTkNFKTtcblxuICAgICAgICBpZiAobG9jYXRpb25TbmFwcGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc25hcHBpbmdbYXhpc10gPSB7XG4gICAgICAgICAgICB2YWx1ZTogbG9jYXRpb25TbmFwcGluZyxcbiAgICAgICAgICAgIG9yaWdpblZhbHVlOiBsb2NhdGlvblNuYXBwaW5nIC0gc25hcE9yaWdpbltheGlzXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIG5vIG5lZWQgdG8gY29udGludWUgc25hcHBpbmdcbiAgICBpZiAoc25hcHBpbmcueCAmJiBzbmFwcGluZy55KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICAvLyBzaG93IHNuYXAgbGluZXNcbiAgdGhpcy5zaG93U25hcExpbmUoJ3ZlcnRpY2FsJywgc25hcHBpbmcueCAmJiBzbmFwcGluZy54LnZhbHVlKTtcbiAgdGhpcy5zaG93U25hcExpbmUoJ2hvcml6b250YWwnLCBzbmFwcGluZy55ICYmIHNuYXBwaW5nLnkudmFsdWUpO1xuXG4gIC8vIHNuYXAgZXZlbnRcbiAgZm9yRWFjaChbICd4JywgJ3knIF0sIGZ1bmN0aW9uKGF4aXMpIHtcbiAgICB2YXIgYXhpc1NuYXBwaW5nID0gc25hcHBpbmdbYXhpc107XG5cbiAgICBpZiAoaXNPYmplY3QoYXhpc1NuYXBwaW5nKSkge1xuICAgICAgc2V0U25hcHBlZChldmVudCwgYXhpcywgYXhpc1NuYXBwaW5nLm9yaWdpblZhbHVlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuU25hcHBpbmcucHJvdG90eXBlLl9jcmVhdGVMaW5lID0gZnVuY3Rpb24ob3JpZW50YXRpb24pIHtcbiAgdmFyIHJvb3QgPSB0aGlzLl9jYW52YXMuZ2V0TGF5ZXIoJ3NuYXAnKTtcblxuICB2YXIgbGluZSA9IHN2Z0NyZWF0ZSgncGF0aCcpO1xuXG4gIHN2Z0F0dHIobGluZSwgeyBkOiAnTTAsMCBMMCwwJyB9KTtcblxuICBzdmdDbGFzc2VzKGxpbmUpLmFkZCgnZGpzLXNuYXAtbGluZScpO1xuXG4gIHN2Z0FwcGVuZChyb290LCBsaW5lKTtcblxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24ocG9zaXRpb24pIHtcblxuICAgICAgaWYgKCFpc051bWJlcihwb3NpdGlvbikpIHtcbiAgICAgICAgc3ZnQXR0cihsaW5lLCB7IGRpc3BsYXk6ICdub25lJyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgc3ZnQXR0cihsaW5lLCB7XG4gICAgICAgICAgICBkOiAnTS0xMDAwMDAsJyArIHBvc2l0aW9uICsgJyBMKzEwMDAwMCwnICsgcG9zaXRpb24sXG4gICAgICAgICAgICBkaXNwbGF5OiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN2Z0F0dHIobGluZSwge1xuICAgICAgICAgICAgZDogJ00gJyArIHBvc2l0aW9uICsgJywtMTAwMDAwIEwgJyArIHBvc2l0aW9uICsgJywgKzEwMDAwMCcsXG4gICAgICAgICAgICBkaXNwbGF5OiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuU25hcHBpbmcucHJvdG90eXBlLl9jcmVhdGVTbmFwTGluZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc25hcExpbmVzID0ge1xuICAgIGhvcml6b250YWw6IHRoaXMuX2NyZWF0ZUxpbmUoJ2hvcml6b250YWwnKSxcbiAgICB2ZXJ0aWNhbDogdGhpcy5fY3JlYXRlTGluZSgndmVydGljYWwnKVxuICB9O1xufTtcblxuU25hcHBpbmcucHJvdG90eXBlLnNob3dTbmFwTGluZSA9IGZ1bmN0aW9uKG9yaWVudGF0aW9uLCBwb3NpdGlvbikge1xuXG4gIHZhciBsaW5lID0gdGhpcy5nZXRTbmFwTGluZShvcmllbnRhdGlvbik7XG5cbiAgaWYgKGxpbmUpIHtcbiAgICBsaW5lLnVwZGF0ZShwb3NpdGlvbik7XG4gIH1cblxuICB0aGlzLl9hc3luY0hpZGUoKTtcbn07XG5cblNuYXBwaW5nLnByb3RvdHlwZS5nZXRTbmFwTGluZSA9IGZ1bmN0aW9uKG9yaWVudGF0aW9uKSB7XG4gIGlmICghdGhpcy5fc25hcExpbmVzKSB7XG4gICAgdGhpcy5fY3JlYXRlU25hcExpbmVzKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fc25hcExpbmVzW29yaWVudGF0aW9uXTtcbn07XG5cblNuYXBwaW5nLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIGZvckVhY2godGhpcy5fc25hcExpbmVzLCBmdW5jdGlvbihzbmFwTGluZSkge1xuICAgIHNuYXBMaW5lLnVwZGF0ZSgpO1xuICB9KTtcbn07XG4iLCJpbXBvcnQgQ3JlYXRlTW92ZVNuYXBwaW5nIGZyb20gJy4vQ3JlYXRlTW92ZVNuYXBwaW5nJztcbmltcG9ydCBSZXNpemVTbmFwcGluZyBmcm9tICcuL1Jlc2l6ZVNuYXBwaW5nJztcbmltcG9ydCBTbmFwcGluZyBmcm9tICcuL1NuYXBwaW5nJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogW1xuICAgICdjcmVhdGVNb3ZlU25hcHBpbmcnLFxuICAgICdyZXNpemVTbmFwcGluZycsXG4gICAgJ3NuYXBwaW5nJ1xuICBdLFxuICBjcmVhdGVNb3ZlU25hcHBpbmc6IFsgJ3R5cGUnLCBDcmVhdGVNb3ZlU25hcHBpbmcgXSxcbiAgcmVzaXplU25hcHBpbmc6IFsgJ3R5cGUnLCBSZXNpemVTbmFwcGluZyBdLFxuICBzbmFwcGluZzogWyAndHlwZScsIFNuYXBwaW5nIF1cbn07IiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmaWx0ZXIsXG4gIGZvckVhY2gsXG4gIGlzTnVtYmVyXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHsgYXNUUkJMIH0gZnJvbSAnLi4vLi4vbGF5b3V0L0xheW91dFV0aWwnO1xuXG5pbXBvcnQgeyBnZXRCQm94IH0gZnJvbSAnLi4vLi4vdXRpbC9FbGVtZW50cyc7XG5cbmltcG9ydCB7IGdldERpcmVjdGlvbiB9IGZyb20gJy4vU3BhY2VVdGlsJztcblxuaW1wb3J0IHsgaGFzUHJpbWFyeU1vZGlmaWVyIH0gZnJvbSAnLi4vLi4vdXRpbC9Nb3VzZSc7XG5cbmltcG9ydCB7IHNldCBhcyBzZXRDdXJzb3IgfSBmcm9tICcuLi8uLi91dGlsL0N1cnNvcic7XG5cbmltcG9ydCB7IHNlbGZBbmRBbGxDaGlsZHJlbiB9IGZyb20gJy4uLy4uL3V0aWwvRWxlbWVudHMnO1xuXG52YXIgYWJzID0gTWF0aC5hYnMsXG4gICAgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG52YXIgQVhJU19UT19ESU1FTlNJT04gPSB7XG4gIHg6ICd3aWR0aCcsXG4gIHk6ICdoZWlnaHQnXG59O1xuXG52YXIgQ1VSU09SX0NST1NTSEFJUiA9ICdjcm9zc2hhaXInO1xuXG52YXIgRElSRUNUSU9OX1RPX1RSQkwgPSB7XG4gIG46ICd0b3AnLFxuICB3OiAnbGVmdCcsXG4gIHM6ICdib3R0b20nLFxuICBlOiAncmlnaHQnXG59O1xuXG52YXIgSElHSF9QUklPUklUWSA9IDE1MDA7XG5cbnZhciBESVJFQ1RJT05fVE9fT1BQT1NJVEUgPSB7XG4gIG46ICdzJyxcbiAgdzogJ2UnLFxuICBzOiAnbicsXG4gIGU6ICd3J1xufTtcblxudmFyIFBBRERJTkcgPSAyMDtcblxuXG4vKipcbiAqIEFkZCBvciByZW1vdmUgc3BhY2UgYnkgbW92aW5nIGFuZCByZXNpemluZyBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKiBAcGFyYW0ge0RyYWdnaW5nfSBkcmFnZ2luZ1xuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKiBAcGFyYW0ge1J1bGVzfSBydWxlc1xuICogQHBhcmFtIHtUb29sTWFuYWdlcn0gdG9vbE1hbmFnZXJcbiAqIEBwYXJhbSB7TW91c2V9IG1vdXNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNwYWNlVG9vbChcbiAgICBjYW52YXMsIGRyYWdnaW5nLCBldmVudEJ1cyxcbiAgICBtb2RlbGluZywgcnVsZXMsIHRvb2xNYW5hZ2VyLFxuICAgIG1vdXNlKSB7XG5cbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICB0aGlzLl9kcmFnZ2luZyA9IGRyYWdnaW5nO1xuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuICB0aGlzLl9ydWxlcyA9IHJ1bGVzO1xuICB0aGlzLl90b29sTWFuYWdlciA9IHRvb2xNYW5hZ2VyO1xuICB0aGlzLl9tb3VzZSA9IG1vdXNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0b29sTWFuYWdlci5yZWdpc3RlclRvb2woJ3NwYWNlJywge1xuICAgIHRvb2w6ICdzcGFjZVRvb2wuc2VsZWN0aW9uJyxcbiAgICBkcmFnZ2luZzogJ3NwYWNlVG9vbCdcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ3NwYWNlVG9vbC5zZWxlY3Rpb24uZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBldmVudEJ1cy5vbmNlKCdzcGFjZVRvb2wuc2VsZWN0aW9uLmVuZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmFjdGl2YXRlTWFrZVNwYWNlKGV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuICAgIH0pO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignc3BhY2VUb29sLm1vdmUnLCBISUdIX1BSSU9SSVRZICwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGluaXRpYWxpemVkID0gY29udGV4dC5pbml0aWFsaXplZDtcblxuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGluaXRpYWxpemVkID0gY29udGV4dC5pbml0aWFsaXplZCA9IHNlbGYuaW5pdChldmVudCwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICBlbnN1cmVDb25zdHJhaW50cyhldmVudCk7XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbignc3BhY2VUb29sLmVuZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBheGlzID0gY29udGV4dC5heGlzLFxuICAgICAgICBkaXJlY3Rpb24gPSBjb250ZXh0LmRpcmVjdGlvbixcbiAgICAgICAgbW92aW5nU2hhcGVzID0gY29udGV4dC5tb3ZpbmdTaGFwZXMsXG4gICAgICAgIHJlc2l6aW5nU2hhcGVzID0gY29udGV4dC5yZXNpemluZ1NoYXBlcyxcbiAgICAgICAgc3RhcnQgPSBjb250ZXh0LnN0YXJ0O1xuXG4gICAgaWYgKCFjb250ZXh0LmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZW5zdXJlQ29uc3RyYWludHMoZXZlbnQpO1xuXG4gICAgdmFyIGRlbHRhID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuXG4gICAgZGVsdGFbIGF4aXMgXSA9IHJvdW5kKGV2ZW50WyAnZCcgKyBheGlzIF0pO1xuXG4gICAgc2VsZi5tYWtlU3BhY2UobW92aW5nU2hhcGVzLCByZXNpemluZ1NoYXBlcywgZGVsdGEsIGRpcmVjdGlvbiwgc3RhcnQpO1xuXG4gICAgZXZlbnRCdXMub25jZSgnc3BhY2VUb29sLmVuZGVkJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgLy8gYWN0aXZhdGUgc3BhY2UgdG9vbCBzZWxlY3Rpb24gYWZ0ZXIgbWFrZSBzcGFjZVxuICAgICAgc2VsZi5hY3RpdmF0ZVNlbGVjdGlvbihldmVudC5vcmlnaW5hbEV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblNwYWNlVG9vbC4kaW5qZWN0ID0gW1xuICAnY2FudmFzJyxcbiAgJ2RyYWdnaW5nJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ3J1bGVzJyxcbiAgJ3Rvb2xNYW5hZ2VyJyxcbiAgJ21vdXNlJ1xuXTtcblxuLyoqXG4gKiBBY3RpdmF0ZSBzcGFjZSB0b29sIHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b0FjdGl2YXRlXG4gKi9cblNwYWNlVG9vbC5wcm90b3R5cGUuYWN0aXZhdGVTZWxlY3Rpb24gPSBmdW5jdGlvbihldmVudCwgYXV0b0FjdGl2YXRlLCByZWFjdGl2YXRlKSB7XG4gIHRoaXMuX2RyYWdnaW5nLmluaXQoZXZlbnQsICdzcGFjZVRvb2wuc2VsZWN0aW9uJywge1xuICAgIGF1dG9BY3RpdmF0ZTogYXV0b0FjdGl2YXRlLFxuICAgIGN1cnNvcjogQ1VSU09SX0NST1NTSEFJUixcbiAgICBkYXRhOiB7XG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIHJlYWN0aXZhdGU6IHJlYWN0aXZhdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyYXBDbGljazogZmFsc2VcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFjdGl2YXRlIHNwYWNlIHRvb2wgbWFrZSBzcGFjZS5cbiAqXG4gKiBAcGFyYW0gIHtNb3VzZUV2ZW50fSBldmVudFxuICovXG5TcGFjZVRvb2wucHJvdG90eXBlLmFjdGl2YXRlTWFrZVNwYWNlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdGhpcy5fZHJhZ2dpbmcuaW5pdChldmVudCwgJ3NwYWNlVG9vbCcsIHtcbiAgICBhdXRvQWN0aXZhdGU6IHRydWUsXG4gICAgY3Vyc29yOiBDVVJTT1JfQ1JPU1NIQUlSLFxuICAgIGRhdGE6IHtcbiAgICAgIGNvbnRleHQ6IHt9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogTWFrZSBzcGFjZS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxkanMubW9kZWwuU2hhcGU+fSBtb3ZpbmdTaGFwZXNcbiAqIEBwYXJhbSAge0FycmF5PGRqcy5tb2RlbC5TaGFwZT59IHJlc2l6aW5nU2hhcGVzXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRlbHRhXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRlbHRhLnhcbiAqIEBwYXJhbSAge251bWJlcn0gZGVsdGEueVxuICogQHBhcmFtICB7c3RyaW5nfSBkaXJlY3Rpb25cbiAqIEBwYXJhbSAge251bWJlcn0gc3RhcnRcbiAqL1xuU3BhY2VUb29sLnByb3RvdHlwZS5tYWtlU3BhY2UgPSBmdW5jdGlvbihtb3ZpbmdTaGFwZXMsIHJlc2l6aW5nU2hhcGVzLCBkZWx0YSwgZGlyZWN0aW9uLCBzdGFydCkge1xuICByZXR1cm4gdGhpcy5fbW9kZWxpbmcuY3JlYXRlU3BhY2UobW92aW5nU2hhcGVzLCByZXNpemluZ1NoYXBlcywgZGVsdGEsIGRpcmVjdGlvbiwgc3RhcnQpO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIG1ha2Ugc3BhY2UgYW5kIHJldHVybiB0cnVlIGlmIHRoYXQgd2FzIHN1Y2Nlc3NmdWwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblNwYWNlVG9vbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGV2ZW50LCBjb250ZXh0KSB7XG4gIHZhciBheGlzID0gYWJzKGV2ZW50LmR4KSA+IGFicyhldmVudC5keSkgPyAneCcgOiAneScsXG4gICAgICBkZWx0YSA9IGV2ZW50WyAnZCcgKyBheGlzIF0sXG4gICAgICBzdGFydCA9IGV2ZW50WyBheGlzIF0gLSBkZWx0YTtcblxuICBpZiAoYWJzKGRlbHRhKSA8IDUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpbnZlcnQgZGVsdGEgdG8gcmVtb3ZlIHNwYWNlIHdoZW4gbW92aW5nIGxlZnRcbiAgaWYgKGRlbHRhIDwgMCkge1xuICAgIGRlbHRhICo9IC0xO1xuICB9XG5cbiAgLy8gaW52ZXJ0IGRlbHRhIHRvIGFkZC9yZW1vdmUgc3BhY2Ugd2hlbiByZW1vdmluZy9hZGRpbmcgc3BhY2UgaWYgbW9kaWZpZXIga2V5IGlzIHByZXNzZWRcbiAgaWYgKGhhc1ByaW1hcnlNb2RpZmllcihldmVudCkpIHtcbiAgICBkZWx0YSAqPSAtMTtcbiAgfVxuXG4gIHZhciBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oYXhpcywgZGVsdGEpO1xuXG4gIHZhciByb290ID0gdGhpcy5fY2FudmFzLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgdmFyIGNoaWxkcmVuID0gc2VsZkFuZEFsbENoaWxkcmVuKHJvb3QsIHRydWUpO1xuXG4gIHZhciBlbGVtZW50cyA9IHRoaXMuY2FsY3VsYXRlQWRqdXN0bWVudHMoY2hpbGRyZW4sIGF4aXMsIGRlbHRhLCBzdGFydCk7XG5cbiAgdmFyIG1pbkRpbWVuc2lvbnMgPSB0aGlzLl9ldmVudEJ1cy5maXJlKCdzcGFjZVRvb2wuZ2V0TWluRGltZW5zaW9ucycsIHtcbiAgICBheGlzOiBheGlzLFxuICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgIHNoYXBlczogZWxlbWVudHMucmVzaXppbmdTaGFwZXMsXG4gICAgc3RhcnQ6IHN0YXJ0XG4gIH0pO1xuXG4gIHZhciBzcGFjZVRvb2xDb25zdHJhaW50cyA9IGdldFNwYWNlVG9vbENvbnN0cmFpbnRzKGVsZW1lbnRzLCBheGlzLCBkaXJlY3Rpb24sIHN0YXJ0LCBtaW5EaW1lbnNpb25zKTtcblxuICBhc3NpZ24oXG4gICAgY29udGV4dCxcbiAgICBlbGVtZW50cyxcbiAgICB7XG4gICAgICBheGlzOiBheGlzLFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICBzcGFjZVRvb2xDb25zdHJhaW50czogc3BhY2VUb29sQ29uc3RyYWludHMsXG4gICAgICBzdGFydDogc3RhcnRcbiAgICB9XG4gICk7XG5cbiAgc2V0Q3Vyc29yKCdyZXNpemUtJyArIChheGlzID09PSAneCcgPyAnZXcnIDogJ25zJykpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBHZXQgZWxlbWVudHMgdG8gYmUgbW92ZWQgYW5kIHJlc2l6ZWQuXG4gKlxuICogQHBhcmFtICB7QXJyYXk8ZGpzLm1vZGVsLlNoYXBlPn0gZWxlbWVudHNcbiAqIEBwYXJhbSAge3N0cmluZ30gYXhpc1xuICogQHBhcmFtICB7bnVtYmVyfSBkZWx0YVxuICogQHBhcmFtICB7bnVtYmVyfSBzdGFydFxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuU3BhY2VUb29sLnByb3RvdHlwZS5jYWxjdWxhdGVBZGp1c3RtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBheGlzLCBkZWx0YSwgc3RhcnQpIHtcbiAgdmFyIHJ1bGVzID0gdGhpcy5fcnVsZXM7XG5cbiAgdmFyIG1vdmluZ1NoYXBlcyA9IFtdLFxuICAgICAgcmVzaXppbmdTaGFwZXMgPSBbXTtcblxuICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50LnBhcmVudCB8fCBpc0Nvbm5lY3Rpb24oZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVTdGFydCA9IGVsZW1lbnRbIGF4aXMgXSxcbiAgICAgICAgc2hhcGVFbmQgPSBzaGFwZVN0YXJ0ICsgZWxlbWVudFsgQVhJU19UT19ESU1FTlNJT05bIGF4aXMgXSBdO1xuXG4gICAgLy8gc2hhcGUgdG8gYmUgbW92ZWRcbiAgICBpZiAoKGRlbHRhID4gMCAmJiBzaGFwZVN0YXJ0ID4gc3RhcnQpIHx8IChkZWx0YSA8IDAgJiYgc2hhcGVFbmQgPCBzdGFydCkpIHtcbiAgICAgIHJldHVybiBtb3ZpbmdTaGFwZXMucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBzaGFwZSB0byBiZSByZXNpemVkXG4gICAgaWYgKHNoYXBlU3RhcnQgPCBzdGFydCAmJlxuICAgICAgc2hhcGVFbmQgPiBzdGFydCAmJlxuICAgICAgcnVsZXMuYWxsb3dlZCgnc2hhcGUucmVzaXplJywgeyBzaGFwZTogZWxlbWVudCB9KVxuICAgICkge1xuXG4gICAgICByZXR1cm4gcmVzaXppbmdTaGFwZXMucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbW92aW5nU2hhcGVzOiBtb3ZpbmdTaGFwZXMsXG4gICAgcmVzaXppbmdTaGFwZXM6IHJlc2l6aW5nU2hhcGVzXG4gIH07XG59O1xuXG5TcGFjZVRvb2wucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJhZ2dpbmcuY2FuY2VsKCk7XG4gIH1cblxuICB2YXIgbW91c2VFdmVudCA9IHRoaXMuX21vdXNlLmdldExhc3RNb3ZlRXZlbnQoKTtcblxuICB0aGlzLmFjdGl2YXRlU2VsZWN0aW9uKG1vdXNlRXZlbnQsICEhbW91c2VFdmVudCk7XG59O1xuXG5TcGFjZVRvb2wucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5fZHJhZ2dpbmcuY29udGV4dCgpO1xuXG4gIHJldHVybiBjb250ZXh0ICYmIC9ec3BhY2VUb29sLy50ZXN0KGNvbnRleHQucHJlZml4KTtcbn07XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBhZGRQYWRkaW5nKHRyYmwpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHRyYmwudG9wIC0gUEFERElORyxcbiAgICByaWdodDogdHJibC5yaWdodCArIFBBRERJTkcsXG4gICAgYm90dG9tOiB0cmJsLmJvdHRvbSArIFBBRERJTkcsXG4gICAgbGVmdDogdHJibC5sZWZ0IC0gUEFERElOR1xuICB9O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVDb25zdHJhaW50cyhldmVudCkge1xuICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICBzcGFjZVRvb2xDb25zdHJhaW50cyA9IGNvbnRleHQuc3BhY2VUb29sQ29uc3RyYWludHM7XG5cbiAgaWYgKCFzcGFjZVRvb2xDb25zdHJhaW50cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB4LCB5O1xuXG4gIGlmIChpc051bWJlcihzcGFjZVRvb2xDb25zdHJhaW50cy5sZWZ0KSkge1xuICAgIHggPSBNYXRoLm1heChldmVudC54LCBzcGFjZVRvb2xDb25zdHJhaW50cy5sZWZ0KTtcblxuICAgIGV2ZW50LmR4ID0gZXZlbnQuZHggKyB4IC0gZXZlbnQueDtcbiAgICBldmVudC54ID0geDtcbiAgfVxuXG4gIGlmIChpc051bWJlcihzcGFjZVRvb2xDb25zdHJhaW50cy5yaWdodCkpIHtcbiAgICB4ID0gTWF0aC5taW4oZXZlbnQueCwgc3BhY2VUb29sQ29uc3RyYWludHMucmlnaHQpO1xuXG4gICAgZXZlbnQuZHggPSBldmVudC5keCArIHggLSBldmVudC54O1xuICAgIGV2ZW50LnggPSB4O1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKHNwYWNlVG9vbENvbnN0cmFpbnRzLnRvcCkpIHtcbiAgICB5ID0gTWF0aC5tYXgoZXZlbnQueSwgc3BhY2VUb29sQ29uc3RyYWludHMudG9wKTtcblxuICAgIGV2ZW50LmR5ID0gZXZlbnQuZHkgKyB5IC0gZXZlbnQueTtcbiAgICBldmVudC55ID0geTtcbiAgfVxuXG4gIGlmIChpc051bWJlcihzcGFjZVRvb2xDb25zdHJhaW50cy5ib3R0b20pKSB7XG4gICAgeSA9IE1hdGgubWluKGV2ZW50LnksIHNwYWNlVG9vbENvbnN0cmFpbnRzLmJvdHRvbSk7XG5cbiAgICBldmVudC5keSA9IGV2ZW50LmR5ICsgeSAtIGV2ZW50Lnk7XG4gICAgZXZlbnQueSA9IHk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3BhY2VUb29sQ29uc3RyYWludHMoZWxlbWVudHMsIGF4aXMsIGRpcmVjdGlvbiwgc3RhcnQsIG1pbkRpbWVuc2lvbnMpIHtcbiAgdmFyIG1vdmluZ1NoYXBlcyA9IGVsZW1lbnRzLm1vdmluZ1NoYXBlcyxcbiAgICAgIHJlc2l6aW5nU2hhcGVzID0gZWxlbWVudHMucmVzaXppbmdTaGFwZXM7XG5cbiAgaWYgKCFyZXNpemluZ1NoYXBlcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3BhY2VUb29sQ29uc3RyYWludHMgPSB7fSxcbiAgICAgIG1pbixcbiAgICAgIG1heDtcblxuICBmb3JFYWNoKHJlc2l6aW5nU2hhcGVzLCBmdW5jdGlvbihyZXNpemluZ1NoYXBlKSB7XG4gICAgdmFyIHJlc2l6aW5nU2hhcGVCQm94ID0gYXNUUkJMKHJlc2l6aW5nU2hhcGUpO1xuXG4gICAgLy8gZmluZCBjaGlsZHJlbiB0aGF0IGFyZSBub3QgbW92aW5nIG9yIHJlc2l6aW5nXG4gICAgdmFyIG5vbk1vdmluZ1Jlc2l6aW5nQ2hpbGRyZW4gPSBmaWx0ZXIocmVzaXppbmdTaGFwZS5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiAhaXNDb25uZWN0aW9uKGNoaWxkKSAmJlxuICAgICAgICAhaXNMYWJlbChjaGlsZCkgJiZcbiAgICAgICAgIWluY2x1ZGVzKG1vdmluZ1NoYXBlcywgY2hpbGQpICYmXG4gICAgICAgICFpbmNsdWRlcyhyZXNpemluZ1NoYXBlcywgY2hpbGQpO1xuICAgIH0pO1xuXG4gICAgLy8gZmluZCBjaGlsZHJlbiB0aGF0IGFyZSBtb3ZpbmdcbiAgICB2YXIgbW92aW5nQ2hpbGRyZW4gPSBmaWx0ZXIocmVzaXppbmdTaGFwZS5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiAhaXNDb25uZWN0aW9uKGNoaWxkKSAmJiAhaXNMYWJlbChjaGlsZCkgJiYgaW5jbHVkZXMobW92aW5nU2hhcGVzLCBjaGlsZCk7XG4gICAgfSk7XG5cbiAgICB2YXIgbWluT3JNYXgsXG4gICAgICAgIG5vbk1vdmluZ1Jlc2l6aW5nQ2hpbGRyZW5CQm94LFxuICAgICAgICBtb3ZpbmdDaGlsZHJlbkJCb3g7XG5cbiAgICBpZiAobm9uTW92aW5nUmVzaXppbmdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIG5vbk1vdmluZ1Jlc2l6aW5nQ2hpbGRyZW5CQm94ID0gYWRkUGFkZGluZyhhc1RSQkwoZ2V0QkJveChub25Nb3ZpbmdSZXNpemluZ0NoaWxkcmVuKSkpO1xuXG4gICAgICBtaW5Pck1heCA9IHN0YXJ0IC1cbiAgICAgICAgcmVzaXppbmdTaGFwZUJCb3hbIERJUkVDVElPTl9UT19UUkJMWyBkaXJlY3Rpb24gXSBdICtcbiAgICAgICAgbm9uTW92aW5nUmVzaXppbmdDaGlsZHJlbkJCb3hbIERJUkVDVElPTl9UT19UUkJMWyBkaXJlY3Rpb24gXSBdO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnbicpIHtcbiAgICAgICAgc3BhY2VUb29sQ29uc3RyYWludHMuYm90dG9tID0gbWF4ID0gaXNOdW1iZXIobWF4KSA/IE1hdGgubWluKG1heCwgbWluT3JNYXgpIDogbWluT3JNYXg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3cnKSB7XG4gICAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzLnJpZ2h0ID0gbWF4ID0gaXNOdW1iZXIobWF4KSA/IE1hdGgubWluKG1heCwgbWluT3JNYXgpIDogbWluT3JNYXg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3MnKSB7XG4gICAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzLnRvcCA9IG1pbiA9IGlzTnVtYmVyKG1pbikgPyBNYXRoLm1heChtaW4sIG1pbk9yTWF4KSA6IG1pbk9yTWF4O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdlJykge1xuICAgICAgICBzcGFjZVRvb2xDb25zdHJhaW50cy5sZWZ0ID0gbWluID0gaXNOdW1iZXIobWluKSA/IE1hdGgubWF4KG1pbiwgbWluT3JNYXgpIDogbWluT3JNYXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vdmluZ0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgbW92aW5nQ2hpbGRyZW5CQm94ID0gYWRkUGFkZGluZyhhc1RSQkwoZ2V0QkJveChtb3ZpbmdDaGlsZHJlbikpKTtcblxuICAgICAgbWluT3JNYXggPSBzdGFydCAtXG4gICAgICAgIG1vdmluZ0NoaWxkcmVuQkJveFsgRElSRUNUSU9OX1RPX1RSQkxbIERJUkVDVElPTl9UT19PUFBPU0lURVsgZGlyZWN0aW9uIF0gXSBdICtcbiAgICAgICAgcmVzaXppbmdTaGFwZUJCb3hbIERJUkVDVElPTl9UT19UUkJMWyBESVJFQ1RJT05fVE9fT1BQT1NJVEVbIGRpcmVjdGlvbiBdIF0gXTtcblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ24nKSB7XG4gICAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzLmJvdHRvbSA9IG1heCA9IGlzTnVtYmVyKG1heCkgPyBNYXRoLm1pbihtYXgsIG1pbk9yTWF4KSA6IG1pbk9yTWF4O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICd3Jykge1xuICAgICAgICBzcGFjZVRvb2xDb25zdHJhaW50cy5yaWdodCA9IG1heCA9IGlzTnVtYmVyKG1heCkgPyBNYXRoLm1pbihtYXgsIG1pbk9yTWF4KSA6IG1pbk9yTWF4O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdzJykge1xuICAgICAgICBzcGFjZVRvb2xDb25zdHJhaW50cy50b3AgPSBtaW4gPSBpc051bWJlcihtaW4pID8gTWF0aC5tYXgobWluLCBtaW5Pck1heCkgOiBtaW5Pck1heDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnZScpIHtcbiAgICAgICAgc3BhY2VUb29sQ29uc3RyYWludHMubGVmdCA9IG1pbiA9IGlzTnVtYmVyKG1pbikgPyBNYXRoLm1heChtaW4sIG1pbk9yTWF4KSA6IG1pbk9yTWF4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXNpemluZ1NoYXBlTWluRGltZW5zaW9ucyA9IG1pbkRpbWVuc2lvbnMgJiYgbWluRGltZW5zaW9uc1sgcmVzaXppbmdTaGFwZS5pZCBdO1xuXG4gICAgaWYgKHJlc2l6aW5nU2hhcGVNaW5EaW1lbnNpb25zKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnbicpIHtcbiAgICAgICAgbWluT3JNYXggPSBzdGFydCArXG4gICAgICAgICAgcmVzaXppbmdTaGFwZVsgQVhJU19UT19ESU1FTlNJT04gWyBheGlzIF0gXSAtXG4gICAgICAgICAgcmVzaXppbmdTaGFwZU1pbkRpbWVuc2lvbnNbIEFYSVNfVE9fRElNRU5TSU9OWyBheGlzIF0gXTtcblxuICAgICAgICBzcGFjZVRvb2xDb25zdHJhaW50cy5ib3R0b20gPSBtYXggPSBpc051bWJlcihtYXgpID8gTWF0aC5taW4obWF4LCBtaW5Pck1heCkgOiBtaW5Pck1heDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAndycpIHtcbiAgICAgICAgbWluT3JNYXggPSBzdGFydCArXG4gICAgICAgICAgcmVzaXppbmdTaGFwZVsgQVhJU19UT19ESU1FTlNJT04gWyBheGlzIF0gXSAtXG4gICAgICAgICAgcmVzaXppbmdTaGFwZU1pbkRpbWVuc2lvbnNbIEFYSVNfVE9fRElNRU5TSU9OWyBheGlzIF0gXTtcblxuICAgICAgICBzcGFjZVRvb2xDb25zdHJhaW50cy5yaWdodCA9IG1heCA9IGlzTnVtYmVyKG1heCkgPyBNYXRoLm1pbihtYXgsIG1pbk9yTWF4KSA6IG1pbk9yTWF4O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdzJykge1xuICAgICAgICBtaW5Pck1heCA9IHN0YXJ0IC1cbiAgICAgICAgICByZXNpemluZ1NoYXBlWyBBWElTX1RPX0RJTUVOU0lPTiBbIGF4aXMgXSBdICtcbiAgICAgICAgICByZXNpemluZ1NoYXBlTWluRGltZW5zaW9uc1sgQVhJU19UT19ESU1FTlNJT05bIGF4aXMgXSBdO1xuXG4gICAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzLnRvcCA9IG1pbiA9IGlzTnVtYmVyKG1pbikgPyBNYXRoLm1heChtaW4sIG1pbk9yTWF4KSA6IG1pbk9yTWF4O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdlJykge1xuICAgICAgICBtaW5Pck1heCA9IHN0YXJ0IC1cbiAgICAgICAgICByZXNpemluZ1NoYXBlWyBBWElTX1RPX0RJTUVOU0lPTiBbIGF4aXMgXSBdICtcbiAgICAgICAgICByZXNpemluZ1NoYXBlTWluRGltZW5zaW9uc1sgQVhJU19UT19ESU1FTlNJT05bIGF4aXMgXSBdO1xuXG4gICAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzLmxlZnQgPSBtaW4gPSBpc051bWJlcihtaW4pID8gTWF0aC5tYXgobWluLCBtaW5Pck1heCkgOiBtaW5Pck1heDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzcGFjZVRvb2xDb25zdHJhaW50cztcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIGl0ZW0pIHtcbiAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBpc0Nvbm5lY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gISFlbGVtZW50LndheXBvaW50cztcbn1cblxuZnVuY3Rpb24gaXNMYWJlbChlbGVtZW50KSB7XG4gIHJldHVybiAhIWVsZW1lbnQubGFiZWxUYXJnZXQ7XG59IiwiaW1wb3J0IHtcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbnZhciBNQVJLRVJfRFJBR0dJTkcgPSAnZGpzLWRyYWdnaW5nJyxcbiAgICBNQVJLRVJfUkVTSVpJTkcgPSAnZGpzLXJlc2l6aW5nJztcblxudmFyIExPV19QUklPUklUWSA9IDI1MDtcblxuaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjbGFzc2VzIGFzIHN2Z0NsYXNzZXMsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXG4gIHJlbW92ZSBhcyBzdmdSZW1vdmVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQge1xuICB0cmFuc2xhdGVcbn0gZnJvbSAnLi4vLi4vdXRpbC9TdmdUcmFuc2Zvcm1VdGlsJztcblxudmFyIG1heCA9IE1hdGgubWF4O1xuXG5cbi8qKlxuICogUHJvdmlkZXMgcHJldmlld3MgZm9yIHNlbGVjdGluZy9tb3ZpbmcvcmVzaXppbmcgc2hhcGVzIHdoZW4gY3JlYXRpbmcvcmVtb3Zpbmcgc3BhY2UuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqIEBwYXJhbSB7U3R5bGVzfSBzdHlsZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3BhY2VUb29sUHJldmlldyhcbiAgICBldmVudEJ1cywgZWxlbWVudFJlZ2lzdHJ5LCBjYW52YXMsXG4gICAgc3R5bGVzLCBwcmV2aWV3U3VwcG9ydCkge1xuXG4gIGZ1bmN0aW9uIGFkZFByZXZpZXdHZngoY29sbGVjdGlvbiwgZHJhZ0dyb3VwKSB7XG4gICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBwcmV2aWV3U3VwcG9ydC5hZGREcmFnZ2VyKGVsZW1lbnQsIGRyYWdHcm91cCk7XG5cbiAgICAgIGNhbnZhcy5hZGRNYXJrZXIoZWxlbWVudCwgTUFSS0VSX0RSQUdHSU5HKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGFkZCBjcm9zc2hhaXJcbiAgZXZlbnRCdXMub24oJ3NwYWNlVG9vbC5zZWxlY3Rpb24uc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBzcGFjZSA9IGNhbnZhcy5nZXRMYXllcignc3BhY2UnKSxcbiAgICAgICAgY29udGV4dCA9IGV2ZW50LmNvbnRleHQ7XG5cbiAgICB2YXIgb3JpZW50YXRpb24gPSB7XG4gICAgICB4OiAnTSAwLC0xMDAwMCBMIDAsMTAwMDAnLFxuICAgICAgeTogJ00gLTEwMDAwLDAgTCAxMDAwMCwwJ1xuICAgIH07XG5cbiAgICB2YXIgY3Jvc3NoYWlyR3JvdXAgPSBzdmdDcmVhdGUoJ2cnKTtcbiAgICBzdmdBdHRyKGNyb3NzaGFpckdyb3VwLCBzdHlsZXMuY2xzKCdkanMtY3Jvc3NoYWlyLWdyb3VwJywgWyAnbm8tZXZlbnRzJyBdKSk7XG5cbiAgICBzdmdBcHBlbmQoc3BhY2UsIGNyb3NzaGFpckdyb3VwKTtcblxuICAgIC8vIGhvcml6b250YWwgcGF0aFxuICAgIHZhciBwYXRoWCA9IHN2Z0NyZWF0ZSgncGF0aCcpO1xuICAgIHN2Z0F0dHIocGF0aFgsICdkJywgb3JpZW50YXRpb24ueCk7XG4gICAgc3ZnQ2xhc3NlcyhwYXRoWCkuYWRkKCdkanMtY3Jvc3NoYWlyJyk7XG5cbiAgICBzdmdBcHBlbmQoY3Jvc3NoYWlyR3JvdXAsIHBhdGhYKTtcblxuICAgIC8vIHZlcnRpY2FsIHBhdGhcbiAgICB2YXIgcGF0aFkgPSBzdmdDcmVhdGUoJ3BhdGgnKTtcbiAgICBzdmdBdHRyKHBhdGhZLCAnZCcsIG9yaWVudGF0aW9uLnkpO1xuICAgIHN2Z0NsYXNzZXMocGF0aFkpLmFkZCgnZGpzLWNyb3NzaGFpcicpO1xuXG4gICAgc3ZnQXBwZW5kKGNyb3NzaGFpckdyb3VwLCBwYXRoWSk7XG5cbiAgICBjb250ZXh0LmNyb3NzaGFpckdyb3VwID0gY3Jvc3NoYWlyR3JvdXA7XG4gIH0pO1xuXG4gIC8vIHVwZGF0ZSBjcm9zc2hhaXJcbiAgZXZlbnRCdXMub24oJ3NwYWNlVG9vbC5zZWxlY3Rpb24ubW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNyb3NzaGFpckdyb3VwID0gZXZlbnQuY29udGV4dC5jcm9zc2hhaXJHcm91cDtcblxuICAgIHRyYW5zbGF0ZShjcm9zc2hhaXJHcm91cCwgZXZlbnQueCwgZXZlbnQueSk7XG4gIH0pO1xuXG4gIC8vIHJlbW92ZSBjcm9zc2hhaXJcbiAgZXZlbnRCdXMub24oJ3NwYWNlVG9vbC5zZWxlY3Rpb24uY2xlYW51cCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBjcm9zc2hhaXJHcm91cCA9IGNvbnRleHQuY3Jvc3NoYWlyR3JvdXA7XG5cbiAgICBpZiAoY3Jvc3NoYWlyR3JvdXApIHtcbiAgICAgIHN2Z1JlbW92ZShjcm9zc2hhaXJHcm91cCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBhZGQgYW5kIHVwZGF0ZSBtb3ZlL3Jlc2l6ZSBwcmV2aWV3c1xuICBldmVudEJ1cy5vbignc3BhY2VUb29sLm1vdmUnLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGxpbmUgPSBjb250ZXh0LmxpbmUsXG4gICAgICAgIGF4aXMgPSBjb250ZXh0LmF4aXMsXG4gICAgICAgIG1vdmluZ1NoYXBlcyA9IGNvbnRleHQubW92aW5nU2hhcGVzLFxuICAgICAgICByZXNpemluZ1NoYXBlcyA9IGNvbnRleHQucmVzaXppbmdTaGFwZXM7XG5cbiAgICBpZiAoIWNvbnRleHQuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNvbnRleHQuZHJhZ0dyb3VwKSB7XG4gICAgICB2YXIgc3BhY2VMYXllciA9IGNhbnZhcy5nZXRMYXllcignc3BhY2UnKTtcblxuICAgICAgbGluZSA9IHN2Z0NyZWF0ZSgncGF0aCcpO1xuICAgICAgc3ZnQXR0cihsaW5lLCAnZCcsICdNMCwwIEwwLDAnKTtcbiAgICAgIHN2Z0NsYXNzZXMobGluZSkuYWRkKCdkanMtY3Jvc3NoYWlyJyk7XG5cbiAgICAgIHN2Z0FwcGVuZChzcGFjZUxheWVyLCBsaW5lKTtcblxuICAgICAgY29udGV4dC5saW5lID0gbGluZTtcblxuICAgICAgdmFyIGRyYWdHcm91cCA9IHN2Z0NyZWF0ZSgnZycpO1xuICAgICAgc3ZnQXR0cihkcmFnR3JvdXAsIHN0eWxlcy5jbHMoJ2Rqcy1kcmFnLWdyb3VwJywgWyAnbm8tZXZlbnRzJyBdKSk7XG5cbiAgICAgIHN2Z0FwcGVuZChjYW52YXMuZ2V0RGVmYXVsdExheWVyKCksIGRyYWdHcm91cCk7XG5cbiAgICAgIC8vIHNoYXBlc1xuICAgICAgYWRkUHJldmlld0dmeChtb3ZpbmdTaGFwZXMsIGRyYWdHcm91cCk7XG5cbiAgICAgIC8vIGNvbm5lY3Rpb25zXG4gICAgICB2YXIgbW92aW5nQ29ubmVjdGlvbnMgPSBjb250ZXh0Lm1vdmluZ0Nvbm5lY3Rpb25zID0gZWxlbWVudFJlZ2lzdHJ5LmZpbHRlcihmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHZhciBzb3VyY2VJc01vdmluZyA9IGZhbHNlO1xuXG4gICAgICAgIGZvckVhY2gobW92aW5nU2hhcGVzLCBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgIGZvckVhY2goc2hhcGUub3V0Z29pbmcsIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHNvdXJjZUlzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHRhcmdldElzTW92aW5nID0gZmFsc2U7XG5cbiAgICAgICAgZm9yRWFjaChtb3ZpbmdTaGFwZXMsIGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgZm9yRWFjaChzaGFwZS5pbmNvbWluZywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgdGFyZ2V0SXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc291cmNlSXNSZXNpemluZyA9IGZhbHNlO1xuXG4gICAgICAgIGZvckVhY2gocmVzaXppbmdTaGFwZXMsIGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgZm9yRWFjaChzaGFwZS5vdXRnb2luZywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgc291cmNlSXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB0YXJnZXRJc1Jlc2l6aW5nID0gZmFsc2U7XG5cbiAgICAgICAgZm9yRWFjaChyZXNpemluZ1NoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICBmb3JFYWNoKHNoYXBlLmluY29taW5nLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICB0YXJnZXRJc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGlvbihlbGVtZW50KVxuICAgICAgICAgICYmIChzb3VyY2VJc01vdmluZyB8fCBzb3VyY2VJc1Jlc2l6aW5nKVxuICAgICAgICAgICYmICh0YXJnZXRJc01vdmluZyB8fCB0YXJnZXRJc1Jlc2l6aW5nKTtcbiAgICAgIH0pO1xuXG5cbiAgICAgIGFkZFByZXZpZXdHZngobW92aW5nQ29ubmVjdGlvbnMsIGRyYWdHcm91cCk7XG5cbiAgICAgIGNvbnRleHQuZHJhZ0dyb3VwID0gZHJhZ0dyb3VwO1xuICAgIH1cblxuICAgIGlmICghY29udGV4dC5mcmFtZUdyb3VwKSB7XG4gICAgICB2YXIgZnJhbWVHcm91cCA9IHN2Z0NyZWF0ZSgnZycpO1xuICAgICAgc3ZnQXR0cihmcmFtZUdyb3VwLCBzdHlsZXMuY2xzKCdkanMtZnJhbWUtZ3JvdXAnLCBbICduby1ldmVudHMnIF0pKTtcblxuICAgICAgc3ZnQXBwZW5kKGNhbnZhcy5nZXREZWZhdWx0TGF5ZXIoKSwgZnJhbWVHcm91cCk7XG5cbiAgICAgIHZhciBmcmFtZXMgPSBbXTtcblxuICAgICAgZm9yRWFjaChyZXNpemluZ1NoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgdmFyIGZyYW1lID0gcHJldmlld1N1cHBvcnQuYWRkRnJhbWUoc2hhcGUsIGZyYW1lR3JvdXApO1xuXG4gICAgICAgIHZhciBpbml0aWFsQm91bmRzID0gZnJhbWUuZ2V0QkJveCgpO1xuXG4gICAgICAgIGZyYW1lcy5wdXNoKHtcbiAgICAgICAgICBlbGVtZW50OiBmcmFtZSxcbiAgICAgICAgICBpbml0aWFsQm91bmRzOiBpbml0aWFsQm91bmRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNhbnZhcy5hZGRNYXJrZXIoc2hhcGUsIE1BUktFUl9SRVNJWklORyk7XG4gICAgICB9KTtcblxuICAgICAgY29udGV4dC5mcmFtZUdyb3VwID0gZnJhbWVHcm91cDtcbiAgICAgIGNvbnRleHQuZnJhbWVzID0gZnJhbWVzO1xuICAgIH1cblxuICAgIHZhciBvcmllbnRhdGlvbiA9IHtcbiAgICAgIHg6ICdNJyArIGV2ZW50LnggKyAnLCAtMTAwMDAgTCcgKyBldmVudC54ICsgJywgMTAwMDAnLFxuICAgICAgeTogJ00gLTEwMDAwLCAnICsgZXZlbnQueSArICcgTCAxMDAwMCwgJyArIGV2ZW50LnlcbiAgICB9O1xuXG4gICAgc3ZnQXR0cihsaW5lLCB7IGQ6IG9yaWVudGF0aW9uWyBheGlzIF0gfSk7XG5cbiAgICB2YXIgb3Bwb3NpdGUgPSB7IHg6ICd5JywgeTogJ3gnIH07XG4gICAgdmFyIGRlbHRhID0geyB4OiBldmVudC5keCwgeTogZXZlbnQuZHkgfTtcbiAgICBkZWx0YVsgb3Bwb3NpdGVbIGNvbnRleHQuYXhpcyBdIF0gPSAwO1xuXG4gICAgLy8gdXBkYXRlIG1vdmUgcHJldmlld3NcbiAgICB0cmFuc2xhdGUoY29udGV4dC5kcmFnR3JvdXAsIGRlbHRhLngsIGRlbHRhLnkpO1xuXG4gICAgLy8gdXBkYXRlIHJlc2l6ZSBwcmV2aWV3c1xuICAgIGZvckVhY2goY29udGV4dC5mcmFtZXMsIGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGZyYW1lLmVsZW1lbnQsXG4gICAgICAgICAgaW5pdGlhbEJvdW5kcyA9IGZyYW1lLmluaXRpYWxCb3VuZHMsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0O1xuXG4gICAgICBpZiAoY29udGV4dC5kaXJlY3Rpb24gPT09ICdlJykge1xuICAgICAgICBzdmdBdHRyKGVsZW1lbnQsIHtcbiAgICAgICAgICB3aWR0aDogbWF4KGluaXRpYWxCb3VuZHMud2lkdGggKyBkZWx0YS54LCA1KVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gbWF4KGluaXRpYWxCb3VuZHMud2lkdGggLSBkZWx0YS54LCA1KTtcblxuICAgICAgICBzdmdBdHRyKGVsZW1lbnQsIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgeDogaW5pdGlhbEJvdW5kcy54ICsgaW5pdGlhbEJvdW5kcy53aWR0aCAtIHdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dC5kaXJlY3Rpb24gPT09ICdzJykge1xuICAgICAgICBzdmdBdHRyKGVsZW1lbnQsIHtcbiAgICAgICAgICBoZWlnaHQ6IG1heChpbml0aWFsQm91bmRzLmhlaWdodCArIGRlbHRhLnksIDUpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gbWF4KGluaXRpYWxCb3VuZHMuaGVpZ2h0IC0gZGVsdGEueSwgNSk7XG5cbiAgICAgICAgc3ZnQXR0cihlbGVtZW50LCB7XG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgeTogaW5pdGlhbEJvdW5kcy55ICsgaW5pdGlhbEJvdW5kcy5oZWlnaHQgLSBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIG1vdmUvcmVzaXplIHByZXZpZXdzXG4gIGV2ZW50QnVzLm9uKCdzcGFjZVRvb2wuY2xlYW51cCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIG1vdmluZ1NoYXBlcyA9IGNvbnRleHQubW92aW5nU2hhcGVzLFxuICAgICAgICBtb3ZpbmdDb25uZWN0aW9ucyA9IGNvbnRleHQubW92aW5nQ29ubmVjdGlvbnMsXG4gICAgICAgIHJlc2l6aW5nU2hhcGVzID0gY29udGV4dC5yZXNpemluZ1NoYXBlcyxcbiAgICAgICAgbGluZSA9IGNvbnRleHQubGluZSxcbiAgICAgICAgZHJhZ0dyb3VwID0gY29udGV4dC5kcmFnR3JvdXAsXG4gICAgICAgIGZyYW1lR3JvdXAgPSBjb250ZXh0LmZyYW1lR3JvdXA7XG5cbiAgICAvLyBtb3Zpbmcgc2hhcGVzXG4gICAgZm9yRWFjaChtb3ZpbmdTaGFwZXMsIGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKHNoYXBlLCBNQVJLRVJfRFJBR0dJTkcpO1xuICAgIH0pO1xuXG4gICAgLy8gbW92aW5nIGNvbm5lY3Rpb25zXG4gICAgZm9yRWFjaChtb3ZpbmdDb25uZWN0aW9ucywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgY2FudmFzLnJlbW92ZU1hcmtlcihjb25uZWN0aW9uLCBNQVJLRVJfRFJBR0dJTkcpO1xuICAgIH0pO1xuXG4gICAgaWYgKGRyYWdHcm91cCkge1xuICAgICAgc3ZnUmVtb3ZlKGxpbmUpO1xuICAgICAgc3ZnUmVtb3ZlKGRyYWdHcm91cCk7XG4gICAgfVxuXG4gICAgZm9yRWFjaChyZXNpemluZ1NoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoc2hhcGUsIE1BUktFUl9SRVNJWklORyk7XG4gICAgfSk7XG5cbiAgICBpZiAoZnJhbWVHcm91cCkge1xuICAgICAgc3ZnUmVtb3ZlKGZyYW1lR3JvdXApO1xuICAgIH1cbiAgfSk7XG59XG5cblNwYWNlVG9vbFByZXZpZXcuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2VsZW1lbnRSZWdpc3RyeScsXG4gICdjYW52YXMnLFxuICAnc3R5bGVzJyxcbiAgJ3ByZXZpZXdTdXBwb3J0J1xuXTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZWxlbWVudCBpcyBhIGNvbm5lY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGlzQ29ubmVjdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LndheXBvaW50cztcbn1cbiIsImltcG9ydCB7IGZvckVhY2ggfSBmcm9tICdtaW4tZGFzaCc7XG5cbi8qKlxuICogUmV0dXJuIGRpcmVjdGlvbiBnaXZlbiBheGlzIGFuZCBkZWx0YS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpc1xuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKGF4aXMsIGRlbHRhKSB7XG5cbiAgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgIHJldHVybiAnZSc7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgcmV0dXJuICd3JztcbiAgICB9XG4gIH1cblxuICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgcmV0dXJuICdzJztcbiAgICB9XG5cbiAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICByZXR1cm4gJ24nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgY29ubmVjdGlvbnMgd2hvc2Ugd2F5cG9pbnRzIGFyZSB0byBiZSB1cGRhdGVkLiBXYXlwb2ludHMgYXJlIHRvIGJlIHVwZGF0ZWQgaWYgc3RhcnRcbiAqIG9yIGVuZCBpcyB0byBiZSBtb3ZlZCBvciByZXNpemVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLlNoYXBlfSBtb3ZpbmdTaGFwZXNcbiAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLlNoYXBlfSByZXNpemluZ1NoYXBlc1xuICpcbiAqIEByZXR1cm5zIHtBcnJheTxkanMubW9kZWwuQ29ubmVjdGlvbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXYXlwb2ludHNVcGRhdGluZ0Nvbm5lY3Rpb25zKG1vdmluZ1NoYXBlcywgcmVzaXppbmdTaGFwZXMpIHtcbiAgdmFyIHdheXBvaW50c1VwZGF0aW5nQ29ubmVjdGlvbnMgPSBbXTtcblxuICBmb3JFYWNoKG1vdmluZ1NoYXBlcy5jb25jYXQocmVzaXppbmdTaGFwZXMpLCBmdW5jdGlvbihzaGFwZSkge1xuICAgIHZhciBpbmNvbWluZyA9IHNoYXBlLmluY29taW5nLFxuICAgICAgICBvdXRnb2luZyA9IHNoYXBlLm91dGdvaW5nO1xuXG4gICAgZm9yRWFjaChpbmNvbWluZy5jb25jYXQob3V0Z29pbmcpLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICB2YXIgc291cmNlID0gY29ubmVjdGlvbi5zb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0ID0gY29ubmVjdGlvbi50YXJnZXQ7XG5cbiAgICAgIGlmIChpbmNsdWRlcyhtb3ZpbmdTaGFwZXMsIHNvdXJjZSkgfHxcbiAgICAgICAgaW5jbHVkZXMobW92aW5nU2hhcGVzLCB0YXJnZXQpIHx8XG4gICAgICAgIGluY2x1ZGVzKHJlc2l6aW5nU2hhcGVzLCBzb3VyY2UpIHx8XG4gICAgICAgIGluY2x1ZGVzKHJlc2l6aW5nU2hhcGVzLCB0YXJnZXQpKSB7XG5cbiAgICAgICAgaWYgKCFpbmNsdWRlcyh3YXlwb2ludHNVcGRhdGluZ0Nvbm5lY3Rpb25zLCBjb25uZWN0aW9uKSkge1xuICAgICAgICAgIHdheXBvaW50c1VwZGF0aW5nQ29ubmVjdGlvbnMucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gd2F5cG9pbnRzVXBkYXRpbmdDb25uZWN0aW9ucztcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIGl0ZW0pIHtcbiAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufVxuXG4vKipcbiAqIFJlc2l6ZSBib3VuZHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGJvdW5kc1xuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy54XG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMud2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuaGVpZ2h0XG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gZGVsdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YS54XG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGEueVxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZUJvdW5kcyhib3VuZHMsIGRpcmVjdGlvbiwgZGVsdGEpIHtcbiAgdmFyIHggPSBib3VuZHMueCxcbiAgICAgIHkgPSBib3VuZHMueSxcbiAgICAgIHdpZHRoID0gYm91bmRzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodCxcbiAgICAgIGR4ID0gZGVsdGEueCxcbiAgICAgIGR5ID0gZGVsdGEueTtcblxuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICBjYXNlICduJzpcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHkgKyBkeSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0IC0gZHlcbiAgICB9O1xuICBjYXNlICdzJzpcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCArIGR5XG4gICAgfTtcbiAgY2FzZSAndyc6XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBkeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogd2lkdGggLSBkeCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgY2FzZSAnZSc6XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgd2lkdGg6IHdpZHRoICsgZHgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGRpcmVjdGlvbjogJyArIGRpcmVjdGlvbik7XG4gIH1cbn0iLCJpbXBvcnQgRHJhZ2dpbmdNb2R1bGUgZnJvbSAnLi4vZHJhZ2dpbmcnO1xuaW1wb3J0IFJ1bGVzTW9kdWxlIGZyb20gJy4uL3J1bGVzJztcbmltcG9ydCBUb29sTWFuYWdlck1vZHVsZSBmcm9tICcuLi90b29sLW1hbmFnZXInO1xuaW1wb3J0IFByZXZpZXdTdXBwb3J0TW9kdWxlIGZyb20gJy4uL3ByZXZpZXctc3VwcG9ydCc7XG5pbXBvcnQgTW91c2VNb2R1bGUgZnJvbSAnLi4vbW91c2UnO1xuXG5pbXBvcnQgU3BhY2VUb29sIGZyb20gJy4vU3BhY2VUb29sJztcbmltcG9ydCBTcGFjZVRvb2xQcmV2aWV3IGZyb20gJy4vU3BhY2VUb29sUHJldmlldyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsnc3BhY2VUb29sUHJldmlldyddLFxuICBfX2RlcGVuZHNfXzogW1xuICAgIERyYWdnaW5nTW9kdWxlLFxuICAgIFJ1bGVzTW9kdWxlLFxuICAgIFRvb2xNYW5hZ2VyTW9kdWxlLFxuICAgIFByZXZpZXdTdXBwb3J0TW9kdWxlLFxuICAgIE1vdXNlTW9kdWxlXG4gIF0sXG4gIHNwYWNlVG9vbDogWyd0eXBlJywgU3BhY2VUb29sIF0sXG4gIHNwYWNlVG9vbFByZXZpZXc6IFsndHlwZScsIFNwYWNlVG9vbFByZXZpZXcgXVxufTtcbiIsImltcG9ydCB7XG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBjbG9zZXN0IGFzIGRvbUNsb3Nlc3Rcbn0gZnJvbSAnbWluLWRvbSc7XG5cbnZhciBMT1dfUFJJT1JJVFkgPSAyNTA7XG5cbi8qKlxuICogVGhlIHRvb2wgbWFuYWdlciBhY3RzIGFzIG1pZGRsZS1tYW4gYmV0d2VlbiB0aGUgYXZhaWxhYmxlIHRvb2wncyBhbmQgdGhlIFBhbGV0dGUsXG4gKiBpdCB0YWtlcyBjYXJlIG9mIG1ha2luZyBzdXJlIHRoYXQgdGhlIGNvcnJlY3QgYWN0aXZlIHN0YXRlIGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgIGV2ZW50QnVzXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgIGRyYWdnaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRvb2xNYW5hZ2VyKGV2ZW50QnVzLCBkcmFnZ2luZykge1xuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICB0aGlzLl9kcmFnZ2luZyA9IGRyYWdnaW5nO1xuXG4gIHRoaXMuX3Rvb2xzID0gW107XG4gIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG59XG5cblRvb2xNYW5hZ2VyLiRpbmplY3QgPSBbICdldmVudEJ1cycsICdkcmFnZ2luZycgXTtcblxuVG9vbE1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyVG9vbCA9IGZ1bmN0aW9uKG5hbWUsIGV2ZW50cykge1xuICB2YXIgdG9vbHMgPSB0aGlzLl90b29scztcblxuICBpZiAoIWV2ZW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcignQSB0b29sIGhhcyB0byBiZSByZWdpc3RlcmVkIHdpdGggaXRcXCdzIFwiZXZlbnRzXCInKTtcbiAgfVxuXG4gIHRvb2xzLnB1c2gobmFtZSk7XG5cbiAgdGhpcy5iaW5kRXZlbnRzKG5hbWUsIGV2ZW50cyk7XG59O1xuXG5Ub29sTWFuYWdlci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbih0b29sKSB7XG4gIHJldHVybiB0b29sICYmIHRoaXMuX2FjdGl2ZSA9PT0gdG9vbDtcbn07XG5cblRvb2xNYW5hZ2VyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbih0b29sKSB7XG4gIHJldHVybiB0aGlzLl90b29scy5sZW5ndGg7XG59O1xuXG5Ub29sTWFuYWdlci5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24odG9vbCkge1xuICB2YXIgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICBpZiAodGhpcy5fYWN0aXZlICE9PSB0b29sKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gdG9vbDtcblxuICAgIGV2ZW50QnVzLmZpcmUoJ3Rvb2wtbWFuYWdlci51cGRhdGUnLCB7IHRvb2w6IHRvb2wgfSk7XG4gIH1cbn07XG5cblRvb2xNYW5hZ2VyLnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24obmFtZSwgZXZlbnRzKSB7XG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzLFxuICAgICAgZHJhZ2dpbmcgPSB0aGlzLl9kcmFnZ2luZztcblxuICB2YXIgZXZlbnRzVG9SZWdpc3RlciA9IFtdO1xuXG4gIGV2ZW50QnVzLm9uKGV2ZW50cy50b29sICsgJy5pbml0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQ7XG5cbiAgICAvLyBBY3RpdmUgdG9vbHMgdGhhdCB3YW50IHRvIHJlYWN0aXZhdGUgdGhlbXNlbHZlcyBtdXN0IGRvIHRoaXMgZXhwbGljaXRseVxuICAgIGlmICghY29udGV4dC5yZWFjdGl2YXRlICYmIHRoaXMuaXNBY3RpdmUobmFtZSkpIHtcbiAgICAgIHRoaXMuc2V0QWN0aXZlKG51bGwpO1xuXG4gICAgICBkcmFnZ2luZy5jYW5jZWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldEFjdGl2ZShuYW1lKTtcblxuICB9LCB0aGlzKTtcblxuICAvLyBUb2RvW3JpY2FyZG9dOiBhZGQgdGVzdCBjYXNlc1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBldmVudHNUb1JlZ2lzdGVyLnB1c2goZXZlbnQgKyAnLmVuZGVkJyk7XG4gICAgZXZlbnRzVG9SZWdpc3Rlci5wdXNoKGV2ZW50ICsgJy5jYW5jZWxlZCcpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbihldmVudHNUb1JlZ2lzdGVyLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAvLyBXZSBkZWZlciB0aGUgZGUtYWN0aXZhdGlvbiBvZiB0aGUgdG9vbCB0byB0aGUgLmFjdGl2YXRlIHBoYXNlLFxuICAgIC8vIHNvIHdlJ3JlIGFibGUgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byB0b2dnbGUgb2ZmIHRoZSBjdXJyZW50XG4gICAgLy8gYWN0aXZlIHRvb2wgb3Igc3dpdGNoIHRvIGEgbmV3IG9uZVxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzUGFsZXR0ZUNsaWNrKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QWN0aXZlKG51bGwpO1xuICB9LCB0aGlzKTtcblxufTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gZXZlbnQgaXMgYSBwYWxldHRlIGNsaWNrIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXMuRXZlbnR9IGV2ZW50XG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNQYWxldHRlQ2xpY2soZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC50YXJnZXQ7XG5cbiAgcmV0dXJuIHRhcmdldCAmJiBkb21DbG9zZXN0KHRhcmdldCwgJy5ncm91cFtkYXRhLWdyb3VwPVwidG9vbHNcIl0nKTtcbn0iLCJpbXBvcnQgRHJhZ2dpbmdNb2R1bGUgZnJvbSAnLi4vZHJhZ2dpbmcnO1xuXG5pbXBvcnQgVG9vbE1hbmFnZXIgZnJvbSAnLi9Ub29sTWFuYWdlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBEcmFnZ2luZ01vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAndG9vbE1hbmFnZXInIF0sXG4gIHRvb2xNYW5hZ2VyOiBbICd0eXBlJywgVG9vbE1hbmFnZXIgXVxufTtcbiIsImltcG9ydCB7XG4gIGlzU3RyaW5nLFxuICBhc3NpZ24sXG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBkb21pZnksXG4gIGF0dHIgYXMgZG9tQXR0cixcbiAgY2xhc3NlcyBhcyBkb21DbGFzc2VzLFxuICByZW1vdmUgYXMgZG9tUmVtb3ZlLFxuICBkZWxlZ2F0ZSBhcyBkb21EZWxlZ2F0ZVxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IElkcyBmcm9tICcuLi8uLi91dGlsL0lkR2VuZXJhdG9yJztcblxuLy8gZG9jdW1lbnQgd2lkZSB1bmlxdWUgdG9vbHRpcCBpZHNcbnZhciBpZHMgPSBuZXcgSWRzKCd0dCcpO1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QocGFyZW50Tm9kZSkge1xuICB2YXIgcm9vdCA9IGRvbWlmeShcbiAgICAnPGRpdiBjbGFzcz1cImRqcy10b29sdGlwLWNvbnRhaW5lclwiIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMDsgaGVpZ2h0OiAwO1wiIC8+J1xuICApO1xuXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHJvb3QsIHBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG5cbiAgcmV0dXJuIHJvb3Q7XG59XG5cblxuZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHgsIHkpIHtcbiAgYXNzaWduKGVsLnN0eWxlLCB7IGxlZnQ6IHggKyAncHgnLCB0b3A6IHkgKyAncHgnIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRWaXNpYmxlKGVsLCB2aXNpYmxlKSB7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID09PSBmYWxzZSA/ICdub25lJyA6ICcnO1xufVxuXG5cbnZhciB0b29sdGlwQ2xhc3MgPSAnZGpzLXRvb2x0aXAnLFxuICAgIHRvb2x0aXBTZWxlY3RvciA9ICcuJyArIHRvb2x0aXBDbGFzcztcblxuLyoqXG4gKiBBIHNlcnZpY2UgdGhhdCBhbGxvd3MgdXNlcnMgdG8gcmVuZGVyIHRvb2wgdGlwcyBvbiB0aGUgZGlhZ3JhbS5cbiAqXG4gKiBUaGUgdG9vbHRpcCBzZXJ2aWNlIHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0aW5nIHRoZSB0b29sdGlwIHBvc2l0aW9uaW5nXG4gKiBkdXJpbmcgbmF2aWdhdGlvbiArIHpvb21pbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKlxuICogLy8gYWRkIGEgcGluayBiYWRnZSBvbiB0aGUgdG9wIGxlZnQgb2YgdGhlIHNoYXBlXG4gKiB0b29sdGlwcy5hZGQoe1xuICogICBwb3NpdGlvbjoge1xuICogICAgIHg6IDUwLFxuICogICAgIHk6IDEwMFxuICogICB9LFxuICogICBodG1sOiAnPGRpdiBzdHlsZT1cIndpZHRoOiAxMHB4OyBiYWNrZ3JvdW5kOiBmdWNoc2lhOyBjb2xvcjogd2hpdGU7XCI+MDwvZGl2PidcbiAqIH0pO1xuICpcbiAqIC8vIG9yIHdpdGggb3B0aW9uYWwgbGlmZSBzcGFuXG4gKiB0b29sdGlwcy5hZGQoe1xuICogICBwb3NpdGlvbjoge1xuICogICAgIHRvcDogLTUsXG4gKiAgICAgbGVmdDogLTVcbiAqICAgfSxcbiAqICAgaHRtbDogJzxkaXYgc3R5bGU9XCJ3aWR0aDogMTBweDsgYmFja2dyb3VuZDogZnVjaHNpYTsgY29sb3I6IHdoaXRlO1wiPjA8L2Rpdj4nLFxuICogICB0dGw6IDIwMDBcbiAqIH0pO1xuICpcbiAqIC8vIHJlbW92ZSBhIHRvb2wgdGlwXG4gKiB2YXIgaWQgPSB0b29sdGlwcy5hZGQoLi4uKTtcbiAqIHRvb2x0aXBzLnJlbW92ZShpZCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUb29sdGlwcyhldmVudEJ1cywgY2FudmFzKSB7XG5cbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuXG4gIHRoaXMuX2lkcyA9IGlkcztcblxuICB0aGlzLl90b29sdGlwRGVmYXVsdHMgPSB7XG4gICAgc2hvdzoge1xuICAgICAgbWluWm9vbTogMC43LFxuICAgICAgbWF4Wm9vbTogNS4wXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIHRvb2x0aXBJZCAtPiB0b29sdGlwXG4gICAqL1xuICB0aGlzLl90b29sdGlwcyA9IHt9O1xuXG4gIC8vIHJvb3QgaHRtbCBlbGVtZW50IGZvciBhbGwgdG9vbHRpcHNcbiAgdGhpcy5fdG9vbHRpcFJvb3QgPSBjcmVhdGVSb290KGNhbnZhcy5nZXRDb250YWluZXIoKSk7XG5cblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZG9tRGVsZWdhdGUuYmluZCh0aGlzLl90b29sdGlwUm9vdCwgdG9vbHRpcFNlbGVjdG9yLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG5cbiAgZG9tRGVsZWdhdGUuYmluZCh0aGlzLl90b29sdGlwUm9vdCwgdG9vbHRpcFNlbGVjdG9yLCAnbW91c2VvdmVyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBzZWxmLnRyaWdnZXIoJ21vdXNlb3ZlcicsIGV2ZW50KTtcbiAgfSk7XG5cbiAgZG9tRGVsZWdhdGUuYmluZCh0aGlzLl90b29sdGlwUm9vdCwgdG9vbHRpcFNlbGVjdG9yLCAnbW91c2VvdXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHNlbGYudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gIH0pO1xuXG4gIHRoaXMuX2luaXQoKTtcbn1cblxuXG5Ub29sdGlwcy4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnLCAnY2FudmFzJyBdO1xuXG5cbi8qKlxuICogQWRkcyBhIEhUTUwgdG9vbHRpcCB0byB0aGUgZGlhZ3JhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIHRvb2x0aXAgICB0aGUgdG9vbHRpcCBjb25maWd1cmF0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8RE9NRWxlbWVudH0gICAgdG9vbHRpcC5odG1sICAgICAgICAgICAgICAgICBodG1sIGVsZW1lbnQgdG8gdXNlIGFzIGFuIHRvb2x0aXBcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIFt0b29sdGlwLnNob3ddICAgICAgICAgICAgICAgc2hvdyBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICBbdG9vbHRpcC5zaG93Lm1pblpvb21dICAgICAgIG1pbmltYWwgem9vbSBsZXZlbCB0byBzaG93IHRoZSB0b29sdGlwXG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICBbdG9vbHRpcC5zaG93Lm1heFpvb21dICAgICAgIG1heGltdW0gem9vbSBsZXZlbCB0byBzaG93IHRoZSB0b29sdGlwXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICB0b29sdGlwLnBvc2l0aW9uICAgICAgICAgICAgIHdoZXJlIHRvIGF0dGFjaCB0aGUgdG9vbHRpcFxuICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgW3Rvb2x0aXAucG9zaXRpb24ubGVmdF0gICAgICByZWxhdGl2ZSB0byBlbGVtZW50IGJib3ggbGVmdCBhdHRhY2htZW50XG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICBbdG9vbHRpcC5wb3NpdGlvbi50b3BdICAgICAgIHJlbGF0aXZlIHRvIGVsZW1lbnQgYmJveCB0b3AgYXR0YWNobWVudFxuICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgW3Rvb2x0aXAucG9zaXRpb24uYm90dG9tXSAgICByZWxhdGl2ZSB0byBlbGVtZW50IGJib3ggYm90dG9tIGF0dGFjaG1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgIFt0b29sdGlwLnBvc2l0aW9uLnJpZ2h0XSAgICAgcmVsYXRpdmUgdG8gZWxlbWVudCBiYm94IHJpZ2h0IGF0dGFjaG1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgIFt0b29sdGlwLnRpbWVvdXQ9LTFdXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgICAgaWQgdGhhdCBtYXkgYmUgdXNlZCB0byByZWZlcmVuY2UgdGhlIHRvb2x0aXAgZm9yIHVwZGF0ZSBvciByZW1vdmFsXG4gKi9cblRvb2x0aXBzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih0b29sdGlwKSB7XG5cbiAgaWYgKCF0b29sdGlwLnBvc2l0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZml5IHRvb2x0aXAgcG9zaXRpb24nKTtcbiAgfVxuXG4gIGlmICghdG9vbHRpcC5odG1sKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZml5IHRvb2x0aXAgaHRtbCcpO1xuICB9XG5cbiAgdmFyIGlkID0gdGhpcy5faWRzLm5leHQoKTtcblxuICB0b29sdGlwID0gYXNzaWduKHt9LCB0aGlzLl90b29sdGlwRGVmYXVsdHMsIHRvb2x0aXAsIHtcbiAgICBpZDogaWRcbiAgfSk7XG5cbiAgdGhpcy5fYWRkVG9vbHRpcCh0b29sdGlwKTtcblxuICBpZiAodG9vbHRpcC50aW1lb3V0KSB7XG4gICAgdGhpcy5zZXRUaW1lb3V0KHRvb2x0aXApO1xuICB9XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuVG9vbHRpcHMucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihhY3Rpb24sIGV2ZW50KSB7XG5cbiAgdmFyIG5vZGUgPSBldmVudC5kZWxlZ2F0ZVRhcmdldCB8fCBldmVudC50YXJnZXQ7XG5cbiAgdmFyIHRvb2x0aXAgPSB0aGlzLmdldChkb21BdHRyKG5vZGUsICdkYXRhLXRvb2x0aXAtaWQnKSk7XG5cbiAgaWYgKCF0b29sdGlwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGFjdGlvbiA9PT0gJ21vdXNlb3ZlcicgJiYgdG9vbHRpcC50aW1lb3V0KSB7XG4gICAgdGhpcy5jbGVhclRpbWVvdXQodG9vbHRpcCk7XG4gIH1cblxuICBpZiAoYWN0aW9uID09PSAnbW91c2VvdXQnICYmIHRvb2x0aXAudGltZW91dCkge1xuXG4gICAgLy8gY3V0IHRpbWVvdXQgYWZ0ZXIgbW91c2Ugb3V0XG4gICAgdG9vbHRpcC50aW1lb3V0ID0gMTAwMDtcblxuICAgIHRoaXMuc2V0VGltZW91dCh0b29sdGlwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSB0b29sdGlwIHdpdGggdGhlIGdpdmVuIGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKi9cblRvb2x0aXBzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpZCkge1xuXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgaWQgPSBpZC5pZDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl90b29sdGlwc1tpZF07XG59O1xuXG5Ub29sdGlwcy5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24odG9vbHRpcCkge1xuXG4gIHRvb2x0aXAgPSB0aGlzLmdldCh0b29sdGlwKTtcblxuICBpZiAoIXRvb2x0aXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVtb3ZlVGltZXIgPSB0b29sdGlwLnJlbW92ZVRpbWVyO1xuXG4gIGlmIChyZW1vdmVUaW1lcikge1xuICAgIGNsZWFyVGltZW91dChyZW1vdmVUaW1lcik7XG4gICAgdG9vbHRpcC5yZW1vdmVUaW1lciA9IG51bGw7XG4gIH1cbn07XG5cblRvb2x0aXBzLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24odG9vbHRpcCkge1xuXG4gIHRvb2x0aXAgPSB0aGlzLmdldCh0b29sdGlwKTtcblxuICBpZiAoIXRvb2x0aXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmNsZWFyVGltZW91dCh0b29sdGlwKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdG9vbHRpcC5yZW1vdmVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5yZW1vdmUodG9vbHRpcCk7XG4gIH0sIHRvb2x0aXAudGltZW91dCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiB0b29sdGlwIHdpdGggdGhlIGdpdmVuIGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKi9cblRvb2x0aXBzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpZCkge1xuXG4gIHZhciB0b29sdGlwID0gdGhpcy5nZXQoaWQpO1xuXG4gIGlmICh0b29sdGlwKSB7XG4gICAgZG9tUmVtb3ZlKHRvb2x0aXAuaHRtbCk7XG4gICAgZG9tUmVtb3ZlKHRvb2x0aXAuaHRtbENvbnRhaW5lcik7XG5cbiAgICBkZWxldGUgdG9vbHRpcC5odG1sQ29udGFpbmVyO1xuXG4gICAgZGVsZXRlIHRoaXMuX3Rvb2x0aXBzW3Rvb2x0aXAuaWRdO1xuICB9XG59O1xuXG5cblRvb2x0aXBzLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIHNldFZpc2libGUodGhpcy5fdG9vbHRpcFJvb3QpO1xufTtcblxuXG5Ub29sdGlwcy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBzZXRWaXNpYmxlKHRoaXMuX3Rvb2x0aXBSb290LCBmYWxzZSk7XG59O1xuXG5cblRvb2x0aXBzLnByb3RvdHlwZS5fdXBkYXRlUm9vdCA9IGZ1bmN0aW9uKHZpZXdib3gpIHtcbiAgdmFyIGEgPSB2aWV3Ym94LnNjYWxlIHx8IDE7XG4gIHZhciBkID0gdmlld2JveC5zY2FsZSB8fCAxO1xuXG4gIHZhciBtYXRyaXggPSAnbWF0cml4KCcgKyBhICsgJywwLDAsJyArIGQgKyAnLCcgKyAoLTEgKiB2aWV3Ym94LnggKiBhKSArICcsJyArICgtMSAqIHZpZXdib3gueSAqIGQpICsgJyknO1xuXG4gIHRoaXMuX3Rvb2x0aXBSb290LnN0eWxlLnRyYW5zZm9ybSA9IG1hdHJpeDtcbiAgdGhpcy5fdG9vbHRpcFJvb3Quc3R5bGVbJy1tcy10cmFuc2Zvcm0nXSA9IG1hdHJpeDtcbn07XG5cblxuVG9vbHRpcHMucHJvdG90eXBlLl9hZGRUb29sdGlwID0gZnVuY3Rpb24odG9vbHRpcCkge1xuXG4gIHZhciBpZCA9IHRvb2x0aXAuaWQsXG4gICAgICBodG1sID0gdG9vbHRpcC5odG1sLFxuICAgICAgaHRtbENvbnRhaW5lcixcbiAgICAgIHRvb2x0aXBSb290ID0gdGhpcy5fdG9vbHRpcFJvb3Q7XG5cbiAgLy8gdW53cmFwIGpxdWVyeSAoZm9yIHRob3NlIHdobyBuZWVkIGl0KVxuICBpZiAoaHRtbC5nZXQgJiYgaHRtbC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuanF1ZXJ5KSB7XG4gICAgaHRtbCA9IGh0bWwuZ2V0KDApO1xuICB9XG5cbiAgLy8gY3JlYXRlIHByb3BlciBodG1sIGVsZW1lbnRzIGZyb21cbiAgLy8gdG9vbHRpcCBIVE1MIHN0cmluZ3NcbiAgaWYgKGlzU3RyaW5nKGh0bWwpKSB7XG4gICAgaHRtbCA9IGRvbWlmeShodG1sKTtcbiAgfVxuXG4gIGh0bWxDb250YWluZXIgPSBkb21pZnkoJzxkaXYgZGF0YS10b29sdGlwLWlkPVwiJyArIGlkICsgJ1wiIGNsYXNzPVwiJyArIHRvb2x0aXBDbGFzcyArICdcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZVwiPicpO1xuXG4gIGh0bWxDb250YWluZXIuYXBwZW5kQ2hpbGQoaHRtbCk7XG5cbiAgaWYgKHRvb2x0aXAudHlwZSkge1xuICAgIGRvbUNsYXNzZXMoaHRtbENvbnRhaW5lcikuYWRkKCdkanMtdG9vbHRpcC0nICsgdG9vbHRpcC50eXBlKTtcbiAgfVxuXG4gIGlmICh0b29sdGlwLmNsYXNzTmFtZSkge1xuICAgIGRvbUNsYXNzZXMoaHRtbENvbnRhaW5lcikuYWRkKHRvb2x0aXAuY2xhc3NOYW1lKTtcbiAgfVxuXG4gIHRvb2x0aXAuaHRtbENvbnRhaW5lciA9IGh0bWxDb250YWluZXI7XG5cbiAgdG9vbHRpcFJvb3QuYXBwZW5kQ2hpbGQoaHRtbENvbnRhaW5lcik7XG5cbiAgdGhpcy5fdG9vbHRpcHNbaWRdID0gdG9vbHRpcDtcblxuICB0aGlzLl91cGRhdGVUb29sdGlwKHRvb2x0aXApO1xufTtcblxuXG5Ub29sdGlwcy5wcm90b3R5cGUuX3VwZGF0ZVRvb2x0aXAgPSBmdW5jdGlvbih0b29sdGlwKSB7XG5cbiAgdmFyIHBvc2l0aW9uID0gdG9vbHRpcC5wb3NpdGlvbixcbiAgICAgIGh0bWxDb250YWluZXIgPSB0b29sdGlwLmh0bWxDb250YWluZXI7XG5cbiAgLy8gdXBkYXRlIG92ZXJsYXkgaHRtbCBiYXNlZCBvbiB0b29sdGlwIHgsIHlcblxuICBzZXRQb3NpdGlvbihodG1sQ29udGFpbmVyLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbn07XG5cblxuVG9vbHRpcHMucHJvdG90eXBlLl91cGRhdGVUb29sdGlwVmlzaWJpbHR5ID0gZnVuY3Rpb24odmlld2JveCkge1xuXG4gIGZvckVhY2godGhpcy5fdG9vbHRpcHMsIGZ1bmN0aW9uKHRvb2x0aXApIHtcbiAgICB2YXIgc2hvdyA9IHRvb2x0aXAuc2hvdyxcbiAgICAgICAgaHRtbENvbnRhaW5lciA9IHRvb2x0aXAuaHRtbENvbnRhaW5lcixcbiAgICAgICAgdmlzaWJsZSA9IHRydWU7XG5cbiAgICBpZiAoc2hvdykge1xuICAgICAgaWYgKHNob3cubWluWm9vbSA+IHZpZXdib3guc2NhbGUgfHxcbiAgICAgICAgICBzaG93Lm1heFpvb20gPCB2aWV3Ym94LnNjYWxlKSB7XG4gICAgICAgIHZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc2V0VmlzaWJsZShodG1sQ29udGFpbmVyLCB2aXNpYmxlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuVG9vbHRpcHMucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIHNjcm9sbC96b29tIGludGVncmF0aW9uXG5cbiAgZnVuY3Rpb24gdXBkYXRlVmlld2JveCh2aWV3Ym94KSB7XG4gICAgc2VsZi5fdXBkYXRlUm9vdCh2aWV3Ym94KTtcbiAgICBzZWxmLl91cGRhdGVUb29sdGlwVmlzaWJpbHR5KHZpZXdib3gpO1xuXG4gICAgc2VsZi5zaG93KCk7XG4gIH1cblxuICB0aGlzLl9ldmVudEJ1cy5vbignY2FudmFzLnZpZXdib3guY2hhbmdpbmcnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHNlbGYuaGlkZSgpO1xuICB9KTtcblxuICB0aGlzLl9ldmVudEJ1cy5vbignY2FudmFzLnZpZXdib3guY2hhbmdlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdXBkYXRlVmlld2JveChldmVudC52aWV3Ym94KTtcbiAgfSk7XG59O1xuIiwiaW1wb3J0IFRvb2x0aXBzIGZyb20gJy4vVG9vbHRpcHMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICd0b29sdGlwcycgXSxcbiAgdG9vbHRpcHM6IFsgJ3R5cGUnLCBUb29sdGlwcyBdXG59OyIsImltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVG91Y2hGaXgoY2FudmFzLCBldmVudEJ1cykge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBldmVudEJ1cy5vbignY2FudmFzLmluaXQnLCBmdW5jdGlvbihlKSB7XG4gICAgc2VsZi5hZGRCQm94TWFya2VyKGUuc3ZnKTtcbiAgfSk7XG59XG5cblRvdWNoRml4LiRpbmplY3QgPSBbICdjYW52YXMnLCAnZXZlbnRCdXMnIF07XG5cblxuLyoqXG4gKiBTYWZhcmkgbW9iaWxlIChpT1MgNykgZG9lcyBub3QgZmlyZSB0b3VjaHN0YXJ0IGV2ZW50IGluIDxTVkc+IGVsZW1lbnRcbiAqIGlmIHRoZXJlIGlzIG5vIHNoYXBlIGJldHdlZW4gMCwwIGFuZCB2aWV3cG9ydCBlbGVtZW50cyBvcmlnaW4uXG4gKlxuICogU28gdG91Y2hzdGFydCBldmVudCBpcyBvbmx5IGZpcmVkIHdoZW4gdGhlIDxnIGNsYXNzPVwidmlld3BvcnRcIj4gZWxlbWVudCB3YXMgaGl0LlxuICogUHV0dGluZyBhbiBlbGVtZW50IG92ZXIgYW5kIGJlbG93IHRoZSAndmlld3BvcnQnIGZpeGVzIHRoYXQgYmVoYXZpb3IuXG4gKi9cblRvdWNoRml4LnByb3RvdHlwZS5hZGRCQm94TWFya2VyID0gZnVuY3Rpb24oc3ZnKSB7XG5cbiAgdmFyIG1hcmtlclN0eWxlID0ge1xuICAgIGZpbGw6ICdub25lJyxcbiAgICBjbGFzczogJ291dGVyLWJvdW5kLW1hcmtlcidcbiAgfTtcblxuICB2YXIgcmVjdDEgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcbiAgc3ZnQXR0cihyZWN0MSwge1xuICAgIHg6IC0xMDAwMCxcbiAgICB5OiAxMDAwMCxcbiAgICB3aWR0aDogMTAsXG4gICAgaGVpZ2h0OiAxMFxuICB9KTtcbiAgc3ZnQXR0cihyZWN0MSwgbWFya2VyU3R5bGUpO1xuXG4gIHN2Z0FwcGVuZChzdmcsIHJlY3QxKTtcblxuICB2YXIgcmVjdDIgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcbiAgc3ZnQXR0cihyZWN0Miwge1xuICAgIHg6IDEwMDAwLFxuICAgIHk6IDEwMDAwLFxuICAgIHdpZHRoOiAxMCxcbiAgICBoZWlnaHQ6IDEwXG4gIH0pO1xuICBzdmdBdHRyKHJlY3QyLCBtYXJrZXJTdHlsZSk7XG5cbiAgc3ZnQXBwZW5kKHN2ZywgcmVjdDIpO1xufTtcbiIsImltcG9ydCB7XG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBldmVudCBhcyBkb21FdmVudCxcbiAgY2xvc2VzdCBhcyBkb21DbG9zZXN0XG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQgSGFtbWVyIGZyb20gJ2hhbW1lcmpzJztcblxuaW1wb3J0IHtcbiAgdG9Qb2ludFxufSBmcm9tICcuLi8uLi91dGlsL0V2ZW50JztcblxudmFyIE1JTl9aT09NID0gMC4yLFxuICAgIE1BWF9aT09NID0gNDtcblxudmFyIG1vdXNlRXZlbnRzID0gW1xuICAnbW91c2Vkb3duJyxcbiAgJ21vdXNldXAnLFxuICAnbW91c2VvdmVyJyxcbiAgJ21vdXNlb3V0JyxcbiAgJ2NsaWNrJyxcbiAgJ2RibGNsaWNrJ1xuXTtcblxuZnVuY3Rpb24gbG9nKCkge1xuXG4gIC8vIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldChzZXJ2aWNlLCBpbmplY3Rvcikge1xuICByZXR1cm4gaW5qZWN0b3IuZ2V0KHNlcnZpY2UsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gc3RvcEV2ZW50KGV2ZW50KSB7XG5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICBpZiAodHlwZW9mIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9IGVsc2UgaWYgKGV2ZW50LnNyY0V2ZW50ICYmIHR5cGVvZiBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24gPT09ICdmdW5jdGlvbicpIHtcblxuICAgIC8vIGlQaG9uZSAmIGlQYWRcbiAgICBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVUb3VjaFJlY29nbml6ZXIobm9kZSkge1xuXG4gIGZ1bmN0aW9uIHN0b3BNb3VzZShldmVudCkge1xuXG4gICAgZm9yRWFjaChtb3VzZUV2ZW50cywgZnVuY3Rpb24oZSkge1xuICAgICAgZG9tRXZlbnQuYmluZChub2RlLCBlLCBzdG9wRXZlbnQsIHRydWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxsb3dNb3VzZShldmVudCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBmb3JFYWNoKG1vdXNlRXZlbnRzLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRvbUV2ZW50LnVuYmluZChub2RlLCBlLCBzdG9wRXZlbnQsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfSwgNTAwKTtcbiAgfVxuXG4gIGRvbUV2ZW50LmJpbmQobm9kZSwgJ3RvdWNoc3RhcnQnLCBzdG9wTW91c2UsIHRydWUpO1xuICBkb21FdmVudC5iaW5kKG5vZGUsICd0b3VjaGVuZCcsIGFsbG93TW91c2UsIHRydWUpO1xuICBkb21FdmVudC5iaW5kKG5vZGUsICd0b3VjaGNhbmNlbCcsIGFsbG93TW91c2UsIHRydWUpO1xuXG4gIC8vIEEgdG91Y2ggZXZlbnQgcmVjb2duaXplciB0aGF0IGhhbmRsZXNcbiAgLy8gdG91Y2ggZXZlbnRzIG9ubHkgKHdlIGtub3csIHdlIGNhbiBhbHJlYWR5IGhhbmRsZVxuICAvLyBtb3VzZSBldmVudHMgb3V0IG9mIHRoZSBib3gpXG5cbiAgdmFyIHJlY29nbml6ZXIgPSBuZXcgSGFtbWVyLk1hbmFnZXIobm9kZSwge1xuICAgIGlucHV0Q2xhc3M6IEhhbW1lci5Ub3VjaElucHV0LFxuICAgIHJlY29nbml6ZXJzOiBbXSxcbiAgICBkb21FdmVudHM6IHRydWVcbiAgfSk7XG5cblxuICB2YXIgdGFwID0gbmV3IEhhbW1lci5UYXAoKTtcbiAgdmFyIHBhbiA9IG5ldyBIYW1tZXIuUGFuKHsgdGhyZXNob2xkOiAxMCB9KTtcbiAgdmFyIHByZXNzID0gbmV3IEhhbW1lci5QcmVzcygpO1xuICB2YXIgcGluY2ggPSBuZXcgSGFtbWVyLlBpbmNoKCk7XG5cbiAgdmFyIGRvdWJsZVRhcCA9IG5ldyBIYW1tZXIuVGFwKHsgZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyIH0pO1xuXG4gIHBpbmNoLnJlcXVpcmVGYWlsdXJlKHBhbik7XG4gIHBpbmNoLnJlcXVpcmVGYWlsdXJlKHByZXNzKTtcblxuICByZWNvZ25pemVyLmFkZChbIHBhbiwgcHJlc3MsIHBpbmNoLCBkb3VibGVUYXAsIHRhcCBdKTtcblxuICByZWNvZ25pemVyLnJlc2V0ID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzLFxuICAgICAgICBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuXG4gICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZygncmVjb2duaXplcicsICdzdG9wJyk7XG5cbiAgICByZWNvZ25pemVyLnN0b3AoZm9yY2UpO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCByO1xuXG4gICAgICBsb2coJ3JlY29nbml6ZXInLCAncmVzZXQnKTtcbiAgICAgIGZvciAoaSA9IDA7IChyID0gcmVjb2duaXplcnNbaV0pOyBpKyspIHtcbiAgICAgICAgci5yZXNldCgpO1xuICAgICAgICByLnN0YXRlID0gODsgLy8gRkFJTEVEIFNUQVRFXG4gICAgICB9XG5cbiAgICAgIHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgfSwgMCk7XG4gIH07XG5cbiAgcmVjb2duaXplci5vbignaGFtbWVyLmlucHV0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuc3JjRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmVjb2duaXplci5yZXNldCh0cnVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZWNvZ25pemVyO1xufVxuXG4vKipcbiAqIEEgcGx1Z2luIHRoYXQgcHJvdmlkZXMgdG91Y2ggZXZlbnRzIGZvciBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtJbnRlcmFjdGlvbkV2ZW50c30gaW50ZXJhY3Rpb25FdmVudHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVG91Y2hJbnRlcmFjdGlvbkV2ZW50cyhcbiAgICBpbmplY3RvciwgY2FudmFzLCBldmVudEJ1cyxcbiAgICBlbGVtZW50UmVnaXN0cnksIGludGVyYWN0aW9uRXZlbnRzKSB7XG5cbiAgLy8gb3B0aW9uYWwgaW50ZWdyYXRpb25zXG4gIHZhciBkcmFnZ2luZyA9IGdldCgnZHJhZ2dpbmcnLCBpbmplY3RvciksXG4gICAgICBtb3ZlID0gZ2V0KCdtb3ZlJywgaW5qZWN0b3IpLFxuICAgICAgY29udGV4dFBhZCA9IGdldCgnY29udGV4dFBhZCcsIGluamVjdG9yKSxcbiAgICAgIHBhbGV0dGUgPSBnZXQoJ3BhbGV0dGUnLCBpbmplY3Rvcik7XG5cbiAgLy8gdGhlIHRvdWNoIHJlY29nbml6ZXJcbiAgdmFyIHJlY29nbml6ZXI7XG5cbiAgZnVuY3Rpb24gaGFuZGxlcih0eXBlKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGxvZygnZWxlbWVudCcsIHR5cGUsIGV2ZW50KTtcblxuICAgICAgaW50ZXJhY3Rpb25FdmVudHMuZmlyZSh0eXBlLCBldmVudCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEdmeCh0YXJnZXQpIHtcbiAgICB2YXIgbm9kZSA9IGRvbUNsb3Nlc3QodGFyZ2V0LCAnc3ZnLCAuZGpzLWVsZW1lbnQnLCB0cnVlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRFdmVudHMoc3ZnKSB7XG5cbiAgICAvLyB0b3VjaCByZWNvZ25pemVyXG4gICAgcmVjb2duaXplciA9IGNyZWF0ZVRvdWNoUmVjb2duaXplcihzdmcpO1xuXG4gICAgcmVjb2duaXplci5vbignZG91YmxldGFwJywgaGFuZGxlcignZWxlbWVudC5kYmxjbGljaycpKTtcblxuICAgIHJlY29nbml6ZXIub24oJ3RhcCcsIGhhbmRsZXIoJ2VsZW1lbnQuY2xpY2snKSk7XG5cbiAgICBmdW5jdGlvbiBzdGFydEdyYWJDYW52YXMoZXZlbnQpIHtcblxuICAgICAgbG9nKCdjYW52YXMnLCAnZ3JhYiBzdGFydCcpO1xuXG4gICAgICB2YXIgbHggPSAwLCBseSA9IDA7XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZShlKSB7XG5cbiAgICAgICAgdmFyIGR4ID0gZS5kZWx0YVggLSBseCxcbiAgICAgICAgICAgIGR5ID0gZS5kZWx0YVkgLSBseTtcblxuICAgICAgICBjYW52YXMuc2Nyb2xsKHsgZHg6IGR4LCBkeTogZHkgfSk7XG5cbiAgICAgICAgbHggPSBlLmRlbHRhWDtcbiAgICAgICAgbHkgPSBlLmRlbHRhWTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW5kKGUpIHtcbiAgICAgICAgcmVjb2duaXplci5vZmYoJ3Bhbm1vdmUnLCB1cGRhdGUpO1xuICAgICAgICByZWNvZ25pemVyLm9mZigncGFuZW5kJywgZW5kKTtcbiAgICAgICAgcmVjb2duaXplci5vZmYoJ3BhbmNhbmNlbCcsIGVuZCk7XG5cbiAgICAgICAgbG9nKCdjYW52YXMnLCAnZ3JhYiBlbmQnKTtcbiAgICAgIH1cblxuICAgICAgcmVjb2duaXplci5vbigncGFubW92ZScsIHVwZGF0ZSk7XG4gICAgICByZWNvZ25pemVyLm9uKCdwYW5lbmQnLCBlbmQpO1xuICAgICAgcmVjb2duaXplci5vbigncGFuY2FuY2VsJywgZW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydEdyYWIoZXZlbnQpIHtcblxuICAgICAgdmFyIGdmeCA9IGdldEdmeChldmVudC50YXJnZXQpLFxuICAgICAgICAgIGVsZW1lbnQgPSBnZnggJiYgZWxlbWVudFJlZ2lzdHJ5LmdldChnZngpO1xuXG4gICAgICAvLyByZWNvZ25pemVyXG4gICAgICBpZiAobW92ZSAmJiBjYW52YXMuZ2V0Um9vdEVsZW1lbnQoKSAhPT0gZWxlbWVudCkge1xuICAgICAgICBsb2coJ2VsZW1lbnQnLCAnbW92ZSBzdGFydCcsIGVsZW1lbnQsIGV2ZW50LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG1vdmUuc3RhcnQoZXZlbnQsIGVsZW1lbnQsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRHcmFiQ2FudmFzKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydFpvb20oZSkge1xuXG4gICAgICBsb2coJ2NhbnZhcycsICd6b29tIHN0YXJ0Jyk7XG5cbiAgICAgIHZhciB6b29tID0gY2FudmFzLnpvb20oKSxcbiAgICAgICAgICBtaWQgPSBlLmNlbnRlcjtcblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKGUpIHtcblxuICAgICAgICB2YXIgcmF0aW8gPSAxIC0gKDEgLSBlLnNjYWxlKSAvIDEuNTAsXG4gICAgICAgICAgICBuZXdab29tID0gTWF0aC5tYXgoTUlOX1pPT00sIE1hdGgubWluKE1BWF9aT09NLCByYXRpbyAqIHpvb20pKTtcblxuICAgICAgICBjYW52YXMuem9vbShuZXdab29tLCBtaWQpO1xuXG4gICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW5kKGUpIHtcbiAgICAgICAgcmVjb2duaXplci5vZmYoJ3BpbmNobW92ZScsIHVwZGF0ZSk7XG4gICAgICAgIHJlY29nbml6ZXIub2ZmKCdwaW5jaGVuZCcsIGVuZCk7XG4gICAgICAgIHJlY29nbml6ZXIub2ZmKCdwaW5jaGNhbmNlbCcsIGVuZCk7XG5cbiAgICAgICAgcmVjb2duaXplci5yZXNldCh0cnVlKTtcblxuICAgICAgICBsb2coJ2NhbnZhcycsICd6b29tIGVuZCcpO1xuICAgICAgfVxuXG4gICAgICByZWNvZ25pemVyLm9uKCdwaW5jaG1vdmUnLCB1cGRhdGUpO1xuICAgICAgcmVjb2duaXplci5vbigncGluY2hlbmQnLCBlbmQpO1xuICAgICAgcmVjb2duaXplci5vbigncGluY2hjYW5jZWwnLCBlbmQpO1xuICAgIH1cblxuICAgIHJlY29nbml6ZXIub24oJ3BhbnN0YXJ0Jywgc3RhcnRHcmFiKTtcbiAgICByZWNvZ25pemVyLm9uKCdwcmVzcycsIHN0YXJ0R3JhYik7XG5cbiAgICByZWNvZ25pemVyLm9uKCdwaW5jaHN0YXJ0Jywgc3RhcnRab29tKTtcbiAgfVxuXG4gIGlmIChkcmFnZ2luZykge1xuXG4gICAgLy8gc2ltdWxhdGUgaG92ZXIgZHVyaW5nIGRyYWdnaW5nXG4gICAgZXZlbnRCdXMub24oJ2RyYWcubW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudDtcblxuICAgICAgaWYgKCFvcmlnaW5hbEV2ZW50IHx8IG9yaWdpbmFsRXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvc2l0aW9uID0gdG9Qb2ludChvcmlnaW5hbEV2ZW50KTtcblxuICAgICAgLy8gdGhpcyBnZXRzIHJlYWxseSBleHBlbnNpdmUgLi4uXG4gICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQocG9zaXRpb24ueCwgcG9zaXRpb24ueSksXG4gICAgICAgICAgZ2Z4ID0gZ2V0R2Z4KG5vZGUpLFxuICAgICAgICAgIGVsZW1lbnQgPSBnZnggJiYgZWxlbWVudFJlZ2lzdHJ5LmdldChnZngpO1xuXG4gICAgICBpZiAoZWxlbWVudCAhPT0gZXZlbnQuaG92ZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50LmhvdmVyKSB7XG4gICAgICAgICAgZHJhZ2dpbmcub3V0KGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgZHJhZ2dpbmcuaG92ZXIoeyBlbGVtZW50OiBlbGVtZW50LCBnZng6IGdmeCB9KTtcblxuICAgICAgICAgIGV2ZW50LmhvdmVyID0gZWxlbWVudDtcbiAgICAgICAgICBldmVudC5ob3ZlckdmeCA9IGdmeDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGNvbnRleHRQYWQpIHtcblxuICAgIGV2ZW50QnVzLm9uKCdjb250ZXh0UGFkLmNyZWF0ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgbm9kZSA9IGV2ZW50LnBhZC5odG1sO1xuXG4gICAgICAvLyB0b3VjaCByZWNvZ25pemVyXG4gICAgICB2YXIgcGFkUmVjb2duaXplciA9IGNyZWF0ZVRvdWNoUmVjb2duaXplcihub2RlKTtcblxuICAgICAgcGFkUmVjb2duaXplci5vbigncGFuc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBsb2coJ2NvbnRleHQtcGFkJywgJ3BhbnN0YXJ0JywgZXZlbnQpO1xuICAgICAgICBjb250ZXh0UGFkLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2ZW50LCB0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBwYWRSZWNvZ25pemVyLm9uKCdwcmVzcycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGxvZygnY29udGV4dC1wYWQnLCAncHJlc3MnLCBldmVudCk7XG4gICAgICAgIGNvbnRleHRQYWQudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXZlbnQsIHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHBhZFJlY29nbml6ZXIub24oJ3RhcCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGxvZygnY29udGV4dC1wYWQnLCAndGFwJywgZXZlbnQpO1xuICAgICAgICBjb250ZXh0UGFkLnRyaWdnZXIoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocGFsZXR0ZSkge1xuICAgIGV2ZW50QnVzLm9uKCdwYWxldHRlLmNyZWF0ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgbm9kZSA9IGV2ZW50LmNvbnRhaW5lcjtcblxuICAgICAgLy8gdG91Y2ggcmVjb2duaXplclxuICAgICAgdmFyIHBhZFJlY29nbml6ZXIgPSBjcmVhdGVUb3VjaFJlY29nbml6ZXIobm9kZSk7XG5cbiAgICAgIHBhZFJlY29nbml6ZXIub24oJ3BhbnN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgbG9nKCdwYWxldHRlJywgJ3BhbnN0YXJ0JywgZXZlbnQpO1xuICAgICAgICBwYWxldHRlLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2ZW50LCB0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBwYWRSZWNvZ25pemVyLm9uKCdwcmVzcycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGxvZygncGFsZXR0ZScsICdwcmVzcycsIGV2ZW50KTtcbiAgICAgICAgcGFsZXR0ZS50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldmVudCwgdHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgcGFkUmVjb2duaXplci5vbigndGFwJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgbG9nKCdwYWxldHRlJywgJ3RhcCcsIGV2ZW50KTtcbiAgICAgICAgcGFsZXR0ZS50cmlnZ2VyKCdjbGljaycsIGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXZlbnRCdXMub24oJ2NhbnZhcy5pbml0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpbml0RXZlbnRzKGV2ZW50LnN2Zyk7XG4gIH0pO1xufVxuXG5cblRvdWNoSW50ZXJhY3Rpb25FdmVudHMuJGluamVjdCA9IFtcbiAgJ2luamVjdG9yJyxcbiAgJ2NhbnZhcycsXG4gICdldmVudEJ1cycsXG4gICdlbGVtZW50UmVnaXN0cnknLFxuICAnaW50ZXJhY3Rpb25FdmVudHMnLFxuICAndG91Y2hGaXgnXG5dO1xuIiwiaW1wb3J0IEludGVyYWN0aW9uRXZlbnRzTW9kdWxlIGZyb20gJy4uL2ludGVyYWN0aW9uLWV2ZW50cyc7XG5cbmltcG9ydCBUb3VjaEludGVyYWN0aW9uRXZlbnRzIGZyb20gJy4vVG91Y2hJbnRlcmFjdGlvbkV2ZW50cyc7XG5pbXBvcnQgVG91Y2hGaXggZnJvbSAnLi9Ub3VjaEZpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFsgSW50ZXJhY3Rpb25FdmVudHNNb2R1bGUgXSxcbiAgX19pbml0X186IFsgJ3RvdWNoSW50ZXJhY3Rpb25FdmVudHMnIF0sXG4gIHRvdWNoSW50ZXJhY3Rpb25FdmVudHM6IFsgJ3R5cGUnLCBUb3VjaEludGVyYWN0aW9uRXZlbnRzIF0sXG4gIHRvdWNoRml4OiBbICd0eXBlJywgVG91Y2hGaXggXVxufTsiLCJpbXBvcnQgdHJhbnNsYXRlIGZyb20gJy4vdHJhbnNsYXRlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB0cmFuc2xhdGU6IFsgJ3ZhbHVlJywgdHJhbnNsYXRlIF1cbn07IiwiLyoqXG4gKiBBIHNpbXBsZSB0cmFuc2xhdGlvbiBzdHViIHRvIGJlIHVzZWQgZm9yIG11bHRpLWxhbmd1YWdlIHN1cHBvcnRcbiAqIGluIGRpYWdyYW1zLiBDYW4gYmUgZWFzaWx5IHJlcGxhY2VkIHdpdGggYSBtb3JlIHNvcGhpc3RpY2F0ZWRcbiAqIHNvbHV0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gdXNlIGl0IGluc2lkZSBhbnkgZGlhZ3JhbSBjb21wb25lbnQgYnkgaW5qZWN0aW5nIGB0cmFuc2xhdGVgLlxuICpcbiAqIGZ1bmN0aW9uIE15U2VydmljZSh0cmFuc2xhdGUpIHtcbiAqICAgYWxlcnQodHJhbnNsYXRlKCdIRUxMTyB7eW91fScsIHsgeW91OiAnWW91IScgfSkpO1xuICogfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSB0byBpbnRlcnBvbGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtyZXBsYWNlbWVudHNdIGEgbWFwIHdpdGggc3Vic3RpdHV0ZXNcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB0cmFuc2xhdGVkIHN0cmluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2xhdGUodGVtcGxhdGUsIHJlcGxhY2VtZW50cykge1xuXG4gIHJlcGxhY2VtZW50cyA9IHJlcGxhY2VtZW50cyB8fCB7fTtcblxuICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgveyhbXn1dKyl9L2csIGZ1bmN0aW9uKF8sIGtleSkge1xuICAgIHJldHVybiByZXBsYWNlbWVudHNba2V5XSB8fCAneycgKyBrZXkgKyAnfSc7XG4gIH0pO1xufSIsImltcG9ydCB7XG4gIGdldE1pZFxufSBmcm9tICcuL0xheW91dFV0aWwnO1xuXG5cbi8qKlxuICogQSBiYXNlIGNvbm5lY3Rpb24gbGF5b3V0ZXIgaW1wbGVtZW50YXRpb25cbiAqIHRoYXQgbGF5b3V0cyB0aGUgY29ubmVjdGlvbiBieSBkaXJlY3RseSBjb25uZWN0aW5nXG4gKiBtaWQoc291cmNlKSArIG1pZCh0YXJnZXQpLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCYXNlTGF5b3V0ZXIoKSB7fVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBuZXcgbGF5b3V0ZWQgd2F5cG9pbnRzIGZvciB0aGUgZ2l2ZW4gY29ubmVjdGlvbi5cbiAqXG4gKiBUaGUgY29ubmVjdGlvbiBwYXNzZWQgaXMgc3RpbGwgdW5jaGFuZ2VkOyB5b3UgbWF5IGZpZ3VyZSBvdXQgYWJvdXRcbiAqIHRoZSBuZXcgY29ubmVjdGlvbiBzdGFydCAvIGVuZCB2aWEgdGhlIGxheW91dCBoaW50cyBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5Db25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW2hpbnRzXVxuICogQHBhcmFtIHtQb2ludH0gW2hpbnRzLmNvbm5lY3Rpb25TdGFydF1cbiAqIEBwYXJhbSB7UG9pbnR9IFtoaW50cy5jb25uZWN0aW9uRW5kXVxuICogQHBhcmFtIHtQb2ludH0gW2hpbnRzLnNvdXJjZV1cbiAqIEBwYXJhbSB7UG9pbnR9IFtoaW50cy50YXJnZXRdXG4gKlxuICogQHJldHVybiB7QXJyYXk8UG9pbnQ+fSB0aGUgbGF5b3V0ZWQgY29ubmVjdGlvbiB3YXlwb2ludHNcbiAqL1xuQmFzZUxheW91dGVyLnByb3RvdHlwZS5sYXlvdXRDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgaGludHMpIHtcblxuICBoaW50cyA9IGhpbnRzIHx8IHt9O1xuXG4gIHJldHVybiBbXG4gICAgaGludHMuY29ubmVjdGlvblN0YXJ0IHx8IGdldE1pZChoaW50cy5zb3VyY2UgfHwgY29ubmVjdGlvbi5zb3VyY2UpLFxuICAgIGhpbnRzLmNvbm5lY3Rpb25FbmQgfHwgZ2V0TWlkKGhpbnRzLnRhcmdldCB8fCBjb25uZWN0aW9uLnRhcmdldClcbiAgXTtcbn07XG4iLCJpbXBvcnQge1xuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRFbGVtZW50TGluZUludGVyc2VjdGlvblxufSBmcm9tICcuL0xheW91dFV0aWwnO1xuXG5cbmZ1bmN0aW9uIGRvY2tpbmdUb1BvaW50KGRvY2tpbmcpIHtcblxuICAvLyB1c2UgdGhlIGRvY2tpbmdzIGFjdHVhbCBwb2ludCBhbmRcbiAgLy8gcmV0YWluIHRoZSBvcmlnaW5hbCBkb2NraW5nXG4gIHJldHVybiBhc3NpZ24oeyBvcmlnaW5hbDogZG9ja2luZy5wb2ludC5vcmlnaW5hbCB8fCBkb2NraW5nLnBvaW50IH0sIGRvY2tpbmcuYWN0dWFsKTtcbn1cblxuXG4vKipcbiAqIEEge0BsaW5rIENvbm5lY3Rpb25Eb2NraW5nfSB0aGF0IGNyb3BzIGNvbm5lY3Rpb24gd2F5cG9pbnRzIGJhc2VkIG9uXG4gKiB0aGUgcGF0aChzKSBvZiB0aGUgY29ubmVjdGlvbiBzb3VyY2UgYW5kIHRhcmdldC5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5jb3JlLkVsZW1lbnRSZWdpc3RyeX0gZWxlbWVudFJlZ2lzdHJ5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENyb3BwaW5nQ29ubmVjdGlvbkRvY2tpbmcoZWxlbWVudFJlZ2lzdHJ5LCBncmFwaGljc0ZhY3RvcnkpIHtcbiAgdGhpcy5fZWxlbWVudFJlZ2lzdHJ5ID0gZWxlbWVudFJlZ2lzdHJ5O1xuICB0aGlzLl9ncmFwaGljc0ZhY3RvcnkgPSBncmFwaGljc0ZhY3Rvcnk7XG59XG5cbkNyb3BwaW5nQ29ubmVjdGlvbkRvY2tpbmcuJGluamVjdCA9IFsgJ2VsZW1lbnRSZWdpc3RyeScsICdncmFwaGljc0ZhY3RvcnknIF07XG5cblxuLyoqXG4gKiBAaW5oZXJpdERvYyBDb25uZWN0aW9uRG9ja2luZyNnZXRDcm9wcGVkV2F5cG9pbnRzXG4gKi9cbkNyb3BwaW5nQ29ubmVjdGlvbkRvY2tpbmcucHJvdG90eXBlLmdldENyb3BwZWRXYXlwb2ludHMgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBzb3VyY2UsIHRhcmdldCkge1xuXG4gIHNvdXJjZSA9IHNvdXJjZSB8fCBjb25uZWN0aW9uLnNvdXJjZTtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IGNvbm5lY3Rpb24udGFyZ2V0O1xuXG4gIHZhciBzb3VyY2VEb2NraW5nID0gdGhpcy5nZXREb2NraW5nUG9pbnQoY29ubmVjdGlvbiwgc291cmNlLCB0cnVlKSxcbiAgICAgIHRhcmdldERvY2tpbmcgPSB0aGlzLmdldERvY2tpbmdQb2ludChjb25uZWN0aW9uLCB0YXJnZXQpO1xuXG4gIHZhciBjcm9wcGVkV2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHMuc2xpY2Uoc291cmNlRG9ja2luZy5pZHggKyAxLCB0YXJnZXREb2NraW5nLmlkeCk7XG5cbiAgY3JvcHBlZFdheXBvaW50cy51bnNoaWZ0KGRvY2tpbmdUb1BvaW50KHNvdXJjZURvY2tpbmcpKTtcbiAgY3JvcHBlZFdheXBvaW50cy5wdXNoKGRvY2tpbmdUb1BvaW50KHRhcmdldERvY2tpbmcpKTtcblxuICByZXR1cm4gY3JvcHBlZFdheXBvaW50cztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjb25uZWN0aW9uIGRvY2tpbmcgcG9pbnQgb24gdGhlIHNwZWNpZmllZCBzaGFwZVxuICpcbiAqIEBpbmhlcml0RG9jIENvbm5lY3Rpb25Eb2NraW5nI2dldERvY2tpbmdQb2ludFxuICovXG5Dcm9wcGluZ0Nvbm5lY3Rpb25Eb2NraW5nLnByb3RvdHlwZS5nZXREb2NraW5nUG9pbnQgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBzaGFwZSwgZG9ja1N0YXJ0KSB7XG5cbiAgdmFyIHdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzLFxuICAgICAgZG9ja2luZ0lkeCxcbiAgICAgIGRvY2tpbmdQb2ludCxcbiAgICAgIGNyb3BwZWRQb2ludDtcblxuICBkb2NraW5nSWR4ID0gZG9ja1N0YXJ0ID8gMCA6IHdheXBvaW50cy5sZW5ndGggLSAxO1xuICBkb2NraW5nUG9pbnQgPSB3YXlwb2ludHNbZG9ja2luZ0lkeF07XG5cbiAgY3JvcHBlZFBvaW50ID0gdGhpcy5fZ2V0SW50ZXJzZWN0aW9uKHNoYXBlLCBjb25uZWN0aW9uLCBkb2NrU3RhcnQpO1xuXG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IGRvY2tpbmdQb2ludCxcbiAgICBhY3R1YWw6IGNyb3BwZWRQb2ludCB8fCBkb2NraW5nUG9pbnQsXG4gICAgaWR4OiBkb2NraW5nSWR4XG4gIH07XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5Dcm9wcGluZ0Nvbm5lY3Rpb25Eb2NraW5nLnByb3RvdHlwZS5fZ2V0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oc2hhcGUsIGNvbm5lY3Rpb24sIHRha2VGaXJzdCkge1xuXG4gIHZhciBzaGFwZVBhdGggPSB0aGlzLl9nZXRTaGFwZVBhdGgoc2hhcGUpLFxuICAgICAgY29ubmVjdGlvblBhdGggPSB0aGlzLl9nZXRDb25uZWN0aW9uUGF0aChjb25uZWN0aW9uKTtcblxuICByZXR1cm4gZ2V0RWxlbWVudExpbmVJbnRlcnNlY3Rpb24oc2hhcGVQYXRoLCBjb25uZWN0aW9uUGF0aCwgdGFrZUZpcnN0KTtcbn07XG5cbkNyb3BwaW5nQ29ubmVjdGlvbkRvY2tpbmcucHJvdG90eXBlLl9nZXRDb25uZWN0aW9uUGF0aCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgcmV0dXJuIHRoaXMuX2dyYXBoaWNzRmFjdG9yeS5nZXRDb25uZWN0aW9uUGF0aChjb25uZWN0aW9uKTtcbn07XG5cbkNyb3BwaW5nQ29ubmVjdGlvbkRvY2tpbmcucHJvdG90eXBlLl9nZXRTaGFwZVBhdGggPSBmdW5jdGlvbihzaGFwZSkge1xuICByZXR1cm4gdGhpcy5fZ3JhcGhpY3NGYWN0b3J5LmdldFNoYXBlUGF0aChzaGFwZSk7XG59O1xuXG5Dcm9wcGluZ0Nvbm5lY3Rpb25Eb2NraW5nLnByb3RvdHlwZS5fZ2V0R2Z4ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldEdyYXBoaWNzKGVsZW1lbnQpO1xufTtcbiIsImltcG9ydCB7XG4gIGlzT2JqZWN0LFxuICBzb3J0Qnlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBwb2ludERpc3RhbmNlLFxuICBwb2ludHNPbkxpbmVcbn0gZnJvbSAnLi4vdXRpbC9HZW9tZXRyeSc7XG5cbmltcG9ydCBpbnRlcnNlY3RQYXRocyBmcm9tICdwYXRoLWludGVyc2VjdGlvbic7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kQm91bmRzKGJvdW5kcykge1xuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoYm91bmRzLngpLFxuICAgIHk6IE1hdGgucm91bmQoYm91bmRzLnkpLFxuICAgIHdpZHRoOiBNYXRoLnJvdW5kKGJvdW5kcy53aWR0aCksXG4gICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGJvdW5kcy5oZWlnaHQpXG4gIH07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kUG9pbnQocG9pbnQpIHtcblxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQocG9pbnQueCksXG4gICAgeTogTWF0aC5yb3VuZChwb2ludC55KVxuICB9O1xufVxuXG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYm91bmRzIHRvIGEgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSBkZXNjcmlwdG9yLlxuICpcbiAqIEBwYXJhbSB7Qm91bmRzfFBvaW50fSBib3VuZHNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc1RSQkwoYm91bmRzKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBib3VuZHMueSxcbiAgICByaWdodDogYm91bmRzLnggKyAoYm91bmRzLndpZHRoIHx8IDApLFxuICAgIGJvdHRvbTogYm91bmRzLnkgKyAoYm91bmRzLmhlaWdodCB8fCAwKSxcbiAgICBsZWZ0OiBib3VuZHMueFxuICB9O1xufVxuXG5cbi8qKlxuICogQ29udmVydCBhIHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0gdG8gYW4gb2JqZWN0cyBib3VuZHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRyYmxcbiAqXG4gKiBAcmV0dXJuIHtCb3VuZHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0JvdW5kcyh0cmJsKSB7XG4gIHJldHVybiB7XG4gICAgeDogdHJibC5sZWZ0LFxuICAgIHk6IHRyYmwudG9wLFxuICAgIHdpZHRoOiB0cmJsLnJpZ2h0IC0gdHJibC5sZWZ0LFxuICAgIGhlaWdodDogdHJibC5ib3R0b20gLSB0cmJsLnRvcFxuICB9O1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBtaWQgb2YgdGhlIGdpdmVuIGJvdW5kcyBvciBwb2ludC5cbiAqXG4gKiBAcGFyYW0ge0JvdW5kc3xQb2ludH0gYm91bmRzXG4gKlxuICogQHJldHVybiB7UG9pbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaWQoYm91bmRzKSB7XG4gIHJldHVybiByb3VuZFBvaW50KHtcbiAgICB4OiBib3VuZHMueCArIChib3VuZHMud2lkdGggfHwgMCkgLyAyLFxuICAgIHk6IGJvdW5kcy55ICsgKGJvdW5kcy5oZWlnaHQgfHwgMCkgLyAyXG4gIH0pO1xufVxuXG5cbi8vIG9yaWVudGF0aW9uIHV0aWxzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBHZXQgb3JpZW50YXRpb24gb2YgdGhlIGdpdmVuIHJlY3RhbmdsZSB3aXRoIHJlc3BlY3QgdG9cbiAqIHRoZSByZWZlcmVuY2UgcmVjdGFuZ2xlLlxuICpcbiAqIEEgcGFkZGluZyAocG9zaXRpdmUgb3IgbmVnYXRpdmUpIG1heSBiZSBwYXNzZWQgdG8gaW5mbHVlbmNlXG4gKiBob3Jpem9udGFsIC8gdmVydGljYWwgb3JpZW50YXRpb24gYW5kIGludGVyc2VjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0JvdW5kc30gcmVjdFxuICogQHBhcmFtIHtCb3VuZHN9IHJlZmVyZW5jZVxuICogQHBhcmFtIHtQb2ludHxudW1iZXJ9IHBhZGRpbmdcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBvcmllbnRhdGlvbjsgb25lIG9mIHRvcCwgdG9wLWxlZnQsIGxlZnQsIC4uLiwgYm90dG9tLCByaWdodCBvciBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmllbnRhdGlvbihyZWN0LCByZWZlcmVuY2UsIHBhZGRpbmcpIHtcblxuICBwYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuXG4gIC8vIG1ha2Ugc3VyZSB3ZSBjYW4gdXNlIGFuIG9iamVjdCwgdG9vXG4gIC8vIGZvciBpbmRpdmlkdWFsIHsgeCwgeSB9IHBhZGRpbmdcbiAgaWYgKCFpc09iamVjdChwYWRkaW5nKSkge1xuICAgIHBhZGRpbmcgPSB7IHg6IHBhZGRpbmcsIHk6IHBhZGRpbmcgfTtcbiAgfVxuXG5cbiAgdmFyIHJlY3RPcmllbnRhdGlvbiA9IGFzVFJCTChyZWN0KSxcbiAgICAgIHJlZmVyZW5jZU9yaWVudGF0aW9uID0gYXNUUkJMKHJlZmVyZW5jZSk7XG5cbiAgdmFyIHRvcCA9IHJlY3RPcmllbnRhdGlvbi5ib3R0b20gKyBwYWRkaW5nLnkgPD0gcmVmZXJlbmNlT3JpZW50YXRpb24udG9wLFxuICAgICAgcmlnaHQgPSByZWN0T3JpZW50YXRpb24ubGVmdCAtIHBhZGRpbmcueCA+PSByZWZlcmVuY2VPcmllbnRhdGlvbi5yaWdodCxcbiAgICAgIGJvdHRvbSA9IHJlY3RPcmllbnRhdGlvbi50b3AgLSBwYWRkaW5nLnkgPj0gcmVmZXJlbmNlT3JpZW50YXRpb24uYm90dG9tLFxuICAgICAgbGVmdCA9IHJlY3RPcmllbnRhdGlvbi5yaWdodCArIHBhZGRpbmcueCA8PSByZWZlcmVuY2VPcmllbnRhdGlvbi5sZWZ0O1xuXG4gIHZhciB2ZXJ0aWNhbCA9IHRvcCA/ICd0b3AnIDogKGJvdHRvbSA/ICdib3R0b20nIDogbnVsbCksXG4gICAgICBob3Jpem9udGFsID0gbGVmdCA/ICdsZWZ0JyA6IChyaWdodCA/ICdyaWdodCcgOiBudWxsKTtcblxuICBpZiAoaG9yaXpvbnRhbCAmJiB2ZXJ0aWNhbCkge1xuICAgIHJldHVybiB2ZXJ0aWNhbCArICctJyArIGhvcml6b250YWw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhvcml6b250YWwgfHwgdmVydGljYWwgfHwgJ2ludGVyc2VjdCc7XG4gIH1cbn1cblxuXG4vLyBpbnRlcnNlY3Rpb24gdXRpbHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEdldCBpbnRlcnNlY3Rpb24gYmV0d2VlbiBhbiBlbGVtZW50IGFuZCBhIGxpbmUgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1BhdGhEZWZ9IGVsZW1lbnRQYXRoXG4gKiBAcGFyYW0ge1BhdGhEZWZ9IGxpbmVQYXRoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNyb3BTdGFydCBjcm9wIGZyb20gc3RhcnQgb3IgZW5kXG4gKlxuICogQHJldHVybiB7UG9pbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50TGluZUludGVyc2VjdGlvbihlbGVtZW50UGF0aCwgbGluZVBhdGgsIGNyb3BTdGFydCkge1xuXG4gIHZhciBpbnRlcnNlY3Rpb25zID0gZ2V0SW50ZXJzZWN0aW9ucyhlbGVtZW50UGF0aCwgbGluZVBhdGgpO1xuXG4gIC8vIHJlY29nbml6ZSBpbnRlcnNlY3Rpb25zXG4gIC8vIG9ubHkgb25lIC0+IGNob29zZVxuICAvLyB0d28gY2xvc2UgdG9nZXRoZXIgLT4gY2hvb3NlIGZpcnN0XG4gIC8vIHR3byBvciBtb3JlIGRpc3RpbmN0IC0+IHB1bGwgb3V0IGFwcHJvcHJpYXRlIG9uZVxuICAvLyBub25lIC0+IG9rIChmYWxsYmFjayB0byBwb2ludCBpdHNlbGYpXG4gIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiByb3VuZFBvaW50KGludGVyc2VjdGlvbnNbMF0pO1xuICB9IGVsc2UgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID09PSAyICYmIHBvaW50RGlzdGFuY2UoaW50ZXJzZWN0aW9uc1swXSwgaW50ZXJzZWN0aW9uc1sxXSkgPCAxKSB7XG4gICAgcmV0dXJuIHJvdW5kUG9pbnQoaW50ZXJzZWN0aW9uc1swXSk7XG4gIH0gZWxzZSBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPiAxKSB7XG5cbiAgICAvLyBzb3J0IGJ5IGludGVyc2VjdGlvbnMgYmFzZWQgb24gY29ubmVjdGlvbiBzZWdtZW50ICtcbiAgICAvLyBkaXN0YW5jZSBmcm9tIHN0YXJ0XG4gICAgaW50ZXJzZWN0aW9ucyA9IHNvcnRCeShpbnRlcnNlY3Rpb25zLCBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmZsb29yKGkudDIgKiAxMDApIHx8IDE7XG5cbiAgICAgIGRpc3RhbmNlID0gMTAwIC0gZGlzdGFuY2U7XG5cbiAgICAgIGRpc3RhbmNlID0gKGRpc3RhbmNlIDwgMTAgPyAnMCcgOiAnJykgKyBkaXN0YW5jZTtcblxuICAgICAgLy8gY3JlYXRlIGEgc29ydCBzdHJpbmcgdGhhdCBtYWtlcyBzdXJlIHdlIHNvcnRcbiAgICAgIC8vIGxpbmUgc2VnbWVudCBBU0MgKyBsaW5lIHNlZ21lbnQgcG9zaXRpb24gREVTQyAoZm9yIGNyb3BTdGFydClcbiAgICAgIC8vIGxpbmUgc2VnbWVudCBBU0MgKyBsaW5lIHNlZ21lbnQgcG9zaXRpb24gQVNDIChmb3IgY3JvcEVuZClcbiAgICAgIHJldHVybiBpLnNlZ21lbnQyICsgJyMnICsgZGlzdGFuY2U7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcm91bmRQb2ludChpbnRlcnNlY3Rpb25zW2Nyb3BTdGFydCA/IDAgOiBpbnRlcnNlY3Rpb25zLmxlbmd0aCAtIDFdKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25zKGEsIGIpIHtcbiAgcmV0dXJuIGludGVyc2VjdFBhdGhzKGEsIGIpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJSZWR1bmRhbnRXYXlwb2ludHMod2F5cG9pbnRzKSB7XG5cbiAgLy8gYWx0ZXIgY29weSBvZiB3YXlwb2ludHMsIG5vdCBvcmlnaW5hbFxuICB3YXlwb2ludHMgPSB3YXlwb2ludHMuc2xpY2UoKTtcblxuICB2YXIgaWR4ID0gMCxcbiAgICAgIHBvaW50LFxuICAgICAgcHJldmlvdXNQb2ludCxcbiAgICAgIG5leHRQb2ludDtcblxuICB3aGlsZSAod2F5cG9pbnRzW2lkeF0pIHtcbiAgICBwb2ludCA9IHdheXBvaW50c1tpZHhdO1xuICAgIHByZXZpb3VzUG9pbnQgPSB3YXlwb2ludHNbaWR4IC0gMV07XG4gICAgbmV4dFBvaW50ID0gd2F5cG9pbnRzW2lkeCArIDFdO1xuXG4gICAgaWYgKHBvaW50RGlzdGFuY2UocG9pbnQsIG5leHRQb2ludCkgPT09IDAgfHxcbiAgICAgICAgcG9pbnRzT25MaW5lKHByZXZpb3VzUG9pbnQsIG5leHRQb2ludCwgcG9pbnQpKSB7XG5cbiAgICAgIC8vIHJlbW92ZSBwb2ludCwgaWYgb3ZlcmxhcHBpbmcgd2l0aCB7bmV4dFBvaW50fVxuICAgICAgLy8gb3Igb24gbGluZSB3aXRoIHtwcmV2aW91c1BvaW50fSAtPiB7cG9pbnR9IC0+IHtuZXh0UG9pbnR9XG4gICAgICB3YXlwb2ludHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkeCsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3YXlwb2ludHM7XG59XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdtaW4tZGFzaCc7XG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgUmVmcyBmcm9tICdvYmplY3QtcmVmcyc7XG5cbnZhciBwYXJlbnRSZWZzID0gbmV3IFJlZnMoeyBuYW1lOiAnY2hpbGRyZW4nLCBlbnVtZXJhYmxlOiB0cnVlLCBjb2xsZWN0aW9uOiB0cnVlIH0sIHsgbmFtZTogJ3BhcmVudCcgfSksXG4gICAgbGFiZWxSZWZzID0gbmV3IFJlZnMoeyBuYW1lOiAnbGFiZWxzJywgZW51bWVyYWJsZTogdHJ1ZSwgY29sbGVjdGlvbjogdHJ1ZSB9LCB7IG5hbWU6ICdsYWJlbFRhcmdldCcgfSksXG4gICAgYXR0YWNoZXJSZWZzID0gbmV3IFJlZnMoeyBuYW1lOiAnYXR0YWNoZXJzJywgY29sbGVjdGlvbjogdHJ1ZSB9LCB7IG5hbWU6ICdob3N0JyB9KSxcbiAgICBvdXRnb2luZ1JlZnMgPSBuZXcgUmVmcyh7IG5hbWU6ICdvdXRnb2luZycsIGNvbGxlY3Rpb246IHRydWUgfSwgeyBuYW1lOiAnc291cmNlJyB9KSxcbiAgICBpbmNvbWluZ1JlZnMgPSBuZXcgUmVmcyh7IG5hbWU6ICdpbmNvbWluZycsIGNvbGxlY3Rpb246IHRydWUgfSwgeyBuYW1lOiAndGFyZ2V0JyB9KTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIGRqcy5tb2RlbFxuICovXG5cbi8qKlxuICogQG1lbWJlck9mIGRqcy5tb2RlbFxuICovXG5cbi8qKlxuICogVGhlIGJhc2ljIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBjbGFzc1xuICpcbiAqIEBhYnN0cmFjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gQmFzZSgpIHtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0aGF0IGJhY2tzIHVwIHRoZSBzaGFwZVxuICAgKlxuICAgKiBAbmFtZSBCYXNlI2J1c2luZXNzT2JqZWN0XG4gICAqIEB0eXBlIE9iamVjdFxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdidXNpbmVzc09iamVjdCcsIHtcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KTtcblxuXG4gIC8qKlxuICAgKiBTaW5nbGUgbGFiZWwgc3VwcG9ydCwgd2lsbCBtYXBwZWQgdG8gbXVsdGkgbGFiZWwgYXJyYXlcbiAgICpcbiAgICogQG5hbWUgQmFzZSNsYWJlbFxuICAgKiBAdHlwZSBPYmplY3RcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbGFiZWwnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsc1swXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24obmV3TGFiZWwpIHtcblxuICAgICAgdmFyIGxhYmVsID0gdGhpcy5sYWJlbCxcbiAgICAgICAgICBsYWJlbHMgPSB0aGlzLmxhYmVscztcblxuICAgICAgaWYgKCFuZXdMYWJlbCAmJiBsYWJlbCkge1xuICAgICAgICBsYWJlbHMucmVtb3ZlKGxhYmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVscy5hZGQobmV3TGFiZWwsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJlbnQgc2hhcGVcbiAgICpcbiAgICogQG5hbWUgQmFzZSNwYXJlbnRcbiAgICogQHR5cGUgU2hhcGVcbiAgICovXG4gIHBhcmVudFJlZnMuYmluZCh0aGlzLCAncGFyZW50Jyk7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGxhYmVsc1xuICAgKlxuICAgKiBAbmFtZSBCYXNlI2xhYmVsc1xuICAgKiBAdHlwZSBMYWJlbFxuICAgKi9cbiAgbGFiZWxSZWZzLmJpbmQodGhpcywgJ2xhYmVscycpO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBvdXRnb2luZyBjb25uZWN0aW9uc1xuICAgKlxuICAgKiBAbmFtZSBCYXNlI291dGdvaW5nXG4gICAqIEB0eXBlIEFycmF5PENvbm5lY3Rpb24+XG4gICAqL1xuICBvdXRnb2luZ1JlZnMuYmluZCh0aGlzLCAnb3V0Z29pbmcnKTtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgaW5jb21pbmcgY29ubmVjdGlvbnNcbiAgICpcbiAgICogQG5hbWUgQmFzZSNpbmNvbWluZ1xuICAgKiBAdHlwZSBBcnJheTxDb25uZWN0aW9uPlxuICAgKi9cbiAgaW5jb21pbmdSZWZzLmJpbmQodGhpcywgJ2luY29taW5nJyk7XG59XG5cblxuLyoqXG4gKiBBIGdyYXBoaWNhbCBvYmplY3RcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBleHRlbmRzIEJhc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNoYXBlKCkge1xuICBCYXNlLmNhbGwodGhpcyk7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBmcmFtZSBzaGFwZXNcbiAgICpcbiAgICogQG5hbWUgU2hhcGUjaXNGcmFtZVxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBjaGlsZHJlblxuICAgKlxuICAgKiBAbmFtZSBTaGFwZSNjaGlsZHJlblxuICAgKiBAdHlwZSBBcnJheTxCYXNlPlxuICAgKi9cbiAgcGFyZW50UmVmcy5iaW5kKHRoaXMsICdjaGlsZHJlbicpO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBTaGFwZSNob3N0XG4gICAqIEB0eXBlIFNoYXBlXG4gICAqL1xuICBhdHRhY2hlclJlZnMuYmluZCh0aGlzLCAnaG9zdCcpO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBTaGFwZSNhdHRhY2hlcnNcbiAgICogQHR5cGUgU2hhcGVcbiAgICovXG4gIGF0dGFjaGVyUmVmcy5iaW5kKHRoaXMsICdhdHRhY2hlcnMnKTtcbn1cblxuaW5oZXJpdHMoU2hhcGUsIEJhc2UpO1xuXG5cbi8qKlxuICogQSByb290IGdyYXBoaWNhbCBvYmplY3RcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBleHRlbmRzIFNoYXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb290KCkge1xuICBTaGFwZS5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0cyhSb290LCBTaGFwZSk7XG5cblxuLyoqXG4gKiBBIGxhYmVsIGZvciBhbiBlbGVtZW50XG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gTGFiZWwoKSB7XG4gIFNoYXBlLmNhbGwodGhpcyk7XG5cbiAgLyoqXG4gICAqIFRoZSBsYWJlbGVkIGVsZW1lbnRcbiAgICpcbiAgICogQG5hbWUgTGFiZWwjbGFiZWxUYXJnZXRcbiAgICogQHR5cGUgQmFzZVxuICAgKi9cbiAgbGFiZWxSZWZzLmJpbmQodGhpcywgJ2xhYmVsVGFyZ2V0Jyk7XG59XG5cbmluaGVyaXRzKExhYmVsLCBTaGFwZSk7XG5cblxuLyoqXG4gKiBBIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gZWxlbWVudHNcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBleHRlbmRzIEJhc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbm5lY3Rpb24oKSB7XG4gIEJhc2UuY2FsbCh0aGlzKTtcblxuICAvKipcbiAgICogVGhlIGVsZW1lbnQgdGhpcyBjb25uZWN0aW9uIG9yaWdpbmF0ZXMgZnJvbVxuICAgKlxuICAgKiBAbmFtZSBDb25uZWN0aW9uI3NvdXJjZVxuICAgKiBAdHlwZSBCYXNlXG4gICAqL1xuICBvdXRnb2luZ1JlZnMuYmluZCh0aGlzLCAnc291cmNlJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGVtZW50IHRoaXMgY29ubmVjdGlvbiBwb2ludHMgdG9cbiAgICpcbiAgICogQG5hbWUgQ29ubmVjdGlvbiN0YXJnZXRcbiAgICogQHR5cGUgQmFzZVxuICAgKi9cbiAgaW5jb21pbmdSZWZzLmJpbmQodGhpcywgJ3RhcmdldCcpO1xufVxuXG5pbmhlcml0cyhDb25uZWN0aW9uLCBCYXNlKTtcblxuXG52YXIgdHlwZXMgPSB7XG4gIGNvbm5lY3Rpb246IENvbm5lY3Rpb24sXG4gIHNoYXBlOiBTaGFwZSxcbiAgbGFiZWw6IExhYmVsLFxuICByb290OiBSb290XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbW9kZWwgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGVcbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHNoYXBlMSA9IE1vZGVsLmNyZWF0ZSgnc2hhcGUnLCB7IHg6IDEwLCB5OiAxMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAgfSk7XG4gKiB2YXIgc2hhcGUyID0gTW9kZWwuY3JlYXRlKCdzaGFwZScsIHsgeDogMjEwLCB5OiAyMTAsIHdpZHRoOiAxMDAsIGhlaWdodDogMTAwIH0pO1xuICpcbiAqIHZhciBjb25uZWN0aW9uID0gTW9kZWwuY3JlYXRlKCdjb25uZWN0aW9uJywgeyB3YXlwb2ludHM6IFsgeyB4OiAxMTAsIHk6IDU1IH0sIHt4OiAyMTAsIHk6IDU1IH0gXSB9KTtcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgbG93ZXItY2FzZWQgbW9kZWwgbmFtZVxuICogQHBhcmFtICB7T2JqZWN0fSBhdHRycyBhdHRyaWJ1dGVzIHRvIGluaXRpYWxpemUgdGhlIG5ldyBtb2RlbCBpbnN0YW5jZSB3aXRoXG4gKlxuICogQHJldHVybiB7QmFzZX0gdGhlIG5ldyBtb2RlbCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHR5cGUsIGF0dHJzKSB7XG4gIHZhciBUeXBlID0gdHlwZXNbdHlwZV07XG4gIGlmICghVHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biB0eXBlOiA8JyArIHR5cGUgKyAnPicpO1xuICB9XG4gIHJldHVybiBhc3NpZ24obmV3IFR5cGUoKSwgYXR0cnMpO1xufSIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ21pbi1kYXNoJztcblxuXG52YXIgREVGQVVMVF9DT05GSUcgPSB7XG4gIG1vdmVTcGVlZDogNTAsXG4gIG1vdmVTcGVlZEFjY2VsZXJhdGVkOiAyMDBcbn07XG5cblxuLyoqXG4gKiBBIGZlYXR1cmUgdGhhdCBhbGxvd3MgdXNlcnMgdG8gbW92ZSB0aGUgY2FudmFzIHVzaW5nIHRoZSBrZXlib2FyZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tb3ZlU3BlZWQ9NTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tb3ZlU3BlZWRBY2NlbGVyYXRlZD0yMDBdXG4gKiBAcGFyYW0ge0tleWJvYXJkfSBrZXlib2FyZFxuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBLZXlib2FyZE1vdmUoXG4gICAgY29uZmlnLFxuICAgIGtleWJvYXJkLFxuICAgIGNhbnZhc1xuKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuX2NvbmZpZyA9IGFzc2lnbih7fSwgREVGQVVMVF9DT05GSUcsIGNvbmZpZyB8fCB7fSk7XG5cbiAga2V5Ym9hcmQuYWRkTGlzdGVuZXIoYXJyb3dzTGlzdGVuZXIpO1xuXG5cbiAgZnVuY3Rpb24gYXJyb3dzTGlzdGVuZXIoY29udGV4dCkge1xuXG4gICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudCxcbiAgICAgICAgY29uZmlnID0gc2VsZi5fY29uZmlnO1xuXG4gICAgaWYgKCFrZXlib2FyZC5pc0NtZChldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5Ym9hcmQuaXNLZXkoW1xuICAgICAgJ0Fycm93TGVmdCcsICdMZWZ0JyxcbiAgICAgICdBcnJvd1VwJywgJ1VwJyxcbiAgICAgICdBcnJvd0Rvd24nLCAnRG93bicsXG4gICAgICAnQXJyb3dSaWdodCcsICdSaWdodCdcbiAgICBdLCBldmVudCkpIHtcblxuICAgICAgdmFyIHNwZWVkID0gKFxuICAgICAgICBrZXlib2FyZC5pc1NoaWZ0KGV2ZW50KSA/XG4gICAgICAgICAgY29uZmlnLm1vdmVTcGVlZEFjY2VsZXJhdGVkIDpcbiAgICAgICAgICBjb25maWcubW92ZVNwZWVkXG4gICAgICApO1xuXG4gICAgICB2YXIgZGlyZWN0aW9uO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgIGNhc2UgJ0xlZnQnOlxuICAgICAgICBkaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICBjYXNlICdVcCc6XG4gICAgICAgIGRpcmVjdGlvbiA9ICd1cCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICBjYXNlICdSaWdodCc6XG4gICAgICAgIGRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgIGNhc2UgJ0Rvd24nOlxuICAgICAgICBkaXJlY3Rpb24gPSAnZG93bic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzZWxmLm1vdmVDYW52YXMoe1xuICAgICAgICBzcGVlZDogc3BlZWQsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5tb3ZlQ2FudmFzID0gZnVuY3Rpb24ob3B0cykge1xuXG4gICAgdmFyIGR4ID0gMCxcbiAgICAgICAgZHkgPSAwLFxuICAgICAgICBzcGVlZCA9IG9wdHMuc3BlZWQ7XG5cbiAgICB2YXIgYWN0dWFsU3BlZWQgPSBzcGVlZCAvIE1hdGgubWluKE1hdGguc3FydChjYW52YXMudmlld2JveCgpLnNjYWxlKSwgMSk7XG5cbiAgICBzd2l0Y2ggKG9wdHMuZGlyZWN0aW9uKSB7XG4gICAgY2FzZSAnbGVmdCc6IC8vIExlZnRcbiAgICAgIGR4ID0gYWN0dWFsU3BlZWQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1cCc6IC8vIFVwXG4gICAgICBkeSA9IGFjdHVhbFNwZWVkO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOiAvLyBSaWdodFxuICAgICAgZHggPSAtYWN0dWFsU3BlZWQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkb3duJzogLy8gRG93blxuICAgICAgZHkgPSAtYWN0dWFsU3BlZWQ7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYW52YXMuc2Nyb2xsKHtcbiAgICAgIGR4OiBkeCxcbiAgICAgIGR5OiBkeVxuICAgIH0pO1xuICB9O1xuXG59XG5cblxuS2V5Ym9hcmRNb3ZlLiRpbmplY3QgPSBbXG4gICdjb25maWcua2V5Ym9hcmRNb3ZlJyxcbiAgJ2tleWJvYXJkJyxcbiAgJ2NhbnZhcydcbl07XG4iLCJpbXBvcnQgS2V5Ym9hcmRNb2R1bGUgZnJvbSAnLi4vLi4vZmVhdHVyZXMva2V5Ym9hcmQnO1xuXG5pbXBvcnQgS2V5Ym9hcmRNb3ZlIGZyb20gJy4vS2V5Ym9hcmRNb3ZlJztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgS2V5Ym9hcmRNb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFsgJ2tleWJvYXJkTW92ZScgXSxcbiAga2V5Ym9hcmRNb3ZlOiBbICd0eXBlJywgS2V5Ym9hcmRNb3ZlIF1cbn07IiwiaW1wb3J0IHtcbiAgc2V0IGFzIGN1cnNvclNldCxcbiAgdW5zZXQgYXMgY3Vyc29yVW5zZXRcbn0gZnJvbSAnLi4vLi4vdXRpbC9DdXJzb3InO1xuXG5pbXBvcnQge1xuICBpbnN0YWxsIGFzIGluc3RhbGxDbGlja1RyYXBcbn0gZnJvbSAnLi4vLi4vdXRpbC9DbGlja1RyYXAnO1xuXG5pbXBvcnQge1xuICBkZWx0YSBhcyBkZWx0YVBvc1xufSBmcm9tICcuLi8uLi91dGlsL1Bvc2l0aW9uVXRpbCc7XG5cbmltcG9ydCB7XG4gIGV2ZW50IGFzIGRvbUV2ZW50LFxuICBjbG9zZXN0IGFzIGRvbUNsb3Nlc3Rcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIHRvUG9pbnRcbn0gZnJvbSAnLi4vLi4vdXRpbC9FdmVudCc7XG5cblxudmFyIFRIUkVTSE9MRCA9IDE1O1xuXG5cbi8qKlxuICogTW92ZSB0aGUgY2FudmFzIHZpYSBtb3VzZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNb3ZlQ2FudmFzKGV2ZW50QnVzLCBjYW52YXMpIHtcblxuICB2YXIgY29udGV4dDtcblxuXG4gIC8vIGxpc3RlbiBmb3IgbW92ZSBvbiBlbGVtZW50IG1vdXNlIGRvd247XG4gIC8vIGFsbG93IG90aGVycyB0byBob29rIGludG8gdGhlIGV2ZW50IGJlZm9yZSB1cyB0aG91Z2hcbiAgLy8gKGRyYWdnaW5nIC8gZWxlbWVudCBtb3Zpbmcgd2lsbCBkbyB0aGlzKVxuICBldmVudEJ1cy5vbignZWxlbWVudC5tb3VzZWRvd24nLCA1MDAsIGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gaGFuZGxlU3RhcnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgfSk7XG5cblxuICBmdW5jdGlvbiBoYW5kbGVNb3ZlKGV2ZW50KSB7XG5cbiAgICB2YXIgc3RhcnQgPSBjb250ZXh0LnN0YXJ0LFxuICAgICAgICBidXR0b24gPSBjb250ZXh0LmJ1dHRvbixcbiAgICAgICAgcG9zaXRpb24gPSB0b1BvaW50KGV2ZW50KSxcbiAgICAgICAgZGVsdGEgPSBkZWx0YVBvcyhwb3NpdGlvbiwgc3RhcnQpO1xuXG4gICAgaWYgKCFjb250ZXh0LmRyYWdnaW5nICYmIGxlbmd0aChkZWx0YSkgPiBUSFJFU0hPTEQpIHtcbiAgICAgIGNvbnRleHQuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoYnV0dG9uID09PSAwKSB7XG4gICAgICAgIGluc3RhbGxDbGlja1RyYXAoZXZlbnRCdXMpO1xuICAgICAgfVxuXG4gICAgICBjdXJzb3JTZXQoJ2dyYWInKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5kcmFnZ2luZykge1xuXG4gICAgICB2YXIgbGFzdFBvc2l0aW9uID0gY29udGV4dC5sYXN0IHx8IGNvbnRleHQuc3RhcnQ7XG5cbiAgICAgIGRlbHRhID0gZGVsdGFQb3MocG9zaXRpb24sIGxhc3RQb3NpdGlvbik7XG5cbiAgICAgIGNhbnZhcy5zY3JvbGwoe1xuICAgICAgICBkeDogZGVsdGEueCxcbiAgICAgICAgZHk6IGRlbHRhLnlcbiAgICAgIH0pO1xuXG4gICAgICBjb250ZXh0Lmxhc3QgPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IHNlbGVjdFxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGhhbmRsZUVuZChldmVudCkge1xuICAgIGRvbUV2ZW50LnVuYmluZChkb2N1bWVudCwgJ21vdXNlbW92ZScsIGhhbmRsZU1vdmUpO1xuICAgIGRvbUV2ZW50LnVuYmluZChkb2N1bWVudCwgJ21vdXNldXAnLCBoYW5kbGVFbmQpO1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICBjdXJzb3JVbnNldCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnQoZXZlbnQpIHtcblxuICAgIC8vIGV2ZW50IGlzIGFscmVhZHkgaGFuZGxlZCBieSAnLmRqcy1kcmFnZ2FibGUnXG4gICAgaWYgKGRvbUNsb3Nlc3QoZXZlbnQudGFyZ2V0LCAnLmRqcy1kcmFnZ2FibGUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cbiAgICAvLyByZWplY3QgcmlnaHQgbW91c2UgYnV0dG9uIG9yIG1vZGlmaWVyIGtleVxuICAgIGlmIChidXR0b24gPj0gMiB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQgPSB7XG4gICAgICBidXR0b246IGJ1dHRvbixcbiAgICAgIHN0YXJ0OiB0b1BvaW50KGV2ZW50KVxuICAgIH07XG5cbiAgICBkb21FdmVudC5iaW5kKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgaGFuZGxlTW92ZSk7XG4gICAgZG9tRXZlbnQuYmluZChkb2N1bWVudCwgJ21vdXNldXAnLCBoYW5kbGVFbmQpO1xuXG4gICAgLy8gd2UndmUgaGFuZGxlZCB0aGUgZXZlbnRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISFjb250ZXh0O1xuICB9O1xuXG59XG5cblxuTW92ZUNhbnZhcy4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJ1xuXTtcblxuXG5cbi8vIGhlbHBlcnMgLy8vLy8vL1xuXG5mdW5jdGlvbiBsZW5ndGgocG9pbnQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwb2ludC54LCAyKSArIE1hdGgucG93KHBvaW50LnksIDIpKTtcbn1cbiIsImltcG9ydCBNb3ZlQ2FudmFzIGZyb20gJy4vTW92ZUNhbnZhcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ21vdmVDYW52YXMnIF0sXG4gIG1vdmVDYW52YXM6IFsgJ3R5cGUnLCBNb3ZlQ2FudmFzIF1cbn07IiwiaW1wb3J0IFRvdWNoTW9kdWxlIGZyb20gJy4uLy4uL2ZlYXR1cmVzL3RvdWNoJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIFRvdWNoTW9kdWxlXG4gIF1cbn07IiwiaW1wb3J0IHtcbiAgZXZlbnQgYXMgZG9tRXZlbnQsXG4gIGNsb3Nlc3QgYXMgZG9tQ2xvc2VzdFxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgZ2V0U3RlcFNpemUsXG4gIGNhcFxufSBmcm9tICcuL1pvb21VdGlsJztcblxuaW1wb3J0IHtcbiAgbG9nMTBcbn0gZnJvbSAnLi4vLi4vdXRpbC9NYXRoJztcblxuaW1wb3J0IHtcbiAgYmluZFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbnZhciBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuIG4gPj0gMCA/IDEgOiAtMTtcbn07XG5cbnZhciBSQU5HRSA9IHsgbWluOiAwLjIsIG1heDogNCB9LFxuICAgIE5VTV9TVEVQUyA9IDEwO1xuXG52YXIgREVMVEFfVEhSRVNIT0xEID0gMC4xO1xuXG52YXIgREVGQVVMVF9TQ0FMRSA9IDAuNzU7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2Ygem9vbWluZyBhbmQgc2Nyb2xsaW5nIHdpdGhpbiB0aGVcbiAqIHtAbGluayBDYW52YXN9IHZpYSB0aGUgbW91c2Ugd2hlZWwuXG4gKlxuICogTW91c2Ugd2hlZWwgem9vbWluZyAvIHNjcm9sbGluZyBtYXkgYmUgZGlzYWJsZWQgdXNpbmdcbiAqIHRoZSB7QGxpbmsgdG9nZ2xlKGVuYWJsZWQpfSBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjb25maWcuZW5hYmxlZD10cnVlXSBkZWZhdWx0IGVuYWJsZWQgc3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLnNjYWxlPS43NV0gc2Nyb2xsIHNlbnNpdml0eVxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gWm9vbVNjcm9sbChjb25maWcsIGV2ZW50QnVzLCBjYW52YXMpIHtcblxuICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fY29udGFpbmVyID0gY2FudmFzLl9jb250YWluZXI7XG5cbiAgdGhpcy5faGFuZGxlV2hlZWwgPSBiaW5kKHRoaXMuX2hhbmRsZVdoZWVsLCB0aGlzKTtcblxuICB0aGlzLl90b3RhbERlbHRhID0gMDtcbiAgdGhpcy5fc2NhbGUgPSBjb25maWcuc2NhbGUgfHwgREVGQVVMVF9TQ0FMRTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRCdXMub24oJ2NhbnZhcy5pbml0JywgZnVuY3Rpb24oZSkge1xuICAgIHNlbGYuX2luaXQoY29uZmlnLmVuYWJsZWQgIT09IGZhbHNlKTtcbiAgfSk7XG59XG5cblpvb21TY3JvbGwuJGluamVjdCA9IFtcbiAgJ2NvbmZpZy56b29tU2Nyb2xsJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcydcbl07XG5cblpvb21TY3JvbGwucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uIHNjcm9sbChkZWx0YSkge1xuICB0aGlzLl9jYW52YXMuc2Nyb2xsKGRlbHRhKTtcbn07XG5cblxuWm9vbVNjcm9sbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgdGhpcy5fY2FudmFzLnpvb20oJ2ZpdC12aWV3cG9ydCcpO1xufTtcblxuLyoqXG4gKiBab29tIGRlcGVuZGluZyBvbiBkZWx0YS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvblxuICovXG5ab29tU2Nyb2xsLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24gem9vbShkZWx0YSwgcG9zaXRpb24pIHtcblxuICAvLyB6b29tIHdpdGggaGFsZiB0aGUgc3RlcCBzaXplIG9mIHN0ZXBab29tXG4gIHZhciBzdGVwU2l6ZSA9IGdldFN0ZXBTaXplKFJBTkdFLCBOVU1fU1RFUFMgKiAyKTtcblxuICAvLyBhZGQgdW50aWwgdGhyZXNob2xkIHJlYWNoZWRcbiAgdGhpcy5fdG90YWxEZWx0YSArPSBkZWx0YTtcblxuICBpZiAoTWF0aC5hYnModGhpcy5fdG90YWxEZWx0YSkgPiBERUxUQV9USFJFU0hPTEQpIHtcbiAgICB0aGlzLl96b29tKGRlbHRhLCBwb3NpdGlvbiwgc3RlcFNpemUpO1xuXG4gICAgLy8gcmVzZXRcbiAgICB0aGlzLl90b3RhbERlbHRhID0gMDtcbiAgfVxufTtcblxuXG5ab29tU2Nyb2xsLnByb3RvdHlwZS5faGFuZGxlV2hlZWwgPSBmdW5jdGlvbiBoYW5kbGVXaGVlbChldmVudCkge1xuXG4gIC8vIGV2ZW50IGlzIGFscmVhZHkgaGFuZGxlZCBieSAnLmRqcy1zY3JvbGxhYmxlJ1xuICBpZiAoZG9tQ2xvc2VzdChldmVudC50YXJnZXQsICcuZGpzLXNjcm9sbGFibGUnLCB0cnVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gdGhpcy5fY29udGFpbmVyO1xuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgLy8gcGluY2ggdG8gem9vbSBpcyBtYXBwZWQgdG8gd2hlZWwgKyBjdHJsS2V5ID0gdHJ1ZVxuICAvLyBpbiBtb2Rlcm4gYnJvd3NlcnMgKCEpXG5cbiAgdmFyIGlzWm9vbSA9IGV2ZW50LmN0cmxLZXk7XG5cbiAgdmFyIGlzSG9yaXpvbnRhbFNjcm9sbCA9IGV2ZW50LnNoaWZ0S2V5O1xuXG4gIHZhciBmYWN0b3IgPSAtMSAqIHRoaXMuX3NjYWxlLFxuICAgICAgZGVsdGE7XG5cbiAgaWYgKGlzWm9vbSkge1xuICAgIGZhY3RvciAqPSBldmVudC5kZWx0YU1vZGUgPT09IDAgPyAwLjAyMCA6IDAuMzI7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yICo9IGV2ZW50LmRlbHRhTW9kZSA9PT0gMCA/IDEuMCA6IDE2LjA7XG4gIH1cblxuICBpZiAoaXNab29tKSB7XG4gICAgdmFyIGVsZW1lbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHZhciBvZmZzZXQgPSB7XG4gICAgICB4OiBldmVudC5jbGllbnRYIC0gZWxlbWVudFJlY3QubGVmdCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSBlbGVtZW50UmVjdC50b3BcbiAgICB9O1xuXG4gICAgZGVsdGEgPSAoXG4gICAgICBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGgucG93KGV2ZW50LmRlbHRhWSwgMikgK1xuICAgICAgICBNYXRoLnBvdyhldmVudC5kZWx0YVgsIDIpXG4gICAgICApICogc2lnbihldmVudC5kZWx0YVkpICogZmFjdG9yXG4gICAgKTtcblxuICAgIC8vIHpvb20gaW4gcmVsYXRpdmUgdG8gZGlhZ3JhbSB7eCx5fSBjb29yZGluYXRlc1xuICAgIHRoaXMuem9vbShkZWx0YSwgb2Zmc2V0KTtcbiAgfSBlbHNlIHtcblxuICAgIGlmIChpc0hvcml6b250YWxTY3JvbGwpIHtcbiAgICAgIGRlbHRhID0ge1xuICAgICAgICBkeDogZmFjdG9yICogZXZlbnQuZGVsdGFZLFxuICAgICAgICBkeTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsdGEgPSB7XG4gICAgICAgIGR4OiBmYWN0b3IgKiBldmVudC5kZWx0YVgsXG4gICAgICAgIGR5OiBmYWN0b3IgKiBldmVudC5kZWx0YVlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGwoZGVsdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIFpvb20gd2l0aCBmaXhlZCBzdGVwIHNpemUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIC0gWm9vbSBkZWx0YSAoMSBmb3Igem9vbWluZyBpbiwgLTEgZm9yIG91dCkuXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25cbiAqL1xuWm9vbVNjcm9sbC5wcm90b3R5cGUuc3RlcFpvb20gPSBmdW5jdGlvbiBzdGVwWm9vbShkZWx0YSwgcG9zaXRpb24pIHtcblxuICB2YXIgc3RlcFNpemUgPSBnZXRTdGVwU2l6ZShSQU5HRSwgTlVNX1NURVBTKTtcblxuICB0aGlzLl96b29tKGRlbHRhLCBwb3NpdGlvbiwgc3RlcFNpemUpO1xufTtcblxuXG4vKipcbiAqIFpvb20gaW4vb3V0IGdpdmVuIGEgc3RlcCBzaXplLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gc3RlcFNpemVcbiAqL1xuWm9vbVNjcm9sbC5wcm90b3R5cGUuX3pvb20gPSBmdW5jdGlvbihkZWx0YSwgcG9zaXRpb24sIHN0ZXBTaXplKSB7XG4gIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cbiAgdmFyIGRpcmVjdGlvbiA9IGRlbHRhID4gMCA/IDEgOiAtMTtcblxuICB2YXIgY3VycmVudExpbmVhclpvb21MZXZlbCA9IGxvZzEwKGNhbnZhcy56b29tKCkpO1xuXG4gIC8vIHNuYXAgdG8gYSBwcm94aW1hdGUgem9vbSBzdGVwXG4gIHZhciBuZXdMaW5lYXJab29tTGV2ZWwgPSBNYXRoLnJvdW5kKGN1cnJlbnRMaW5lYXJab29tTGV2ZWwgLyBzdGVwU2l6ZSkgKiBzdGVwU2l6ZTtcblxuICAvLyBpbmNyZWFzZSBvciBkZWNyZWFzZSBvbmUgem9vbSBzdGVwIGluIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgbmV3TGluZWFyWm9vbUxldmVsICs9IHN0ZXBTaXplICogZGlyZWN0aW9uO1xuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgbG9nYXJpdGhtaWMgem9vbSBsZXZlbCBiYXNlZCBvbiB0aGUgbGluZWFyIHpvb20gbGV2ZWxcbiAgLy8gKGUuZy4gMiBmb3IgYW4gYWJzb2x1dGUgeDIgem9vbSlcbiAgdmFyIG5ld0xvZ1pvb21MZXZlbCA9IE1hdGgucG93KDEwLCBuZXdMaW5lYXJab29tTGV2ZWwpO1xuXG4gIGNhbnZhcy56b29tKGNhcChSQU5HRSwgbmV3TG9nWm9vbUxldmVsKSwgcG9zaXRpb24pO1xufTtcblxuXG4vKipcbiAqIFRvZ2dsZSB0aGUgem9vbSBzY3JvbGwgYWJpbGl0eSB2aWEgbW91c2Ugd2hlZWwuXG4gKlxuICogQHBhcmFtICB7Ym9vbGVhbn0gW25ld0VuYWJsZWRdIG5ldyBlbmFibGVkIHN0YXRlXG4gKi9cblpvb21TY3JvbGwucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZShuZXdFbmFibGVkKSB7XG5cbiAgdmFyIGVsZW1lbnQgPSB0aGlzLl9jb250YWluZXI7XG4gIHZhciBoYW5kbGVXaGVlbCA9IHRoaXMuX2hhbmRsZVdoZWVsO1xuXG4gIHZhciBvbGRFbmFibGVkID0gdGhpcy5fZW5hYmxlZDtcblxuICBpZiAodHlwZW9mIG5ld0VuYWJsZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbmV3RW5hYmxlZCA9ICFvbGRFbmFibGVkO1xuICB9XG5cbiAgLy8gb25seSByZWFjdCBvbiBhY3R1YWwgY2hhbmdlc1xuICBpZiAob2xkRW5hYmxlZCAhPT0gbmV3RW5hYmxlZCkge1xuXG4gICAgLy8gYWRkIG9yIHJlbW92ZSB3aGVlbCBsaXN0ZW5lciBiYXNlZCBvblxuICAgIC8vIGNoYW5nZWQgZW5hYmxlZCBzdGF0ZVxuICAgIGRvbUV2ZW50W25ld0VuYWJsZWQgPyAnYmluZCcgOiAndW5iaW5kJ10oZWxlbWVudCwgJ3doZWVsJywgaGFuZGxlV2hlZWwsIGZhbHNlKTtcbiAgfVxuXG4gIHRoaXMuX2VuYWJsZWQgPSBuZXdFbmFibGVkO1xuXG4gIHJldHVybiBuZXdFbmFibGVkO1xufTtcblxuXG5ab29tU2Nyb2xsLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKG5ld0VuYWJsZWQpIHtcbiAgdGhpcy50b2dnbGUobmV3RW5hYmxlZCk7XG59O1xuIiwiaW1wb3J0IHtcbiAgbG9nMTBcbn0gZnJvbSAnLi4vLi4vdXRpbC9NYXRoJztcblxuLyoqXG4gKiBHZXQgc3RlcCBzaXplIGZvciBnaXZlbiByYW5nZSBhbmQgbnVtYmVyIG9mIHN0ZXBzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlLm1pblxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlLm1heFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RlcFNpemUocmFuZ2UsIHN0ZXBzKSB7XG5cbiAgdmFyIG1pbkxpbmVhclJhbmdlID0gbG9nMTAocmFuZ2UubWluKSxcbiAgICAgIG1heExpbmVhclJhbmdlID0gbG9nMTAocmFuZ2UubWF4KTtcblxuICB2YXIgYWJzb2x1dGVMaW5lYXJSYW5nZSA9IE1hdGguYWJzKG1pbkxpbmVhclJhbmdlKSArIE1hdGguYWJzKG1heExpbmVhclJhbmdlKTtcblxuICByZXR1cm4gYWJzb2x1dGVMaW5lYXJSYW5nZSAvIHN0ZXBzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FwKHJhbmdlLCBzY2FsZSkge1xuICByZXR1cm4gTWF0aC5tYXgocmFuZ2UubWluLCBNYXRoLm1pbihyYW5nZS5tYXgsIHNjYWxlKSk7XG59XG4iLCJpbXBvcnQgWm9vbVNjcm9sbCBmcm9tICcuL1pvb21TY3JvbGwnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICd6b29tU2Nyb2xsJyBdLFxuICB6b29tU2Nyb2xsOiBbICd0eXBlJywgWm9vbVNjcm9sbCBdXG59OyIsImltcG9ydCB7XG4gIGFzVFJCTCxcbiAgZ2V0T3JpZW50YXRpb24sXG4gIHJvdW5kUG9pbnRcbn0gZnJvbSAnLi4vbGF5b3V0L0xheW91dFV0aWwnO1xuXG5pbXBvcnQge1xuICBjZW50ZXIsXG4gIGRlbHRhXG59IGZyb20gJy4vUG9zaXRpb25VdGlsJztcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFic29sdXRlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBuZXcgZWxlbWVudCdzIHBvc2l0aW9uXG4gKlxuICogQHBhcmFtIHtwb2ludH0gcG9pbnQgW2Fic29sdXRlXVxuICogQHBhcmFtIHtib3VuZHN9IG9sZEJvdW5kc1xuICogQHBhcmFtIHtib3VuZHN9IG5ld0JvdW5kc1xuICpcbiAqIEByZXR1cm4ge3BvaW50fSBwb2ludCBbYWJzb2x1dGVdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXdBdHRhY2hQb2ludChwb2ludCwgb2xkQm91bmRzLCBuZXdCb3VuZHMpIHtcbiAgdmFyIG9sZENlbnRlciA9IGNlbnRlcihvbGRCb3VuZHMpLFxuICAgICAgbmV3Q2VudGVyID0gY2VudGVyKG5ld0JvdW5kcyksXG4gICAgICBvbGREZWx0YSA9IGRlbHRhKHBvaW50LCBvbGRDZW50ZXIpO1xuXG4gIHZhciBuZXdEZWx0YSA9IHtcbiAgICB4OiBvbGREZWx0YS54ICogKG5ld0JvdW5kcy53aWR0aCAvIG9sZEJvdW5kcy53aWR0aCksXG4gICAgeTogb2xkRGVsdGEueSAqIChuZXdCb3VuZHMuaGVpZ2h0IC8gb2xkQm91bmRzLmhlaWdodClcbiAgfTtcblxuICByZXR1cm4gcm91bmRQb2ludCh7XG4gICAgeDogbmV3Q2VudGVyLnggKyBuZXdEZWx0YS54LFxuICAgIHk6IG5ld0NlbnRlci55ICsgbmV3RGVsdGEueVxuICB9KTtcbn1cblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNoYXBlJ3MgZGVsdGEgcmVsYXRpdmUgdG8gYSBuZXcgcG9zaXRpb25cbiAqIG9mIGEgY2VydGFpbiBlbGVtZW50J3MgYm91bmRzXG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuU2hhcGV9IHBvaW50IFthYnNvbHV0ZV1cbiAqIEBwYXJhbSB7Ym91bmRzfSBvbGRCb3VuZHNcbiAqIEBwYXJhbSB7Ym91bmRzfSBuZXdCb3VuZHNcbiAqXG4gKiBAcmV0dXJuIHtkZWx0YX0gZGVsdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5ld0F0dGFjaFNoYXBlRGVsdGEoc2hhcGUsIG9sZEJvdW5kcywgbmV3Qm91bmRzKSB7XG4gIHZhciBzaGFwZUNlbnRlciA9IGNlbnRlcihzaGFwZSksXG4gICAgICBvbGRDZW50ZXIgPSBjZW50ZXIob2xkQm91bmRzKSxcbiAgICAgIG5ld0NlbnRlciA9IGNlbnRlcihuZXdCb3VuZHMpLFxuICAgICAgc2hhcGVEZWx0YSA9IGRlbHRhKHNoYXBlLCBzaGFwZUNlbnRlciksXG4gICAgICBvbGRDZW50ZXJEZWx0YSA9IGRlbHRhKHNoYXBlQ2VudGVyLCBvbGRDZW50ZXIpLFxuICAgICAgc3RpY2t5UG9zaXRpb25EZWx0YSA9IGdldFN0aWNreVBvc2l0aW9uRGVsdGEoc2hhcGVDZW50ZXIsIG9sZEJvdW5kcywgbmV3Qm91bmRzKTtcblxuICBpZiAoc3RpY2t5UG9zaXRpb25EZWx0YSkge1xuICAgIHJldHVybiBzdGlja3lQb3NpdGlvbkRlbHRhO1xuICB9XG5cbiAgdmFyIG5ld0NlbnRlckRlbHRhID0ge1xuICAgIHg6IG9sZENlbnRlckRlbHRhLnggKiAobmV3Qm91bmRzLndpZHRoIC8gb2xkQm91bmRzLndpZHRoKSxcbiAgICB5OiBvbGRDZW50ZXJEZWx0YS55ICogKG5ld0JvdW5kcy5oZWlnaHQgLyBvbGRCb3VuZHMuaGVpZ2h0KVxuICB9O1xuXG4gIHZhciBuZXdTaGFwZUNlbnRlciA9IHtcbiAgICB4OiBuZXdDZW50ZXIueCArIG5ld0NlbnRlckRlbHRhLngsXG4gICAgeTogbmV3Q2VudGVyLnkgKyBuZXdDZW50ZXJEZWx0YS55XG4gIH07XG5cbiAgcmV0dXJuIHJvdW5kUG9pbnQoe1xuICAgIHg6IG5ld1NoYXBlQ2VudGVyLnggKyBzaGFwZURlbHRhLnggLSBzaGFwZS54LFxuICAgIHk6IG5ld1NoYXBlQ2VudGVyLnkgKyBzaGFwZURlbHRhLnkgLSBzaGFwZS55XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTdGlja3lQb3NpdGlvbkRlbHRhKG9sZFNoYXBlQ2VudGVyLCBvbGRCb3VuZHMsIG5ld0JvdW5kcykge1xuICB2YXIgb2xkVFJCTCA9IGFzVFJCTChvbGRCb3VuZHMpLFxuICAgICAgbmV3VFJCTCA9IGFzVFJCTChuZXdCb3VuZHMpO1xuXG4gIGlmIChpc01vdmVkKG9sZFRSQkwsIG5ld1RSQkwpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgb2xkT3JpZW50YXRpb24gPSBnZXRPcmllbnRhdGlvbihvbGRCb3VuZHMsIG9sZFNoYXBlQ2VudGVyKSxcbiAgICAgIHN0aWNreVBvc2l0aW9uRGVsdGEsXG4gICAgICBuZXdTaGFwZUNlbnRlcixcbiAgICAgIG5ld09yaWVudGF0aW9uO1xuXG4gIGlmIChvbGRPcmllbnRhdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICBzdGlja3lQb3NpdGlvbkRlbHRhID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IG5ld1RSQkwuYm90dG9tIC0gb2xkVFJCTC5ib3R0b21cbiAgICB9O1xuICB9IGVsc2UgaWYgKG9sZE9yaWVudGF0aW9uID09PSAnYm90dG9tJykge1xuICAgIHN0aWNreVBvc2l0aW9uRGVsdGEgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogbmV3VFJCTC50b3AgLSBvbGRUUkJMLnRvcFxuICAgIH07XG4gIH0gZWxzZSBpZiAob2xkT3JpZW50YXRpb24gPT09ICdyaWdodCcpIHtcbiAgICBzdGlja3lQb3NpdGlvbkRlbHRhID0ge1xuICAgICAgeDogbmV3VFJCTC5sZWZ0IC0gb2xkVFJCTC5sZWZ0LFxuICAgICAgeTogMFxuICAgIH07XG4gIH0gZWxzZSBpZiAob2xkT3JpZW50YXRpb24gPT09ICdsZWZ0Jykge1xuICAgIHN0aWNreVBvc2l0aW9uRGVsdGEgPSB7XG4gICAgICB4OiBuZXdUUkJMLnJpZ2h0IC0gb2xkVFJCTC5yaWdodCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuXG4gICAgLy8gZmFsbGJhY2sgdG8gcHJvcG9ydGlvbmFsIG1vdmVtZW50IGZvciBjb3JuZXItcGxhY2VkIGF0dGFjaG1lbnRzXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuZXdTaGFwZUNlbnRlciA9IHtcbiAgICB4OiBvbGRTaGFwZUNlbnRlci54ICsgc3RpY2t5UG9zaXRpb25EZWx0YS54LFxuICAgIHk6IG9sZFNoYXBlQ2VudGVyLnkgKyBzdGlja3lQb3NpdGlvbkRlbHRhLnlcbiAgfTtcblxuICBuZXdPcmllbnRhdGlvbiA9IGdldE9yaWVudGF0aW9uKG5ld0JvdW5kcywgbmV3U2hhcGVDZW50ZXIpO1xuXG4gIGlmIChuZXdPcmllbnRhdGlvbiAhPT0gb2xkT3JpZW50YXRpb24pIHtcblxuICAgIC8vIGZhbGxiYWNrIHRvIHByb3BvcnRpb25hbCBtb3ZlbWVudCBpZiBvcmllbnRhdGlvbiB3b3VsZCBvdGhlcndpc2UgY2hhbmdlXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gc3RpY2t5UG9zaXRpb25EZWx0YTtcbn1cblxuZnVuY3Rpb24gaXNNb3ZlZChvbGRUUkJMLCBuZXdUUkJMKSB7XG4gIHJldHVybiBpc0hvcml6b250YWxseU1vdmVkKG9sZFRSQkwsIG5ld1RSQkwpIHx8IGlzVmVydGljYWxseU1vdmVkKG9sZFRSQkwsIG5ld1RSQkwpO1xufVxuXG5mdW5jdGlvbiBpc0hvcml6b250YWxseU1vdmVkKG9sZFRSQkwsIG5ld1RSQkwpIHtcbiAgcmV0dXJuIG9sZFRSQkwucmlnaHQgIT09IG5ld1RSQkwucmlnaHQgJiYgb2xkVFJCTC5sZWZ0ICE9PSBuZXdUUkJMLmxlZnQ7XG59XG5cbmZ1bmN0aW9uIGlzVmVydGljYWxseU1vdmVkKG9sZFRSQkwsIG5ld1RSQkwpIHtcbiAgcmV0dXJuIG9sZFRSQkwudG9wICE9PSBuZXdUUkJMLnRvcCAmJiBvbGRUUkJMLmJvdHRvbSAhPT0gbmV3VFJCTC5ib3R0b207XG59XG4iLCJ2YXIgVFJBUF9QUklPUklUWSA9IDUwMDA7XG5cbi8qKlxuICogSW5zdGFsbHMgYSBjbGljayB0cmFwIHRoYXQgcHJldmVudHMgYSBnaG9zdCBjbGljayBmb2xsb3dpbmcgYSBkcmFnZ2luZyBvcGVyYXRpb24uXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdG8gaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBpbnN0YWxsZWQgdHJhcC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwoZXZlbnRCdXMsIGV2ZW50TmFtZSkge1xuXG4gIGV2ZW50TmFtZSA9IGV2ZW50TmFtZSB8fCAnZWxlbWVudC5jbGljayc7XG5cbiAgZnVuY3Rpb24gdHJhcCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBldmVudEJ1cy5vbmNlKGV2ZW50TmFtZSwgVFJBUF9QUklPUklUWSwgdHJhcCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGV2ZW50QnVzLm9mZihldmVudE5hbWUsIHRyYXApO1xuICB9O1xufSIsIi8qKlxuICogRmFpbHNhZmUgcmVtb3ZlIGFuIGVsZW1lbnQgZnJvbSBhIGNvbGxlY3Rpb25cbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxPYmplY3Q+fSBbY29sbGVjdGlvbl1cbiAqIEBwYXJhbSAge09iamVjdH0gW2VsZW1lbnRdXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgcHJldmlvdXMgaW5kZXggb2YgdGhlIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShjb2xsZWN0aW9uLCBlbGVtZW50KSB7XG5cbiAgaWYgKCFjb2xsZWN0aW9uIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIGlkeCA9IGNvbGxlY3Rpb24uaW5kZXhPZihlbGVtZW50KTtcblxuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIGNvbGxlY3Rpb24uc3BsaWNlKGlkeCwgMSk7XG4gIH1cblxuICByZXR1cm4gaWR4O1xufVxuXG4vKipcbiAqIEZhaWwgc2F2ZSBhZGQgYW4gZWxlbWVudCB0byB0aGUgZ2l2ZW4gY29ubmVjdGlvbiwgZW5zdXJpbmdcbiAqIGl0IGRvZXMgbm90IHlldCBleGlzdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY29sbGVjdGlvbiwgZWxlbWVudCwgaWR4KSB7XG5cbiAgaWYgKCFjb2xsZWN0aW9uIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKSB7XG4gICAgaWR4ID0gLTE7XG4gIH1cblxuICB2YXIgY3VycmVudElkeCA9IGNvbGxlY3Rpb24uaW5kZXhPZihlbGVtZW50KTtcblxuICBpZiAoY3VycmVudElkeCAhPT0gLTEpIHtcblxuICAgIGlmIChjdXJyZW50SWR4ID09PSBpZHgpIHtcblxuICAgICAgLy8gbm90aGluZyB0byBkbywgcG9zaXRpb24gaGFzIG5vdCBjaGFuZ2VkXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcblxuICAgICAgICAvLyByZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgIGNvbGxlY3Rpb24uc3BsaWNlKGN1cnJlbnRJZHgsIDEpO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBhbHJlYWR5IGV4aXN0cyBpbiBjb2xsZWN0aW9uXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaWR4ICE9PSAtMSkge1xuXG4gICAgLy8gaW5zZXJ0IGF0IHNwZWNpZmllZCBwb3NpdGlvblxuICAgIGNvbGxlY3Rpb24uc3BsaWNlKGlkeCwgMCwgZWxlbWVudCk7XG4gIH0gZWxzZSB7XG5cbiAgICAvLyBwdXNoIHRvIGVuZFxuICAgIGNvbGxlY3Rpb24ucHVzaChlbGVtZW50KTtcbiAgfVxufVxuXG5cbi8qKlxuICogRmFpbCBzYXZlIGdldCB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9yIC0xIGlmIGNvbGxlY3Rpb24gb3IgZWxlbWVudCBkb1xuICogICAgICAgICAgICAgICAgICBub3QgZXhpc3Qgb3IgdGhlIGVsZW1lbnQgaXMgbm90IGNvbnRhaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoY29sbGVjdGlvbiwgZWxlbWVudCkge1xuXG4gIGlmICghY29sbGVjdGlvbiB8fCAhZWxlbWVudCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiBjb2xsZWN0aW9uLmluZGV4T2YoZWxlbWVudCk7XG59XG4iLCJpbXBvcnQge1xuICBjbGFzc2VzIGFzIGRvbUNsYXNzZXNcbn0gZnJvbSAnbWluLWRvbSc7XG5cbnZhciBDVVJTT1JfQ0xTX1BBVFRFUk4gPSAvXmRqcy1jdXJzb3ItLiokLztcblxuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG1vZGUpIHtcbiAgdmFyIGNsYXNzZXMgPSBkb21DbGFzc2VzKGRvY3VtZW50LmJvZHkpO1xuXG4gIGNsYXNzZXMucmVtb3ZlTWF0Y2hpbmcoQ1VSU09SX0NMU19QQVRURVJOKTtcblxuICBpZiAobW9kZSkge1xuICAgIGNsYXNzZXMuYWRkKCdkanMtY3Vyc29yLScgKyBtb2RlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5zZXQoKSB7XG4gIHNldChudWxsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhcyhtb2RlKSB7XG4gIHZhciBjbGFzc2VzID0gZG9tQ2xhc3Nlcyhkb2N1bWVudC5ib2R5KTtcblxuICByZXR1cm4gY2xhc3Nlcy5oYXMoJ2Rqcy1jdXJzb3ItJyArIG1vZGUpO1xufVxuIiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmaWx0ZXIsXG4gIGZpbmQsXG4gIGlzQXJyYXksXG4gIGlzTnVtYmVyLFxuICBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQsXG4gIGdyb3VwQnksXG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbi8qKlxuICogR2V0IHBhcmVudCBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGRqcy5tb2RlbC5iYXNlPn0gZWxlbWVudHNcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50cyhlbGVtZW50cykge1xuXG4gIC8vIGZpbmQgZWxlbWVudHMgdGhhdCBhcmUgbm90IGNoaWxkcmVuIG9mIGFueSBvdGhlciBlbGVtZW50c1xuICByZXR1cm4gZmlsdGVyKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuICFmaW5kKGVsZW1lbnRzLCBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gZSAhPT0gZWxlbWVudCAmJiBnZXRQYXJlbnQoZWxlbWVudCwgZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbmZ1bmN0aW9uIGdldFBhcmVudChlbGVtZW50LCBwYXJlbnQpIHtcbiAgaWYgKCFwYXJlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWxlbWVudCA9PT0gcGFyZW50KSB7XG4gICAgcmV0dXJuIHBhcmVudDtcbiAgfVxuXG4gIGlmICghZWxlbWVudC5wYXJlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gZ2V0UGFyZW50KGVsZW1lbnQucGFyZW50LCBwYXJlbnQpO1xufVxuXG5cbi8qKlxuICogQWRkcyBhbiBlbGVtZW50IHRvIGEgY29sbGVjdGlvbiBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZVxuICogZWxlbWVudCB3YXMgYWRkZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBlbGVtZW50c1xuICogQHBhcmFtIHtPYmplY3R9IGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdW5pcXVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoZWxlbWVudHMsIGUsIHVuaXF1ZSkge1xuICB2YXIgY2FuQWRkID0gIXVuaXF1ZSB8fCBlbGVtZW50cy5pbmRleE9mKGUpID09PSAtMTtcblxuICBpZiAoY2FuQWRkKSB7XG4gICAgZWxlbWVudHMucHVzaChlKTtcbiAgfVxuXG4gIHJldHVybiBjYW5BZGQ7XG59XG5cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgY2FsbGluZyB0aGUgaXRlcmF0b3IgZnVuY3Rpb24gYGZuYFxuICogd2l0aCAoZWxlbWVudCwgaW5kZXgsIHJlY3Vyc2lvbkRlcHRoKS5cbiAqXG4gKiBSZWN1cnNlIGludG8gYWxsIGVsZW1lbnRzIHRoYXQgYXJlIHJldHVybmVkIGJ5IGBmbmAuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5PE9iamVjdD59IGVsZW1lbnRzXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gaXRlcmF0b3IgZnVuY3Rpb24gY2FsbGVkIHdpdGggKGVsZW1lbnQsIGluZGV4LCByZWN1cnNpb25EZXB0aClcbiAqIEBwYXJhbSAge251bWJlcn0gW2RlcHRoXSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaEVsZW1lbnQoZWxlbWVudHMsIGZuLCBkZXB0aCkge1xuXG4gIGRlcHRoID0gZGVwdGggfHwgMDtcblxuICBpZiAoIWlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgZWxlbWVudHMgPSBbIGVsZW1lbnRzIF07XG4gIH1cblxuICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihzLCBpKSB7XG4gICAgdmFyIGZpbHRlciA9IGZuKHMsIGksIGRlcHRoKTtcblxuICAgIGlmIChpc0FycmF5KGZpbHRlcikgJiYgZmlsdGVyLmxlbmd0aCkge1xuICAgICAgZWFjaEVsZW1lbnQoZmlsdGVyLCBmbiwgZGVwdGggKyAxKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKlxuICogQ29sbGVjdHMgc2VsZiArIGNoaWxkIGVsZW1lbnRzIHVwIHRvIGEgZ2l2ZW4gZGVwdGggZnJvbSBhIGxpc3Qgb2YgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtICB7ZGpzLm1vZGVsLkJhc2V8QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBlbGVtZW50cyB0aGUgZWxlbWVudHMgdG8gc2VsZWN0IHRoZSBjaGlsZHJlbiBmcm9tXG4gKiBAcGFyYW0gIHtib29sZWFufSB1bmlxdWUgd2hldGhlciB0byByZXR1cm4gYSB1bmlxdWUgcmVzdWx0IHNldCAobm8gZHVwbGljYXRlcylcbiAqIEBwYXJhbSAge251bWJlcn0gbWF4RGVwdGggdGhlIGRlcHRoIHRvIHNlYXJjaCB0aHJvdWdoIG9yIC0xIGZvciBpbmZpbml0ZVxuICpcbiAqIEByZXR1cm4ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZm91bmQgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGZBbmRDaGlsZHJlbihlbGVtZW50cywgdW5pcXVlLCBtYXhEZXB0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBwcm9jZXNzZWRDaGlsZHJlbiA9IFtdO1xuXG4gIGVhY2hFbGVtZW50KGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50LCBpLCBkZXB0aCkge1xuICAgIGFkZChyZXN1bHQsIGVsZW1lbnQsIHVuaXF1ZSk7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuO1xuXG4gICAgLy8gbWF4IHRyYXZlcnNhbCBkZXB0aCBub3QgcmVhY2hlZCB5ZXRcbiAgICBpZiAobWF4RGVwdGggPT09IC0xIHx8IGRlcHRoIDwgbWF4RGVwdGgpIHtcblxuICAgICAgLy8gY2hpbGRyZW4gZXhpc3QgJiYgY2hpbGRyZW4gbm90IHlldCBwcm9jZXNzZWRcbiAgICAgIGlmIChjaGlsZHJlbiAmJiBhZGQocHJvY2Vzc2VkQ2hpbGRyZW4sIGNoaWxkcmVuLCB1bmlxdWUpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHNlbGYgKyBkaXJlY3QgY2hpbGRyZW4gZm9yIGEgbnVtYmVyIG9mIGVsZW1lbnRzXG4gKlxuICogQHBhcmFtICB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBlbGVtZW50cyB0byBxdWVyeVxuICogQHBhcmFtICB7Ym9vbGVhbn0gYWxsb3dEdXBsaWNhdGVzIHRvIGFsbG93IGR1cGxpY2F0ZXMgaW4gdGhlIHJlc3VsdCBzZXRcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59IHRoZSBjb2xsZWN0ZWQgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGZBbmREaXJlY3RDaGlsZHJlbihlbGVtZW50cywgYWxsb3dEdXBsaWNhdGVzKSB7XG4gIHJldHVybiBzZWxmQW5kQ2hpbGRyZW4oZWxlbWVudHMsICFhbGxvd0R1cGxpY2F0ZXMsIDEpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHNlbGYgKyBBTEwgY2hpbGRyZW4gZm9yIGEgbnVtYmVyIG9mIGVsZW1lbnRzXG4gKlxuICogQHBhcmFtICB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBlbGVtZW50cyB0byBxdWVyeVxuICogQHBhcmFtICB7Ym9vbGVhbn0gYWxsb3dEdXBsaWNhdGVzIHRvIGFsbG93IGR1cGxpY2F0ZXMgaW4gdGhlIHJlc3VsdCBzZXRcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59IHRoZSBjb2xsZWN0ZWQgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGZBbmRBbGxDaGlsZHJlbihlbGVtZW50cywgYWxsb3dEdXBsaWNhdGVzKSB7XG4gIHJldHVybiBzZWxmQW5kQ2hpbGRyZW4oZWxlbWVudHMsICFhbGxvd0R1cGxpY2F0ZXMsIC0xKTtcbn1cblxuXG4vKipcbiAqIEdldHMgdGhlIHRoZSBjbG9zdXJlIGZvciBhbGwgc2VsZWN0ZWQgZWxlbWVudHMsXG4gKiB0aGVpciBlbmNsb3NlZCBjaGlsZHJlbiBhbmQgY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1RvcExldmVsPXRydWVdXG4gKiBAcGFyYW0ge09iamVjdH0gW2V4aXN0aW5nQ2xvc3VyZV1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IG5ld0Nsb3N1cmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENsb3N1cmUoZWxlbWVudHMsIGlzVG9wTGV2ZWwsIGNsb3N1cmUpIHtcblxuICBpZiAoaXNVbmRlZmluZWQoaXNUb3BMZXZlbCkpIHtcbiAgICBpc1RvcExldmVsID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChpc1RvcExldmVsKSkge1xuICAgIGNsb3N1cmUgPSBpc1RvcExldmVsO1xuICAgIGlzVG9wTGV2ZWwgPSB0cnVlO1xuICB9XG5cblxuICBjbG9zdXJlID0gY2xvc3VyZSB8fCB7fTtcblxuICB2YXIgYWxsU2hhcGVzID0gY29weU9iamVjdChjbG9zdXJlLmFsbFNoYXBlcyksXG4gICAgICBhbGxDb25uZWN0aW9ucyA9IGNvcHlPYmplY3QoY2xvc3VyZS5hbGxDb25uZWN0aW9ucyksXG4gICAgICBlbmNsb3NlZEVsZW1lbnRzID0gY29weU9iamVjdChjbG9zdXJlLmVuY2xvc2VkRWxlbWVudHMpLFxuICAgICAgZW5jbG9zZWRDb25uZWN0aW9ucyA9IGNvcHlPYmplY3QoY2xvc3VyZS5lbmNsb3NlZENvbm5lY3Rpb25zKTtcblxuICB2YXIgdG9wTGV2ZWwgPSBjb3B5T2JqZWN0KFxuICAgIGNsb3N1cmUudG9wTGV2ZWwsXG4gICAgaXNUb3BMZXZlbCAmJiBncm91cEJ5KGVsZW1lbnRzLCBmdW5jdGlvbihlKSB7IHJldHVybiBlLmlkOyB9KVxuICApO1xuXG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbihjKSB7XG4gICAgaWYgKHRvcExldmVsW2Muc291cmNlLmlkXSAmJiB0b3BMZXZlbFtjLnRhcmdldC5pZF0pIHtcbiAgICAgIHRvcExldmVsW2MuaWRdID0gWyBjIF07XG4gICAgfVxuXG4gICAgLy8gbm90IGVuY2xvc2VkIGFzIGEgY2hpbGQsIGJ1dCBtYXliZSBsb2dpY2FsbHlcbiAgICAvLyAoY29ubmVjdGluZyB0d28gbW92ZWQgZWxlbWVudHM/KVxuICAgIGlmIChhbGxTaGFwZXNbYy5zb3VyY2UuaWRdICYmIGFsbFNoYXBlc1tjLnRhcmdldC5pZF0pIHtcbiAgICAgIGVuY2xvc2VkQ29ubmVjdGlvbnNbYy5pZF0gPSBlbmNsb3NlZEVsZW1lbnRzW2MuaWRdID0gYztcbiAgICB9XG5cbiAgICBhbGxDb25uZWN0aW9uc1tjLmlkXSA9IGM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVFbGVtZW50KGVsZW1lbnQpIHtcblxuICAgIGVuY2xvc2VkRWxlbWVudHNbZWxlbWVudC5pZF0gPSBlbGVtZW50O1xuXG4gICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG5cbiAgICAgIC8vIHJlbWVtYmVyIGNvbm5lY3Rpb25cbiAgICAgIGVuY2xvc2VkQ29ubmVjdGlvbnNbZWxlbWVudC5pZF0gPSBhbGxDb25uZWN0aW9uc1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gcmVtZW1iZXIgc2hhcGVcbiAgICAgIGFsbFNoYXBlc1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG5cbiAgICAgIC8vIHJlbWVtYmVyIGFsbCBjb25uZWN0aW9uc1xuICAgICAgZm9yRWFjaChlbGVtZW50LmluY29taW5nLCBoYW5kbGVDb25uZWN0aW9uKTtcblxuICAgICAgZm9yRWFjaChlbGVtZW50Lm91dGdvaW5nLCBoYW5kbGVDb25uZWN0aW9uKTtcblxuICAgICAgLy8gcmVjdXJzZSBpbnRvIGNoaWxkcmVuXG4gICAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbjtcbiAgICB9XG4gIH1cblxuICBlYWNoRWxlbWVudChlbGVtZW50cywgaGFuZGxlRWxlbWVudCk7XG5cbiAgcmV0dXJuIHtcbiAgICBhbGxTaGFwZXM6IGFsbFNoYXBlcyxcbiAgICBhbGxDb25uZWN0aW9uczogYWxsQ29ubmVjdGlvbnMsXG4gICAgdG9wTGV2ZWw6IHRvcExldmVsLFxuICAgIGVuY2xvc2VkQ29ubmVjdGlvbnM6IGVuY2xvc2VkQ29ubmVjdGlvbnMsXG4gICAgZW5jbG9zZWRFbGVtZW50czogZW5jbG9zZWRFbGVtZW50c1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN1cnJvdW5kaW5nIGJib3ggZm9yIGFsbCBlbGVtZW50cyBpblxuICogdGhlIGFycmF5IG9yIHRoZSBlbGVtZW50IHByaW1pdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGRqcy5tb2RlbC5TaGFwZT58ZGpzLm1vZGVsLlNoYXBlfSBlbGVtZW50c1xuICogQHBhcmFtIHtib29sZWFufSBzdG9wUmVjdXJzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCQm94KGVsZW1lbnRzLCBzdG9wUmVjdXJzaW9uKSB7XG5cbiAgc3RvcFJlY3Vyc2lvbiA9ICEhc3RvcFJlY3Vyc2lvbjtcbiAgaWYgKCFpc0FycmF5KGVsZW1lbnRzKSkge1xuICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcbiAgfVxuXG4gIHZhciBtaW5YLFxuICAgICAgbWluWSxcbiAgICAgIG1heFgsXG4gICAgICBtYXhZO1xuXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgIC8vIElmIGVsZW1lbnQgaXMgYSBjb25uZWN0aW9uIHRoZSBiYm94IG11c3QgYmUgY29tcHV0ZWQgZmlyc3RcbiAgICB2YXIgYmJveCA9IGVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzICYmICFzdG9wUmVjdXJzaW9uKSB7XG4gICAgICBiYm94ID0gZ2V0QkJveChlbGVtZW50LndheXBvaW50cywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHggPSBiYm94LngsXG4gICAgICAgIHkgPSBiYm94LnksXG4gICAgICAgIGhlaWdodCA9IGJib3guaGVpZ2h0IHx8IDAsXG4gICAgICAgIHdpZHRoID0gYmJveC53aWR0aCB8fCAwO1xuXG4gICAgaWYgKHggPCBtaW5YIHx8IG1pblggPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluWCA9IHg7XG4gICAgfVxuICAgIGlmICh5IDwgbWluWSB8fCBtaW5ZID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pblkgPSB5O1xuICAgIH1cblxuICAgIGlmICgoeCArIHdpZHRoKSA+IG1heFggfHwgbWF4WCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtYXhYID0geCArIHdpZHRoO1xuICAgIH1cbiAgICBpZiAoKHkgKyBoZWlnaHQpID4gbWF4WSB8fCBtYXhZID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1heFkgPSB5ICsgaGVpZ2h0O1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBtaW5YLFxuICAgIHk6IG1pblksXG4gICAgaGVpZ2h0OiBtYXhZIC0gbWluWSxcbiAgICB3aWR0aDogbWF4WCAtIG1pblhcbiAgfTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgYWxsIGVsZW1lbnRzIHRoYXQgYXJlIGVuY2xvc2VkIGZyb20gdGhlIGJvdW5kaW5nIGJveC5cbiAqXG4gKiAgICogSWYgYmJveC4od2lkdGh8aGVpZ2h0KSBpcyBub3Qgc3BlY2lmaWVkIHRoZSBtZXRob2QgcmV0dXJuc1xuICogICAgIGFsbCBlbGVtZW50cyB3aXRoIGVsZW1lbnQueC95ID4gYmJveC54L3lcbiAqICAgKiBJZiBvbmx5IGJib3gueCBvciBiYm94LnkgaXMgc3BlY2lmaWVkLCBtZXRob2QgcmV0dXJuIGFsbCBlbGVtZW50cyB3aXRoXG4gKiAgICAgZS54ID4gYmJveC54IG9yIGUueSA+IGJib3gueVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLlNoYXBlPn0gZWxlbWVudHMgTGlzdCBvZiBFbGVtZW50cyB0byBzZWFyY2ggdGhyb3VnaFxuICogQHBhcmFtIHtkanMubW9kZWwuU2hhcGV9IGJib3ggdGhlIGVuY2xvc2luZyBiYm94LlxuICpcbiAqIEByZXR1cm4ge0FycmF5PGRqcy5tb2RlbC5TaGFwZT59IGVuY2xvc2VkIGVsZW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbmNsb3NlZEVsZW1lbnRzKGVsZW1lbnRzLCBiYm94KSB7XG5cbiAgdmFyIGZpbHRlcmVkRWxlbWVudHMgPSB7fTtcblxuICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICB2YXIgZSA9IGVsZW1lbnQ7XG5cbiAgICBpZiAoZS53YXlwb2ludHMpIHtcbiAgICAgIGUgPSBnZXRCQm94KGUpO1xuICAgIH1cblxuICAgIGlmICghaXNOdW1iZXIoYmJveC55KSAmJiAoZS54ID4gYmJveC54KSkge1xuICAgICAgZmlsdGVyZWRFbGVtZW50c1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIGlmICghaXNOdW1iZXIoYmJveC54KSAmJiAoZS55ID4gYmJveC55KSkge1xuICAgICAgZmlsdGVyZWRFbGVtZW50c1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIGlmIChlLnggPiBiYm94LnggJiYgZS55ID4gYmJveC55KSB7XG4gICAgICBpZiAoaXNOdW1iZXIoYmJveC53aWR0aCkgJiYgaXNOdW1iZXIoYmJveC5oZWlnaHQpICYmXG4gICAgICAgICAgZS53aWR0aCArIGUueCA8IGJib3gud2lkdGggKyBiYm94LnggJiZcbiAgICAgICAgICBlLmhlaWdodCArIGUueSA8IGJib3guaGVpZ2h0ICsgYmJveC55KSB7XG5cbiAgICAgICAgZmlsdGVyZWRFbGVtZW50c1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKCFpc051bWJlcihiYm94LndpZHRoKSB8fCAhaXNOdW1iZXIoYmJveC5oZWlnaHQpKSB7XG4gICAgICAgIGZpbHRlcmVkRWxlbWVudHNbZWxlbWVudC5pZF0gPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZpbHRlcmVkRWxlbWVudHM7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGUoZWxlbWVudCkge1xuXG4gIGlmICgnd2F5cG9pbnRzJyBpbiBlbGVtZW50KSB7XG4gICAgcmV0dXJuICdjb25uZWN0aW9uJztcbiAgfVxuXG4gIGlmICgneCcgaW4gZWxlbWVudCkge1xuICAgIHJldHVybiAnc2hhcGUnO1xuICB9XG5cbiAgcmV0dXJuICdyb290Jztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRnJhbWVFbGVtZW50KGVsZW1lbnQpIHtcblxuICByZXR1cm4gISEoZWxlbWVudCAmJiBlbGVtZW50LmlzRnJhbWUpO1xufVxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gY29weU9iamVjdChzcmMxLCBzcmMyKSB7XG4gIHJldHVybiBhc3NpZ24oe30sIHNyYzEgfHwge30sIHNyYzIgfHwge30pO1xufSIsImZ1bmN0aW9uIF9fc3RvcFByb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIGlmICghZXZlbnQgfHwgdHlwZW9mIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmlnaW5hbChldmVudCkge1xuICByZXR1cm4gZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudC5zcmNFdmVudDtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2ZW50LCBpbW1lZGlhdGUpIHtcbiAgX19zdG9wUHJvcGFnYXRpb24oZXZlbnQsIGltbWVkaWF0ZSk7XG4gIF9fc3RvcFByb3BhZ2F0aW9uKGdldE9yaWdpbmFsKGV2ZW50KSwgaW1tZWRpYXRlKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdG9Qb2ludChldmVudCkge1xuXG4gIGlmIChldmVudC5wb2ludGVycyAmJiBldmVudC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICBldmVudCA9IGV2ZW50LnBvaW50ZXJzWzBdO1xuICB9XG5cbiAgaWYgKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcbiAgICBldmVudCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gIH1cblxuICByZXR1cm4gZXZlbnQgPyB7XG4gICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICB5OiBldmVudC5jbGllbnRZXG4gIH0gOiBudWxsO1xufSIsImltcG9ydCB7XG4gIGV2ZXJ5LFxuICBpc0FycmF5XG59IGZyb20gJ21pbi1kYXNoJztcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKlxuICogQHBhcmFtICB7UG9pbnR9ICBwXG4gKiBAcGFyYW0gIHtQb2ludH0gIHFcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICBkaXN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9pbnREaXN0YW5jZShhLCBiKSB7XG4gIGlmICghYSB8fCAhYikge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoXG4gICAgTWF0aC5wb3coYS54IC0gYi54LCAyKSArXG4gICAgTWF0aC5wb3coYS55IC0gYi55LCAyKVxuICApO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCByIGlzIG9uIHRoZSBsaW5lIGJldHdlZW4gcCBhbmQgcVxuICpcbiAqIEBwYXJhbSAge1BvaW50fSAgcFxuICogQHBhcmFtICB7UG9pbnR9ICBxXG4gKiBAcGFyYW0gIHtQb2ludH0gIHJcbiAqIEBwYXJhbSAge251bWJlcn0gW2FjY3VyYWN5PTVdIGFjY3VyYWN5IGZvciBwb2ludHMgb24gbGluZSBjaGVjayAobG93ZXIgaXMgYmV0dGVyKVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNPbkxpbmUocCwgcSwgciwgYWNjdXJhY3kpIHtcblxuICBpZiAodHlwZW9mIGFjY3VyYWN5ID09PSAndW5kZWZpbmVkJykge1xuICAgIGFjY3VyYWN5ID0gNTtcbiAgfVxuXG4gIGlmICghcCB8fCAhcSB8fCAhcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB2YWwgPSAocS54IC0gcC54KSAqIChyLnkgLSBwLnkpIC0gKHEueSAtIHAueSkgKiAoci54IC0gcC54KSxcbiAgICAgIGRpc3QgPSBwb2ludERpc3RhbmNlKHAsIHEpO1xuXG4gIC8vIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTA3NDkxLzQxMjE5MFxuICByZXR1cm4gTWF0aC5hYnModmFsIC8gZGlzdCkgPD0gYWNjdXJhY3k7XG59XG5cblxudmFyIEFMSUdORURfVEhSRVNIT0xEID0gMjtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBwb2ludHMgYXJlIGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5IGFsaWduZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD58UG9pbnR9XG4gKiBAcGFyYW0ge1BvaW50fVxuICpcbiAqIEByZXR1cm4ge3N0cmluZ3xib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzQWxpZ25lZChhLCBiKSB7XG4gIHZhciBwb2ludHM7XG5cbiAgaWYgKGlzQXJyYXkoYSkpIHtcbiAgICBwb2ludHMgPSBhO1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IFsgYSwgYiBdO1xuICB9XG5cbiAgaWYgKHBvaW50c0FsaWduZWRIb3Jpem9udGFsbHkocG9pbnRzKSkge1xuICAgIHJldHVybiAnaCc7XG4gIH1cblxuICBpZiAocG9pbnRzQWxpZ25lZFZlcnRpY2FsbHkocG9pbnRzKSkge1xuICAgIHJldHVybiAndic7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNBbGlnbmVkSG9yaXpvbnRhbGx5KGEsIGIpIHtcbiAgdmFyIHBvaW50cztcblxuICBpZiAoaXNBcnJheShhKSkge1xuICAgIHBvaW50cyA9IGE7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gWyBhLCBiIF07XG4gIH1cblxuICB2YXIgZmlyc3RQb2ludCA9IHBvaW50cy5zbGljZSgpLnNoaWZ0KCk7XG5cbiAgcmV0dXJuIGV2ZXJ5KHBvaW50cywgZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoZmlyc3RQb2ludC55IC0gcG9pbnQueSkgPD0gQUxJR05FRF9USFJFU0hPTEQ7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzQWxpZ25lZFZlcnRpY2FsbHkoYSwgYikge1xuICB2YXIgcG9pbnRzO1xuXG4gIGlmIChpc0FycmF5KGEpKSB7XG4gICAgcG9pbnRzID0gYTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBbIGEsIGIgXTtcbiAgfVxuXG4gIHZhciBmaXJzdFBvaW50ID0gcG9pbnRzLnNsaWNlKCkuc2hpZnQoKTtcblxuICByZXR1cm4gZXZlcnkocG9pbnRzLCBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBNYXRoLmFicyhmaXJzdFBvaW50LnggLSBwb2ludC54KSA8PSBBTElHTkVEX1RIUkVTSE9MRDtcbiAgfSk7XG59XG5cblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgcCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZSByZWN0XG4gKlxuICogQHBhcmFtICB7UG9pbnR9ICBwXG4gKiBAcGFyYW0gIHtSZWN0fSByZWN0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRvbGVyYW5jZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludEluUmVjdChwLCByZWN0LCB0b2xlcmFuY2UpIHtcbiAgdG9sZXJhbmNlID0gdG9sZXJhbmNlIHx8IDA7XG5cbiAgcmV0dXJuIHAueCA+IHJlY3QueCAtIHRvbGVyYW5jZSAmJlxuICAgICAgICAgcC55ID4gcmVjdC55IC0gdG9sZXJhbmNlICYmXG4gICAgICAgICBwLnggPCByZWN0LnggKyByZWN0LndpZHRoICsgdG9sZXJhbmNlICYmXG4gICAgICAgICBwLnkgPCByZWN0LnkgKyByZWN0LmhlaWdodCArIHRvbGVyYW5jZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcG9pbnQgaW4gdGhlIG1pZGRsZSBvZiBwb2ludHMgcCBhbmQgcVxuICpcbiAqIEBwYXJhbSAge1BvaW50fSAgcFxuICogQHBhcmFtICB7UG9pbnR9ICBxXG4gKlxuICogQHJldHVybiB7UG9pbnR9IG1pZGRsZSBwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWlkUG9pbnQocCwgcSkge1xuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQocC54ICsgKChxLnggLSBwLngpIC8gMi4wKSksXG4gICAgeTogTWF0aC5yb3VuZChwLnkgKyAoKHEueSAtIHAueSkgLyAyLjApKVxuICB9O1xufVxuIiwiLyoqXG4gKiBTVkdzIGZvciBlbGVtZW50cyBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSB7QGxpbmsgR3JhcGhpY3NGYWN0b3J5fS5cbiAqXG4gKiBUaGlzIHV0aWxpdHkgZ2l2ZXMgcXVpY2sgYWNjZXNzIHRvIHRoZSBpbXBvcnRhbnQgc2VtYW50aWNcbiAqIHBhcnRzIG9mIGFuIGVsZW1lbnQuXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2aXN1YWwgcGFydCBvZiBhIGRpYWdyYW0gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7U25hcDxTVkdFbGVtZW50Pn0gZ2Z4XG4gKlxuICogQHJldHVybiB7U25hcDxTVkdFbGVtZW50Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZpc3VhbChnZngpIHtcbiAgcmV0dXJuIGdmeC5jaGlsZE5vZGVzWzBdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNoaWxkcmVuIGZvciBhIGdpdmVuIGRpYWdyYW0gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1NuYXA8U1ZHRWxlbWVudD59IGdmeFxuICogQHJldHVybiB7U25hcDxTVkdFbGVtZW50Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkcmVuKGdmeCkge1xuICByZXR1cm4gZ2Z4LnBhcmVudE5vZGUuY2hpbGROb2Rlc1sxXTtcbn0iLCIvKipcbiAqIFV0aWwgdGhhdCBwcm92aWRlcyB1bmlxdWUgSURzLlxuICpcbiAqIEBjbGFzcyBkanMudXRpbC5JZEdlbmVyYXRvclxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWVtYmVyT2YgZGpzLnV0aWxcbiAqXG4gKiBUaGUgaWRzIGNhbiBiZSBjdXN0b21pemVkIHZpYSBhIGdpdmVuIHByZWZpeCBhbmQgY29udGFpbiBhIHJhbmRvbSB2YWx1ZSB0byBhdm9pZCBjb2xsaXNpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggYSBwcmVmaXggdG8gcHJlcGVuZCB0byBnZW5lcmF0ZWQgaWRzIChmb3IgYmV0dGVyIHJlYWRhYmlsaXR5KVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJZEdlbmVyYXRvcihwcmVmaXgpIHtcblxuICB0aGlzLl9jb3VudGVyID0gMDtcbiAgdGhpcy5fcHJlZml4ID0gKHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnKSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDApICsgJy0nO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXh0IHVuaXF1ZSBJRC5cbiAqXG4gKiBAbWV0aG9kIGRqcy51dGlsLklkR2VuZXJhdG9yI25leHRcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgaWRcbiAqL1xuSWRHZW5lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3ByZWZpeCArICgrK3RoaXMuX2NvdW50ZXIpO1xufTtcbiIsImltcG9ydCB7XG4gIHBvaW50RGlzdGFuY2Vcbn0gZnJvbSAnLi9HZW9tZXRyeSc7XG5cbmltcG9ydCBpbnRlcnNlY3RQYXRocyBmcm9tICdwYXRoLWludGVyc2VjdGlvbic7XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgbWF4ID0gTWF0aC5tYXg7XG5cblxuZnVuY3Rpb24gY2lyY2xlUGF0aChjZW50ZXIsIHIpIHtcbiAgdmFyIHggPSBjZW50ZXIueCxcbiAgICAgIHkgPSBjZW50ZXIueTtcblxuICByZXR1cm4gW1xuICAgIFsnTScsIHgsIHldLFxuICAgIFsnbScsIDAsIC1yXSxcbiAgICBbJ2EnLCByLCByLCAwLCAxLCAxLCAwLCAyICogcl0sXG4gICAgWydhJywgciwgciwgMCwgMSwgMSwgMCwgLTIgKiByXSxcbiAgICBbJ3onXVxuICBdO1xufVxuXG5mdW5jdGlvbiBsaW5lUGF0aChwb2ludHMpIHtcbiAgdmFyIHNlZ21lbnRzID0gW107XG5cbiAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24ocCwgaWR4KSB7XG4gICAgc2VnbWVudHMucHVzaChbIGlkeCA9PT0gMCA/ICdNJyA6ICdMJywgcC54LCBwLnkgXSk7XG4gIH0pO1xuXG4gIHJldHVybiBzZWdtZW50cztcbn1cblxuXG52YXIgSU5URVJTRUNUSU9OX1RIUkVTSE9MRCA9IDEwO1xuXG5mdW5jdGlvbiBnZXRCZW5kcG9pbnRJbnRlcnNlY3Rpb24od2F5cG9pbnRzLCByZWZlcmVuY2UpIHtcblxuICB2YXIgaSwgdztcblxuICBmb3IgKGkgPSAwOyAodyA9IHdheXBvaW50c1tpXSk7IGkrKykge1xuXG4gICAgaWYgKHBvaW50RGlzdGFuY2UodywgcmVmZXJlbmNlKSA8PSBJTlRFUlNFQ1RJT05fVEhSRVNIT0xEKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogd2F5cG9pbnRzW2ldLFxuICAgICAgICBiZW5kcG9pbnQ6IHRydWUsXG4gICAgICAgIGluZGV4OiBpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRQYXRoSW50ZXJzZWN0aW9uKHdheXBvaW50cywgcmVmZXJlbmNlKSB7XG5cbiAgdmFyIGludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RQYXRocyhjaXJjbGVQYXRoKHJlZmVyZW5jZSwgSU5URVJTRUNUSU9OX1RIUkVTSE9MRCksIGxpbmVQYXRoKHdheXBvaW50cykpO1xuXG4gIHZhciBhID0gaW50ZXJzZWN0aW9uc1swXSxcbiAgICAgIGIgPSBpbnRlcnNlY3Rpb25zW2ludGVyc2VjdGlvbnMubGVuZ3RoIC0gMV0sXG4gICAgICBpZHg7XG5cbiAgaWYgKCFhKSB7XG5cbiAgICAvLyBubyBpbnRlcnNlY3Rpb25cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChhICE9PSBiKSB7XG5cbiAgICBpZiAoYS5zZWdtZW50MiAhPT0gYi5zZWdtZW50Mikge1xuXG4gICAgICAvLyB3ZSB1c2UgdGhlIGJlbmRwb2ludCBpbiBiZXR3ZWVuIGJvdGggc2VnbWVudHNcbiAgICAgIC8vIGFzIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcblxuICAgICAgaWR4ID0gbWF4KGEuc2VnbWVudDIsIGIuc2VnbWVudDIpIC0gMTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQ6IHdheXBvaW50c1tpZHhdLFxuICAgICAgICBiZW5kcG9pbnQ6IHRydWUsXG4gICAgICAgIGluZGV4OiBpZHhcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiB7XG4gICAgICAgIHg6IChyb3VuZChhLnggKyBiLngpIC8gMiksXG4gICAgICAgIHk6IChyb3VuZChhLnkgKyBiLnkpIC8gMilcbiAgICAgIH0sXG4gICAgICBpbmRleDogYS5zZWdtZW50MlxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvaW50OiB7XG4gICAgICB4OiByb3VuZChhLngpLFxuICAgICAgeTogcm91bmQoYS55KVxuICAgIH0sXG4gICAgaW5kZXg6IGEuc2VnbWVudDJcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBjb25uZWN0aW9uIHRvd2FyZHMgYSBnaXZlbiByZWZlcmVuY2UgcG9pbnQuXG4gKlxuICogQHBhcmFtICB7QXJyYXk8UG9pbnQ+fSB3YXlwb2ludHNcbiAqIEBwYXJhbSAge1BvaW50fSByZWZlcmVuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGludGVyc2VjdGlvbiBkYXRhIChzZWdtZW50LCBwb2ludClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFwcHJveEludGVyc2VjdGlvbih3YXlwb2ludHMsIHJlZmVyZW5jZSkge1xuICByZXR1cm4gZ2V0QmVuZHBvaW50SW50ZXJzZWN0aW9uKHdheXBvaW50cywgcmVmZXJlbmNlKSB8fCBnZXRQYXRoSW50ZXJzZWN0aW9uKHdheXBvaW50cywgcmVmZXJlbmNlKTtcbn1cbiIsIi8qKlxuICogR2V0IHRoZSBsb2dhcml0aG0gb2YgeCB3aXRoIGJhc2UgMTBcbiAqIEBwYXJhbSAge0ludGVnZXJ9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGgubG9nKDEwKTtcbn1cblxuZXhwb3J0IHsgZGVsdGEgYXMgc3Vic3RyYWN0IH0gZnJvbSAnLi9Qb3NpdGlvblV0aWwnO1xuIiwiaW1wb3J0IHtcbiAgZ2V0T3JpZ2luYWwgYXMgZ2V0T3JpZ2luYWxFdmVudFxufSBmcm9tICcuL0V2ZW50JztcblxuaW1wb3J0IHtcbiAgaXNNYWNcbn0gZnJvbSAnLi9QbGF0Zm9ybSc7XG5cbmV4cG9ydCB7XG4gIGlzTWFjXG59IGZyb20gJy4vUGxhdGZvcm0nO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNCdXR0b24oZXZlbnQsIGJ1dHRvbikge1xuICByZXR1cm4gKGdldE9yaWdpbmFsRXZlbnQoZXZlbnQpIHx8IGV2ZW50KS5idXR0b24gPT09IGJ1dHRvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJpbWFyeUJ1dHRvbihldmVudCkge1xuXG4gIC8vIGJ1dHRvbiA9PT0gMCAtPiBsZWZ0IMOha2EgcHJpbWFyeSBtb3VzZSBidXR0b25cbiAgcmV0dXJuIGlzQnV0dG9uKGV2ZW50LCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV4aWxpYXJ5QnV0dG9uKGV2ZW50KSB7XG5cbiAgLy8gYnV0dG9uID09PSAxIC0+IGF1eGlsaWFyeSDDoWthIHdoZWVsIGJ1dHRvblxuICByZXR1cm4gaXNCdXR0b24oZXZlbnQsIDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTZWNvbmRhcnlCdXR0b24oZXZlbnQpIHtcblxuICAvLyBidXR0b24gPT09IDIgLT4gcmlnaHQgw6FrYSBzZWNvbmRhcnkgYnV0dG9uXG4gIHJldHVybiBpc0J1dHRvbihldmVudCwgMik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNQcmltYXJ5TW9kaWZpZXIoZXZlbnQpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBnZXRPcmlnaW5hbEV2ZW50KGV2ZW50KSB8fCBldmVudDtcblxuICBpZiAoIWlzUHJpbWFyeUJ1dHRvbihldmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBVc2UgY21kIGFzIHByaW1hcnkgbW9kaWZpZXIga2V5IGZvciBtYWMgT1NcbiAgaWYgKGlzTWFjKCkpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxFdmVudC5tZXRhS2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvcmlnaW5hbEV2ZW50LmN0cmxLZXk7XG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaGFzU2Vjb25kYXJ5TW9kaWZpZXIoZXZlbnQpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBnZXRPcmlnaW5hbEV2ZW50KGV2ZW50KSB8fCBldmVudDtcblxuICByZXR1cm4gaXNQcmltYXJ5QnV0dG9uKGV2ZW50KSAmJiBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzTWFjKCkge1xuICByZXR1cm4gKC9tYWMvaSkudGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xufSIsImV4cG9ydCBmdW5jdGlvbiBjZW50ZXIoYm91bmRzKSB7XG4gIHJldHVybiB7XG4gICAgeDogYm91bmRzLnggKyAoYm91bmRzLndpZHRoIC8gMiksXG4gICAgeTogYm91bmRzLnkgKyAoYm91bmRzLmhlaWdodCAvIDIpXG4gIH07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbHRhKGEsIGIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBhLnggLSBiLngsXG4gICAgeTogYS55IC0gYi55XG4gIH07XG59IiwiLyoqXG4gKiBSZW1vdmUgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGEgY29sbGVjdGlvbiB1bnRpbCBpdCBpcyBlbXB0eS5cbiAqXG4gKiBUaGlzIGlzIGEgbnVsbC1zYWZlIG9wZXJhdGlvbiB0aGF0IGVuc3VyZXMgZWxlbWVudHNcbiAqIGFyZSBiZWluZyByZW1vdmVkIGZyb20gdGhlIGdpdmVuIGNvbGxlY3Rpb24gdW50aWwgdGhlXG4gKiBjb2xsZWN0aW9uIGlzIGVtcHR5LlxuICpcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBkZWFscyB3aXRoIHRoZSBmYWN0IHRoYXQgYSByZW1vdmUgb3BlcmF0aW9uXG4gKiBtYXkgdG91Y2gsIGkuZS4gcmVtb3ZlIG11bHRpcGxlIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uXG4gKiBhdCBhIHRpbWUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBbY29sbGVjdGlvbl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlbW92ZUZuXG4gKlxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gdGhlIGNsZWFyZWQgY29sbGVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUNsZWFyKGNvbGxlY3Rpb24sIHJlbW92ZUZuKSB7XG5cbiAgaWYgKHR5cGVvZiByZW1vdmVGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlRm4gaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZTtcblxuICB3aGlsZSAoKGUgPSBjb2xsZWN0aW9uWzBdKSkge1xuICAgIHJlbW92ZUZuKGUpO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59XG4iLCJpbXBvcnQge1xuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRzVG9QYXRoKGVsZW1lbnRzKSB7XG4gIHJldHVybiBlbGVtZW50cy5qb2luKCcsJykucmVwbGFjZSgvLD8oW0Etel0pLD8vZywgJyQxJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1NWR1BvaW50cyhwb2ludHMpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBwOyAocCA9IHBvaW50c1tpXSk7IGkrKykge1xuICAgIHJlc3VsdCArPSBwLnggKyAnLCcgKyBwLnkgKyAnICc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGluZShwb2ludHMsIGF0dHJzKSB7XG5cbiAgdmFyIGxpbmUgPSBzdmdDcmVhdGUoJ3BvbHlsaW5lJyk7XG4gIHN2Z0F0dHIobGluZSwgeyBwb2ludHM6IHRvU1ZHUG9pbnRzKHBvaW50cykgfSk7XG5cbiAgaWYgKGF0dHJzKSB7XG4gICAgc3ZnQXR0cihsaW5lLCBhdHRycyk7XG4gIH1cblxuICByZXR1cm4gbGluZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUxpbmUoZ2Z4LCBwb2ludHMpIHtcbiAgc3ZnQXR0cihnZngsIHsgcG9pbnRzOiB0b1NWR1BvaW50cyhwb2ludHMpIH0pO1xuXG4gIHJldHVybiBnZng7XG59XG4iLCJpbXBvcnQge1xyXG4gIHRyYW5zZm9ybSBhcyBzdmdUcmFuc2Zvcm0sXHJcbiAgY3JlYXRlVHJhbnNmb3JtXHJcbn0gZnJvbSAndGlueS1zdmcnO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gezxTVkdFbGVtZW50Pn0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge251bWJlcn0geFxyXG4gKiBAcGFyYW0ge251bWJlcn0geVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcclxuICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybShnZngsIHgsIHksIGFuZ2xlLCBhbW91bnQpIHtcclxuICB2YXIgdHJhbnNsYXRlID0gY3JlYXRlVHJhbnNmb3JtKCk7XHJcbiAgdHJhbnNsYXRlLnNldFRyYW5zbGF0ZSh4LCB5KTtcclxuXHJcbiAgdmFyIHJvdGF0ZSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xyXG4gIHJvdGF0ZS5zZXRSb3RhdGUoYW5nbGUgfHwgMCwgMCwgMCk7XHJcblxyXG4gIHZhciBzY2FsZSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xyXG4gIHNjYWxlLnNldFNjYWxlKGFtb3VudCB8fCAxLCBhbW91bnQgfHwgMSk7XHJcblxyXG4gIHN2Z1RyYW5zZm9ybShnZngsIFsgdHJhbnNsYXRlLCByb3RhdGUsIHNjYWxlIF0pO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge251bWJlcn0geFxyXG4gKiBAcGFyYW0ge251bWJlcn0geVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShnZngsIHgsIHkpIHtcclxuICB2YXIgdHJhbnNsYXRlID0gY3JlYXRlVHJhbnNmb3JtKCk7XHJcbiAgdHJhbnNsYXRlLnNldFRyYW5zbGF0ZSh4LCB5KTtcclxuXHJcbiAgc3ZnVHJhbnNmb3JtKGdmeCwgdHJhbnNsYXRlKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKGdmeCwgYW5nbGUpIHtcclxuICB2YXIgcm90YXRlID0gY3JlYXRlVHJhbnNmb3JtKCk7XHJcbiAgcm90YXRlLnNldFJvdGF0ZShhbmdsZSwgMCwgMCk7XHJcblxyXG4gIHN2Z1RyYW5zZm9ybShnZngsIHJvdGF0ZSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShnZngsIGFtb3VudCkge1xyXG4gIHZhciBzY2FsZSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xyXG4gIHNjYWxlLnNldFNjYWxlKGFtb3VudCwgYW1vdW50KTtcclxuXHJcbiAgc3ZnVHJhbnNmb3JtKGdmeCwgc2NhbGUpO1xyXG59IiwiaW1wb3J0IHtcbiAgaXNPYmplY3QsXG4gIGFzc2lnbixcbiAgZm9yRWFjaCxcbiAgcmVkdWNlXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjcmVhdGUgYXMgc3ZnQ3JlYXRlLFxuICByZW1vdmUgYXMgc3ZnUmVtb3ZlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxudmFyIERFRkFVTFRfQk9YX1BBRERJTkcgPSAwO1xuXG52YXIgREVGQVVMVF9MQUJFTF9TSVpFID0ge1xuICB3aWR0aDogMTUwLFxuICBoZWlnaHQ6IDUwXG59O1xuXG5cbmZ1bmN0aW9uIHBhcnNlQWxpZ24oYWxpZ24pIHtcblxuICB2YXIgcGFydHMgPSBhbGlnbi5zcGxpdCgnLScpO1xuXG4gIHJldHVybiB7XG4gICAgaG9yaXpvbnRhbDogcGFydHNbMF0gfHwgJ2NlbnRlcicsXG4gICAgdmVydGljYWw6IHBhcnRzWzFdIHx8ICd0b3AnXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFkZGluZyhwYWRkaW5nKSB7XG5cbiAgaWYgKGlzT2JqZWN0KHBhZGRpbmcpKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7IHRvcDogMCwgbGVmdDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9LCBwYWRkaW5nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBwYWRkaW5nLFxuICAgICAgbGVmdDogcGFkZGluZyxcbiAgICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgICAgYm90dG9tOiBwYWRkaW5nXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUZXh0QkJveCh0ZXh0LCBmYWtlVGV4dCkge1xuXG4gIGZha2VUZXh0LnRleHRDb250ZW50ID0gdGV4dDtcblxuICB2YXIgdGV4dEJCb3g7XG5cbiAgdHJ5IHtcbiAgICB2YXIgYmJveCxcbiAgICAgICAgZW1wdHlMaW5lID0gdGV4dCA9PT0gJyc7XG5cbiAgICAvLyBhZGQgZHVtbXkgdGV4dCwgd2hlbiBsaW5lIGlzIGVtcHR5IHRvXG4gICAgLy8gZGV0ZXJtaW5lIGNvcnJlY3QgaGVpZ2h0XG4gICAgZmFrZVRleHQudGV4dENvbnRlbnQgPSBlbXB0eUxpbmUgPyAnZHVtbXknIDogdGV4dDtcblxuICAgIHRleHRCQm94ID0gZmFrZVRleHQuZ2V0QkJveCgpO1xuXG4gICAgLy8gdGFrZSB0ZXh0IHJlbmRlcmluZyByZWxhdGVkIGhvcml6b250YWxcbiAgICAvLyBwYWRkaW5nIGludG8gYWNjb3VudFxuICAgIGJib3ggPSB7XG4gICAgICB3aWR0aDogdGV4dEJCb3gud2lkdGggKyB0ZXh0QkJveC54ICogMixcbiAgICAgIGhlaWdodDogdGV4dEJCb3guaGVpZ2h0XG4gICAgfTtcblxuICAgIGlmIChlbXB0eUxpbmUpIHtcblxuICAgICAgLy8gY29ycmVjdCB3aWR0aFxuICAgICAgYmJveC53aWR0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJib3g7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gIH1cbn1cblxuXG4vKipcbiAqIExheW91dCB0aGUgbmV4dCBsaW5lIGFuZCByZXR1cm4gdGhlIGxheW91dGVkIGVsZW1lbnQuXG4gKlxuICogQWx0ZXJzIHRoZSBsaW5lcyBwYXNzZWQuXG4gKlxuICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPn0gbGluZXNcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGxpbmUgZGVzY3JpcHRvciwgYW4gb2JqZWN0IHsgd2lkdGgsIGhlaWdodCwgdGV4dCB9XG4gKi9cbmZ1bmN0aW9uIGxheW91dE5leHQobGluZXMsIG1heFdpZHRoLCBmYWtlVGV4dCkge1xuXG4gIHZhciBvcmlnaW5hbExpbmUgPSBsaW5lcy5zaGlmdCgpLFxuICAgICAgZml0TGluZSA9IG9yaWdpbmFsTGluZTtcblxuICB2YXIgdGV4dEJCb3g7XG5cbiAgZm9yICg7Oykge1xuICAgIHRleHRCQm94ID0gZ2V0VGV4dEJCb3goZml0TGluZSwgZmFrZVRleHQpO1xuXG4gICAgdGV4dEJCb3gud2lkdGggPSBmaXRMaW5lID8gdGV4dEJCb3gud2lkdGggOiAwO1xuXG4gICAgLy8gdHJ5IHRvIGZpdFxuICAgIGlmIChmaXRMaW5lID09PSAnICcgfHwgZml0TGluZSA9PT0gJycgfHwgdGV4dEJCb3gud2lkdGggPCBNYXRoLnJvdW5kKG1heFdpZHRoKSB8fCBmaXRMaW5lLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBmaXQobGluZXMsIGZpdExpbmUsIG9yaWdpbmFsTGluZSwgdGV4dEJCb3gpO1xuICAgIH1cblxuICAgIGZpdExpbmUgPSBzaG9ydGVuTGluZShmaXRMaW5lLCB0ZXh0QkJveC53aWR0aCwgbWF4V2lkdGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpdChsaW5lcywgZml0TGluZSwgb3JpZ2luYWxMaW5lLCB0ZXh0QkJveCkge1xuICBpZiAoZml0TGluZS5sZW5ndGggPCBvcmlnaW5hbExpbmUubGVuZ3RoKSB7XG4gICAgdmFyIHJlbWFpbmRlciA9IG9yaWdpbmFsTGluZS5zbGljZShmaXRMaW5lLmxlbmd0aCkudHJpbSgpO1xuXG4gICAgbGluZXMudW5zaGlmdChyZW1haW5kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogdGV4dEJCb3gud2lkdGgsXG4gICAgaGVpZ2h0OiB0ZXh0QkJveC5oZWlnaHQsXG4gICAgdGV4dDogZml0TGluZVxuICB9O1xufVxuXG52YXIgU09GVF9CUkVBSyA9ICdcXHUwMEFEJztcblxuXG4vKipcbiAqIFNob3J0ZW5zIGEgbGluZSBiYXNlZCBvbiBzcGFjaW5nIGFuZCBoeXBoZW5zLlxuICogUmV0dXJucyB0aGUgc2hvcnRlbmVkIHJlc3VsdCBvbiBzdWNjZXNzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbGluZVxuICogQHBhcmFtICB7bnVtYmVyfSBtYXhMZW5ndGggdGhlIG1heGltdW0gY2hhcmFjdGVycyBvZiB0aGUgc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBzaG9ydGVuZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHNlbWFudGljU2hvcnRlbihsaW5lLCBtYXhMZW5ndGgpIHtcblxuICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KC8oXFxzfC18XFx1MDBBRCkvZyksXG4gICAgICBwYXJ0LFxuICAgICAgc2hvcnRlbmVkUGFydHMgPSBbXSxcbiAgICAgIGxlbmd0aCA9IDA7XG5cbiAgLy8gdHJ5IHRvIHNob3J0ZW4gdmlhIGJyZWFrIGNoYXJzXG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cbiAgICB3aGlsZSAoKHBhcnQgPSBwYXJ0cy5zaGlmdCgpKSkge1xuICAgICAgaWYgKHBhcnQubGVuZ3RoICsgbGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHNob3J0ZW5lZFBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIGxlbmd0aCArPSBwYXJ0Lmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHByZXZpb3VzIHBhcnQsIHRvbyBpZiBoeXBoZW4gZG9lcyBub3QgZml0IGFueW1vcmVcbiAgICAgICAgaWYgKHBhcnQgPT09ICctJyB8fCBwYXJ0ID09PSBTT0ZUX0JSRUFLKSB7XG4gICAgICAgICAgc2hvcnRlbmVkUGFydHMucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbGFzdCA9IHNob3J0ZW5lZFBhcnRzW3Nob3J0ZW5lZFBhcnRzLmxlbmd0aCAtIDFdO1xuXG4gIC8vIHRyYW5zbGF0ZSB0cmFpbGluZyBzb2Z0IGJyZWFrIHRvIGFjdHVhbCBoeXBoZW5cbiAgaWYgKGxhc3QgJiYgbGFzdCA9PT0gU09GVF9CUkVBSykge1xuICAgIHNob3J0ZW5lZFBhcnRzW3Nob3J0ZW5lZFBhcnRzLmxlbmd0aCAtIDFdID0gJy0nO1xuICB9XG5cbiAgcmV0dXJuIHNob3J0ZW5lZFBhcnRzLmpvaW4oJycpO1xufVxuXG5cbmZ1bmN0aW9uIHNob3J0ZW5MaW5lKGxpbmUsIHdpZHRoLCBtYXhXaWR0aCkge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgobGluZS5sZW5ndGggKiAobWF4V2lkdGggLyB3aWR0aCksIDEpO1xuXG4gIC8vIHRyeSB0byBzaG9ydGVuIHNlbWFudGljYWxseSAoaS5lLiBiYXNlZCBvbiBzcGFjZXMgYW5kIGh5cGhlbnMpXG4gIHZhciBzaG9ydGVuZWRMaW5lID0gc2VtYW50aWNTaG9ydGVuKGxpbmUsIGxlbmd0aCk7XG5cbiAgaWYgKCFzaG9ydGVuZWRMaW5lKSB7XG5cbiAgICAvLyBmb3JjZSBzaG9ydGVuIGJ5IGN1dHRpbmcgdGhlIGxvbmcgd29yZFxuICAgIHNob3J0ZW5lZExpbmUgPSBsaW5lLnNsaWNlKDAsIE1hdGgubWF4KE1hdGgucm91bmQobGVuZ3RoIC0gMSksIDEpKTtcbiAgfVxuXG4gIHJldHVybiBzaG9ydGVuZWRMaW5lO1xufVxuXG5cbmZ1bmN0aW9uIGdldEhlbHBlclN2ZygpIHtcbiAgdmFyIGhlbHBlclN2ZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWxwZXItc3ZnJyk7XG5cbiAgaWYgKCFoZWxwZXJTdmcpIHtcbiAgICBoZWxwZXJTdmcgPSBzdmdDcmVhdGUoJ3N2ZycpO1xuXG4gICAgc3ZnQXR0cihoZWxwZXJTdmcsIHtcbiAgICAgIGlkOiAnaGVscGVyLXN2ZycsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHN0eWxlOiAndmlzaWJpbGl0eTogaGlkZGVuOyBwb3NpdGlvbjogZml4ZWQnXG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGhlbHBlclN2Zyk7XG4gIH1cblxuICByZXR1cm4gaGVscGVyU3ZnO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsYWJlbCB1dGlsaXR5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtEaW1lbnNpb25zfSBjb25maWcuc2l6ZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5wYWRkaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnN0eWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLmFsaWduXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRleHQoY29uZmlnKSB7XG5cbiAgdGhpcy5fY29uZmlnID0gYXNzaWduKHt9LCB7XG4gICAgc2l6ZTogREVGQVVMVF9MQUJFTF9TSVpFLFxuICAgIHBhZGRpbmc6IERFRkFVTFRfQk9YX1BBRERJTkcsXG4gICAgc3R5bGU6IHt9LFxuICAgIGFsaWduOiAnY2VudGVyLXRvcCdcbiAgfSwgY29uZmlnIHx8IHt9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXlvdXRlZCB0ZXh0IGFzIGFuIFNWRyBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9XG4gKi9cblRleHQucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmxheW91dFRleHQodGV4dCwgb3B0aW9ucykuZWxlbWVudDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGxhYmVscyBsYXlvdXRlZCBkaW1lbnNpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IHRvIGxheW91dFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuIHtEaW1lbnNpb25zfVxuICovXG5UZXh0LnByb3RvdHlwZS5nZXREaW1lbnNpb25zID0gZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5sYXlvdXRUZXh0KHRleHQsIG9wdGlvbnMpLmRpbWVuc2lvbnM7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBsYWJlbCBhbmQgaXRzIGJvdW5kaW5nIGJveC5cbiAqXG4gKiBAbWV0aG9kIFRleHQjY3JlYXRlVGV4dFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IHRoZSB0ZXh0IHRvIHJlbmRlciBvbiB0aGUgbGFiZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hbGlnbiBob3cgdG8gYWxpZ24gaW4gdGhlIGJvdW5kaW5nIGJveC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFueSBvZiB7ICdjZW50ZXItbWlkZGxlJywgJ2NlbnRlci10b3AnIH0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0cyB0byAnY2VudGVyLXRvcCcuXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zdHlsZSBzdHlsZSB0byBiZSBhcHBsaWVkIHRvIHRoZSB0ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuZml0Qm94IGluZGljYXRlcyBpZiBib3ggd2lsbCBiZSByZWNhbGN1bGF0ZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml0IHRleHRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHsgZWxlbWVudCwgZGltZW5zaW9ucyB9XG4gKi9cblRleHQucHJvdG90eXBlLmxheW91dFRleHQgPSBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBib3ggPSBhc3NpZ24oe30sIHRoaXMuX2NvbmZpZy5zaXplLCBvcHRpb25zLmJveCksXG4gICAgICBzdHlsZSA9IGFzc2lnbih7fSwgdGhpcy5fY29uZmlnLnN0eWxlLCBvcHRpb25zLnN0eWxlKSxcbiAgICAgIGFsaWduID0gcGFyc2VBbGlnbihvcHRpb25zLmFsaWduIHx8IHRoaXMuX2NvbmZpZy5hbGlnbiksXG4gICAgICBwYWRkaW5nID0gcGFyc2VQYWRkaW5nKG9wdGlvbnMucGFkZGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wYWRkaW5nIDogdGhpcy5fY29uZmlnLnBhZGRpbmcpLFxuICAgICAgZml0Qm94ID0gb3B0aW9ucy5maXRCb3ggfHwgZmFsc2U7XG5cbiAgdmFyIGxpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0KHN0eWxlKTtcblxuICAvLyB3ZSBzcGxpdCB0ZXh0IGJ5IGxpbmVzIGFuZCBub3JtYWxpemVcbiAgLy8ge3NvZnQgYnJlYWt9ICsge2xpbmUgYnJlYWt9ID0+IHsgbGluZSBicmVhayB9XG4gIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoL1xcdTAwQUQ/XFxyP1xcbi8pLFxuICAgICAgbGF5b3V0ZWQgPSBbXTtcblxuICB2YXIgbWF4V2lkdGggPSBib3gud2lkdGggLSBwYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0O1xuXG4gIC8vIGVuc3VyZSBjb3JyZWN0IHJlbmRlcmluZyBieSBhdHRhY2hpbmcgaGVscGVyIHRleHQgbm9kZSB0byBpbnZpc2libGUgU1ZHXG4gIHZhciBoZWxwZXJUZXh0ID0gc3ZnQ3JlYXRlKCd0ZXh0Jyk7XG4gIHN2Z0F0dHIoaGVscGVyVGV4dCwgeyB4OiAwLCB5OiAwIH0pO1xuICBzdmdBdHRyKGhlbHBlclRleHQsIHN0eWxlKTtcblxuICB2YXIgaGVscGVyU3ZnID0gZ2V0SGVscGVyU3ZnKCk7XG5cbiAgc3ZnQXBwZW5kKGhlbHBlclN2ZywgaGVscGVyVGV4dCk7XG5cbiAgd2hpbGUgKGxpbmVzLmxlbmd0aCkge1xuICAgIGxheW91dGVkLnB1c2gobGF5b3V0TmV4dChsaW5lcywgbWF4V2lkdGgsIGhlbHBlclRleHQpKTtcbiAgfVxuXG4gIGlmIChhbGlnbi52ZXJ0aWNhbCA9PT0gJ21pZGRsZScpIHtcbiAgICBwYWRkaW5nLnRvcCA9IHBhZGRpbmcuYm90dG9tID0gMDtcbiAgfVxuXG4gIHZhciB0b3RhbEhlaWdodCA9IHJlZHVjZShsYXlvdXRlZCwgZnVuY3Rpb24oc3VtLCBsaW5lLCBpZHgpIHtcbiAgICByZXR1cm4gc3VtICsgKGxpbmVIZWlnaHQgfHwgbGluZS5oZWlnaHQpO1xuICB9LCAwKSArIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG5cbiAgdmFyIG1heExpbmVXaWR0aCA9IHJlZHVjZShsYXlvdXRlZCwgZnVuY3Rpb24oc3VtLCBsaW5lLCBpZHgpIHtcbiAgICByZXR1cm4gbGluZS53aWR0aCA+IHN1bSA/IGxpbmUud2lkdGggOiBzdW07XG4gIH0sIDApO1xuXG4gIC8vIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBuZXh0IGxpbmVcbiAgdmFyIHkgPSBwYWRkaW5nLnRvcDtcblxuICBpZiAoYWxpZ24udmVydGljYWwgPT09ICdtaWRkbGUnKSB7XG4gICAgeSArPSAoYm94LmhlaWdodCAtIHRvdGFsSGVpZ2h0KSAvIDI7XG4gIH1cblxuICAvLyBtYWdpYyBudW1iZXIgaW5pdGlhbCBvZmZzZXRcbiAgeSAtPSAobGluZUhlaWdodCB8fCBsYXlvdXRlZFswXS5oZWlnaHQpIC8gNDtcblxuXG4gIHZhciB0ZXh0RWxlbWVudCA9IHN2Z0NyZWF0ZSgndGV4dCcpO1xuXG4gIHN2Z0F0dHIodGV4dEVsZW1lbnQsIHN0eWxlKTtcblxuICAvLyBsYXlvdXQgZWFjaCBsaW5lIHRha2luZyBpbnRvIGFjY291bnQgdGhhdCBwYXJlbnRcbiAgLy8gc2hhcGUgbWlnaHQgcmVzaXplIHRvIGZpdCB0ZXh0IHNpemVcbiAgZm9yRWFjaChsYXlvdXRlZCwgZnVuY3Rpb24obGluZSkge1xuXG4gICAgdmFyIHg7XG5cbiAgICB5ICs9IChsaW5lSGVpZ2h0IHx8IGxpbmUuaGVpZ2h0KTtcblxuICAgIHN3aXRjaCAoYWxpZ24uaG9yaXpvbnRhbCkge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgeCA9IHBhZGRpbmcubGVmdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgeCA9ICgoZml0Qm94ID8gbWF4TGluZVdpZHRoIDogbWF4V2lkdGgpXG4gICAgICAgIC0gcGFkZGluZy5yaWdodCAtIGxpbmUud2lkdGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuXG4gICAgICAvLyBha2EgY2VudGVyXG4gICAgICB4ID0gTWF0aC5tYXgoKCgoZml0Qm94ID8gbWF4TGluZVdpZHRoIDogbWF4V2lkdGgpXG4gICAgICAgIC0gbGluZS53aWR0aCkgLyAyICsgcGFkZGluZy5sZWZ0KSwgMCk7XG4gICAgfVxuXG4gICAgdmFyIHRzcGFuID0gc3ZnQ3JlYXRlKCd0c3BhbicpO1xuICAgIHN2Z0F0dHIodHNwYW4sIHsgeDogeCwgeTogeSB9KTtcblxuICAgIHRzcGFuLnRleHRDb250ZW50ID0gbGluZS50ZXh0O1xuXG4gICAgc3ZnQXBwZW5kKHRleHRFbGVtZW50LCB0c3Bhbik7XG4gIH0pO1xuXG4gIHN2Z1JlbW92ZShoZWxwZXJUZXh0KTtcblxuICB2YXIgZGltZW5zaW9ucyA9IHtcbiAgICB3aWR0aDogbWF4TGluZVdpZHRoLFxuICAgIGhlaWdodDogdG90YWxIZWlnaHRcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgZWxlbWVudDogdGV4dEVsZW1lbnRcbiAgfTtcbn07XG5cblxuZnVuY3Rpb24gZ2V0TGluZUhlaWdodChzdHlsZSkge1xuICBpZiAoJ2ZvbnRTaXplJyBpbiBzdHlsZSAmJiAnbGluZUhlaWdodCcgaW4gc3R5bGUpIHtcbiAgICByZXR1cm4gc3R5bGUubGluZUhlaWdodCAqIHBhcnNlSW50KHN0eWxlLmZvbnRTaXplLCAxMCk7XG4gIH1cbn0iLCJ2YXIgQ0xBU1NfUEFUVEVSTiA9IC9eY2xhc3MgLztcblxuZnVuY3Rpb24gaXNDbGFzcyhmbikge1xuICByZXR1cm4gQ0xBU1NfUEFUVEVSTi50ZXN0KGZuLnRvU3RyaW5nKCkpO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbmZ1bmN0aW9uIGhhc093blByb3Aob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZnVuY3Rpb24gYW5ub3RhdGUoKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShhcmdzWzBdKSkge1xuICAgIGFyZ3MgPSBhcmdzWzBdO1xuICB9XG5cbiAgdmFyIGZuID0gYXJncy5wb3AoKTtcblxuICBmbi4kaW5qZWN0ID0gYXJncztcblxuICByZXR1cm4gZm47XG59XG5cblxuLy8gQ3VycmVudCBsaW1pdGF0aW9uczpcbi8vIC0gY2FuJ3QgcHV0IGludG8gXCJmdW5jdGlvbiBhcmdcIiBjb21tZW50c1xuLy8gZnVuY3Rpb24gLyogKG5vIHBhcmVudGhlc2lzIGxpa2UgdGhpcykgKi8gKCl7fVxuLy8gZnVuY3Rpb24gYWJjKCAvKiB4eCAobm8gcGFyZW50aGVzaXMgbGlrZSB0aGlzKSAqLyBhLCBiKSB7fVxuLy9cbi8vIEp1c3QgcHV0IHRoZSBjb21tZW50IGJlZm9yZSBmdW5jdGlvbiBvciBpbnNpZGU6XG4vLyAvKiAoKCh0aGlzIGlzIGZpbmUpKSkgKi8gZnVuY3Rpb24oYSwgYikge31cbi8vIGZ1bmN0aW9uIGFiYyhhKSB7IC8qICgoKHRoaXMgaXMgZmluZSkpKSAqL31cbi8vXG4vLyAtIGNhbid0IHJlbGlhYmx5IGF1dG8tYW5ub3RhdGUgY29uc3RydWN0b3I7IHdlJ2xsIG1hdGNoIHRoZVxuLy8gZmlyc3QgY29uc3RydWN0b3IoLi4uKSBwYXR0ZXJuIGZvdW5kIHdoaWNoIG1heSBiZSB0aGUgb25lXG4vLyBvZiBhIG5lc3RlZCBjbGFzcywgdG9vLlxuXG52YXIgQ09OU1RSVUNUT1JfQVJHUyA9IC9jb25zdHJ1Y3RvclxccypbXihdKlxcKFxccyooW14pXSopXFwpL207XG52YXIgRk5fQVJHUyA9IC9eKD86YXN5bmMgKT8oPzpmdW5jdGlvblxccyopP1teKF0qXFwoXFxzKihbXildKilcXCkvbTtcbnZhciBGTl9BUkcgPSAvXFwvXFwqKFteKl0qKVxcKlxcLy9tO1xuXG5mdW5jdGlvbiBwYXJzZUFubm90YXRpb25zKGZuKSB7XG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFubm90YXRlIFwiJyArIGZuICsgJ1wiLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIScpO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gZm4udG9TdHJpbmcoKS5tYXRjaChpc0NsYXNzKGZuKSA/IENPTlNUUlVDVE9SX0FSR1MgOiBGTl9BUkdTKTtcblxuICAvLyBtYXkgcGFyc2UgY2xhc3Mgd2l0aG91dCBjb25zdHJ1Y3RvclxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoWzFdICYmIG1hdGNoWzFdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKGFyZykge1xuICAgIG1hdGNoID0gYXJnLm1hdGNoKEZOX0FSRyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0udHJpbSgpIDogYXJnLnRyaW0oKTtcbiAgfSkgfHwgW107XG59XG5cbmZ1bmN0aW9uIE1vZHVsZSgpIHtcbiAgdmFyIHByb3ZpZGVycyA9IFtdO1xuXG4gIHRoaXMuZmFjdG9yeSA9IGZ1bmN0aW9uKG5hbWUsIGZhY3RvcnkpIHtcbiAgICBwcm92aWRlcnMucHVzaChbbmFtZSwgJ2ZhY3RvcnknLCBmYWN0b3J5XSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy52YWx1ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgcHJvdmlkZXJzLnB1c2goW25hbWUsICd2YWx1ZScsIHZhbHVlXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy50eXBlID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgIHByb3ZpZGVycy5wdXNoKFtuYW1lLCAndHlwZScsIHR5cGVdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmZvckVhY2ggPSBmdW5jdGlvbihpdGVyYXRvcikge1xuICAgIHByb3ZpZGVycy5mb3JFYWNoKGl0ZXJhdG9yKTtcbiAgfTtcblxufVxuXG5mdW5jdGlvbiBJbmplY3Rvcihtb2R1bGVzLCBwYXJlbnQpIHtcbiAgcGFyZW50ID0gcGFyZW50IHx8IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUsIHN0cmljdCkge1xuICAgICAgY3VycmVudGx5UmVzb2x2aW5nLnB1c2gobmFtZSk7XG5cbiAgICAgIGlmIChzdHJpY3QgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3IoJ05vIHByb3ZpZGVyIGZvciBcIicgKyBuYW1lICsgJ1wiIScpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY3VycmVudGx5UmVzb2x2aW5nID0gW107XG4gIHZhciBwcm92aWRlcnMgPSB0aGlzLl9wcm92aWRlcnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5fcHJvdmlkZXJzIHx8IG51bGwpO1xuICB2YXIgaW5zdGFuY2VzID0gdGhpcy5faW5zdGFuY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB2YXIgc2VsZiA9IGluc3RhbmNlcy5pbmplY3RvciA9IHRoaXM7XG5cbiAgdmFyIGVycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gICAgdmFyIHN0YWNrID0gY3VycmVudGx5UmVzb2x2aW5nLmpvaW4oJyAtPiAnKTtcbiAgICBjdXJyZW50bHlSZXNvbHZpbmcubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gbmV3IEVycm9yKHN0YWNrID8gbXNnICsgJyAoUmVzb2x2aW5nOiAnICsgc3RhY2sgKyAnKScgOiBtc2cpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuYW1lZCBzZXJ2aWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdHJpY3Q9dHJ1ZV0gaWYgZmFsc2UsIHJlc29sdmUgbWlzc2luZyBzZXJ2aWNlcyB0byBudWxsXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHZhciBnZXQgPSBmdW5jdGlvbihuYW1lLCBzdHJpY3QpIHtcbiAgICBpZiAoIXByb3ZpZGVyc1tuYW1lXSAmJiBuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBwaXZvdCA9IGdldChwYXJ0cy5zaGlmdCgpKTtcblxuICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICBwaXZvdCA9IHBpdm90W3BhcnRzLnNoaWZ0KCldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGl2b3Q7XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3AoaW5zdGFuY2VzLCBuYW1lKSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlc1tuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChwcm92aWRlcnMsIG5hbWUpKSB7XG4gICAgICBpZiAoY3VycmVudGx5UmVzb2x2aW5nLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wdXNoKG5hbWUpO1xuICAgICAgICB0aHJvdyBlcnJvcignQ2Fubm90IHJlc29sdmUgY2lyY3VsYXIgZGVwZW5kZW5jeSEnKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudGx5UmVzb2x2aW5nLnB1c2gobmFtZSk7XG4gICAgICBpbnN0YW5jZXNbbmFtZV0gPSBwcm92aWRlcnNbbmFtZV1bMF0ocHJvdmlkZXJzW25hbWVdWzFdKTtcbiAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wb3AoKTtcblxuICAgICAgcmV0dXJuIGluc3RhbmNlc1tuYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50LmdldChuYW1lLCBzdHJpY3QpO1xuICB9O1xuXG4gIHZhciBmbkRlZiA9IGZ1bmN0aW9uKGZuLCBsb2NhbHMpIHtcblxuICAgIGlmICh0eXBlb2YgbG9jYWxzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxzID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgICAgIGZuID0gYW5ub3RhdGUoZm4uc2xpY2UoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgXCInICsgZm4gKyAnXCIuIEV4cGVjdGVkIGEgZnVuY3Rpb24hJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGluamVjdCA9IGZuLiRpbmplY3QgfHwgcGFyc2VBbm5vdGF0aW9ucyhmbik7XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IGluamVjdC5tYXAoZnVuY3Rpb24oZGVwKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcChsb2NhbHMsIGRlcCkpIHtcbiAgICAgICAgcmV0dXJuIGxvY2Fsc1tkZXBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldChkZXApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZuOiBmbixcbiAgICAgIGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzXG4gICAgfTtcbiAgfTtcblxuICB2YXIgaW5zdGFudGlhdGUgPSBmdW5jdGlvbihUeXBlKSB7XG4gICAgdmFyIGRlZiA9IGZuRGVmKFR5cGUpO1xuXG4gICAgdmFyIGZuID0gZGVmLmZuLFxuICAgICAgICBkZXBlbmRlbmNpZXMgPSBkZWYuZGVwZW5kZW5jaWVzO1xuXG4gICAgLy8gaW5zdGFudGlhdGUgdmFyIGFyZ3MgY29uc3RydWN0b3JcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShmbiwgWyBudWxsIF0uY29uY2F0KGRlcGVuZGVuY2llcykpO1xuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcigpO1xuICB9O1xuXG4gIHZhciBpbnZva2UgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBsb2NhbHMpIHtcbiAgICB2YXIgZGVmID0gZm5EZWYoZnVuYywgbG9jYWxzKTtcblxuICAgIHZhciBmbiA9IGRlZi5mbixcbiAgICAgICAgZGVwZW5kZW5jaWVzID0gZGVmLmRlcGVuZGVuY2llcztcblxuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBkZXBlbmRlbmNpZXMpO1xuICB9O1xuXG5cbiAgdmFyIGNyZWF0ZVByaXZhdGVJbmplY3RvckZhY3RvcnkgPSBmdW5jdGlvbihwcml2YXRlQ2hpbGRJbmplY3Rvcikge1xuICAgIHJldHVybiBhbm5vdGF0ZShmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBwcml2YXRlQ2hpbGRJbmplY3Rvci5nZXQoa2V5KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlQ2hpbGQgPSBmdW5jdGlvbihtb2R1bGVzLCBmb3JjZU5ld0luc3RhbmNlcykge1xuICAgIGlmIChmb3JjZU5ld0luc3RhbmNlcyAmJiBmb3JjZU5ld0luc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBmcm9tUGFyZW50TW9kdWxlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBtYXRjaGVkU2NvcGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgdmFyIHByaXZhdGVJbmplY3RvcnNDYWNoZSA9IFtdO1xuICAgICAgdmFyIHByaXZhdGVDaGlsZEluamVjdG9ycyA9IFtdO1xuICAgICAgdmFyIHByaXZhdGVDaGlsZEZhY3RvcmllcyA9IFtdO1xuXG4gICAgICB2YXIgcHJvdmlkZXI7XG4gICAgICB2YXIgY2FjaGVJZHg7XG4gICAgICB2YXIgcHJpdmF0ZUNoaWxkSW5qZWN0b3I7XG4gICAgICB2YXIgcHJpdmF0ZUNoaWxkSW5qZWN0b3JGYWN0b3J5O1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcm92aWRlcnMpIHtcbiAgICAgICAgcHJvdmlkZXIgPSBwcm92aWRlcnNbbmFtZV07XG5cbiAgICAgICAgaWYgKGZvcmNlTmV3SW5zdGFuY2VzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgaWYgKHByb3ZpZGVyWzJdID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIGNhY2hlSWR4ID0gcHJpdmF0ZUluamVjdG9yc0NhY2hlLmluZGV4T2YocHJvdmlkZXJbM10pO1xuICAgICAgICAgICAgaWYgKGNhY2hlSWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICBwcml2YXRlQ2hpbGRJbmplY3RvciA9IHByb3ZpZGVyWzNdLmNyZWF0ZUNoaWxkKFtdLCBmb3JjZU5ld0luc3RhbmNlcyk7XG4gICAgICAgICAgICAgIHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeSA9IGNyZWF0ZVByaXZhdGVJbmplY3RvckZhY3RvcnkocHJpdmF0ZUNoaWxkSW5qZWN0b3IpO1xuICAgICAgICAgICAgICBwcml2YXRlSW5qZWN0b3JzQ2FjaGUucHVzaChwcm92aWRlclszXSk7XG4gICAgICAgICAgICAgIHByaXZhdGVDaGlsZEluamVjdG9ycy5wdXNoKHByaXZhdGVDaGlsZEluamVjdG9yKTtcbiAgICAgICAgICAgICAgcHJpdmF0ZUNoaWxkRmFjdG9yaWVzLnB1c2gocHJpdmF0ZUNoaWxkSW5qZWN0b3JGYWN0b3J5KTtcbiAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFtwcml2YXRlQ2hpbGRJbmplY3RvckZhY3RvcnksIG5hbWUsICdwcml2YXRlJywgcHJpdmF0ZUNoaWxkSW5qZWN0b3JdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFtwcml2YXRlQ2hpbGRGYWN0b3JpZXNbY2FjaGVJZHhdLCBuYW1lLCAncHJpdmF0ZScsIHByaXZhdGVDaGlsZEluamVjdG9yc1tjYWNoZUlkeF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9tUGFyZW50TW9kdWxlW25hbWVdID0gW3Byb3ZpZGVyWzJdLCBwcm92aWRlclsxXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdGNoZWRTY29wZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChwcm92aWRlclsyXSA9PT0gJ2ZhY3RvcnknIHx8IHByb3ZpZGVyWzJdID09PSAndHlwZScpICYmIHByb3ZpZGVyWzFdLiRzY29wZSkge1xuICAgICAgICAgIC8qIGpzaGludCAtVzA4MyAqL1xuICAgICAgICAgIGZvcmNlTmV3SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgICAgIGlmIChwcm92aWRlclsxXS4kc2NvcGUuaW5kZXhPZihzY29wZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGZyb21QYXJlbnRNb2R1bGVbbmFtZV0gPSBbcHJvdmlkZXJbMl0sIHByb3ZpZGVyWzFdXTtcbiAgICAgICAgICAgICAgbWF0Y2hlZFNjb3Blc1tzY29wZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvcmNlTmV3SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2NvcGVzW3Njb3BlXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvdmlkZXIgZm9yIFwiJyArIHNjb3BlICsgJ1wiLiBDYW5ub3QgdXNlIHByb3ZpZGVyIGZyb20gdGhlIHBhcmVudCEnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG1vZHVsZXMudW5zaGlmdChmcm9tUGFyZW50TW9kdWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEluamVjdG9yKG1vZHVsZXMsIHNlbGYpO1xuICB9O1xuXG4gIHZhciBmYWN0b3J5TWFwID0ge1xuICAgIGZhY3Rvcnk6IGludm9rZSxcbiAgICB0eXBlOiBpbnN0YW50aWF0ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4gICAgZnVuY3Rpb24gYXJyYXlVbndyYXAodHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlICE9PSAndmFsdWUnICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gYW5ub3RhdGUodmFsdWUuc2xpY2UoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBUT0RPKHZvanRhKTogaGFuZGxlIHdyb25nIGlucHV0cyAobW9kdWxlcylcbiAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgTW9kdWxlKSB7XG4gICAgICBtb2R1bGUuZm9yRWFjaChmdW5jdGlvbihwcm92aWRlcikge1xuICAgICAgICB2YXIgbmFtZSA9IHByb3ZpZGVyWzBdO1xuICAgICAgICB2YXIgdHlwZSA9IHByb3ZpZGVyWzFdO1xuICAgICAgICB2YXIgdmFsdWUgPSBwcm92aWRlclsyXTtcblxuICAgICAgICBwcm92aWRlcnNbbmFtZV0gPSBbZmFjdG9yeU1hcFt0eXBlXSwgYXJyYXlVbndyYXAodHlwZSwgdmFsdWUpLCB0eXBlXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChtb2R1bGUuX19leHBvcnRzX18pIHtcbiAgICAgICAgdmFyIGNsb25lZE1vZHVsZSA9IE9iamVjdC5rZXlzKG1vZHVsZSkucmVkdWNlKGZ1bmN0aW9uKG0sIGtleSkge1xuICAgICAgICAgIGlmIChrZXkuc3Vic3RyaW5nKDAsIDIpICE9PSAnX18nKSB7XG4gICAgICAgICAgICBtW2tleV0gPSBtb2R1bGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gICAgICAgIHZhciBwcml2YXRlSW5qZWN0b3IgPSBuZXcgSW5qZWN0b3IoKG1vZHVsZS5fX21vZHVsZXNfXyB8fCBbXSkuY29uY2F0KFtjbG9uZWRNb2R1bGVdKSwgc2VsZik7XG4gICAgICAgIHZhciBnZXRGcm9tUHJpdmF0ZUluamVjdG9yID0gYW5ub3RhdGUoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHByaXZhdGVJbmplY3Rvci5nZXQoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vZHVsZS5fX2V4cG9ydHNfXy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHByb3ZpZGVyc1trZXldID0gW2dldEZyb21Qcml2YXRlSW5qZWN0b3IsIGtleSwgJ3ByaXZhdGUnLCBwcml2YXRlSW5qZWN0b3JdO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG1vZHVsZSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgaWYgKG1vZHVsZVtuYW1lXVsyXSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICBwcm92aWRlcnNbbmFtZV0gPSBtb2R1bGVbbmFtZV07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHR5cGUgPSBtb2R1bGVbbmFtZV1bMF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gbW9kdWxlW25hbWVdWzFdO1xuXG4gICAgICAgICAgcHJvdmlkZXJzW25hbWVdID0gW2ZhY3RvcnlNYXBbdHlwZV0sIGFycmF5VW53cmFwKHR5cGUsIHZhbHVlKSwgdHlwZV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHVibGljIEFQSVxuICB0aGlzLmdldCA9IGdldDtcbiAgdGhpcy5pbnZva2UgPSBpbnZva2U7XG4gIHRoaXMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcbiAgdGhpcy5jcmVhdGVDaGlsZCA9IGNyZWF0ZUNoaWxkO1xufVxuXG5leHBvcnQgeyBhbm5vdGF0ZSwgcGFyc2VBbm5vdGF0aW9ucywgTW9kdWxlLCBJbmplY3RvciB9O1xuIiwiLyohIEhhbW1lci5KUyAtIHYyLjAuNyAtIDIwMTYtMDQtMjJcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEpvcmlrIFRhbmdlbGRlcjtcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnTW96JywgJ01TJywgJ21zJywgJ28nXTtcbnZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIG5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIHNldCBhIHRpbWVvdXQgd2l0aCBhIGdpdmVuIHNjb3BlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xufVxuXG4vKipcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuXG4gICAgICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAqL1xudmFyIGFzc2lnbjtcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIW1lcmdlIHx8IChtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBtZXJnZSA9IGRlcHJlY2F0ZShmdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG59LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICAgIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlLFxuICAgICAgICBjaGlsZFA7XG5cbiAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xuICAgICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAqIEBwYXJhbSB7Kn0gdmFsMVxuICogQHBhcmFtIHsqfSB2YWwyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xuICAgIHJldHVybiAodmFsMSA9PT0gdW5kZWZpbmVkKSA/IHZhbDIgOiB2YWwxO1xufVxuXG4vKipcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cblxuLyoqXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG5cbi8qKlxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgICAgcHJvcCA9IChwcmVmaXgpID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG52YXIgX3VuaXF1ZUlkID0gMTtcbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG59XG5cbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xudmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcblxudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcblxudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG5cbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG5cbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcblxufVxuXG5JbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlO1xuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgICBpZiAoaW5wdXRDbGFzcykge1xuICAgICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcblxuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgIH1cblxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gICAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cblxuLyoqXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH1cblxuICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuXG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG5cbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuXG4gICAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gKGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpKSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG5cbiAgICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG5cbiAgICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6ICgoaW5wdXQucG9pbnRlcnMubGVuZ3RoID5cbiAgICAgICAgc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpO1xuXG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcblxuICAgIC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICAgICAgfTtcblxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xufVxuXG4vKipcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0LFxuICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgICAgdmVsb2NpdHlZID0gdi55O1xuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcbiAgICAgICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG5cbi8qKlxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgICAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB4ID0gMCwgeSA9IDAsIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgICAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbi8qKlxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG5cbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1FaGFuZGxlcihldikge1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07XG5cbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG52YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG59O1xuXG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50ICYmICF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuXG4vKipcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnN0b3JlID0gKHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXSk7XG59XG5cbmluaGVyaXQoUG9pbnRlckV2ZW50SW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuXG4gICAgICAgIHZhciBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpO1xuXG4gICAgICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XG5cbiAgICAgICAgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0JztcbnZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cbiAgICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgICAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xufVxuXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMudGFyZ2V0SWRzID0ge307XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTVRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciB0YXJnZXRJZHMgPSB0aGlzLnRhcmdldElkcztcblxuICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gICAgfVxuXG4gICAgdmFyIGksXG4gICAgICAgIHRhcmdldFRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXG4gICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXG4gICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuICAgIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgICB9KTtcblxuICAgIC8vIGNvbGxlY3QgdG91Y2hlc1xuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICAgICAgICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXG4gICAgXTtcbn1cblxuLyoqXG4gKiBDb21iaW5lZCB0b3VjaCBhbmQgbW91c2UgaW5wdXRcbiAqXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAqIFRoaXMgYmVjYXVzZSB0b3VjaCBkZXZpY2VzIGFsc28gZW1pdCBtb3VzZSBldmVudHMgd2hpbGUgZG9pbmcgYSB0b3VjaC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xudmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbmZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcbiAgICB0aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcblxuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb3VjaGVzID0gW107XG59XG5cbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcblxuICAgICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbCh0aGlzLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgaXNTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGlucHV0RGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXI7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF07XG5cbiAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgICAgdmFyIGxhc3RUb3VjaCA9IHt4OiB0b3VjaC5jbGllbnRYLCB5OiB0b3VjaC5jbGllbnRZfTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG4gICAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLCB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCksIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG4gICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbi8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbnZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbnZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG4vKipcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbn1cblxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG5cbiAgICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG5cbiAgICAgICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc05vbmUgfHxcbiAgICAgICAgICAgIChoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB8fFxuICAgICAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAgICovXG4gICAgcHJldmVudFNyYzogZnVuY3Rpb24oc3JjRXZlbnQpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgLy8gbm9uZVxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIC8vIHBhbi14IE9SIHBhbi15XG4gICAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9XG5cbiAgICAvLyBtYW5pcHVsYXRpb25cbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gICAgfVxuXG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9BVVRPO1xufVxuXG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICAgIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0b3VjaE1hcCA9IHt9O1xuICAgIHZhciBjc3NTdXBwb3J0cyA9IHdpbmRvdy5DU1MgJiYgd2luZG93LkNTUy5zdXBwb3J0cztcbiAgICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgICAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgICAgIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbmRvdy5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaE1hcDtcbn1cblxuLyoqXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xudmFyIFNUQVRFX0JFR0FOID0gMjtcbnZhciBTVEFURV9DSEFOR0VEID0gNDtcbnZhciBTVEFURV9FTkRFRCA9IDg7XG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xudmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG4vKipcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcblxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG5cbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbn1cblxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7IC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTtcblxuICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxufTtcblxuLyoqXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5mdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICAgIHJldHVybiAnZW5kJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICByZXR1cm4gJ21vdmUnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtDb25zdH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgICByZXR1cm4gJ3VwJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cblxuLyoqXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcblxuICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcblxuICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG59XG5cbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BhbicsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9LFxuXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgLy8gbG9jayB0byBheGlzP1xuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHkgIT0gdGhpcy5wWTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG5cbiAgICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGluY2hcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG59XG5cbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRpbWU6IDI1MSwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgICAgdGhyZXNob2xkOiA5IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUm90YXRlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFJvdGF0ZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiZcbiAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxuICAgICAgICAgICAgaW5wdXQubWF4UG9pbnRlcnMgPT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmXG4gICAgICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEEgdGFwIGlzIGVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFRhcFJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IDA7XG59XG5cbmluaGVyaXQoVGFwUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGFwczogMSxcbiAgICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xuICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuXG4gICAgICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcbiAgICAgICAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbkhhbW1lci5WRVJTSU9OID0gJzIuMC43JztcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkb21FdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGVuYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAgICAgKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBwcmVzZXQ6IFtcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX1dLFxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX0sIFsncm90YXRlJ11dLFxuICAgICAgICBbU3dpcGVSZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH1dLFxuICAgICAgICBbUGFuUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9LCBbJ3N3aXBlJ11dLFxuICAgICAgICBbVGFwUmVjb2duaXplcl0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyLCB7ZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyfSwgWyd0YXAnXV0sXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBjc3NQcm9wczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH1cbn07XG5cbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG5cbi8qKlxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgSGFtbWVyLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuXG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcbiAgICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICB9LCB0aGlzKTtcbn1cblxuTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG4gICAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcbiAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcbiAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHsgLy8gM1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7XG5cbiAgICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9wO1xuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFkZCkge1xuICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxufVxuXG4vKipcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5hc3NpZ24oSGFtbWVyLCB7XG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkU6IElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG5cbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgIE1hbmFnZXI6IE1hbmFnZXIsXG4gICAgSW5wdXQ6IElucHV0LFxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgZWFjaDogZWFjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICBiaW5kRm46IGJpbmRGbixcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcbn0pO1xuXG4vLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG52YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5mcmVlR2xvYmFsLkhhbW1lciA9IEhhbW1lcjtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSGFtbWVyO1xufSBlbHNlIHtcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XG59XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTtcbiIsImZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgaGF0XzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG52YXIgaGF0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0cywgYmFzZSkge1xuICAgIGlmICghYmFzZSkgYmFzZSA9IDE2O1xuICAgIGlmIChiaXRzID09PSB1bmRlZmluZWQpIGJpdHMgPSAxMjg7XG4gICAgaWYgKGJpdHMgPD0gMCkgcmV0dXJuICcwJztcbiAgICBcbiAgICB2YXIgZGlnaXRzID0gTWF0aC5sb2coTWF0aC5wb3coMiwgYml0cykpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgZm9yICh2YXIgaSA9IDI7IGRpZ2l0cyA9PT0gSW5maW5pdHk7IGkgKj0gMikge1xuICAgICAgICBkaWdpdHMgPSBNYXRoLmxvZyhNYXRoLnBvdygyLCBiaXRzIC8gaSkpIC8gTWF0aC5sb2coYmFzZSkgKiBpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcmVtID0gZGlnaXRzIC0gTWF0aC5mbG9vcihkaWdpdHMpO1xuICAgIFxuICAgIHZhciByZXMgPSAnJztcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGguZmxvb3IoZGlnaXRzKTsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIHJlcyA9IHggKyByZXM7XG4gICAgfVxuICAgIFxuICAgIGlmIChyZW0pIHtcbiAgICAgICAgdmFyIGIgPSBNYXRoLnBvdyhiYXNlLCByZW0pO1xuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGIpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICByZXMgPSB4ICsgcmVzO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQocmVzLCBiYXNlKTtcbiAgICBpZiAocGFyc2VkICE9PSBJbmZpbml0eSAmJiBwYXJzZWQgPj0gTWF0aC5wb3coMiwgYml0cykpIHtcbiAgICAgICAgcmV0dXJuIGhhdChiaXRzLCBiYXNlKVxuICAgIH1cbiAgICBlbHNlIHJldHVybiByZXM7XG59O1xuXG5oYXQucmFjayA9IGZ1bmN0aW9uIChiaXRzLCBiYXNlLCBleHBhbmRCeSkge1xuICAgIHZhciBmbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBpdGVycyA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChpdGVycyArKyA+IDEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZEJ5KSBiaXRzICs9IGV4cGFuZEJ5O1xuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCd0b28gbWFueSBJRCBjb2xsaXNpb25zLCB1c2UgbW9yZSBiaXRzJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGlkID0gaGF0KGJpdHMsIGJhc2UpO1xuICAgICAgICB9IHdoaWxlIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChoYXRzLCBpZCkpO1xuICAgICAgICBcbiAgICAgICAgaGF0c1tpZF0gPSBkYXRhO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICB2YXIgaGF0cyA9IGZuLmhhdHMgPSB7fTtcbiAgICBcbiAgICBmbi5nZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGZuLmhhdHNbaWRdO1xuICAgIH07XG4gICAgXG4gICAgZm4uc2V0ID0gZnVuY3Rpb24gKGlkLCB2YWx1ZSkge1xuICAgICAgICBmbi5oYXRzW2lkXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBcbiAgICBmbi5iaXRzID0gYml0cyB8fCAxMjg7XG4gICAgZm4uYmFzZSA9IGJhc2UgfHwgMTY7XG4gICAgcmV0dXJuIGZuO1xufTtcbn0pO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpZCBnZW5lcmF0b3IgLyBjYWNoZSBpbnN0YW5jZS5cbiAqXG4gKiBZb3UgbWF5IG9wdGlvbmFsbHkgcHJvdmlkZSBhIHNlZWQgdGhhdCBpcyB1c2VkIGludGVybmFsbHkuXG4gKlxuICogQHBhcmFtIHtTZWVkfSBzZWVkXG4gKi9cblxuZnVuY3Rpb24gSWRzKHNlZWQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIElkcykpIHtcbiAgICByZXR1cm4gbmV3IElkcyhzZWVkKTtcbiAgfVxuXG4gIHNlZWQgPSBzZWVkIHx8IFsxMjgsIDM2LCAxXTtcbiAgdGhpcy5fc2VlZCA9IHNlZWQubGVuZ3RoID8gaGF0XzEucmFjayhzZWVkWzBdLCBzZWVkWzFdLCBzZWVkWzJdKSA6IHNlZWQ7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEgbmV4dCBpZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2VsZW1lbnRdIGVsZW1lbnQgdG8gYmluZCB0aGUgaWQgdG9cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG4gKi9cblxuSWRzLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHRoaXMuX3NlZWQoZWxlbWVudCB8fCB0cnVlKTtcbn07XG4vKipcbiAqIEdlbmVyYXRlIGEgbmV4dCBpZCB3aXRoIGEgZ2l2ZW4gcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZWxlbWVudF0gZWxlbWVudCB0byBiaW5kIHRoZSBpZCB0b1xuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gaWRcbiAqL1xuXG5cbklkcy5wcm90b3R5cGUubmV4dFByZWZpeGVkID0gZnVuY3Rpb24gKHByZWZpeCwgZWxlbWVudCkge1xuICB2YXIgaWQ7XG5cbiAgZG8ge1xuICAgIGlkID0gcHJlZml4ICsgdGhpcy5uZXh0KHRydWUpO1xuICB9IHdoaWxlICh0aGlzLmFzc2lnbmVkKGlkKSk7IC8vIGNsYWltIHtwcmVmaXh9e3JhbmRvbX1cblxuXG4gIHRoaXMuY2xhaW0oaWQsIGVsZW1lbnQpOyAvLyByZXR1cm5cblxuICByZXR1cm4gaWQ7XG59O1xuLyoqXG4gKiBNYW51YWxseSBjbGFpbSBhbiBleGlzdGluZyBpZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZWxlbWVudF0gZWxlbWVudCB0aGUgaWQgaXMgY2xhaW1lZCBieVxuICovXG5cblxuSWRzLnByb3RvdHlwZS5jbGFpbSA9IGZ1bmN0aW9uIChpZCwgZWxlbWVudCkge1xuICB0aGlzLl9zZWVkLnNldChpZCwgZWxlbWVudCB8fCB0cnVlKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gaWQgaGFzIGFscmVhZHkgYmVlbiBhc3NpZ25lZC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cblxuSWRzLnByb3RvdHlwZS5hc3NpZ25lZCA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gdGhpcy5fc2VlZC5nZXQoaWQpIHx8IGZhbHNlO1xufTtcbi8qKlxuICogVW5jbGFpbSBhbiBpZC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGlkIHRoZSBpZCB0byB1bmNsYWltXG4gKi9cblxuXG5JZHMucHJvdG90eXBlLnVuY2xhaW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgZGVsZXRlIHRoaXMuX3NlZWQuaGF0c1tpZF07XG59O1xuLyoqXG4gKiBDbGVhciBhbGwgY2xhaW1lZCBpZHMuXG4gKi9cblxuXG5JZHMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGF0cyA9IHRoaXMuX3NlZWQuaGF0cyxcbiAgICAgIGlkO1xuXG4gIGZvciAoaWQgaW4gaGF0cykge1xuICAgIHRoaXMudW5jbGFpbShpZCk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IElkcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogRmxhdHRlbiBhcnJheSwgb25lIGxldmVsIGRlZXAuXG4gKlxuICogQHBhcmFtIHtBcnJheTw/Pn0gYXJyXG4gKlxuICogQHJldHVybiB7QXJyYXk8Pz59XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xufVxuXG52YXIgbmF0aXZlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG5hdGl2ZUhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0RlZmluZWQob2JqKSB7XG4gIHJldHVybiBvYmogIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzTmlsKG9iaikge1xuICByZXR1cm4gb2JqID09IG51bGw7XG59XG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gbmF0aXZlVG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBuYXRpdmVUb1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gIHJldHVybiBuYXRpdmVUb1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgdmFyIHRhZyA9IG5hdGl2ZVRvU3RyaW5nLmNhbGwob2JqKTtcbiAgcmV0dXJuIHRhZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fCB0YWcgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyB8fCB0YWcgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScgfHwgdGFnID09PSAnW29iamVjdCBBc3luY0dlbmVyYXRvckZ1bmN0aW9uXScgfHwgdGFnID09PSAnW29iamVjdCBQcm94eV0nO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gIHJldHVybiBuYXRpdmVUb1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuLyoqXG4gKiBFbnN1cmUgY29sbGVjdGlvbiBpcyBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuZnVuY3Rpb24gZW5zdXJlQXJyYXkob2JqKSB7XG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3VwcGx5IGFycmF5Jyk7XG59XG4vKipcbiAqIFJldHVybiB0cnVlLCBpZiB0YXJnZXQgb3ducyBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXModGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIG5hdGl2ZUhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpO1xufVxuXG4vKipcbiAqIEZpbmQgZWxlbWVudCBpbiBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gY29sbGVjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb258T2JqZWN0fSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbiwgbWF0Y2hlcikge1xuICBtYXRjaGVyID0gdG9NYXRjaGVyKG1hdGNoZXIpO1xuICB2YXIgbWF0Y2g7XG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgaWYgKG1hdGNoZXIodmFsLCBrZXkpKSB7XG4gICAgICBtYXRjaCA9IHZhbDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWF0Y2g7XG59XG4vKipcbiAqIEZpbmQgZWxlbWVudCBpbmRleCBpbiBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gY29sbGVjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IG1hdGNoZXJcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZmluZEluZGV4KGNvbGxlY3Rpb24sIG1hdGNoZXIpIHtcbiAgbWF0Y2hlciA9IHRvTWF0Y2hlcihtYXRjaGVyKTtcbiAgdmFyIGlkeCA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyAtMSA6IHVuZGVmaW5lZDtcbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICBpZiAobWF0Y2hlcih2YWwsIGtleSkpIHtcbiAgICAgIGlkeCA9IGtleTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaWR4O1xufVxuLyoqXG4gKiBGaW5kIGVsZW1lbnQgaW4gY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7QXJyYXl9IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBtYXRjaGVyKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICBpZiAobWF0Y2hlcih2YWwsIGtleSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGNvbGxlY3Rpb247IHJldHVybmluZyBzb21ldGhpbmdcbiAqIChub24tdW5kZWZpbmVkKSB3aWxsIHN0b3AgaXRlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gY29sbGVjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSByZXR1cm4gcmVzdWx0IHRoYXQgc3RvcHBlZCB0aGUgaXRlcmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRvcikge1xuICB2YXIgdmFsLCByZXN1bHQ7XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRLZXkgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gdG9OdW0gOiBpZGVudGl0eTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29sbGVjdGlvbikge1xuICAgIGlmIChoYXMoY29sbGVjdGlvbiwga2V5KSkge1xuICAgICAgdmFsID0gY29sbGVjdGlvbltrZXldO1xuICAgICAgcmVzdWx0ID0gaXRlcmF0b3IodmFsLCBjb252ZXJ0S2V5KGtleSkpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBSZXR1cm4gY29sbGVjdGlvbiB3aXRob3V0IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFyclxuICogQHBhcmFtICB7RnVuY3Rpb259IG1hdGNoZXJcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiB3aXRob3V0KGFyciwgbWF0Y2hlcikge1xuICBpZiAoaXNVbmRlZmluZWQoYXJyKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGVuc3VyZUFycmF5KGFycik7XG4gIG1hdGNoZXIgPSB0b01hdGNoZXIobWF0Y2hlcik7XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgcmV0dXJuICFtYXRjaGVyKGVsLCBpZHgpO1xuICB9KTtcbn1cbi8qKlxuICogUmVkdWNlIGNvbGxlY3Rpb24sIHJldHVybmluZyBhIHNpbmdsZSByZXN1bHQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSAge0FueX0gcmVzdWx0XG4gKlxuICogQHJldHVybiB7QW55fSByZXN1bHQgcmV0dXJuZWQgZnJvbSBsYXN0IGl0ZXJhdG9yXG4gKi9cblxuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdG9yLCByZXN1bHQpIHtcbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgIHJlc3VsdCA9IGl0ZXJhdG9yKHJlc3VsdCwgdmFsdWUsIGlkeCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBldmVyeSBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gKiBtYXRjaGVzIHRoZSBjcml0ZXJpYS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBtYXRjaGVyKSB7XG4gIHJldHVybiAhIXJlZHVjZShjb2xsZWN0aW9uLCBmdW5jdGlvbiAobWF0Y2hlcywgdmFsLCBrZXkpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyAmJiBtYXRjaGVyKHZhbCwga2V5KTtcbiAgfSwgdHJ1ZSk7XG59XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHNvbWUgZWxlbWVudHMgaW4gdGhlIGNvbGxlY3Rpb25cbiAqIG1hdGNoIHRoZSBjcml0ZXJpYS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIG1hdGNoZXIpIHtcbiAgcmV0dXJuICEhZmluZChjb2xsZWN0aW9uLCBtYXRjaGVyKTtcbn1cbi8qKlxuICogVHJhbnNmb3JtIGEgY29sbGVjdGlvbiBpbnRvIGFub3RoZXIgY29sbGVjdGlvblxuICogYnkgcGlwaW5nIGVhY2ggbWVtYmVyIHRocm91Z2ggdGhlIGdpdmVuIGZuLlxuICpcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gICBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gdHJhbnNmb3JtZWQgY29sbGVjdGlvblxuICovXG5cbmZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBmbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgcmVzdWx0LnB1c2goZm4odmFsLCBrZXkpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEdldCB0aGUgY29sbGVjdGlvbnMga2V5cy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBrZXlzKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIGNvbGxlY3Rpb24gJiYgT2JqZWN0LmtleXMoY29sbGVjdGlvbikgfHwgW107XG59XG4vKipcbiAqIFNob3J0aGFuZCBmb3IgYGtleXMobykubGVuZ3RoYC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbn1cbi8qKlxuICogR2V0IHRoZSB2YWx1ZXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBjb2xsZWN0aW9uXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gdmFsdWVzKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIG1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSk7XG59XG4vKipcbiAqIEdyb3VwIGNvbGxlY3Rpb24gbWVtYmVycyBieSBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZXh0cmFjdG9yXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBtYXAgd2l0aCB7IGF0dHJWYWx1ZSA9PiBbIGEsIGIsIGMgXSB9XG4gKi9cblxuZnVuY3Rpb24gZ3JvdXBCeShjb2xsZWN0aW9uLCBleHRyYWN0b3IpIHtcbiAgdmFyIGdyb3VwZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBleHRyYWN0b3IgPSB0b0V4dHJhY3RvcihleHRyYWN0b3IpO1xuICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgZGlzY3JpbWluYXRvciA9IGV4dHJhY3Rvcih2YWwpIHx8ICdfJztcbiAgICB2YXIgZ3JvdXAgPSBncm91cGVkW2Rpc2NyaW1pbmF0b3JdO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgZ3JvdXAgPSBncm91cGVkW2Rpc2NyaW1pbmF0b3JdID0gW107XG4gICAgfVxuXG4gICAgZ3JvdXAucHVzaCh2YWwpO1xuICB9KTtcbiAgcmV0dXJuIGdyb3VwZWQ7XG59XG5mdW5jdGlvbiB1bmlxdWVCeShleHRyYWN0b3IpIHtcbiAgZXh0cmFjdG9yID0gdG9FeHRyYWN0b3IoZXh0cmFjdG9yKTtcbiAgdmFyIGdyb3VwZWQgPSB7fTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY29sbGVjdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGNvbGxlY3Rpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGZvckVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGdyb3VwQnkoYywgZXh0cmFjdG9yLCBncm91cGVkKTtcbiAgfSk7XG4gIHZhciByZXN1bHQgPSBtYXAoZ3JvdXBlZCwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgcmV0dXJuIHZhbFswXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgdW5pb25CeSA9IHVuaXF1ZUJ5O1xuLyoqXG4gKiBTb3J0IGNvbGxlY3Rpb24gYnkgY3JpdGVyaWEuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtTdHJpbmd8RnVuY3Rpb259IGV4dHJhY3RvclxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBleHRyYWN0b3IpIHtcbiAgZXh0cmFjdG9yID0gdG9FeHRyYWN0b3IoZXh0cmFjdG9yKTtcbiAgdmFyIHNvcnRlZCA9IFtdO1xuICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgdmFyIGRpc2MgPSBleHRyYWN0b3IodmFsdWUsIGtleSk7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgZDogZGlzYyxcbiAgICAgIHY6IHZhbHVlXG4gICAgfTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHNvcnRlZC5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICB2YXIgZCA9IHNvcnRlZFtpZHhdLmQ7XG5cbiAgICAgIGlmIChkaXNjIDwgZCkge1xuICAgICAgICBzb3J0ZWQuc3BsaWNlKGlkeCwgMCwgZW50cnkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSAvLyBub3QgaW5zZXJ0ZWQsIGFwcGVuZCAoISlcblxuXG4gICAgc29ydGVkLnB1c2goZW50cnkpO1xuICB9KTtcbiAgcmV0dXJuIG1hcChzb3J0ZWQsIGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGUudjtcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBvYmplY3QgcGF0dGVybiBtYXRjaGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgbWF0Y2hlciA9IG1hdGNoUGF0dGVybih7IGlkOiAxIH0pO1xuICpcbiAqIHZhciBlbGVtZW50ID0gZmluZChlbGVtZW50cywgbWF0Y2hlcik7XG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXR0ZXJuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259IG1hdGNoZXJGblxuICovXG5cbmZ1bmN0aW9uIG1hdGNoUGF0dGVybihwYXR0ZXJuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZXZlcnkocGF0dGVybiwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICByZXR1cm4gZWxba2V5XSA9PT0gdmFsO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0b0V4dHJhY3RvcihleHRyYWN0b3IpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZXh0cmFjdG9yKSA/IGV4dHJhY3RvciA6IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGVbZXh0cmFjdG9yXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9NYXRjaGVyKG1hdGNoZXIpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24obWF0Y2hlcikgPyBtYXRjaGVyIDogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZSA9PT0gbWF0Y2hlcjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59XG5cbmZ1bmN0aW9uIHRvTnVtKGFyZykge1xuICByZXR1cm4gTnVtYmVyKGFyZyk7XG59XG5cbi8qKlxuICogRGVib3VuY2UgZm4sIGNhbGxpbmcgaXQgb25seSBvbmNlIGlmXG4gKiB0aGUgZ2l2ZW4gdGltZSBlbGFwc2VkIGJldHdlZW4gY2FsbHMuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVvdXRcbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCB0aW1lb3V0KSB7XG4gIHZhciB0aW1lcjtcbiAgdmFyIGxhc3RBcmdzO1xuICB2YXIgbGFzdFRoaXM7XG4gIHZhciBsYXN0Tm93O1xuXG4gIGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIHNjaGVkdWxlZERpZmYgPSBsYXN0Tm93ICsgdGltZW91dCAtIG5vdztcblxuICAgIGlmIChzY2hlZHVsZWREaWZmID4gMCkge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlKHNjaGVkdWxlZERpZmYpO1xuICAgIH1cblxuICAgIGZuLmFwcGx5KGxhc3RUaGlzLCBsYXN0QXJncyk7XG4gICAgdGltZXIgPSBsYXN0Tm93ID0gbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKHRpbWVvdXQpIHtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZmlyZSwgdGltZW91dCk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGxhc3ROb3cgPSBEYXRlLm5vdygpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxhc3RBcmdzID0gYXJncztcbiAgICBsYXN0VGhpcyA9IHRoaXM7IC8vIGVuc3VyZSBhbiBleGVjdXRpb24gaXMgc2NoZWR1bGVkXG5cbiAgICBpZiAoIXRpbWVyKSB7XG4gICAgICBzY2hlZHVsZSh0aW1lb3V0KTtcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIFRocm90dGxlIGZuLCBjYWxsaW5nIGF0IG1vc3Qgb25jZVxuICogaW4gdGhlIGdpdmVuIGludGVydmFsLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtICB7TnVtYmVyfSBpbnRlcnZhbFxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiB0aHJvdHRsZShmbiwgaW50ZXJ2YWwpIHtcbiAgdmFyIHRocm90dGxpbmcgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhyb3R0bGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZuLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICB0aHJvdHRsaW5nID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm90dGxpbmcgPSBmYWxzZTtcbiAgICB9LCBpbnRlcnZhbCk7XG4gIH07XG59XG4vKipcbiAqIEJpbmQgZnVuY3Rpb24gYWdhaW5zdCB0YXJnZXQgPHRoaXM+LlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtICB7T2JqZWN0fSAgIHRhcmdldFxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBib3VuZCBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGJpbmQoZm4sIHRhcmdldCkge1xuICByZXR1cm4gZm4uYmluZCh0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIHdyYXBwZXIgZm9yIGBPYmplY3QuYXNzaWduYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb3RoZXJzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3RoZXJzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBvdGhlcnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHZvaWQgMCwgW3RhcmdldF0uY29uY2F0KG90aGVycykpO1xufVxuLyoqXG4gKiBTZXRzIGEgbmVzdGVkIHByb3BlcnR5IG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gKlxuICogVGhpcyBtdXRhdGVzIHRoZSBvYmplY3QgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9mIHRoZSBzZXQgb3BlcmF0aW9uLlxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcilbXX0gcGF0aCBUaGUgcGF0aCB0byB0aGUgbmVzdGVkIHZhbHVlLlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKi9cblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIGN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG4gIGZvckVhY2gocGF0aCwgZnVuY3Rpb24gKGtleSwgaWR4KSB7XG4gICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBrZXk6IF9fcHJvdG9fXycpO1xuICAgIH1cblxuICAgIHZhciBuZXh0S2V5ID0gcGF0aFtpZHggKyAxXTtcbiAgICB2YXIgbmV4dFRhcmdldCA9IGN1cnJlbnRUYXJnZXRba2V5XTtcblxuICAgIGlmIChpc0RlZmluZWQobmV4dEtleSkgJiYgaXNOaWwobmV4dFRhcmdldCkpIHtcbiAgICAgIG5leHRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0W2tleV0gPSBpc05hTigrbmV4dEtleSkgPyB7fSA6IFtdO1xuICAgIH1cblxuICAgIGlmIChpc1VuZGVmaW5lZChuZXh0S2V5KSkge1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICBkZWxldGUgY3VycmVudFRhcmdldFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRUYXJnZXQgPSBuZXh0VGFyZ2V0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIEdldHMgYSBuZXN0ZWQgcHJvcGVydHkgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9mIHRoZSBnZXQgb3BlcmF0aW9uLlxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcilbXX0gcGF0aCBUaGUgcGF0aCB0byB0aGUgbmVzdGVkIHZhbHVlLlxuICogQHBhcmFtIHthbnl9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgbm8gdmFsdWUgZXhpc3RzLlxuICovXG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgZm9yRWFjaChwYXRoLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgLy8gYWNjZXNzaW5nIG5pbCBwcm9wZXJ0eSB5aWVsZHMgPHVuZGVmaW5lZD5cbiAgICBpZiAoaXNOaWwoY3VycmVudFRhcmdldCkpIHtcbiAgICAgIGN1cnJlbnRUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXRba2V5XTtcbiAgfSk7XG4gIHJldHVybiBpc1VuZGVmaW5lZChjdXJyZW50VGFyZ2V0KSA/IGRlZmF1bHRWYWx1ZSA6IGN1cnJlbnRUYXJnZXQ7XG59XG4vKipcbiAqIFBpY2sgZ2l2ZW4gcHJvcGVydGllcyBmcm9tIHRoZSB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnRpZXNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIHBpY2sodGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIG9iaiA9IE9iamVjdCh0YXJnZXQpO1xuICBmb3JFYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSB0YXJnZXRbcHJvcF07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUGljayBhbGwgdGFyZ2V0IHByb3BlcnRpZXMsIGV4Y2x1ZGluZyB0aGUgZ2l2ZW4gb25lcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wZXJ0aWVzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBvbWl0KHRhcmdldCwgcHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBvYmogPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yRWFjaChvYmosIGZ1bmN0aW9uIChwcm9wLCBrZXkpIHtcbiAgICBpZiAocHJvcGVydGllcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHByb3A7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgbWVyZ2UgYC4uLnNvdXJjZXNgIGludG8gZ2l2ZW4gdGFyZ2V0LlxuICpcbiAqIERvZXMgc3VwcG9ydCBtZXJnaW5nIG9iamVjdHM7IGRvZXMgbm90IHN1cHBvcnQgbWVyZ2luZyBhcnJheXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBzb3VyY2VzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgaWYgKCFzb3VyY2VzLmxlbmd0aCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmb3JFYWNoKHNvdXJjZXMsIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAvLyBza2lwIG5vbi1vYmogc291cmNlcywgaS5lLiBudWxsXG4gICAgaWYgKCFzb3VyY2UgfHwgIWlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3JFYWNoKHNvdXJjZSwgZnVuY3Rpb24gKHNvdXJjZVZhbCwga2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XTtcblxuICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVZhbCkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdCh0YXJnZXRWYWwpKSB7XG4gICAgICAgICAgLy8gb3ZlcnJpZGUgdGFyZ2V0W2tleV0gd2l0aCBvYmplY3RcbiAgICAgICAgICB0YXJnZXRWYWwgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2UodGFyZ2V0VmFsLCBzb3VyY2VWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2VWYWw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgeyBhc3NpZ24sIGJpbmQsIGRlYm91bmNlLCBlbnN1cmVBcnJheSwgZXZlcnksIGZpbHRlciwgZmluZCwgZmluZEluZGV4LCBmbGF0dGVuLCBmb3JFYWNoLCBnZXQsIGdyb3VwQnksIGhhcywgaXNBcnJheSwgaXNEZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc05pbCwgaXNOdW1iZXIsIGlzT2JqZWN0LCBpc1N0cmluZywgaXNVbmRlZmluZWQsIGtleXMsIG1hcCwgbWF0Y2hQYXR0ZXJuLCBtZXJnZSwgb21pdCwgcGljaywgcmVkdWNlLCBzZXQsIHNpemUsIHNvbWUsIHNvcnRCeSwgdGhyb3R0bGUsIHVuaW9uQnksIHVuaXF1ZUJ5LCB2YWx1ZXMsIHdpdGhvdXQgfTtcbiIsIi8qKlxuICogU2V0IGF0dHJpYnV0ZSBgbmFtZWAgdG8gYHZhbGAsIG9yIGdldCBhdHRyIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IFt2YWxdXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBhdHRyKGVsLCBuYW1lLCB2YWwpIHtcbiAgLy8gZ2V0XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICB9XG5cbiAgLy8gcmVtb3ZlXG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG5cbiAgLy8gc2V0XG4gIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWwpO1xuXG4gIHJldHVybiBlbDtcbn1cblxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG52YXIgaW5kZXhvZiA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvY2xhc3Nlc1xuICpcbiAqIFdpdGhvdXQgdGhlIGNvbXBvbmVudCBiaXRzLlxuICovXG5cbi8qKlxuICogV2hpdGVzcGFjZSByZWdleHAuXG4gKi9cblxudmFyIHJlID0gL1xccysvO1xuXG4vKipcbiAqIHRvU3RyaW5nIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdyYXAgYGVsYCBpbiBhIGBDbGFzc0xpc3RgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY2xhc3NlcyhlbCkge1xuICByZXR1cm4gbmV3IENsYXNzTGlzdChlbCk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBDbGFzc0xpc3QgZm9yIGBlbGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KGVsKSB7XG4gIGlmICghZWwgfHwgIWVsLm5vZGVUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIERPTSBlbGVtZW50IHJlZmVyZW5jZSBpcyByZXF1aXJlZCcpO1xuICB9XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5saXN0ID0gZWwuY2xhc3NMaXN0O1xufVxuXG4vKipcbiAqIEFkZCBjbGFzcyBgbmFtZWAgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIC8vIGNsYXNzTGlzdFxuICBpZiAodGhpcy5saXN0KSB7XG4gICAgdGhpcy5saXN0LmFkZChuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIHZhciBpID0gaW5kZXhvZihhcnIsIG5hbWUpO1xuICBpZiAoIX5pKSBhcnIucHVzaChuYW1lKTtcbiAgdGhpcy5lbC5jbGFzc05hbWUgPSBhcnIuam9pbignICcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIGBuYW1lYCB3aGVuIHByZXNlbnQsIG9yXG4gKiBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIHRvIHJlbW92ZVxuICogYW55IHdoaWNoIG1hdGNoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICgnW29iamVjdCBSZWdFeHBdJyA9PSB0b1N0cmluZy5jYWxsKG5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTWF0Y2hpbmcobmFtZSk7XG4gIH1cblxuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIHRoaXMubGlzdC5yZW1vdmUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICB2YXIgaSA9IGluZGV4b2YoYXJyLCBuYW1lKTtcbiAgaWYgKH5pKSBhcnIuc3BsaWNlKGksIDEpO1xuICB0aGlzLmVsLmNsYXNzTmFtZSA9IGFyci5qb2luKCcgJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGNsYXNzZXMgbWF0Y2hpbmcgYHJlYC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlTWF0Y2hpbmcgPSBmdW5jdGlvbiAocmUpIHtcbiAgdmFyIGFyciA9IHRoaXMuYXJyYXkoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmUudGVzdChhcnJbaV0pKSB7XG4gICAgICB0aGlzLnJlbW92ZShhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG9nZ2xlIGNsYXNzIGBuYW1lYCwgY2FuIGZvcmNlIHN0YXRlIHZpYSBgZm9yY2VgLlxuICpcbiAqIEZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgY2xhc3NMaXN0LCBidXQgZG8gbm90IHN1cHBvcnQgYGZvcmNlYCB5ZXQsXG4gKiB0aGUgbWlzdGFrZSB3aWxsIGJlIGRldGVjdGVkIGFuZCBjb3JyZWN0ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAobmFtZSwgZm9yY2UpIHtcbiAgLy8gY2xhc3NMaXN0XG4gIGlmICh0aGlzLmxpc3QpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBmb3JjZSkge1xuICAgICAgaWYgKGZvcmNlICE9PSB0aGlzLmxpc3QudG9nZ2xlKG5hbWUsIGZvcmNlKSkge1xuICAgICAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpOyAvLyB0b2dnbGUgYWdhaW4gdG8gY29ycmVjdFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgdGhpcy5yZW1vdmUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChuYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IG9mIGNsYXNzZXMuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjbGFzc05hbWUgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcbiAgdmFyIHN0ciA9IGNsYXNzTmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIHZhciBhcnIgPSBzdHIuc3BsaXQocmUpO1xuICBpZiAoJycgPT09IGFyclswXSkgYXJyLnNoaWZ0KCk7XG4gIHJldHVybiBhcnI7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGNsYXNzIGBuYW1lYCBpcyBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuaGFzID0gQ2xhc3NMaXN0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLmxpc3QgPyB0aGlzLmxpc3QuY29udGFpbnMobmFtZSkgOiAhIX5pbmRleG9mKHRoaXMuYXJyYXkoKSwgbmFtZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgY2hpbGRyZW4gZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gY2xlYXIoZWwpIHtcblxuICB2YXIgYztcblxuICB3aGlsZSAoZWwuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICBjID0gZWwuY2hpbGROb2Rlc1swXTtcbiAgICBlbC5yZW1vdmVDaGlsZChjKTtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxudmFyIHByb3RvID0gdHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gRWxlbWVudC5wcm90b3R5cGUgOiB7fTtcbnZhciB2ZW5kb3IgPSBwcm90by5tYXRjaGVzXG4gIHx8IHByb3RvLm1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm9NYXRjaGVzU2VsZWN0b3I7XG5cbnZhciBtYXRjaGVzU2VsZWN0b3IgPSBtYXRjaDtcblxuLyoqXG4gKiBNYXRjaCBgZWxgIHRvIGBzZWxlY3RvcmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBtYXRjaChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKCFlbCB8fCBlbC5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodmVuZG9yKSByZXR1cm4gdmVuZG9yLmNhbGwoZWwsIHNlbGVjdG9yKTtcbiAgdmFyIG5vZGVzID0gZWwucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXSA9PSBlbCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENsb3Nlc3RcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tZb3VyU2VsZiAob3B0aW9uYWwpXG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3QgKGVsZW1lbnQsIHNlbGVjdG9yLCBjaGVja1lvdXJTZWxmKSB7XG4gIHZhciBjdXJyZW50RWxlbSA9IGNoZWNrWW91clNlbGYgPyBlbGVtZW50IDogZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gIHdoaWxlIChjdXJyZW50RWxlbSAmJiBjdXJyZW50RWxlbS5ub2RlVHlwZSAhPT0gZG9jdW1lbnQuRE9DVU1FTlRfTk9ERSAmJiBjdXJyZW50RWxlbS5ub2RlVHlwZSAhPT0gZG9jdW1lbnQuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuXG4gICAgaWYgKG1hdGNoZXNTZWxlY3RvcihjdXJyZW50RWxlbSwgc2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm4gY3VycmVudEVsZW07XG4gICAgfVxuXG4gICAgY3VycmVudEVsZW0gPSBjdXJyZW50RWxlbS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXNTZWxlY3RvcihjdXJyZW50RWxlbSwgc2VsZWN0b3IpID8gY3VycmVudEVsZW0gOiBudWxsO1xufVxuXG52YXIgYmluZCA9IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ2F0dGFjaEV2ZW50JyxcbiAgICB1bmJpbmQgPSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciA/ICdyZW1vdmVFdmVudExpc3RlbmVyJyA6ICdkZXRhY2hFdmVudCcsXG4gICAgcHJlZml4ID0gYmluZCAhPT0gJ2FkZEV2ZW50TGlzdGVuZXInID8gJ29uJyA6ICcnO1xuXG4vKipcbiAqIEJpbmQgYGVsYCBldmVudCBgdHlwZWAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBiaW5kXzEgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICBlbFtiaW5kXShwcmVmaXggKyB0eXBlLCBmbiwgY2FwdHVyZSB8fCBmYWxzZSk7XG4gIHJldHVybiBmbjtcbn07XG5cbi8qKlxuICogVW5iaW5kIGBlbGAgZXZlbnQgYHR5cGVgJ3MgY2FsbGJhY2sgYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciB1bmJpbmRfMSA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIGVsW3VuYmluZF0ocHJlZml4ICsgdHlwZSwgZm4sIGNhcHR1cmUgfHwgZmFsc2UpO1xuICByZXR1cm4gZm47XG59O1xuXG52YXIgY29tcG9uZW50RXZlbnQgPSB7XG5cdGJpbmQ6IGJpbmRfMSxcblx0dW5iaW5kOiB1bmJpbmRfMVxufTtcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbi8qKlxuICogRGVsZWdhdGUgZXZlbnQgYHR5cGVgIHRvIGBzZWxlY3RvcmBcbiAqIGFuZCBpbnZva2UgYGZuKGUpYC4gQSBjYWxsYmFjayBmdW5jdGlvblxuICogaXMgcmV0dXJuZWQgd2hpY2ggbWF5IGJlIHBhc3NlZCB0byBgLnVuYmluZCgpYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLy8gU29tZSBldmVudHMgZG9uJ3QgYnViYmxlLCBzbyB3ZSB3YW50IHRvIGJpbmQgdG8gdGhlIGNhcHR1cmUgcGhhc2UgaW5zdGVhZFxuLy8gd2hlbiBkZWxlZ2F0aW5nLlxudmFyIGZvcmNlQ2FwdHVyZUV2ZW50cyA9IFsnZm9jdXMnLCAnYmx1ciddO1xuXG5mdW5jdGlvbiBiaW5kJDEoZWwsIHNlbGVjdG9yLCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuICBpZiAoZm9yY2VDYXB0dXJlRXZlbnRzLmluZGV4T2YodHlwZSkgIT09IC0xKSB7XG4gICAgY2FwdHVyZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50RXZlbnQuYmluZChlbCwgdHlwZSwgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIGUuZGVsZWdhdGVUYXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgc2VsZWN0b3IsIHRydWUsIGVsKTtcbiAgICBpZiAoZS5kZWxlZ2F0ZVRhcmdldCkge1xuICAgICAgZm4uY2FsbChlbCwgZSk7XG4gICAgfVxuICB9LCBjYXB0dXJlKTtcbn1cblxuLyoqXG4gKiBVbmJpbmQgZXZlbnQgYHR5cGVgJ3MgY2FsbGJhY2sgYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdW5iaW5kJDEoZWwsIHR5cGUsIGZuLCBjYXB0dXJlKSB7XG4gIGlmIChmb3JjZUNhcHR1cmVFdmVudHMuaW5kZXhPZih0eXBlKSAhPT0gLTEpIHtcbiAgICBjYXB0dXJlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRFdmVudC51bmJpbmQoZWwsIHR5cGUsIGZuLCBjYXB0dXJlKTtcbn1cblxudmFyIGRlbGVnYXRlID0ge1xuICBiaW5kOiBiaW5kJDEsXG4gIHVuYmluZDogdW5iaW5kJDFcbn07XG5cbi8qKlxuICogRXhwb3NlIGBwYXJzZWAuXG4gKi9cblxudmFyIGRvbWlmeSA9IHBhcnNlO1xuXG4vKipcbiAqIFRlc3RzIGZvciBicm93c2VyIHN1cHBvcnQuXG4gKi9cblxudmFyIGlubmVySFRNTEJ1ZyA9IGZhbHNlO1xudmFyIGJ1Z1Rlc3REaXY7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBidWdUZXN0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIC8vIFNldHVwXG4gIGJ1Z1Rlc3REaXYuaW5uZXJIVE1MID0gJyAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9XCIvYVwiPmE8L2E+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiLz4nO1xuICAvLyBNYWtlIHN1cmUgdGhhdCBsaW5rIGVsZW1lbnRzIGdldCBzZXJpYWxpemVkIGNvcnJlY3RseSBieSBpbm5lckhUTUxcbiAgLy8gVGhpcyByZXF1aXJlcyBhIHdyYXBwZXIgZWxlbWVudCBpbiBJRVxuICBpbm5lckhUTUxCdWcgPSAhYnVnVGVzdERpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpLmxlbmd0aDtcbiAgYnVnVGVzdERpdiA9IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBXcmFwIG1hcCBmcm9tIGpxdWVyeS5cbiAqL1xuXG52YXIgbWFwID0ge1xuICBsZWdlbmQ6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICB0cjogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG4gIGNvbDogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gIC8vIGZvciBzY3JpcHQvbGluay9zdHlsZSB0YWdzIHRvIHdvcmsgaW4gSUU2LTgsIHlvdSBoYXZlIHRvIHdyYXBcbiAgLy8gaW4gYSBkaXYgd2l0aCBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBpbiBmcm9udCwgaGEhXG4gIF9kZWZhdWx0OiBpbm5lckhUTUxCdWcgPyBbMSwgJ1g8ZGl2PicsICc8L2Rpdj4nXSA6IFswLCAnJywgJyddXG59O1xuXG5tYXAudGQgPVxubWFwLnRoID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbm1hcC5vcHRpb24gPVxubWFwLm9wdGdyb3VwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nLCAnPC9zZWxlY3Q+J107XG5cbm1hcC50aGVhZCA9XG5tYXAudGJvZHkgPVxubWFwLmNvbGdyb3VwID1cbm1hcC5jYXB0aW9uID1cbm1hcC50Zm9vdCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xuXG5tYXAucG9seWxpbmUgPVxubWFwLmVsbGlwc2UgPVxubWFwLnBvbHlnb24gPVxubWFwLmNpcmNsZSA9XG5tYXAudGV4dCA9XG5tYXAubGluZSA9XG5tYXAucGF0aCA9XG5tYXAucmVjdCA9XG5tYXAuZyA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmVyc2lvbj1cIjEuMVwiPicsJzwvc3ZnPiddO1xuXG4vKipcbiAqIFBhcnNlIGBodG1sYCBhbmQgcmV0dXJuIGEgRE9NIE5vZGUgaW5zdGFuY2UsIHdoaWNoIGNvdWxkIGJlIGEgVGV4dE5vZGUsXG4gKiBIVE1MIERPTSBOb2RlIG9mIHNvbWUga2luZCAoPGRpdj4gZm9yIGV4YW1wbGUpLCBvciBhIERvY3VtZW50RnJhZ21lbnRcbiAqIGluc3RhbmNlLCBkZXBlbmRpbmcgb24gdGhlIGNvbnRlbnRzIG9mIHRoZSBgaHRtbGAgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIC0gSFRNTCBzdHJpbmcgdG8gXCJkb21pZnlcIlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIC0gVGhlIGBkb2N1bWVudGAgaW5zdGFuY2UgdG8gY3JlYXRlIHRoZSBOb2RlIGZvclxuICogQHJldHVybiB7RE9NTm9kZX0gdGhlIFRleHROb2RlLCBET00gTm9kZSwgb3IgRG9jdW1lbnRGcmFnbWVudCBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UoaHRtbCwgZG9jKSB7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgaHRtbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkJyk7XG5cbiAgLy8gZGVmYXVsdCB0byB0aGUgZ2xvYmFsIGBkb2N1bWVudGAgb2JqZWN0XG4gIGlmICghZG9jKSBkb2MgPSBkb2N1bWVudDtcblxuICAvLyB0YWcgbmFtZVxuICB2YXIgbSA9IC88KFtcXHc6XSspLy5leGVjKGh0bWwpO1xuICBpZiAoIW0pIHJldHVybiBkb2MuY3JlYXRlVGV4dE5vZGUoaHRtbCk7XG5cbiAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpOyAvLyBSZW1vdmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlXG5cbiAgdmFyIHRhZyA9IG1bMV07XG5cbiAgLy8gYm9keSBzdXBwb3J0XG4gIGlmICh0YWcgPT0gJ2JvZHknKSB7XG4gICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBlbC5yZW1vdmVDaGlsZChlbC5sYXN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gd3JhcCBtYXBcbiAgdmFyIHdyYXAgPSBtYXBbdGFnXSB8fCBtYXAuX2RlZmF1bHQ7XG4gIHZhciBkZXB0aCA9IHdyYXBbMF07XG4gIHZhciBwcmVmaXggPSB3cmFwWzFdO1xuICB2YXIgc3VmZml4ID0gd3JhcFsyXTtcbiAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbC5pbm5lckhUTUwgPSBwcmVmaXggKyBodG1sICsgc3VmZml4O1xuICB3aGlsZSAoZGVwdGgtLSkgZWwgPSBlbC5sYXN0Q2hpbGQ7XG5cbiAgLy8gb25lIGVsZW1lbnRcbiAgaWYgKGVsLmZpcnN0Q2hpbGQgPT0gZWwubGFzdENoaWxkKSB7XG4gICAgcmV0dXJuIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBlbGVtZW50c1xuICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gcXVlcnkoc2VsZWN0b3IsIGVsKSB7XG4gIGVsID0gZWwgfHwgZG9jdW1lbnQ7XG5cbiAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBhbGwoc2VsZWN0b3IsIGVsKSB7XG4gIGVsID0gZWwgfHwgZG9jdW1lbnQ7XG5cbiAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoZWwpIHtcbiAgZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbn1cblxuZXhwb3J0IHsgYXR0ciwgY2xhc3NlcywgY2xlYXIsIGNsb3Nlc3QsIGRlbGVnYXRlLCBkb21pZnksIGNvbXBvbmVudEV2ZW50IGFzIGV2ZW50LCBtYXRjaGVzU2VsZWN0b3IgYXMgbWF0Y2hlcywgcXVlcnksIGFsbCBhcyBxdWVyeUFsbCwgcmVtb3ZlIH07XG4iLCJpbXBvcnQgeyBmb3JFYWNoLCBhc3NpZ24sIGZpbmQsIGZpbHRlciwgaGFzLCBpc1N0cmluZywgbWFwIH0gZnJvbSAnbWluLWRhc2gnO1xuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSAnc2F4ZW4nO1xuaW1wb3J0IHsgY29lcmNlVHlwZSwgcGFyc2VOYW1lTlMsIGlzU2ltcGxlVHlwZSwgTW9kZGxlIH0gZnJvbSAnbW9kZGxlJztcblxuZnVuY3Rpb24gaGFzTG93ZXJDYXNlQWxpYXMocGtnKSB7XG4gIHJldHVybiBwa2cueG1sICYmIHBrZy54bWwudGFnQWxpYXMgPT09ICdsb3dlckNhc2UnO1xufVxuXG52YXIgREVGQVVMVF9OU19NQVAgPSB7XG4gICd4c2knOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2UnLFxuICAneG1sJzogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbn07XG5cbnZhciBYU0lfVFlQRSA9ICd4c2k6dHlwZSc7XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvcm1hdChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnhtbCAmJiBlbGVtZW50LnhtbC5zZXJpYWxpemU7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFzVHlwZShlbGVtZW50KSB7XG4gIHJldHVybiBzZXJpYWxpemVGb3JtYXQoZWxlbWVudCkgPT09IFhTSV9UWVBFO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVBc1Byb3BlcnR5KGVsZW1lbnQpIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZUZvcm1hdChlbGVtZW50KSA9PT0gJ3Byb3BlcnR5Jztcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuZnVuY3Rpb24gYWxpYXNUb05hbWUoYWxpYXNOcywgcGtnKSB7XG5cbiAgaWYgKCFoYXNMb3dlckNhc2VBbGlhcyhwa2cpKSB7XG4gICAgcmV0dXJuIGFsaWFzTnMubmFtZTtcbiAgfVxuXG4gIHJldHVybiBhbGlhc05zLnByZWZpeCArICc6JyArIGNhcGl0YWxpemUoYWxpYXNOcy5sb2NhbE5hbWUpO1xufVxuXG5mdW5jdGlvbiBwcmVmaXhlZFRvTmFtZShuYW1lTnMsIHBrZykge1xuXG4gIHZhciBuYW1lID0gbmFtZU5zLm5hbWUsXG4gICAgICBsb2NhbE5hbWUgPSBuYW1lTnMubG9jYWxOYW1lO1xuXG4gIHZhciB0eXBlUHJlZml4ID0gcGtnLnhtbCAmJiBwa2cueG1sLnR5cGVQcmVmaXg7XG5cbiAgaWYgKHR5cGVQcmVmaXggJiYgbG9jYWxOYW1lLmluZGV4T2YodHlwZVByZWZpeCkgPT09IDApIHtcbiAgICByZXR1cm4gbmFtZU5zLnByZWZpeCArICc6JyArIGxvY2FsTmFtZS5zbGljZSh0eXBlUHJlZml4Lmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplWHNpVHlwZU5hbWUobmFtZSwgbW9kZWwpIHtcblxuICB2YXIgbmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSk7XG4gIHZhciBwa2cgPSBtb2RlbC5nZXRQYWNrYWdlKG5hbWVOcy5wcmVmaXgpO1xuXG4gIHJldHVybiBwcmVmaXhlZFRvTmFtZShuYW1lTnMsIHBrZyk7XG59XG5cbmZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1vZGRsZSBkZXNjcmlwdG9yIGZvciBhIGdpdmVuIGluc3RhbmNlIG9yIHR5cGUuXG4gKlxuICogQHBhcmFtICB7TW9kZGxlRWxlbWVudHxGdW5jdGlvbn0gZWxlbWVudFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG1vZGRsZSBkZXNjcmlwdG9yXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC4kZGVzY3JpcHRvcjtcbn1cblxuXG4vKipcbiAqIEEgcGFyc2UgY29udGV4dC5cbiAqXG4gKiBAY2xhc3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtFbGVtZW50SGFuZGxlcn0gb3B0aW9ucy5yb290SGFuZGxlciB0aGUgcm9vdCBoYW5kbGVyIGZvciBwYXJzaW5nIGEgZG9jdW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGF4PWZhbHNlXSB3aGV0aGVyIG9yIG5vdCB0byBpZ25vcmUgaW52YWxpZCBlbGVtZW50c1xuICovXG5mdW5jdGlvbiBDb250ZXh0KG9wdGlvbnMpIHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IHtFbGVtZW50SGFuZGxlcn0gcm9vdEhhbmRsZXJcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbGF4XG4gICAqL1xuXG4gIGFzc2lnbih0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLmVsZW1lbnRzQnlJZCA9IHt9O1xuICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcbiAgdGhpcy53YXJuaW5ncyA9IFtdO1xuXG4gIC8qKlxuICAgKiBBZGQgYW4gdW5yZXNvbHZlZCByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VcbiAgICovXG4gIHRoaXMuYWRkUmVmZXJlbmNlID0gZnVuY3Rpb24ocmVmZXJlbmNlKSB7XG4gICAgdGhpcy5yZWZlcmVuY2VzLnB1c2gocmVmZXJlbmNlKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgcHJvY2Vzc2VkIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgdGhpcy5hZGRFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICB0aHJvdyBlcnJvcignZXhwZWN0ZWQgZWxlbWVudCcpO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50c0J5SWQgPSB0aGlzLmVsZW1lbnRzQnlJZDtcblxuICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KTtcblxuICAgIHZhciBpZFByb3BlcnR5ID0gZGVzY3JpcHRvci5pZFByb3BlcnR5LFxuICAgICAgICBpZDtcblxuICAgIGlmIChpZFByb3BlcnR5KSB7XG4gICAgICBpZCA9IGVsZW1lbnQuZ2V0KGlkUHJvcGVydHkubmFtZSk7XG5cbiAgICAgIGlmIChpZCkge1xuXG4gICAgICAgIC8vIGZvciBRTmFtZSB2YWxpZGF0aW9uIGFzIHBlciBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lQ2hhclxuICAgICAgICBpZiAoIS9eKFthLXpdW1xcdy0uXSo6KT9bYS16X11bXFx3LS5dKiQvaS50ZXN0KGlkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBJRCA8JyArIGlkICsgJz4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50c0J5SWRbaWRdKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3IoJ2R1cGxpY2F0ZSBJRCA8JyArIGlkICsgJz4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzQnlJZFtpZF0gPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIGFuIGltcG9ydCB3YXJuaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gd2FybmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gd2FybmluZy5tZXNzYWdlXG4gICAqIEBwYXJhbSB7RXJyb3J9IFt3YXJuaW5nLmVycm9yXVxuICAgKi9cbiAgdGhpcy5hZGRXYXJuaW5nID0gZnVuY3Rpb24od2FybmluZykge1xuICAgIHRoaXMud2FybmluZ3MucHVzaCh3YXJuaW5nKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQmFzZUhhbmRsZXIoKSB7fVxuXG5CYXNlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7fTtcbkJhc2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVUZXh0ID0gZnVuY3Rpb24oKSB7fTtcbkJhc2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVOb2RlID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vKipcbiAqIEEgc2ltcGxlIHBhc3MgdGhyb3VnaCBoYW5kbGVyIHRoYXQgZG9lcyBub3RoaW5nIGV4Y2VwdCBmb3JcbiAqIGlnbm9yaW5nIGFsbCBpbnB1dCBpdCByZWNlaXZlcy5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgdG8gaWdub3JlIHVua25vd24gZWxlbWVudHMgYW5kXG4gKiBhdHRyaWJ1dGVzLlxuICovXG5mdW5jdGlvbiBOb29wSGFuZGxlcigpIHsgfVxuXG5Ob29wSGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VIYW5kbGVyLnByb3RvdHlwZSk7XG5cbk5vb3BIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVOb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gQm9keUhhbmRsZXIoKSB7fVxuXG5Cb2R5SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VIYW5kbGVyLnByb3RvdHlwZSk7XG5cbkJvZHlIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICB0aGlzLmJvZHkgPSAodGhpcy5ib2R5IHx8ICcnKSArIHRleHQ7XG59O1xuXG5mdW5jdGlvbiBSZWZlcmVuY2VIYW5kbGVyKHByb3BlcnR5LCBjb250ZXh0KSB7XG4gIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUmVmZXJlbmNlSGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJvZHlIYW5kbGVyLnByb3RvdHlwZSk7XG5cblJlZmVyZW5jZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgIHRocm93IGVycm9yKCdleHBlY3RlZCBubyBzdWIgbm9kZXMnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNyZWF0ZVJlZmVyZW5jZShub2RlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVmZXJlbmNlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudC5pZCA9IHRoaXMuYm9keTtcbn07XG5cblJlZmVyZW5jZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVJlZmVyZW5jZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9wZXJ0eTogdGhpcy5wcm9wZXJ0eS5ucy5uYW1lLFxuICAgIGlkOiAnJ1xuICB9O1xufTtcblxuZnVuY3Rpb24gVmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLnByb3BlcnR5RGVzYyA9IHByb3BlcnR5RGVzYztcbn1cblxuVmFsdWVIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQm9keUhhbmRsZXIucHJvdG90eXBlKTtcblxuVmFsdWVIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgdmFsdWUgPSB0aGlzLmJvZHkgfHwgJycsXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgcHJvcGVydHlEZXNjID0gdGhpcy5wcm9wZXJ0eURlc2M7XG5cbiAgdmFsdWUgPSBjb2VyY2VUeXBlKHByb3BlcnR5RGVzYy50eXBlLCB2YWx1ZSk7XG5cbiAgaWYgKHByb3BlcnR5RGVzYy5pc01hbnkpIHtcbiAgICBlbGVtZW50LmdldChwcm9wZXJ0eURlc2MubmFtZSkucHVzaCh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5zZXQocHJvcGVydHlEZXNjLm5hbWUsIHZhbHVlKTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBCYXNlRWxlbWVudEhhbmRsZXIoKSB7fVxuXG5CYXNlRWxlbWVudEhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCb2R5SGFuZGxlci5wcm90b3R5cGUpO1xuXG5CYXNlRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBwYXJzZXIgPSB0aGlzLFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KG5vZGUpO1xuXG4gICAgdGhpcy5jb250ZXh0LmFkZEVsZW1lbnQoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VyID0gdGhpcy5oYW5kbGVDaGlsZChub2RlKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXI7XG59O1xuXG4vKipcbiAqIEBjbGFzcyBSZWFkZXIuRWxlbWVudEhhbmRsZXJcbiAqXG4gKi9cbmZ1bmN0aW9uIEVsZW1lbnRIYW5kbGVyKG1vZGVsLCB0eXBlTmFtZSwgY29udGV4dCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMudHlwZSA9IG1vZGVsLmdldFR5cGUodHlwZU5hbWUpO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUpO1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUuYWRkUmVmZXJlbmNlID0gZnVuY3Rpb24ocmVmZXJlbmNlKSB7XG4gIHRoaXMuY29udGV4dC5hZGRSZWZlcmVuY2UocmVmZXJlbmNlKTtcbn07XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuXG4gIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgZGVzY3JpcHRvciA9IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudCksXG4gICAgICBib2R5UHJvcGVydHkgPSBkZXNjcmlwdG9yLmJvZHlQcm9wZXJ0eTtcblxuICBpZiAoIWJvZHlQcm9wZXJ0eSkge1xuICAgIHRocm93IGVycm9yKCd1bmV4cGVjdGVkIGJvZHkgdGV4dCA8JyArIHRleHQgKyAnPicpO1xuICB9XG5cbiAgQm9keUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQuY2FsbCh0aGlzLCB0ZXh0KTtcbn07XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgdmFsdWUgPSB0aGlzLmJvZHksXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgZGVzY3JpcHRvciA9IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudCksXG4gICAgICBib2R5UHJvcGVydHkgPSBkZXNjcmlwdG9yLmJvZHlQcm9wZXJ0eTtcblxuICBpZiAoYm9keVByb3BlcnR5ICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGNvZXJjZVR5cGUoYm9keVByb3BlcnR5LnR5cGUsIHZhbHVlKTtcbiAgICBlbGVtZW50LnNldChib2R5UHJvcGVydHkubmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgbW9kZWwgZnJvbSB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlIHRoZSB4bWwgbm9kZVxuICovXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICBUeXBlID0gdGhpcy50eXBlLFxuICAgICAgZGVzY3JpcHRvciA9IGdldE1vZGRsZURlc2NyaXB0b3IoVHlwZSksXG4gICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgaW5zdGFuY2UgPSBuZXcgVHlwZSh7fSksXG4gICAgICBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICBwcm9wTmFtZU5zO1xuXG4gIGZvckVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblxuICAgIHZhciBwcm9wID0gZGVzY3JpcHRvci5wcm9wZXJ0aWVzQnlOYW1lW25hbWVdLFxuICAgICAgICB2YWx1ZXM7XG5cbiAgICBpZiAocHJvcCAmJiBwcm9wLmlzUmVmZXJlbmNlKSB7XG5cbiAgICAgIGlmICghcHJvcC5pc01hbnkpIHtcbiAgICAgICAgY29udGV4dC5hZGRSZWZlcmVuY2Uoe1xuICAgICAgICAgIGVsZW1lbnQ6IGluc3RhbmNlLFxuICAgICAgICAgIHByb3BlcnR5OiBwcm9wLm5zLm5hbWUsXG4gICAgICAgICAgaWQ6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBJRFJFRlM6IHBhcnNlIHJlZmVyZW5jZXMgYXMgd2hpdGVzcGFjZS1zZXBhcmF0ZWQgbGlzdFxuICAgICAgICB2YWx1ZXMgPSB2YWx1ZS5zcGxpdCgnICcpO1xuXG4gICAgICAgIGZvckVhY2godmFsdWVzLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgY29udGV4dC5hZGRSZWZlcmVuY2Uoe1xuICAgICAgICAgICAgZWxlbWVudDogaW5zdGFuY2UsXG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcC5ucy5uYW1lLFxuICAgICAgICAgICAgaWQ6IHZcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgdmFsdWUgPSBjb2VyY2VUeXBlKHByb3AudHlwZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlXG4gICAgICBpZiAobmFtZSAhPT0gJ3htbG5zJykge1xuICAgICAgICBwcm9wTmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSwgZGVzY3JpcHRvci5ucy5wcmVmaXgpO1xuXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXR0cmlidXRlIGlzIGRlZmluZWQgaW4gYSB3ZWxsLWtub3duIG5hbWVzcGFjZVxuICAgICAgICAvLyBpZiB0aGF0IGlzIHRoZSBjYXNlIHdlIGVtaXQgYSB3YXJuaW5nIHRvIGluZGljYXRlIHBvdGVudGlhbCBtaXN1c2VcbiAgICAgICAgaWYgKG1vZGVsLmdldFBhY2thZ2UocHJvcE5hbWVOcy5wcmVmaXgpKSB7XG5cbiAgICAgICAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ3Vua25vd24gYXR0cmlidXRlIDwnICsgbmFtZSArICc+JyxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGluc3RhbmNlLFxuICAgICAgICAgICAgcHJvcGVydHk6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmdldFByb3BlcnR5Rm9yTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgdmFyIG5hbWVOcyA9IHBhcnNlTmFtZU5TKG5hbWUpO1xuXG4gIHZhciB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsLFxuICAgICAgZGVzY3JpcHRvciA9IGdldE1vZGRsZURlc2NyaXB0b3IodHlwZSk7XG5cbiAgdmFyIHByb3BlcnR5TmFtZSA9IG5hbWVOcy5uYW1lLFxuICAgICAgcHJvcGVydHkgPSBkZXNjcmlwdG9yLnByb3BlcnRpZXNCeU5hbWVbcHJvcGVydHlOYW1lXSxcbiAgICAgIGVsZW1lbnRUeXBlTmFtZSxcbiAgICAgIGVsZW1lbnRUeXBlO1xuXG4gIC8vIHNlYXJjaCBmb3IgcHJvcGVydGllcyBieSBuYW1lIGZpcnN0XG5cbiAgaWYgKHByb3BlcnR5ICYmICFwcm9wZXJ0eS5pc0F0dHIpIHtcblxuICAgIGlmIChzZXJpYWxpemVBc1R5cGUocHJvcGVydHkpKSB7XG4gICAgICBlbGVtZW50VHlwZU5hbWUgPSBub2RlLmF0dHJpYnV0ZXNbWFNJX1RZUEVdO1xuXG4gICAgICAvLyB4c2kgdHlwZSBpcyBvcHRpb25hbCwgaWYgaXQgZG9lcyBub3QgZXhpc3RzIHRoZVxuICAgICAgLy8gZGVmYXVsdCB0eXBlIGlzIGFzc3VtZWRcbiAgICAgIGlmIChlbGVtZW50VHlwZU5hbWUpIHtcblxuICAgICAgICAvLyB0YWtlIHBvc3NpYmxlIHR5cGUgcHJlZml4ZXMgZnJvbSBYTUxcbiAgICAgICAgLy8gaW50byBhY2NvdW50LCBpLmUuOiB4c2k6dHlwZT1cInR7QWN0dWFsVHlwZX1cIlxuICAgICAgICBlbGVtZW50VHlwZU5hbWUgPSBub3JtYWxpemVYc2lUeXBlTmFtZShlbGVtZW50VHlwZU5hbWUsIG1vZGVsKTtcblxuICAgICAgICBlbGVtZW50VHlwZSA9IG1vZGVsLmdldFR5cGUoZWxlbWVudFR5cGVOYW1lKTtcblxuICAgICAgICByZXR1cm4gYXNzaWduKHt9LCBwcm9wZXJ0eSwge1xuICAgICAgICAgIGVmZmVjdGl2ZVR5cGU6IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudFR5cGUpLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2VhcmNoIGZvciBwcm9wZXJ0aWVzIGJ5IG5hbWUgZmlyc3RcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH1cblxuICB2YXIgcGtnID0gbW9kZWwuZ2V0UGFja2FnZShuYW1lTnMucHJlZml4KTtcblxuICBpZiAocGtnKSB7XG4gICAgZWxlbWVudFR5cGVOYW1lID0gYWxpYXNUb05hbWUobmFtZU5zLCBwa2cpO1xuICAgIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0VHlwZShlbGVtZW50VHlwZU5hbWUpO1xuXG4gICAgLy8gc2VhcmNoIGZvciBjb2xsZWN0aW9uIG1lbWJlcnMgbGF0ZXJcbiAgICBwcm9wZXJ0eSA9IGZpbmQoZGVzY3JpcHRvci5wcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gIXAuaXNWaXJ0dWFsICYmICFwLmlzUmVmZXJlbmNlICYmICFwLmlzQXR0cmlidXRlICYmIGVsZW1lbnRUeXBlLmhhc1R5cGUocC50eXBlKTtcbiAgICB9KTtcblxuICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIGFzc2lnbih7fSwgcHJvcGVydHksIHtcbiAgICAgICAgZWZmZWN0aXZlVHlwZTogZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50VHlwZSkubmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuXG4gICAgLy8gcGFyc2UgdW5rbm93biBlbGVtZW50IChtYXliZSBleHRlbnNpb24pXG4gICAgcHJvcGVydHkgPSBmaW5kKGRlc2NyaXB0b3IucHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuICFwLmlzUmVmZXJlbmNlICYmICFwLmlzQXR0cmlidXRlICYmIHAudHlwZSA9PT0gJ0VsZW1lbnQnO1xuICAgIH0pO1xuXG4gICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gcHJvcGVydHk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgZXJyb3IoJ3VucmVjb2duaXplZCBlbGVtZW50IDwnICsgbmFtZU5zLm5hbWUgKyAnPicpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnRWxlbWVudERlc2NyaXB0b3JbJyArIGdldE1vZGRsZURlc2NyaXB0b3IodGhpcy50eXBlKS5uYW1lICsgJ10nO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnZhbHVlSGFuZGxlciA9IGZ1bmN0aW9uKHByb3BlcnR5RGVzYywgZWxlbWVudCkge1xuICByZXR1cm4gbmV3IFZhbHVlSGFuZGxlcihwcm9wZXJ0eURlc2MsIGVsZW1lbnQpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnJlZmVyZW5jZUhhbmRsZXIgPSBmdW5jdGlvbihwcm9wZXJ0eURlc2MpIHtcbiAgcmV0dXJuIG5ldyBSZWZlcmVuY2VIYW5kbGVyKHByb3BlcnR5RGVzYywgdGhpcy5jb250ZXh0KTtcbn07XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodHlwZSA9PT0gJ0VsZW1lbnQnKSB7XG4gICAgcmV0dXJuIG5ldyBHZW5lcmljRWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgdHlwZSwgdGhpcy5jb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnRIYW5kbGVyKHRoaXMubW9kZWwsIHR5cGUsIHRoaXMuY29udGV4dCk7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIHRoZSBjaGlsZCBlbGVtZW50IHBhcnNpbmdcbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlIHRoZSB4bWwgbm9kZVxuICovXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlQ2hpbGQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBwcm9wZXJ0eURlc2MsIHR5cGUsIGVsZW1lbnQsIGNoaWxkSGFuZGxlcjtcblxuICBwcm9wZXJ0eURlc2MgPSB0aGlzLmdldFByb3BlcnR5Rm9yTm9kZShub2RlKTtcbiAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICB0eXBlID0gcHJvcGVydHlEZXNjLmVmZmVjdGl2ZVR5cGUgfHwgcHJvcGVydHlEZXNjLnR5cGU7XG5cbiAgaWYgKGlzU2ltcGxlVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlSGFuZGxlcihwcm9wZXJ0eURlc2MsIGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5RGVzYy5pc1JlZmVyZW5jZSkge1xuICAgIGNoaWxkSGFuZGxlciA9IHRoaXMucmVmZXJlbmNlSGFuZGxlcihwcm9wZXJ0eURlc2MpLmhhbmRsZU5vZGUobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRIYW5kbGVyID0gdGhpcy5oYW5kbGVyKHR5cGUpLmhhbmRsZU5vZGUobm9kZSk7XG4gIH1cblxuICB2YXIgbmV3RWxlbWVudCA9IGNoaWxkSGFuZGxlci5lbGVtZW50O1xuXG4gIC8vIGNoaWxkIGhhbmRsZXMgbWF5IGRlY2lkZSB0byBza2lwIGVsZW1lbnRzXG4gIC8vIGJ5IG5vdCByZXR1cm5pbmcgYW55dGhpbmdcbiAgaWYgKG5ld0VsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgaWYgKHByb3BlcnR5RGVzYy5pc01hbnkpIHtcbiAgICAgIGVsZW1lbnQuZ2V0KHByb3BlcnR5RGVzYy5uYW1lKS5wdXNoKG5ld0VsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNldChwcm9wZXJ0eURlc2MubmFtZSwgbmV3RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5RGVzYy5pc1JlZmVyZW5jZSkge1xuICAgICAgYXNzaWduKG5ld0VsZW1lbnQsIHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY29udGV4dC5hZGRSZWZlcmVuY2UobmV3RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gZXN0YWJsaXNoIGNoaWxkIC0+IHBhcmVudCByZWxhdGlvbnNoaXBcbiAgICAgIG5ld0VsZW1lbnQuJHBhcmVudCA9IGVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkSGFuZGxlcjtcbn07XG5cbi8qKlxuICogQW4gZWxlbWVudCBoYW5kbGVyIHRoYXQgcGVyZm9ybXMgc3BlY2lhbCB2YWxpZGF0aW9uXG4gKiB0byBlbnN1cmUgdGhlIG5vZGUgaXQgZ2V0cyBpbml0aWFsaXplZCB3aXRoIG1hdGNoZXNcbiAqIHRoZSBoYW5kbGVycyB0eXBlIChuYW1lc3BhY2Ugd2lzZSkuXG4gKlxuICogQHBhcmFtIHtNb2RkbGV9IG1vZGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZU5hbWVcbiAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBSb290RWxlbWVudEhhbmRsZXIobW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KSB7XG4gIEVsZW1lbnRIYW5kbGVyLmNhbGwodGhpcywgbW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KTtcbn1cblxuUm9vdEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRWxlbWVudEhhbmRsZXIucHJvdG90eXBlKTtcblxuUm9vdEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lLFxuICAgICAgbmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSksXG4gICAgICBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgcGtnID0gbW9kZWwuZ2V0UGFja2FnZShuYW1lTnMucHJlZml4KSxcbiAgICAgIHR5cGVOYW1lID0gcGtnICYmIGFsaWFzVG9OYW1lKG5hbWVOcywgcGtnKSB8fCBuYW1lO1xuXG4gIC8vIHZlcmlmeSB0aGUgY29ycmVjdCBuYW1lc3BhY2UgaWYgd2UgcGFyc2VcbiAgLy8gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGhhbmRsZXIgdHJlZVxuICAvL1xuICAvLyB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgbWlzdGFrZW5seSBpbXBvcnQgd3JvbmcgbmFtZXNwYWNlIGVsZW1lbnRzXG4gIGlmICghdHlwZS5oYXNUeXBlKHR5cGVOYW1lKSkge1xuICAgIHRocm93IGVycm9yKCd1bmV4cGVjdGVkIGVsZW1lbnQgPCcgKyBub2RlLm9yaWdpbmFsTmFtZSArICc+Jyk7XG4gIH1cblxuICByZXR1cm4gRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBub2RlKTtcbn07XG5cblxuZnVuY3Rpb24gR2VuZXJpY0VsZW1lbnRIYW5kbGVyKG1vZGVsLCB0eXBlTmFtZSwgY29udGV4dCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkdlbmVyaWNFbGVtZW50SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUpO1xuXG5HZW5lcmljRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWUsXG4gICAgICBucyA9IHBhcnNlTmFtZU5TKG5hbWUpLFxuICAgICAgcHJlZml4ID0gbnMucHJlZml4LFxuICAgICAgdXJpID0gbm9kZS5uc1twcmVmaXggKyAnJHVyaSddLFxuICAgICAgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcblxuICByZXR1cm4gdGhpcy5tb2RlbC5jcmVhdGVBbnkobmFtZSwgdXJpLCBhdHRyaWJ1dGVzKTtcbn07XG5cbkdlbmVyaWNFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlQ2hpbGQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgdmFyIGhhbmRsZXIgPSBuZXcgR2VuZXJpY0VsZW1lbnRIYW5kbGVyKHRoaXMubW9kZWwsICdFbGVtZW50JywgdGhpcy5jb250ZXh0KS5oYW5kbGVOb2RlKG5vZGUpLFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICB2YXIgbmV3RWxlbWVudCA9IGhhbmRsZXIuZWxlbWVudCxcbiAgICAgIGNoaWxkcmVuO1xuXG4gIGlmIChuZXdFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjaGlsZHJlbiA9IGVsZW1lbnQuJGNoaWxkcmVuID0gZWxlbWVudC4kY2hpbGRyZW4gfHwgW107XG4gICAgY2hpbGRyZW4ucHVzaChuZXdFbGVtZW50KTtcblxuICAgIC8vIGVzdGFibGlzaCBjaGlsZCAtPiBwYXJlbnQgcmVsYXRpb25zaGlwXG4gICAgbmV3RWxlbWVudC4kcGFyZW50ID0gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuR2VuZXJpY0VsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuYm9keSkge1xuICAgIHRoaXMuZWxlbWVudC4kYm9keSA9IHRoaXMuYm9keTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIHJlYWRlciBmb3IgYSBtZXRhLW1vZGVsXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TW9kZWx9IG9wdGlvbnMubW9kZWwgdXNlZCB0byByZWFkIHhtbCBmaWxlc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmxheCB3aGV0aGVyIHRvIG1ha2UgcGFyc2UgZXJyb3JzIHdhcm5pbmdzXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihvcHRpb25zKSB7XG5cbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBNb2RkbGUpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbW9kZWw6IG9wdGlvbnNcbiAgICB9O1xuICB9XG5cbiAgYXNzaWduKHRoaXMsIHsgbGF4OiBmYWxzZSB9LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBUaGUgZnJvbVhNTCByZXN1bHQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUGFyc2VSZXN1bHRcbiAqXG4gKiBAcHJvcGVydHkge01vZGRsZUVsZW1lbnR9IHJvb3RFbGVtZW50XG4gKiBAcHJvcGVydHkge0FycmF5PE9iamVjdD59IHJlZmVyZW5jZXNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8RXJyb3I+fSB3YXJuaW5nc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGVsZW1lbnRzQnlJZCAtIGEgbWFwcGluZyBjb250YWluaW5nIGVhY2ggSUQgLT4gTW9kZGxlRWxlbWVudFxuICovXG5cbi8qKlxuICogVGhlIGZyb21YTUwgcmVzdWx0LlxuICpcbiAqIEB0eXBlZGVmIHtFcnJvcn0gUGFyc2VFcnJvclxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8RXJyb3I+fSB3YXJuaW5nc1xuICovXG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIFhNTCBpbnRvIGEgbW9kZGxlIGRvY3VtZW50IHRyZWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHhtbFxuICogQHBhcmFtIHtFbGVtZW50SGFuZGxlcnxPYmplY3R9IG9wdGlvbnMgb3Igcm9vdEhhbmRsZXJcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxQYXJzZVJlc3VsdCwgUGFyc2VFcnJvcj59XG4gKi9cblJlYWRlci5wcm90b3R5cGUuZnJvbVhNTCA9IGZ1bmN0aW9uKHhtbCwgb3B0aW9ucywgZG9uZSkge1xuXG4gIHZhciByb290SGFuZGxlciA9IG9wdGlvbnMucm9vdEhhbmRsZXI7XG5cbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBFbGVtZW50SGFuZGxlcikge1xuXG4gICAgLy8gcm9vdCBoYW5kbGVyIHBhc3NlZCB2aWEgKHhtbCwgeyByb290SGFuZGxlcjogRWxlbWVudEhhbmRsZXIgfSwgLi4uKVxuICAgIHJvb3RIYW5kbGVyID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuXG4gICAgICAvLyByb290SGFuZGxlciBwYXNzZWQgdmlhICh4bWwsICdzb21lU3RyaW5nJywgLi4uKVxuICAgICAgcm9vdEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIob3B0aW9ucyk7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygcm9vdEhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgIC8vIHJvb3RIYW5kbGVyIHBhc3NlZCB2aWEgKHhtbCwgeyByb290SGFuZGxlcjogJ3NvbWVTdHJpbmcnIH0sIC4uLilcbiAgICAgIHJvb3RIYW5kbGVyID0gdGhpcy5oYW5kbGVyKHJvb3RIYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsLFxuICAgICAgbGF4ID0gdGhpcy5sYXg7XG5cbiAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dChhc3NpZ24oe30sIG9wdGlvbnMsIHsgcm9vdEhhbmRsZXI6IHJvb3RIYW5kbGVyIH0pKSxcbiAgICAgIHBhcnNlciA9IG5ldyBQYXJzZXIoeyBwcm94eTogdHJ1ZSB9KSxcbiAgICAgIHN0YWNrID0gY3JlYXRlU3RhY2soKTtcblxuICByb290SGFuZGxlci5jb250ZXh0ID0gY29udGV4dDtcblxuICAvLyBwdXNoIHJvb3QgaGFuZGxlclxuICBzdGFjay5wdXNoKHJvb3RIYW5kbGVyKTtcblxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSAge0Vycm9yfSBlcnJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGdldENvbnRleHRcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbGF4XG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgaGFuZGxlZFxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBnZXRDb250ZXh0LCBsYXgpIHtcblxuICAgIHZhciBjdHggPSBnZXRDb250ZXh0KCk7XG5cbiAgICB2YXIgbGluZSA9IGN0eC5saW5lLFxuICAgICAgICBjb2x1bW4gPSBjdHguY29sdW1uLFxuICAgICAgICBkYXRhID0gY3R4LmRhdGE7XG5cbiAgICAvLyB3ZSByZWNlaXZlIHRoZSBmdWxsIGNvbnRleHQgZGF0YSBoZXJlLFxuICAgIC8vIGZvciBlbGVtZW50cyB0cmltIGRvd24gdGhlIGluZm9ybWF0aW9uXG4gICAgLy8gdG8gdGhlIHRhZyBuYW1lLCBvbmx5XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnPCcgJiYgZGF0YS5pbmRleE9mKCcgJykgIT09IC0xKSB7XG4gICAgICBkYXRhID0gZGF0YS5zbGljZSgwLCBkYXRhLmluZGV4T2YoJyAnKSkgKyAnPic7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPVxuICAgICAgJ3VucGFyc2FibGUgY29udGVudCAnICsgKGRhdGEgPyBkYXRhICsgJyAnIDogJycpICsgJ2RldGVjdGVkXFxuXFx0JyArXG4gICAgICAgICdsaW5lOiAnICsgbGluZSArICdcXG5cXHQnICtcbiAgICAgICAgJ2NvbHVtbjogJyArIGNvbHVtbiArICdcXG5cXHQnICtcbiAgICAgICAgJ25lc3RlZCBlcnJvcjogJyArIGVyci5tZXNzYWdlO1xuXG4gICAgaWYgKGxheCkge1xuICAgICAgY29udGV4dC5hZGRXYXJuaW5nKHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgZXJyb3I6IGVyclxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVXYXJuaW5nKGVyciwgZ2V0Q29udGV4dCkge1xuXG4gICAgLy8ganVzdCBsaWtlIGhhbmRsaW5nIGVycm9ycyBpbiA8bGF4PXRydWU+IG1vZGVcbiAgICByZXR1cm4gaGFuZGxlRXJyb3IoZXJyLCBnZXRDb250ZXh0LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGNvbGxlY3RlZCByZWZlcmVuY2VzIG9uIHBhcnNlIGVuZC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlc29sdmVSZWZlcmVuY2VzKCkge1xuXG4gICAgdmFyIGVsZW1lbnRzQnlJZCA9IGNvbnRleHQuZWxlbWVudHNCeUlkO1xuICAgIHZhciByZWZlcmVuY2VzID0gY29udGV4dC5yZWZlcmVuY2VzO1xuXG4gICAgdmFyIGksIHI7XG5cbiAgICBmb3IgKGkgPSAwOyAociA9IHJlZmVyZW5jZXNbaV0pOyBpKyspIHtcbiAgICAgIHZhciBlbGVtZW50ID0gci5lbGVtZW50O1xuICAgICAgdmFyIHJlZmVyZW5jZSA9IGVsZW1lbnRzQnlJZFtyLmlkXTtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudCkucHJvcGVydGllc0J5TmFtZVtyLnByb3BlcnR5XTtcblxuICAgICAgaWYgKCFyZWZlcmVuY2UpIHtcbiAgICAgICAgY29udGV4dC5hZGRXYXJuaW5nKHtcbiAgICAgICAgICBtZXNzYWdlOiAndW5yZXNvbHZlZCByZWZlcmVuY2UgPCcgKyByLmlkICsgJz4nLFxuICAgICAgICAgIGVsZW1lbnQ6IHIuZWxlbWVudCxcbiAgICAgICAgICBwcm9wZXJ0eTogci5wcm9wZXJ0eSxcbiAgICAgICAgICB2YWx1ZTogci5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BlcnR5LmlzTWFueSkge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IGVsZW1lbnQuZ2V0KHByb3BlcnR5Lm5hbWUpLFxuICAgICAgICAgICAgaWR4ID0gY29sbGVjdGlvbi5pbmRleE9mKHIpO1xuXG4gICAgICAgIC8vIHdlIHJlcGxhY2UgYW4gZXhpc3RpbmcgcGxhY2UgaG9sZGVyIChpZHggIT0gLTEpIG9yXG4gICAgICAgIC8vIGFwcGVuZCB0byB0aGUgY29sbGVjdGlvbiBpbnN0ZWFkXG4gICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgaWR4ID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZmVyZW5jZSkge1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIHVucmVzb2x2YWJsZSByZWZlcmVuY2VcbiAgICAgICAgICBjb2xsZWN0aW9uLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gYWRkIG9yIHVwZGF0ZSByZWZlcmVuY2UgaW4gY29sbGVjdGlvblxuICAgICAgICAgIGNvbGxlY3Rpb25baWR4XSA9IHJlZmVyZW5jZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXQocHJvcGVydHkubmFtZSwgcmVmZXJlbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbG9zZSgpIHtcbiAgICBzdGFjay5wb3AoKS5oYW5kbGVFbmQoKTtcbiAgfVxuXG4gIHZhciBQUkVBTUJMRV9TVEFSVF9QQVRURVJOID0gL148XFw/eG1sIC9pO1xuXG4gIHZhciBFTkNPRElOR19QQVRURVJOID0gLyBlbmNvZGluZz1cIihbXlwiXSspXCIvaTtcblxuICB2YXIgVVRGXzhfUEFUVEVSTiA9IC9edXRmLTgkL2k7XG5cbiAgZnVuY3Rpb24gaGFuZGxlUXVlc3Rpb24ocXVlc3Rpb24pIHtcblxuICAgIGlmICghUFJFQU1CTEVfU1RBUlRfUEFUVEVSTi50ZXN0KHF1ZXN0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IEVOQ09ESU5HX1BBVFRFUk4uZXhlYyhxdWVzdGlvbik7XG4gICAgdmFyIGVuY29kaW5nID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG5cbiAgICBpZiAoIWVuY29kaW5nIHx8IFVURl84X1BBVFRFUk4udGVzdChlbmNvZGluZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgbWVzc2FnZTpcbiAgICAgICAgJ3Vuc3VwcG9ydGVkIGRvY3VtZW50IGVuY29kaW5nIDwnICsgZW5jb2RpbmcgKyAnPiwgJyArXG4gICAgICAgICdmYWxsaW5nIGJhY2sgdG8gVVRGLTgnXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVPcGVuKG5vZGUsIGdldENvbnRleHQpIHtcbiAgICB2YXIgaGFuZGxlciA9IHN0YWNrLnBlZWsoKTtcblxuICAgIHRyeSB7XG4gICAgICBzdGFjay5wdXNoKGhhbmRsZXIuaGFuZGxlTm9kZShub2RlKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG5cbiAgICAgIGlmIChoYW5kbGVFcnJvcihlcnIsIGdldENvbnRleHQsIGxheCkpIHtcbiAgICAgICAgc3RhY2sucHVzaChuZXcgTm9vcEhhbmRsZXIoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ0RhdGEodGV4dCwgZ2V0Q29udGV4dCkge1xuXG4gICAgdHJ5IHtcbiAgICAgIHN0YWNrLnBlZWsoKS5oYW5kbGVUZXh0KHRleHQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaGFuZGxlV2FybmluZyhlcnIsIGdldENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRleHQodGV4dCwgZ2V0Q29udGV4dCkge1xuXG4gICAgLy8gc3RyaXAgd2hpdGVzcGFjZSBvbmx5IG5vZGVzLCBpLmUuIGJlZm9yZVxuICAgIC8vIDwhQ0RBVEFbIC4uLiBdPiBzZWN0aW9ucyBhbmQgaW4gYmV0d2VlbiB0YWdzXG4gICAgdGV4dCA9IHRleHQudHJpbSgpO1xuXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFuZGxlQ0RhdGEodGV4dCwgZ2V0Q29udGV4dCk7XG4gIH1cblxuICB2YXIgdXJpTWFwID0gbW9kZWwuZ2V0UGFja2FnZXMoKS5yZWR1Y2UoZnVuY3Rpb24odXJpTWFwLCBwKSB7XG4gICAgdXJpTWFwW3AudXJpXSA9IHAucHJlZml4O1xuXG4gICAgcmV0dXJuIHVyaU1hcDtcbiAgfSwge1xuICAgICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnOiAneG1sJyAvLyBhZGQgZGVmYXVsdCB4bWwgbnNcbiAgfSk7XG4gIHBhcnNlclxuICAgIC5ucyh1cmlNYXApXG4gICAgLm9uKCdvcGVuVGFnJywgZnVuY3Rpb24ob2JqLCBkZWNvZGVTdHIsIHNlbGZDbG9zaW5nLCBnZXRDb250ZXh0KSB7XG5cbiAgICAgIC8vIGdyYWNlZnVsbHkgaGFuZGxlIHVucGFyc2FibGUgYXR0cmlidXRlcyAoYXR0cnM9ZmFsc2UpXG4gICAgICB2YXIgYXR0cnMgPSBvYmouYXR0cnMgfHwge307XG5cbiAgICAgIHZhciBkZWNvZGVkQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykucmVkdWNlKGZ1bmN0aW9uKGQsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkZWNvZGVTdHIoYXR0cnNba2V5XSk7XG5cbiAgICAgICAgZFtrZXldID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9LCB7fSk7XG5cbiAgICAgIHZhciBub2RlID0ge1xuICAgICAgICBuYW1lOiBvYmoubmFtZSxcbiAgICAgICAgb3JpZ2luYWxOYW1lOiBvYmoub3JpZ2luYWxOYW1lLFxuICAgICAgICBhdHRyaWJ1dGVzOiBkZWNvZGVkQXR0cnMsXG4gICAgICAgIG5zOiBvYmoubnNcbiAgICAgIH07XG5cbiAgICAgIGhhbmRsZU9wZW4obm9kZSwgZ2V0Q29udGV4dCk7XG4gICAgfSlcbiAgICAub24oJ3F1ZXN0aW9uJywgaGFuZGxlUXVlc3Rpb24pXG4gICAgLm9uKCdjbG9zZVRhZycsIGhhbmRsZUNsb3NlKVxuICAgIC5vbignY2RhdGEnLCBoYW5kbGVDRGF0YSlcbiAgICAub24oJ3RleHQnLCBmdW5jdGlvbih0ZXh0LCBkZWNvZGVFbnRpdGllcywgZ2V0Q29udGV4dCkge1xuICAgICAgaGFuZGxlVGV4dChkZWNvZGVFbnRpdGllcyh0ZXh0KSwgZ2V0Q29udGV4dCk7XG4gICAgfSlcbiAgICAub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpXG4gICAgLm9uKCd3YXJuJywgaGFuZGxlV2FybmluZyk7XG5cbiAgLy8gYXN5bmMgWE1MIHBhcnNpbmcgdG8gbWFrZSBzdXJlIHRoZSBleGVjdXRpb24gZW52aXJvbm1lbnRcbiAgLy8gKG5vZGUgb3IgYnJvd2VyKSBpcyBrZXB0IHJlc3BvbnNpdmUgYW5kIHRoYXQgY2VydGFpbiBvcHRpbWl6YXRpb25cbiAgLy8gc3RyYXRlZ2llcyBjYW4ga2ljayBpbi5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgdmFyIGVycjtcblxuICAgIHRyeSB7XG4gICAgICBwYXJzZXIucGFyc2UoeG1sKTtcblxuICAgICAgcmVzb2x2ZVJlZmVyZW5jZXMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cblxuICAgIHZhciByb290RWxlbWVudCA9IHJvb3RIYW5kbGVyLmVsZW1lbnQ7XG5cbiAgICBpZiAoIWVyciAmJiAhcm9vdEVsZW1lbnQpIHtcbiAgICAgIGVyciA9IGVycm9yKCdmYWlsZWQgdG8gcGFyc2UgZG9jdW1lbnQgYXMgPCcgKyByb290SGFuZGxlci50eXBlLiRkZXNjcmlwdG9yLm5hbWUgKyAnPicpO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5ncyA9IGNvbnRleHQud2FybmluZ3M7XG4gICAgdmFyIHJlZmVyZW5jZXMgPSBjb250ZXh0LnJlZmVyZW5jZXM7XG4gICAgdmFyIGVsZW1lbnRzQnlJZCA9IGNvbnRleHQuZWxlbWVudHNCeUlkO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyLndhcm5pbmdzID0gd2FybmluZ3M7XG5cbiAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICByb290RWxlbWVudDogcm9vdEVsZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzQnlJZDogZWxlbWVudHNCeUlkLFxuICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzLFxuICAgICAgICB3YXJuaW5nczogd2FybmluZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5SZWFkZXIucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBuZXcgUm9vdEVsZW1lbnRIYW5kbGVyKHRoaXMubW9kZWwsIG5hbWUpO1xufTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YWNrKCkge1xuICB2YXIgc3RhY2sgPSBbXTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhY2ssICdwZWVrJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc3RhY2s7XG59XG5cbnZhciBYTUxfUFJFQU1CTEUgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XFxuJztcblxudmFyIEVTQ0FQRV9BVFRSX0NIQVJTID0gLzx8PnwnfFwifCZ8XFxuXFxyfFxcbi9nO1xudmFyIEVTQ0FQRV9DSEFSUyA9IC88fD58Ji9nO1xuXG5cbmZ1bmN0aW9uIE5hbWVzcGFjZXMocGFyZW50KSB7XG5cbiAgdmFyIHByZWZpeE1hcCA9IHt9O1xuICB2YXIgdXJpTWFwID0ge307XG4gIHZhciB1c2VkID0ge307XG5cbiAgdmFyIHdlbGxrbm93biA9IFtdO1xuICB2YXIgY3VzdG9tID0gW107XG5cbiAgLy8gQVBJXG5cbiAgdGhpcy5ieVVyaSA9IGZ1bmN0aW9uKHVyaSkge1xuICAgIHJldHVybiB1cmlNYXBbdXJpXSB8fCAoXG4gICAgICBwYXJlbnQgJiYgcGFyZW50LmJ5VXJpKHVyaSlcbiAgICApO1xuICB9O1xuXG4gIHRoaXMuYWRkID0gZnVuY3Rpb24obnMsIGlzV2VsbGtub3duKSB7XG5cbiAgICB1cmlNYXBbbnMudXJpXSA9IG5zO1xuXG4gICAgaWYgKGlzV2VsbGtub3duKSB7XG4gICAgICB3ZWxsa25vd24ucHVzaChucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1c3RvbS5wdXNoKG5zKTtcbiAgICB9XG5cbiAgICB0aGlzLm1hcFByZWZpeChucy5wcmVmaXgsIG5zLnVyaSk7XG4gIH07XG5cbiAgdGhpcy51cmlCeVByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHJldHVybiBwcmVmaXhNYXBbcHJlZml4IHx8ICd4bWxucyddO1xuICB9O1xuXG4gIHRoaXMubWFwUHJlZml4ID0gZnVuY3Rpb24ocHJlZml4LCB1cmkpIHtcbiAgICBwcmVmaXhNYXBbcHJlZml4IHx8ICd4bWxucyddID0gdXJpO1xuICB9O1xuXG4gIHRoaXMuZ2V0TlNLZXkgPSBmdW5jdGlvbihucykge1xuICAgIHJldHVybiAobnMucHJlZml4ICE9PSB1bmRlZmluZWQpID8gKG5zLnVyaSArICd8JyArIG5zLnByZWZpeCkgOiBucy51cmk7XG4gIH07XG5cbiAgdGhpcy5sb2dVc2VkID0gZnVuY3Rpb24obnMpIHtcblxuICAgIHZhciB1cmkgPSBucy51cmk7XG4gICAgdmFyIG5zS2V5ID0gdGhpcy5nZXROU0tleShucyk7XG5cbiAgICB1c2VkW25zS2V5XSA9IHRoaXMuYnlVcmkodXJpKTtcblxuICAgIC8vIEluZm9ybSBwYXJlbnQgcmVjdXJzaXZlbHkgYWJvdXQgdGhlIHVzYWdlIG9mIHRoaXMgTlNcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQubG9nVXNlZChucyk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuZ2V0VXNlZCA9IGZ1bmN0aW9uKG5zKSB7XG5cbiAgICBmdW5jdGlvbiBpc1VzZWQobnMpIHtcbiAgICAgIHZhciBuc0tleSA9IHNlbGYuZ2V0TlNLZXkobnMpO1xuXG4gICAgICByZXR1cm4gdXNlZFtuc0tleV07XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGFsbE5zID0gW10uY29uY2F0KHdlbGxrbm93biwgY3VzdG9tKTtcblxuICAgIHJldHVybiBhbGxOcy5maWx0ZXIoaXNVc2VkKTtcbiAgfTtcblxufVxuXG5mdW5jdGlvbiBsb3dlcihzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxuZnVuY3Rpb24gbmFtZVRvQWxpYXMobmFtZSwgcGtnKSB7XG4gIGlmIChoYXNMb3dlckNhc2VBbGlhcyhwa2cpKSB7XG4gICAgcmV0dXJuIGxvd2VyKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbnNOYW1lKG5zKSB7XG4gIGlmIChpc1N0cmluZyhucykpIHtcbiAgICByZXR1cm4gbnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChucy5wcmVmaXggPyBucy5wcmVmaXggKyAnOicgOiAnJykgKyBucy5sb2NhbE5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TnNBdHRycyhuYW1lc3BhY2VzKSB7XG5cbiAgcmV0dXJuIG1hcChuYW1lc3BhY2VzLmdldFVzZWQoKSwgZnVuY3Rpb24obnMpIHtcbiAgICB2YXIgbmFtZSA9ICd4bWxucycgKyAobnMucHJlZml4ID8gJzonICsgbnMucHJlZml4IDogJycpO1xuICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIHZhbHVlOiBucy51cmkgfTtcbiAgfSk7XG5cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudE5zKG5zLCBkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmlzR2VuZXJpYykge1xuICAgIHJldHVybiBhc3NpZ24oeyBsb2NhbE5hbWU6IGRlc2NyaXB0b3IubnMubG9jYWxOYW1lIH0sIG5zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzaWduKHsgbG9jYWxOYW1lOiBuYW1lVG9BbGlhcyhkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZSwgZGVzY3JpcHRvci4kcGtnKSB9LCBucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlOcyhucywgZGVzY3JpcHRvcikge1xuICByZXR1cm4gYXNzaWduKHsgbG9jYWxOYW1lOiBkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZSB9LCBucyk7XG59XG5cbmZ1bmN0aW9uIGdldFNlcmlhbGl6YWJsZVByb3BlcnRpZXMoZWxlbWVudCkge1xuICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuJGRlc2NyaXB0b3I7XG5cbiAgcmV0dXJuIGZpbHRlcihkZXNjcmlwdG9yLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgbmFtZSA9IHAubmFtZTtcblxuICAgIGlmIChwLmlzVmlydHVhbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgZGVmYXVsdHNcbiAgICBpZiAoIWhhcyhlbGVtZW50LCBuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGVsZW1lbnRbbmFtZV07XG5cbiAgICAvLyBkbyBub3Qgc2VyaWFsaXplIGRlZmF1bHQgZXF1YWxzXG4gICAgaWYgKHZhbHVlID09PSBwLmRlZmF1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBkbyBub3Qgc2VyaWFsaXplIG51bGwgcHJvcGVydGllc1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBwLmlzTWFueSA/IHZhbHVlLmxlbmd0aCA6IHRydWU7XG4gIH0pO1xufVxuXG52YXIgRVNDQVBFX0FUVFJfTUFQID0ge1xuICAnXFxuJzogJyMxMCcsXG4gICdcXG5cXHInOiAnIzEwJyxcbiAgJ1wiJzogJyMzNCcsXG4gICdcXCcnOiAnIzM5JyxcbiAgJzwnOiAnIzYwJyxcbiAgJz4nOiAnIzYyJyxcbiAgJyYnOiAnIzM4J1xufTtcblxudmFyIEVTQ0FQRV9NQVAgPSB7XG4gICc8JzogJ2x0JyxcbiAgJz4nOiAnZ3QnLFxuICAnJic6ICdhbXAnXG59O1xuXG5mdW5jdGlvbiBlc2NhcGUoc3RyLCBjaGFyUGF0dGVybiwgcmVwbGFjZU1hcCkge1xuXG4gIC8vIGVuc3VyZSB3ZSBhcmUgaGFuZGxpbmcgc3RyaW5ncyBoZXJlXG4gIHN0ciA9IGlzU3RyaW5nKHN0cikgPyBzdHIgOiAnJyArIHN0cjtcblxuICByZXR1cm4gc3RyLnJlcGxhY2UoY2hhclBhdHRlcm4sIGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gJyYnICsgcmVwbGFjZU1hcFtzXSArICc7JztcbiAgfSk7XG59XG5cbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBub3QgY29udGFpbiBhbnkgYmFkIHZhbHVlcyAobGluZSBicmVha3MsICdcIicsIC4uLilcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gZXNjYXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBlc2NhcGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBlc2NhcGVBdHRyKHN0cikge1xuICByZXR1cm4gZXNjYXBlKHN0ciwgRVNDQVBFX0FUVFJfQ0hBUlMsIEVTQ0FQRV9BVFRSX01BUCk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUJvZHkoc3RyKSB7XG4gIHJldHVybiBlc2NhcGUoc3RyLCBFU0NBUEVfQ0hBUlMsIEVTQ0FQRV9NQVApO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJBdHRyaWJ1dGVzKHByb3BzKSB7XG4gIHJldHVybiBmaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuaXNBdHRyOyB9KTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyQ29udGFpbmVkKHByb3BzKSB7XG4gIHJldHVybiBmaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKHApIHsgcmV0dXJuICFwLmlzQXR0cjsgfSk7XG59XG5cblxuZnVuY3Rpb24gUmVmZXJlbmNlU2VyaWFsaXplcih0YWdOYW1lKSB7XG4gIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG59XG5cblJlZmVyZW5jZVNlcmlhbGl6ZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlZmVyZW5jZVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHdyaXRlclxuICAgIC5hcHBlbmRJbmRlbnQoKVxuICAgIC5hcHBlbmQoJzwnICsgdGhpcy50YWdOYW1lICsgJz4nICsgdGhpcy5lbGVtZW50LmlkICsgJzwvJyArIHRoaXMudGFnTmFtZSArICc+JylcbiAgICAuYXBwZW5kTmV3TGluZSgpO1xufTtcblxuZnVuY3Rpb24gQm9keVNlcmlhbGl6ZXIoKSB7fVxuXG5Cb2R5U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVmFsdWUgPVxuQm9keVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHdyaXRlci5hcHBlbmQoXG4gICAgdGhpcy5lc2NhcGVcbiAgICAgID8gZXNjYXBlQm9keSh0aGlzLnZhbHVlKVxuICAgICAgOiB0aGlzLnZhbHVlXG4gICk7XG59O1xuXG5Cb2R5U2VyaWFsaXplci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgaWYgKHByb3AudHlwZSA9PT0gJ1N0cmluZycgJiYgdmFsdWUuc2VhcmNoKEVTQ0FQRV9DSEFSUykgIT09IC0xKSB7XG4gICAgdGhpcy5lc2NhcGUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBWYWx1ZVNlcmlhbGl6ZXIodGFnTmFtZSkge1xuICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xufVxuXG5pbmhlcml0cyhWYWx1ZVNlcmlhbGl6ZXIsIEJvZHlTZXJpYWxpemVyKTtcblxuVmFsdWVTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVUbyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuXG4gIHdyaXRlclxuICAgIC5hcHBlbmRJbmRlbnQoKVxuICAgIC5hcHBlbmQoJzwnICsgdGhpcy50YWdOYW1lICsgJz4nKTtcblxuICB0aGlzLnNlcmlhbGl6ZVZhbHVlKHdyaXRlcik7XG5cbiAgd3JpdGVyXG4gICAgLmFwcGVuZCgnPC8nICsgdGhpcy50YWdOYW1lICsgJz4nKVxuICAgIC5hcHBlbmROZXdMaW5lKCk7XG59O1xuXG5mdW5jdGlvbiBFbGVtZW50U2VyaWFsaXplcihwYXJlbnQsIHByb3BlcnR5RGVzY3JpcHRvcikge1xuICB0aGlzLmJvZHkgPSBbXTtcbiAgdGhpcy5hdHRycyA9IFtdO1xuXG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLnByb3BlcnR5RGVzY3JpcHRvciA9IHByb3BlcnR5RGVzY3JpcHRvcjtcbn1cblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gIHZhciBlbGVtZW50RGVzY3JpcHRvciA9IGVsZW1lbnQuJGRlc2NyaXB0b3IsXG4gICAgICBwcm9wZXJ0eURlc2NyaXB0b3IgPSB0aGlzLnByb3BlcnR5RGVzY3JpcHRvcjtcblxuICB2YXIgb3RoZXJBdHRycyxcbiAgICAgIHByb3BlcnRpZXM7XG5cbiAgdmFyIGlzR2VuZXJpYyA9IGVsZW1lbnREZXNjcmlwdG9yLmlzR2VuZXJpYztcblxuICBpZiAoaXNHZW5lcmljKSB7XG4gICAgb3RoZXJBdHRycyA9IHRoaXMucGFyc2VHZW5lcmljKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIG90aGVyQXR0cnMgPSB0aGlzLnBhcnNlTnNBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgIHRoaXMubnMgPSB0aGlzLm5zUHJvcGVydHlUYWdOYW1lKHByb3BlcnR5RGVzY3JpcHRvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ucyA9IHRoaXMubnNUYWdOYW1lKGVsZW1lbnREZXNjcmlwdG9yKTtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgdGFnIG5hbWVcbiAgdGhpcy50YWdOYW1lID0gdGhpcy5hZGRUYWdOYW1lKHRoaXMubnMpO1xuXG4gIGlmICghaXNHZW5lcmljKSB7XG4gICAgcHJvcGVydGllcyA9IGdldFNlcmlhbGl6YWJsZVByb3BlcnRpZXMoZWxlbWVudCk7XG5cbiAgICB0aGlzLnBhcnNlQXR0cmlidXRlcyhmaWx0ZXJBdHRyaWJ1dGVzKHByb3BlcnRpZXMpKTtcbiAgICB0aGlzLnBhcnNlQ29udGFpbm1lbnRzKGZpbHRlckNvbnRhaW5lZChwcm9wZXJ0aWVzKSk7XG4gIH1cblxuICB0aGlzLnBhcnNlR2VuZXJpY0F0dHJpYnV0ZXMoZWxlbWVudCwgb3RoZXJBdHRycyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUubnNUYWdOYW1lID0gZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuICB2YXIgZWZmZWN0aXZlTnMgPSB0aGlzLmxvZ05hbWVzcGFjZVVzZWQoZGVzY3JpcHRvci5ucyk7XG4gIHJldHVybiBnZXRFbGVtZW50TnMoZWZmZWN0aXZlTnMsIGRlc2NyaXB0b3IpO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLm5zUHJvcGVydHlUYWdOYW1lID0gZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuICB2YXIgZWZmZWN0aXZlTnMgPSB0aGlzLmxvZ05hbWVzcGFjZVVzZWQoZGVzY3JpcHRvci5ucyk7XG4gIHJldHVybiBnZXRQcm9wZXJ0eU5zKGVmZmVjdGl2ZU5zLCBkZXNjcmlwdG9yKTtcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5pc0xvY2FsTnMgPSBmdW5jdGlvbihucykge1xuICByZXR1cm4gbnMudXJpID09PSB0aGlzLm5zLnVyaTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhY3R1YWwgbnMgYXR0cmlidXRlIG5hbWUgZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtlbGVtZW50LmluaGVyaXRlZD1mYWxzZV1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IG5zTmFtZVxuICovXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUubnNBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gIHZhciBucztcblxuICBpZiAoaXNTdHJpbmcoZWxlbWVudCkpIHtcbiAgICBucyA9IHBhcnNlTmFtZU5TKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIG5zID0gZWxlbWVudC5ucztcbiAgfVxuXG4gIC8vIHJldHVybiBqdXN0IGxvY2FsIG5hbWUgZm9yIGluaGVyaXRlZCBhdHRyaWJ1dGVzXG4gIGlmIChlbGVtZW50LmluaGVyaXRlZCkge1xuICAgIHJldHVybiB7IGxvY2FsTmFtZTogbnMubG9jYWxOYW1lIH07XG4gIH1cblxuICAvLyBwYXJzZSArIGxvZyBlZmZlY3RpdmUgbnNcbiAgdmFyIGVmZmVjdGl2ZU5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKG5zKTtcblxuICAvLyBMT0cgQUNUVUFMIG5hbWVzcGFjZSB1c2VcbiAgdGhpcy5nZXROYW1lc3BhY2VzKCkubG9nVXNlZChlZmZlY3RpdmVOcyk7XG5cbiAgLy8gc3RyaXAgcHJlZml4IGlmIHNhbWUgbmFtZXNwYWNlIGxpa2UgcGFyZW50XG4gIGlmICh0aGlzLmlzTG9jYWxOcyhlZmZlY3RpdmVOcykpIHtcbiAgICByZXR1cm4geyBsb2NhbE5hbWU6IG5zLmxvY2FsTmFtZSB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NpZ24oeyBsb2NhbE5hbWU6IG5zLmxvY2FsTmFtZSB9LCBlZmZlY3RpdmVOcyk7XG4gIH1cbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZUdlbmVyaWMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgYm9keSA9IHRoaXMuYm9keTtcblxuICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuXG4gIGZvckVhY2goZWxlbWVudCwgZnVuY3Rpb24odmFsLCBrZXkpIHtcblxuICAgIHZhciBub25Oc0F0dHI7XG5cbiAgICBpZiAoa2V5ID09PSAnJGJvZHknKSB7XG4gICAgICBib2R5LnB1c2gobmV3IEJvZHlTZXJpYWxpemVyKCkuYnVpbGQoeyB0eXBlOiAnU3RyaW5nJyB9LCB2YWwpKTtcbiAgICB9IGVsc2VcbiAgICBpZiAoa2V5ID09PSAnJGNoaWxkcmVuJykge1xuICAgICAgZm9yRWFjaCh2YWwsIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGJvZHkucHVzaChuZXcgRWxlbWVudFNlcmlhbGl6ZXIoc2VsZikuYnVpbGQoY2hpbGQpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZVxuICAgIGlmIChrZXkuaW5kZXhPZignJCcpICE9PSAwKSB7XG4gICAgICBub25Oc0F0dHIgPSBzZWxmLnBhcnNlTnNBdHRyaWJ1dGUoZWxlbWVudCwga2V5LCB2YWwpO1xuXG4gICAgICBpZiAobm9uTnNBdHRyKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMucHVzaCh7IG5hbWU6IGtleSwgdmFsdWU6IHZhbCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlTnNBdHRyaWJ1dGUgPSBmdW5jdGlvbihlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgbW9kZWwgPSBlbGVtZW50LiRtb2RlbDtcblxuICB2YXIgbmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSk7XG5cbiAgdmFyIG5zO1xuXG4gIC8vIHBhcnNlIHhtbG5zOmZvbz1cImh0dHA6Ly9mb28uYmFyXCJcbiAgaWYgKG5hbWVOcy5wcmVmaXggPT09ICd4bWxucycpIHtcbiAgICBucyA9IHsgcHJlZml4OiBuYW1lTnMubG9jYWxOYW1lLCB1cmk6IHZhbHVlIH07XG4gIH1cblxuICAvLyBwYXJzZSB4bWxucz1cImh0dHA6Ly9mb28uYmFyXCJcbiAgaWYgKCFuYW1lTnMucHJlZml4ICYmIG5hbWVOcy5sb2NhbE5hbWUgPT09ICd4bWxucycpIHtcbiAgICBucyA9IHsgdXJpOiB2YWx1ZSB9O1xuICB9XG5cbiAgaWYgKCFucykge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChtb2RlbCAmJiBtb2RlbC5nZXRQYWNrYWdlKHZhbHVlKSkge1xuXG4gICAgLy8gcmVnaXN0ZXIgd2VsbCBrbm93biBuYW1lc3BhY2VcbiAgICB0aGlzLmxvZ05hbWVzcGFjZShucywgdHJ1ZSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG5cbiAgICAvLyBsb2cgY3VzdG9tIG5hbWVzcGFjZSBkaXJlY3RseSBhcyB1c2VkXG4gICAgdmFyIGFjdHVhbE5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKG5zLCB0cnVlKTtcblxuICAgIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQoYWN0dWFsTnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2UgbmFtZXNwYWNlcyBhbmQgcmV0dXJuIGEgbGlzdCBvZiBsZWZ0IG92ZXIgZ2VuZXJpYyBhdHRyaWJ1dGVzXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fVxuICovXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGdlbmVyaWNBdHRycyA9IGVsZW1lbnQuJGF0dHJzO1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gW107XG5cbiAgLy8gcGFyc2UgbmFtZXNwYWNlIGF0dHJpYnV0ZXMgZmlyc3RcbiAgLy8gYW5kIGxvZyB0aGVtLiBwdXNoIG5vbiBuYW1lc3BhY2UgYXR0cmlidXRlcyB0byBhIGxpc3RcbiAgLy8gYW5kIHByb2Nlc3MgdGhlbSBsYXRlclxuICBmb3JFYWNoKGdlbmVyaWNBdHRycywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblxuICAgIHZhciBub25Oc0F0dHIgPSBzZWxmLnBhcnNlTnNBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuXG4gICAgaWYgKG5vbk5zQXR0cikge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKG5vbk5zQXR0cik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZUdlbmVyaWNBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlcykge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3JFYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHIpIHtcblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgeHNpOnR5cGUgYXR0cmlidXRlXG4gICAgLy8gaXQgaXMgc2V0IG1hbnVhbGx5IGJhc2VkIG9uIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gdHlwZVxuICAgIGlmIChhdHRyLm5hbWUgPT09IFhTSV9UWVBFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuYWRkQXR0cmlidXRlKHNlbGYubnNBdHRyaWJ1dGVOYW1lKGF0dHIubmFtZSksIGF0dHIudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ21pc3NpbmcgbmFtZXNwYWNlIGluZm9ybWF0aW9uIGZvciAnLFxuICAgICAgICBhdHRyLm5hbWUsICc9JywgYXR0ci52YWx1ZSwgJ29uJywgZWxlbWVudCxcbiAgICAgICAgZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZUNvbnRhaW5tZW50cyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBib2R5ID0gdGhpcy5ib2R5LFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICBmb3JFYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgdmFsdWUgPSBlbGVtZW50LmdldChwLm5hbWUpLFxuICAgICAgICBpc1JlZmVyZW5jZSA9IHAuaXNSZWZlcmVuY2UsXG4gICAgICAgIGlzTWFueSA9IHAuaXNNYW55O1xuXG4gICAgaWYgKCFpc01hbnkpIHtcbiAgICAgIHZhbHVlID0gWyB2YWx1ZSBdO1xuICAgIH1cblxuICAgIGlmIChwLmlzQm9keSkge1xuICAgICAgYm9keS5wdXNoKG5ldyBCb2R5U2VyaWFsaXplcigpLmJ1aWxkKHAsIHZhbHVlWzBdKSk7XG4gICAgfSBlbHNlXG4gICAgaWYgKGlzU2ltcGxlVHlwZShwLnR5cGUpKSB7XG4gICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIGJvZHkucHVzaChuZXcgVmFsdWVTZXJpYWxpemVyKHNlbGYuYWRkVGFnTmFtZShzZWxmLm5zUHJvcGVydHlUYWdOYW1lKHApKSkuYnVpbGQocCwgdikpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlXG4gICAgaWYgKGlzUmVmZXJlbmNlKSB7XG4gICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIGJvZHkucHVzaChuZXcgUmVmZXJlbmNlU2VyaWFsaXplcihzZWxmLmFkZFRhZ05hbWUoc2VsZi5uc1Byb3BlcnR5VGFnTmFtZShwKSkpLmJ1aWxkKHYpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGFsbG93IHNlcmlhbGl6YXRpb24gdmlhIHR5cGVcbiAgICAgIC8vIHJhdGhlciB0aGFuIGVsZW1lbnQgbmFtZVxuICAgICAgdmFyIGFzVHlwZSA9IHNlcmlhbGl6ZUFzVHlwZShwKSxcbiAgICAgICAgICBhc1Byb3BlcnR5ID0gc2VyaWFsaXplQXNQcm9wZXJ0eShwKTtcblxuICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgc2VyaWFsaXplcjtcblxuICAgICAgICBpZiAoYXNUeXBlKSB7XG4gICAgICAgICAgc2VyaWFsaXplciA9IG5ldyBUeXBlU2VyaWFsaXplcihzZWxmLCBwKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgIGlmIChhc1Byb3BlcnR5KSB7XG4gICAgICAgICAgc2VyaWFsaXplciA9IG5ldyBFbGVtZW50U2VyaWFsaXplcihzZWxmLCBwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpYWxpemVyID0gbmV3IEVsZW1lbnRTZXJpYWxpemVyKHNlbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgYm9keS5wdXNoKHNlcmlhbGl6ZXIuYnVpbGQodikpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5nZXROYW1lc3BhY2VzID0gZnVuY3Rpb24obG9jYWwpIHtcblxuICB2YXIgbmFtZXNwYWNlcyA9IHRoaXMubmFtZXNwYWNlcyxcbiAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgcGFyZW50TmFtZXNwYWNlcztcblxuICBpZiAoIW5hbWVzcGFjZXMpIHtcbiAgICBwYXJlbnROYW1lc3BhY2VzID0gcGFyZW50ICYmIHBhcmVudC5nZXROYW1lc3BhY2VzKCk7XG5cbiAgICBpZiAobG9jYWwgfHwgIXBhcmVudE5hbWVzcGFjZXMpIHtcbiAgICAgIHRoaXMubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXMgPSBuZXcgTmFtZXNwYWNlcyhwYXJlbnROYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZXNwYWNlcyA9IHBhcmVudE5hbWVzcGFjZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWVzcGFjZXM7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUubG9nTmFtZXNwYWNlID0gZnVuY3Rpb24obnMsIHdlbGxrbm93biwgbG9jYWwpIHtcbiAgdmFyIG5hbWVzcGFjZXMgPSB0aGlzLmdldE5hbWVzcGFjZXMobG9jYWwpO1xuXG4gIHZhciBuc1VyaSA9IG5zLnVyaSxcbiAgICAgIG5zUHJlZml4ID0gbnMucHJlZml4O1xuXG4gIHZhciBleGlzdGluZyA9IG5hbWVzcGFjZXMuYnlVcmkobnNVcmkpO1xuXG4gIGlmIChuc1ByZWZpeCAhPT0gJ3htbCcgJiYgKCFleGlzdGluZyB8fCBsb2NhbCkpIHtcbiAgICBuYW1lc3BhY2VzLmFkZChucywgd2VsbGtub3duKTtcbiAgfVxuXG4gIG5hbWVzcGFjZXMubWFwUHJlZml4KG5zUHJlZml4LCBuc1VyaSk7XG5cbiAgcmV0dXJuIG5zO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmxvZ05hbWVzcGFjZVVzZWQgPSBmdW5jdGlvbihucywgbG9jYWwpIHtcbiAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBtb2RlbCA9IGVsZW1lbnQuJG1vZGVsLFxuICAgICAgbmFtZXNwYWNlcyA9IHRoaXMuZ2V0TmFtZXNwYWNlcyhsb2NhbCk7XG5cbiAgLy8gbnMgbWF5IGJlXG4gIC8vXG4gIC8vICAgKiBwcmVmaXggb25seVxuICAvLyAgICogcHJlZml4OnVyaVxuICAvLyAgICogbG9jYWxOYW1lIG9ubHlcblxuICB2YXIgcHJlZml4ID0gbnMucHJlZml4LFxuICAgICAgdXJpID0gbnMudXJpLFxuICAgICAgbmV3UHJlZml4LCBpZHgsXG4gICAgICB3ZWxsa25vd25Vcmk7XG5cbiAgLy8gaGFuZGxlIGFub255bW91cyBuYW1lc3BhY2VzIChlbGVtZW50Rm9ybT11bnF1YWxpZmllZCksIGNmLiAjMjNcbiAgaWYgKCFwcmVmaXggJiYgIXVyaSkge1xuICAgIHJldHVybiB7IGxvY2FsTmFtZTogbnMubG9jYWxOYW1lIH07XG4gIH1cblxuICB3ZWxsa25vd25VcmkgPSBERUZBVUxUX05TX01BUFtwcmVmaXhdIHx8IG1vZGVsICYmIChtb2RlbC5nZXRQYWNrYWdlKHByZWZpeCkgfHwge30pLnVyaTtcblxuICB1cmkgPSB1cmkgfHwgd2VsbGtub3duVXJpIHx8IG5hbWVzcGFjZXMudXJpQnlQcmVmaXgocHJlZml4KTtcblxuICBpZiAoIXVyaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gbmFtZXNwYWNlIHVyaSBnaXZlbiBmb3IgcHJlZml4IDwnICsgcHJlZml4ICsgJz4nKTtcbiAgfVxuXG4gIG5zID0gbmFtZXNwYWNlcy5ieVVyaSh1cmkpO1xuXG4gIGlmICghbnMpIHtcbiAgICBuZXdQcmVmaXggPSBwcmVmaXg7XG4gICAgaWR4ID0gMTtcblxuICAgIC8vIGZpbmQgYSBwcmVmaXggdGhhdCBpcyBub3QgbWFwcGVkIHlldFxuICAgIHdoaWxlIChuYW1lc3BhY2VzLnVyaUJ5UHJlZml4KG5ld1ByZWZpeCkpIHtcbiAgICAgIG5ld1ByZWZpeCA9IHByZWZpeCArICdfJyArIGlkeCsrO1xuICAgIH1cblxuICAgIG5zID0gdGhpcy5sb2dOYW1lc3BhY2UoeyBwcmVmaXg6IG5ld1ByZWZpeCwgdXJpOiB1cmkgfSwgd2VsbGtub3duVXJpID09PSB1cmkpO1xuICB9XG5cbiAgaWYgKHByZWZpeCkge1xuICAgIG5hbWVzcGFjZXMubWFwUHJlZml4KHByZWZpeCwgdXJpKTtcbiAgfVxuXG4gIHJldHVybiBucztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG5cbiAgICB2YXIgdmFsdWUgPSBlbGVtZW50LmdldChwLm5hbWUpO1xuXG4gICAgaWYgKHAuaXNSZWZlcmVuY2UpIHtcblxuICAgICAgaWYgKCFwLmlzTWFueSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmlkO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHYuaWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJRFJFRlMgaXMgYSB3aGl0ZXNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHJlZmVyZW5jZXMuXG4gICAgICAgIHZhbHVlID0gdmFsdWVzLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHNlbGYuYWRkQXR0cmlidXRlKHNlbGYubnNBdHRyaWJ1dGVOYW1lKHApLCB2YWx1ZSk7XG4gIH0pO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmFkZFRhZ05hbWUgPSBmdW5jdGlvbihuc1RhZ05hbWUpIHtcbiAgdmFyIGFjdHVhbE5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKG5zVGFnTmFtZSk7XG5cbiAgdGhpcy5nZXROYW1lc3BhY2VzKCkubG9nVXNlZChhY3R1YWxOcyk7XG5cbiAgcmV0dXJuIG5zTmFtZShuc1RhZ05hbWUpO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBhdHRycyA9IHRoaXMuYXR0cnM7XG5cbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gZXNjYXBlQXR0cih2YWx1ZSk7XG4gIH1cblxuICBhdHRycy5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgdmFyIGF0dHJzID0gdGhpcy5hdHRycyxcbiAgICAgIG5hbWVzcGFjZXMgPSB0aGlzLm5hbWVzcGFjZXM7XG5cbiAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICBhdHRycyA9IGdldE5zQXR0cnMobmFtZXNwYWNlcykuY29uY2F0KGF0dHJzKTtcbiAgfVxuXG4gIGZvckVhY2goYXR0cnMsIGZ1bmN0aW9uKGEpIHtcbiAgICB3cml0ZXJcbiAgICAgIC5hcHBlbmQoJyAnKVxuICAgICAgLmFwcGVuZChuc05hbWUoYS5uYW1lKSkuYXBwZW5kKCc9XCInKS5hcHBlbmQoYS52YWx1ZSkuYXBwZW5kKCdcIicpO1xuICB9KTtcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVUbyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB2YXIgZmlyc3RCb2R5ID0gdGhpcy5ib2R5WzBdLFxuICAgICAgaW5kZW50ID0gZmlyc3RCb2R5ICYmIGZpcnN0Qm9keS5jb25zdHJ1Y3RvciAhPT0gQm9keVNlcmlhbGl6ZXI7XG5cbiAgd3JpdGVyXG4gICAgLmFwcGVuZEluZGVudCgpXG4gICAgLmFwcGVuZCgnPCcgKyB0aGlzLnRhZ05hbWUpO1xuXG4gIHRoaXMuc2VyaWFsaXplQXR0cmlidXRlcyh3cml0ZXIpO1xuXG4gIHdyaXRlci5hcHBlbmQoZmlyc3RCb2R5ID8gJz4nIDogJyAvPicpO1xuXG4gIGlmIChmaXJzdEJvZHkpIHtcblxuICAgIGlmIChpbmRlbnQpIHtcbiAgICAgIHdyaXRlclxuICAgICAgICAuYXBwZW5kTmV3TGluZSgpXG4gICAgICAgIC5pbmRlbnQoKTtcbiAgICB9XG5cbiAgICBmb3JFYWNoKHRoaXMuYm9keSwgZnVuY3Rpb24oYikge1xuICAgICAgYi5zZXJpYWxpemVUbyh3cml0ZXIpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluZGVudCkge1xuICAgICAgd3JpdGVyXG4gICAgICAgIC51bmluZGVudCgpXG4gICAgICAgIC5hcHBlbmRJbmRlbnQoKTtcbiAgICB9XG5cbiAgICB3cml0ZXIuYXBwZW5kKCc8LycgKyB0aGlzLnRhZ05hbWUgKyAnPicpO1xuICB9XG5cbiAgd3JpdGVyLmFwcGVuZE5ld0xpbmUoKTtcbn07XG5cbi8qKlxuICogQSBzZXJpYWxpemVyIGZvciB0eXBlcyB0aGF0IGhhbmRsZXMgc2VyaWFsaXphdGlvbiBvZiBkYXRhIHR5cGVzXG4gKi9cbmZ1bmN0aW9uIFR5cGVTZXJpYWxpemVyKHBhcmVudCwgcHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gIEVsZW1lbnRTZXJpYWxpemVyLmNhbGwodGhpcywgcGFyZW50LCBwcm9wZXJ0eURlc2NyaXB0b3IpO1xufVxuXG5pbmhlcml0cyhUeXBlU2VyaWFsaXplciwgRWxlbWVudFNlcmlhbGl6ZXIpO1xuXG5UeXBlU2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgLy8gZXh0cmFjdGVkIGF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBlbGVtZW50KTtcblxuICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuJGRlc2NyaXB0b3I7XG5cbiAgLy8gb25seSBzZXJpYWxpemUgeHNpOnR5cGUgaWYgbmVjZXNzYXJ5XG4gIGlmIChkZXNjcmlwdG9yLm5hbWUgPT09IHRoaXMucHJvcGVydHlEZXNjcmlwdG9yLnR5cGUpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxuXG4gIHZhciB0eXBlTnMgPSB0aGlzLnR5cGVOcyA9IHRoaXMubnNUYWdOYW1lKGRlc2NyaXB0b3IpO1xuICB0aGlzLmdldE5hbWVzcGFjZXMoKS5sb2dVc2VkKHRoaXMudHlwZU5zKTtcblxuICAvLyBhZGQgeHNpOnR5cGUgYXR0cmlidXRlIHRvIHJlcHJlc2VudCB0aGUgZWxlbWVudHNcbiAgLy8gYWN0dWFsIHR5cGVcblxuICB2YXIgcGtnID0gZWxlbWVudC4kbW9kZWwuZ2V0UGFja2FnZSh0eXBlTnMudXJpKSxcbiAgICAgIHR5cGVQcmVmaXggPSAocGtnLnhtbCAmJiBwa2cueG1sLnR5cGVQcmVmaXgpIHx8ICcnO1xuXG4gIHRoaXMuYWRkQXR0cmlidXRlKFxuICAgIHRoaXMubnNBdHRyaWJ1dGVOYW1lKFhTSV9UWVBFKSxcbiAgICAodHlwZU5zLnByZWZpeCA/IHR5cGVOcy5wcmVmaXggKyAnOicgOiAnJykgKyB0eXBlUHJlZml4ICsgZGVzY3JpcHRvci5ucy5sb2NhbE5hbWVcbiAgKTtcblxuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cblR5cGVTZXJpYWxpemVyLnByb3RvdHlwZS5pc0xvY2FsTnMgPSBmdW5jdGlvbihucykge1xuICByZXR1cm4gbnMudXJpID09PSAodGhpcy50eXBlTnMgfHwgdGhpcy5ucykudXJpO1xufTtcblxuZnVuY3Rpb24gU2F2aW5nV3JpdGVyKCkge1xuICB0aGlzLnZhbHVlID0gJyc7XG5cbiAgdGhpcy53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHRoaXMudmFsdWUgKz0gc3RyO1xuICB9O1xufVxuXG5mdW5jdGlvbiBGb3JtYXRpbmdXcml0ZXIob3V0LCBmb3JtYXQpIHtcblxuICB2YXIgaW5kZW50ID0gWycnXTtcblxuICB0aGlzLmFwcGVuZCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIG91dC53cml0ZShzdHIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5hcHBlbmROZXdMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgb3V0LndyaXRlKCdcXG4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmFwcGVuZEluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIG91dC53cml0ZShpbmRlbnQuam9pbignICAnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICBpbmRlbnQucHVzaCgnJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy51bmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGluZGVudC5wb3AoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHdyaXRlciBmb3IgbWV0YS1tb2RlbCBiYWNrZWQgZG9jdW1lbnQgdHJlZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvdXRwdXQgb3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHdyaXRlclxuICovXG5mdW5jdGlvbiBXcml0ZXIob3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBhc3NpZ24oeyBmb3JtYXQ6IGZhbHNlLCBwcmVhbWJsZTogdHJ1ZSB9LCBvcHRpb25zIHx8IHt9KTtcblxuICBmdW5jdGlvbiB0b1hNTCh0cmVlLCB3cml0ZXIpIHtcbiAgICB2YXIgaW50ZXJuYWxXcml0ZXIgPSB3cml0ZXIgfHwgbmV3IFNhdmluZ1dyaXRlcigpO1xuICAgIHZhciBmb3JtYXRpbmdXcml0ZXIgPSBuZXcgRm9ybWF0aW5nV3JpdGVyKGludGVybmFsV3JpdGVyLCBvcHRpb25zLmZvcm1hdCk7XG5cbiAgICBpZiAob3B0aW9ucy5wcmVhbWJsZSkge1xuICAgICAgZm9ybWF0aW5nV3JpdGVyLmFwcGVuZChYTUxfUFJFQU1CTEUpO1xuICAgIH1cblxuICAgIG5ldyBFbGVtZW50U2VyaWFsaXplcigpLmJ1aWxkKHRyZWUpLnNlcmlhbGl6ZVRvKGZvcm1hdGluZ1dyaXRlcik7XG5cbiAgICBpZiAoIXdyaXRlcikge1xuICAgICAgcmV0dXJuIGludGVybmFsV3JpdGVyLnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9YTUw6IHRvWE1MXG4gIH07XG59XG5cbmV4cG9ydCB7IFJlYWRlciwgV3JpdGVyIH07XG4iLCJpbXBvcnQgeyBmb3JFYWNoLCBiaW5kLCBwaWNrLCBhc3NpZ24sIGlzU3RyaW5nLCBpc09iamVjdCB9IGZyb20gJ21pbi1kYXNoJztcblxuLyoqXG4gKiBNb2RkbGUgYmFzZSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBCYXNlKCkgeyB9XG5cbkJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuJG1vZGVsLnByb3BlcnRpZXMuZ2V0KHRoaXMsIG5hbWUpO1xufTtcblxuQmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy4kbW9kZWwucHJvcGVydGllcy5zZXQodGhpcywgbmFtZSwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBBIG1vZGVsIGVsZW1lbnQgZmFjdG9yeS5cbiAqXG4gKiBAcGFyYW0ge01vZGRsZX0gbW9kZWxcbiAqIEBwYXJhbSB7UHJvcGVydGllc30gcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBGYWN0b3J5KG1vZGVsLCBwcm9wZXJ0aWVzKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbn1cblxuXG5GYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVUeXBlID0gZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuXG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG5cbiAgdmFyIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlLnByb3RvdHlwZSk7XG5cbiAgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0IHZhbHVlc1xuICBmb3JFYWNoKGRlc2NyaXB0b3IucHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgIGlmICghcC5pc01hbnkgJiYgcC5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb3RvdHlwZVtwLm5hbWVdID0gcC5kZWZhdWx0O1xuICAgIH1cbiAgfSk7XG5cbiAgcHJvcHMuZGVmaW5lTW9kZWwocHJvdG90eXBlLCBtb2RlbCk7XG4gIHByb3BzLmRlZmluZURlc2NyaXB0b3IocHJvdG90eXBlLCBkZXNjcmlwdG9yKTtcblxuICB2YXIgbmFtZSA9IGRlc2NyaXB0b3IubnMubmFtZTtcblxuICAvKipcbiAgICogVGhlIG5ldyB0eXBlIGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBNb2RkbGVFbGVtZW50KGF0dHJzKSB7XG4gICAgcHJvcHMuZGVmaW5lKHRoaXMsICckdHlwZScsIHsgdmFsdWU6IG5hbWUsIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgcHJvcHMuZGVmaW5lKHRoaXMsICckYXR0cnMnLCB7IHZhbHVlOiB7fSB9KTtcbiAgICBwcm9wcy5kZWZpbmUodGhpcywgJyRwYXJlbnQnLCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xuXG4gICAgZm9yRWFjaChhdHRycywgYmluZChmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWwpO1xuICAgIH0sIHRoaXMpKTtcbiAgfVxuXG4gIE1vZGRsZUVsZW1lbnQucHJvdG90eXBlID0gcHJvdG90eXBlO1xuXG4gIE1vZGRsZUVsZW1lbnQuaGFzVHlwZSA9IHByb3RvdHlwZS4kaW5zdGFuY2VPZiA9IHRoaXMubW9kZWwuaGFzVHlwZTtcblxuICAvLyBzdGF0aWMgbGlua3NcbiAgcHJvcHMuZGVmaW5lTW9kZWwoTW9kZGxlRWxlbWVudCwgbW9kZWwpO1xuICBwcm9wcy5kZWZpbmVEZXNjcmlwdG9yKE1vZGRsZUVsZW1lbnQsIGRlc2NyaXB0b3IpO1xuXG4gIHJldHVybiBNb2RkbGVFbGVtZW50O1xufTtcblxuLyoqXG4gKiBCdWlsdC1pbiBtb2RkbGUgdHlwZXNcbiAqL1xudmFyIEJVSUxUSU5TID0ge1xuICBTdHJpbmc6IHRydWUsXG4gIEJvb2xlYW46IHRydWUsXG4gIEludGVnZXI6IHRydWUsXG4gIFJlYWw6IHRydWUsXG4gIEVsZW1lbnQ6IHRydWVcbn07XG5cbi8qKlxuICogQ29udmVydGVycyBmb3IgYnVpbHQgaW4gdHlwZXMgZnJvbSBzdHJpbmcgcmVwcmVzZW50YXRpb25zXG4gKi9cbnZhciBUWVBFX0NPTlZFUlRFUlMgPSB7XG4gIFN0cmluZzogZnVuY3Rpb24ocykgeyByZXR1cm4gczsgfSxcbiAgQm9vbGVhbjogZnVuY3Rpb24ocykgeyByZXR1cm4gcyA9PT0gJ3RydWUnOyB9LFxuICBJbnRlZ2VyOiBmdW5jdGlvbihzKSB7IHJldHVybiBwYXJzZUludChzLCAxMCk7IH0sXG4gIFJlYWw6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHBhcnNlRmxvYXQocywgMTApOyB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSB0eXBlIHRvIGl0cyByZWFsIHJlcHJlc2VudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVR5cGUodHlwZSwgdmFsdWUpIHtcblxuICB2YXIgY29udmVydGVyID0gVFlQRV9DT05WRVJURVJTW3R5cGVdO1xuXG4gIGlmIChjb252ZXJ0ZXIpIHtcbiAgICByZXR1cm4gY29udmVydGVyKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB0aGUgZ2l2ZW4gdHlwZSBpcyBidWlsdC1pblxuICovXG5mdW5jdGlvbiBpc0J1aWx0SW4odHlwZSkge1xuICByZXR1cm4gISFCVUlMVElOU1t0eXBlXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB0aGUgZ2l2ZW4gdHlwZSBpcyBzaW1wbGVcbiAqL1xuZnVuY3Rpb24gaXNTaW1wbGUodHlwZSkge1xuICByZXR1cm4gISFUWVBFX0NPTlZFUlRFUlNbdHlwZV07XG59XG5cbi8qKlxuICogUGFyc2VzIGEgbmFtZXNwYWNlZCBhdHRyaWJ1dGUgbmFtZSBvZiB0aGUgZm9ybSAobnM6KWxvY2FsTmFtZSB0byBhbiBvYmplY3QsXG4gKiBnaXZlbiBhIGRlZmF1bHQgcHJlZml4IHRvIGFzc3VtZSBpbiBjYXNlIG5vIGV4cGxpY2l0IG5hbWVzcGFjZSBpcyBnaXZlbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IFtkZWZhdWx0UHJlZml4XSB0aGUgZGVmYXVsdCBwcmVmaXggdG8gdGFrZSwgaWYgbm9uZSBpcyBwcmVzZW50LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHBhcnNlZCBuYW1lXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lLCBkZWZhdWx0UHJlZml4KSB7XG4gIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoLzovKSxcbiAgICAgIGxvY2FsTmFtZSwgcHJlZml4O1xuXG4gIC8vIG5vIHByZWZpeCAoaS5lLiBvbmx5IGxvY2FsIG5hbWUpXG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICBsb2NhbE5hbWUgPSBuYW1lO1xuICAgIHByZWZpeCA9IGRlZmF1bHRQcmVmaXg7XG4gIH0gZWxzZVxuICAvLyBwcmVmaXggKyBsb2NhbCBuYW1lXG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICBsb2NhbE5hbWUgPSBwYXJ0c1sxXTtcbiAgICBwcmVmaXggPSBwYXJ0c1swXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIDxwcmVmaXg6bG9jYWxOYW1lPiBvciA8bG9jYWxOYW1lPiwgZ290ICcgKyBuYW1lKTtcbiAgfVxuXG4gIG5hbWUgPSAocHJlZml4ID8gcHJlZml4ICsgJzonIDogJycpICsgbG9jYWxOYW1lO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICBsb2NhbE5hbWU6IGxvY2FsTmFtZVxuICB9O1xufVxuXG4vKipcbiAqIEEgdXRpbGl0eSB0byBidWlsZCBlbGVtZW50IGRlc2NyaXB0b3JzLlxuICovXG5mdW5jdGlvbiBEZXNjcmlwdG9yQnVpbGRlcihuYW1lTnMpIHtcbiAgdGhpcy5ucyA9IG5hbWVOcztcbiAgdGhpcy5uYW1lID0gbmFtZU5zLm5hbWU7XG4gIHRoaXMuYWxsVHlwZXMgPSBbXTtcbiAgdGhpcy5hbGxUeXBlc0J5TmFtZSA9IHt9O1xuICB0aGlzLnByb3BlcnRpZXMgPSBbXTtcbiAgdGhpcy5wcm9wZXJ0aWVzQnlOYW1lID0ge307XG59XG5cblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwaWNrKHRoaXMsIFtcbiAgICAnbnMnLFxuICAgICduYW1lJyxcbiAgICAnYWxsVHlwZXMnLFxuICAgICdhbGxUeXBlc0J5TmFtZScsXG4gICAgJ3Byb3BlcnRpZXMnLFxuICAgICdwcm9wZXJ0aWVzQnlOYW1lJyxcbiAgICAnYm9keVByb3BlcnR5JyxcbiAgICAnaWRQcm9wZXJ0eSdcbiAgXSk7XG59O1xuXG4vKipcbiAqIEFkZCBwcm9wZXJ0eSBhdCBnaXZlbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcFxuICogQHBhcmFtIHtOdW1iZXJ9IFtpZHhdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt2YWxpZGF0ZT10cnVlXVxuICovXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYWRkUHJvcGVydHkgPSBmdW5jdGlvbihwLCBpZHgsIHZhbGlkYXRlKSB7XG5cbiAgaWYgKHR5cGVvZiBpZHggPT09ICdib29sZWFuJykge1xuICAgIHZhbGlkYXRlID0gaWR4O1xuICAgIGlkeCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRoaXMuYWRkTmFtZWRQcm9wZXJ0eShwLCB2YWxpZGF0ZSAhPT0gZmFsc2UpO1xuXG4gIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzO1xuXG4gIGlmIChpZHggIT09IHVuZGVmaW5lZCkge1xuICAgIHByb3BlcnRpZXMuc3BsaWNlKGlkeCwgMCwgcCk7XG4gIH0gZWxzZSB7XG4gICAgcHJvcGVydGllcy5wdXNoKHApO1xuICB9XG59O1xuXG5cbkRlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5yZXBsYWNlUHJvcGVydHkgPSBmdW5jdGlvbihvbGRQcm9wZXJ0eSwgbmV3UHJvcGVydHksIHJlcGxhY2UpIHtcbiAgdmFyIG9sZE5hbWVOcyA9IG9sZFByb3BlcnR5Lm5zO1xuXG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgIHByb3BlcnRpZXNCeU5hbWUgPSB0aGlzLnByb3BlcnRpZXNCeU5hbWUsXG4gICAgICByZW5hbWUgPSBvbGRQcm9wZXJ0eS5uYW1lICE9PSBuZXdQcm9wZXJ0eS5uYW1lO1xuXG4gIGlmIChvbGRQcm9wZXJ0eS5pc0lkKSB7XG4gICAgaWYgKCFuZXdQcm9wZXJ0eS5pc0lkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdwcm9wZXJ0eSA8JyArIG5ld1Byb3BlcnR5Lm5zLm5hbWUgKyAnPiBtdXN0IGJlIGlkIHByb3BlcnR5ICcgK1xuICAgICAgICAndG8gcmVmaW5lIDwnICsgb2xkUHJvcGVydHkubnMubmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRJZFByb3BlcnR5KG5ld1Byb3BlcnR5LCBmYWxzZSk7XG4gIH1cblxuICBpZiAob2xkUHJvcGVydHkuaXNCb2R5KSB7XG5cbiAgICBpZiAoIW5ld1Byb3BlcnR5LmlzQm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAncHJvcGVydHkgPCcgKyBuZXdQcm9wZXJ0eS5ucy5uYW1lICsgJz4gbXVzdCBiZSBib2R5IHByb3BlcnR5ICcgK1xuICAgICAgICAndG8gcmVmaW5lIDwnICsgb2xkUHJvcGVydHkubnMubmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogQ2hlY2sgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMuc2V0Qm9keVByb3BlcnR5KG5ld1Byb3BlcnR5LCBmYWxzZSk7XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBleGlzdGVuY2UgYW5kIGdldCBsb2NhdGlvbiBvZiBvbGQgcHJvcGVydHlcbiAgdmFyIGlkeCA9IHByb3BzLmluZGV4T2Yob2xkUHJvcGVydHkpO1xuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvcGVydHkgPCcgKyBvbGROYW1lTnMubmFtZSArICc+IG5vdCBmb3VuZCBpbiBwcm9wZXJ0eSBsaXN0Jyk7XG4gIH1cblxuICAvLyByZW1vdmUgb2xkIHByb3BlcnR5XG4gIHByb3BzLnNwbGljZShpZHgsIDEpO1xuXG4gIC8vIHJlcGxhY2luZyB0aGUgbmFtZWQgcHJvcGVydHkgaXMgaW50ZW50aW9uYWxcbiAgLy9cbiAgLy8gICogdmFsaWRhdGUgb25seSBpZiB0aGlzIGlzIGEgXCJyZW5hbWVcIiBvcGVyYXRpb25cbiAgLy8gICogYWRkIGF0IHNwZWNpZmljIGluZGV4IHVubGVzcyB3ZSBcInJlcGxhY2VcIlxuICAvL1xuICB0aGlzLmFkZFByb3BlcnR5KG5ld1Byb3BlcnR5LCByZXBsYWNlID8gdW5kZWZpbmVkIDogaWR4LCByZW5hbWUpO1xuXG4gIC8vIG1ha2UgbmV3IHByb3BlcnR5IGF2YWlsYWJsZSB1bmRlciBvbGQgbmFtZVxuICBwcm9wZXJ0aWVzQnlOYW1lW29sZE5hbWVOcy5uYW1lXSA9IHByb3BlcnRpZXNCeU5hbWVbb2xkTmFtZU5zLmxvY2FsTmFtZV0gPSBuZXdQcm9wZXJ0eTtcbn07XG5cblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLnJlZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbihwLCB0YXJnZXRQcm9wZXJ0eU5hbWUsIHJlcGxhY2UpIHtcblxuICB2YXIgbnNQcmVmaXggPSBwLm5zLnByZWZpeDtcbiAgdmFyIHBhcnRzID0gdGFyZ2V0UHJvcGVydHlOYW1lLnNwbGl0KCcjJyk7XG5cbiAgdmFyIG5hbWUgPSBwYXJzZU5hbWUocGFydHNbMF0sIG5zUHJlZml4KTtcbiAgdmFyIGF0dHJOYW1lID0gcGFyc2VOYW1lKHBhcnRzWzFdLCBuYW1lLnByZWZpeCkubmFtZTtcblxuICB2YXIgcmVkZWZpbmVkUHJvcGVydHkgPSB0aGlzLnByb3BlcnRpZXNCeU5hbWVbYXR0ck5hbWVdO1xuICBpZiAoIXJlZGVmaW5lZFByb3BlcnR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZWZpbmVkIHByb3BlcnR5IDwnICsgYXR0ck5hbWUgKyAnPiBub3QgZm91bmQnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlcGxhY2VQcm9wZXJ0eShyZWRlZmluZWRQcm9wZXJ0eSwgcCwgcmVwbGFjZSk7XG4gIH1cblxuICBkZWxldGUgcC5yZWRlZmluZXM7XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYWRkTmFtZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIHZhbGlkYXRlKSB7XG4gIHZhciBucyA9IHAubnMsXG4gICAgICBwcm9wc0J5TmFtZSA9IHRoaXMucHJvcGVydGllc0J5TmFtZTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICB0aGlzLmFzc2VydE5vdERlZmluZWQocCwgbnMubmFtZSk7XG4gICAgdGhpcy5hc3NlcnROb3REZWZpbmVkKHAsIG5zLmxvY2FsTmFtZSk7XG4gIH1cblxuICBwcm9wc0J5TmFtZVtucy5uYW1lXSA9IHByb3BzQnlOYW1lW25zLmxvY2FsTmFtZV0gPSBwO1xufTtcblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLnJlbW92ZU5hbWVkUHJvcGVydHkgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBucyA9IHAubnMsXG4gICAgICBwcm9wc0J5TmFtZSA9IHRoaXMucHJvcGVydGllc0J5TmFtZTtcblxuICBkZWxldGUgcHJvcHNCeU5hbWVbbnMubmFtZV07XG4gIGRlbGV0ZSBwcm9wc0J5TmFtZVtucy5sb2NhbE5hbWVdO1xufTtcblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLnNldEJvZHlQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIHZhbGlkYXRlKSB7XG5cbiAgaWYgKHZhbGlkYXRlICYmIHRoaXMuYm9keVByb3BlcnR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2JvZHkgcHJvcGVydHkgZGVmaW5lZCBtdWx0aXBsZSB0aW1lcyAnICtcbiAgICAgICcoPCcgKyB0aGlzLmJvZHlQcm9wZXJ0eS5ucy5uYW1lICsgJz4sIDwnICsgcC5ucy5uYW1lICsgJz4pJyk7XG4gIH1cblxuICB0aGlzLmJvZHlQcm9wZXJ0eSA9IHA7XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuc2V0SWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIHZhbGlkYXRlKSB7XG5cbiAgaWYgKHZhbGlkYXRlICYmIHRoaXMuaWRQcm9wZXJ0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdpZCBwcm9wZXJ0eSBkZWZpbmVkIG11bHRpcGxlIHRpbWVzICcgK1xuICAgICAgJyg8JyArIHRoaXMuaWRQcm9wZXJ0eS5ucy5uYW1lICsgJz4sIDwnICsgcC5ucy5uYW1lICsgJz4pJyk7XG4gIH1cblxuICB0aGlzLmlkUHJvcGVydHkgPSBwO1xufTtcblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLmFzc2VydE5vdERlZmluZWQgPSBmdW5jdGlvbihwLCBuYW1lKSB7XG4gIHZhciBwcm9wZXJ0eU5hbWUgPSBwLm5hbWUsXG4gICAgICBkZWZpbmVkUHJvcGVydHkgPSB0aGlzLnByb3BlcnRpZXNCeU5hbWVbcHJvcGVydHlOYW1lXTtcblxuICBpZiAoZGVmaW5lZFByb3BlcnR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ3Byb3BlcnR5IDwnICsgcHJvcGVydHlOYW1lICsgJz4gYWxyZWFkeSBkZWZpbmVkOyAnICtcbiAgICAgICdvdmVycmlkZSBvZiA8JyArIGRlZmluZWRQcm9wZXJ0eS5kZWZpbmVkQnkubnMubmFtZSArICcjJyArIGRlZmluZWRQcm9wZXJ0eS5ucy5uYW1lICsgJz4gYnkgJyArXG4gICAgICAnPCcgKyBwLmRlZmluZWRCeS5ucy5uYW1lICsgJyMnICsgcC5ucy5uYW1lICsgJz4gbm90IGFsbG93ZWQgd2l0aG91dCByZWRlZmluZXMnKTtcbiAgfVxufTtcblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLmhhc1Byb3BlcnR5ID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzQnlOYW1lW25hbWVdO1xufTtcblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLmFkZFRyYWl0ID0gZnVuY3Rpb24odCwgaW5oZXJpdGVkKSB7XG5cbiAgdmFyIHR5cGVzQnlOYW1lID0gdGhpcy5hbGxUeXBlc0J5TmFtZSxcbiAgICAgIHR5cGVzID0gdGhpcy5hbGxUeXBlcztcblxuICB2YXIgdHlwZU5hbWUgPSB0Lm5hbWU7XG5cbiAgaWYgKHR5cGVOYW1lIGluIHR5cGVzQnlOYW1lKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaCh0LnByb3BlcnRpZXMsIGJpbmQoZnVuY3Rpb24ocCkge1xuXG4gICAgLy8gY2xvbmUgcHJvcGVydHkgdG8gYWxsb3cgZXh0ZW5zaW9uc1xuICAgIHAgPSBhc3NpZ24oe30sIHAsIHtcbiAgICAgIG5hbWU6IHAubnMubG9jYWxOYW1lLFxuICAgICAgaW5oZXJpdGVkOiBpbmhlcml0ZWRcbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCAnZGVmaW5lZEJ5Jywge1xuICAgICAgdmFsdWU6IHRcbiAgICB9KTtcblxuICAgIHZhciByZXBsYWNlcyA9IHAucmVwbGFjZXMsXG4gICAgICAgIHJlZGVmaW5lcyA9IHAucmVkZWZpbmVzO1xuXG4gICAgLy8gYWRkIHJlcGxhY2UvcmVkZWZpbmUgc3VwcG9ydFxuICAgIGlmIChyZXBsYWNlcyB8fCByZWRlZmluZXMpIHtcbiAgICAgIHRoaXMucmVkZWZpbmVQcm9wZXJ0eShwLCByZXBsYWNlcyB8fCByZWRlZmluZXMsIHJlcGxhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHAuaXNCb2R5KSB7XG4gICAgICAgIHRoaXMuc2V0Qm9keVByb3BlcnR5KHApO1xuICAgICAgfVxuICAgICAgaWYgKHAuaXNJZCkge1xuICAgICAgICB0aGlzLnNldElkUHJvcGVydHkocCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZFByb3BlcnR5KHApO1xuICAgIH1cbiAgfSwgdGhpcykpO1xuXG4gIHR5cGVzLnB1c2godCk7XG4gIHR5cGVzQnlOYW1lW3R5cGVOYW1lXSA9IHQ7XG59O1xuXG4vKipcbiAqIEEgcmVnaXN0cnkgb2YgTW9kZGxlIHBhY2thZ2VzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8UGFja2FnZT59IHBhY2thZ2VzXG4gKiBAcGFyYW0ge1Byb3BlcnRpZXN9IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gUmVnaXN0cnkocGFja2FnZXMsIHByb3BlcnRpZXMpIHtcbiAgdGhpcy5wYWNrYWdlTWFwID0ge307XG4gIHRoaXMudHlwZU1hcCA9IHt9O1xuXG4gIHRoaXMucGFja2FnZXMgPSBbXTtcblxuICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuXG4gIGZvckVhY2gocGFja2FnZXMsIGJpbmQodGhpcy5yZWdpc3RlclBhY2thZ2UsIHRoaXMpKTtcbn1cblxuXG5SZWdpc3RyeS5wcm90b3R5cGUuZ2V0UGFja2FnZSA9IGZ1bmN0aW9uKHVyaU9yUHJlZml4KSB7XG4gIHJldHVybiB0aGlzLnBhY2thZ2VNYXBbdXJpT3JQcmVmaXhdO1xufTtcblxuUmVnaXN0cnkucHJvdG90eXBlLmdldFBhY2thZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBhY2thZ2VzO1xufTtcblxuXG5SZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXJQYWNrYWdlID0gZnVuY3Rpb24ocGtnKSB7XG5cbiAgLy8gY29weSBwYWNrYWdlXG4gIHBrZyA9IGFzc2lnbih7fSwgcGtnKTtcblxuICB2YXIgcGtnTWFwID0gdGhpcy5wYWNrYWdlTWFwO1xuXG4gIGVuc3VyZUF2YWlsYWJsZShwa2dNYXAsIHBrZywgJ3ByZWZpeCcpO1xuICBlbnN1cmVBdmFpbGFibGUocGtnTWFwLCBwa2csICd1cmknKTtcblxuICAvLyByZWdpc3RlciB0eXBlc1xuICBmb3JFYWNoKHBrZy50eXBlcywgYmluZChmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG4gICAgdGhpcy5yZWdpc3RlclR5cGUoZGVzY3JpcHRvciwgcGtnKTtcbiAgfSwgdGhpcykpO1xuXG4gIHBrZ01hcFtwa2cudXJpXSA9IHBrZ01hcFtwa2cucHJlZml4XSA9IHBrZztcbiAgdGhpcy5wYWNrYWdlcy5wdXNoKHBrZyk7XG59O1xuXG5cbi8qKlxuICogUmVnaXN0ZXIgYSB0eXBlIGZyb20gYSBzcGVjaWZpYyBwYWNrYWdlIHdpdGggdXNcbiAqL1xuUmVnaXN0cnkucHJvdG90eXBlLnJlZ2lzdGVyVHlwZSA9IGZ1bmN0aW9uKHR5cGUsIHBrZykge1xuXG4gIHR5cGUgPSBhc3NpZ24oe30sIHR5cGUsIHtcbiAgICBzdXBlckNsYXNzOiAodHlwZS5zdXBlckNsYXNzIHx8IFtdKS5zbGljZSgpLFxuICAgIGV4dGVuZHM6ICh0eXBlLmV4dGVuZHMgfHwgW10pLnNsaWNlKCksXG4gICAgcHJvcGVydGllczogKHR5cGUucHJvcGVydGllcyB8fCBbXSkuc2xpY2UoKSxcbiAgICBtZXRhOiBhc3NpZ24oKHR5cGUubWV0YSB8fCB7fSkpXG4gIH0pO1xuXG4gIHZhciBucyA9IHBhcnNlTmFtZSh0eXBlLm5hbWUsIHBrZy5wcmVmaXgpLFxuICAgICAgbmFtZSA9IG5zLm5hbWUsXG4gICAgICBwcm9wZXJ0aWVzQnlOYW1lID0ge307XG5cbiAgLy8gcGFyc2UgcHJvcGVydGllc1xuICBmb3JFYWNoKHR5cGUucHJvcGVydGllcywgYmluZChmdW5jdGlvbihwKSB7XG5cbiAgICAvLyBuYW1lc3BhY2UgcHJvcGVydHkgbmFtZXNcbiAgICB2YXIgcHJvcGVydHlOcyA9IHBhcnNlTmFtZShwLm5hbWUsIG5zLnByZWZpeCksXG4gICAgICAgIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TnMubmFtZTtcblxuICAgIC8vIG5hbWVzcGFjZSBwcm9wZXJ0eSB0eXBlc1xuICAgIGlmICghaXNCdWlsdEluKHAudHlwZSkpIHtcbiAgICAgIHAudHlwZSA9IHBhcnNlTmFtZShwLnR5cGUsIHByb3BlcnR5TnMucHJlZml4KS5uYW1lO1xuICAgIH1cblxuICAgIGFzc2lnbihwLCB7XG4gICAgICBuczogcHJvcGVydHlOcyxcbiAgICAgIG5hbWU6IHByb3BlcnR5TmFtZVxuICAgIH0pO1xuXG4gICAgcHJvcGVydGllc0J5TmFtZVtwcm9wZXJ0eU5hbWVdID0gcDtcbiAgfSwgdGhpcykpO1xuXG4gIC8vIHVwZGF0ZSBucyArIG5hbWVcbiAgYXNzaWduKHR5cGUsIHtcbiAgICBuczogbnMsXG4gICAgbmFtZTogbmFtZSxcbiAgICBwcm9wZXJ0aWVzQnlOYW1lOiBwcm9wZXJ0aWVzQnlOYW1lXG4gIH0pO1xuXG4gIGZvckVhY2godHlwZS5leHRlbmRzLCBiaW5kKGZ1bmN0aW9uKGV4dGVuZHNOYW1lKSB7XG4gICAgdmFyIGV4dGVuZGVkID0gdGhpcy50eXBlTWFwW2V4dGVuZHNOYW1lXTtcblxuICAgIGV4dGVuZGVkLnRyYWl0cyA9IGV4dGVuZGVkLnRyYWl0cyB8fCBbXTtcbiAgICBleHRlbmRlZC50cmFpdHMucHVzaChuYW1lKTtcbiAgfSwgdGhpcykpO1xuXG4gIC8vIGxpbmsgdG8gcGFja2FnZVxuICB0aGlzLmRlZmluZVBhY2thZ2UodHlwZSwgcGtnKTtcblxuICAvLyByZWdpc3RlclxuICB0aGlzLnR5cGVNYXBbbmFtZV0gPSB0eXBlO1xufTtcblxuXG4vKipcbiAqIFRyYXZlcnNlIHRoZSB0eXBlIGhpZXJhcmNoeSBmcm9tIGJvdHRvbSB0byB0b3AsXG4gKiBjYWxsaW5nIGl0ZXJhdG9yIHdpdGggKHR5cGUsIGluaGVyaXRlZCkgZm9yIGFsbCBlbGVtZW50cyBpblxuICogdGhlIGluaGVyaXRhbmNlIGNoYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBuc05hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt0cmFpdD1mYWxzZV1cbiAqL1xuUmVnaXN0cnkucHJvdG90eXBlLm1hcFR5cGVzID0gZnVuY3Rpb24obnNOYW1lLCBpdGVyYXRvciwgdHJhaXQpIHtcblxuICB2YXIgdHlwZSA9IGlzQnVpbHRJbihuc05hbWUubmFtZSkgPyB7IG5hbWU6IG5zTmFtZS5uYW1lIH0gOiB0aGlzLnR5cGVNYXBbbnNOYW1lLm5hbWVdO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvKipcbiAgICogVHJhdmVyc2UgdGhlIHNlbGVjdGVkIHRyYWl0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gICAqL1xuICBmdW5jdGlvbiB0cmF2ZXJzZVRyYWl0KGNscykge1xuICAgIHJldHVybiB0cmF2ZXJzZVN1cGVyKGNscywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogVHJhdmVyc2UgdGhlIHNlbGVjdGVkIHN1cGVyIHR5cGUgb3IgdHJhaXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0cmFpdD1mYWxzZV1cbiAgICovXG4gIGZ1bmN0aW9uIHRyYXZlcnNlU3VwZXIoY2xzLCB0cmFpdCkge1xuICAgIHZhciBwYXJlbnROcyA9IHBhcnNlTmFtZShjbHMsIGlzQnVpbHRJbihjbHMpID8gJycgOiBuc05hbWUucHJlZml4KTtcbiAgICBzZWxmLm1hcFR5cGVzKHBhcmVudE5zLCBpdGVyYXRvciwgdHJhaXQpO1xuICB9XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHR5cGUgPCcgKyBuc05hbWUubmFtZSArICc+Jyk7XG4gIH1cblxuICBmb3JFYWNoKHR5cGUuc3VwZXJDbGFzcywgdHJhaXQgPyB0cmF2ZXJzZVRyYWl0IDogdHJhdmVyc2VTdXBlcik7XG5cbiAgLy8gY2FsbCBpdGVyYXRvciB3aXRoICh0eXBlLCBpbmhlcml0ZWQ9IXRyYWl0KVxuICBpdGVyYXRvcih0eXBlLCAhdHJhaXQpO1xuXG4gIGZvckVhY2godHlwZS50cmFpdHMsIHRyYXZlcnNlVHJhaXQpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBkZXNjcmlwdG9yIGZvciBhIHR5cGUuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlIHRoZSBuYW1lc3BhY2VkIG5hbWUgKG5zOmxvY2FsTmFtZSkgb2YgdGhlIHR5cGVcbiAqXG4gKiBAcmV0dXJuIHtEZXNjcmlwdG9yfSB0aGUgcmVzdWx0aW5nIGVmZmVjdGl2ZSBkZXNjcmlwdG9yXG4gKi9cblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRFZmZlY3RpdmVEZXNjcmlwdG9yID0gZnVuY3Rpb24obmFtZSkge1xuXG4gIHZhciBuc05hbWUgPSBwYXJzZU5hbWUobmFtZSk7XG5cbiAgdmFyIGJ1aWxkZXIgPSBuZXcgRGVzY3JpcHRvckJ1aWxkZXIobnNOYW1lKTtcblxuICB0aGlzLm1hcFR5cGVzKG5zTmFtZSwgZnVuY3Rpb24odHlwZSwgaW5oZXJpdGVkKSB7XG4gICAgYnVpbGRlci5hZGRUcmFpdCh0eXBlLCBpbmhlcml0ZWQpO1xuICB9KTtcblxuICB2YXIgZGVzY3JpcHRvciA9IGJ1aWxkZXIuYnVpbGQoKTtcblxuICAvLyBkZWZpbmUgcGFja2FnZSBsaW5rXG4gIHRoaXMuZGVmaW5lUGFja2FnZShkZXNjcmlwdG9yLCBkZXNjcmlwdG9yLmFsbFR5cGVzW2Rlc2NyaXB0b3IuYWxsVHlwZXMubGVuZ3RoIC0gMV0uJHBrZyk7XG5cbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5kZWZpbmVQYWNrYWdlID0gZnVuY3Rpb24odGFyZ2V0LCBwa2cpIHtcbiAgdGhpcy5wcm9wZXJ0aWVzLmRlZmluZSh0YXJnZXQsICckcGtnJywgeyB2YWx1ZTogcGtnIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gZW5zdXJlQXZhaWxhYmxlKHBhY2thZ2VNYXAsIHBrZywgaWRlbnRpZmllcktleSkge1xuXG4gIHZhciB2YWx1ZSA9IHBrZ1tpZGVudGlmaWVyS2V5XTtcblxuICBpZiAodmFsdWUgaW4gcGFja2FnZU1hcCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFja2FnZSB3aXRoICcgKyBpZGVudGlmaWVyS2V5ICsgJyA8JyArIHZhbHVlICsgJz4gYWxyZWFkeSBkZWZpbmVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIHV0aWxpdHkgdGhhdCBnZXRzIGFuZCBzZXRzIHByb3BlcnRpZXMgb2YgbW9kZWwgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqL1xuZnVuY3Rpb24gUHJvcGVydGllcyhtb2RlbCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG59XG5cblxuLyoqXG4gKiBTZXRzIGEgbmFtZWQgcHJvcGVydHkgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICogSWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgdGhlIHByb3BlcnR5IGdldHMgZGVsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKi9cblByb3BlcnRpZXMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcblxuICB2YXIgcHJvcGVydHkgPSB0aGlzLm1vZGVsLmdldFByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIG5hbWUpO1xuXG4gIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5uYW1lO1xuXG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAvLyB1bnNldCB0aGUgcHJvcGVydHksIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgdW5kZWZpbmVkO1xuICAgIC8vIGRlbGV0ZSBmcm9tICRhdHRycyAoZm9yIGV4dGVuc2lvbnMpIG9yIHRoZSB0YXJnZXQgaXRzZWxmXG4gICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5TmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXQuJGF0dHJzW25hbWVdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBzZXQgdGhlIHByb3BlcnR5LCBkZWZpbmluZyB3ZWxsIGRlZmluZWQgcHJvcGVydGllcyBvbiB0aGUgZmx5XG4gICAgLy8gb3Igc2ltcGx5IHVwZGF0aW5nIHRoZW0gaW4gdGFyZ2V0LiRhdHRycyAoZm9yIGV4dGVuc2lvbnMpXG4gICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICBpZiAocHJvcGVydHlOYW1lIGluIHRhcmdldCkge1xuICAgICAgICB0YXJnZXRbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuJGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuUHJvcGVydGllcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBuYW1lKSB7XG5cbiAgdmFyIHByb3BlcnR5ID0gdGhpcy5tb2RlbC5nZXRQcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBuYW1lKTtcblxuICBpZiAoIXByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHRhcmdldC4kYXR0cnNbbmFtZV07XG4gIH1cblxuICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHkubmFtZTtcblxuICAvLyBjaGVjayBpZiBhY2Nlc3MgdG8gY29sbGVjdGlvbiBwcm9wZXJ0eSBhbmQgbGF6aWx5IGluaXRpYWxpemUgaXRcbiAgaWYgKCF0YXJnZXRbcHJvcGVydHlOYW1lXSAmJiBwcm9wZXJ0eS5pc01hbnkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBbXSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5TmFtZV07XG59O1xuXG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkgb24gdGhlIHRhcmdldCBlbGVtZW50XG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblByb3BlcnRpZXMucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uKHRhcmdldCwgbmFtZSwgb3B0aW9ucykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCBvcHRpb25zKTtcbn07XG5cblxuLyoqXG4gKiBEZWZpbmUgdGhlIGRlc2NyaXB0b3IgZm9yIGFuIGVsZW1lbnRcbiAqL1xuUHJvcGVydGllcy5wcm90b3R5cGUuZGVmaW5lRGVzY3JpcHRvciA9IGZ1bmN0aW9uKHRhcmdldCwgZGVzY3JpcHRvcikge1xuICB0aGlzLmRlZmluZSh0YXJnZXQsICckZGVzY3JpcHRvcicsIHsgdmFsdWU6IGRlc2NyaXB0b3IgfSk7XG59O1xuXG4vKipcbiAqIERlZmluZSB0aGUgbW9kZWwgZm9yIGFuIGVsZW1lbnRcbiAqL1xuUHJvcGVydGllcy5wcm90b3R5cGUuZGVmaW5lTW9kZWwgPSBmdW5jdGlvbih0YXJnZXQsIG1vZGVsKSB7XG4gIHRoaXMuZGVmaW5lKHRhcmdldCwgJyRtb2RlbCcsIHsgdmFsdWU6IG1vZGVsIH0pO1xufTtcblxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eS5uYW1lLCB7XG4gICAgZW51bWVyYWJsZTogIXByb3BlcnR5LmlzUmVmZXJlbmNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vLy8gTW9kZGxlIGltcGxlbWVudGF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAY2xhc3MgTW9kZGxlXG4gKlxuICogQSBtb2RlbCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBlbGVtZW50cyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgTW9kZGxlID0gcmVxdWlyZSgnbW9kZGxlJyk7XG4gKlxuICogdmFyIHBrZyA9IHtcbiAqICAgbmFtZTogJ215cGFja2FnZScsXG4gKiAgIHByZWZpeDogJ215JyxcbiAqICAgdHlwZXM6IFtcbiAqICAgICB7IG5hbWU6ICdSb290JyB9XG4gKiAgIF1cbiAqIH07XG4gKlxuICogdmFyIG1vZGRsZSA9IG5ldyBNb2RkbGUoW3BrZ10pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8UGFja2FnZT59IHBhY2thZ2VzIHRoZSBwYWNrYWdlcyB0byBjb250YWluXG4gKi9cbmZ1bmN0aW9uIE1vZGRsZShwYWNrYWdlcykge1xuXG4gIHRoaXMucHJvcGVydGllcyA9IG5ldyBQcm9wZXJ0aWVzKHRoaXMpO1xuXG4gIHRoaXMuZmFjdG9yeSA9IG5ldyBGYWN0b3J5KHRoaXMsIHRoaXMucHJvcGVydGllcyk7XG4gIHRoaXMucmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkocGFja2FnZXMsIHRoaXMucHJvcGVydGllcyk7XG5cbiAgdGhpcy50eXBlQ2FjaGUgPSB7fTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gKlxuICogQG1ldGhvZCBNb2RkbGUjY3JlYXRlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgZm9vID0gbW9kZGxlLmNyZWF0ZSgnbXk6Rm9vJyk7XG4gKiB2YXIgYmFyID0gbW9kZGxlLmNyZWF0ZSgnbXk6QmFyJywgeyBpZDogJ0JBUl8xJyB9KTtcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBkZXNjcmlwdG9yIHRoZSB0eXBlIGRlc2NyaXB0b3Igb3IgbmFtZSBrbm93IHRvIHRoZSBtb2RlbFxuICogQHBhcmFtICB7T2JqZWN0fSBhdHRycyAgIGEgbnVtYmVyIG9mIGF0dHJpYnV0ZXMgdG8gaW5pdGlhbGl6ZSB0aGUgbW9kZWwgaW5zdGFuY2Ugd2l0aFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIG1vZGVsIGluc3RhbmNlXG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oZGVzY3JpcHRvciwgYXR0cnMpIHtcbiAgdmFyIFR5cGUgPSB0aGlzLmdldFR5cGUoZGVzY3JpcHRvcik7XG5cbiAgaWYgKCFUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHR5cGUgPCcgKyBkZXNjcmlwdG9yICsgJz4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVHlwZShhdHRycyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHlwZSByZXByZXNlbnRpbmcgYSBnaXZlbiBkZXNjcmlwdG9yXG4gKlxuICogQG1ldGhvZCBNb2RkbGUjZ2V0VHlwZVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIEZvbyA9IG1vZGRsZS5nZXRUeXBlKCdteTpGb28nKTtcbiAqIHZhciBmb28gPSBuZXcgRm9vKHsgJ2lkJyA6ICdGT09fMScgfSk7XG4gKlxuICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gZGVzY3JpcHRvciB0aGUgdHlwZSBkZXNjcmlwdG9yIG9yIG5hbWUga25vdyB0byB0aGUgbW9kZWxcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICB0aGUgdHlwZSByZXByZXNlbnRpbmcgdGhlIGRlc2NyaXB0b3JcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuXG4gIHZhciBjYWNoZSA9IHRoaXMudHlwZUNhY2hlO1xuXG4gIHZhciBuYW1lID0gaXNTdHJpbmcoZGVzY3JpcHRvcikgPyBkZXNjcmlwdG9yIDogZGVzY3JpcHRvci5ucy5uYW1lO1xuXG4gIHZhciB0eXBlID0gY2FjaGVbbmFtZV07XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgZGVzY3JpcHRvciA9IHRoaXMucmVnaXN0cnkuZ2V0RWZmZWN0aXZlRGVzY3JpcHRvcihuYW1lKTtcbiAgICB0eXBlID0gY2FjaGVbbmFtZV0gPSB0aGlzLmZhY3RvcnkuY3JlYXRlVHlwZShkZXNjcmlwdG9yKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYW55LWVsZW1lbnQgdHlwZSB0byBiZSB1c2VkIHdpdGhpbiBtb2RlbCBpbnN0YW5jZXMuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBjcmVhdGUgY3VzdG9tIGVsZW1lbnRzIHRoYXQgbGllIG91dHNpZGUgdGhlIG1ldGEtbW9kZWwuXG4gKiBUaGUgY3JlYXRlZCBlbGVtZW50IGNvbnRhaW5zIGFsbCB0aGUgbWV0YS1kYXRhIHJlcXVpcmVkIHRvIHNlcmlhbGl6ZSBpdFxuICogYXMgcGFydCBvZiBtZXRhLW1vZGVsIGVsZW1lbnRzLlxuICpcbiAqIEBtZXRob2QgTW9kZGxlI2NyZWF0ZUFueVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGZvbyA9IG1vZGRsZS5jcmVhdGVBbnkoJ3ZlbmRvcjpGb28nLCAnaHR0cDovL3ZlbmRvcicsIHtcbiAqICAgdmFsdWU6ICdiYXInXG4gKiB9KTtcbiAqXG4gKiB2YXIgY29udGFpbmVyID0gbW9kZGxlLmNyZWF0ZSgnbXk6Q29udGFpbmVyJywgJ2h0dHA6Ly9teScsIHtcbiAqICAgYW55OiBbIGZvbyBdXG4gKiB9KTtcbiAqXG4gKiAvLyBnbyBhaGVhZCBhbmQgc2VyaWFsaXplIHRoZSBzdHVmZlxuICpcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgIHRoZSBuYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5zVXJpIHRoZSBuYW1lc3BhY2UgdXJpIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBhIG1hcCBvZiBwcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgdGhlIGluc3RhbmNlIHdpdGhcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGFueSB0eXBlIGluc3RhbmNlXG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuY3JlYXRlQW55ID0gZnVuY3Rpb24obmFtZSwgbnNVcmksIHByb3BlcnRpZXMpIHtcblxuICB2YXIgbmFtZU5zID0gcGFyc2VOYW1lKG5hbWUpO1xuXG4gIHZhciBlbGVtZW50ID0ge1xuICAgICR0eXBlOiBuYW1lLFxuICAgICRpbnN0YW5jZU9mOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gdGhpcy4kdHlwZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBpc0dlbmVyaWM6IHRydWUsXG4gICAgbnM6IHtcbiAgICAgIHByZWZpeDogbmFtZU5zLnByZWZpeCxcbiAgICAgIGxvY2FsTmFtZTogbmFtZU5zLmxvY2FsTmFtZSxcbiAgICAgIHVyaTogbnNVcmlcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5wcm9wZXJ0aWVzLmRlZmluZURlc2NyaXB0b3IoZWxlbWVudCwgZGVzY3JpcHRvcik7XG4gIHRoaXMucHJvcGVydGllcy5kZWZpbmVNb2RlbChlbGVtZW50LCB0aGlzKTtcbiAgdGhpcy5wcm9wZXJ0aWVzLmRlZmluZShlbGVtZW50LCAnJHBhcmVudCcsIHsgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH0pO1xuXG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24oYSwga2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KGEpICYmIGEudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbWVudFthLm5hbWVdID0gYS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudFtrZXldID0gYTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVnaXN0ZXJlZCBwYWNrYWdlIGJ5IHVyaSBvciBwcmVmaXhcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwYWNrYWdlXG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuZ2V0UGFja2FnZSA9IGZ1bmN0aW9uKHVyaU9yUHJlZml4KSB7XG4gIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmdldFBhY2thZ2UodXJpT3JQcmVmaXgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc25hcHNob3Qgb2YgYWxsIGtub3duIHBhY2thZ2VzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgcGFja2FnZVxuICovXG5Nb2RkbGUucHJvdG90eXBlLmdldFBhY2thZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmdldFBhY2thZ2VzKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGRlc2NyaXB0b3IgZm9yIGFuIGVsZW1lbnRcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5nZXRFbGVtZW50RGVzY3JpcHRvciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuJGRlc2NyaXB0b3I7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGVzY3JpcHRvciBvciBpbnN0YW5jZVxuICogcmVwcmVzZW50cyB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBNYXkgYmUgYXBwbGllZCB0byB0aGlzLCBpZiBlbGVtZW50IGlzIG9taXR0ZWQuXG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuaGFzVHlwZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHR5cGUgPSBlbGVtZW50O1xuICAgIGVsZW1lbnQgPSB0aGlzO1xuICB9XG5cbiAgdmFyIGRlc2NyaXB0b3IgPSBlbGVtZW50LiRtb2RlbC5nZXRFbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KTtcblxuICByZXR1cm4gKHR5cGUgaW4gZGVzY3JpcHRvci5hbGxUeXBlc0J5TmFtZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGRlc2NyaXB0b3Igb2YgYW4gZWxlbWVudHMgbmFtZWQgcHJvcGVydHlcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5nZXRQcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gdGhpcy5nZXRFbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KS5wcm9wZXJ0aWVzQnlOYW1lW3Byb3BlcnR5XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG1hcHBlZCB0eXBlJ3MgZGVzY3JpcHRvclxuICovXG5Nb2RkbGUucHJvdG90eXBlLmdldFR5cGVEZXNjcmlwdG9yID0gZnVuY3Rpb24odHlwZSkge1xuICByZXR1cm4gdGhpcy5yZWdpc3RyeS50eXBlTWFwW3R5cGVdO1xufTtcblxuZXhwb3J0IHsgTW9kZGxlLCBjb2VyY2VUeXBlLCBpc0J1aWx0SW4gYXMgaXNCdWlsdEluVHlwZSwgaXNTaW1wbGUgYXMgaXNTaW1wbGVUeXBlLCBwYXJzZU5hbWUgYXMgcGFyc2VOYW1lTlMgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcmVmcycpO1xuXG5tb2R1bGUuZXhwb3J0cy5Db2xsZWN0aW9uID0gcmVxdWlyZSgnLi9saWIvY29sbGVjdGlvbicpOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBbiBlbXB0eSBjb2xsZWN0aW9uIHN0dWIuIFVzZSB7QGxpbmsgUmVmc0NvbGxlY3Rpb24uZXh0ZW5kfSB0byBleHRlbmQgYVxuICogY29sbGVjdGlvbiB3aXRoIHJlZiBzZW1hbnRpY3MuXG4gKlxuICogQGNsYXNzIFJlZnNDb2xsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBFeHRlbmRzIGEgY29sbGVjdGlvbiB3aXRoIHtAbGluayBSZWZzfSBhd2FyZSBtZXRob2RzXG4gKlxuICogQG1lbWJlcm9mIFJlZnNDb2xsZWN0aW9uXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtICB7QXJyYXk8T2JqZWN0Pn0gY29sbGVjdGlvblxuICogQHBhcmFtICB7UmVmc30gcmVmcyBpbnN0YW5jZVxuICogQHBhcmFtICB7T2JqZWN0fSBwcm9wZXJ0eSByZXByZXNlbnRlZCBieSB0aGUgY29sbGVjdGlvblxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXQgb2JqZWN0IHRoZSBjb2xsZWN0aW9uIGlzIGF0dGFjaGVkIHRvXG4gKlxuICogQHJldHVybiB7UmVmc0NvbGxlY3Rpb248T2JqZWN0Pn0gdGhlIGV4dGVuZGVkIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChjb2xsZWN0aW9uLCByZWZzLCBwcm9wZXJ0eSwgdGFyZ2V0KSB7XG5cbiAgdmFyIGludmVyc2VQcm9wZXJ0eSA9IHByb3BlcnR5LmludmVyc2U7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkgYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIEBtZXRob2QgUmVmc0NvbGxlY3Rpb24jcmVtb3ZlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHJlbW92ZVxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbGxlY3Rpb24sICdyZW1vdmUnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgICAgIC8vIHVuc2V0IGludmVyc2VcbiAgICAgICAgcmVmcy51bnNldChlbGVtZW50LCBpbnZlcnNlUHJvcGVydHksIHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29sbGVjdGlvbiBjb250YWlucyB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgKlxuICAgKiBAbWV0aG9kIFJlZnNDb2xsZWN0aW9uI2NvbnRhaW5zXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGNoZWNrIGZvclxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbGxlY3Rpb24sICdjb250YWlucycsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBhcnJheSwgdW5sZXNzIGl0IGV4aXN0cyBhbHJlYWR5IChzZXQgc2VtYW50aWNzKS5cbiAgICpcbiAgICogQG1ldGhvZCBSZWZzQ29sbGVjdGlvbiNhZGRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gYWRkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBpbmRleCB0byBhZGQgZWxlbWVudCB0b1xuICAgKiAgICAgICAgICAgICAgICAgKHBvc3NpYmx5IG1vdmluZyBvdGhlciBlbGVtZW50cyBhcm91bmQpXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29sbGVjdGlvbiwgJ2FkZCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oZWxlbWVudCwgaWR4KSB7XG5cbiAgICAgIHZhciBjdXJyZW50SWR4ID0gdGhpcy5pbmRleE9mKGVsZW1lbnQpO1xuXG4gICAgICBpZiAodHlwZW9mIGlkeCA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICBpZiAoY3VycmVudElkeCAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBlbGVtZW50IGFscmVhZHkgaW4gY29sbGVjdGlvbiAoISlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdG8gZW5kIG9mIGFycmF5LCBhcyBubyBpZHggaXMgc3BlY2lmaWVkXG4gICAgICAgIGlkeCA9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgYWxyZWFkeSBpbiBjb2xsZWN0aW9uXG4gICAgICBpZiAoY3VycmVudElkeCAhPT0gLTEpIHtcblxuICAgICAgICAvLyByZW1vdmUgZWxlbWVudCBmcm9tIGN1cnJlbnRJZHhcbiAgICAgICAgdGhpcy5zcGxpY2UoY3VycmVudElkeCwgMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBlbGVtZW50IGF0IGlkeFxuICAgICAgdGhpcy5zcGxpY2UoaWR4LCAwLCBlbGVtZW50KTtcblxuICAgICAgaWYgKGN1cnJlbnRJZHggPT09IC0xKSB7XG4gICAgICAgIC8vIHNldCBpbnZlcnNlLCB1bmxlc3MgZWxlbWVudCB3YXNcbiAgICAgICAgLy8gaW4gY29sbGVjdGlvbiBhbHJlYWR5XG4gICAgICAgIHJlZnMuc2V0KGVsZW1lbnQsIGludmVyc2VQcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIGEgc2ltcGxlIG1hcmtlciwgaWRlbnRpZnlpbmcgdGhpcyBlbGVtZW50XG4gIC8vIGFzIGJlaW5nIGEgcmVmcyBjb2xsZWN0aW9uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb2xsZWN0aW9uLCAnX19yZWZzX2NvbGxlY3Rpb24nLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59XG5cblxuZnVuY3Rpb24gaXNFeHRlbmRlZChjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBjb2xsZWN0aW9uLl9fcmVmc19jb2xsZWN0aW9uID09PSB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5cbm1vZHVsZS5leHBvcnRzLmlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoZSwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBwcm9wZXJ0eS5uYW1lIHx8IHByb3BlcnR5KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29sbGVjdGlvblByb3BlcnR5KHJlZiwgcHJvcGVydHksIHRhcmdldCkge1xuXG4gIHZhciBjb2xsZWN0aW9uID0gQ29sbGVjdGlvbi5leHRlbmQodGFyZ2V0W3Byb3BlcnR5Lm5hbWVdIHx8IFtdLCByZWYsIHByb3BlcnR5LCB0YXJnZXQpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5Lm5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBwcm9wZXJ0eS5lbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBjb2xsZWN0aW9uXG4gIH0pO1xuXG4gIGlmIChjb2xsZWN0aW9uLmxlbmd0aCkge1xuXG4gICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJlZi5zZXQobywgcHJvcGVydHkuaW52ZXJzZSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHJlZiwgcHJvcGVydHksIHRhcmdldCkge1xuXG4gIHZhciBpbnZlcnNlUHJvcGVydHkgPSBwcm9wZXJ0eS5pbnZlcnNlO1xuXG4gIHZhciBfdmFsdWUgPSB0YXJnZXRbcHJvcGVydHkubmFtZV07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkubmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogcHJvcGVydHkuY29uZmlndXJhYmxlLFxuICAgIGVudW1lcmFibGU6IHByb3BlcnR5LmVudW1lcmFibGUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF92YWx1ZTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgICAvLyByZXR1cm4gaWYgd2UgYWxyZWFkeSBwZXJmb3JtZWQgYWxsIGNoYW5nZXNcbiAgICAgIGlmICh2YWx1ZSA9PT0gX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9sZCA9IF92YWx1ZTtcblxuICAgICAgLy8gdGVtcG9yYXJ5IHNldCBudWxsXG4gICAgICBfdmFsdWUgPSBudWxsO1xuXG4gICAgICBpZiAob2xkKSB7XG4gICAgICAgIHJlZi51bnNldChvbGQsIGludmVyc2VQcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgX3ZhbHVlID0gdmFsdWU7XG5cbiAgICAgIC8vIHNldCBpbnZlcnNlIHZhbHVlXG4gICAgICByZWYuc2V0KF92YWx1ZSwgaW52ZXJzZVByb3BlcnR5LCB0YXJnZXQpO1xuICAgIH1cbiAgfSk7XG5cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlZmVyZW5jZXMgb2JqZWN0IGRlZmluaW5nIHR3byBpbnZlcnNseSByZWxhdGVkXG4gKiBhdHRyaWJ1dGUgZGVzY3JpcHRvcnMgYSBhbmQgYi5cbiAqXG4gKiA8cD5cbiAqICAgV2hlbiBib3VuZCB0byBhbiBvYmplY3QgdXNpbmcge0BsaW5rIFJlZnMjYmluZH0gdGhlIHJlZmVyZW5jZXNcbiAqICAgZ2V0IGFjdGl2YXRlZCBhbmQgZW5zdXJlIHRoYXQgYWRkIGFuZCByZW1vdmUgb3BlcmF0aW9ucyBhcmUgYXBwbGllZFxuICogICByZXZlcnNlbHksIHRvby5cbiAqIDwvcD5cbiAqXG4gKiA8cD5cbiAqICAgRm9yIGF0dHJpYnV0ZXMgcmVwcmVzZW50ZWQgYXMgY29sbGVjdGlvbnMge0BsaW5rIFJlZnN9IHByb3ZpZGVzIHRoZVxuICogICB7QGxpbmsgUmVmc0NvbGxlY3Rpb24jYWRkfSwge0BsaW5rIFJlZnNDb2xsZWN0aW9uI3JlbW92ZX0gYW5kIHtAbGluayBSZWZzQ29sbGVjdGlvbiNjb250YWluc30gZXh0ZW5zaW9uc1xuICogICB0aGF0IG11c3QgYmUgdXNlZCB0byBwcm9wZXJseSBob29rIGludG8gdGhlIGludmVyc2UgY2hhbmdlIG1lY2hhbmlzbS5cbiAqIDwvcD5cbiAqXG4gKiBAY2xhc3MgUmVmc1xuICpcbiAqIEBjbGFzc2Rlc2MgQSBiaS1kaXJlY3Rpb25hbCByZWZlcmVuY2UgYmV0d2VlbiB0d28gYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0ge1JlZnMuQXR0cmlidXRlRGVzY3JpcHRvcn0gYSBwcm9wZXJ0eSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge1JlZnMuQXR0cmlidXRlRGVzY3JpcHRvcn0gYiBwcm9wZXJ0eSBkZXNjcmlwdG9yXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgcmVmcyA9IFJlZnMoeyBuYW1lOiAnd2hlZWxzJywgY29sbGVjdGlvbjogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSB9LCB7IG5hbWU6ICdjYXInIH0pO1xuICpcbiAqIHZhciBjYXIgPSB7IG5hbWU6ICd0b3lvdGEnIH07XG4gKiB2YXIgd2hlZWxzID0gW3sgcG9zOiAnZnJvbnQtbGVmdCcgfSwgeyBwb3M6ICdmcm9udC1yaWdodCcgfV07XG4gKlxuICogcmVmcy5iaW5kKGNhciwgJ3doZWVscycpO1xuICpcbiAqIGNhci53aGVlbHMgLy8gW11cbiAqIGNhci53aGVlbHMuYWRkKHdoZWVsc1swXSk7XG4gKiBjYXIud2hlZWxzLmFkZCh3aGVlbHNbMV0pO1xuICpcbiAqIGNhci53aGVlbHMgLy8gW3sgcG9zOiAnZnJvbnQtbGVmdCcgfSwgeyBwb3M6ICdmcm9udC1yaWdodCcgfV1cbiAqXG4gKiB3aGVlbHNbMF0uY2FyIC8vIHsgbmFtZTogJ3RveW90YScgfTtcbiAqIGNhci53aGVlbHMucmVtb3ZlKHdoZWVsc1swXSk7XG4gKlxuICogd2hlZWxzWzBdLmNhciAvLyB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gUmVmcyhhLCBiKSB7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlZnMpKSB7XG4gICAgcmV0dXJuIG5ldyBSZWZzKGEsIGIpO1xuICB9XG5cbiAgLy8gbGlua1xuICBhLmludmVyc2UgPSBiO1xuICBiLmludmVyc2UgPSBhO1xuXG4gIHRoaXMucHJvcHMgPSB7fTtcbiAgdGhpcy5wcm9wc1thLm5hbWVdID0gYTtcbiAgdGhpcy5wcm9wc1tiLm5hbWVdID0gYjtcbn1cblxuLyoqXG4gKiBCaW5kcyBvbmUgc2lkZSBvZiBhIGJpLWRpcmVjdGlvbmFsIHJlZmVyZW5jZSB0byBhXG4gKiB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBtZW1iZXJPZiBSZWZzXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuUmVmcy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXRoaXMucHJvcHNbcHJvcGVydHldKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByb3BlcnR5IDwnICsgcHJvcGVydHkgKyAnPiBpbiByZWYnKTtcbiAgICB9XG4gICAgcHJvcGVydHkgPSB0aGlzLnByb3BzW3Byb3BlcnR5XTtcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eS5jb2xsZWN0aW9uKSB7XG4gICAgZGVmaW5lQ29sbGVjdGlvblByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB0YXJnZXQpO1xuICB9XG59O1xuXG5SZWZzLnByb3RvdHlwZS5lbnN1cmVSZWZzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHkpIHtcblxuICB2YXIgY29sbGVjdGlvbiA9IHRhcmdldFtwcm9wZXJ0eS5uYW1lXTtcblxuICBpZiAoIUNvbGxlY3Rpb24uaXNFeHRlbmRlZChjb2xsZWN0aW9uKSkge1xuICAgIGRlZmluZUNvbGxlY3Rpb25Qcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgfVxuXG4gIHJldHVybiBjb2xsZWN0aW9uO1xufTtcblxuUmVmcy5wcm90b3R5cGUuZW5zdXJlQm91bmQgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkpIHtcbiAgICB0aGlzLmJpbmQodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gIH1cbn07XG5cblJlZnMucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcblxuICBpZiAodGFyZ2V0KSB7XG4gICAgdGhpcy5lbnN1cmVCb3VuZCh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgIGlmIChwcm9wZXJ0eS5jb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLmVuc3VyZVJlZnNDb2xsZWN0aW9uKHRhcmdldCwgcHJvcGVydHkpLnJlbW92ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFtwcm9wZXJ0eS5uYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn07XG5cblJlZnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG5cbiAgaWYgKHRhcmdldCkge1xuICAgIHRoaXMuZW5zdXJlQm91bmQodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICBpZiAocHJvcGVydHkuY29sbGVjdGlvbikge1xuICAgICAgdGhpcy5lbnN1cmVSZWZzQ29sbGVjdGlvbih0YXJnZXQsIHByb3BlcnR5KS5hZGQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRbcHJvcGVydHkubmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVmcztcblxuXG4vKipcbiAqIEFuIGF0dHJpYnV0ZSBkZXNjcmlwdG9yIHRvIGJlIHVzZWQgc3BlY2lmeSBhbiBhdHRyaWJ1dGUgaW4gYSB7QGxpbmsgUmVmc30gaW5zdGFuY2VcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWZzLkF0dHJpYnV0ZURlc2NyaXB0b3JcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb2xsZWN0aW9uPWZhbHNlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbZW51bWVyYWJsZT1mYWxzZV1cbiAqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgc291cmNlIGNvZGUgYWRhcHRlZCBmcm9tIFNuYXAuc3ZnIChsaWNlbnNlZCBBcGFjaGUtMi4wKS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS13ZWJwbGF0Zm9ybS9TbmFwLnN2Zy9ibG9iL21hc3Rlci9zcmMvcGF0aC5qc1xuICovXG5cbi8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogXCJvZmZcIiAqL1xuXG52YXIgcDJzID0gLyw/KFthLXpdKSw/L2dpLFxuICAgIHRvRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgIG1hdGggPSBNYXRoLFxuICAgIFBJID0gbWF0aC5QSSxcbiAgICBtbWluID0gbWF0aC5taW4sXG4gICAgbW1heCA9IG1hdGgubWF4LFxuICAgIHBvdyA9IG1hdGgucG93LFxuICAgIGFicyA9IG1hdGguYWJzLFxuICAgIHBhdGhDb21tYW5kID0gLyhbYS16XSlbXFxzLF0qKCgtP1xcZCpcXC4/XFxkKig/OmVbLStdP1xcZCspP1tcXHNdKiw/W1xcc10qKSspL2lnLFxuICAgIHBhdGhWYWx1ZXMgPSAvKC0/XFxkKlxcLj9cXGQqKD86ZVstK10/XFxkKyk/KVtcXHNdKiw/W1xcc10qL2lnO1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24obykgeyByZXR1cm4gbyBpbnN0YW5jZW9mIEFycmF5OyB9O1xuXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmosIHByb3BlcnR5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wZXJ0eSk7XG59XG5cbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuXG4gIGlmICh0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgT2JqZWN0KG9iaikgIT09IG9iaikge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVzID0gbmV3IG9iai5jb25zdHJ1Y3RvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc1Byb3BlcnR5KG9iaiwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBjbG9uZShvYmpba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcmVwdXNoKGFycmF5LCBpdGVtKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKGFycmF5LnNwbGljZShpLCAxKVswXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FjaGVyKGYpIHtcblxuICBmdW5jdGlvbiBuZXdmKCkge1xuXG4gICAgdmFyIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgIGFyZ3MgPSBhcmcuam9pbignXFx1MjQwMCcpLFxuICAgICAgICBjYWNoZSA9IG5ld2YuY2FjaGUgPSBuZXdmLmNhY2hlIHx8IHt9LFxuICAgICAgICBjb3VudCA9IG5ld2YuY291bnQgPSBuZXdmLmNvdW50IHx8IFtdO1xuXG4gICAgaWYgKGhhc1Byb3BlcnR5KGNhY2hlLCBhcmdzKSkge1xuICAgICAgcmVwdXNoKGNvdW50LCBhcmdzKTtcbiAgICAgIHJldHVybiBjYWNoZVthcmdzXTtcbiAgICB9XG5cbiAgICBjb3VudC5sZW5ndGggPj0gMWUzICYmIGRlbGV0ZSBjYWNoZVtjb3VudC5zaGlmdCgpXTtcbiAgICBjb3VudC5wdXNoKGFyZ3MpO1xuICAgIGNhY2hlW2FyZ3NdID0gZi5hcHBseSgwLCBhcmcpO1xuXG4gICAgcmV0dXJuIGNhY2hlW2FyZ3NdO1xuICB9XG4gIHJldHVybiBuZXdmO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGhTdHJpbmcocGF0aFN0cmluZykge1xuXG4gIGlmICghcGF0aFN0cmluZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHB0aCA9IHBhdGhzKHBhdGhTdHJpbmcpO1xuXG4gIGlmIChwdGguYXJyKSB7XG4gICAgcmV0dXJuIGNsb25lKHB0aC5hcnIpO1xuICB9XG5cbiAgdmFyIHBhcmFtQ291bnRzID0geyBhOiA3LCBjOiA2LCBoOiAxLCBsOiAyLCBtOiAyLCBxOiA0LCBzOiA0LCB0OiAyLCB2OiAxLCB6OiAwIH0sXG4gICAgICBkYXRhID0gW107XG5cbiAgaWYgKGlzQXJyYXkocGF0aFN0cmluZykgJiYgaXNBcnJheShwYXRoU3RyaW5nWzBdKSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgZGF0YSA9IGNsb25lKHBhdGhTdHJpbmcpO1xuICB9XG5cbiAgaWYgKCFkYXRhLmxlbmd0aCkge1xuXG4gICAgU3RyaW5nKHBhdGhTdHJpbmcpLnJlcGxhY2UocGF0aENvbW1hbmQsIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBbXSxcbiAgICAgICAgICBuYW1lID0gYi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBjLnJlcGxhY2UocGF0aFZhbHVlcywgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBiICYmIHBhcmFtcy5wdXNoKCtiKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobmFtZSA9PSAnbScgJiYgcGFyYW1zLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zLnNwbGljZSgwLCAyKSkpO1xuICAgICAgICBuYW1lID0gJ2wnO1xuICAgICAgICBiID0gYiA9PSAnbScgPyAnbCcgOiAnTCc7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwYXJhbXMubGVuZ3RoID49IHBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcy5zcGxpY2UoMCwgcGFyYW1Db3VudHNbbmFtZV0pKSk7XG4gICAgICAgIGlmICghcGFyYW1Db3VudHNbbmFtZV0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGF0YS50b1N0cmluZyA9IHBhdGhzLnRvU3RyaW5nO1xuICBwdGguYXJyID0gY2xvbmUoZGF0YSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHBhdGhzKHBzKSB7XG4gIHZhciBwID0gcGF0aHMucHMgPSBwYXRocy5wcyB8fCB7fTtcblxuICBpZiAocFtwc10pIHtcbiAgICBwW3BzXS5zbGVlcCA9IDEwMDtcbiAgfSBlbHNlIHtcbiAgICBwW3BzXSA9IHtcbiAgICAgIHNsZWVwOiAxMDBcbiAgICB9O1xuICB9XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcCkge1xuICAgICAgaWYgKGhhc1Byb3BlcnR5KHAsIGtleSkgJiYga2V5ICE9IHBzKSB7XG4gICAgICAgIHBba2V5XS5zbGVlcC0tO1xuICAgICAgICAhcFtrZXldLnNsZWVwICYmIGRlbGV0ZSBwW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcFtwc107XG59XG5cbmZ1bmN0aW9uIHJlY3RCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHkgPSB4Lnk7XG4gICAgd2lkdGggPSB4LndpZHRoO1xuICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgIHggPSB4Lng7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDI6IHggKyB3aWR0aCxcbiAgICB5MjogeSArIGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXRoVG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLmpvaW4oJywnKS5yZXBsYWNlKHAycywgJyQxJyk7XG59XG5cbmZ1bmN0aW9uIHBhdGhDbG9uZShwYXRoQXJyYXkpIHtcbiAgdmFyIHJlcyA9IGNsb25lKHBhdGhBcnJheSk7XG4gIHJlcy50b1N0cmluZyA9IHBhdGhUb1N0cmluZztcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZmluZERvdHNBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQpIHtcbiAgdmFyIHQxID0gMSAtIHQsXG4gICAgICB0MTMgPSBwb3codDEsIDMpLFxuICAgICAgdDEyID0gcG93KHQxLCAyKSxcbiAgICAgIHQyID0gdCAqIHQsXG4gICAgICB0MyA9IHQyICogdCxcbiAgICAgIHggPSB0MTMgKiBwMXggKyB0MTIgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgdDMgKiBwMngsXG4gICAgICB5ID0gdDEzICogcDF5ICsgdDEyICogMyAqIHQgKiBjMXkgKyB0MSAqIDMgKiB0ICogdCAqIGMyeSArIHQzICogcDJ5O1xuXG4gIHJldHVybiB7XG4gICAgeDogZml4RXJyb3IoeCksXG4gICAgeTogZml4RXJyb3IoeSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmV6aWVyQkJveChwb2ludHMpIHtcblxuICB2YXIgYmJveCA9IGN1cnZlQkJveC5hcHBseShudWxsLCBwb2ludHMpO1xuXG4gIHJldHVybiByZWN0QkJveChcbiAgICBiYm94LngwLFxuICAgIGJib3gueTAsXG4gICAgYmJveC54MSAtIGJib3gueDAsXG4gICAgYmJveC55MSAtIGJib3gueTBcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNQb2ludEluc2lkZUJCb3goYmJveCwgeCwgeSkge1xuICByZXR1cm4geCA+PSBiYm94LnggJiZcbiAgICB4IDw9IGJib3gueCArIGJib3gud2lkdGggJiZcbiAgICB5ID49IGJib3gueSAmJlxuICAgIHkgPD0gYmJveC55ICsgYmJveC5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGlzQkJveEludGVyc2VjdChiYm94MSwgYmJveDIpIHtcbiAgYmJveDEgPSByZWN0QkJveChiYm94MSk7XG4gIGJib3gyID0gcmVjdEJCb3goYmJveDIpO1xuICByZXR1cm4gaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngsIGJib3gxLnkpXG4gICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngyLCBiYm94MS55KVxuICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gyLCBiYm94MS54LCBiYm94MS55MilcbiAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueDIsIGJib3gxLnkyKVxuICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54LCBiYm94Mi55KVxuICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54MiwgYmJveDIueSlcbiAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueCwgYmJveDIueTIpXG4gICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55MilcbiAgICB8fCAoYmJveDEueCA8IGJib3gyLngyICYmIGJib3gxLnggPiBiYm94Mi54XG4gICAgICAgIHx8IGJib3gyLnggPCBiYm94MS54MiAmJiBiYm94Mi54ID4gYmJveDEueClcbiAgICAmJiAoYmJveDEueSA8IGJib3gyLnkyICYmIGJib3gxLnkgPiBiYm94Mi55XG4gICAgICAgIHx8IGJib3gyLnkgPCBiYm94MS55MiAmJiBiYm94Mi55ID4gYmJveDEueSk7XG59XG5cbmZ1bmN0aW9uIGJhc2UzKHQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gIHZhciB0MSA9IC0zICogcDEgKyA5ICogcDIgLSA5ICogcDMgKyAzICogcDQsXG4gICAgICB0MiA9IHQgKiB0MSArIDYgKiBwMSAtIDEyICogcDIgKyA2ICogcDM7XG4gIHJldHVybiB0ICogdDIgLSAzICogcDEgKyAzICogcDI7XG59XG5cbmZ1bmN0aW9uIGJlemxlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHopIHtcblxuICBpZiAoeiA9PSBudWxsKSB7XG4gICAgeiA9IDE7XG4gIH1cblxuICB6ID0geiA+IDEgPyAxIDogeiA8IDAgPyAwIDogejtcblxuICB2YXIgejIgPSB6IC8gMixcbiAgICAgIG4gPSAxMixcbiAgICAgIFR2YWx1ZXMgPSBbLS4xMjUyLC4xMjUyLC0uMzY3OCwuMzY3OCwtLjU4NzMsLjU4NzMsLS43Njk5LC43Njk5LC0uOTA0MSwuOTA0MSwtLjk4MTYsLjk4MTZdLFxuICAgICAgQ3ZhbHVlcyA9IFswLjI0OTEsMC4yNDkxLDAuMjMzNSwwLjIzMzUsMC4yMDMyLDAuMjAzMiwwLjE2MDEsMC4xNjAxLDAuMTA2OSwwLjEwNjksMC4wNDcyLDAuMDQ3Ml0sXG4gICAgICBzdW0gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIGN0ID0gejIgKiBUdmFsdWVzW2ldICsgejIsXG4gICAgICAgIHhiYXNlID0gYmFzZTMoY3QsIHgxLCB4MiwgeDMsIHg0KSxcbiAgICAgICAgeWJhc2UgPSBiYXNlMyhjdCwgeTEsIHkyLCB5MywgeTQpLFxuICAgICAgICBjb21iID0geGJhc2UgKiB4YmFzZSArIHliYXNlICogeWJhc2U7XG5cbiAgICBzdW0gKz0gQ3ZhbHVlc1tpXSAqIG1hdGguc3FydChjb21iKTtcbiAgfVxuXG4gIHJldHVybiB6MiAqIHN1bTtcbn1cblxuXG5mdW5jdGlvbiBpbnRlcnNlY3RMaW5lcyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIHtcblxuICBpZiAoXG4gICAgbW1heCh4MSwgeDIpIDwgbW1pbih4MywgeDQpIHx8XG4gICAgICBtbWluKHgxLCB4MikgPiBtbWF4KHgzLCB4NCkgfHxcbiAgICAgIG1tYXgoeTEsIHkyKSA8IG1taW4oeTMsIHk0KSB8fFxuICAgICAgbW1pbih5MSwgeTIpID4gbW1heCh5MywgeTQpXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBueCA9ICh4MSAqIHkyIC0geTEgKiB4MikgKiAoeDMgLSB4NCkgLSAoeDEgLSB4MikgKiAoeDMgKiB5NCAtIHkzICogeDQpLFxuICAgICAgbnkgPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzICogeTQgLSB5MyAqIHg0KSxcbiAgICAgIGRlbm9taW5hdG9yID0gKHgxIC0geDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzIC0geDQpO1xuXG4gIGlmICghZGVub21pbmF0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHggPSBmaXhFcnJvcihueCAvIGRlbm9taW5hdG9yKSxcbiAgICAgIHB5ID0gZml4RXJyb3IobnkgLyBkZW5vbWluYXRvciksXG4gICAgICBweDIgPSArcHgudG9GaXhlZCgyKSxcbiAgICAgIHB5MiA9ICtweS50b0ZpeGVkKDIpO1xuXG4gIGlmIChcbiAgICBweDIgPCArbW1pbih4MSwgeDIpLnRvRml4ZWQoMikgfHxcbiAgICAgIHB4MiA+ICttbWF4KHgxLCB4MikudG9GaXhlZCgyKSB8fFxuICAgICAgcHgyIDwgK21taW4oeDMsIHg0KS50b0ZpeGVkKDIpIHx8XG4gICAgICBweDIgPiArbW1heCh4MywgeDQpLnRvRml4ZWQoMikgfHxcbiAgICAgIHB5MiA8ICttbWluKHkxLCB5MikudG9GaXhlZCgyKSB8fFxuICAgICAgcHkyID4gK21tYXgoeTEsIHkyKS50b0ZpeGVkKDIpIHx8XG4gICAgICBweTIgPCArbW1pbih5MywgeTQpLnRvRml4ZWQoMikgfHxcbiAgICAgIHB5MiA+ICttbWF4KHkzLCB5NCkudG9GaXhlZCgyKVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4geyB4OiBweCwgeTogcHkgfTtcbn1cblxuZnVuY3Rpb24gZml4RXJyb3IobnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIDEwMDAwMDAwMDAwMCkgLyAxMDAwMDAwMDAwMDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRCZXppZXJJbnRlcnNlY3Rpb25zKGJlejEsIGJlejIsIGp1c3RDb3VudCkge1xuICB2YXIgYmJveDEgPSBiZXppZXJCQm94KGJlejEpLFxuICAgICAgYmJveDIgPSBiZXppZXJCQm94KGJlejIpO1xuXG4gIGlmICghaXNCQm94SW50ZXJzZWN0KGJib3gxLCBiYm94MikpIHtcbiAgICByZXR1cm4ganVzdENvdW50ID8gMCA6IFtdO1xuICB9XG5cbiAgLy8gQXMgYW4gb3B0aW1pemF0aW9uLCBsaW5lcyB3aWxsIGhhdmUgb25seSAxIHNlZ21lbnRcblxuICB2YXIgbDEgPSBiZXpsZW4uYXBwbHkoMCwgYmV6MSksXG4gICAgICBsMiA9IGJlemxlbi5hcHBseSgwLCBiZXoyKSxcbiAgICAgIG4xID0gaXNMaW5lKGJlejEpID8gMSA6IH5+KGwxIC8gNSkgfHwgMSxcbiAgICAgIG4yID0gaXNMaW5lKGJlejIpID8gMSA6IH5+KGwyIC8gNSkgfHwgMSxcbiAgICAgIGRvdHMxID0gW10sXG4gICAgICBkb3RzMiA9IFtdLFxuICAgICAgeHkgPSB7fSxcbiAgICAgIHJlcyA9IGp1c3RDb3VudCA/IDAgOiBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG4xICsgMTsgaSsrKSB7XG4gICAgdmFyIHAgPSBmaW5kRG90c0F0U2VnbWVudC5hcHBseSgwLCBiZXoxLmNvbmNhdChpIC8gbjEpKTtcbiAgICBkb3RzMS5wdXNoKHsgeDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMSB9KTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBuMiArIDE7IGkrKykge1xuICAgIHAgPSBmaW5kRG90c0F0U2VnbWVudC5hcHBseSgwLCBiZXoyLmNvbmNhdChpIC8gbjIpKTtcbiAgICBkb3RzMi5wdXNoKHsgeDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMiB9KTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBuMTsgaSsrKSB7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG4yOyBqKyspIHtcbiAgICAgIHZhciBkaSA9IGRvdHMxW2ldLFxuICAgICAgICAgIGRpMSA9IGRvdHMxW2kgKyAxXSxcbiAgICAgICAgICBkaiA9IGRvdHMyW2pdLFxuICAgICAgICAgIGRqMSA9IGRvdHMyW2ogKyAxXSxcbiAgICAgICAgICBjaSA9IGFicyhkaTEueCAtIGRpLngpIDwgLjAxID8gJ3knIDogJ3gnLFxuICAgICAgICAgIGNqID0gYWJzKGRqMS54IC0gZGoueCkgPCAuMDEgPyAneScgOiAneCcsXG4gICAgICAgICAgaXMgPSBpbnRlcnNlY3RMaW5lcyhkaS54LCBkaS55LCBkaTEueCwgZGkxLnksIGRqLngsIGRqLnksIGRqMS54LCBkajEueSksXG4gICAgICAgICAga2V5O1xuXG4gICAgICBpZiAoaXMpIHtcbiAgICAgICAga2V5ID0gaXMueC50b0ZpeGVkKDkpICsgJyMnICsgaXMueS50b0ZpeGVkKDkpO1xuXG4gICAgICAgIGlmICh4eVtrZXldKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB4eVtrZXldID0gdHJ1ZTtcblxuICAgICAgICB2YXIgdDEgPSBkaS50ICsgYWJzKChpc1tjaV0gLSBkaVtjaV0pIC8gKGRpMVtjaV0gLSBkaVtjaV0pKSAqIChkaTEudCAtIGRpLnQpLFxuICAgICAgICAgICAgdDIgPSBkai50ICsgYWJzKChpc1tjal0gLSBkaltjal0pIC8gKGRqMVtjal0gLSBkaltjal0pKSAqIChkajEudCAtIGRqLnQpO1xuXG4gICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEgJiYgdDIgPj0gMCAmJiB0MiA8PSAxKSB7XG5cbiAgICAgICAgICBpZiAoanVzdENvdW50KSB7XG4gICAgICAgICAgICByZXMrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICB4OiBpcy54LFxuICAgICAgICAgICAgICB5OiBpcy55LFxuICAgICAgICAgICAgICB0MTogdDEsXG4gICAgICAgICAgICAgIHQyOiB0MlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuXG4vKipcbiAqIEZpbmQgb3IgY291bnRzIHRoZSBpbnRlcnNlY3Rpb25zIGJldHdlZW4gdHdvIFNWRyBwYXRocy5cbiAqXG4gKiBSZXR1cm5zIGEgbnVtYmVyIGluIGNvdW50aW5nIG1vZGUgYW5kIGEgbGlzdCBvZiBpbnRlcnNlY3Rpb25zIG90aGVyd2lzZS5cbiAqXG4gKiBBIHNpbmdsZSBpbnRlcnNlY3Rpb24gZW50cnkgY29udGFpbnMgdGhlIGludGVyc2VjdGlvbiBjb29yZGluYXRlcyAoeCwgeSlcbiAqIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgdGhlIGludGVyc2VjdGluZyBzZWdtZW50c1xuICogb24gZWFjaCBwYXRoIChzZWdtZW50MSwgc2VnbWVudDIpIGFuZCB0aGUgcmVsYXRpdmUgbG9jYXRpb24gb2YgdGhlXG4gKiBpbnRlcnNlY3Rpb24gb24gdGhlc2Ugc2VnbWVudHMgKHQxLCB0MikuXG4gKlxuICogVGhlIHBhdGggbWF5IGJlIGFuIFNWRyBwYXRoIHN0cmluZyBvciBhIGxpc3Qgb2YgcGF0aCBjb21wb25lbnRzXG4gKiBzdWNoIGFzIGBbIFsgJ00nLCAwLCAxMCBdLCBbICdMJywgMjAsIDAgXSBdYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBpbnRlcnNlY3Rpb25zID0gZmluZFBhdGhJbnRlcnNlY3Rpb25zKFxuICogICAnTTAsMEwxMDAsMTAwJyxcbiAqICAgWyBbICdNJywgMCwgMTAwIF0sIFsgJ0wnLCAxMDAsIDAgXSBdXG4gKiApO1xuICpcbiAqIC8vIGludGVyc2VjdGlvbnMgPSBbXG4gKiAvLyAgIHsgeDogNTAsIHk6IDUwLCBzZWdtZW50MTogMSwgc2VnbWVudDI6IDEsIHQxOiAwLjUsIHQyOiAwLjUgfVxuICogLy8gXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5PFBhdGhEZWY+fSBwYXRoMVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXk8UGF0aERlZj59IHBhdGgyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtqdXN0Q291bnQ9ZmFsc2VdXG4gKlxuICogQHJldHVybiB7QXJyYXk8SW50ZXJzZWN0aW9uPnxOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXRoSW50ZXJzZWN0aW9ucyhwYXRoMSwgcGF0aDIsIGp1c3RDb3VudCkge1xuICBwYXRoMSA9IHBhdGhUb0N1cnZlKHBhdGgxKTtcbiAgcGF0aDIgPSBwYXRoVG9DdXJ2ZShwYXRoMik7XG5cbiAgdmFyIHgxLCB5MSwgeDIsIHkyLCB4MW0sIHkxbSwgeDJtLCB5Mm0sIGJlejEsIGJlejIsXG4gICAgICByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aDEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIHZhciBwaSA9IHBhdGgxW2ldO1xuXG4gICAgaWYgKHBpWzBdID09ICdNJykge1xuICAgICAgeDEgPSB4MW0gPSBwaVsxXTtcbiAgICAgIHkxID0geTFtID0gcGlbMl07XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKHBpWzBdID09ICdDJykge1xuICAgICAgICBiZXoxID0gW3gxLCB5MV0uY29uY2F0KHBpLnNsaWNlKDEpKTtcbiAgICAgICAgeDEgPSBiZXoxWzZdO1xuICAgICAgICB5MSA9IGJlejFbN107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZXoxID0gW3gxLCB5MSwgeDEsIHkxLCB4MW0sIHkxbSwgeDFtLCB5MW1dO1xuICAgICAgICB4MSA9IHgxbTtcbiAgICAgICAgeTEgPSB5MW07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHBhdGgyLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgdmFyIHBqID0gcGF0aDJbal07XG5cbiAgICAgICAgaWYgKHBqWzBdID09ICdNJykge1xuICAgICAgICAgIHgyID0geDJtID0gcGpbMV07XG4gICAgICAgICAgeTIgPSB5Mm0gPSBwalsyXTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGlmIChwalswXSA9PSAnQycpIHtcbiAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyXS5jb25jYXQocGouc2xpY2UoMSkpO1xuICAgICAgICAgICAgeDIgPSBiZXoyWzZdO1xuICAgICAgICAgICAgeTIgPSBiZXoyWzddO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZXoyID0gW3gyLCB5MiwgeDIsIHkyLCB4Mm0sIHkybSwgeDJtLCB5Mm1dO1xuICAgICAgICAgICAgeDIgPSB4Mm07XG4gICAgICAgICAgICB5MiA9IHkybTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW50ciA9IGZpbmRCZXppZXJJbnRlcnNlY3Rpb25zKGJlejEsIGJlejIsIGp1c3RDb3VudCk7XG5cbiAgICAgICAgICBpZiAoanVzdENvdW50KSB7XG4gICAgICAgICAgICByZXMgKz0gaW50cjtcbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBpbnRyLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgICAgICAgaW50cltrXS5zZWdtZW50MSA9IGk7XG4gICAgICAgICAgICAgIGludHJba10uc2VnbWVudDIgPSBqO1xuICAgICAgICAgICAgICBpbnRyW2tdLmJlejEgPSBiZXoxO1xuICAgICAgICAgICAgICBpbnRyW2tdLmJlejIgPSBiZXoyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGludHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cblxuZnVuY3Rpb24gcGF0aFRvQWJzb2x1dGUocGF0aEFycmF5KSB7XG4gIHZhciBwdGggPSBwYXRocyhwYXRoQXJyYXkpO1xuXG4gIGlmIChwdGguYWJzKSB7XG4gICAgcmV0dXJuIHBhdGhDbG9uZShwdGguYWJzKTtcbiAgfVxuXG4gIGlmICghaXNBcnJheShwYXRoQXJyYXkpIHx8ICFpc0FycmF5KHBhdGhBcnJheSAmJiBwYXRoQXJyYXlbMF0pKSB7IC8vIHJvdWdoIGFzc3VtcHRpb25cbiAgICBwYXRoQXJyYXkgPSBwYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcbiAgfVxuXG4gIGlmICghcGF0aEFycmF5IHx8ICFwYXRoQXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtbJ00nLCAwLCAwXV07XG4gIH1cblxuICB2YXIgcmVzID0gW10sXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgbXggPSAwLFxuICAgICAgbXkgPSAwLFxuICAgICAgc3RhcnQgPSAwLFxuICAgICAgcGEwO1xuXG4gIGlmIChwYXRoQXJyYXlbMF1bMF0gPT0gJ00nKSB7XG4gICAgeCA9ICtwYXRoQXJyYXlbMF1bMV07XG4gICAgeSA9ICtwYXRoQXJyYXlbMF1bMl07XG4gICAgbXggPSB4O1xuICAgIG15ID0geTtcbiAgICBzdGFydCsrO1xuICAgIHJlc1swXSA9IFsnTScsIHgsIHldO1xuICB9XG5cbiAgZm9yICh2YXIgciwgcGEsIGkgPSBzdGFydCwgaWkgPSBwYXRoQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIHJlcy5wdXNoKHIgPSBbXSk7XG4gICAgcGEgPSBwYXRoQXJyYXlbaV07XG4gICAgcGEwID0gcGFbMF07XG5cbiAgICBpZiAocGEwICE9IHBhMC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICByWzBdID0gcGEwLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIHJbMV0gPSBwYVsxXTtcbiAgICAgICAgclsyXSA9IHBhWzJdO1xuICAgICAgICByWzNdID0gcGFbM107XG4gICAgICAgIHJbNF0gPSBwYVs0XTtcbiAgICAgICAgcls1XSA9IHBhWzVdO1xuICAgICAgICByWzZdID0gK3BhWzZdICsgeDtcbiAgICAgICAgcls3XSA9ICtwYVs3XSArIHk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVic6XG4gICAgICAgIHJbMV0gPSArcGFbMV0gKyB5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgICByWzFdID0gK3BhWzFdICsgeDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNJzpcbiAgICAgICAgbXggPSArcGFbMV0gKyB4O1xuICAgICAgICBteSA9ICtwYVsyXSArIHk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBmb3IgKHZhciBqID0gMSwgamogPSBwYS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgcltqXSA9ICtwYVtqXSArICgoaiAlIDIpID8geCA6IHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IHBhLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgcltrXSA9IHBhW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICBwYTAgPSBwYTAudG9VcHBlckNhc2UoKTtcblxuICAgIHN3aXRjaCAoclswXSkge1xuICAgIGNhc2UgJ1onOlxuICAgICAgeCA9ICtteDtcbiAgICAgIHkgPSArbXk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdIJzpcbiAgICAgIHggPSByWzFdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnVic6XG4gICAgICB5ID0gclsxXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ00nOlxuICAgICAgbXggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICBteSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICBkZWZhdWx0OlxuICAgICAgeCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgIHkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9XG5cbiAgcmVzLnRvU3RyaW5nID0gcGF0aFRvU3RyaW5nO1xuICBwdGguYWJzID0gcGF0aENsb25lKHJlcyk7XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gaXNMaW5lKGJleikge1xuICByZXR1cm4gKFxuICAgIGJlelswXSA9PT0gYmV6WzJdICYmXG4gICAgYmV6WzFdID09PSBiZXpbM10gJiZcbiAgICBiZXpbNF0gPT09IGJlels2XSAmJlxuICAgIGJlels1XSA9PT0gYmV6WzddXG4gICk7XG59XG5cbmZ1bmN0aW9uIGxpbmVUb0N1cnZlKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHJldHVybiBbXG4gICAgeDEsIHkxLCB4MixcbiAgICB5MiwgeDIsIHkyXG4gIF07XG59XG5cbmZ1bmN0aW9uIHF1YmljVG9DdXJ2ZSh4MSwgeTEsIGF4LCBheSwgeDIsIHkyKSB7XG4gIHZhciBfMTMgPSAxIC8gMyxcbiAgICAgIF8yMyA9IDIgLyAzO1xuXG4gIHJldHVybiBbXG4gICAgXzEzICogeDEgKyBfMjMgKiBheCxcbiAgICBfMTMgKiB5MSArIF8yMyAqIGF5LFxuICAgIF8xMyAqIHgyICsgXzIzICogYXgsXG4gICAgXzEzICogeTIgKyBfMjMgKiBheSxcbiAgICB4MixcbiAgICB5MlxuICBdO1xufVxuXG5mdW5jdGlvbiBhcmNUb0N1cnZlKHgxLCB5MSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHgyLCB5MiwgcmVjdXJzaXZlKSB7XG5cbiAgLy8gZm9yIG1vcmUgaW5mb3JtYXRpb24gb2Ygd2hlcmUgdGhpcyBtYXRoIGNhbWUgZnJvbSB2aXNpdDpcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gIHZhciBfMTIwID0gUEkgKiAxMjAgLyAxODAsXG4gICAgICByYWQgPSBQSSAvIDE4MCAqICgrYW5nbGUgfHwgMCksXG4gICAgICByZXMgPSBbXSxcbiAgICAgIHh5LFxuICAgICAgcm90YXRlID0gY2FjaGVyKGZ1bmN0aW9uKHgsIHksIHJhZCkge1xuICAgICAgICB2YXIgWCA9IHggKiBtYXRoLmNvcyhyYWQpIC0geSAqIG1hdGguc2luKHJhZCksXG4gICAgICAgICAgICBZID0geCAqIG1hdGguc2luKHJhZCkgKyB5ICogbWF0aC5jb3MocmFkKTtcblxuICAgICAgICByZXR1cm4geyB4OiBYLCB5OiBZIH07XG4gICAgICB9KTtcblxuICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgIHh5ID0gcm90YXRlKHgxLCB5MSwgLXJhZCk7XG4gICAgeDEgPSB4eS54O1xuICAgIHkxID0geHkueTtcbiAgICB4eSA9IHJvdGF0ZSh4MiwgeTIsIC1yYWQpO1xuICAgIHgyID0geHkueDtcbiAgICB5MiA9IHh5Lnk7XG5cbiAgICB2YXIgeCA9ICh4MSAtIHgyKSAvIDIsXG4gICAgICAgIHkgPSAoeTEgLSB5MikgLyAyO1xuXG4gICAgdmFyIGggPSAoeCAqIHgpIC8gKHJ4ICogcngpICsgKHkgKiB5KSAvIChyeSAqIHJ5KTtcblxuICAgIGlmIChoID4gMSkge1xuICAgICAgaCA9IG1hdGguc3FydChoKTtcbiAgICAgIHJ4ID0gaCAqIHJ4O1xuICAgICAgcnkgPSBoICogcnk7XG4gICAgfVxuXG4gICAgdmFyIHJ4MiA9IHJ4ICogcngsXG4gICAgICAgIHJ5MiA9IHJ5ICogcnksXG4gICAgICAgIGsgPSAobGFyZ2VfYXJjX2ZsYWcgPT0gc3dlZXBfZmxhZyA/IC0xIDogMSkgKlxuICAgICAgICAgICAgbWF0aC5zcXJ0KGFicygocngyICogcnkyIC0gcngyICogeSAqIHkgLSByeTIgKiB4ICogeCkgLyAocngyICogeSAqIHkgKyByeTIgKiB4ICogeCkpKSxcbiAgICAgICAgY3ggPSBrICogcnggKiB5IC8gcnkgKyAoeDEgKyB4MikgLyAyLFxuICAgICAgICBjeSA9IGsgKiAtcnkgKiB4IC8gcnggKyAoeTEgKyB5MikgLyAyLFxuICAgICAgICBmMSA9IG1hdGguYXNpbigoKHkxIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpLFxuICAgICAgICBmMiA9IG1hdGguYXNpbigoKHkyIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpO1xuXG4gICAgZjEgPSB4MSA8IGN4ID8gUEkgLSBmMSA6IGYxO1xuICAgIGYyID0geDIgPCBjeCA/IFBJIC0gZjIgOiBmMjtcbiAgICBmMSA8IDAgJiYgKGYxID0gUEkgKiAyICsgZjEpO1xuICAgIGYyIDwgMCAmJiAoZjIgPSBQSSAqIDIgKyBmMik7XG5cbiAgICBpZiAoc3dlZXBfZmxhZyAmJiBmMSA+IGYyKSB7XG4gICAgICBmMSA9IGYxIC0gUEkgKiAyO1xuICAgIH1cbiAgICBpZiAoIXN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSkge1xuICAgICAgZjIgPSBmMiAtIFBJICogMjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZjEgPSByZWN1cnNpdmVbMF07XG4gICAgZjIgPSByZWN1cnNpdmVbMV07XG4gICAgY3ggPSByZWN1cnNpdmVbMl07XG4gICAgY3kgPSByZWN1cnNpdmVbM107XG4gIH1cblxuICB2YXIgZGYgPSBmMiAtIGYxO1xuXG4gIGlmIChhYnMoZGYpID4gXzEyMCkge1xuICAgIHZhciBmMm9sZCA9IGYyLFxuICAgICAgICB4Mm9sZCA9IHgyLFxuICAgICAgICB5Mm9sZCA9IHkyO1xuXG4gICAgZjIgPSBmMSArIF8xMjAgKiAoc3dlZXBfZmxhZyAmJiBmMiA+IGYxID8gMSA6IC0xKTtcbiAgICB4MiA9IGN4ICsgcnggKiBtYXRoLmNvcyhmMik7XG4gICAgeTIgPSBjeSArIHJ5ICogbWF0aC5zaW4oZjIpO1xuICAgIHJlcyA9IGFyY1RvQ3VydmUoeDIsIHkyLCByeCwgcnksIGFuZ2xlLCAwLCBzd2VlcF9mbGFnLCB4Mm9sZCwgeTJvbGQsIFtmMiwgZjJvbGQsIGN4LCBjeV0pO1xuICB9XG5cbiAgZGYgPSBmMiAtIGYxO1xuXG4gIHZhciBjMSA9IG1hdGguY29zKGYxKSxcbiAgICAgIHMxID0gbWF0aC5zaW4oZjEpLFxuICAgICAgYzIgPSBtYXRoLmNvcyhmMiksXG4gICAgICBzMiA9IG1hdGguc2luKGYyKSxcbiAgICAgIHQgPSBtYXRoLnRhbihkZiAvIDQpLFxuICAgICAgaHggPSA0IC8gMyAqIHJ4ICogdCxcbiAgICAgIGh5ID0gNCAvIDMgKiByeSAqIHQsXG4gICAgICBtMSA9IFt4MSwgeTFdLFxuICAgICAgbTIgPSBbeDEgKyBoeCAqIHMxLCB5MSAtIGh5ICogYzFdLFxuICAgICAgbTMgPSBbeDIgKyBoeCAqIHMyLCB5MiAtIGh5ICogYzJdLFxuICAgICAgbTQgPSBbeDIsIHkyXTtcblxuICBtMlswXSA9IDIgKiBtMVswXSAtIG0yWzBdO1xuICBtMlsxXSA9IDIgKiBtMVsxXSAtIG0yWzFdO1xuXG4gIGlmIChyZWN1cnNpdmUpIHtcbiAgICByZXR1cm4gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlcyA9IFttMiwgbTMsIG00XS5jb25jYXQocmVzKS5qb2luKCkuc3BsaXQoJywnKTtcbiAgICB2YXIgbmV3cmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgbmV3cmVzW2ldID0gaSAlIDIgPyByb3RhdGUocmVzW2kgLSAxXSwgcmVzW2ldLCByYWQpLnkgOiByb3RhdGUocmVzW2ldLCByZXNbaSArIDFdLCByYWQpLng7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld3JlcztcbiAgfVxufVxuXG4vLyBSZXR1cm5zIGJvdW5kaW5nIGJveCBvZiBjdWJpYyBiZXppZXIgY3VydmUuXG4vLyBTb3VyY2U6IGh0dHA6Ly9ibG9nLmhhY2tlcnMtY2FmZS5uZXQvMjAwOS8wNi9ob3ctdG8tY2FsY3VsYXRlLWJlemllci1jdXJ2ZXMtYm91bmRpbmcuaHRtbFxuLy8gT3JpZ2luYWwgdmVyc2lvbjogTklTSElPIEhpcm9rYXp1XG4vLyBNb2RpZmljYXRpb25zOiBodHRwczovL2dpdGh1Yi5jb20vdGltbzIyMzQ1XG5mdW5jdGlvbiBjdXJ2ZUJCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIHZhciB0dmFsdWVzID0gW10sXG4gICAgICBib3VuZHMgPSBbW10sIFtdXSxcbiAgICAgIGEsIGIsIGMsIHQsIHQxLCB0MiwgYjJhYywgc3FydGIyYWM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcblxuICAgIGlmIChpID09IDApIHtcbiAgICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gNiAqIHkwIC0gMTIgKiB5MSArIDYgKiB5MjtcbiAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgYyA9IDMgKiB5MSAtIDMgKiB5MDtcbiAgICB9XG5cbiAgICBpZiAoYWJzKGEpIDwgMWUtMTIpIHtcblxuICAgICAgaWYgKGFicyhiKSA8IDFlLTEyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0ID0gLWMgLyBiO1xuXG4gICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgc3FydGIyYWMgPSBtYXRoLnNxcnQoYjJhYyk7XG5cbiAgICBpZiAoYjJhYyA8IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHQxID0gKC1iICsgc3FydGIyYWMpIC8gKDIgKiBhKTtcblxuICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgIH1cblxuICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcblxuICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBqID0gdHZhbHVlcy5sZW5ndGgsXG4gICAgICBqbGVuID0gaixcbiAgICAgIG10O1xuXG4gIHdoaWxlIChqLS0pIHtcbiAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICBtdCA9IDEgLSB0O1xuICAgIGJvdW5kc1swXVtqXSA9IChtdCAqIG10ICogbXQgKiB4MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeDEpICsgKDMgKiBtdCAqIHQgKiB0ICogeDIpICsgKHQgKiB0ICogdCAqIHgzKTtcbiAgICBib3VuZHNbMV1bal0gPSAobXQgKiBtdCAqIG10ICogeTApICsgKDMgKiBtdCAqIG10ICogdCAqIHkxKSArICgzICogbXQgKiB0ICogdCAqIHkyKSArICh0ICogdCAqIHQgKiB5Myk7XG4gIH1cblxuICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgYm91bmRzWzFdW2psZW5dID0geTA7XG4gIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuICBib3VuZHNbMF0ubGVuZ3RoID0gYm91bmRzWzFdLmxlbmd0aCA9IGpsZW4gKyAyO1xuXG4gIHJldHVybiB7XG4gICAgeDA6IG1taW4uYXBwbHkoMCwgYm91bmRzWzBdKSxcbiAgICB5MDogbW1pbi5hcHBseSgwLCBib3VuZHNbMV0pLFxuICAgIHgxOiBtbWF4LmFwcGx5KDAsIGJvdW5kc1swXSksXG4gICAgeTE6IG1tYXguYXBwbHkoMCwgYm91bmRzWzFdKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXRoVG9DdXJ2ZShwYXRoKSB7XG5cbiAgdmFyIHB0aCA9IHBhdGhzKHBhdGgpO1xuXG4gIC8vIHJldHVybiBjYWNoZWQgY3VydmUsIGlmIGV4aXN0aW5nXG4gIGlmIChwdGguY3VydmUpIHtcbiAgICByZXR1cm4gcGF0aENsb25lKHB0aC5jdXJ2ZSk7XG4gIH1cblxuICB2YXIgY3VydmVkUGF0aCA9IHBhdGhUb0Fic29sdXRlKHBhdGgpLFxuICAgICAgYXR0cnMgPSB7IHg6IDAsIHk6IDAsIGJ4OiAwLCBieTogMCwgWDogMCwgWTogMCwgcXg6IG51bGwsIHF5OiBudWxsIH0sXG4gICAgICBwcm9jZXNzUGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGQsIHBhdGhDb21tYW5kKSB7XG4gICAgICAgIHZhciBueCwgbnk7XG5cbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIFsnQycsIGQueCwgZC55LCBkLngsIGQueSwgZC54LCBkLnldO1xuICAgICAgICB9XG5cbiAgICAgICAgIShwYXRoWzBdIGluIHsgVDogMSwgUTogMSB9KSAmJiAoZC5xeCA9IGQucXkgPSBudWxsKTtcblxuICAgICAgICBzd2l0Y2ggKHBhdGhbMF0pIHtcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgZC5YID0gcGF0aFsxXTtcbiAgICAgICAgICBkLlkgPSBwYXRoWzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KGFyY1RvQ3VydmUuYXBwbHkoMCwgW2QueCwgZC55XS5jb25jYXQocGF0aC5zbGljZSgxKSkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgaWYgKHBhdGhDb21tYW5kID09ICdDJyB8fCBwYXRoQ29tbWFuZCA9PSAnUycpIHtcblxuICAgICAgICAgICAgLy8gSW4gJ1MnIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgQy9TLlxuICAgICAgICAgICAgbnggPSBkLnggKiAyIC0gZC5ieDtcblxuICAgICAgICAgICAgLy8gQW5kIHJlZmxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICBueSA9IGQueSAqIDIgLSBkLmJ5O1xuXG4gICAgICAgICAgICAvLyBjb21tYW5kJ3MgY29udHJvbCBwb2ludCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIG9yIHNvbWUgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgICBueCA9IGQueDtcbiAgICAgICAgICAgIG55ID0gZC55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRoID0gWydDJywgbngsIG55XS5jb25jYXQocGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgIGlmIChwYXRoQ29tbWFuZCA9PSAnUScgfHwgcGF0aENvbW1hbmQgPT0gJ1QnKSB7XG5cbiAgICAgICAgICAgIC8vIEluICdUJyBjYXNlIHdlIGhhdmUgdG8gdGFrZSBpbnRvIGFjY291bnQsIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIGlzIFEvVC5cbiAgICAgICAgICAgIGQucXggPSBkLnggKiAyIC0gZC5xeDtcblxuICAgICAgICAgICAgLy8gQW5kIG1ha2UgYSByZWZsZWN0aW9uIHNpbWlsYXJcbiAgICAgICAgICAgIGQucXkgPSBkLnkgKiAyIC0gZC5xeTtcblxuICAgICAgICAgICAgLy8gdG8gY2FzZSAnUycuXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBvciBzb21ldGhpbmcgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgICBkLnF4ID0gZC54O1xuICAgICAgICAgICAgZC5xeSA9IGQueTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChxdWJpY1RvQ3VydmUoZC54LCBkLnksIGQucXgsIGQucXksIHBhdGhbMV0sIHBhdGhbMl0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgZC5xeCA9IHBhdGhbMV07XG4gICAgICAgICAgZC5xeSA9IHBhdGhbMl07XG4gICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChxdWJpY1RvQ3VydmUoZC54LCBkLnksIHBhdGhbMV0sIHBhdGhbMl0sIHBhdGhbM10sIHBhdGhbNF0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChsaW5lVG9DdXJ2ZShkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KGxpbmVUb0N1cnZlKGQueCwgZC55LCBwYXRoWzFdLCBkLnkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChsaW5lVG9DdXJ2ZShkLngsIGQueSwgZC54LCBwYXRoWzFdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQobGluZVRvQ3VydmUoZC54LCBkLnksIGQuWCwgZC5ZKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH0sXG5cbiAgICAgIGZpeEFyYyA9IGZ1bmN0aW9uKHBwLCBpKSB7XG5cbiAgICAgICAgaWYgKHBwW2ldLmxlbmd0aCA+IDcpIHtcbiAgICAgICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgICAgIHZhciBwaSA9IHBwW2ldO1xuXG4gICAgICAgICAgd2hpbGUgKHBpLmxlbmd0aCkge1xuICAgICAgICAgICAgcGF0aENvbW1hbmRzW2ldID0gJ0EnOyAvLyBpZiBjcmVhdGVkIG11bHRpcGxlIEM6cywgdGhlaXIgb3JpZ2luYWwgc2VnIGlzIHNhdmVkXG4gICAgICAgICAgICBwcC5zcGxpY2UoaSsrLCAwLCBbJ0MnXS5jb25jYXQocGkuc3BsaWNlKDAsIDYpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGlpID0gY3VydmVkUGF0aC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHBhdGhDb21tYW5kcyA9IFtdLCAvLyBwYXRoIGNvbW1hbmRzIG9mIG9yaWdpbmFsIHBhdGggcFxuICAgICAgcGZpcnN0ID0gJycsIC8vIHRlbXBvcmFyeSBob2xkZXIgZm9yIG9yaWdpbmFsIHBhdGggY29tbWFuZFxuICAgICAgcGF0aENvbW1hbmQgPSAnJzsgLy8gaG9sZGVyIGZvciBwcmV2aW91cyBwYXRoIGNvbW1hbmQgb2Ygb3JpZ2luYWwgcGF0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGN1cnZlZFBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGN1cnZlZFBhdGhbaV0gJiYgKHBmaXJzdCA9IGN1cnZlZFBhdGhbaV1bMF0pOyAvLyBzYXZlIGN1cnJlbnQgcGF0aCBjb21tYW5kXG5cbiAgICBpZiAocGZpcnN0ICE9ICdDJykgLy8gQyBpcyBub3Qgc2F2ZWQgeWV0LCBiZWNhdXNlIGl0IG1heSBiZSByZXN1bHQgb2YgY29udmVyc2lvblxuICAgIHtcbiAgICAgIHBhdGhDb21tYW5kc1tpXSA9IHBmaXJzdDsgLy8gU2F2ZSBjdXJyZW50IHBhdGggY29tbWFuZFxuICAgICAgaSAmJiAocGF0aENvbW1hbmQgPSBwYXRoQ29tbWFuZHNbaSAtIDFdKTsgLy8gR2V0IHByZXZpb3VzIHBhdGggY29tbWFuZCBwYXRoQ29tbWFuZFxuICAgIH1cbiAgICBjdXJ2ZWRQYXRoW2ldID0gcHJvY2Vzc1BhdGgoY3VydmVkUGF0aFtpXSwgYXR0cnMsIHBhdGhDb21tYW5kKTsgLy8gUHJldmlvdXMgcGF0aCBjb21tYW5kIGlzIGlucHV0dGVkIHRvIHByb2Nlc3NQYXRoXG5cbiAgICBpZiAocGF0aENvbW1hbmRzW2ldICE9ICdBJyAmJiBwZmlyc3QgPT0gJ0MnKSBwYXRoQ29tbWFuZHNbaV0gPSAnQyc7IC8vIEEgaXMgdGhlIG9ubHkgY29tbWFuZFxuICAgIC8vIHdoaWNoIG1heSBwcm9kdWNlIG11bHRpcGxlIEM6c1xuICAgIC8vIHNvIHdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgQyBpcyBhbHNvIEMgaW4gb3JpZ2luYWwgcGF0aFxuXG4gICAgZml4QXJjKGN1cnZlZFBhdGgsIGkpOyAvLyBmaXhBcmMgYWRkcyBhbHNvIHRoZSByaWdodCBhbW91bnQgb2YgQTpzIHRvIHBhdGhDb21tYW5kc1xuXG4gICAgdmFyIHNlZyA9IGN1cnZlZFBhdGhbaV0sXG4gICAgICAgIHNlZ2xlbiA9IHNlZy5sZW5ndGg7XG5cbiAgICBhdHRycy54ID0gc2VnW3NlZ2xlbiAtIDJdO1xuICAgIGF0dHJzLnkgPSBzZWdbc2VnbGVuIC0gMV07XG4gICAgYXR0cnMuYnggPSB0b0Zsb2F0KHNlZ1tzZWdsZW4gLSA0XSkgfHwgYXR0cnMueDtcbiAgICBhdHRycy5ieSA9IHRvRmxvYXQoc2VnW3NlZ2xlbiAtIDNdKSB8fCBhdHRycy55O1xuICB9XG5cbiAgLy8gY2FjaGUgY3VydmVcbiAgcHRoLmN1cnZlID0gcGF0aENsb25lKGN1cnZlZFBhdGgpO1xuXG4gIHJldHVybiBjdXJ2ZWRQYXRoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRQYXRoSW50ZXJzZWN0aW9ucztcbiIsInZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgRU5USVRZX1BBVFRFUk4gPSAvJiMoXFxkKyk7fCYjeChbMC05YS1mXSspO3wmKFxcdyspOy9pZztcblxudmFyIEVOVElUWV9NQVBQSU5HID0ge1xuICAnYW1wJzogJyYnLFxuICAnYXBvcyc6ICdcXCcnLFxuICAnZ3QnOiAnPicsXG4gICdsdCc6ICc8JyxcbiAgJ3F1b3QnOiAnXCInXG59O1xuXG4vLyBtYXAgVVBQRVJDQVNFIHZhcmlhbnRzIG9mIHN1cHBvcnRlZCBzcGVjaWFsIGNoYXJzXG5PYmplY3Qua2V5cyhFTlRJVFlfTUFQUElORykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIEVOVElUWV9NQVBQSU5HW2sudG9VcHBlckNhc2UoKV0gPSBFTlRJVFlfTUFQUElOR1trXTtcbn0pO1xuXG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdGllcyhfLCBkLCB4LCB6KSB7XG5cbiAgLy8gcmVzZXJ2ZWQgbmFtZXMsIGkuZS4gJm5ic3A7XG4gIGlmICh6KSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoRU5USVRZX01BUFBJTkcsIHopKSB7XG4gICAgICByZXR1cm4gRU5USVRZX01BUFBJTkdbel07XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gZmFsbCBiYWNrIHRvIG9yaWdpbmFsIHZhbHVlXG4gICAgICByZXR1cm4gJyYnICsgeiArICc7JztcbiAgICB9XG4gIH1cblxuICAvLyBkZWNpbWFsIGVuY29kZWQgY2hhclxuICBpZiAoZCkge1xuICAgIHJldHVybiBmcm9tQ2hhckNvZGUoZCk7XG4gIH1cblxuICAvLyBoZXggZW5jb2RlZCBjaGFyXG4gIHJldHVybiBmcm9tQ2hhckNvZGUocGFyc2VJbnQoeCwgMTYpKTtcbn1cblxuXG4vKipcbiAqIEEgYmFzaWMgZW50aXR5IGRlY29kZXIgdGhhdCBjYW4gZGVjb2RlIGEgbWluaW1hbFxuICogc3ViLXNldCBvZiByZXNlcnZlZCBuYW1lcyAoJmFtcDspIGFzIHdlbGwgYXNcbiAqIGhleCAoJiN4YWFmOykgYW5kIGRlY2ltYWwgKCYjMTIzMTspIGVuY29kZWQgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBkZWNvZGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBkZWNvZGVFbnRpdGllcyhzKSB7XG4gIGlmIChzLmxlbmd0aCA+IDMgJiYgcy5pbmRleE9mKCcmJykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShFTlRJVFlfUEFUVEVSTiwgcmVwbGFjZUVudGl0aWVzKTtcbiAgfVxuXG4gIHJldHVybiBzO1xufVxuXG52YXIgWFNJX1VSSSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZSc7XG52YXIgWFNJX1BSRUZJWCA9ICd4c2knO1xudmFyIFhTSV9UWVBFID0gJ3hzaTp0eXBlJztcblxudmFyIE5PTl9XSElURVNQQUNFX09VVFNJREVfUk9PVF9OT0RFID0gJ25vbi13aGl0ZXNwYWNlIG91dHNpZGUgb2Ygcm9vdCBub2RlJztcblxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHJldHVybiBuZXcgRXJyb3IobXNnKTtcbn1cblxuZnVuY3Rpb24gbWlzc2luZ05hbWVzcGFjZUZvclByZWZpeChwcmVmaXgpIHtcbiAgcmV0dXJuICdtaXNzaW5nIG5hbWVzcGFjZSBmb3IgcHJlZml4IDwnICsgcHJlZml4ICsgJz4nO1xufVxuXG5mdW5jdGlvbiBnZXR0ZXIoZ2V0Rm4pIHtcbiAgcmV0dXJuIHtcbiAgICAnZ2V0JzogZ2V0Rm4sXG4gICAgJ2VudW1lcmFibGUnOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsb25lTnNNYXRyaXgobnNNYXRyaXgpIHtcbiAgdmFyIGNsb25lID0ge30sIGtleTtcbiAgZm9yIChrZXkgaW4gbnNNYXRyaXgpIHtcbiAgICBjbG9uZVtrZXldID0gbnNNYXRyaXhba2V5XTtcbiAgfVxuICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHVyaVByZWZpeChwcmVmaXgpIHtcbiAgcmV0dXJuIHByZWZpeCArICckdXJpJztcbn1cblxuZnVuY3Rpb24gYnVpbGROc01hdHJpeChuc1VyaVRvUHJlZml4KSB7XG4gIHZhciBuc01hdHJpeCA9IHt9LFxuICAgICAgdXJpLFxuICAgICAgcHJlZml4O1xuXG4gIGZvciAodXJpIGluIG5zVXJpVG9QcmVmaXgpIHtcbiAgICBwcmVmaXggPSBuc1VyaVRvUHJlZml4W3VyaV07XG4gICAgbnNNYXRyaXhbcHJlZml4XSA9IHByZWZpeDtcbiAgICBuc01hdHJpeFt1cmlQcmVmaXgocHJlZml4KV0gPSB1cmk7XG4gIH1cblxuICByZXR1cm4gbnNNYXRyaXg7XG59XG5cbmZ1bmN0aW9uIG5vb3BHZXRDb250ZXh0KCkge1xuICByZXR1cm4geyAnbGluZSc6IDAsICdjb2x1bW4nOiAwIH07XG59XG5cbmZ1bmN0aW9uIHRocm93RnVuYyhlcnIpIHtcbiAgdGhyb3cgZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcGFyc2VyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtICB7IU9iamVjdDxzdHJpbmcsID8+PX0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuXG4gIGlmICghdGhpcykge1xuICAgIHJldHVybiBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHByb3h5ID0gb3B0aW9ucyAmJiBvcHRpb25zWydwcm94eSddO1xuXG4gIHZhciBvblRleHQsXG4gICAgICBvbk9wZW5UYWcsXG4gICAgICBvbkNsb3NlVGFnLFxuICAgICAgb25DREFUQSxcbiAgICAgIG9uRXJyb3IgPSB0aHJvd0Z1bmMsXG4gICAgICBvbldhcm5pbmcsXG4gICAgICBvbkNvbW1lbnQsXG4gICAgICBvblF1ZXN0aW9uLFxuICAgICAgb25BdHRlbnRpb247XG5cbiAgdmFyIGdldENvbnRleHQgPSBub29wR2V0Q29udGV4dDtcblxuICAvKipcbiAgICogRG8gd2UgbmVlZCB0byBwYXJzZSB0aGUgY3VycmVudCBlbGVtZW50cyBhdHRyaWJ1dGVzIGZvciBuYW1lc3BhY2VzP1xuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHZhciBtYXliZU5TID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIERvIHdlIHByb2Nlc3MgbmFtZXNwYWNlcyBhdCBhbGw/XG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdmFyIGlzTmFtZXNwYWNlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBjYXVnaHQgZXJyb3IgcmV0dXJuZWQgb24gcGFyc2UgZW5kXG4gICAqXG4gICAqIEB0eXBlIHtFcnJvcn1cbiAgICovXG4gIHZhciByZXR1cm5FcnJvciA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNob3VsZCB3ZSBzdG9wIHBhcnNpbmc/XG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdmFyIHBhcnNlU3RvcCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIG1hcCBvZiB7IHVyaTogcHJlZml4IH0gdXNlZCBieSB0aGUgcGFyc2VyLlxuICAgKlxuICAgKiBUaGlzIG1hcCB3aWxsIGVuc3VyZSB3ZSBjYW4gbm9ybWFsaXplIHByZWZpeGVzIGR1cmluZyBwcm9jZXNzaW5nO1xuICAgKiBmb3IgZWFjaCB1cmksIG9ubHkgb25lIHByZWZpeCB3aWxsIGJlIGV4cG9zZWQgdG8gdGhlIGhhbmRsZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59fVxuICAgKi9cbiAgdmFyIG5zVXJpVG9QcmVmaXg7XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwYXJzZSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEVycm9yfSBlcnJcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycikge1xuICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgZXJyID0gZXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm5FcnJvciA9IGVycjtcblxuICAgIG9uRXJyb3IoZXJyLCBnZXRDb250ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcGFyc2UgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xFcnJvcn0gZXJyXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVXYXJuaW5nKGVycikge1xuXG4gICAgaWYgKCFvbldhcm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgIGVyciA9IGVycm9yKGVycik7XG4gICAgfVxuXG4gICAgb25XYXJuaW5nKGVyciwgZ2V0Q29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgcGFyc2UgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBuYW1lXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKlxuICAgKiBAcmV0dXJuIHtQYXJzZXJ9XG4gICAqL1xuICB0aGlzWydvbiddID0gZnVuY3Rpb24obmFtZSwgY2IpIHtcblxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVycm9yKCdyZXF1aXJlZCBhcmdzIDxuYW1lLCBjYj4nKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvcGVuVGFnJzogb25PcGVuVGFnID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ3RleHQnOiBvblRleHQgPSBjYjsgYnJlYWs7XG4gICAgY2FzZSAnY2xvc2VUYWcnOiBvbkNsb3NlVGFnID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ2Vycm9yJzogb25FcnJvciA9IGNiOyBicmVhaztcbiAgICBjYXNlICd3YXJuJzogb25XYXJuaW5nID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ2NkYXRhJzogb25DREFUQSA9IGNiOyBicmVhaztcbiAgICBjYXNlICdhdHRlbnRpb24nOiBvbkF0dGVudGlvbiA9IGNiOyBicmVhazsgLy8gPCFYWFhYWCB6enp6PVwiZWVlZVwiPlxuICAgIGNhc2UgJ3F1ZXN0aW9uJzogb25RdWVzdGlvbiA9IGNiOyBicmVhazsgLy8gPD8gLi4uLiAgPz5cbiAgICBjYXNlICdjb21tZW50Jzogb25Db21tZW50ID0gY2I7IGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBlcnJvcigndW5zdXBwb3J0ZWQgZXZlbnQ6ICcgKyBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBuYW1lc3BhY2UgdG8gcHJlZml4IG1hcHBpbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHBhcnNlci5ucyh7XG4gICAqICAgJ2h0dHA6Ly9mb28nOiAnZm9vJyxcbiAgICogICAnaHR0cDovL2Jhcic6ICdiYXInXG4gICAqIH0pO1xuICAgKlxuICAgKiBAcGFyYW0gIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gbnNNYXBcbiAgICpcbiAgICogQHJldHVybiB7UGFyc2VyfVxuICAgKi9cbiAgdGhpc1snbnMnXSA9IGZ1bmN0aW9uKG5zTWFwKSB7XG5cbiAgICBpZiAodHlwZW9mIG5zTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbnNNYXAgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5zTWFwICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgZXJyb3IoJ3JlcXVpcmVkIGFyZ3MgPG5zTWFwPXt9PicpO1xuICAgIH1cblxuICAgIHZhciBfbnNVcmlUb1ByZWZpeCA9IHt9LCBrO1xuXG4gICAgZm9yIChrIGluIG5zTWFwKSB7XG4gICAgICBfbnNVcmlUb1ByZWZpeFtrXSA9IG5zTWFwW2tdO1xuICAgIH1cblxuICAgIC8vIEZPUkNFIGRlZmF1bHQgbWFwcGluZyBmb3Igc2NoZW1hIGluc3RhbmNlXG4gICAgX25zVXJpVG9QcmVmaXhbWFNJX1VSSV0gPSBYU0lfUFJFRklYO1xuXG4gICAgaXNOYW1lc3BhY2UgPSB0cnVlO1xuICAgIG5zVXJpVG9QcmVmaXggPSBfbnNVcmlUb1ByZWZpeDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSB4bWwgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHhtbFxuICAgKlxuICAgKiBAcmV0dXJuIHtFcnJvcn0gcmV0dXJuRXJyb3IsIGlmIG5vdCB0aHJvd25cbiAgICovXG4gIHRoaXNbJ3BhcnNlJ10gPSBmdW5jdGlvbih4bWwpIHtcbiAgICBpZiAodHlwZW9mIHhtbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IGVycm9yKCdyZXF1aXJlZCBhcmdzIDx4bWw9c3RyaW5nPicpO1xuICAgIH1cblxuICAgIHJldHVybkVycm9yID0gbnVsbDtcblxuICAgIHBhcnNlKHhtbCk7XG5cbiAgICBnZXRDb250ZXh0ID0gbm9vcEdldENvbnRleHQ7XG4gICAgcGFyc2VTdG9wID0gZmFsc2U7XG5cbiAgICByZXR1cm4gcmV0dXJuRXJyb3I7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgcGFyc2luZy5cbiAgICovXG4gIHRoaXNbJ3N0b3AnXSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhcnNlU3RvcCA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHN0cmluZywgaW52b2tpbmcgY29uZmlndXJlZCBsaXN0ZW5lcnMgb24gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB4bWxcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlKHhtbCkge1xuICAgIHZhciBuc01hdHJpeFN0YWNrID0gaXNOYW1lc3BhY2UgPyBbXSA6IG51bGwsXG4gICAgICAgIG5zTWF0cml4ID0gaXNOYW1lc3BhY2UgPyBidWlsZE5zTWF0cml4KG5zVXJpVG9QcmVmaXgpIDogbnVsbCxcbiAgICAgICAgX25zTWF0cml4LFxuICAgICAgICBub2RlU3RhY2sgPSBbXSxcbiAgICAgICAgYW5vbnltb3VzTnNDb3VudCA9IDAsXG4gICAgICAgIHRhZ1N0YXJ0ID0gZmFsc2UsXG4gICAgICAgIHRhZ0VuZCA9IGZhbHNlLFxuICAgICAgICBpID0gMCwgaiA9IDAsXG4gICAgICAgIHgsIHksIHEsIHcsIHYsXG4gICAgICAgIHhtbG5zLFxuICAgICAgICBlbGVtZW50TmFtZSxcbiAgICAgICAgX2VsZW1lbnROYW1lLFxuICAgICAgICBlbGVtZW50UHJveHlcbiAgICAgICAgO1xuXG4gICAgdmFyIGF0dHJzU3RyaW5nID0gJycsXG4gICAgICAgIGF0dHJzU3RhcnQgPSAwLFxuICAgICAgICBjYWNoZWRBdHRycyAvLyBmYWxzZSA9IHBhcnNlZCB3aXRoIGVycm9ycywgbnVsbCA9IG5lZWRzIHBhcnNpbmdcbiAgICAgICAgO1xuXG4gICAgLyoqXG4gICAgICogUGFyc2UgYXR0cmlidXRlcyBvbiBkZW1hbmQgYW5kIHJldHVybnMgdGhlIHBhcnNlZCBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogUmV0dXJuIHNlbWFudGljczogKDEpIGBmYWxzZWAgb24gYXR0cmlidXRlIHBhcnNlIGVycm9yLFxuICAgICAqICgyKSBvYmplY3QgaGFzaCBvbiBleHRyYWN0ZWQgYXR0cnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufE9iamVjdH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBdHRycygpIHtcbiAgICAgIGlmIChjYWNoZWRBdHRycyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkQXR0cnM7XG4gICAgICB9XG5cbiAgICAgIHZhciBuc1VyaSxcbiAgICAgICAgICBuc1VyaVByZWZpeCxcbiAgICAgICAgICBuc05hbWUsXG4gICAgICAgICAgZGVmYXVsdEFsaWFzID0gaXNOYW1lc3BhY2UgJiYgbnNNYXRyaXhbJ3htbG5zJ10sXG4gICAgICAgICAgYXR0ckxpc3QgPSBpc05hbWVzcGFjZSAmJiBtYXliZU5TID8gW10gOiBudWxsLFxuICAgICAgICAgIGkgPSBhdHRyc1N0YXJ0LFxuICAgICAgICAgIHMgPSBhdHRyc1N0cmluZyxcbiAgICAgICAgICBsID0gcy5sZW5ndGgsXG4gICAgICAgICAgaGFzTmV3TWF0cml4LFxuICAgICAgICAgIG5ld2FsaWFzLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGFsaWFzLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXR0cnMgPSB7fSxcbiAgICAgICAgICBzZWVuQXR0cnMgPSB7fSxcbiAgICAgICAgICBza2lwQXR0cixcbiAgICAgICAgICB3LFxuICAgICAgICAgIGo7XG5cbiAgICAgIHBhcnNlQXR0cjpcbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHNraXBBdHRyID0gZmFsc2U7XG4gICAgICAgIHcgPSBzLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKHcgPT09IDMyIHx8ICh3IDwgMTQgJiYgdyA+IDgpKSB7IC8vIFdISVRFU1BBQ0U9eyBcXGZcXG5cXHJcXHRcXHZ9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3YWl0IGZvciBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKHcgPCA2NSB8fCB3ID4gMTIyIHx8ICh3ID4gOTAgJiYgdyA8IDk3KSkge1xuICAgICAgICAgIGlmICh3ICE9PSA5NSAmJiB3ICE9PSA1OCkgeyAvLyBjaGFyIDk1XCJfXCIgNThcIjpcIlxuICAgICAgICAgICAgaGFuZGxlV2FybmluZygnaWxsZWdhbCBmaXJzdCBjaGFyIGF0dHJpYnV0ZSBuYW1lJyk7XG4gICAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2UgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICB3ID0gcy5jaGFyQ29kZUF0KGopO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdyA+IDk2ICYmIHcgPCAxMjMgfHxcbiAgICAgICAgICAgIHcgPiA2NCAmJiB3IDwgOTEgfHxcbiAgICAgICAgICAgIHcgPiA0NyAmJiB3IDwgNTkgfHxcbiAgICAgICAgICAgIHcgPT09IDQ2IHx8IC8vICcuJ1xuICAgICAgICAgICAgdyA9PT0gNDUgfHwgLy8gJy0nXG4gICAgICAgICAgICB3ID09PSA5NSAvLyAnXydcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgd2hpdGVzcGFjZVxuICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBXSElURVNQQUNFXG4gICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdtaXNzaW5nIGF0dHJpYnV0ZSB2YWx1ZScpO1xuICAgICAgICAgICAgaSA9IGo7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlIHBhcnNlQXR0cjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBleHBlY3RlZCBcIj1cIlxuICAgICAgICAgIGlmICh3ID09PSA2MSkgeyAvLyBcIj1cIiA9PSA2MVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFuZGxlV2FybmluZygnaWxsZWdhbCBhdHRyaWJ1dGUgbmFtZSBjaGFyJyk7XG4gICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IHMuc3Vic3RyaW5nKGksIGopO1xuXG4gICAgICAgIGlmIChuYW1lID09PSAneG1sbnM6eG1sbnMnKSB7XG4gICAgICAgICAgaGFuZGxlV2FybmluZygnaWxsZWdhbCBkZWNsYXJhdGlvbiBvZiB4bWxucycpO1xuICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcgPSBzLmNoYXJDb2RlQXQoaiArIDEpO1xuXG4gICAgICAgIGlmICh3ID09PSAzNCkgeyAvLyAnXCInXG4gICAgICAgICAgaiA9IHMuaW5kZXhPZignXCInLCBpID0gaiArIDIpO1xuXG4gICAgICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgICAgICBqID0gcy5pbmRleE9mKCdcXCcnLCBpKTtcblxuICAgICAgICAgICAgaWYgKGogIT09IC0xKSB7XG4gICAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2F0dHJpYnV0ZSB2YWx1ZSBxdW90ZSBtaXNzbWF0Y2gnKTtcbiAgICAgICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHcgPT09IDM5KSB7IC8vIFwiJ1wiXG4gICAgICAgICAgaiA9IHMuaW5kZXhPZignXFwnJywgaSA9IGogKyAyKTtcblxuICAgICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgICAgaiA9IHMuaW5kZXhPZignXCInLCBpKTtcblxuICAgICAgICAgICAgaWYgKGogIT09IC0xKSB7XG4gICAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2F0dHJpYnV0ZSB2YWx1ZSBxdW90ZSBtaXNzbWF0Y2gnKTtcbiAgICAgICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ21pc3NpbmcgYXR0cmlidXRlIHZhbHVlIHF1b3RlcycpO1xuICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIHNraXAgdG8gbmV4dCBzcGFjZVxuICAgICAgICAgIGZvciAoaiA9IGogKyAxOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICB3ID0gcy5jaGFyQ29kZUF0KGogKyAxKTtcblxuICAgICAgICAgICAgaWYgKHcgPT09IDMyIHx8ICh3IDwgMTQgJiYgdyA+IDgpKSB7IC8vIFdISVRFU1BBQ0VcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdtaXNzaW5nIGNsb3NpbmcgcXVvdGVzJyk7XG5cbiAgICAgICAgICBqID0gbDtcbiAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNraXBBdHRyKSB7XG4gICAgICAgICAgdmFsdWUgPSBzLnN1YnN0cmluZyhpLCBqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgPSBqO1xuXG4gICAgICAgIC8vIGVuc3VyZSBTUEFDRSBmb2xsb3dzIGF0dHJpYnV0ZVxuICAgICAgICAvLyBza2lwIGlsbGVnYWwgY29udGVudCBvdGhlcndpc2VcbiAgICAgICAgLy8gZXhhbXBsZSBhPVwiYlwiY1xuICAgICAgICBmb3IgKDsgaiArIDEgPCBsOyBqKyspIHtcbiAgICAgICAgICB3ID0gcy5jaGFyQ29kZUF0KGogKyAxKTtcblxuICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBXSElURVNQQUNFXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGSVJTVCBJTExFR0FMIENIQVJcbiAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgaGFuZGxlV2FybmluZygnaWxsZWdhbCBjaGFyYWN0ZXIgYWZ0ZXIgYXR0cmlidXRlIGVuZCcpO1xuICAgICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkdmFuY2UgY3Vyc29yIHRvIG5leHQgYXR0cmlidXRlXG4gICAgICAgIGkgPSBqICsgMTtcblxuICAgICAgICBpZiAoc2tpcEF0dHIpIHtcbiAgICAgICAgICBjb250aW51ZSBwYXJzZUF0dHI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBhdHRyaWJ1dGUgcmUtZGVjbGFyYXRpb25cbiAgICAgICAgaWYgKG5hbWUgaW4gc2VlbkF0dHJzKSB7XG4gICAgICAgICAgaGFuZGxlV2FybmluZygnYXR0cmlidXRlIDwnICsgbmFtZSArICc+IGFscmVhZHkgZGVmaW5lZCcpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VlbkF0dHJzW25hbWVdID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWlzTmFtZXNwYWNlKSB7XG4gICAgICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byBleHRyYWN0IG5hbWVzcGFjZSBpbmZvcm1hdGlvblxuICAgICAgICBpZiAobWF5YmVOUykge1xuICAgICAgICAgIG5ld2FsaWFzID0gKFxuICAgICAgICAgICAgbmFtZSA9PT0gJ3htbG5zJ1xuICAgICAgICAgICAgICA/ICd4bWxucydcbiAgICAgICAgICAgICAgOiAobmFtZS5jaGFyQ29kZUF0KDApID09PSAxMjAgJiYgbmFtZS5zdWJzdHIoMCwgNikgPT09ICd4bWxuczonKVxuICAgICAgICAgICAgICAgID8gbmFtZS5zdWJzdHIoNilcbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gaGFuZGxlIHhtbG5zKDphbGlhcykgYXNzaWdubWVudFxuICAgICAgICAgIGlmIChuZXdhbGlhcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbnNVcmkgPSBkZWNvZGVFbnRpdGllcyh2YWx1ZSk7XG4gICAgICAgICAgICBuc1VyaVByZWZpeCA9IHVyaVByZWZpeChuZXdhbGlhcyk7XG5cbiAgICAgICAgICAgIGFsaWFzID0gbnNVcmlUb1ByZWZpeFtuc1VyaV07XG5cbiAgICAgICAgICAgIGlmICghYWxpYXMpIHtcblxuICAgICAgICAgICAgICAvLyBubyBwcmVmaXggZGVmaW5lZCBvciBwcmVmaXggY29sbGlzaW9uXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAobmV3YWxpYXMgPT09ICd4bWxucycpIHx8XG4gICAgICAgICAgICAgICAgKG5zVXJpUHJlZml4IGluIG5zTWF0cml4ICYmIG5zTWF0cml4W25zVXJpUHJlZml4XSAhPT0gbnNVcmkpXG4gICAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgLy8gYWxvY2F0ZSBmcmVlIG5zIHByZWZpeFxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIGFsaWFzID0gJ25zJyArIChhbm9ueW1vdXNOc0NvdW50KyspO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHR5cGVvZiBuc01hdHJpeFthbGlhc10gIT09ICd1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbGlhcyA9IG5ld2FsaWFzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbnNVcmlUb1ByZWZpeFtuc1VyaV0gPSBhbGlhcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5zTWF0cml4W25ld2FsaWFzXSAhPT0gYWxpYXMpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNOZXdNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBuc01hdHJpeCA9IGNsb25lTnNNYXRyaXgobnNNYXRyaXgpO1xuICAgICAgICAgICAgICAgIGhhc05ld01hdHJpeCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuc01hdHJpeFtuZXdhbGlhc10gPSBhbGlhcztcbiAgICAgICAgICAgICAgaWYgKG5ld2FsaWFzID09PSAneG1sbnMnKSB7XG4gICAgICAgICAgICAgICAgbnNNYXRyaXhbdXJpUHJlZml4KGFsaWFzKV0gPSBuc1VyaTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWxpYXMgPSBhbGlhcztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5zTWF0cml4W25zVXJpUHJlZml4XSA9IG5zVXJpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBleHBvc2UgeG1sbnMoOmFzZCk9XCIuLi5cIiBpbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY29sbGVjdCBhdHRyaWJ1dGVzIHVudGlsIGFsbCBuYW1lc3BhY2VcbiAgICAgICAgICAvLyBkZWNsYXJhdGlvbnMgYXJlIHByb2Nlc3NlZFxuICAgICAgICAgIGF0dHJMaXN0LnB1c2gobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIH0gLyoqIGVuZCBpZiAobWF5YmVOcykgKi9cblxuICAgICAgICAvLyBoYW5kbGUgYXR0cmlidXRlcyBvbiBlbGVtZW50IHdpdGhvdXRcbiAgICAgICAgLy8gbmFtZXNwYWNlIGRlY2xhcmF0aW9uc1xuICAgICAgICB3ID0gbmFtZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGlmICh3ID09PSAtMSkge1xuICAgICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgaWYgKCEobnNOYW1lID0gbnNNYXRyaXhbbmFtZS5zdWJzdHJpbmcoMCwgdyldKSkge1xuICAgICAgICAgIGhhbmRsZVdhcm5pbmcobWlzc2luZ05hbWVzcGFjZUZvclByZWZpeChuYW1lLnN1YnN0cmluZygwLCB3KSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IGRlZmF1bHRBbGlhcyA9PT0gbnNOYW1lXG4gICAgICAgICAgPyBuYW1lLnN1YnN0cih3ICsgMSlcbiAgICAgICAgICA6IG5zTmFtZSArIG5hbWUuc3Vic3RyKHcpO1xuXG4gICAgICAgIC8vIGVuZDogbm9ybWFsaXplIG5zIGF0dHJpYnV0ZSBuYW1lXG5cbiAgICAgICAgLy8gbm9ybWFsaXplIHhzaTp0eXBlIG5zIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICBpZiAobmFtZSA9PT0gWFNJX1RZUEUpIHtcbiAgICAgICAgICB3ID0gdmFsdWUuaW5kZXhPZignOicpO1xuXG4gICAgICAgICAgaWYgKHcgIT09IC0xKSB7XG4gICAgICAgICAgICBuc05hbWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdyk7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBkZWZhdWx0IHByZWZpeGVzLCBpLmUuIHhzOlN0cmluZyBncmFjZWZ1bGx5XG4gICAgICAgICAgICBuc05hbWUgPSBuc01hdHJpeFtuc05hbWVdIHx8IG5zTmFtZTtcbiAgICAgICAgICAgIHZhbHVlID0gbnNOYW1lICsgdmFsdWUuc3Vic3RyaW5nKHcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRBbGlhcyArICc6JyArIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuZDogbm9ybWFsaXplIHhzaTp0eXBlIG5zIGF0dHJpYnV0ZSB2YWx1ZVxuXG4gICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cblxuICAgICAgLy8gaGFuZGxlIGRlZmVycmVkLCBwb3NzaWJseSBuYW1lc3BhY2VkIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChtYXliZU5TKSB7XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIGNhcHR1cmVkIGF0dHJpYnV0ZXNcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGF0dHJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgICAgbmFtZSA9IGF0dHJMaXN0W2krK107XG4gICAgICAgICAgdmFsdWUgPSBhdHRyTGlzdFtpXTtcblxuICAgICAgICAgIHcgPSBuYW1lLmluZGV4T2YoJzonKTtcblxuICAgICAgICAgIGlmICh3ICE9PSAtMSkge1xuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgIGlmICghKG5zTmFtZSA9IG5zTWF0cml4W25hbWUuc3Vic3RyaW5nKDAsIHcpXSkpIHtcbiAgICAgICAgICAgICAgaGFuZGxlV2FybmluZyhtaXNzaW5nTmFtZXNwYWNlRm9yUHJlZml4KG5hbWUuc3Vic3RyaW5nKDAsIHcpKSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuYW1lID0gZGVmYXVsdEFsaWFzID09PSBuc05hbWVcbiAgICAgICAgICAgICAgPyBuYW1lLnN1YnN0cih3ICsgMSlcbiAgICAgICAgICAgICAgOiBuc05hbWUgKyBuYW1lLnN1YnN0cih3KTtcblxuICAgICAgICAgICAgLy8gZW5kOiBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcblxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIHhzaTp0eXBlIG5zIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFhTSV9UWVBFKSB7XG4gICAgICAgICAgICAgIHcgPSB2YWx1ZS5pbmRleE9mKCc6Jyk7XG5cbiAgICAgICAgICAgICAgaWYgKHcgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbnNOYW1lID0gdmFsdWUuc3Vic3RyaW5nKDAsIHcpO1xuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGRlZmF1bHQgcHJlZml4ZXMsIGkuZS4geHM6U3RyaW5nIGdyYWNlZnVsbHlcbiAgICAgICAgICAgICAgICBuc05hbWUgPSBuc01hdHJpeFtuc05hbWVdIHx8IG5zTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5zTmFtZSArIHZhbHVlLnN1YnN0cmluZyh3KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRBbGlhcyArICc6JyArIHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVuZDogbm9ybWFsaXplIHhzaTp0eXBlIG5zIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbmQ6IG5vcm1hbGl6ZSBjYXB0dXJlZCBhdHRyaWJ1dGVzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZWRBdHRycyA9IGF0dHJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgdGhlIHBhcnNlIGNvbnRleHQgeyBsaW5lLCBjb2x1bW4sIHBhcnQgfVxuICAgICAqIGZyb20gdGhlIGN1cnJlbnQgcGFyc2VyIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwYXJzZSBjb250ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VDb250ZXh0KCkge1xuICAgICAgdmFyIHNwbGl0c1JlID0gLyhcXHJcXG58XFxyfFxcbikvZztcblxuICAgICAgdmFyIGxpbmUgPSAwO1xuICAgICAgdmFyIGNvbHVtbiA9IDA7XG4gICAgICB2YXIgc3RhcnRPZkxpbmUgPSAwO1xuICAgICAgdmFyIGVuZE9mTGluZSA9IGo7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB2YXIgZGF0YTtcblxuICAgICAgd2hpbGUgKGkgPj0gc3RhcnRPZkxpbmUpIHtcblxuICAgICAgICBtYXRjaCA9IHNwbGl0c1JlLmV4ZWMoeG1sKTtcblxuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbmQgb2YgbGluZSA9IChicmVhayBpZHggKyBicmVhayBjaGFycylcbiAgICAgICAgZW5kT2ZMaW5lID0gbWF0Y2hbMF0ubGVuZ3RoICsgbWF0Y2guaW5kZXg7XG5cbiAgICAgICAgaWYgKGVuZE9mTGluZSA+IGkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkdmFuY2UgdG8gbmV4dCBsaW5lXG4gICAgICAgIGxpbmUgKz0gMTtcblxuICAgICAgICBzdGFydE9mTGluZSA9IGVuZE9mTGluZTtcbiAgICAgIH1cblxuICAgICAgLy8gRU9GIGVycm9yc1xuICAgICAgaWYgKGkgPT0gLTEpIHtcbiAgICAgICAgY29sdW1uID0gZW5kT2ZMaW5lO1xuICAgICAgICBkYXRhID0geG1sLnN1YnN0cmluZyhqKTtcbiAgICAgIH0gZWxzZVxuXG4gICAgICAvLyBzdGFydCBlcnJvcnNcbiAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgIGRhdGEgPSB4bWwuc3Vic3RyaW5nKGosIGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdGhlciBlcnJvcnNcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb2x1bW4gPSBpIC0gc3RhcnRPZkxpbmU7XG4gICAgICAgIGRhdGEgPSAoaiA9PSAtMSA/IHhtbC5zdWJzdHJpbmcoaSkgOiB4bWwuc3Vic3RyaW5nKGksIGogKyAxKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICdkYXRhJzogZGF0YSxcbiAgICAgICAgJ2xpbmUnOiBsaW5lLFxuICAgICAgICAnY29sdW1uJzogY29sdW1uXG4gICAgICB9O1xuICAgIH1cblxuICAgIGdldENvbnRleHQgPSBnZXRQYXJzZUNvbnRleHQ7XG5cblxuICAgIGlmIChwcm94eSkge1xuICAgICAgZWxlbWVudFByb3h5ID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAnbmFtZSc6IGdldHRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudE5hbWU7XG4gICAgICAgIH0pLFxuICAgICAgICAnb3JpZ2luYWxOYW1lJzogZ2V0dGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfZWxlbWVudE5hbWU7XG4gICAgICAgIH0pLFxuICAgICAgICAnYXR0cnMnOiBnZXR0ZXIoZ2V0QXR0cnMpLFxuICAgICAgICAnbnMnOiBnZXR0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5zTWF0cml4O1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYWN0dWFsIHBhcnNlIGxvZ2ljXG4gICAgd2hpbGUgKGogIT09IC0xKSB7XG5cbiAgICAgIGlmICh4bWwuY2hhckNvZGVBdChqKSA9PT0gNjApIHsgLy8gXCI8XCJcbiAgICAgICAgaSA9IGo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpID0geG1sLmluZGV4T2YoJzwnLCBqKTtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgZW5kXG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKG5vZGVTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdtaXNzaW5nIHN0YXJ0IHRhZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPCB4bWwubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHhtbC5zdWJzdHJpbmcoaikudHJpbSgpKSB7XG4gICAgICAgICAgICBoYW5kbGVXYXJuaW5nKE5PTl9XSElURVNQQUNFX09VVFNJREVfUk9PVF9OT0RFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIHRleHRcbiAgICAgIGlmIChqICE9PSBpKSB7XG5cbiAgICAgICAgaWYgKG5vZGVTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAob25UZXh0KSB7XG4gICAgICAgICAgICBvblRleHQoeG1sLnN1YnN0cmluZyhqLCBpKSwgZGVjb2RlRW50aXRpZXMsIGdldENvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHhtbC5zdWJzdHJpbmcoaiwgaSkudHJpbSgpKSB7XG4gICAgICAgICAgICBoYW5kbGVXYXJuaW5nKE5PTl9XSElURVNQQUNFX09VVFNJREVfUk9PVF9OT0RFKTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHcgPSB4bWwuY2hhckNvZGVBdChpKzEpO1xuXG4gICAgICAvLyBwYXJzZSBjb21tZW50cyArIENEQVRBXG4gICAgICBpZiAodyA9PT0gMzMpIHsgLy8gXCIhXCJcbiAgICAgICAgcSA9IHhtbC5jaGFyQ29kZUF0KGkrMik7XG5cbiAgICAgICAgLy8gQ0RBVEEgc2VjdGlvblxuICAgICAgICBpZiAocSA9PT0gOTEgJiYgeG1sLnN1YnN0cihpICsgMywgNikgPT09ICdDREFUQVsnKSB7IC8vIDkxID09IFwiW1wiXG4gICAgICAgICAgaiA9IHhtbC5pbmRleE9mKCddXT4nLCBpKTtcbiAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgY2RhdGEnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob25DREFUQSkge1xuICAgICAgICAgICAgb25DREFUQSh4bWwuc3Vic3RyaW5nKGkgKyA5LCBqKSwgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21tZW50XG4gICAgICAgIGlmIChxID09PSA0NSAmJiB4bWwuY2hhckNvZGVBdChpICsgMykgPT09IDQ1KSB7IC8vIDQ1ID09IFwiLVwiXG4gICAgICAgICAgaiA9IHhtbC5pbmRleE9mKCctLT4nLCBpKTtcbiAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgY29tbWVudCcpO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgaWYgKG9uQ29tbWVudCkge1xuICAgICAgICAgICAgb25Db21tZW50KHhtbC5zdWJzdHJpbmcoaSArIDQsIGopLCBkZWNvZGVFbnRpdGllcywgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgcXVlc3Rpb24gPD8gLi4uID8+XG4gICAgICBpZiAodyA9PT0gNjMpIHsgLy8gXCI/XCJcbiAgICAgICAgaiA9IHhtbC5pbmRleE9mKCc/PicsIGkpO1xuICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ3VuY2xvc2VkIHF1ZXN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob25RdWVzdGlvbikge1xuICAgICAgICAgIG9uUXVlc3Rpb24oeG1sLnN1YnN0cmluZyhpLCBqICsgMiksIGdldENvbnRleHQpO1xuICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBqICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBmaW5kIG1hdGNoaW5nIGNsb3NpbmcgdGFnIGZvciBhdHRlbnRpb24gb3Igc3RhbmRhcmQgdGFnc1xuICAgICAgLy8gZm9yIHRoYXQgd2UgbXVzdCBza2lwIHRocm91Z2ggYXR0cmlidXRlIHZhbHVlc1xuICAgICAgLy8gKGVuY2xvc2VkIGluIHNpbmdsZSBvciBkb3VibGUgcXVvdGVzKVxuICAgICAgZm9yICh4ID0gaSArIDE7IDsgeCsrKSB7XG4gICAgICAgIHYgPSB4bWwuY2hhckNvZGVBdCh4KTtcbiAgICAgICAgaWYgKGlzTmFOKHYpKSB7XG4gICAgICAgICAgaiA9IC0xO1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgdGFnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBbMTBdIEF0dFZhbHVlIDo6PSAnXCInIChbXjwmXCJdIHwgUmVmZXJlbmNlKSogJ1wiJyB8IFwiJ1wiIChbXjwmJ10gfCBSZWZlcmVuY2UpKiBcIidcIlxuICAgICAgICAvLyBza2lwcyB0aGUgcXVvdGVkIHN0cmluZ1xuICAgICAgICAvLyAoZG91YmxlIHF1b3RlcykgZG9lcyBub3QgYXBwZWFyIGluIGEgbGl0ZXJhbCBlbmNsb3NlZCBieSAoZG91YmxlIHF1b3RlcylcbiAgICAgICAgLy8gKHNpbmdsZSBxdW90ZSkgZG9lcyBub3QgYXBwZWFyIGluIGEgbGl0ZXJhbCBlbmNsb3NlZCBieSAoc2luZ2xlIHF1b3RlKVxuICAgICAgICBpZiAodiA9PT0gMzQpIHsgLy8gICdcIidcbiAgICAgICAgICBxID0geG1sLmluZGV4T2YoJ1wiJywgeCArIDEpO1xuICAgICAgICAgIHggPSBxICE9PSAtMSA/IHEgOiB4O1xuICAgICAgICB9IGVsc2UgaWYgKHYgPT09IDM5KSB7IC8vIFwiJ1wiXG4gICAgICAgICAgcSA9IHhtbC5pbmRleE9mKFwiJ1wiLCB4ICsgMSk7XG4gICAgICAgICAgeCA9IHEgIT09IC0xID8gcSA6IHg7XG4gICAgICAgIH0gZWxzZSBpZiAodiA9PT0gNjIpIHsgLy8gJz4nXG4gICAgICAgICAgaiA9IHg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICAvLyBwYXJzZSBhdHRlbnRpb24gPCEgLi4uPlxuICAgICAgLy8gcHJldmlvdXNseSBjb21tZW50IGFuZCBDREFUQSBoYXZlIGFscmVhZHkgYmVlbiBwYXJzZWRcbiAgICAgIGlmICh3ID09PSAzMykgeyAvLyBcIiFcIlxuXG4gICAgICAgIGlmIChvbkF0dGVudGlvbikge1xuICAgICAgICAgIG9uQXR0ZW50aW9uKHhtbC5zdWJzdHJpbmcoaSwgaiArIDEpLCBkZWNvZGVFbnRpdGllcywgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGogKz0gMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbid0IHByb2Nlc3MgYXR0cmlidXRlcztcbiAgICAgIC8vIHRoZXJlIGFyZSBub25lXG4gICAgICBjYWNoZWRBdHRycyA9IHt9O1xuXG4gICAgICAvLyBpZiAoeG1sLmNoYXJDb2RlQXQoaSsxKSA9PT0gNDcpIHsgLy8gPC8uLi5cbiAgICAgIGlmICh3ID09PSA0NykgeyAvLyA8Ly4uLlxuICAgICAgICB0YWdTdGFydCA9IGZhbHNlO1xuICAgICAgICB0YWdFbmQgPSB0cnVlO1xuXG4gICAgICAgIGlmICghbm9kZVN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignbWlzc2luZyBvcGVuIHRhZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmVyaWZ5IG9wZW4gPC0+IGNsb3NlIHRhZyBtYXRjaFxuICAgICAgICB4ID0gZWxlbWVudE5hbWUgPSBub2RlU3RhY2sucG9wKCk7XG4gICAgICAgIHEgPSBpICsgMiArIHgubGVuZ3RoO1xuXG4gICAgICAgIGlmICh4bWwuc3Vic3RyaW5nKGkgKyAyLCBxKSAhPT0geCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignY2xvc2luZyB0YWcgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcmlmeSBjaGFycyBpbiBjbG9zZSB0YWdcbiAgICAgICAgZm9yICg7IHEgPCBqOyBxKyspIHtcbiAgICAgICAgICB3ID0geG1sLmNoYXJDb2RlQXQocSk7XG5cbiAgICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPiA4ICYmIHcgPCAxNCkpIHsgLy8gXFxmXFxuXFxyXFx0XFx2IHNwYWNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ2Nsb3NlIHRhZycpO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh4bWwuY2hhckNvZGVBdChqIC0gMSkgPT09IDQ3KSB7IC8vIC4uLi8+XG4gICAgICAgICAgeCA9IGVsZW1lbnROYW1lID0geG1sLnN1YnN0cmluZyhpICsgMSwgaiAtIDEpO1xuXG4gICAgICAgICAgdGFnU3RhcnQgPSB0cnVlO1xuICAgICAgICAgIHRhZ0VuZCA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ID0gZWxlbWVudE5hbWUgPSB4bWwuc3Vic3RyaW5nKGkgKyAxLCBqKTtcblxuICAgICAgICAgIHRhZ1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICB0YWdFbmQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHcgPiA5NiAmJiB3IDwgMTIzIHx8IHcgPiA2NCAmJiB3IDwgOTEgfHwgdyA9PT0gOTUgfHwgdyA9PT0gNTgpKSB7IC8vIGNoYXIgOTVcIl9cIiA1OFwiOlwiXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdpbGxlZ2FsIGZpcnN0IGNoYXIgbm9kZU5hbWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocSA9IDEsIHkgPSB4Lmxlbmd0aDsgcSA8IHk7IHErKykge1xuICAgICAgICAgIHcgPSB4LmNoYXJDb2RlQXQocSk7XG5cbiAgICAgICAgICBpZiAodyA+IDk2ICYmIHcgPCAxMjMgfHwgdyA+IDY0ICYmIHcgPCA5MSB8fCB3ID4gNDcgJiYgdyA8IDU5IHx8IHcgPT09IDQ1IHx8IHcgPT09IDk1IHx8IHcgPT0gNDYpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBcXGZcXG5cXHJcXHRcXHYgc3BhY2VcbiAgICAgICAgICAgIGVsZW1lbnROYW1lID0geC5zdWJzdHJpbmcoMCwgcSk7XG5cbiAgICAgICAgICAgIC8vIG1heWJlIHRoZXJlIGFyZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBjYWNoZWRBdHRycyA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ2ludmFsaWQgbm9kZU5hbWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGFnRW5kKSB7XG4gICAgICAgICAgbm9kZVN0YWNrLnB1c2goZWxlbWVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05hbWVzcGFjZSkge1xuXG4gICAgICAgIF9uc01hdHJpeCA9IG5zTWF0cml4O1xuXG4gICAgICAgIGlmICh0YWdTdGFydCkge1xuXG4gICAgICAgICAgLy8gcmVtZW1iZXIgb2xkIG5hbWVzcGFjZVxuICAgICAgICAgIC8vIHVubGVzcyB3ZSdyZSBzZWxmLWNsb3NpbmdcbiAgICAgICAgICBpZiAoIXRhZ0VuZCkge1xuICAgICAgICAgICAgbnNNYXRyaXhTdGFjay5wdXNoKF9uc01hdHJpeCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNhY2hlZEF0dHJzID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgIC8vIHF1aWNrIGNoZWNrLCB3aGV0aGVyIHRoZXJlIG1heSBiZSBuYW1lc3BhY2VcbiAgICAgICAgICAgIC8vIGRlY2xhcmF0aW9ucyBvbiB0aGUgbm9kZTsgaWYgdGhhdCBpcyB0aGUgY2FzZVxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBlYWdlcmx5IHBhcnNlIHRoZSBub2RlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmICgobWF5YmVOUyA9IHguaW5kZXhPZigneG1sbnMnLCBxKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgIGF0dHJzU3RhcnQgPSBxO1xuICAgICAgICAgICAgICBhdHRyc1N0cmluZyA9IHg7XG5cbiAgICAgICAgICAgICAgZ2V0QXR0cnMoKTtcblxuICAgICAgICAgICAgICBtYXliZU5TID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2VsZW1lbnROYW1lID0gZWxlbWVudE5hbWU7XG5cbiAgICAgICAgdyA9IGVsZW1lbnROYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgaWYgKHcgIT09IC0xKSB7XG4gICAgICAgICAgeG1sbnMgPSBuc01hdHJpeFtlbGVtZW50TmFtZS5zdWJzdHJpbmcoMCwgdyldO1xuXG4gICAgICAgICAgLy8gcHJlZml4IGdpdmVuOyBuYW1lc3BhY2UgbXVzdCBleGlzdFxuICAgICAgICAgIGlmICgheG1sbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignbWlzc2luZyBuYW1lc3BhY2Ugb24gPCcgKyBfZWxlbWVudE5hbWUgKyAnPicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnROYW1lID0gZWxlbWVudE5hbWUuc3Vic3RyKHcgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4bWxucyA9IG5zTWF0cml4Wyd4bWxucyddO1xuXG4gICAgICAgICAgLy8gaWYgbm8gZGVmYXVsdCBuYW1lc3BhY2UgaXMgZGVmaW5lZCxcbiAgICAgICAgICAvLyB3ZSdsbCBpbXBvcnQgdGhlIGVsZW1lbnQgYXMgYW5vbnltb3VzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gaXQgaXMgdXAgdG8gdXNlcnMgdG8gY29ycmVjdCB0aGF0IHRvIHRoZSBkb2N1bWVudCBkZWZpbmVkXG4gICAgICAgICAgLy8gdGFyZ2V0TmFtZXNwYWNlLCBvciB3aGF0ZXZlciB0aGVpciB1bmRlcnNhbmRpbmcgb2YgdGhlXG4gICAgICAgICAgLy8gWE1MIHNwZWMgbWFuZGF0ZXMuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgbmFtZXNwYWNlIHByZWZpeHMgYXMgY29uZmlndXJlZFxuICAgICAgICBpZiAoeG1sbnMpIHtcbiAgICAgICAgICBlbGVtZW50TmFtZSA9IHhtbG5zICsgJzonICsgZWxlbWVudE5hbWU7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAodGFnU3RhcnQpIHtcbiAgICAgICAgYXR0cnNTdGFydCA9IHE7XG4gICAgICAgIGF0dHJzU3RyaW5nID0geDtcblxuICAgICAgICBpZiAob25PcGVuVGFnKSB7XG4gICAgICAgICAgaWYgKHByb3h5KSB7XG4gICAgICAgICAgICBvbk9wZW5UYWcoZWxlbWVudFByb3h5LCBkZWNvZGVFbnRpdGllcywgdGFnRW5kLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25PcGVuVGFnKGVsZW1lbnROYW1lLCBnZXRBdHRycywgZGVjb2RlRW50aXRpZXMsIHRhZ0VuZCwgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICh0YWdFbmQpIHtcblxuICAgICAgICBpZiAob25DbG9zZVRhZykge1xuICAgICAgICAgIG9uQ2xvc2VUYWcocHJveHkgPyBlbGVtZW50UHJveHkgOiBlbGVtZW50TmFtZSwgZGVjb2RlRW50aXRpZXMsIHRhZ1N0YXJ0LCBnZXRDb250ZXh0KTtcblxuICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIG9sZCBuYW1lc3BhY2VcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlKSB7XG4gICAgICAgICAgaWYgKCF0YWdTdGFydCkge1xuICAgICAgICAgICAgbnNNYXRyaXggPSBuc01hdHJpeFN0YWNrLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuc01hdHJpeCA9IF9uc01hdHJpeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaiArPSAxO1xuICAgIH1cbiAgfSAvKiogZW5kIHBhcnNlICovXG5cbn1cblxuZXhwb3J0IHsgUGFyc2VyLCBkZWNvZGVFbnRpdGllcyBhcyBkZWNvZGUgfTtcbiIsImZ1bmN0aW9uIGVuc3VyZUltcG9ydGVkKGVsZW1lbnQsIHRhcmdldCkge1xuXG4gIGlmIChlbGVtZW50Lm93bmVyRG9jdW1lbnQgIT09IHRhcmdldC5vd25lckRvY3VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIG1heSBmYWlsIG9uIHdlYmtpdFxuICAgICAgcmV0dXJuIHRhcmdldC5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoZWxlbWVudCwgdHJ1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWdub3JlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogYXBwZW5kVG8gdXRpbGl0eVxuICovXG5cbi8qKlxuICogQXBwZW5kIGEgbm9kZSB0byBhIHRhcmdldCBlbGVtZW50IGFuZCByZXR1cm4gdGhlIGFwcGVuZGVkIG5vZGUuXG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gdGFyZ2V0XG4gKlxuICogQHJldHVybiB7U1ZHRWxlbWVudH0gdGhlIGFwcGVuZGVkIG5vZGVcbiAqL1xuZnVuY3Rpb24gYXBwZW5kVG8oZWxlbWVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQuYXBwZW5kQ2hpbGQoZW5zdXJlSW1wb3J0ZWQoZWxlbWVudCwgdGFyZ2V0KSk7XG59XG5cbi8qKlxuICogYXBwZW5kIHV0aWxpdHlcbiAqL1xuXG4vKipcbiAqIEFwcGVuZCBhIG5vZGUgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IG5vZGVcbiAqXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fSB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gIGFwcGVuZFRvKG5vZGUsIHRhcmdldCk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogYXR0cmlidXRlIGFjY2Vzc29yIHV0aWxpdHlcbiAqL1xuXG52YXIgTEVOR1RIX0FUVFIgPSAyO1xuXG52YXIgQ1NTX1BST1BFUlRJRVMgPSB7XG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAxLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAxLFxuICAnY2xpcCc6IDEsXG4gICdjbGlwLXBhdGgnOiAxLFxuICAnY2xpcC1ydWxlJzogMSxcbiAgJ2NvbG9yJzogMSxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAxLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogMSxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAxLFxuICAnY29sb3ItcmVuZGVyaW5nJzogMSxcbiAgJ2N1cnNvcic6IDEsXG4gICdkaXJlY3Rpb24nOiAxLFxuICAnZGlzcGxheSc6IDEsXG4gICdkb21pbmFudC1iYXNlbGluZSc6IDEsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6IDEsXG4gICdmaWxsJzogMSxcbiAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICdmaWxsLXJ1bGUnOiAxLFxuICAnZmlsdGVyJzogMSxcbiAgJ2Zsb29kLWNvbG9yJzogMSxcbiAgJ2Zsb29kLW9wYWNpdHknOiAxLFxuICAnZm9udCc6IDEsXG4gICdmb250LWZhbWlseSc6IDEsXG4gICdmb250LXNpemUnOiBMRU5HVEhfQVRUUixcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAxLFxuICAnZm9udC1zdHJldGNoJzogMSxcbiAgJ2ZvbnQtc3R5bGUnOiAxLFxuICAnZm9udC12YXJpYW50JzogMSxcbiAgJ2ZvbnQtd2VpZ2h0JzogMSxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAxLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAxLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogMSxcbiAgJ2tlcm5pbmcnOiAxLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAxLFxuICAnbGlnaHRpbmctY29sb3InOiAxLFxuICAnbWFya2VyJzogMSxcbiAgJ21hcmtlci1lbmQnOiAxLFxuICAnbWFya2VyLW1pZCc6IDEsXG4gICdtYXJrZXItc3RhcnQnOiAxLFxuICAnbWFzayc6IDEsXG4gICdvcGFjaXR5JzogMSxcbiAgJ292ZXJmbG93JzogMSxcbiAgJ3BvaW50ZXItZXZlbnRzJzogMSxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6IDEsXG4gICdzdG9wLWNvbG9yJzogMSxcbiAgJ3N0b3Atb3BhY2l0eSc6IDEsXG4gICdzdHJva2UnOiAxLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6IDEsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6IDEsXG4gICdzdHJva2UtbGluZWNhcCc6IDEsXG4gICdzdHJva2UtbGluZWpvaW4nOiAxLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAxLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAxLFxuICAnc3Ryb2tlLXdpZHRoJzogTEVOR1RIX0FUVFIsXG4gICd0ZXh0LWFuY2hvcic6IDEsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAxLFxuICAndGV4dC1yZW5kZXJpbmcnOiAxLFxuICAndW5pY29kZS1iaWRpJzogMSxcbiAgJ3Zpc2liaWxpdHknOiAxLFxuICAnd29yZC1zcGFjaW5nJzogMSxcbiAgJ3dyaXRpbmctbW9kZSc6IDFcbn07XG5cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUpIHtcbiAgaWYgKENTU19QUk9QRVJUSUVTW25hbWVdKSB7XG4gICAgcmV0dXJuIG5vZGUuc3R5bGVbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBoeXBoZW5hdGVkID0gbmFtZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciB0eXBlID0gQ1NTX1BST1BFUlRJRVNbaHlwaGVuYXRlZF07XG5cbiAgaWYgKHR5cGUpIHtcbiAgICAvLyBhcHBlbmQgcGl4ZWwgdW5pdCwgdW5sZXNzIHByZXNlbnRcbiAgICBpZiAodHlwZSA9PT0gTEVOR1RIX0FUVFIgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpICsgJ3B4JztcbiAgICB9XG5cbiAgICBub2RlLnN0eWxlW2h5cGhlbmF0ZWRdID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBuYW1lLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhub2RlLCBhdHRycykge1xuXG4gIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGF0dHJzKSwgaSwgbmFtZTtcblxuICBmb3IgKGkgPSAwLCBuYW1lOyAobmFtZSA9IG5hbWVzW2ldKTsgaSsrKSB7XG4gICAgc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgb3Igc2V0cyByYXcgYXR0cmlidXRlcyBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gbm9kZVxuICogQHBhcmFtICB7T2JqZWN0fSBbYXR0cnNdXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtuYW1lXVxuICogQHBhcmFtICB7U3RyaW5nfSBbdmFsdWVdXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBhdHRyKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldEF0dHJpYnV0ZShub2RlLCBuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2V0QXR0cmlidXRlcyhub2RlLCBuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcclxuICogQ2xlYXIgdXRpbGl0eVxyXG4gKi9cclxuZnVuY3Rpb24gaW5kZXgoYXJyLCBvYmopIHtcclxuICBpZiAoYXJyLmluZGV4T2YpIHtcclxuICAgIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xyXG4gIH1cclxuXHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHtcclxuICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gLTE7XHJcbn1cclxuXHJcbnZhciByZSA9IC9cXHMrLztcclxuXHJcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcblxyXG5mdW5jdGlvbiBkZWZpbmVkKG8pIHtcclxuICByZXR1cm4gdHlwZW9mIG8gIT09ICd1bmRlZmluZWQnO1xyXG59XHJcblxyXG4vKipcclxuICogV3JhcCBgZWxgIGluIGEgYENsYXNzTGlzdGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcclxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNsYXNzZXMoZWwpIHtcclxuICByZXR1cm4gbmV3IENsYXNzTGlzdChlbCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIENsYXNzTGlzdChlbCkge1xyXG4gIGlmICghZWwgfHwgIWVsLm5vZGVUeXBlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgRE9NIGVsZW1lbnQgcmVmZXJlbmNlIGlzIHJlcXVpcmVkJyk7XHJcbiAgfVxyXG4gIHRoaXMuZWwgPSBlbDtcclxuICB0aGlzLmxpc3QgPSBlbC5jbGFzc0xpc3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGQgY2xhc3MgYG5hbWVgIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuXHJcbiAgLy8gY2xhc3NMaXN0XHJcbiAgaWYgKHRoaXMubGlzdCkge1xyXG4gICAgdGhpcy5saXN0LmFkZChuYW1lKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gZmFsbGJhY2tcclxuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xyXG4gIHZhciBpID0gaW5kZXgoYXJyLCBuYW1lKTtcclxuICBpZiAoIX5pKSB7XHJcbiAgICBhcnIucHVzaChuYW1lKTtcclxuICB9XHJcblxyXG4gIGlmIChkZWZpbmVkKHRoaXMuZWwuY2xhc3NOYW1lLmJhc2VWYWwpKSB7XHJcbiAgICB0aGlzLmVsLmNsYXNzTmFtZS5iYXNlVmFsID0gYXJyLmpvaW4oJyAnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5lbC5jbGFzc05hbWUgPSBhcnIuam9pbignICcpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGNsYXNzIGBuYW1lYCB3aGVuIHByZXNlbnQsIG9yXHJcbiAqIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlXHJcbiAqIGFueSB3aGljaCBtYXRjaC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBuYW1lXHJcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICBpZiAoJ1tvYmplY3QgUmVnRXhwXScgPT09IHRvU3RyaW5nLmNhbGwobmFtZSkpIHtcclxuICAgIHJldHVybiB0aGlzLnJlbW92ZU1hdGNoaW5nKG5hbWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gY2xhc3NMaXN0XHJcbiAgaWYgKHRoaXMubGlzdCkge1xyXG4gICAgdGhpcy5saXN0LnJlbW92ZShuYW1lKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gZmFsbGJhY2tcclxuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xyXG4gIHZhciBpID0gaW5kZXgoYXJyLCBuYW1lKTtcclxuICBpZiAofmkpIHtcclxuICAgIGFyci5zcGxpY2UoaSwgMSk7XHJcbiAgfVxyXG4gIHRoaXMuZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBhcnIuam9pbignICcpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhbGwgY2xhc3NlcyBtYXRjaGluZyBgcmVgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcclxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZU1hdGNoaW5nID0gZnVuY3Rpb24ocmUpIHtcclxuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAocmUudGVzdChhcnJbaV0pKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlKGFycltpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRvZ2dsZSBjbGFzcyBgbmFtZWAsIGNhbiBmb3JjZSBzdGF0ZSB2aWEgYGZvcmNlYC5cclxuICpcclxuICogRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBjbGFzc0xpc3QsIGJ1dCBkbyBub3Qgc3VwcG9ydCBgZm9yY2VgIHlldCxcclxuICogdGhlIG1pc3Rha2Ugd2lsbCBiZSBkZXRlY3RlZCBhbmQgY29ycmVjdGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlXHJcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcmNlKSB7XHJcbiAgLy8gY2xhc3NMaXN0XHJcbiAgaWYgKHRoaXMubGlzdCkge1xyXG4gICAgaWYgKGRlZmluZWQoZm9yY2UpKSB7XHJcbiAgICAgIGlmIChmb3JjZSAhPT0gdGhpcy5saXN0LnRvZ2dsZShuYW1lLCBmb3JjZSkpIHtcclxuICAgICAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpOyAvLyB0b2dnbGUgYWdhaW4gdG8gY29ycmVjdFxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBmYWxsYmFja1xyXG4gIGlmIChkZWZpbmVkKGZvcmNlKSkge1xyXG4gICAgaWYgKCFmb3JjZSkge1xyXG4gICAgICB0aGlzLnJlbW92ZShuYW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuYWRkKG5hbWUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcclxuICAgICAgdGhpcy5yZW1vdmUobmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmFkZChuYW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhbiBhcnJheSBvZiBjbGFzc2VzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xyXG4gIHZhciBzdHIgPSBjbGFzc05hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG4gIHZhciBhcnIgPSBzdHIuc3BsaXQocmUpO1xyXG4gIGlmICgnJyA9PT0gYXJyWzBdKSB7XHJcbiAgICBhcnIuc2hpZnQoKTtcclxuICB9XHJcbiAgcmV0dXJuIGFycjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBjbGFzcyBgbmFtZWAgaXMgcHJlc2VudC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUuaGFzID1cclxuQ2xhc3NMaXN0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICByZXR1cm4gKFxyXG4gICAgdGhpcy5saXN0ID9cclxuICAgICAgdGhpcy5saXN0LmNvbnRhaW5zKG5hbWUpIDpcclxuICAgICAgISEgfmluZGV4KHRoaXMuYXJyYXkoKSwgbmFtZSlcclxuICApO1xyXG59O1xuXG5mdW5jdGlvbiByZW1vdmUoZWxlbWVudCkge1xuICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbGVhciB1dGlsaXR5XG4gKi9cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoZSBnaXZlbiBlbGVtZW50XG4gKlxuICogQHBhcmFtICB7RE9NRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhlIGVsZW1lbnQgKGZvciBjaGFpbmluZylcbiAqL1xuZnVuY3Rpb24gY2xlYXIoZWxlbWVudCkge1xuICB2YXIgY2hpbGQ7XG5cbiAgd2hpbGUgKChjaGlsZCA9IGVsZW1lbnQuZmlyc3RDaGlsZCkpIHtcbiAgICByZW1vdmUoY2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xufVxuXG52YXIgbnMgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxuLyoqXG4gKiBET00gcGFyc2luZyB1dGlsaXR5XG4gKi9cblxudmFyIFNWR19TVEFSVCA9ICc8c3ZnIHhtbG5zPVwiJyArIG5zLnN2ZyArICdcIic7XG5cbmZ1bmN0aW9uIHBhcnNlKHN2Zykge1xuXG4gIHZhciB1bndyYXAgPSBmYWxzZTtcblxuICAvLyBlbnN1cmUgd2UgaW1wb3J0IGEgdmFsaWQgc3ZnIGRvY3VtZW50XG4gIGlmIChzdmcuc3Vic3RyaW5nKDAsIDQpID09PSAnPHN2ZycpIHtcbiAgICBpZiAoc3ZnLmluZGV4T2YobnMuc3ZnKSA9PT0gLTEpIHtcbiAgICAgIHN2ZyA9IFNWR19TVEFSVCArIHN2Zy5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG5hbWVzcGFjZSBzdmdcbiAgICBzdmcgPSBTVkdfU1RBUlQgKyAnPicgKyBzdmcgKyAnPC9zdmc+JztcbiAgICB1bndyYXAgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHBhcnNlZCA9IHBhcnNlRG9jdW1lbnQoc3ZnKTtcblxuICBpZiAoIXVud3JhcCkge1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgdmFyIHBhcmVudCA9IHBhcnNlZC5maXJzdENoaWxkO1xuXG4gIHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChzdmcpIHtcblxuICB2YXIgcGFyc2VyO1xuXG4gIC8vIHBhcnNlXG4gIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgcGFyc2VyLmFzeW5jID0gZmFsc2U7XG5cbiAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnLCAndGV4dC94bWwnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdXRpbGl0eSBmb3IgU1ZHIGVsZW1lbnRzXG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZSBhIHNwZWNpZmljIHR5cGUgZnJvbSBuYW1lIG9yIFNWRyBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb3IgbWFya3VwIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW2F0dHJzXSBhdHRyaWJ1dGVzIHRvIHNldCBvbiB0aGUgZWxlbWVudFxuICpcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGUobmFtZSwgYXR0cnMpIHtcbiAgdmFyIGVsZW1lbnQ7XG5cbiAgaWYgKG5hbWUuY2hhckF0KDApID09PSAnPCcpIHtcbiAgICBlbGVtZW50ID0gcGFyc2UobmFtZSkuZmlyc3RDaGlsZDtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuaW1wb3J0Tm9kZShlbGVtZW50LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLnN2ZywgbmFtZSk7XG4gIH1cblxuICBpZiAoYXR0cnMpIHtcbiAgICBhdHRyKGVsZW1lbnQsIGF0dHJzKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIEV2ZW50cyBoYW5kbGluZyB1dGlsaXR5XG4gKi9cblxuZnVuY3Rpb24gb24obm9kZSwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiBvZmYobm9kZSwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xufVxuXG4vKipcbiAqIEdlb21ldHJ5IGhlbHBlcnNcbiAqL1xuXG4vLyBmYWtlIG5vZGUgdXNlZCB0byBpbnN0YW50aWF0ZSBzdmcgZ2VvbWV0cnkgZWxlbWVudHNcbnZhciBub2RlID0gY3JlYXRlKCdzdmcnKTtcblxuZnVuY3Rpb24gZXh0ZW5kKG9iamVjdCwgcHJvcHMpIHtcbiAgdmFyIGksIGssIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG5cbiAgZm9yIChpID0gMDsgKGsgPSBrZXlzW2ldKTsgaSsrKSB7XG4gICAgb2JqZWN0W2tdID0gcHJvcHNba107XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50KHgsIHkpIHtcbiAgdmFyIHBvaW50ID0gbm9kZS5jcmVhdGVTVkdQb2ludCgpO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICBjYXNlIDA6XG4gICAgcmV0dXJuIHBvaW50O1xuICBjYXNlIDI6XG4gICAgeCA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBleHRlbmQocG9pbnQsIHgpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBtYXRyaXggdmlhIGFyZ3MuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBjcmVhdGVNYXRyaXgoeyBhOiAxLCBiOiAxIH0pO1xuICogY3JlYXRlTWF0cml4KCk7XG4gKiBjcmVhdGVNYXRyaXgoMSwgMiwgMCwgMCwgMzAsIDIwKTtcbiAqXG4gKiBAcmV0dXJuIHtTVkdNYXRyaXh9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBtYXRyaXggPSBub2RlLmNyZWF0ZVNWR01hdHJpeCgpO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICBjYXNlIDA6XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgY2FzZSAxOlxuICAgIHJldHVybiBleHRlbmQobWF0cml4LCBhKTtcbiAgY2FzZSA2OlxuICAgIHJldHVybiBleHRlbmQobWF0cml4LCB7XG4gICAgICBhOiBhLFxuICAgICAgYjogYixcbiAgICAgIGM6IGMsXG4gICAgICBkOiBkLFxuICAgICAgZTogZSxcbiAgICAgIGY6IGZcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm0obWF0cml4KSB7XG4gIGlmIChtYXRyaXgpIHtcbiAgICByZXR1cm4gbm9kZS5jcmVhdGVTVkdUcmFuc2Zvcm1Gcm9tTWF0cml4KG1hdHJpeCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUuY3JlYXRlU1ZHVHJhbnNmb3JtKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXJpYWxpemF0aW9uIHV0aWxcbiAqL1xuXG52YXIgVEVYVF9FTlRJVElFUyA9IC8oWyY8Pl17MX0pL2c7XG52YXIgQVRUUl9FTlRJVElFUyA9IC8oW1xcblxcclwiXXsxfSkvZztcblxudmFyIEVOVElUWV9SRVBMQUNFTUVOVCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICdcXCcnXG59O1xuXG5mdW5jdGlvbiBlc2NhcGUoc3RyLCBwYXR0ZXJuKSB7XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBlbnRpdHkpIHtcbiAgICByZXR1cm4gRU5USVRZX1JFUExBQ0VNRU5UW2VudGl0eV0gfHwgZW50aXR5O1xuICB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VGbik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShub2RlLCBvdXRwdXQpIHtcblxuICB2YXIgaSwgbGVuLCBhdHRyTWFwLCBhdHRyTm9kZSwgY2hpbGROb2RlcztcblxuICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgLy8gVEVYVFxuICBjYXNlIDM6XG4gICAgLy8gcmVwbGFjZSBzcGVjaWFsIFhNTCBjaGFyYWN0ZXJzXG4gICAgb3V0cHV0LnB1c2goZXNjYXBlKG5vZGUudGV4dENvbnRlbnQsIFRFWFRfRU5USVRJRVMpKTtcbiAgICBicmVhaztcblxuICAvLyBFTEVNRU5UXG4gIGNhc2UgMTpcbiAgICBvdXRwdXQucHVzaCgnPCcsIG5vZGUudGFnTmFtZSk7XG5cbiAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgIGF0dHJNYXAgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRyTWFwLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGF0dHJOb2RlID0gYXR0ck1hcC5pdGVtKGkpO1xuICAgICAgICBvdXRwdXQucHVzaCgnICcsIGF0dHJOb2RlLm5hbWUsICc9XCInLCBlc2NhcGUoYXR0ck5vZGUudmFsdWUsIEFUVFJfRU5USVRJRVMpLCAnXCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIG91dHB1dC5wdXNoKCc+Jyk7XG4gICAgICBjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBzZXJpYWxpemUoY2hpbGROb2Rlcy5pdGVtKGkpLCBvdXRwdXQpO1xuICAgICAgfVxuICAgICAgb3V0cHV0LnB1c2goJzwvJywgbm9kZS50YWdOYW1lLCAnPicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnLz4nKTtcbiAgICB9XG4gICAgYnJlYWs7XG5cbiAgLy8gQ09NTUVOVFxuICBjYXNlIDg6XG4gICAgb3V0cHV0LnB1c2goJzwhLS0nLCBlc2NhcGUobm9kZS5ub2RlVmFsdWUsIFRFWFRfRU5USVRJRVMpLCAnLS0+Jyk7XG4gICAgYnJlYWs7XG5cbiAgLy8gQ0RBVEFcbiAgY2FzZSA0OlxuICAgIG91dHB1dC5wdXNoKCc8IVtDREFUQVsnLCBub2RlLm5vZGVWYWx1ZSwgJ11dPicpO1xuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gaGFuZGxlIG5vZGUgJyArIG5vZGUubm9kZVR5cGUpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBpbm5lckhUTUwgbGlrZSBmdW5jdGlvbmFsaXR5IGZvciBTVkcgZWxlbWVudHMuXG4gKiBiYXNlZCBvbiBpbm5lclNWRyAoaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9pbm5lcnN2ZylcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChlbGVtZW50LCBzdmcpIHtcblxuICB2YXIgcGFyc2VkID0gcGFyc2Uoc3ZnKTtcblxuICAvLyBjbGVhciBlbGVtZW50IGNvbnRlbnRzXG4gIGNsZWFyKGVsZW1lbnQpO1xuXG4gIGlmICghc3ZnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFpc0ZyYWdtZW50KHBhcnNlZCkpIHtcbiAgICAvLyBleHRyYWN0IDxzdmc+IGZyb20gcGFyc2VkIGRvY3VtZW50XG4gICAgcGFyc2VkID0gcGFyc2VkLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIHZhciBub2RlcyA9IHNsaWNlKHBhcnNlZC5jaGlsZE5vZGVzKTtcblxuICAvLyBpbXBvcnQgKyBhcHBlbmQgZWFjaCBub2RlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBhcHBlbmRUbyhub2Rlc1tpXSwgZWxlbWVudCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZXQoZWxlbWVudCkge1xuICB2YXIgY2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQsXG4gICAgICBvdXRwdXQgPSBbXTtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBzZXJpYWxpemUoY2hpbGQsIG91dHB1dCk7XG4gICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGlzRnJhZ21lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudC1mcmFnbWVudCc7XG59XG5cbmZ1bmN0aW9uIGlubmVyU1ZHKGVsZW1lbnQsIHN2Zykge1xuXG4gIGlmIChzdmcgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldChlbGVtZW50LCBzdmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3IgcGFyc2luZyBTVkc6ICcgKyBlLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXQoZWxlbWVudCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzbGljZShhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG59XG5cbi8qKlxuICogU2VsZWN0aW9uIHV0aWxpdGllc1xuICovXG5cbmZ1bmN0aW9uIHNlbGVjdChub2RlLCBzZWxlY3Rvcikge1xuICByZXR1cm4gbm9kZS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0QWxsKG5vZGUsIHNlbGVjdG9yKSB7XG4gIHZhciBub2RlcyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cbiAgcmV0dXJuIFtdLm1hcC5jYWxsKG5vZGVzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIHByZXBlbmRUbyB1dGlsaXR5XG4gKi9cblxuLyoqXG4gKiBQcmVwZW5kIGEgbm9kZSB0byBhIHRhcmdldCBlbGVtZW50IGFuZCByZXR1cm4gdGhlIHByZXBlbmRlZCBub2RlLlxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IHRhcmdldFxuICpcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHRoZSBwcmVwZW5kZWQgbm9kZVxuICovXG5mdW5jdGlvbiBwcmVwZW5kVG8obm9kZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQuaW5zZXJ0QmVmb3JlKGVuc3VyZUltcG9ydGVkKG5vZGUsIHRhcmdldCksIHRhcmdldC5maXJzdENoaWxkIHx8IG51bGwpO1xufVxuXG4vKipcbiAqIHByZXBlbmQgdXRpbGl0eVxuICovXG5cbi8qKlxuICogUHJlcGVuZCBhIG5vZGUgdG8gYSB0YXJnZXQgZWxlbWVudFxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gbm9kZVxuICpcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHRoZSB0YXJnZXQgZWxlbWVudFxuICovXG5mdW5jdGlvbiBwcmVwZW5kKHRhcmdldCwgbm9kZSkge1xuICBwcmVwZW5kVG8obm9kZSwgdGFyZ2V0KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBSZXBsYWNlIHV0aWxpdHlcbiAqL1xuXG5mdW5jdGlvbiByZXBsYWNlKGVsZW1lbnQsIHJlcGxhY2VtZW50KSB7XG4gIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZW5zdXJlSW1wb3J0ZWQocmVwbGFjZW1lbnQsIGVsZW1lbnQpLCBlbGVtZW50KTtcbiAgcmV0dXJuIHJlcGxhY2VtZW50O1xufVxuXG4vKipcbiAqIHRyYW5zZm9ybSBhY2Nlc3NvciB1dGlsaXR5XG4gKi9cblxuZnVuY3Rpb24gd3JhcE1hdHJpeCh0cmFuc2Zvcm1MaXN0LCB0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIFNWR01hdHJpeCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1MaXN0LmNyZWF0ZVNWR1RyYW5zZm9ybUZyb21NYXRyaXgodHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cblxuZnVuY3Rpb24gc2V0VHJhbnNmb3Jtcyh0cmFuc2Zvcm1MaXN0LCB0cmFuc2Zvcm1zKSB7XG4gIHZhciBpLCB0O1xuXG4gIHRyYW5zZm9ybUxpc3QuY2xlYXIoKTtcblxuICBmb3IgKGkgPSAwOyAodCA9IHRyYW5zZm9ybXNbaV0pOyBpKyspIHtcbiAgICB0cmFuc2Zvcm1MaXN0LmFwcGVuZEl0ZW0od3JhcE1hdHJpeCh0cmFuc2Zvcm1MaXN0LCB0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb3Igc2V0IHRoZSB0cmFuc2Zvcm1zIG9uIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gbm9kZVxuICogQHBhcmFtICB7U1ZHVHJhbnNmb3JtfFNWR01hdHJpeHxBcnJheTxTVkdUcmFuc2Zvcm18U1ZHTWF0cml4Pn0gW3RyYW5zZm9ybXNdXG4gKlxuICogQHJldHVybiB7U1ZHVHJhbnNmb3JtfSB0aGUgY29uc29saWRhdGVkIHRyYW5zZm9ybVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgdHJhbnNmb3Jtcykge1xuICB2YXIgdHJhbnNmb3JtTGlzdCA9IG5vZGUudHJhbnNmb3JtLmJhc2VWYWw7XG5cbiAgaWYgKHRyYW5zZm9ybXMpIHtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1zKSkge1xuICAgICAgdHJhbnNmb3JtcyA9IFsgdHJhbnNmb3JtcyBdO1xuICAgIH1cblxuICAgIHNldFRyYW5zZm9ybXModHJhbnNmb3JtTGlzdCwgdHJhbnNmb3Jtcyk7XG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtTGlzdC5jb25zb2xpZGF0ZSgpO1xufVxuXG5leHBvcnQgeyBhcHBlbmQsIGFwcGVuZFRvLCBhdHRyLCBjbGFzc2VzLCBjbGVhciwgY2xvbmUsIGNyZWF0ZSwgaW5uZXJTVkcsIHByZXBlbmQsIHByZXBlbmRUbywgcmVtb3ZlLCByZXBsYWNlLCB0cmFuc2Zvcm0sIG9uLCBvZmYsIGNyZWF0ZVBvaW50LCBjcmVhdGVNYXRyaXgsIGNyZWF0ZVRyYW5zZm9ybSwgc2VsZWN0LCBzZWxlY3RBbGwgfTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbGliL2luZGV4LmpzXCIpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==
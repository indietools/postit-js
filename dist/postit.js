(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["PostItModeler"] = factory();
	else
		root["PostItModeler"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/BaseModeler.js":
/*!****************************!*\
  !*** ./lib/BaseModeler.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseModeler)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ids__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ids */ "./node_modules/ids/dist/index.esm.js");
/* harmony import */ var _BaseViewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseViewer */ "./lib/BaseViewer.js");







/**
 * A base modeler for postit-js boards.
 *
 * Have a look at {@link Modeler} for a bundle that includes actual features.
 *
 * @param {Object} [options] configuration options to pass to the viewer
 * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.
 * @param {String|Number} [options.width] the width of the viewer
 * @param {String|Number} [options.height] the height of the viewer
 * @param {Object} [options.moddleExtensions] extension packages to provide
 * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules
 * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules
 */
function BaseModeler(options) {
  _BaseViewer__WEBPACK_IMPORTED_MODULE_2__.default.call(this, options);

  // hook ID collection into the modeler
  this.on('import.parse.complete', function(event) {
    if (!event.error) {
      this._collectIds(event.definitions, event.context);
    }
  }, this);

  this.on('diagram.destroy', function() {
    this.get('moddle').ids.clear();
  }, this);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(BaseModeler, _BaseViewer__WEBPACK_IMPORTED_MODULE_2__.default);


/**
 * Create a moddle instance, attaching ids to it.
 *
 * @param {Object} options
 */
BaseModeler.prototype._createModdle = function(options) {
  var moddle = _BaseViewer__WEBPACK_IMPORTED_MODULE_2__.default.prototype._createModdle.call(this, options);

  // attach ids to moddle to be able to track
  // and validated ids in the XML document
  // tree
  moddle.ids = new ids__WEBPACK_IMPORTED_MODULE_1__.default([ 32, 36, 1 ]);

  return moddle;
};

/**
 * Collect ids processed during parsing of the
 * definitions object.
 *
 * @param {ModdleElement} definitions
 * @param {Context} context
 */
BaseModeler.prototype._collectIds = function(definitions, context) {

  var moddle = definitions.$model,
      ids = moddle.ids,
      id;

  // remove references from previous import
  ids.clear();

  for (id in context.elementsById) {
    ids.claim(id, context.elementsById[id]);
  }
};


/***/ }),

/***/ "./lib/BaseViewer.js":
/*!***************************!*\
  !*** ./lib/BaseViewer.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseViewer)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var diagram_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js */ "./node_modules/diagram-js/lib/Diagram.js");
/* harmony import */ var _moddle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./moddle */ "./lib/moddle/index.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _import_Importer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./import/Importer */ "./lib/import/Importer.js");
/**
 * The code in the <project-logo></project-logo> area
 * must not be changed.
 *
 * @see http://bpmn.io/license for more information.
 */
















/**
 * A base viewer for Postit boards.
 *
 * Have a look at {@link Viewer}, {@link NavigatedViewer} or {@link Modeler} for
 * bundles that include actual features.
 *
 * @param {Object} [options] configuration options to pass to the viewer
 * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.
 * @param {String|Number} [options.width] the width of the viewer
 * @param {String|Number} [options.height] the height of the viewer
 * @param {Object} [options.moddleExtensions] extension packages to provide
 * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules
 * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules
 */
function BaseViewer(options) {

  options = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({}, DEFAULT_OPTIONS, options);

  this._moddle = this._createModdle(options);

  this._container = this._createContainer(options);

  this._init(this._container, this._moddle, options);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(BaseViewer, diagram_js__WEBPACK_IMPORTED_MODULE_2__.default);

/**
* The importXML result.
*
* @typedef {Object} ImportXMLResult
*
* @property {Array<string>} warnings
*/

/**
* The importXML error.
*
* @typedef {Error} ImportXMLError
*
* @property {Array<string>} warnings
*/


/**
 * Parse and render a Postit diagram.
 *
 * Once finished the viewer reports back the result to the
 * provided callback function with (err, warnings).
 *
 * ## Life-Cycle Events
 *
 * During import the viewer will fire life-cycle events:
 *
 *   * import.parse.start (about to read model from xml)
 *   * import.parse.complete (model read; may have worked or not)
 *   * import.render.start (graphical import start)
 *   * import.render.complete (graphical import finished)
 *   * import.done (everything done)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {String} xml the Postit xml
 * @param {ModdleElement<PostitRootBoard>|String} [rootBoard] Postit board or id of board to render (if not provided, the first one will be rendered)
 *
 * @returns {Promise<ImportXMLResult, ImportXMLError>}
 */
BaseViewer.prototype.importXML = function(xml, rootBoard) {

  var self = this;

  return new Promise(function(resolve, reject) {

    // hook in pre-parse listeners +
    // allow xml manipulation
    xml = self._emit('import.parse.start', { xml: xml }) || xml;

    self._moddle.fromXML(xml, 'postit:Definitions').then(function(result) {

      var definitions = result.rootElement;
      var references = result.references;
      var parseWarnings = result.warnings;
      var elementsById = result.elementsById;

      var context = {
        references: references,
        elementsById: elementsById,
        warnings: parseWarnings
      };

      // hook in post parse listeners +
      // allow definitions manipulation
      definitions = self._emit('import.parse.complete', {
        definitions: definitions,
        context: context
      }) || definitions;

      self.importDefinitions(definitions, rootBoard).then(function(result) {
        var allWarnings = [].concat(parseWarnings, result.warnings || []);

        self._emit('import.done', { error: null, warnings: allWarnings });

        return resolve({ warnings: allWarnings });
      }).catch(function(err) {
        var allWarnings = [].concat(parseWarnings, err.warnings || []);

        self._emit('import.done', { error: err, warnings: allWarnings });

        return reject(addWarningsToError(err, allWarnings));
      });
    }).catch(function(err) {

      self._emit('import.parse.complete', {
        error: err
      });

      err = checkValidationError(err);

      self._emit('import.done', { error: err, warnings: err.warnings });

      return reject(err);
    });

  });
};

/**
* The importDefinitions result.
*
* @typedef {Object} ImportDefinitionsResult
*
* @property {Array<string>} warnings
*/

/**
* The importDefinitions error.
*
* @typedef {Error} ImportDefinitionsError
*
* @property {Array<string>} warnings
*/

/**
 * Import parsed definitions and render a Postit diagram.
 *
 * Once finished the viewer reports back the result to the
 * provided callback function with (err, warnings).
 *
 * ## Life-Cycle Events
 *
 * During import the viewer will fire life-cycle events:
 *
 *   * import.render.start (graphical import start)
 *   * import.render.complete (graphical import finished)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {ModdleElement<Definitions>} definitions parsed Postit definitions
 * @param {ModdleElement<PostitRootBoard>|String} [rootBoard] Postit board or id of board to render (if not provided, the first one will be rendered)
 *
 * returns {Promise<ImportDefinitionsResult, ImportDefinitionsError>}
 */
BaseViewer.prototype.importDefinitions = function(definitions, rootBoard) {

  var self = this;

  return new Promise(function(resolve, reject) {

    self._setDefinitions(definitions);

    self.open(rootBoard).then(function(result) {

      var warnings = result.warnings;

      return resolve({ warnings: warnings });
    }).catch(function(err) {

      return reject(err);
    });
  });
};

/**
 * The open result.
 *
 * @typedef {Object} OpenResult
 *
 * @property {Array<string>} warnings
 */

/**
* The open error.
*
* @typedef {Error} OpenError
*
* @property {Array<string>} warnings
*/

/**
 * Open board of previously imported XML.
 *
 * Once finished the viewer reports back the result to the
 * provided callback function with (err, warnings).
 *
 * ## Life-Cycle Events
 *
 * During switch the viewer will fire life-cycle events:
 *
 *   * import.render.start (graphical import start)
 *   * import.render.complete (graphical import finished)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {String|ModdleElement<PostitRootBoard>} [rootBoardOrId] id or the diagram to open
 *
 * returns {Promise<OpenResult, OpenError>}
 */
BaseViewer.prototype.open = function(rootBoardOrId) {

  var definitions = this._definitions;
  var rootBord = rootBoardOrId;

  var self = this;

  return new Promise(function(resolve, reject) {
    if (!definitions) {
      var err1 = new Error('no XML imported');

      return reject(addWarningsToError(err1, []));
    }

    if (typeof rootBoardOrId === 'string') {
      rootBord = findRootBoard(definitions, rootBoardOrId);

      if (!rootBord) {
        var err2 = new Error('PostitRootBoard <' + rootBoardOrId + '> not found');

        return reject(addWarningsToError(err2, []));
      }
    }

    // clear existing rendered diagram
    // catch synchronous exceptions during #clear()
    try {
      self.clear();
    } catch (error) {

      return reject(addWarningsToError(error, []));
    }

    // perform graphical import
    (0,_import_Importer__WEBPACK_IMPORTED_MODULE_3__.importPostitDiagram)(self, definitions, rootBord).then(function(result) {

      var warnings = result.warnings;

      return resolve({ warnings: warnings });
    }).catch(function(err) {

      return reject(err);
    });
  });
};

/**
 * The saveXML result.
 *
 * @typedef {Object} SaveXMLResult
 *
 * @property {string} xml
 */

/**
 * Export the currently displayed Postit diagram as
 * a Postit XML document.
 *
 * ## Life-Cycle Events
 *
 * During XML saving the viewer will fire life-cycle events:
 *
 *   * saveXML.start (before serialization)
 *   * saveXML.serialized (after xml generation)
 *   * saveXML.done (everything done)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {Object} [options] export options
 * @param {Boolean} [options.format=false] output formatted XML
 * @param {Boolean} [options.preamble=true] output preamble
 *
 * returns {Promise<SaveXMLResult, Error>}
 */
BaseViewer.prototype.saveXML = function(options) {

  options = options || {};

  var self = this;

  var definitions = this._definitions;

  return new Promise(function(resolve, reject) {

    if (!definitions) {
      var err = new Error('no definitions loaded');

      return reject(err);
    }

    // allow to fiddle around with definitions
    definitions = self._emit('saveXML.start', {
      definitions: definitions
    }) || definitions;

    self._moddle.toXML(definitions, options).then(function(result) {

      var xml = result.xml;

      try {
        xml = self._emit('saveXML.serialized', {
          error: null,
          xml: xml
        }) || xml;

        self._emit('saveXML.done', {
          error: null,
          xml: xml
        });
      } catch (e) {
        console.error('error in saveXML life-cycle listener', e);
      }

      return resolve({ xml: xml });
    }).catch(function(err) {

      return reject(err);
    });
  });
};

/**
 * The saveSVG result.
 *
 * @typedef {Object} SaveSVGResult
 *
 * @property {string} svg
 */

/**
 * Export the currently displayed Postit diagram as
 * an SVG image.
 *
 * ## Life-Cycle Events
 *
 * During SVG saving the viewer will fire life-cycle events:
 *
 *   * saveSVG.start (before serialization)
 *   * saveSVG.done (everything done)
 *
 * You can use these events to hook into the life-cycle.
 *
 * @param {Object} [options]
 *
 * returns {Promise<SaveSVGResult, Error>}
 */
BaseViewer.prototype.saveSVG = function(options) {

  options = options || {};

  var self = this;

  return new Promise(function(resolve, reject) {

    self._emit('saveSVG.start');

    var svg, err;

    try {
      var canvas = self.get('canvas');

      var contentNode = canvas.getDefaultLayer(),
          defsNode = (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.query)('defs', canvas._svg);

      var contents = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_5__.innerSVG)(contentNode),
          defs = defsNode ? '<defs>' + (0,tiny_svg__WEBPACK_IMPORTED_MODULE_5__.innerSVG)(defsNode) + '</defs>' : '';

      var bbox = contentNode.getBBox();

      svg =
        '<?xml version="1.0" encoding="utf-8"?>\n' +
        '<!-- created with diagram-js / http://bpmn.io -->\n' +
        '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' +
        '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ' +
             'width="' + bbox.width + '" height="' + bbox.height + '" ' +
             'viewBox="' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '" version="1.1">' +
          defs + contents +
        '</svg>';
    } catch (e) {
      err = e;
    }

    self._emit('saveSVG.done', {
      error: err,
      svg: svg
    });

    if (!err) {
      return resolve({ svg: svg });
    }

    return reject(err);
  });
};

/**
 * Get a named diagram service.
 *
 * @example
 *
 * var elementRegistry = viewer.get('elementRegistry');
 * var startEventShape = elementRegistry.get('StartEvent_1');
 *
 * @param {String} name
 *
 * @return {Object} diagram service instance
 *
 * @method BaseViewer#get
 */

/**
 * Invoke a function in the context of this viewer.
 *
 * @example
 *
 * viewer.invoke(function(elementRegistry) {
 *   var startEventShape = elementRegistry.get('StartEvent_1');
 * });
 *
 * @param {Function} fn to be invoked
 *
 * @return {Object} the functions return value
 *
 * @method BaseViewer#invoke
 */


BaseViewer.prototype._setDefinitions = function(definitions) {
  this._definitions = definitions;
};

BaseViewer.prototype.getModules = function() {
  return this._modules;
};

/**
 * Remove all drawn elements from the viewer.
 *
 * After calling this method the viewer can still
 * be reused for opening another diagram.
 *
 * @method BaseViewer#clear
 */
BaseViewer.prototype.clear = function() {
  if (!this.getDefinitions()) {

    // no diagram to clear
    return;
  }

  // remove businessObject#di binding
  //
  // this is necessary, as we establish the bindings
  // in the PostitTreeWalker (and assume none are given
  // on reimport)
  this.get('elementRegistry').forEach(function(element) {
    var bo = element.businessObject;

    if (bo && bo.di) {
      delete bo.di;
    }
  });

  // remove drawn elements
  diagram_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.clear.call(this);
};

/**
 * Destroy the viewer instance and remove all its
 * remainders from the document tree.
 */
BaseViewer.prototype.destroy = function() {

  // diagram destroy
  diagram_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.destroy.call(this);

  // dom detach
  (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.remove)(this._container);
};

/**
 * Register an event listener
 *
 * Remove a previously added listener via {@link #off(event, callback)}.
 *
 * @param {String} event
 * @param {Number} [priority]
 * @param {Function} callback
 * @param {Object} [that]
 */
BaseViewer.prototype.on = function(event, priority, callback, target) {
  return this.get('eventBus').on(event, priority, callback, target);
};

/**
 * De-register an event listener
 *
 * @param {String} event
 * @param {Function} callback
 */
BaseViewer.prototype.off = function(event, callback) {
  this.get('eventBus').off(event, callback);
};

BaseViewer.prototype.attachTo = function(parentNode) {

  if (!parentNode) {
    throw new Error('parentNode required');
  }

  // ensure we detach from the
  // previous, old parent
  this.detach();

  // unwrap jQuery if provided
  if (parentNode.get && parentNode.constructor.prototype.jquery) {
    parentNode = parentNode.get(0);
  }

  if (typeof parentNode === 'string') {
    parentNode = (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.query)(parentNode);
  }

  parentNode.appendChild(this._container);

  this._emit('attach', {});

  this.get('canvas').resized();
};

BaseViewer.prototype.getDefinitions = function() {
  return this._definitions;
};

BaseViewer.prototype.detach = function() {

  var container = this._container,
      parentNode = container.parentNode;

  if (!parentNode) {
    return;
  }

  this._emit('detach', {});

  parentNode.removeChild(container);
};

BaseViewer.prototype._init = function(container, moddle, options) {

  var baseModules = options.modules || this.getModules(),
      additionalModules = options.additionalModules || [],
      staticModules = [
        {
          postitjs: [ 'value', this ],
          moddle: [ 'value', moddle ]
        }
      ];

  var diagramModules = [].concat(staticModules, baseModules, additionalModules);

  var diagramOptions = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.omit)(options, [ 'additionalModules' ]), {
    canvas: (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({}, options.canvas, { container: container }),
    modules: diagramModules
  });

  // invoke diagram constructor
  diagram_js__WEBPACK_IMPORTED_MODULE_2__.default.call(this, diagramOptions);

  if (options && options.container) {
    this.attachTo(options.container);
  }
};

/**
 * Emit an event on the underlying {@link EventBus}
 *
 * @param  {String} type
 * @param  {Object} event
 *
 * @return {Object} event processing result (if any)
 */
BaseViewer.prototype._emit = function(type, event) {
  return this.get('eventBus').fire(type, event);
};

BaseViewer.prototype._createContainer = function(options) {

  var container = (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.domify)('<div class="pjs-container"></div>');

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(container.style, {
    width: ensureUnit(options.width),
    height: ensureUnit(options.height),
    position: options.position
  });

  return container;
};

BaseViewer.prototype._createModdle = function(options) {
  var moddleOptions = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({}, this._moddleExtensions, options.moddleExtensions);

  return new _moddle__WEBPACK_IMPORTED_MODULE_6__.default(moddleOptions);
};

BaseViewer.prototype._modules = [];

BaseViewer.prototype._moddleExtensions = {};


// helpers ///////////////

function addWarningsToError(err, warningsAry) {
  err.warnings = warningsAry;
  return err;
}

function checkValidationError(err) {

  // check if we can help the user by indicating wrong Postit xml
  // (in case he or the exporting tool did not get that right)

  var pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/;
  var match = pattern.exec(err.message);

  if (match) {
    err.message =
      'unparsable content <' + match[1] + '> detected; ' +
      'this may indicate an invalid Postit board file' + match[2];
  }

  return err;
}

var DEFAULT_OPTIONS = {
  width: '100%',
  height: '100%',
  position: 'relative'
};


/**
 * Ensure the passed argument is a proper unit (defaulting to px)
 */
function ensureUnit(val) {
  return val + ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isNumber)(val) ? 'px' : '');
}


/**
 * Find RootBoard in definitions by ID
 *
 * @param {ModdleElement<Definitions>} definitions
 * @param {String} boardId
 *
 * @return {ModdleElement<PostitRootBoard>|null}
 */
function findRootBoard(definitions, boardId) {
  if (!boardId) {
    return null;
  }

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(definitions.rootBoards, function(element) {
    return element.id === boardId;
  }) || null;
}





/***/ }),

/***/ "./lib/Modeler.js":
/*!************************!*\
  !*** ./lib/Modeler.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Modeler)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseModeler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseModeler */ "./lib/BaseModeler.js");
/* harmony import */ var _Viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Viewer */ "./lib/Viewer.js");
/* harmony import */ var _NavigatedViewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NavigatedViewer */ "./lib/NavigatedViewer.js");
/* harmony import */ var diagram_js_lib_navigation_keyboard_move__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/navigation/keyboard-move */ "./node_modules/diagram-js/lib/navigation/keyboard-move/index.js");
/* harmony import */ var diagram_js_lib_navigation_movecanvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! diagram-js/lib/navigation/movecanvas */ "./node_modules/diagram-js/lib/navigation/movecanvas/index.js");
/* harmony import */ var diagram_js_lib_navigation_touch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! diagram-js/lib/navigation/touch */ "./node_modules/diagram-js/lib/navigation/touch/index.js");
/* harmony import */ var diagram_js_lib_navigation_zoomscroll__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! diagram-js/lib/navigation/zoomscroll */ "./node_modules/diagram-js/lib/navigation/zoomscroll/index.js");
/* harmony import */ var diagram_js_lib_features_align_elements__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! diagram-js/lib/features/align-elements */ "./node_modules/diagram-js/lib/features/align-elements/index.js");
/* harmony import */ var diagram_js_lib_features_auto_scroll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! diagram-js/lib/features/auto-scroll */ "./node_modules/diagram-js/lib/features/auto-scroll/index.js");
/* harmony import */ var diagram_js_lib_features_bendpoints__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! diagram-js/lib/features/bendpoints */ "./node_modules/diagram-js/lib/features/bendpoints/index.js");
/* harmony import */ var _features_canvas_create__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./features/canvas-create */ "./lib/features/canvas-create/index.js");
/* harmony import */ var diagram_js_lib_features_connect__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! diagram-js/lib/features/connect */ "./node_modules/diagram-js/lib/features/connect/index.js");
/* harmony import */ var diagram_js_lib_features_connection_preview__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! diagram-js/lib/features/connection-preview */ "./node_modules/diagram-js/lib/features/connection-preview/index.js");
/* harmony import */ var _features_context_pad__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./features/context-pad */ "./lib/features/context-pad/index.js");
/* harmony import */ var _features_copy_paste__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./features/copy-paste */ "./lib/features/copy-paste/index.js");
/* harmony import */ var diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! diagram-js/lib/features/create */ "./node_modules/diagram-js/lib/features/create/index.js");
/* harmony import */ var _features_editor_actions__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./features/editor-actions */ "./lib/features/editor-actions/index.js");
/* harmony import */ var _features_image_selection__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./features/image-selection */ "./lib/features/image-selection/index.js");
/* harmony import */ var _features_keyboard__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./features/keyboard */ "./lib/features/keyboard/index.js");
/* harmony import */ var diagram_js_lib_features_keyboard_move_selection__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! diagram-js/lib/features/keyboard-move-selection */ "./node_modules/diagram-js/lib/features/keyboard-move-selection/index.js");
/* harmony import */ var _features_label_editing__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./features/label-editing */ "./lib/features/label-editing/index.js");
/* harmony import */ var _features_modeling__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./features/modeling */ "./lib/features/modeling/index.js");
/* harmony import */ var diagram_js_lib_features_move__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! diagram-js/lib/features/move */ "./node_modules/diagram-js/lib/features/move/index.js");
/* harmony import */ var _features_palette__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./features/palette */ "./lib/features/palette/index.js");
/* harmony import */ var _features_replace_preview__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./features/replace-preview */ "./lib/features/replace-preview/index.js");
/* harmony import */ var diagram_js_lib_features_resize__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! diagram-js/lib/features/resize */ "./node_modules/diagram-js/lib/features/resize/index.js");
/* harmony import */ var _features_snapping__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./features/snapping */ "./lib/features/snapping/index.js");
/* harmony import */ var _features_drag_drop_images__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./features/drag-drop-images */ "./lib/features/drag-drop-images/index.js");


































//import SelectionOrganizerModule from './features/selection-organizer';
//import PropertiesPanelModule from './features/properties-panel-v2';
//import ImageSelectionModule from './features/image-selection-v2';
// CTODO


var initialDiagram =
  `<?xml version="1.0" encoding="UTF-8"?>
  <postit:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:di="http://www.omg.org/spec/DD/20100524/DI" id="sample-diagram">
    <postit:PostitBoard id="Board_1">
    </postit:PostitBoard>
    <postitDi:PostitRootBoard id="RootBoard_1">
      <postitDi:PostitPlane id="PositPlane_1" boardElement="Board_1">
      </postitDi:PostitPlane>
    </postitDi:PostitRootBoard>
  </postit:definitions>`;

function Modeler(options) {
  _BaseModeler__WEBPACK_IMPORTED_MODULE_1__.default.call(this, options);
}
inherits__WEBPACK_IMPORTED_MODULE_0___default()(Modeler, _BaseModeler__WEBPACK_IMPORTED_MODULE_1__.default);


Modeler.Viewer = _Viewer__WEBPACK_IMPORTED_MODULE_2__.default;
Modeler.NavigatedViewer = _NavigatedViewer__WEBPACK_IMPORTED_MODULE_3__.default;

/**
* The createDiagram result.
*
* @typedef {Object} CreateDiagramResult
*
* @property {Array<string>} warnings
*/

/**
* The createDiagram error.
*
* @typedef {Error} CreateDiagramError
*
* @property {Array<string>} warnings
*/

/**
 * Create a new diagram to start modeling.
 *
 * @returns {Promise<CreateDiagramResult, CreateDiagramError>}
 *
 */
Modeler.prototype.createDiagram = function() {
  return this.importXML(initialDiagram);
};


Modeler.prototype._interactionModules = [

  // non-modeling components
  diagram_js_lib_navigation_keyboard_move__WEBPACK_IMPORTED_MODULE_4__.default,
  diagram_js_lib_navigation_movecanvas__WEBPACK_IMPORTED_MODULE_5__.default,
  diagram_js_lib_navigation_touch__WEBPACK_IMPORTED_MODULE_6__.default,
  diagram_js_lib_navigation_zoomscroll__WEBPACK_IMPORTED_MODULE_7__.default
];

Modeler.prototype._modelingModules = [

  // modeling components
  diagram_js_lib_features_align_elements__WEBPACK_IMPORTED_MODULE_8__.default,
  diagram_js_lib_features_auto_scroll__WEBPACK_IMPORTED_MODULE_9__.default,
  diagram_js_lib_features_bendpoints__WEBPACK_IMPORTED_MODULE_10__.default,
  _features_canvas_create__WEBPACK_IMPORTED_MODULE_11__.default,
  diagram_js_lib_features_connect__WEBPACK_IMPORTED_MODULE_12__.default,
  diagram_js_lib_features_connection_preview__WEBPACK_IMPORTED_MODULE_13__.default,
  _features_context_pad__WEBPACK_IMPORTED_MODULE_14__.default,
  _features_copy_paste__WEBPACK_IMPORTED_MODULE_15__.default,
  diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_16__.default,
  _features_editor_actions__WEBPACK_IMPORTED_MODULE_17__.default,
  _features_image_selection__WEBPACK_IMPORTED_MODULE_18__.default,
  _features_keyboard__WEBPACK_IMPORTED_MODULE_19__.default,
  diagram_js_lib_features_keyboard_move_selection__WEBPACK_IMPORTED_MODULE_20__.default,
  _features_label_editing__WEBPACK_IMPORTED_MODULE_21__.default,
  _features_modeling__WEBPACK_IMPORTED_MODULE_22__.default,
  diagram_js_lib_features_move__WEBPACK_IMPORTED_MODULE_23__.default,
  _features_palette__WEBPACK_IMPORTED_MODULE_24__.default,
  _features_replace_preview__WEBPACK_IMPORTED_MODULE_25__.default,
  diagram_js_lib_features_resize__WEBPACK_IMPORTED_MODULE_26__.default,
  _features_snapping__WEBPACK_IMPORTED_MODULE_27__.default,

  _features_drag_drop_images__WEBPACK_IMPORTED_MODULE_28__.default,
  //SelectionOrganizerModule,
  //PropertiesPanelModule,
  //ImageSelectionModule,
  // CTODO
  
];


// modules the modeler is composed of
//
// - viewer modules
// - interaction modules
// - modeling modules

Modeler.prototype._modules = [].concat(
  _Viewer__WEBPACK_IMPORTED_MODULE_2__.default.prototype._modules,
  Modeler.prototype._interactionModules,
  Modeler.prototype._modelingModules
);


/***/ }),

/***/ "./lib/NavigatedViewer.js":
/*!********************************!*\
  !*** ./lib/NavigatedViewer.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NavigatedViewer)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Viewer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Viewer */ "./lib/Viewer.js");
/* harmony import */ var diagram_js_lib_navigation_keyboard_move__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/navigation/keyboard-move */ "./node_modules/diagram-js/lib/navigation/keyboard-move/index.js");
/* harmony import */ var diagram_js_lib_navigation_movecanvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/navigation/movecanvas */ "./node_modules/diagram-js/lib/navigation/movecanvas/index.js");
/* harmony import */ var diagram_js_lib_navigation_zoomscroll__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/navigation/zoomscroll */ "./node_modules/diagram-js/lib/navigation/zoomscroll/index.js");









/**
 * A viewer that includes mouse navigation facilities
 *
 * @param {Object} options
 */
function NavigatedViewer(options) {
  _Viewer__WEBPACK_IMPORTED_MODULE_1__.default.call(this, options);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(NavigatedViewer, _Viewer__WEBPACK_IMPORTED_MODULE_1__.default);


NavigatedViewer.prototype._navigationModules = [
  diagram_js_lib_navigation_keyboard_move__WEBPACK_IMPORTED_MODULE_2__.default,
  diagram_js_lib_navigation_movecanvas__WEBPACK_IMPORTED_MODULE_3__.default,
  diagram_js_lib_navigation_zoomscroll__WEBPACK_IMPORTED_MODULE_4__.default
];

NavigatedViewer.prototype._modules = [].concat(
  _Viewer__WEBPACK_IMPORTED_MODULE_1__.default.prototype._modules,
  NavigatedViewer.prototype._navigationModules
);

/***/ }),

/***/ "./lib/Viewer.js":
/*!***********************!*\
  !*** ./lib/Viewer.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Viewer)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core */ "./lib/core/index.js");
/* harmony import */ var diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/i18n/translate */ "./node_modules/diagram-js/lib/i18n/translate/index.js");
/* harmony import */ var diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/features/selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var diagram_js_lib_features_overlays__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! diagram-js/lib/features/overlays */ "./node_modules/diagram-js/lib/features/overlays/index.js");
/* harmony import */ var _BaseViewer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseViewer */ "./lib/BaseViewer.js");









function Viewer(options) {
  _BaseViewer__WEBPACK_IMPORTED_MODULE_1__.default.call(this, options);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Viewer, _BaseViewer__WEBPACK_IMPORTED_MODULE_1__.default);

// modules the viewer is composed of
Viewer.prototype._modules = [
  _core__WEBPACK_IMPORTED_MODULE_2__.default,
  diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_3__.default,
  diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_4__.default,
  diagram_js_lib_features_overlays__WEBPACK_IMPORTED_MODULE_5__.default
];

// default moddle extensions the viewer is composed of
Viewer.prototype._moddleExtensions = {};

/***/ }),

/***/ "./lib/core/index.js":
/*!***************************!*\
  !*** ./lib/core/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../draw */ "./lib/draw/index.js");
/* harmony import */ var _import__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../import */ "./lib/import/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _draw__WEBPACK_IMPORTED_MODULE_0__.default,
    _import__WEBPACK_IMPORTED_MODULE_1__.default
  ]
});

/***/ }),

/***/ "./lib/draw/PathMap.js":
/*!*****************************!*\
  !*** ./lib/draw/PathMap.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathMap)
/* harmony export */ });
/**
 * Map containing SVG paths needed by PostitRenderer.
 */

function PathMap() {

  /**
   * Contains a map of path elements
   *
   * <h1>Path definition</h1>
   * A parameterized path is defined like this:
   * <pre>
   * 'GATEWAY_PARALLEL': {
   *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
          '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
   *   height: 17.5,
   *   width:  17.5,
   *   heightElements: [2.5, 7.5],
   *   widthElements: [2.5, 7.5]
   * }
   * </pre>
   * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling
   * is based on the ratio between the specified height and width in this object and the
   * height and width that is set as scale target (Note x,y coordinates will be scaled with
   * individual ratios).</p>
   * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.
   * The scaling is based on the computed ratios.
   * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using
   * the computed ratio coefficient.
   * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.
   *   <ul>
   *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>
   *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>
   *   </ul>
   *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.
   * </p>
   */
  this.pathMap = {
    'EVENT_MESSAGE': {
      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
      height: 36,
      width:  36,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    'EVENT_SIGNAL': {
      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',
      height: 36,
      width: 36,
      heightElements: [18],
      widthElements: [10, 20]
    },
    'EVENT_ESCALATION': {
      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',
      height: 36,
      width: 36,
      heightElements: [20, 7],
      widthElements: [8]
    },
    'EVENT_CONDITIONAL': {
      d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' +
         'M {e.x2},{e.y3} l {e.x0},0 ' +
         'M {e.x2},{e.y4} l {e.x0},0 ' +
         'M {e.x2},{e.y5} l {e.x0},0 ' +
         'M {e.x2},{e.y6} l {e.x0},0 ' +
         'M {e.x2},{e.y7} l {e.x0},0 ' +
         'M {e.x2},{e.y8} l {e.x0},0 ',
      height: 36,
      width:  36,
      heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],
      widthElements:  [10.5, 14.5, 12.5]
    },
    'EVENT_LINK': {
      d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',
      height: 36,
      width: 36,
      heightElements: [4.4375, 6.75, 7.8125],
      widthElements: [9.84375, 13.5]
    },
    'EVENT_ERROR': {
      d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',
      height: 36,
      width: 36,
      heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],
      widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]
    },
    'EVENT_CANCEL_45': {
      d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' +
        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
      height: 36,
      width: 36,
      heightElements: [4.75, 8.5],
      widthElements: [4.75, 8.5]
    },
    'EVENT_COMPENSATION': {
      d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',
      height: 36,
      width: 36,
      heightElements: [6.5, 13, 0.4, 6.1],
      widthElements: [9, 9.3, 8.7]
    },
    'EVENT_TIMER_WH': {
      d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',
      height: 36,
      width:  36,
      heightElements: [10, 2],
      widthElements: [3, 7]
    },
    'EVENT_TIMER_LINE': {
      d:  'M {mx},{my} ' +
          'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',
      height: 36,
      width:  36,
      heightElements: [10, 3],
      widthElements: [0, 0]
    },
    'EVENT_MULTIPLE': {
      d:'m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',
      height: 36,
      width:  36,
      heightElements: [6.28099, 12.56199],
      widthElements: [3.1405, 9.42149, 12.56198]
    },
    'EVENT_PARALLEL_MULTIPLE': {
      d:'m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
        '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
      height: 36,
      width:  36,
      heightElements: [2.56228, 7.68683],
      widthElements: [2.56228, 7.68683]
    },
    'GATEWAY_EXCLUSIVE': {
      d:'m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' +
                    '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' +
                    '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',
      height: 17.5,
      width:  17.5,
      heightElements: [8.5, 6.5312, -6.5312, -8.5],
      widthElements:  [6.5, -6.5, 3, -3, 5, -5]
    },
    'GATEWAY_PARALLEL': {
      d:'m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' +
        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
      height: 30,
      width:  30,
      heightElements: [5, 12.5],
      widthElements: [5, 12.5]
    },
    'GATEWAY_EVENT_BASED': {
      d:'m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',
      height: 11,
      width:  11,
      heightElements: [-6, 6, 12, -12],
      widthElements: [9, -3, -12]
    },
    'GATEWAY_COMPLEX': {
      d:'m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' +
        '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' +
        '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' +
        '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',
      height: 17.125,
      width:  17.125,
      heightElements: [4.875, 3.4375, 2.125, 3],
      widthElements: [3.4375, 2.125, 4.875, 3]
    },
    'DATA_OBJECT_PATH': {
      d:'m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',
      height: 61,
      width:  51,
      heightElements: [10, 50, 60],
      widthElements: [10, 40, 50, 60]
    },
    'DATA_OBJECT_COLLECTION_PATH': {
      d:'m {mx}, {my} ' +
        'm  0 15  l 0 -15 ' +
        'm  4 15  l 0 -15 ' +
        'm  4 15  l 0 -15 ',
      height: 61,
      width:  51,
      heightElements: [12],
      widthElements: [1, 6, 12, 15]
    },
    'DATA_ARROW': {
      d:'m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',
      height: 61,
      width:  51,
      heightElements: [],
      widthElements: []
    },
    'DATA_STORE': {
      d:'m  {mx},{my} ' +
        'l  0,{e.y2} ' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +
        'l  0,-{e.y2} ' +
        'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +
        'm  -{e.x2},{e.y0}' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' +
        'm  -{e.x2},{e.y0}' +
        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',
      height: 61,
      width:  61,
      heightElements: [7, 10, 45],
      widthElements:  [2, 58, 60]
    },
    'TEXT_ANNOTATION': {
      d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',
      height: 30,
      width: 10,
      heightElements: [30],
      widthElements: [10]
    },
    'MARKER_SUB_PROCESS': {
      d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    'MARKER_PARALLEL': {
      d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    'MARKER_SEQUENTIAL': {
      d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    'MARKER_COMPENSATION': {
      d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',
      height: 10,
      width: 21,
      heightElements: [],
      widthElements: []
    },
    'MARKER_LOOP': {
      d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' +
        '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' +
        '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' +
        'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',
      height: 13.9,
      width: 13.7,
      heightElements: [],
      widthElements: []
    },
    'MARKER_ADHOC': {
      d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' +
        '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' +
        '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' +
        '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' +
        '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',
      height: 4,
      width: 15,
      heightElements: [],
      widthElements: []
    },
    'TASK_TYPE_SEND': {
      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
      height: 14,
      width:  21,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    'TASK_TYPE_SCRIPT': {
      d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' +
        'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' +
        'm -7,-12 l 5,0 ' +
        'm -4.5,3 l 4.5,0 ' +
        'm -3,3 l 5,0' +
        'm -4,3 l 5,0',
      height: 15,
      width:  12.6,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    'TASK_TYPE_USER_1': {
      d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' +
        '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' +
        '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' +
        'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' +
        'm -8,6 l 0,5.5 m 11,0 l 0,-5'
    },
    'TASK_TYPE_USER_2': {
      d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' +
        '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '
    },
    'TASK_TYPE_USER_3': {
      d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' +
        '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' +
        '-4.20799998,3.36699999 -4.20699998,4.34799999 z'
    },
    'TASK_TYPE_MANUAL': {
      d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' +
        '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' +
        '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' +
        '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' +
        '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' +
        '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' +
        '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' +
        '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' +
        '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' +
        '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' +
        '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' +
        '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'
    },
    'TASK_TYPE_INSTANTIATING_SEND': {
      d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'
    },
    'TASK_TYPE_SERVICE': {
      d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' +
        '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' +
        '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' +
        'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' +
        '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' +
        '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' +
        'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' +
        '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' +
        'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' +
        'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' +
        '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' +
        'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' +
        'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +
        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +
        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
    },
    'TASK_TYPE_SERVICE_FILL': {
      d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +
        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +
        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
    },
    'TASK_TYPE_BUSINESS_RULE_HEADER': {
      d: 'm {mx},{my} 0,4 20,0 0,-4 z'
    },
    'TASK_TYPE_BUSINESS_RULE_MAIN': {
      d: 'm {mx},{my} 0,12 20,0 0,-12 z' +
        'm 0,8 l 20,0 ' +
        'm -13,-4 l 0,8'
    },
    'MESSAGE_FLOW_MARKER': {
      d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'
    }
  };

  this.getRawPath = function getRawPath(pathId) {
    return this.pathMap[pathId].d;
  };

  /**
   * Scales the path to the given height and width.
   * <h1>Use case</h1>
   * <p>Use case is to scale the content of elements (event, gateways) based
   * on the element bounding box's size.
   * </p>
   * <h1>Why not transform</h1>
   * <p>Scaling a path with transform() will also scale the stroke and IE does not support
   * the option 'non-scaling-stroke' to prevent this.
   * Also there are use cases where only some parts of a path should be
   * scaled.</p>
   *
   * @param {String} pathId The ID of the path.
   * @param {Object} param <p>
   *   Example param object scales the path to 60% size of the container (data.width, data.height).
   *   <pre>
   *   {
   *     xScaleFactor: 0.6,
   *     yScaleFactor:0.6,
   *     containerWidth: data.width,
   *     containerHeight: data.height,
   *     position: {
   *       mx: 0.46,
   *       my: 0.2,
   *     }
   *   }
   *   </pre>
   *   <ul>
   *    <li>targetpathwidth = xScaleFactor * containerWidth</li>
   *    <li>targetpathheight = yScaleFactor * containerHeight</li>
   *    <li>Position is used to set the starting coordinate of the path. M is computed:
    *    <ul>
    *      <li>position.x * containerWidth</li>
    *      <li>position.y * containerHeight</li>
    *    </ul>
    *    Center of the container <pre> position: {
   *       mx: 0.5,
   *       my: 0.5,
   *     }</pre>
   *     Upper left corner of the container
   *     <pre> position: {
   *       mx: 0.0,
   *       my: 0.0,
   *     }</pre>
   *    </li>
   *   </ul>
   * </p>
   *
   */
  this.getScaledPath = function getScaledPath(pathId, param) {
    var rawPath = this.pathMap[pathId];

    // positioning
    // compute the start point of the path
    var mx, my;

    if (param.abspos) {
      mx = param.abspos.x;
      my = param.abspos.y;
    } else {
      mx = param.containerWidth * param.position.mx;
      my = param.containerHeight * param.position.my;
    }

    var coordinates = {}; // map for the scaled coordinates
    if (param.position) {

      // path
      var heightRatio = (param.containerHeight / rawPath.height) * param.yScaleFactor;
      var widthRatio = (param.containerWidth / rawPath.width) * param.xScaleFactor;


      // Apply height ratio
      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
        coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
      }

      // Apply width ratio
      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
        coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
      }
    }

    // Apply value to raw path
    var path = format(
      rawPath.d, {
        mx: mx,
        my: my,
        e: coordinates
      }
    );
    return path;
  };
}

// helpers //////////////////////

// copied from https://github.com/adobe-webplatform/Snap.svg/blob/master/src/svg.js
var tokenRegex = /\{([^}]+)\}/g,
    objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g; // matches .xxxxx or ["xxxxx"] to run over object properties

function replacer(all, key, obj) {
  var res = obj;
  key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {
    name = name || quotedName;
    if (res) {
      if (name in res) {
        res = res[name];
      }
      typeof res == 'function' && isFunc && (res = res());
    }
  });
  res = (res == null || res == obj ? all : res) + '';

  return res;
}

function format(str, obj) {
  return String(str).replace(tokenRegex, function(all, key) {
    return replacer(all, key, obj);
  });
}


/***/ }),

/***/ "./lib/draw/PostitRenderer.js":
/*!************************************!*\
  !*** ./lib/draw/PostitRenderer.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitRenderer)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_draw_BaseRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/draw/BaseRenderer */ "./node_modules/diagram-js/lib/draw/BaseRenderer.js");
/* harmony import */ var _features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../features/label-editing/LabelUtil */ "./lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var _PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PostitRendererUtil */ "./lib/draw/PostitRendererUtil.js");














var DEFAULT_FILL_OPACITY = .95;

var TASK_BORDER_RADIUS = 10;

var DEFAULT_TEXT_SIZE = 16;

function PostitRenderer(
    config, eventBus, styles, pathMap,
    canvas, textRenderer, priority) {

  diagram_js_lib_draw_BaseRenderer__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus, priority);

  var defaultFillColor = config && config.defaultFillColor,
      defaultStrokeColor = config && config.defaultStrokeColor;

  var computeStyle = styles.computeStyle;

  function drawCircle(parentGfx, width, height, offset, attrs) {

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isObject)(offset)) {
      attrs = offset;
      offset = 0;
    }

    offset = offset || 0;

    attrs = computeStyle(attrs, {
      stroke: 'black',
      strokeWidth: 2,
      fill: 'white'
    });

    if (attrs.fill === 'none') {
      delete attrs.fillOpacity;
    }

    var cx = width / 2,
        cy = height / 2;

    var circle = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('circle');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(circle, {
      cx: cx,
      cy: cy,
      r: Math.round((width + height) / 4 - offset)
    });
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(circle, attrs);

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(parentGfx, circle);

    return circle;
  }

  function drawRect(parentGfx, width, height, r, offset, attrs) {

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isObject)(offset)) {
      attrs = offset;
      offset = 0;
    }

    offset = offset || 0;

    attrs = computeStyle(attrs, {
      stroke: 'black',
      strokeWidth: 2,
      fill: 'white'
    });

    var rect = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('rect');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(rect, {
      x: offset,
      y: offset,
      width: width - offset * 2,
      height: height - offset * 2,
      rx: r,
      ry: r
    });
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(rect, attrs);

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(parentGfx, rect);

    return rect;
  }

  function drawPath(parentGfx, d, attrs) {

    attrs = computeStyle(attrs, [ 'no-fill' ], {
      strokeWidth: 2,
      stroke: 'black'
    });

    var path = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('path');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(path, { d: d });
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(path, attrs);

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(parentGfx, path);

    return path;
  }


  function renderLabel(parentGfx, label, options) {

    options = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
      size: {
        width: 100
      }
    }, options);

    var text = textRenderer.createText(label || '', options);

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(text).add('djs-label');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(parentGfx, text);

    return text;
  }

  function renderEmbeddedLabel(parentGfx, element, align, fontSize) {
    var semantic = (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getSemantic)(element);

    return renderLabel(parentGfx, semantic.name, {
      box: element,
      align: align,
      padding: 5,
      style: {
        fill: getColor(element) === 'black' ? 'white' : 'black',
        fontSize: fontSize || DEFAULT_TEXT_SIZE
      },
    });
  }

  function renderExternalLabel(parentGfx, element) {

    var box = {
      width: 90,
      height: 30,
      x: element.width / 2 + element.x,
      y: element.height / 2 + element.y
    };

    return renderLabel(parentGfx, (0,_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_5__.getLabel)(element), {
      box: box,
      fitBox: true,
      style: (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(
        {},
        textRenderer.getExternalStyle(),
        {
          fill: 'black'
        }
      )
    });
  }

  this.handlers = {
    'postit:SquarePostit': function(parentGfx, element) {

      var attrs = {
        fill: (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getFillColor)(element, defaultFillColor),
        stroke: (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getStrokeColor)(element, defaultStrokeColor)
      };

      if (!('fillOpacity' in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }

      var rect = drawRect(parentGfx, element.width, element.height, 0, attrs);

      renderEmbeddedLabel(parentGfx, element, 'center-middle');

      return rect;
    },

    'postit:Group': function(parentGfx, element) {

      var group = drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {
        stroke: 'black',
        strokeWidth: 1,
        strokeDasharray: '8,3,1,3',
        fill: 'none',
        pointerEvents: 'none'
      });

      return group;
    },

    'postit:CirclePostit': function(parentGfx, element) {
      var attrs = {
        fill: (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getFillColor)(element, defaultFillColor),
        stroke: (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getStrokeColor)(element, defaultStrokeColor)
      };

      if (!('fillOpacity' in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }

      var rect = drawCircle(parentGfx, element.width, element.height, attrs);

      renderEmbeddedLabel(parentGfx, element, 'center-middle');

      return rect;
    },
    'postit:TextBox': function(parentGfx, element) {
      var attrs = {
        fill: 'none',
        stroke: 'none'
      };

      var textSize = element.textSize || DEFAULT_TEXT_SIZE;

      var rect = drawRect(parentGfx, element.width, element.height, 0, attrs);

      renderEmbeddedLabel(parentGfx, element, 'center-middle', textSize);

      return rect;
    },
    'postit:Image': function(parentGfx, element) {
      var imageSource = getImageSource(element);

      var gfx;
      if (!imageSource) {

        // default placeholder
        gfx = drawRect(parentGfx, element.width, element.height, 0, {
          fill: '#ccc',
          stroke: '#ccc'
        });

        renderLabel(parentGfx, 'Image Placeholder', {
          box: element,
          align: 'center-middle',
          padding: 5,
          style: {
            fill: 'black',
            fontSize: DEFAULT_TEXT_SIZE
          },
        });

      } else {
        gfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('image', {
          x: 0,
          y: 0,
          width: element.width,
          height: element.height,
          href: getImageSource(element)
        });

        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(parentGfx, gfx);
      }

      return gfx;
    },

    'label': function(parentGfx, element) {
      return renderExternalLabel(parentGfx, element);
    }
  };


  // extension API, use at your own risk
  this._drawPath = drawPath;

}


inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitRenderer, diagram_js_lib_draw_BaseRenderer__WEBPACK_IMPORTED_MODULE_1__.default);

PostitRenderer.$inject = [
  'config.postit',
  'eventBus',
  'styles',
  'pathMap',
  'canvas',
  'textRenderer'
];


PostitRenderer.prototype.canRender = function(element) {
  return (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_6__.is)(element, 'postit:BoardElement');
};

PostitRenderer.prototype.drawShape = function(parentGfx, element) {
  var type = element.type;
  var h = this.handlers[type];

  /* jshint -W040 */
  return h(parentGfx, element);
};

PostitRenderer.prototype.getShapePath = function(element) {

  return (0,_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_4__.getRectPath)(element);
};

// helpers //////////

function getColor(element) {
  var bo = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_6__.getBusinessObject)(element);

  return bo.color || element.color;
}

function getImageSource(element) {
  var bo = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_6__.getBusinessObject)(element);

  return bo.source || element.source;
}



/***/ }),

/***/ "./lib/draw/PostitRendererUtil.js":
/*!****************************************!*\
  !*** ./lib/draw/PostitRendererUtil.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isTypedEvent": () => (/* binding */ isTypedEvent),
/* harmony export */   "getDi": () => (/* binding */ getDi),
/* harmony export */   "getSemantic": () => (/* binding */ getSemantic),
/* harmony export */   "getFillColor": () => (/* binding */ getFillColor),
/* harmony export */   "getStrokeColor": () => (/* binding */ getStrokeColor),
/* harmony export */   "getCirclePath": () => (/* binding */ getCirclePath),
/* harmony export */   "getRoundRectPath": () => (/* binding */ getRoundRectPath),
/* harmony export */   "getDiamondPath": () => (/* binding */ getDiamondPath),
/* harmony export */   "getRectPath": () => (/* binding */ getRectPath)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/util/RenderUtil */ "./node_modules/diagram-js/lib/util/RenderUtil.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/ModelUtil */ "./lib/util/ModelUtil.js");







// element utils //////////////////////

/**
 * Checks if eventDefinition of the given element matches with semantic type.
 *
 * @return {boolean} true if element is of the given semantic type
 */
function isTypedEvent(event, eventDefinitionType, filter) {

  function matches(definition, filter) {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.every)(filter, function(val, key) {

      // we want a == conversion here, to be able to catch
      // undefined == false and friends
      /* jshint -W116 */
      return definition[key] == val;
    });
  }

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.some)(event.eventDefinitions, function(definition) {
    return definition.$type === eventDefinitionType && matches(event, filter);
  });
}

function getDi(element) {
  return element.businessObject.di;
}

function getSemantic(element) {
  return element.businessObject;
}


// color access //////////////////////

function getFillColor(element, defaultColor) {
  return (
    getColor(element) ||
    getDi(element).get('bioc:fill') ||
    defaultColor ||
    'white'
  );
}

function getStrokeColor(element, defaultColor) {
  return (
    getColor(element) ||
    getDi(element).get('bioc:stroke') ||
    defaultColor ||
    'black'
  );
}


// cropping path customizations //////////////////////

function getCirclePath(shape) {

  var cx = shape.x + shape.width / 2,
      cy = shape.y + shape.height / 2,
      radius = shape.width / 2;

  var circlePath = [
    ['M', cx, cy],
    ['m', 0, -radius],
    ['a', radius, radius, 0, 1, 1, 0, 2 * radius],
    ['a', radius, radius, 0, 1, 1, 0, -2 * radius],
    ['z']
  ];

  return (0,diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__.componentsToPath)(circlePath);
}

function getRoundRectPath(shape, borderRadius) {

  var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;

  var roundRectPath = [
    ['M', x + borderRadius, y],
    ['l', width - borderRadius * 2, 0],
    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],
    ['l', 0, height - borderRadius * 2],
    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],
    ['l', borderRadius * 2 - width, 0],
    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],
    ['l', 0, borderRadius * 2 - height],
    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],
    ['z']
  ];

  return (0,diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__.componentsToPath)(roundRectPath);
}

function getDiamondPath(shape) {

  var width = shape.width,
      height = shape.height,
      x = shape.x,
      y = shape.y,
      halfWidth = width / 2,
      halfHeight = height / 2;

  var diamondPath = [
    ['M', x + halfWidth, y],
    ['l', halfWidth, halfHeight],
    ['l', -halfWidth, halfHeight],
    ['l', -halfWidth, -halfHeight],
    ['z']
  ];

  return (0,diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__.componentsToPath)(diamondPath);
}

function getRectPath(shape) {
  var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;

  var rectPath = [
    ['M', x, y],
    ['l', width, 0],
    ['l', 0, height],
    ['l', -width, 0],
    ['z']
  ];

  return (0,diagram_js_lib_util_RenderUtil__WEBPACK_IMPORTED_MODULE_1__.componentsToPath)(rectPath);
}

// helpers //////////

function getColor(element) {
  var bo = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.getBusinessObject)(element);

  return bo.color || element.color;
}

/***/ }),

/***/ "./lib/draw/TextRenderer.js":
/*!**********************************!*\
  !*** ./lib/draw/TextRenderer.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextRenderer)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_util_Text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/util/Text */ "./node_modules/diagram-js/lib/util/Text.js");




var DEFAULT_FONT_SIZE = 16;
var LINE_HEIGHT_RATIO = 1.2;


function TextRenderer(config) {

  var defaultStyle = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
    fontFamily: 'IBM Plex, sans-serif',
    fontSize: DEFAULT_FONT_SIZE,
    fontWeight: 'normal',
    lineHeight: LINE_HEIGHT_RATIO
  }, config && config.defaultStyle || {});

  var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;

  var externalStyle = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, defaultStyle, {
    fontSize: fontSize
  }, config && config.externalStyle || {});

  var textUtil = new diagram_js_lib_util_Text__WEBPACK_IMPORTED_MODULE_1__.default({
    style: defaultStyle
  });

  /**
   * Get the new bounds of an externally rendered,
   * layouted label.
   *
   * @param  {Bounds} bounds
   * @param  {String} text
   *
   * @return {Bounds}
   */
  this.getExternalLabelBounds = function(bounds, text) {

    var layoutedDimensions = textUtil.getDimensions(text, {
      box: {
        width: 90,
        height: 30,
        x: bounds.width / 2 + bounds.x,
        y: bounds.height / 2 + bounds.y
      },
      style: externalStyle
    });

    // resize label shape to fit label text
    return {
      x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),
      y: Math.round(bounds.y),
      width: Math.ceil(layoutedDimensions.width),
      height: Math.ceil(layoutedDimensions.height)
    };

  };

  /**
   * Create a layouted text element.
   *
   * @param {String} text
   * @param {Object} [options]
   *
   * @return {SVGElement} rendered text
   */
  this.createText = function(text, options) {
    return textUtil.createText(text, options || {});
  };

  /**
   * Get default text style.
   */
  this.getDefaultStyle = function() {
    return defaultStyle;
  };

  /**
   * Get the external text style.
   */
  this.getExternalStyle = function() {
    return externalStyle;
  };

}

TextRenderer.$inject = [
  'config.textRenderer'
];

/***/ }),

/***/ "./lib/draw/index.js":
/*!***************************!*\
  !*** ./lib/draw/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PostitRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PostitRenderer */ "./lib/draw/PostitRenderer.js");
/* harmony import */ var _TextRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextRenderer */ "./lib/draw/TextRenderer.js");
/* harmony import */ var _PathMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PathMap */ "./lib/draw/PathMap.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'postitRenderer' ],
  postitRenderer: [ 'type', _PostitRenderer__WEBPACK_IMPORTED_MODULE_0__.default ],
  textRenderer: [ 'type', _TextRenderer__WEBPACK_IMPORTED_MODULE_1__.default ],
  pathMap: [ 'type', _PathMap__WEBPACK_IMPORTED_MODULE_2__.default ]
});


/***/ }),

/***/ "./lib/features/canvas-create/CanvasCreate.js":
/*!****************************************************!*\
  !*** ./lib/features/canvas-create/CanvasCreate.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CanvasCreate)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var _util_ColorUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/ColorUtil */ "./lib/util/ColorUtil.js");
/* harmony import */ var diagram_js_lib_util_Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/util/Event */ "./node_modules/diagram-js/lib/util/Event.js");
/* harmony import */ var _modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modeling/util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");











var DEFAULT_SHAPE = {
  type: 'postit:SquarePostit',
  color: _util_ColorUtil__WEBPACK_IMPORTED_MODULE_0__.default.YELLOW,
  $instanceOf: function() { return true; }
};

function CanvasCreate(
    eventBus, elementFactory, canvas, directEditing, modeling) {

  var lastCreatedShape = DEFAULT_SHAPE;

  function _getNewShapePosition(event) {
    var eventPoint = (0,diagram_js_lib_util_Event__WEBPACK_IMPORTED_MODULE_1__.toPoint)(event);

    return {
      x: eventPoint.x,
      y: eventPoint.y
    };
  }

  function _activateDirectEdit(element) {
    if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_2__.isAny)(element, [ 'postit:Postit', 'postit:Group', 'postit:TextBox' ])) {

      directEditing.activate(element);
    }
  }

  function _createShapeOnCanvas(event) {
    var position = _getNewShapePosition(event);

    var newShape = elementFactory.createPostitElement(
      'shape', (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)(lastCreatedShape, position));

    var root = canvas.getRootElement();

    var createdShape = modeling.createShape(newShape, position, root);

    _activateDirectEdit(createdShape);
  }

  function _saveLastCreatedShape(shape) {
    if (!shape) {
      lastCreatedShape = DEFAULT_SHAPE;
      return;
    }

    var bo = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.getBusinessObject)(shape);

    lastCreatedShape = {
      type: shape.type,
      color: shape.color || bo.color,
      $instanceOf: function(type) {
        return (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);
      }
    };
  }


  function _createDropShadowFilter(viewport) {
    viewport.innerHTML = '<filter id="noteDropShadow" style="height: 130%;"><feGaussianBlur in="SourceAlpha" stdDeviation="3"></feGaussianBlur><feOffset dx="1" dy="2" result="offsetblur"></feOffset><feMerge><feMergeNode></feMergeNode><feMergeNode in="SourceGraphic"></feMergeNode></feMerge></filter>';
  }


  eventBus.on('canvas.init', function(context) {
    var svg = context.svg;

    _createDropShadowFilter(context.viewport);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.delegate.bind(svg, 'svg', 'dblclick', function(event) {
      if (event.target !== svg) {
        return;
      }

      _createShapeOnCanvas(event);
    });

    eventBus.on('create.end', function(context) {
      var shape = context.shape;
      _saveLastCreatedShape(shape);
    });
  });
}

CanvasCreate.prototype.$inject = [
  'eventBus',
  'elementFactory',
  'canvas',
  'directEditing',
  'modeling'
];


/***/ }),

/***/ "./lib/features/canvas-create/index.js":
/*!*********************************************!*\
  !*** ./lib/features/canvas-create/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CanvasCreate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CanvasCreate */ "./lib/features/canvas-create/CanvasCreate.js");
/* harmony import */ var diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js-direct-editing */ "./node_modules/diagram-js-direct-editing/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'canvasCreate' ],
  canvasCreate: [ 'type', _CanvasCreate__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./lib/features/context-pad/ContextPadProvider.js":
/*!********************************************************!*\
  !*** ./lib/features/context-pad/ContextPadProvider.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ContextPadProvider)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_util_Mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var _util_ColorUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/ColorUtil */ "./lib/util/ColorUtil.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");








/**
 * A provider for postit elements context pad
 */
function ContextPadProvider(
    config, injector, eventBus,
    contextPad, modeling, rules,
    imageSelection, translate) {

  config = config || {};

  contextPad.registerProvider(this);

  this._contextPad = contextPad;

  this._modeling = modeling;

  this._rules = rules;
  this._imageSelection = imageSelection;
  this._translate = translate;

  if (config.autoPlace !== false) {
    this._autoPlace = injector.get('autoPlace', false);
  }

  eventBus.on('create.end', 250, function(event) {
    var context = event.context,
        shape = context.shape;

    if (!(0,diagram_js_lib_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.hasPrimaryModifier)(event) || !contextPad.isOpen(shape)) {
      return;
    }

    var entries = contextPad.getEntries(shape);

    if (entries.replace) {
      entries.replace.action.click(event, shape);
    }
  });
}

ContextPadProvider.$inject = [
  'config.contextPad',
  'injector',
  'eventBus',
  'contextPad',
  'modeling',
  'rules',
  'imageSelection',
  'translate'
];


ContextPadProvider.prototype.getContextPadEntries = function(element) {

  const {
    _rules: rules,
    _modeling: modeling,
    _imageSelection: imageSelection,
    _translate: translate
  } = this;

  let actions = {};

  function _removeElement(e) {
    var urlParams = new URLSearchParams(window.location.search);
    var s_key = urlParams.get('s_key');
    if( s_key === null ) {
      shepherdAlert("Script Required", "You must open a script to update it's notes.");
    } else {
      $.ajax({
        type: "DELETE",
        beforeSend: function(xhr) {
                      xhr.setRequestHeader('X-CSRF-Token',
                          $('meta[name="csrf-token"]').attr('content'));
                    },
        url: "/scripts/" + s_key + "/destroy_image/" + element.businessObject.$attrs["key"],
        responseType: 'application/json',
        dataType: 'json',
        failure: function(data) {
          // Consciously not doing anything. Fail silently and clean up
          // later.
        }
      });
    }
    modeling.removeElements([ element ]);
  }

  function removeElement(e) {
    if( element.type === "postit:Image" ) {
      shepherdConfirm("Confirm Delete?", "Are you sure you want to delete this element?", _removeElement, [e]);
    } else {
      modeling.removeElements([ element ]);
    }
  }

  function setColor(color) {
    modeling.setColor(element, color);
  }

  function createDeleteEntry(actions) {

    // delete element entry, only show if allowed by rules
    let deleteAllowed = rules.allowed('elements.delete', { elements: [ element ] });

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isArray)(deleteAllowed)) {

      // was the element returned as a deletion candidate?
      deleteAllowed = deleteAllowed[0] === element;
    }

    if (deleteAllowed) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(actions, {
        'delete': {
          group: 'edit',
          className: 'bpmn-icon-trash',
          title: translate('Remove'),
          action: {
            click: removeElement
          }
        }
      });
    }
  }

  function createColoringEntries(actions) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.keys)(_util_ColorUtil__WEBPACK_IMPORTED_MODULE_2__.default), key => {
      var color = _util_ColorUtil__WEBPACK_IMPORTED_MODULE_2__.default[key];

      function getClassNames() {
        var classNames = [];

        if (color === getColor(element)) {

          classNames.push('pjs-color-entry-disabled');
        }

        classNames.push('pjs-color-entry-' + key);

        return classNames;
      }

      (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(actions, {
        ['color-' + key]: {
          group: 'color',
          className: getClassNames(),
          title: translate('Set Color'),
          action: {
            click: (event) => setColor(color)
          }
        }
      });
    });
  }

  if (element.type === 'label') {
    return actions;
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(element, 'postit:Postit')) {
    createColoringEntries(actions);
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(element, 'postit:Image')) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(actions, {
      'replace.image': {
        group: 'replace',
        className: 'bpmn-icon-screw-wrench',
        title: translate('Change image source'),
        action: {
          click: (event) => imageSelection.select(element)
        }
      }
    });
  }

  createDeleteEntry(actions);

  return actions;
};

// helpers //////////

function getColor(element) {
  var bo = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.getBusinessObject)(element);

  return bo.color || element.color;
}


/***/ }),

/***/ "./lib/features/context-pad/index.js":
/*!*******************************************!*\
  !*** ./lib/features/context-pad/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js-direct-editing */ "./node_modules/diagram-js-direct-editing/index.js");
/* harmony import */ var diagram_js_lib_features_context_pad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/context-pad */ "./node_modules/diagram-js/lib/features/context-pad/index.js");
/* harmony import */ var diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/features/selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var diagram_js_lib_features_connect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/features/connect */ "./node_modules/diagram-js/lib/features/connect/index.js");
/* harmony import */ var diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/features/create */ "./node_modules/diagram-js/lib/features/create/index.js");
/* harmony import */ var _popup_menu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../popup-menu */ "./lib/features/popup-menu/index.js");
/* harmony import */ var _ContextPadProvider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ContextPadProvider */ "./lib/features/context-pad/ContextPadProvider.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__.default,
    diagram_js_lib_features_context_pad__WEBPACK_IMPORTED_MODULE_1__.default,
    diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_2__.default,
    diagram_js_lib_features_connect__WEBPACK_IMPORTED_MODULE_3__.default,
    diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_4__.default,
    _popup_menu__WEBPACK_IMPORTED_MODULE_5__.default
  ],
  __init__: [ 'contextPadProvider' ],
  contextPadProvider: [ 'type', _ContextPadProvider__WEBPACK_IMPORTED_MODULE_6__.default ]
});

/***/ }),

/***/ "./lib/features/copy-paste/ModdleCopy.js":
/*!***********************************************!*\
  !*** ./lib/features/copy-paste/ModdleCopy.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ModdleCopy),
/* harmony export */   "getPropertyNames": () => (/* binding */ getPropertyNames)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var DISALLOWED_PROPERTIES = [
  'boardElements'
];

/**
 * @typedef {Function} <moddleCopy.canCopyProperties> listener
 *
 * @param {Object} context
 * @param {Array<string>} context.propertyNames
 * @param {ModdleElement} context.sourceElement
 * @param {ModdleElement} context.targetElement
 *
 * @returns {Array<string>|boolean} - Return properties to be copied or false to disallow
 * copying.
 */

/**
 * @typedef {Function} <moddleCopy.canCopyProperty> listener
 *
 * @param {Object} context
 * @param {ModdleElement} context.parent
 * @param {*} context.property
 * @param {string} context.propertyName
 *
 * @returns {*|boolean} - Return copied property or false to disallow
 * copying.
 */

/**
 * @typedef {Function} <moddleCopy.canSetCopiedProperty> listener
 *
 * @param {Object} context
 * @param {ModdleElement} context.parent
 * @param {*} context.property
 * @param {string} context.propertyName
 *
 * @returns {boolean} - Return false to disallow
 * setting copied property.
 */

/**
 * Utility for copying model properties from source element to target element.
 *
 * @param {EventBus} eventBus
 * @param {PostitFactory} postitFactory
 * @param {PostitModdle} moddle
 */
function ModdleCopy(eventBus, postitFactory, moddle) {
  this._postitFactory = postitFactory;
  this._eventBus = eventBus;
  this._moddle = moddle;

  // copy extension elements last
  eventBus.on('moddleCopy.canCopyProperties', function(context) {
    var propertyNames = context.propertyNames;

    if (!propertyNames || !propertyNames.length) {
      return;
    }

    return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(propertyNames, function(propertyName) {
      return propertyName === 'extensionElements';
    });
  });

  // default check whether property can be copied
  eventBus.on('moddleCopy.canCopyProperty', function(context) {
    var parent = context.parent,
        parentDescriptor = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(parent) && parent.$descriptor,
        propertyName = context.propertyName;

    if (propertyName && DISALLOWED_PROPERTIES.indexOf(propertyName) !== -1) {

      // disallow copying property
      return false;
    }

    if (propertyName &&
      parentDescriptor &&
      !(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(parentDescriptor.properties, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.matchPattern)({ name: propertyName }))) {

      // disallow copying property
      return false;
    }
  });
}

ModdleCopy.$inject = [
  'eventBus',
  'postitFactory',
  'moddle'
];

/**
 * Copy model properties of source element to target element.
 *
 * @param {ModdleElement} sourceElement
 * @param {ModdleElement} targetElement
 * @param {Array<string>} [propertyNames]
 *
 * @param {ModdleElement}
 */
ModdleCopy.prototype.copyElement = function(sourceElement, targetElement, propertyNames) {
  var self = this;

  if (propertyNames && !(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(propertyNames)) {
    propertyNames = [ propertyNames ];
  }

  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);

  var canCopyProperties = this._eventBus.fire('moddleCopy.canCopyProperties', {
    propertyNames: propertyNames,
    sourceElement: sourceElement,
    targetElement: targetElement
  });

  if (canCopyProperties === false) {
    return targetElement;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(canCopyProperties)) {
    propertyNames = canCopyProperties;
  }

  // copy properties
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(propertyNames, function(propertyName) {
    var sourceProperty;

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.has)(sourceElement, propertyName)) {
      sourceProperty = sourceElement.get(propertyName);
    }

    var copiedProperty = self.copyProperty(sourceProperty, targetElement, propertyName);

    var canSetProperty = self._eventBus.fire('moddleCopy.canSetCopiedProperty', {
      parent: targetElement,
      property: copiedProperty,
      propertyName: propertyName
    });

    if (canSetProperty === false) {
      return;
    }

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isDefined)(copiedProperty)) {
      targetElement.set(propertyName, copiedProperty);
    }
  });

  return targetElement;
};

/**
 * Copy model property.
 *
 * @param {*} property
 * @param {ModdleElement} parent
 * @param {string} propertyName
 *
 * @returns {*}
 */
ModdleCopy.prototype.copyProperty = function(property, parent, propertyName) {
  var self = this;

  // allow others to copy property
  var copiedProperty = this._eventBus.fire('moddleCopy.canCopyProperty', {
    parent: parent,
    property: property,
    propertyName: propertyName
  });

  // return if copying is NOT allowed
  if (copiedProperty === false) {
    return;
  }

  if (copiedProperty) {
    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {
      copiedProperty.$parent = parent;
    }

    return copiedProperty;
  }

  var propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName);

  // do NOT copy Ids and references
  if (propertyDescriptor.isId || propertyDescriptor.isReference) {
    return;
  }

  // copy arrays
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(property)) {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(property, function(childProperties, childProperty) {

      // recursion
      copiedProperty = self.copyProperty(childProperty, parent, propertyName);

      // copying might NOT be allowed
      if (copiedProperty) {
        copiedProperty.$parent = parent;

        return childProperties.concat(copiedProperty);
      }

      return childProperties;
    }, []);
  }

  // copy model elements
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(property) && property.$type) {
    if (this._moddle.getElementDescriptor(property).isGeneric) {
      return;
    }

    copiedProperty = self._postitFactory.create(property.$type);

    copiedProperty.$parent = parent;

    // recursion
    copiedProperty = self.copyElement(property, copiedProperty);

    return copiedProperty;
  }

  // copy primitive properties
  return property;
};

// helpers //////////

function getPropertyNames(descriptor, keepDefaultProperties) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(descriptor.properties, function(properties, property) {

    if (keepDefaultProperties && property.default) {
      return properties;
    }

    return properties.concat(property.name);
  }, []);
}

/***/ }),

/***/ "./lib/features/copy-paste/PostitCopyPaste.js":
/*!****************************************************!*\
  !*** ./lib/features/copy-paste/PostitCopyPaste.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitCopyPaste)
/* harmony export */ });
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");




function copyProperties(source, target, properties) {
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(properties)) {
    properties = [ properties ];
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(properties, function(property) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(source[property])) {
      target[property] = source[property];
    }
  });
}

function removeProperties(element, properties) {
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(properties)) {
    properties = [ properties ];
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(properties, function(property) {
    if (element[property]) {
      delete element[property];
    }
  });
}

var LOW_PRIORITY = 750;


function PostitCopyPaste(postitFactory, eventBus, moddleCopy) {

  eventBus.on('copyPaste.copyElement', LOW_PRIORITY, function(context) {
    var descriptor = context.descriptor,
        element = context.element;

    var businessObject = descriptor.oldBusinessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__.getBusinessObject)(element);

    descriptor.type = element.type;

    copyProperties(businessObject, descriptor, 'name');

    descriptor.di = {};

    // fill and stroke will be set to DI
    copyProperties(businessObject.di, descriptor.di, [
      'fill',
      'stroke'
    ]);

    if (isLabel(descriptor)) {
      return descriptor;
    }

  });

  var references;

  function resolveReferences(descriptor, cache) {
    var businessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__.getBusinessObject)(descriptor);

    // default sequence flows
    if (descriptor.default) {

      // relationship cannot be resolved immediately
      references[ descriptor.default ] = {
        element: businessObject,
        property: 'default'
      };
    }

    references = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(references, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(references, function(array, reference, key) {
      var element = reference.element,
          property = reference.property;

      if (key === descriptor.id) {
        element[ property ] = businessObject;

        array.push(descriptor.id);
      }

      return array;
    }, []));
  }

  eventBus.on('copyPaste.pasteElements', function() {
    references = {};
  });

  eventBus.on('copyPaste.pasteElement', function(context) {
    var cache = context.cache,
        descriptor = context.descriptor,
        oldBusinessObject = descriptor.oldBusinessObject,
        newBusinessObject;

    // do NOT copy business object if external label
    if (isLabel(descriptor)) {
      descriptor.businessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__.getBusinessObject)(cache[ descriptor.labelTarget ]);

      return;
    }

    newBusinessObject = postitFactory.create(oldBusinessObject.$type);

    descriptor.businessObject = moddleCopy.copyElement(
      oldBusinessObject,
      newBusinessObject
    );

    // resolve references e.g. default sequence flow
    resolveReferences(descriptor, cache);

    copyProperties(descriptor, newBusinessObject, [
      'color',
      'name'
    ]);

    removeProperties(descriptor, 'oldBusinessObject');
  });

}


PostitCopyPaste.$inject = [
  'postitFactory',
  'eventBus',
  'moddleCopy'
];

// helpers //////////

function isLabel(element) {
  return !!element.labelTarget;
}


/***/ }),

/***/ "./lib/features/copy-paste/index.js":
/*!******************************************!*\
  !*** ./lib/features/copy-paste/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_copy_paste__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/copy-paste */ "./node_modules/diagram-js/lib/features/copy-paste/index.js");
/* harmony import */ var _PostitCopyPaste__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitCopyPaste */ "./lib/features/copy-paste/PostitCopyPaste.js");
/* harmony import */ var _ModdleCopy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ModdleCopy */ "./lib/features/copy-paste/ModdleCopy.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_copy_paste__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'postitCopyPaste', 'moddleCopy' ],
  postitCopyPaste: [ 'type', _PostitCopyPaste__WEBPACK_IMPORTED_MODULE_1__.default ],
  moddleCopy: [ 'type', _ModdleCopy__WEBPACK_IMPORTED_MODULE_2__.default ]
});


/***/ }),

/***/ "./lib/features/di-ordering/PostitDiOrdering.js":
/*!******************************************************!*\
  !*** ./lib/features/di-ordering/PostitDiOrdering.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitDiOrdering)
/* harmony export */ });
/* harmony import */ var _draw_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../draw/PostitRendererUtil */ "./lib/draw/PostitRendererUtil.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_util_Elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");








var HIGH_PRIORITY = 2000;

function PostitDiOrdering(eventBus, canvas) {

  eventBus.on('saveXML.start', HIGH_PRIORITY, orderDi);

  function orderDi() {
    var root = canvas.getRootElement(),
        rootDi = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.getBusinessObject)(root).di,
        elements,
        diElements;

    elements = (0,diagram_js_lib_util_Elements__WEBPACK_IMPORTED_MODULE_1__.selfAndAllChildren)([ root ], false);

    // only postitDi:Shape can be direct children of postitDi:Plane
    elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(elements, function(element) {
      return element !== root && !element.labelTarget;
    });

    diElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.map)(elements, _draw_PostitRendererUtil__WEBPACK_IMPORTED_MODULE_3__.getDi);

    rootDi.set('planeElement', diElements);
  }
}

PostitDiOrdering.$inject = [ 'eventBus', 'canvas' ];


/***/ }),

/***/ "./lib/features/di-ordering/index.js":
/*!*******************************************!*\
  !*** ./lib/features/di-ordering/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PostitDiOrdering__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PostitDiOrdering */ "./lib/features/di-ordering/PostitDiOrdering.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [
    'postitDiOrdering'
  ],
  postitDiOrdering: [ 'type', _PostitDiOrdering__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./lib/features/drag-drop-images/DragDropImages.js":
/*!*********************************************************!*\
  !*** ./lib/features/drag-drop-images/DragDropImages.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragDropImages)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _FileUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FileUtil.js */ "./lib/features/drag-drop-images/FileUtil.js");






/* constants */
const POSTIT_IMAGE = 'postit:Image';
function randStr(length=5) {
  var result = '';
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  var charactersLength = characters.length;
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
const ENTRY_PROTOTYPE = () => {
  return {
    objId: randStr(),
    objType: POSTIT_IMAGE,
    objTitle: '',
    objDescription: '',
    objStarred: false,
    objHidden: false,
    objUnkeyed: false,
    objUnkeyedOriginal: false,
    objSrcUnkeyed: '',
    objCreationDate: '',
    source: '',
    objPositionX: null,
    objPositionY: null,
  };
};

/* constants */


var text;
function DragDropImages(eventBus, canvas, modeling, elementFactory, create, translate) {

  this._eventBus = eventBus;
  this._canvas = canvas;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._create = create;
  this._translate = translate;

  const createImageElement = _createImageElement.bind(this);

  text = { 'URL': this._translate('URL'),
    'An error occured during the file upload': this._translate('An error occured during the file upload'),
    'Upload files here': this._translate('Upload files here'),
    'Upload from local is for demo purposes only. It slows down the page and increases the file size.': this._translate('Upload from local is for demo purposes only. It slows down the page and increases the file size.'),
    'uploaded': this._translate('uploaded'),
    'file': this._translate('file'),
    'files': this._translate('files'),
    'selected': this._translate('selected'),
    'Upload again': this._translate('Upload again'),
    'Drag here': this._translate('Drag here'),
  };

  DragDropImages.CSS = `
    .pjs-visible {
      visibility: visible !important;
      display: block !important;
    }
    
    #pjs-drop-zone {
      visibility: hidden;
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: #555555;
      z-index: 1;
      opacity: 0.9;
    }

    #pjs-drop-zone-border {
      border-radius: 10px 10px 10px 10px;
      -moz-border-radius: 10px 10px 10px 10px;
      -webkit-border-radius: 10px 10px 10px 10px;
      border: 5px dashed #000000;
      z-index: 2;
      display: table;
      width: 98.9%;
      height: 100%; 
    }

    .pjs-drop-zone-text {
      vertical-align: middle;
      width: 100%;
      font-size: 25px;
      font-weight: bold;
      margin: 0 auto;
      text-align: center;
      display: table-cell;
  }`;

  DragDropImages.HTML_MARKUP = '<div id="pjs-drop-zone">'+
        '<div id="pjs-drop-zone-border">'+
          '<div class="pjs-drop-zone-text">'+
          text['Drag here']+
        '</div>'+
      '</div>'+
  '</div>';

  var style = document.createElement('style');
  style.type = 'text/css';
  style.innerHTML = DragDropImages.CSS;
  document.getElementsByTagName('HEAD')[0].appendChild(style);

  const canvasDOM = document.getElementById('canvas');

  const container = this._container = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(DragDropImages.HTML_MARKUP);
  canvasDOM.insertBefore(container, canvas.firstChild);

  function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
  }

  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'drag', function(ev) {
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'dragstart', function(ev) {
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'dragend', function(ev) {
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'dragover', function(ev) {
    preventDefaults(ev);
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'dragenter', function(ev) {
    document.getElementById('pjs-drop-zone').classList.add('pjs-visible');
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM,'dragleave', function(ev) {
    document.getElementById('pjs-drop-zone').classList.remove('pjs-visible');
  }, false);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvasDOM, 'drop', async function(ev) {
    preventDefaults(ev);
    document.getElementById('pjs-drop-zone').classList.remove('pjs-visible');
    uploadFiles(ev);
  }, false);


  async function uploadFiles(ev) {
    let uploadDisplayText;
    let uploadResultObj = await (0,_FileUtil_js__WEBPACK_IMPORTED_MODULE_1__.fileReader)(ev, null);
    let uploadResult = uploadResultObj.results;
    let errors = uploadResultObj.errors;
    if (!errors) {
      let uploadedFilesCount = (uploadResult.length) ? uploadResult.length : null;
      uploadDisplayText = uploadedFilesCount;
      if (isNaN(uploadedFilesCount) === false) {
        const filePluralText =+ (uploadResult.length == 1) ? text['file'] : text['files'];
        uploadDisplayText += ' ' + filePluralText + ' ' + text['uploaded'];
      }
      let i = uploadResult.length;
      while (i--) {
        createImageElement(ev, convertToEntry({ source: uploadResult[i] }));
      }
      console.log(uploadDisplayText);

      // topModal.displaySuccessModal(uploadDisplayText);
    } else {

      // topModal.displayErrorModal(text['An error occured during the file upload']);
    }
  }


}

const convertToEntry = function(options) {
  return { ...ENTRY_PROTOTYPE(), ...options };
};

const _createImageElement = function(event, options) {
  options = options || [];
  const shape = this._elementFactory.createShape({
    type: POSTIT_IMAGE,
    ...options,
  });
  const attach = false;
  const hints = { createElementsBehavior: false };
  const position = { x: event.x + (Math.random() * 100), y: event.y + (Math.random() * 100) };
  const target = this._canvas.getRootElement();
  this._modeling.createElements([shape], position, target, (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, hints, {
    attach: attach,
  }));
  return { id: shape.id, x: position.x, y: position.y, shape, width: shape.width, height: shape.height };
};

DragDropImages.prototype.$inject = [
  'eventBus',
  'canvas',
  'modeling',
  'elementFactory',
  'create',
  'translate'
];


/***/ }),

/***/ "./lib/features/drag-drop-images/FileUtil.js":
/*!***************************************************!*\
  !*** ./lib/features/drag-drop-images/FileUtil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fileToDataURL": () => (/* binding */ fileToDataURL),
/* harmony export */   "imageProcessor": () => (/* binding */ imageProcessor),
/* harmony export */   "fileReader": () => (/* binding */ fileReader)
/* harmony export */ });
function fileToDataURL(file) {
  return new Promise((resolve, reject) => {
    try {
      var reader = new FileReader();
      reader.onloadend = function() {
        resolve(reader.result);
      };
      reader.readAsDataURL(file);
    } catch (e) {
      reject(e);
    }
  });
}

async function imageProcessor(ev, file) {
  const base64file = await fileToDataURL(file);
  return base64file; // passing any errors through
}

async function fileReader(ev, files) {
  let uploadResult = [];
  let errors;
  let fileItems = files;
  if (ev && (ev.dataTransfer.items || ev.dataTransfer.files)) {
    fileItems = ev.dataTransfer.items || ev.dataTransfer.files;
  }
  try {
    if (fileItems) {
      for (var i = 0; i < fileItems.length; i++) {
        if (ev && ev.dataTransfer.items) {
          if (fileItems[i].kind === 'file') {
            var file = fileItems[i].getAsFile();
            uploadResult.push(file);
          }
        } else {
          uploadResult.push(fileItems[i]);
        }
      }
    }
  } catch (e) {
    errors = e;
    uploadResult = null;
  }
  const results = [];
  var j = 0;
  while (j < uploadResult.length) {
    const fileImg = await imageProcessor(ev, uploadResult[j]);
    results.push(fileImg);
    j+=1;
  }
  return { results, errors };
}



/***/ }),

/***/ "./lib/features/drag-drop-images/index.js":
/*!************************************************!*\
  !*** ./lib/features/drag-drop-images/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DragDropImages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragDropImages */ "./lib/features/drag-drop-images/DragDropImages.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'dragDropImages' ],
  dragDropImages: [ 'type', _DragDropImages__WEBPACK_IMPORTED_MODULE_0__.default]
});


/***/ }),

/***/ "./lib/features/editor-actions/PostitEditorActions.js":
/*!************************************************************!*\
  !*** ./lib/features/editor-actions/PostitEditorActions.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitEditorActions)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_features_editor_actions_EditorActions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/editor-actions/EditorActions */ "./node_modules/diagram-js/lib/features/editor-actions/EditorActions.js");
/* harmony import */ var diagram_js_lib_util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");







/**
 * Registers and executes Postit specific editor actions.
 *
 * @param {Injector} injector
 */
function PostitEditorActions(injector) {
  injector.invoke(diagram_js_lib_features_editor_actions_EditorActions__WEBPACK_IMPORTED_MODULE_1__.default, this);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitEditorActions, diagram_js_lib_features_editor_actions_EditorActions__WEBPACK_IMPORTED_MODULE_1__.default);

PostitEditorActions.$inject = [
  'injector'
];

/**
 * Register default actions.
 *
 * @param {Injector} injector
 */
PostitEditorActions.prototype._registerDefaultActions = function(injector) {

  // (0) invoke super method

  diagram_js_lib_features_editor_actions_EditorActions__WEBPACK_IMPORTED_MODULE_1__.default.prototype._registerDefaultActions.call(this, injector);

  // (1) retrieve optional components to integrate with

  var canvas = injector.get('canvas', false);
  var elementRegistry = injector.get('elementRegistry', false);
  var selection = injector.get('selection', false);
  var spaceTool = injector.get('spaceTool', false);
  var lassoTool = injector.get('lassoTool', false);
  var handTool = injector.get('handTool', false);
  var distributeElements = injector.get('distributeElements', false);
  var alignElements = injector.get('alignElements', false);
  var directEditing = injector.get('directEditing', false);
  var searchPad = injector.get('searchPad', false);
  var modeling = injector.get('modeling', false);

  // (2) check components and register actions

  if (canvas && elementRegistry && selection) {
    this._registerAction('selectElements', function() {

      // select all elements except for the invisible
      // root element
      var rootElement = canvas.getRootElement();

      var elements = elementRegistry.filter(function(element) {
        return element !== rootElement;
      });

      selection.select(elements);

      return elements;
    });
  }

  if (spaceTool) {
    this._registerAction('spaceTool', function() {
      spaceTool.toggle();
    });
  }

  if (lassoTool) {
    this._registerAction('lassoTool', function() {
      lassoTool.toggle();
    });
  }

  if (handTool) {
    this._registerAction('handTool', function() {
      handTool.toggle();
    });
  }

  if (selection && distributeElements) {
    this._registerAction('distributeElements', function(opts) {
      var currentSelection = selection.get(),
          type = opts.type;

      if (currentSelection.length) {
        distributeElements.trigger(currentSelection, type);
      }
    });
  }

  if (selection && alignElements) {
    this._registerAction('alignElements', function(opts) {
      var currentSelection = selection.get(),
          type = opts.type;

      if (currentSelection.length) {
        alignElements.trigger(currentSelection, type);
      }
    });
  }

  if (selection && modeling) {
    this._registerAction('setColor', function(opts) {
      var currentSelection = selection.get();

      if (currentSelection.length) {
        modeling.setColor(currentSelection, opts);
      }
    });
  }

  if (selection && directEditing) {
    this._registerAction('directEditing', function() {
      var currentSelection = selection.get();

      if (currentSelection.length) {
        directEditing.activate(currentSelection[0]);
      }
    });
  }

  if (searchPad) {
    this._registerAction('find', function() {
      searchPad.toggle();
    });
  }

  if (canvas && modeling) {
    this._registerAction('moveToOrigin', function() {
      var rootElement = canvas.getRootElement(),
          boundingBox;


      var elements = elementRegistry.filter(function(element) {
        return element !== rootElement;
      });

      boundingBox = (0,diagram_js_lib_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getBBox)(elements);

      modeling.moveElements(
        elements,
        { x: -boundingBox.x, y: -boundingBox.y },
        rootElement
      );
    });
  }

};

/***/ }),

/***/ "./lib/features/editor-actions/index.js":
/*!**********************************************!*\
  !*** ./lib/features/editor-actions/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_editor_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/editor-actions */ "./node_modules/diagram-js/lib/features/editor-actions/index.js");
/* harmony import */ var _PostitEditorActions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitEditorActions */ "./lib/features/editor-actions/PostitEditorActions.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_editor_actions__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  editorActions: [ 'type', _PostitEditorActions__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./lib/features/image-selection/ImageSelection.js":
/*!********************************************************!*\
  !*** ./lib/features/image-selection/ImageSelection.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageSelection)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_FileUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/FileUtil.js */ "./lib/util/FileUtil.js");
/* harmony import */ var _util_ScreenUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ScreenUtil.js */ "./lib/util/ScreenUtil.js");






var LOW_PRIORITY = 500;
var text;

function ImageSelection(canvas, eventBus, modeling, translate) {

  this._canvas = canvas;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._translate = translate;

  var self = this;

  eventBus.on('create.end', LOW_PRIORITY, function(event) {
    var context = event.context,
        element = context.shape,
        hints = context.hints;

    if (hints.selectImage) {
      self.select(element);
    }
  });

  text = { 'URL': this._translate('URL'),
    'An error occured during the file upload': this._translate('An error occured during the file upload'),
    'Upload files here': this._translate('Upload files here'),
    'Upload': this._translate('Upload'),
    'file': this._translate('file'),
    'files': this._translate('files'),
    'selected': this._translate('selected'),
    'Upload again': this._translate('Upload again'),
  };

  ImageSelection.IMAGE_SELECTION_MARKUP = '<div id="pjs-image-selection-modal" class="pjs-io-dialog-local">'+
    '<div class="pjs-io-dialog-section pjs-first">'+
      '<div id="pjs-image-selection-input-wrapper"><input id="pjs-image-selection-input" class="pjs-ui-element-bordered"></input></div>'+
      '<div class="pjs-labeled-input">'+
      '<label for="pjs-image-selection-input" class="pjs-input-text-static"><!--Search / -->'+text['URL']+':</label>'+
      '</div>'+
    '</div">'+
    '<div class="pjs-io-dialog-section">'+
    '<div class="pjs-section-spacer"></div>'+
    '<label for="pjs-image-upload"><div class="pjs-io-dialog-text-hint">'+
      '<a style="display:block"><ul id="pjs-image-dialog-text-hint-list" class="pjs-horizontal">'+
        '<li><div class="pjs-general-icon pjs-image-dialog-upload-icon"></div></li>'+
        '<li id="pjs-image-selection-files-text-error">'+text['An error occured during the file upload']+'</li>'+
        '<li id="pjs-image-selection-files-text-upload">'+text['Upload files here']+'</li>'+
      '</ul></a>'+
    '</div></label>'+
    '<input type="file" id="pjs-image-upload" style="display:none" multiple/>'+
    '<div class="pjs-io-dialog-section">'+
    '<div class="pjs-buttons pjs-image-selection-submit-wrapper"><button id="pjs-image-selection-submit">'+text['Upload']+'</button></div>'+
    '</div>'+
    '</div>'+
  '</div>';

}

ImageSelection.prototype._getParentContainer = function() {
  return this._canvas.getContainer();
};

ImageSelection.prototype.select = function(element, callback) {

  const self = this;

  const container = this._container = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(ImageSelection.IMAGE_SELECTION_MARKUP);

  const canvas = this._canvas._container.parentElement.parentElement;
  canvas.insertBefore(container, canvas.firstChild);

  const mousePosition = (0,_util_ScreenUtil_js__WEBPACK_IMPORTED_MODULE_1__.getMousePosition)(null);
  container.style.left = ( mousePosition.pageX - getOffsetLeft(container) ) + 'px';
  container.style.top = ( mousePosition.pageY - getOffsetTop(container) ) + 'px';

  const inputField = document.getElementById('pjs-image-selection-input'),
        submitButton = document.getElementById('pjs-image-selection-submit'),
        imageUploadTextError = document.getElementById('pjs-image-selection-files-text-error'),
        imageUploadTextUpload = document.getElementById('pjs-image-selection-files-text-upload'),
        imageUploadTextList = document.getElementById('pjs-image-dialog-text-hint-list'),
        imageUploadReader = document.getElementById('pjs-image-upload'),
        modal = document.getElementById('pjs-image-selection-modal');

  var uploadTextListHeight = imageUploadTextList.style.height;

  var source, filesToUpload;

  // focus url input field on modal open
  inputField.focus();

  // remove modal by clicking anywhere else
  const canvasDefaultClick = min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(canvas, 'click', function(ev) {
    if (modal) {

      // If we clicked one of our update buttons, don't close the dialog.
      var isBtn = false;
      document.querySelectorAll('.djs-context-pad .entry').forEach( function(btn) {
        if (btn == event.target ) {
          isBtn = true;
        }
      });

      const mousePos = (0,_util_ScreenUtil_js__WEBPACK_IMPORTED_MODULE_1__.getMousePosition)(ev);

      // The dialog is displaced by a box the size of font-size on each edge.
      var fontSize = document.defaultView.getComputedStyle(modal)['font-size'];
      fontSize = parseInt(fontSize.substring(0, fontSize.indexOf('px')));
      if (!isBtn && (
          (mousePos.pageX > modal.offsetLeft+getOffsetLeft(canvas)+modal.clientWidth
          || mousePos.pageX < modal.offsetLeft+getOffsetLeft(canvas) - fontSize)
          || (mousePos.pageY > modal.offsetTop+getOffsetTop(canvas)+modal.clientHeight
          || mousePos.pageY < modal.offsetTop+getOffsetTop(canvas) - fontSize) )) {
        removeImageSelectionModal();
      }
    }
  });


  for (var i=0; i < imageUploadReader.labels.length; i++) {
    // open file dialog
    min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(imageUploadReader.labels[i], 'click', function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      
      imageUploadReader.dispatchEvent(new MouseEvent(ev.type, ev));
    });
  }

  // after we open file dialog
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(imageUploadReader, 'change', async function() {
    inputField.disabled = 'true';

    let uploadDisplayText;

    let uploadResultObj = await (0,_util_FileUtil_js__WEBPACK_IMPORTED_MODULE_2__.fileReader)(null, imageUploadReader.files),
        uploadResult = uploadResultObj.uploadResult,
        errors = uploadResultObj.errors;

    if (!errors) {
      let uploadedFilesCount = (uploadResult.length) ? uploadResult.length : 0;
      uploadDisplayText = uploadedFilesCount;

      if (isNaN(uploadedFilesCount) === false) {

        const filePluralText =+ (uploadResult.length == 1) ? text['file'] : text['files'];
        uploadDisplayText += ' ' + filePluralText + ' ' + text['selected'];

        // uploaded files are saved in global var
        filesToUpload = uploadResult;
      }

      displayUploadStaging(uploadDisplayText);
    } else {
      displayError();
    }
  });

  // upload button
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(submitButton, 'click', async function() {
    source = filesToUpload;

    // (1) call from canvas, providing a target element
    if (element !== null) {

      // (1.1) local file selection upload
      if (source) {
        for (const f in filesToUpload) {
          uploadImage(self, filesToUpload[f]);
        }

      // (1.2) url upload
      } else {
        source = inputField.value;
        uploadImage(self, source);
      }

      self._eventBus.fire('imageSelection.complete', { element: element });

    // (2) external call w/o canvas target
    } else {

      // (2.1 default) local file selection data is used

      // (2.2) url upload
      if (!source) {
        source = inputField.value;
      }

      callback(source);
    }

    // error handling not necessary as default img will be shown in error situation
    removeImageSelectionModal();
  });

  // enter pressed
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(inputField, 'keyup', function(esvent) {
    if (event.keyCode === 13) {
      event.preventDefault();
      submitButton.click();
    }
  });

  function getOffsetLeft(elem) {
    var offsetLeft = 0;
    do {
      if ( !isNaN( elem.offsetLeft ) )
      {
          offsetLeft += elem.offsetLeft;
      }
    } while( elem = elem.offsetParent );
    return offsetLeft;
  }

  function getOffsetTop(elem) {
    var offsetTop = 0;
    do {
      if ( !isNaN( elem.offsetTop ) )
      {
          offsetTop += elem.offsetTop;
      }
    } while( elem = elem.offsetParent );
    return offsetTop;
  }

  function displayUploadStaging(text) {
    imageUploadTextList.style.height = uploadTextListHeight;
    imageUploadTextError.style.display = 'none';
    imageUploadTextUpload.innerHTML = text;

    if (document.getElementsByClassName('pjs-image-dialog-upload-icon').length > 0) {
      document.getElementsByClassName('pjs-image-dialog-upload-icon')[0].classList.remove('pjs-image-dialog-upload-icon-error');
    }
  }

  function displayError() {
    uploadTextListHeight = imageUploadTextList.style.height;

    imageUploadTextList.style.height = 'auto';
    imageUploadTextError.style.display = 'block';
    imageUploadTextUpload.innerHTML = text['Upload again'];

    document.getElementsByClassName('pjs-image-dialog-upload-icon')[0].classList.add('pjs-image-dialog-upload-icon-error');
  }

  async function uploadImage(self, source) {
    var urlParams = new URLSearchParams(window.location.search);
    var s_key = urlParams.get('s_key');
    if( s_key === null ) {
      shepherdAlert("Script Required", "You must open a script before you can take notes!")
    } else {
      let image, blob;
      if( source.substring(0,4) !== "data" ) {
        blob = await fetch('https://cors-anywhere-dot-indieskedge-production.wl.r.appspot.com/' + source).then( r => r.blob() );
        blob.name = "Remote File";
      } else {
        blob = imageUploadReader.files[0];
      }

      // Ugly because we expect this URL to exist on the page.
      var upload = new ActiveStorage.DirectUpload(
        blob,
        direct_upload_url
      );

      upload.create(function(error, blob) {
        if( error !== null ) {
          if( error.search("Status: 403") >= 0 ) {
            shepherdAlert("Subscription Needed!", "You must have an active subscription to save images! You can sign up <button data-toggle=\"modal\" href=\"#subscriptionModal\" onclick=\"Shepherd.activeTour.complete(); $('#ideatorNotesModal').modal('hide');\" data-description=\"Sign up for image uploading and other great featuers!\" data-reset=\"$('#ideatorNotesModal').modal(\'show\');\" style=\"color: blue; margin-left: -6px; text-decoration: underline;\">here!</button>");
          } else {
            shepherdAlert("Upload Error", error);
          }
        } else if( blob.key ) {
          $.ajax({
            type: "GET",
            beforeSend: function(xhr) {
                          xhr.setRequestHeader('X-CSRF-Token',
                              $('meta[name="csrf-token"]').attr('content'));
                        },
            url: "/scripts/" + s_key + "/image_url/" + blob.key,
            responseType: 'application/json',
            dataType: 'json',
            success: function(data) {
              self._modeling.updateProperties(element, {
                source: data.url,
                key: data.key
              });
            },
            failure: function(data) {
              alert(data);
            }
          });
        } else {
          shepherdAlert("Unknown Error", "We've logged this issue.  If it continues, please reach out to support.");
          Bugsnag.notify("Unknown upload response: " + blob.toString() )
        }
      });
    }
  }

  function removeImageSelectionModal() {
    if (modal && modal.parentNode) {
      modal.parentNode.removeChild(modal);
      if (canvasDefaultClick) {
        canvas.removeEventListener('click', canvasDefaultClick);
      }
    }
  }

};

ImageSelection.prototype.$inject = [
  'canvas',
  'eventBus',
  'modelng',
  'translate'
];


/***/ }),

/***/ "./lib/features/image-selection/index.js":
/*!***********************************************!*\
  !*** ./lib/features/image-selection/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageSelection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageSelection */ "./lib/features/image-selection/ImageSelection.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'imageSelection' ],
  imageSelection: [ 'type', _ImageSelection__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./lib/features/keyboard/PostitKeyboardBindings.js":
/*!*********************************************************!*\
  !*** ./lib/features/keyboard/PostitKeyboardBindings.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitKeyboardBindings)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_features_keyboard_KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/keyboard/KeyboardBindings */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardBindings.js");





/**
 * Postit specific keyboard bindings.
 *
 * @param {Injector} injector
 */
function PostitKeyboardBindings(injector) {
  injector.invoke(diagram_js_lib_features_keyboard_KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__.default, this);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitKeyboardBindings, diagram_js_lib_features_keyboard_KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__.default);

PostitKeyboardBindings.$inject = [
  'injector'
];


/**
 * Register available keyboard bindings.
 *
 * @param {Keyboard} keyboard
 * @param {EditorActions} editorActions
 */
PostitKeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {

  // inherit default bindings
  diagram_js_lib_features_keyboard_KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__.default.prototype.registerBindings.call(this, keyboard, editorActions);

  /**
   * Add keyboard binding if respective editor action
   * is registered.
   *
   * @param {String} action name
   * @param {Function} fn that implements the key binding
   */
  function addListener(action, fn) {

    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  }

  // select all elements
  // CTRL + A
  addListener('selectElements', function(context) {

    var event = context.keyEvent;

    if (keyboard.isKey(['a', 'A'], event) && keyboard.isCmd(event)) {
      editorActions.trigger('selectElements');

      return true;
    }
  });

  // search labels
  // CTRL + F
  addListener('find', function(context) {

    var event = context.keyEvent;

    if (keyboard.isKey(['f', 'F'], event) && keyboard.isCmd(event)) {
      editorActions.trigger('find');

      return true;
    }
  });

  // activate space tool
  // S
  addListener('spaceTool', function(context) {

    var event = context.keyEvent;

    if (keyboard.hasModifier(event)) {
      return;
    }

    if (keyboard.isKey(['s', 'S'], event)) {
      editorActions.trigger('spaceTool');

      return true;
    }
  });

  // activate lasso tool
  // L
  addListener('lassoTool', function(context) {

    var event = context.keyEvent;

    if (keyboard.hasModifier(event)) {
      return;
    }

    if (keyboard.isKey(['l', 'L'], event)) {
      editorActions.trigger('lassoTool');

      return true;
    }
  });

  // activate hand tool
  // H
  addListener('handTool', function(context) {

    var event = context.keyEvent;

    if (keyboard.hasModifier(event)) {
      return;
    }

    if (keyboard.isKey(['h', 'H'], event)) {
      editorActions.trigger('handTool');

      return true;
    }
  });

  // activate direct editing
  // E
  addListener('directEditing', function(context) {

    var event = context.keyEvent;

    if (keyboard.hasModifier(event)) {
      return;
    }

    if (keyboard.isKey(['e', 'E'], event)) {
      editorActions.trigger('directEditing');

      return true;
    }
  });

};

/***/ }),

/***/ "./lib/features/keyboard/index.js":
/*!****************************************!*\
  !*** ./lib/features/keyboard/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/keyboard */ "./node_modules/diagram-js/lib/features/keyboard/index.js");
/* harmony import */ var _PostitKeyboardBindings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitKeyboardBindings */ "./lib/features/keyboard/PostitKeyboardBindings.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_keyboard__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'keyboardBindings' ],
  keyboardBindings: [ 'type', _PostitKeyboardBindings__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./lib/features/label-editing/LabelEditingPreview.js":
/*!***********************************************************!*\
  !*** ./lib/features/label-editing/LabelEditingPreview.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LabelEditingPreview)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");




var MARKER_HIDDEN = 'djs-element-hidden',
    MARKER_LABEL_HIDDEN = 'djs-label-hidden';


function LabelEditingPreview(
    eventBus, canvas, elementRegistry,
    pathMap) {


  var element, gfx;

  eventBus.on('directEditing.activate', function(context) {
    var activeProvider = context.active;

    element = activeProvider.element.label || activeProvider.element;


    if (element.labelTarget) {
      canvas.addMarker(element, MARKER_HIDDEN);
    } else if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.is)(element, 'postit:Postit')) {
      canvas.addMarker(element, MARKER_LABEL_HIDDEN);
    }
  });


  eventBus.on([ 'directEditing.complete', 'directEditing.cancel' ], function(context) {
    var activeProvider = context.active;

    if (activeProvider) {
      canvas.removeMarker(activeProvider.element.label || activeProvider.element, MARKER_HIDDEN);
      canvas.removeMarker(element, MARKER_LABEL_HIDDEN);
    }

    element = undefined;

    if (gfx) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(gfx);

      gfx = undefined;
    }
  });
}

LabelEditingPreview.$inject = [
  'eventBus',
  'canvas',
  'elementRegistry',
  'pathMap'
];

/***/ }),

/***/ "./lib/features/label-editing/LabelEditingProvider.js":
/*!************************************************************!*\
  !*** ./lib/features/label-editing/LabelEditingProvider.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LabelEditingProvider)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _LabelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LabelUtil */ "./lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modeling/util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/LabelUtil */ "./lib/util/LabelUtil.js");









function LabelEditingProvider(
    eventBus, postitFactory, canvas, directEditing,
    modeling, resizeHandles, textRenderer) {

  this._postitFactory = postitFactory;
  this._canvas = canvas;
  this._modeling = modeling;
  this._textRenderer = textRenderer;

  directEditing.registerProvider(this);

  // listen to dblclick on non-root elements
  eventBus.on('element.dblclick', function(event) {
    activateDirectEdit(event.element, true);
  });

  // complete on followup canvas operation
  eventBus.on([
    'autoPlace.start',
    'canvas.viewbox.changing',
    'drag.init',
    'element.mousedown',
    'popupMenu.open'
  ], function(event) {

    if (directEditing.isActive()) {
      directEditing.complete();
    }
  });

  // cancel on command stack changes
  eventBus.on([ 'commandStack.changed' ], function(e) {
    if (directEditing.isActive()) {
      directEditing.cancel();
    }
  });


  eventBus.on('directEditing.activate', function(event) {
    resizeHandles.removeResizers();
  });

  eventBus.on('create.end', 500, function(event) {

    var context = event.context,
        element = context.shape,
        canExecute = event.context.canExecute,
        isTouch = event.isTouch;

    // TODO(nikku): we need to find a way to support the
    // direct editing on mobile devices; right now this will
    // break for desworkflowediting on mobile devices
    // as it breaks the user interaction workflow

    // TODO(nre): we should temporarily focus the edited element
    // here and release the focused viewport after the direct edit
    // operation is finished
    if (isTouch) {
      return;
    }

    if (!canExecute) {
      return;
    }

    if (context.hints && context.hints.createElementsBehavior === false) {
      return;
    }

    activateDirectEdit(element);
  });

  eventBus.on('autoPlace.end', 500, function(event) {
    activateDirectEdit(event.shape);
  });


  function activateDirectEdit(element, force) {
    if (force ||
        (0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(element, [ 'postit:Postit', 'postit:Group', 'postit:TextBox' ])) {

      directEditing.activate(element);
    }
  }

}

LabelEditingProvider.$inject = [
  'eventBus',
  'postitFactory',
  'canvas',
  'directEditing',
  'modeling',
  'resizeHandles',
  'textRenderer'
];


/**
 * Activate direct editing for activities and text annotations.
 *
 * @param  {djs.model.Base} element
 *
 * @return {Object} an object with properties bounds (position and size), text and options
 */
LabelEditingProvider.prototype.activate = function(element) {

  // text
  var text = (0,_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.getLabel)(element);

  if (text === undefined) {
    return;
  }

  var context = {
    text: text
  };

  // bounds
  var bounds = this.getEditingBBox(element);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(context, bounds);

  var options = {};

  // postits and text boxes
  if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(element, ['postit:Postit', 'postit:TextBox'])) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(options, {
      centerVertically: true
    });
  }

  // external labels
  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.isLabelExternal)(element)) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(options, {
      autoResize: true
    });
  }


  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(context, {
    options: options
  });

  return context;
};


/**
 * Get the editing bounding box based on the element's size and position
 *
 * @param  {djs.model.Base} element
 *
 * @return {Object} an object containing information about position
 *                  and size (fixed or minimum and/or maximum)
 */
LabelEditingProvider.prototype.getEditingBBox = function(element) {
  var canvas = this._canvas;

  var target = element.label || element;

  var bbox = canvas.getAbsoluteBBox(target);

  var mid = {
    x: bbox.x + bbox.width / 2,
    y: bbox.y + bbox.height / 2
  };

  // default position
  var bounds = { x: bbox.x, y: bbox.y };

  var zoom = canvas.zoom();

  var defaultStyle = this._textRenderer.getDefaultStyle(),
      externalStyle = this._textRenderer.getExternalStyle();

  // take zoom into account
  var externalFontSize = externalStyle.fontSize * zoom,
      externalLineHeight = externalStyle.lineHeight,
      defaultFontSize = defaultStyle.fontSize * zoom,
      defaultLineHeight = defaultStyle.lineHeight;

  var style = {
    fontFamily: this._textRenderer.getDefaultStyle().fontFamily,
    fontWeight: this._textRenderer.getDefaultStyle().fontWeight
  };


  if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(element, [ 'postit:Postit', 'postit:TextBox', 'postit:Group'])) {

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(bounds, {
      width: bbox.width,
      height: bbox.height
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(style, {
      fontSize: defaultFontSize + 'px',
      lineHeight: defaultLineHeight,
      paddingTop: (7 * zoom) + 'px',
      paddingBottom: (7 * zoom) + 'px',
      paddingLeft: (5 * zoom) + 'px',
      paddingRight: (5 * zoom) + 'px'
    });
  }

  var width = 90 * zoom,
      paddingTop = 7 * zoom,
      paddingBottom = 4 * zoom;

  // external labels for events, data elements, gateways, groups and connections
  if (target.labelTarget) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(bounds, {
      width: width,
      height: bbox.height + paddingTop + paddingBottom,
      x: mid.x - width / 2,
      y: bbox.y - paddingTop
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(style, {
      fontSize: externalFontSize + 'px',
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + 'px',
      paddingBottom: paddingBottom + 'px'
    });
  }

  // external label not yet created
  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.isLabelExternal)(target)
      && !(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.hasExternalLabel)(target)
      && !(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.isLabel)(target)) {

    var externalLabelMid = (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.getExternalLabelMid)(element);

    var absoluteBBox = canvas.getAbsoluteBBox({
      x: externalLabelMid.x,
      y: externalLabelMid.y,
      width: 0,
      height: 0
    });

    var height = externalFontSize + paddingTop + paddingBottom;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(bounds, {
      width: width,
      height: height,
      x: absoluteBBox.x - width / 2,
      y: absoluteBBox.y - height / 2
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(style, {
      fontSize: externalFontSize + 'px',
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + 'px',
      paddingBottom: paddingBottom + 'px'
    });
  }


  // transparent edit box
  if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(element, [ 'postit:Postit' ])) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(style, {
      backgroundColor: 'transparent'
    });
  }

  return { bounds: bounds, style: style };
};


LabelEditingProvider.prototype.update = function(element, newLabel) {

  if (isEmptyText(newLabel)) {
    newLabel = null;
  }

  this._modeling.updateLabel(element, newLabel);
};



// helpers //////////////////////

function isEmptyText(label) {
  return !label || !label.trim();
}

/***/ }),

/***/ "./lib/features/label-editing/LabelUtil.js":
/*!*************************************************!*\
  !*** ./lib/features/label-editing/LabelUtil.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLabel": () => (/* binding */ getLabel),
/* harmony export */   "setLabel": () => (/* binding */ setLabel)
/* harmony export */ });
/* harmony import */ var _modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modeling/util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");


function getLabelAttr(semantic) {
  if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(semantic, [ 'postit:Postit', 'postit:TextBox', 'postit:Group' ])) {
    return 'name';
  }
}

function getLabel(element) {
  var semantic = element.businessObject,
      attr = getLabelAttr(semantic);

  if (attr) {
    return semantic[attr] || '';
  }
}


function setLabel(element, text) {
  var semantic = element.businessObject,
      attr = getLabelAttr(semantic);

  if (attr) {
    semantic[attr] = text;
  }

  return element;
}

/***/ }),

/***/ "./lib/features/label-editing/cmd/UpdateLabelHandler.js":
/*!**************************************************************!*\
  !*** ./lib/features/label-editing/cmd/UpdateLabelHandler.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpdateLabelHandler)
/* harmony export */ });
/* harmony import */ var _LabelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LabelUtil */ "./lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/LabelUtil */ "./lib/util/LabelUtil.js");




var NULL_DIMENSIONS = {
  width: 0,
  height: 0
};


/**
 * A handler that updates the text of a postit element.
 */
function UpdateLabelHandler(modeling, textRenderer) {

  /**
   * Set the label and return the changed elements.
   *
   * Element parameter can be label itself or connection (i.e. sequence flow).
   *
   * @param {djs.model.Base} element
   * @param {String} text
   */
  function setText(element, text) {

    // external label if present
    var label = element.label || element;

    var labelTarget = element.labelTarget || element;

    (0,_LabelUtil__WEBPACK_IMPORTED_MODULE_0__.setLabel)(label, text, labelTarget !== label);

    return [ label, labelTarget ];
  }

  function preExecute(ctx) {
    var element = ctx.element,
        businessObject = element.businessObject,
        newLabel = ctx.newLabel;

    if (!(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.isLabel)(element)
        && (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.isLabelExternal)(element)
        && !(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.hasExternalLabel)(element)
        && !isEmptyText(newLabel)) {

      // create label
      var paddingTop = 7;

      var labelCenter = (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.getExternalLabelMid)(element);

      labelCenter = {
        x: labelCenter.x,
        y: labelCenter.y + paddingTop
      };

      modeling.createLabel(element, labelCenter, {
        id: businessObject.id + '_label',
        businessObject: businessObject
      });
    }
  }

  function execute(ctx) {
    ctx.oldLabel = (0,_LabelUtil__WEBPACK_IMPORTED_MODULE_0__.getLabel)(ctx.element);
    return setText(ctx.element, ctx.newLabel);
  }

  function revert(ctx) {
    return setText(ctx.element, ctx.oldLabel);
  }

  function postExecute(ctx) {
    var element = ctx.element,
        label = element.label || element,
        newLabel = ctx.newLabel,
        newBounds = ctx.newBounds,
        hints = ctx.hints || {};

    // ignore internal labels for elements
    if (!(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.isLabel)(label)) {
      return;
    }

    if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_1__.isLabel)(label) && isEmptyText(newLabel)) {

      if (hints.removeShape !== false) {
        modeling.removeShape(label, { unsetLabel: false });
      }

      return;
    }

    var text = (0,_LabelUtil__WEBPACK_IMPORTED_MODULE_0__.getLabel)(label);

    // resize element based on label _or_ pre-defined bounds
    if (typeof newBounds === 'undefined') {
      newBounds = textRenderer.getExternalLabelBounds(label, text);
    }

    // setting newBounds to false or _null_ will
    // disable the postExecute resize operation
    if (newBounds) {
      modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);
    }
  }

  // API

  this.preExecute = preExecute;
  this.execute = execute;
  this.revert = revert;
  this.postExecute = postExecute;
}

UpdateLabelHandler.$inject = [
  'modeling',
  'textRenderer'
];


// helpers ///////////////////////

function isEmptyText(label) {
  return !label || !label.trim();
}

/***/ }),

/***/ "./lib/features/label-editing/index.js":
/*!*********************************************!*\
  !*** ./lib/features/label-editing/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_change_support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/change-support */ "./node_modules/diagram-js/lib/features/change-support/index.js");
/* harmony import */ var diagram_js_lib_features_resize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/features/resize */ "./node_modules/diagram-js/lib/features/resize/index.js");
/* harmony import */ var diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js-direct-editing */ "./node_modules/diagram-js-direct-editing/index.js");
/* harmony import */ var _LabelEditingProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LabelEditingProvider */ "./lib/features/label-editing/LabelEditingProvider.js");
/* harmony import */ var _LabelEditingPreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LabelEditingPreview */ "./lib/features/label-editing/LabelEditingPreview.js");








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_change_support__WEBPACK_IMPORTED_MODULE_1__.default,
    diagram_js_lib_features_resize__WEBPACK_IMPORTED_MODULE_2__.default,
    diagram_js_direct_editing__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [
    'labelEditingProvider',
    'labelEditingPreview'
  ],
  labelEditingProvider: [ 'type', _LabelEditingProvider__WEBPACK_IMPORTED_MODULE_3__.default ],
  labelEditingPreview: [ 'type', _LabelEditingPreview__WEBPACK_IMPORTED_MODULE_4__.default ]
});


/***/ }),

/***/ "./lib/features/modeling/ElementFactory.js":
/*!*************************************************!*\
  !*** ./lib/features/modeling/ElementFactory.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementFactory)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var diagram_js_lib_core_ElementFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/core/ElementFactory */ "./node_modules/diagram-js/lib/core/ElementFactory.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/LabelUtil */ "./lib/util/LabelUtil.js");











/**
 * A postit-aware factory for diagram-js shapes
 */
function ElementFactory(postitFactory, moddle, translate) {
  diagram_js_lib_core_ElementFactory__WEBPACK_IMPORTED_MODULE_1__.default.call(this);

  this._postitFactory = postitFactory;
  this._moddle = moddle;
  this._translate = translate;
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(ElementFactory, diagram_js_lib_core_ElementFactory__WEBPACK_IMPORTED_MODULE_1__.default);

ElementFactory.$inject = [
  'postitFactory',
  'moddle',
  'translate'
];

ElementFactory.prototype.baseCreate = diagram_js_lib_core_ElementFactory__WEBPACK_IMPORTED_MODULE_1__.default.prototype.create;

ElementFactory.prototype.create = function(elementType, attrs) {

  // no special magic for labels,
  // we assume their businessObjects have already been created
  // and wired via attrs
  if (elementType === 'label') {
    return this.baseCreate(elementType, (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ type: 'label' }, _util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_LABEL_SIZE, attrs));
  }

  return this.createPostitElement(elementType, attrs);
};

ElementFactory.prototype.createPostitElement = function(elementType, attrs) {
  var size,
      translate = this._translate;

  attrs = attrs || {};

  var businessObject = attrs.businessObject;

  if (!businessObject) {
    if (!attrs.type) {
      throw new Error(translate('no shape type specified'));
    }

    businessObject = this._postitFactory.create(attrs.type);
  }

  if (!businessObject.di) {
    if (elementType === 'root') {
      businessObject.di = this._postitFactory.createDiPlane(businessObject, [], {
        id: businessObject.id + '_di'
      });
    } else {
      businessObject.di = this._postitFactory.createDiShape(businessObject, {}, {
        id: businessObject.id + '_di'
      });
    }
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.is)(businessObject, 'postit:Group')) {
    attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
      isFrame: true
    }, attrs);
  }

  if (attrs.di) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(businessObject.di, attrs.di);

    delete attrs.di;
  }

  applyAttributes(businessObject, attrs, [
    'processRef',
    'isInterrupting',
    'associationDirection',
    'isForCompensation'
  ]);

  size = this._getDefaultSize(businessObject);

  attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
    businessObject: businessObject,
    id: businessObject.id
  }, size, attrs);

  return this.baseCreate(elementType, attrs);
};


ElementFactory.prototype._getDefaultSize = function(semantic) {
  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.is)(semantic, 'postit:Postit')) {
    return { width: 150, height: 150 };
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.is)(semantic, 'postit:Group')) {
    return { width: 300, height: 300 };
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.is)(semantic, 'postit:Image')) {
    return { width: 300, height: 300 };
  }

  return { width: 100, height: 80 };
};



// helpers //////////////////////

/**
 * Apply attributes from a map to the given element,
 * remove attribute from the map on application.
 *
 * @param {Base} element
 * @param {Object} attrs (in/out map of attributes)
 * @param {Array<String>} attributeNames name of attributes to apply
 */
function applyAttributes(element, attrs, attributeNames) {

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attributeNames, function(property) {
    if (attrs[property] !== undefined) {
      applyAttribute(element, attrs, property);
    }
  });
}

/**
 * Apply named property to element and drain it from the attrs
 * collection.
 *
 * @param {Base} element
 * @param {Object} attrs (in/out map of attributes)
 * @param {String} attributeName to apply
 */
function applyAttribute(element, attrs, attributeName) {
  element[attributeName] = attrs[attributeName];

  delete attrs[attributeName];
}

/***/ }),

/***/ "./lib/features/modeling/Modeling.js":
/*!*******************************************!*\
  !*** ./lib/features/modeling/Modeling.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Modeling)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_features_modeling_Modeling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/modeling/Modeling */ "./node_modules/diagram-js/lib/features/modeling/Modeling.js");
/* harmony import */ var _cmd_UpdatePropertiesHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cmd/UpdatePropertiesHandler */ "./lib/features/modeling/cmd/UpdatePropertiesHandler.js");
/* harmony import */ var _cmd_UpdateCanvasRootHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cmd/UpdateCanvasRootHandler */ "./lib/features/modeling/cmd/UpdateCanvasRootHandler.js");
/* harmony import */ var _cmd_IdClaimHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cmd/IdClaimHandler */ "./lib/features/modeling/cmd/IdClaimHandler.js");
/* harmony import */ var _cmd_SetColorHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cmd/SetColorHandler */ "./lib/features/modeling/cmd/SetColorHandler.js");
/* harmony import */ var _label_editing_cmd_UpdateLabelHandler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../label-editing/cmd/UpdateLabelHandler */ "./lib/features/label-editing/cmd/UpdateLabelHandler.js");












/**
 * Postit modeling features activator
 *
 * @param {EventBus} eventBus
 * @param {ElementFactory} elementFactory
 * @param {CommandStack} commandStack
 * @param {PostitRules} postitRules
 */
function Modeling(
    eventBus, elementFactory, commandStack,
    postitRules) {

  diagram_js_lib_features_modeling_Modeling__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus, elementFactory, commandStack);

  this._postitRules = postitRules;
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Modeling, diagram_js_lib_features_modeling_Modeling__WEBPACK_IMPORTED_MODULE_1__.default);

Modeling.$inject = [
  'eventBus',
  'elementFactory',
  'commandStack',
  'postitRules'
];


Modeling.prototype.getHandlers = function() {
  var handlers = diagram_js_lib_features_modeling_Modeling__WEBPACK_IMPORTED_MODULE_1__.default.prototype.getHandlers.call(this);

  handlers['element.updateProperties'] = _cmd_UpdatePropertiesHandler__WEBPACK_IMPORTED_MODULE_2__.default;
  handlers['canvas.updateRoot'] = _cmd_UpdateCanvasRootHandler__WEBPACK_IMPORTED_MODULE_3__.default;
  handlers['id.updateClaim'] = _cmd_IdClaimHandler__WEBPACK_IMPORTED_MODULE_4__.default;
  handlers['element.setColor'] = _cmd_SetColorHandler__WEBPACK_IMPORTED_MODULE_5__.default;
  handlers['element.updateLabel'] = _label_editing_cmd_UpdateLabelHandler__WEBPACK_IMPORTED_MODULE_6__.default;

  return handlers;
};


Modeling.prototype.updateLabel = function(element, newLabel, newBounds, hints) {
  this._commandStack.execute('element.updateLabel', {
    element: element,
    newLabel: newLabel,
    newBounds: newBounds,
    hints: hints || {}
  });
};


Modeling.prototype.updateProperties = function(element, properties) {
  this._commandStack.execute('element.updateProperties', {
    element: element,
    properties: properties
  });
};

Modeling.prototype.claimId = function(id, moddleElement) {
  this._commandStack.execute('id.updateClaim', {
    id: id,
    element: moddleElement,
    claiming: true
  });
};


Modeling.prototype.unclaimId = function(id, moddleElement) {
  this._commandStack.execute('id.updateClaim', {
    id: id,
    element: moddleElement
  });
};

Modeling.prototype.setColor = function(elements, color) {
  if (!elements.length) {
    elements = [ elements ];
  }

  this._commandStack.execute('element.setColor', {
    elements: elements,
    color: color
  });
};


/***/ }),

/***/ "./lib/features/modeling/PostitFactory.js":
/*!************************************************!*\
  !*** ./lib/features/modeling/PostitFactory.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PositFactory)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");







function PositFactory(moddle) {
  this._model = moddle;
}

PositFactory.$inject = [ 'moddle' ];


PositFactory.prototype._needsId = function(element) {
  return (0,_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_0__.isAny)(element, [
    'postit:BoardElement'
  ]);
};

PositFactory.prototype._ensureId = function(element) {

  // generate semantic ids for elements
  // postit:Postit -> Positit_ID
  var prefix;

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__.is)(element, 'postit:Postit')) {
    prefix = 'Postit';
  } else {
    prefix = (element.$type || '').replace(/^[^:]*:/g, '');
  }

  prefix += '_';

  if (!element.id && this._needsId(element)) {
    element.id = this._model.ids.nextPrefixed(prefix, element);
  }
};


PositFactory.prototype.create = function(type, attrs) {
  var element = this._model.create(type, attrs || {});

  this._ensureId(element);

  return element;
};


PositFactory.prototype.createDiLabel = function() {
  return this.create('postitDi:PostitLabel', {
    bounds: this.createDiBounds()
  });
};


PositFactory.prototype.createDiShape = function(semantic, bounds, attrs) {

  return this.create('postitDi:PostitShape', (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
    boardElement: semantic,
    bounds: this.createDiBounds(bounds)
  }, attrs));
};


PositFactory.prototype.createDiBounds = function(bounds) {
  return this.create('dc:Bounds', bounds);
};


PositFactory.prototype.createDiPlane = function(semantic) {
  return this.create('postitDi:PostitPlane', {
    boardElement: semantic
  });
};

/***/ }),

/***/ "./lib/features/modeling/PostitUpdater.js":
/*!************************************************!*\
  !*** ./lib/features/modeling/PostitUpdater.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitUpdater)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! diagram-js/lib/util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");
/* harmony import */ var diagram_js_lib_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/model */ "./node_modules/diagram-js/lib/model/index.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");












/**
 * A handler responsible for updating the underlying Postit XML + DI
 * once changes on the diagram happen
 */
function PostitUpdater(
    eventBus, postitFactory, connectionDocking,
    translate) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  this._postitFactory = postitFactory;
  this._translate = translate;

  var self = this;


  // Postit + DI update //////////////////////


  // update parent
  function updateParent(e) {
    var context = e.context;

    self.updateParent(context.shape || context.connection, context.oldParent);
  }

  function reverseUpdateParent(e) {
    var context = e.context;

    var element = context.shape || context.connection,

        // oldParent is the (old) new parent, because we are undoing
        oldParent = context.parent || context.newParent;

    self.updateParent(element, oldParent);
  }

  this.executed([
    'shape.move',
    'shape.create',
    'shape.delete'
  ], ifPostit(updateParent));

  this.reverted([
    'shape.move',
    'shape.create',
    'shape.delete'
  ], ifPostit(reverseUpdateParent));

  /*
   * ## Updating Parent
   *
   * When morphing a root element
   * make sure that both the *semantic* and *di* parent of each element
   * is updated.
   *
   */
  function updateRoot(event) {
    var context = event.context,
        oldRoot = context.oldRoot,
        children = oldRoot.children;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(children, function(child) {
      if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(child, 'postit:BoardElement')) {
        self.updateParent(child);
      }
    });
  }

  this.executed([ 'canvas.updateRoot' ], updateRoot);
  this.reverted([ 'canvas.updateRoot' ], updateRoot);


  // update bounds
  function updateBounds(e) {
    var shape = e.context.shape;

    if (!(0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(shape, 'postit:BoardElement')) {
      return;
    }

    self.updateBounds(shape);
  }

  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], ifPostit(function(event) {

    // exclude labels because they're handled separately during shape.changed
    if (event.context.shape.type === 'label') {
      return;
    }

    updateBounds(event);
  }));

  this.reverted([ 'shape.move', 'shape.create', 'shape.resize' ], ifPostit(function(event) {

    // exclude labels because they're handled separately during shape.changed
    if (event.context.shape.type === 'label') {
      return;
    }

    updateBounds(event);
  }));

  // Handle labels separately. This is necessary, because the label bounds have to be updated
  // every time its shape changes, not only on move, create and resize.
  eventBus.on('shape.changed', function(event) {
    if (event.element.type === 'label') {
      updateBounds({ context: { shape: event.element } });
    }
  });

}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitUpdater, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

PostitUpdater.$inject = [
  'eventBus',
  'postitFactory',
  'connectionDocking',
  'translate'
];


// implementation //////////////////////

PostitUpdater.prototype.updateAttachment = function(context) {

  var shape = context.shape,
      businessObject = shape.businessObject,
      host = shape.host;

  businessObject.attachedToRef = host && host.businessObject;
};

PostitUpdater.prototype.updateParent = function(element, oldParent) {

  // do not update label parent
  if (element instanceof diagram_js_lib_model__WEBPACK_IMPORTED_MODULE_4__.Label) {
    return;
  }

  var parentShape = element.parent;

  var businessObject = element.businessObject,
      parentBusinessObject = parentShape && parentShape.businessObject,
      parentDi = parentBusinessObject && parentBusinessObject.di;

  this.updateSemanticParent(businessObject, parentBusinessObject);

  this.updateDiParent(businessObject.di, parentDi);
};


PostitUpdater.prototype.updateBounds = function(shape) {

  var di = shape.businessObject.di;

  var target = (shape instanceof diagram_js_lib_model__WEBPACK_IMPORTED_MODULE_4__.Label) ? this._getLabel(di) : di;

  var bounds = target.bounds;

  if (!bounds) {
    bounds = this._postitFactory.createDiBounds();
    target.set('bounds', bounds);
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(bounds, {
    x: shape.x,
    y: shape.y,
    width: shape.width,
    height: shape.height
  });
};


PostitUpdater.prototype.updateDiParent = function(di, parentDi) {

  if (parentDi && !(0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(parentDi, 'postitDi:PostitPlane')) {
    parentDi = parentDi.$parent;
  }

  if (di.$parent === parentDi) {
    return;
  }

  var planeElements = (parentDi || di.$parent).get('planeElement');

  if (parentDi) {
    planeElements.push(di);
    di.$parent = parentDi;
  } else {
    (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_5__.remove)(planeElements, di);
    di.$parent = null;
  }
};


PostitUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {

  var containment,
      translate = this._translate;

  if (businessObject.$parent === newParent) {
    return;
  }


  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(businessObject, 'postit:BoardElement')) {
    containment = 'boardElements';
  }

  if (!containment) {
    throw new Error(translate(
      'no parent for {element} in {parent}',
      {
        element: businessObject.id,
        parent: newParent.id
      }
    ));
  }

  var children;

  if (businessObject.$parent) {

    // remove from old parent
    children = businessObject.$parent.get(containment);
    (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_5__.remove)(children, businessObject);
  }

  if (!newParent) {
    businessObject.$parent = null;
  } else {

    // add to new parent
    children = newParent.get(containment);
    children.push(businessObject);
    businessObject.$parent = newParent;
  }

  if (visualParent) {
    var diChildren = visualParent.get(containment);

    (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_5__.remove)(children, businessObject);

    if (newParent) {

      if (!diChildren) {
        diChildren = [];
        newParent.set(containment, diChildren);
      }

      diChildren.push(businessObject);
    }
  }
};


// helpers //////////////////////

PostitUpdater.prototype._getLabel = function(di) {
  if (!di.label) {
    di.label = this._postitFactory.createDiLabel();
  }

  return di.label;
};


/**
 * Make sure the event listener is only called
 * if the touched element is a postit element.
 *
 * @param  {Function} fn
 * @return {Function} guarded function
 */
function ifPostit(fn) {

  return function(event) {

    var context = event.context,
        element = context.shape || context.connection;

    if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(element, 'postit:BoardElement')) {
      fn(event);
    }
  };
}


/***/ }),

/***/ "./lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js":
/*!****************************************************************************!*\
  !*** ./lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AdaptiveLabelPositioningBehavior)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var diagram_js_lib_util_Math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/util/Math */ "./node_modules/diagram-js/lib/util/PositionUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/LabelUtil */ "./lib/util/LabelUtil.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");










var ALIGNMENTS = [
  'top',
  'bottom',
  'left',
  'right'
];

var ELEMENT_LABEL_DISTANCE = 10;

/**
 * A component that makes sure that external labels are added
 * together with respective elements and properly updated (DI wise)
 * during move.
 *
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 */
function AdaptiveLabelPositioningBehavior(eventBus, modeling) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  this.postExecuted([
    'connection.create',
    'connection.layout',
    'connection.updateWaypoints'
  ], function(event) {
    var context = event.context,
        connection = context.connection,
        source = connection.source,
        target = connection.target,
        hints = context.hints || {};

    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(source);
      checkLabelAdjustment(target);
    }
  });


  this.postExecuted([
    'label.create'
  ], function(event) {
    var context = event.context,
        shape = context.shape,
        hints = context.hints || {};

    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(shape.labelTarget);
    }
  });


  this.postExecuted([
    'elements.create'
  ], function(event) {
    var context = event.context,
        elements = context.elements,
        hints = context.hints || {};

    if (hints.createElementsBehavior !== false) {
      elements.forEach(function(element) {
        checkLabelAdjustment(element);
      });
    }
  });

  function checkLabelAdjustment(element) {

    // skip non-existing labels
    if (!(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.hasExternalLabel)(element)) {
      return;
    }

    var optimalPosition = getOptimalPosition(element);

    // no optimal position found
    if (!optimalPosition) {
      return;
    }

    adjustLabelPosition(element, optimalPosition);
  }

  function adjustLabelPosition(element, orientation) {

    var elementMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(element),
        label = element.label,
        labelMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(label);

    // ignore labels that are being created
    if (!label.parent) {
      return;
    }

    var elementTrbl = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.asTRBL)(element);

    var newLabelMid;

    switch (orientation) {
    case 'top':
      newLabelMid = {
        x: elementMid.x,
        y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2
      };

      break;

    case 'left':

      newLabelMid = {
        x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,
        y: elementMid.y
      };

      break;

    case 'bottom':

      newLabelMid = {
        x: elementMid.x,
        y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2
      };

      break;

    case 'right':

      newLabelMid = {
        x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,
        y: elementMid.y
      };

      break;
    }

    var delta = (0,diagram_js_lib_util_Math__WEBPACK_IMPORTED_MODULE_4__.delta)(newLabelMid, labelMid);

    modeling.moveShape(label, delta);
  }

}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(AdaptiveLabelPositioningBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

AdaptiveLabelPositioningBehavior.$inject = [
  'eventBus',
  'modeling'
];


// helpers //////////////////////

/**
 * Return alignments which are taken by a boundary's host element
 *
 * @param {Shape} element
 *
 * @return {Array<String>}
 */
function getTakenHostAlignments(element) {

  var hostElement = element.host,
      elementMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(element),
      hostOrientation = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getOrientation)(elementMid, hostElement);

  var freeAlignments;

  // check whether there is a multi-orientation, e.g. 'top-left'
  if (hostOrientation.indexOf('-') >= 0) {
    freeAlignments = hostOrientation.split('-');
  } else {
    freeAlignments = [ hostOrientation ];
  }

  var takenAlignments = ALIGNMENTS.filter(function(alignment) {

    return freeAlignments.indexOf(alignment) === -1;
  });

  return takenAlignments;

}

/**
 * Return alignments which are taken by related connections
 *
 * @param {Shape} element
 *
 * @return {Array<String>}
 */
function getTakenConnectionAlignments(element) {

  var elementMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(element);

  var takenAlignments = [].concat(
    element.incoming.map(function(c) {
      return c.waypoints[c.waypoints.length - 2 ];
    }),
    element.outgoing.map(function(c) {
      return c.waypoints[1];
    })
  ).map(function(point) {
    return getApproximateOrientation(elementMid, point);
  });

  return takenAlignments;
}

/**
 * Return the optimal label position around an element
 * or _undefined_, if none was found.
 *
 * @param  {Shape} element
 *
 * @return {String} positioning identifier
 */
function getOptimalPosition(element) {

  var labelMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(element.label);

  var elementMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getMid)(element);

  var labelOrientation = getApproximateOrientation(elementMid, labelMid);

  if (!isAligned(labelOrientation)) {
    return;
  }

  var takenAlignments = getTakenConnectionAlignments(element);

  if (element.host) {
    var takenHostAlignments = getTakenHostAlignments(element);

    takenAlignments = takenAlignments.concat(takenHostAlignments);
  }

  var freeAlignments = ALIGNMENTS.filter(function(alignment) {

    return takenAlignments.indexOf(alignment) === -1;
  });

  // NOTHING TO DO; label already aligned a.O.K.
  if (freeAlignments.indexOf(labelOrientation) !== -1) {
    return;
  }

  return freeAlignments[0];
}

function getApproximateOrientation(p0, p1) {
  return (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_3__.getOrientation)(p1, p0, 5);
}

function isAligned(orientation) {
  return ALIGNMENTS.indexOf(orientation) !== -1;
}


/***/ }),

/***/ "./lib/features/modeling/behavior/AppendBehavior.js":
/*!**********************************************************!*\
  !*** ./lib/features/modeling/behavior/AppendBehavior.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AppendBehavior)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");





function AppendBehavior(eventBus) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  // assign correct shape position unless already set

  this.preExecute('shape.append', function(context) {

    var source = context.source,
        shape = context.shape;

    if (!context.position) {

      context.position = {
        x: source.x + source.width + 80 + shape.width / 2,
        y: source.y + source.height / 2
      };

    }
  }, true);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(AppendBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

AppendBehavior.$inject = [
  'eventBus'
];

/***/ }),

/***/ "./lib/features/modeling/behavior/CreateBoardElementBehavior.js":
/*!**********************************************************************!*\
  !*** ./lib/features/modeling/behavior/CreateBoardElementBehavior.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateBoardElementBehavior)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");









function CreateBoardElementBehavior(eventBus) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  // ensure properties were set in business object

  this.execute('shape.create', function(context) {

    var shape = context.context.shape;

    if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(shape, 'postit:Postit')) {
      const businessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.getBusinessObject)(shape);
      !businessObject.color && (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)(businessObject, { color: shape.color });
    }

    if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(shape, 'postit:Image')) {
      const businessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.getBusinessObject)(shape);
      !businessObject.source && (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)(businessObject, { source: shape.source });
    }
  });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(CreateBoardElementBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

CreateBoardElementBehavior.$inject = [
  'eventBus'
];

/***/ }),

/***/ "./lib/features/modeling/behavior/EmptyTextBoxBehavior.js":
/*!****************************************************************!*\
  !*** ./lib/features/modeling/behavior/EmptyTextBoxBehavior.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EmptyTextBoxBehavior)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");







function EmptyTextBoxBehavior(eventBus, modeling, directEditing) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  // delete text box if it has no text
  this.postExecute('element.updateLabel', function(context) {

    var element = context.element,
        newLabel = context.newLabel;

    if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(element, 'postit:TextBox') && isEmpty(newLabel)) {
      modeling.removeElements([ element ]);
    }
  }, true);

  eventBus.on('directEditing.cancel', 1001, function(event) {
    var active = event.active,
        element = active.element;

    if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(element, 'postit:TextBox') && isEmpty((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.getBusinessObject)(element).name)) {
      directEditing._active = false;
      modeling.removeElements([ element ]);
    }
  });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(EmptyTextBoxBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

EmptyTextBoxBehavior.$inject = [
  'eventBus',
  'modeling',
  'directEditing'
];


// helpers //////////

function isEmpty(label) {
  return !label || label === '';
}

/***/ }),

/***/ "./lib/features/modeling/behavior/FixHoverBehavior.js":
/*!************************************************************!*\
  !*** ./lib/features/modeling/behavior/FixHoverBehavior.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FixHoverBehavior)
/* harmony export */ });
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");


var HIGH_PRIORITY = 1500;


/**
 * Correct hover targets in certain situations to improve diagram interaction.
 *
 * @param {ElementRegistry} elementRegistry
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function FixHoverBehavior(elementRegistry, eventBus, canvas) {

  eventBus.on([
    'create.hover',
    'create.move',
    'create.end',
    'shape.move.hover',
    'shape.move.move',
    'shape.move.end'
  ], HIGH_PRIORITY, function(event) {
    var context = event.context,
        shape = context.shape || event.shape,
        hover = event.hover;

    var rootElement = canvas.getRootElement();

    // ensure group & label elements are dropped always onto the root
    if (hover !== rootElement && (shape.labelTarget || (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.is)(shape, 'postit:Group'))) {
      event.hover = rootElement;
      event.hoverGfx = elementRegistry.getGraphics(event.hover);
    }
  });

}

FixHoverBehavior.$inject = [
  'elementRegistry',
  'eventBus',
  'canvas'
];

/***/ }),

/***/ "./lib/features/modeling/behavior/ImportDockingFix.js":
/*!************************************************************!*\
  !*** ./lib/features/modeling/behavior/ImportDockingFix.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImportDockingFix)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var _util_LineIntersect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/LineIntersect */ "./lib/features/modeling/behavior/util/LineIntersect.js");





/**
 * Fix broken dockings after DI imports.
 *
 * @param {EventBus} eventBus
 */
function ImportDockingFix(eventBus) {

  function adjustDocking(startPoint, nextPoint, elementMid) {

    var elementTop = {
      x: elementMid.x,
      y: elementMid.y - 50
    };

    var elementLeft = {
      x: elementMid.x - 50,
      y: elementMid.y
    };

    var verticalIntersect = (0,_util_LineIntersect__WEBPACK_IMPORTED_MODULE_0__.default)(startPoint, nextPoint, elementMid, elementTop),
        horizontalIntersect = (0,_util_LineIntersect__WEBPACK_IMPORTED_MODULE_0__.default)(startPoint, nextPoint, elementMid, elementLeft);

    // original is horizontal or vertical center cross intersection
    var centerIntersect;

    if (verticalIntersect && horizontalIntersect) {
      if (getDistance(verticalIntersect, elementMid) > getDistance(horizontalIntersect, elementMid)) {
        centerIntersect = horizontalIntersect;
      } else {
        centerIntersect = verticalIntersect;
      }
    } else {
      centerIntersect = verticalIntersect || horizontalIntersect;
    }

    startPoint.original = centerIntersect;
  }

  function fixDockings(connection) {
    var waypoints = connection.waypoints;

    adjustDocking(
      waypoints[0],
      waypoints[1],
      (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(connection.source)
    );

    adjustDocking(
      waypoints[waypoints.length - 1],
      waypoints[waypoints.length - 2],
      (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(connection.target)
    );
  }

  eventBus.on('boardElement.added', function(e) {

    var element = e.element;

    if (element.waypoints) {
      fixDockings(element);
    }
  });
}

ImportDockingFix.$inject = [
  'eventBus'
];


// helpers //////////////////////

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

/***/ }),

/***/ "./lib/features/modeling/behavior/LabelBehavior.js":
/*!*********************************************************!*\
  !*** ./lib/features/modeling/behavior/LabelBehavior.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LabelBehavior),
/* harmony export */   "getReferencePointDelta": () => (/* binding */ getReferencePointDelta),
/* harmony export */   "getReferencePoint": () => (/* binding */ getReferencePoint),
/* harmony export */   "asEdges": () => (/* binding */ asEdges)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/LabelUtil */ "./lib/util/LabelUtil.js");
/* harmony import */ var _label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../label-editing/LabelUtil */ "./lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _util_LabelLayoutUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/LabelLayoutUtil */ "./lib/features/modeling/behavior/util/LabelLayoutUtil.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");
/* harmony import */ var diagram_js_lib_util_AttachUtil__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! diagram-js/lib/util/AttachUtil */ "./node_modules/diagram-js/lib/util/AttachUtil.js");
/* harmony import */ var diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! diagram-js/lib/layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var diagram_js_lib_util_PositionUtil__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! diagram-js/lib/util/PositionUtil */ "./node_modules/diagram-js/lib/util/PositionUtil.js");
/* harmony import */ var _util_GeometricUtil__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./util/GeometricUtil */ "./lib/features/modeling/behavior/util/GeometricUtil.js");
























var DEFAULT_LABEL_DIMENSIONS = {
  width: 90,
  height: 20
};

var NAME_PROPERTY = 'name';

/**
 * A component that makes sure that external labels are added
 * together with respective elements and properly updated (DI wise)
 * during move.
 *
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 * @param {PostitFactory} postitFactory
 * @param {TextRenderer} textRenderer
 */
function LabelBehavior(
    eventBus, modeling, postitFactory,
    textRenderer) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  // update label if name property was updated
  this.postExecute('element.updateProperties', function(e) {
    var context = e.context,
        element = context.element,
        properties = context.properties;

    if (NAME_PROPERTY in properties) {
      modeling.updateLabel(element, properties[NAME_PROPERTY]);
    }
  });

  // create label shape after shape/connection was created
  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {
    var context = e.context,
        hints = context.hints || {};

    if (hints.createElementsBehavior === false) {
      return;
    }

    var element = context.shape || context.connection,
        businessObject = element.businessObject;

    if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.isLabel)(element) || !(0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.isLabelExternal)(element)) {
      return;
    }

    // only create label if attribute available
    if (!(0,_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.getLabel)(element)) {
      return;
    }

    var labelCenter = (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.getExternalLabelMid)(element);

    // we don't care about x and y
    var labelDimensions = textRenderer.getExternalLabelBounds(
      DEFAULT_LABEL_DIMENSIONS,
      (0,_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.getLabel)(element)
    );

    modeling.createLabel(element, labelCenter, {
      id: businessObject.id + '_label',
      businessObject: businessObject,
      width: labelDimensions.width,
      height: labelDimensions.height
    });
  });

  // update label after label shape was deleted
  this.postExecute('shape.delete', function(event) {
    var context = event.context,
        labelTarget = context.labelTarget,
        hints = context.hints || {};

    // check if label
    if (labelTarget && hints.unsetLabel !== false) {
      modeling.updateLabel(labelTarget, null, null, { removeShape: false });
    }
  });

  // update di information on label creation
  this.postExecute([ 'label.create' ], function(event) {

    var context = event.context,
        element = context.shape,
        businessObject,
        di;

    // we want to trigger on real labels only
    if (!element.labelTarget) {
      return;
    }

    // we want to trigger on board elements only
    if (!(0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.is)(element.labelTarget || element, 'postit:BoardElement')) {
      return;
    }

    businessObject = element.businessObject,
    di = businessObject.di;


    if (!di.label) {
      di.label = postitFactory.create('postitDi:PostitLabel', {
        bounds: postitFactory.create('dc:Bounds')
      });
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_5__.assign)(di.label.bounds, {
      x: element.x,
      y: element.y,
      width: element.width,
      height: element.height
    });
  });

  function getVisibleLabelAdjustment(event) {

    var context = event.context,
        connection = context.connection,
        label = connection.label,
        hints = (0,min_dash__WEBPACK_IMPORTED_MODULE_5__.assign)({}, context.hints),
        newWaypoints = context.newWaypoints || connection.waypoints,
        oldWaypoints = context.oldWaypoints;


    if (typeof hints.startChanged === 'undefined') {
      hints.startChanged = !!hints.connectionStart;
    }

    if (typeof hints.endChanged === 'undefined') {
      hints.endChanged = !!hints.connectionEnd;
    }

    return (0,_util_LabelLayoutUtil__WEBPACK_IMPORTED_MODULE_6__.getLabelAdjustment)(label, newWaypoints, oldWaypoints, hints);
  }

  this.postExecute([
    'connection.layout',
    'connection.updateWaypoints'
  ], function(event) {
    var context = event.context,
        hints = context.hints || {};

    if (hints.labelBehavior === false) {
      return;
    }

    var connection = context.connection,
        label = connection.label,
        labelAdjustment;

    // handle missing label as well as the case
    // that the label parent does not exist (yet),
    // because it is being pasted / created via multi element create
    //
    // Cf. https://github.com/bpmn-io/bpmn-js/pull/1227
    if (!label || !label.parent) {
      return;
    }

    labelAdjustment = getVisibleLabelAdjustment(event);

    modeling.moveShape(label, labelAdjustment);
  });


  // keep label position on shape replace
  this.postExecute([ 'shape.replace' ], function(event) {
    var context = event.context,
        newShape = context.newShape,
        oldShape = context.oldShape;

    var businessObject = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_4__.getBusinessObject)(newShape);

    if (businessObject
      && (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.isLabelExternal)(businessObject)
      && oldShape.label
      && newShape.label) {
      newShape.label.x = oldShape.label.x;
      newShape.label.y = oldShape.label.y;
    }
  });


  // move external label after resizing
  this.postExecute('shape.resize', function(event) {

    var context = event.context,
        shape = context.shape,
        newBounds = context.newBounds,
        oldBounds = context.oldBounds;

    if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.hasExternalLabel)(shape)) {

      var label = shape.label,
          labelMid = (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_7__.getMid)(label),
          edges = asEdges(oldBounds);

      // get nearest border point to label as reference point
      var referencePoint = getReferencePoint(labelMid, edges);

      var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);

      modeling.moveShape(label, delta);

    }

  });

}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(LabelBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

LabelBehavior.$inject = [
  'eventBus',
  'modeling',
  'postitFactory',
  'textRenderer'
];

// helpers //////////////////////

/**
 * Calculates a reference point delta relative to a new position
 * of a certain element's bounds
 *
 * @param {Point} point
 * @param {Bounds} oldBounds
 * @param {Bounds} newBounds
 *
 * @return {Delta} delta
 */
function getReferencePointDelta(referencePoint, oldBounds, newBounds) {

  var newReferencePoint = (0,diagram_js_lib_util_AttachUtil__WEBPACK_IMPORTED_MODULE_8__.getNewAttachPoint)(referencePoint, oldBounds, newBounds);

  return (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_7__.roundPoint)((0,diagram_js_lib_util_PositionUtil__WEBPACK_IMPORTED_MODULE_9__.delta)(newReferencePoint, referencePoint));
}

/**
 * Generates the nearest point (reference point) for a given point
 * onto given set of lines
 *
 * @param {Array<Point, Point>} lines
 * @param {Point} point
 *
 * @param {Point}
 */
function getReferencePoint(point, lines) {

  if (!lines.length) {
    return;
  }

  var nearestLine = getNearestLine(point, lines);

  return (0,_util_GeometricUtil__WEBPACK_IMPORTED_MODULE_10__.perpendicularFoot)(point, nearestLine);
}

/**
 * Convert the given bounds to a lines array containing all edges
 *
 * @param {Bounds|Point} bounds
 *
 * @return Array<Point>
 */
function asEdges(bounds) {
  return [
    [ // top
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      }
    ],
    [ // right
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [ // bottom
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [ // left
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      }
    ]
  ];
}

/**
 * Returns the nearest line for a given point by distance
 * @param {Point} point
 * @param Array<Point> lines
 *
 * @return Array<Point>
 */
function getNearestLine(point, lines) {

  var distances = lines.map(function(l) {
    return {
      line: l,
      distance: (0,_util_GeometricUtil__WEBPACK_IMPORTED_MODULE_10__.getDistancePointLine)(point, l)
    };
  });

  var sorted = (0,min_dash__WEBPACK_IMPORTED_MODULE_5__.sortBy)(distances, 'distance');

  return sorted[0].line;
}


/***/ }),

/***/ "./lib/features/modeling/behavior/ReplaceElementBehaviour.js":
/*!*******************************************************************!*\
  !*** ./lib/features/modeling/behavior/ReplaceElementBehaviour.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReplaceElementBehaviour)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");







/**
 * postit-specific replace behavior.
 */
function ReplaceElementBehaviour(
    postitReplace,
    postitRules,
    elementRegistry,
    injector,
    modeling,
    selection
) {
  injector.invoke(diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default, this);

  this._postitReplace = postitReplace;
  this._elementRegistry = elementRegistry;
  this._selection = selection;

  // replace elements on move
  this.postExecuted([ 'elements.move' ], 500, function(event) {
    var context = event.context,
        target = context.newParent,
        newHost = context.newHost,
        elements = [];

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(context.closure.topLevel, function(topLevelElements) {
      elements = elements.concat(topLevelElements);
    });

    // set target to host if attaching
    if (elements.length === 1 && newHost) {
      target = newHost;
    }

    var canReplace = postitRules.canReplace(elements, target);

    if (canReplace) {
      this.replaceElements(elements, canReplace.replacements, newHost);
    }
  }, this);

  // update attachments on host replace
  this.postExecute([ 'shape.replace' ], 1500, function(e) {
    var context = e.context,
        oldShape = context.oldShape,
        newShape = context.newShape,
        attachers = oldShape.attachers,
        canReplace;

    if (attachers && attachers.length) {
      canReplace = postitRules.canReplace(attachers, newShape);

      this.replaceElements(attachers, canReplace.replacements);
    }

  }, this);

  // keep ID on shape replace
  this.postExecuted([ 'shape.replace' ], 1500, function(e) {
    var context = e.context,
        oldShape = context.oldShape,
        newShape = context.newShape;

    modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);
    modeling.updateProperties(newShape, { id: oldShape.id });
  });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(ReplaceElementBehaviour, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

ReplaceElementBehaviour.prototype.replaceElements = function(elements, newElements) {
  var elementRegistry = this._elementRegistry,
      postitReplace = this._postitReplace,
      selection = this._selection;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(newElements, function(replacement) {
    var newElement = {
      type: replacement.newElementType
    };

    var oldElement = elementRegistry.get(replacement.oldElementId);

    var idx = elements.indexOf(oldElement);

    elements[idx] = postitReplace.replaceElement(oldElement, newElement, { select: false });
  });

  if (newElements) {
    selection.select(elements);
  }
};

ReplaceElementBehaviour.$inject = [
  'postitReplace',
  'postitRules',
  'elementRegistry',
  'injector',
  'modeling',
  'selection'
];


/***/ }),

/***/ "./lib/features/modeling/behavior/UnclaimIdBehavior.js":
/*!*************************************************************!*\
  !*** ./lib/features/modeling/behavior/UnclaimIdBehavior.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UnclaimIdBehavior)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/LabelUtil */ "./lib/util/LabelUtil.js");







/**
 * Unclaims model IDs on element deletion.
 *
 * @param {Canvas} canvas
 * @param {Injector} injector
 * @param {Moddle} moddle
 * @param {Modeling} modeling
 */
function UnclaimIdBehavior(canvas, injector, moddle, modeling) {
  injector.invoke(diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default, this);

  this.preExecute('shape.delete', function(event) {
    var context = event.context,
        shape = context.shape,
        shapeBo = shape.businessObject;

    if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_2__.isLabel)(shape)) {
      return;
    }

    modeling.unclaimId(shapeBo.id, shapeBo);
  });

  this.preExecute('canvas.updateRoot', function() {
    var rootElement = canvas.getRootElement(),
        rootElementBo = rootElement.businessObject;

    moddle.ids.unclaim(rootElementBo.id);
  });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(UnclaimIdBehavior, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

UnclaimIdBehavior.$inject = [ 'canvas', 'injector', 'moddle', 'modeling' ];

/***/ }),

/***/ "./lib/features/modeling/behavior/index.js":
/*!*************************************************!*\
  !*** ./lib/features/modeling/behavior/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AdaptiveLabelPositioningBehavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AdaptiveLabelPositioningBehavior */ "./lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js");
/* harmony import */ var _AppendBehavior__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AppendBehavior */ "./lib/features/modeling/behavior/AppendBehavior.js");
/* harmony import */ var _FixHoverBehavior__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FixHoverBehavior */ "./lib/features/modeling/behavior/FixHoverBehavior.js");
/* harmony import */ var _ImportDockingFix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ImportDockingFix */ "./lib/features/modeling/behavior/ImportDockingFix.js");
/* harmony import */ var _LabelBehavior__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LabelBehavior */ "./lib/features/modeling/behavior/LabelBehavior.js");
/* harmony import */ var _ReplaceElementBehaviour__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ReplaceElementBehaviour */ "./lib/features/modeling/behavior/ReplaceElementBehaviour.js");
/* harmony import */ var _UnclaimIdBehavior__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UnclaimIdBehavior */ "./lib/features/modeling/behavior/UnclaimIdBehavior.js");
/* harmony import */ var _CreateBoardElementBehavior__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CreateBoardElementBehavior */ "./lib/features/modeling/behavior/CreateBoardElementBehavior.js");
/* harmony import */ var _EmptyTextBoxBehavior__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EmptyTextBoxBehavior */ "./lib/features/modeling/behavior/EmptyTextBoxBehavior.js");










/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [
    'adaptiveLabelPositioningBehavior',
    'appendBehavior',
    'fixHoverBehavior',
    'importDockingFix',
    'labelBehavior',
    'replaceElementBehaviour',
    'unclaimIdBehavior',
    'createBoardElementBehavior',
    'emptyTextBoxBehavior'
  ],
  adaptiveLabelPositioningBehavior: [ 'type', _AdaptiveLabelPositioningBehavior__WEBPACK_IMPORTED_MODULE_0__.default ],
  appendBehavior: [ 'type', _AppendBehavior__WEBPACK_IMPORTED_MODULE_1__.default ],
  fixHoverBehavior: [ 'type', _FixHoverBehavior__WEBPACK_IMPORTED_MODULE_2__.default ],
  importDockingFix: [ 'type', _ImportDockingFix__WEBPACK_IMPORTED_MODULE_3__.default ],
  labelBehavior: [ 'type', _LabelBehavior__WEBPACK_IMPORTED_MODULE_4__.default ],
  replaceElementBehaviour: [ 'type', _ReplaceElementBehaviour__WEBPACK_IMPORTED_MODULE_5__.default ],
  unclaimIdBehavior: [ 'type', _UnclaimIdBehavior__WEBPACK_IMPORTED_MODULE_6__.default ],
  createBoardElementBehavior: [ 'type', _CreateBoardElementBehavior__WEBPACK_IMPORTED_MODULE_7__.default ],
  emptyTextBoxBehavior: [ 'type', _EmptyTextBoxBehavior__WEBPACK_IMPORTED_MODULE_8__.default ]
});


/***/ }),

/***/ "./lib/features/modeling/behavior/util/GeometricUtil.js":
/*!**************************************************************!*\
  !*** ./lib/features/modeling/behavior/util/GeometricUtil.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "vectorLength": () => (/* binding */ vectorLength),
/* harmony export */   "getAngle": () => (/* binding */ getAngle),
/* harmony export */   "rotateVector": () => (/* binding */ rotateVector),
/* harmony export */   "perpendicularFoot": () => (/* binding */ perpendicularFoot),
/* harmony export */   "getDistancePointLine": () => (/* binding */ getDistancePointLine),
/* harmony export */   "getDistancePointPoint": () => (/* binding */ getDistancePointPoint)
/* harmony export */ });
/**
 * Returns the length of a vector
 *
 * @param {Vector}
 * @return {Float}
 */
function vectorLength(v) {
  return Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));
}


/**
 * Calculates the angle between a line a the yAxis
 *
 * @param {Array}
 * @return {Float}
 */
function getAngle(line) {

  // return value is between 0, 180 and -180, -0
  // @janstuemmel: maybe replace return a/b with b/a
  return Math.atan((line[1].y - line[0].y) / (line[1].x - line[0].x));
}


/**
 * Rotates a vector by a given angle
 *
 * @param {Vector}
 * @param {Float} Angle in radians
 * @return {Vector}
 */
function rotateVector(vector, angle) {
  return (!angle) ? vector : {
    x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,
    y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y
  };
}


/**
 * Solves a 2D equation system
 * a + r*b = c, where a,b,c are 2D vectors
 *
 * @param {Vector}
 * @param {Vector}
 * @param {Vector}
 * @return {Float}
 */
function solveLambaSystem(a, b, c) {

  // the 2d system
  var system = [
    { n: a[0] - c[0], lambda: b[0] },
    { n: a[1] - c[1], lambda: b[1] }
  ];

  // solve
  var n = system[0].n * b[0] + system[1].n * b[1],
      l = system[0].lambda * b[0] + system[1].lambda * b[1];

  return -n/l;
}


/**
 * Position of perpendicular foot
 *
 * @param {Point}
 * @param [ {Point}, {Point} ] line defined through two points
 * @return {Point} the perpendicular foot position
 */
function perpendicularFoot(point, line) {

  var a = line[0], b = line[1];

  // relative position of b from a
  var bd = { x: b.x - a.x, y: b.y - a.y };

  // solve equation system to the parametrized vectors param real value
  var r = solveLambaSystem([ a.x, a.y ], [ bd.x, bd.y ], [ point.x, point.y ]);

  return { x: a.x + r*bd.x, y: a.y + r*bd.y };
}


/**
 * Calculates the distance between a point and a line
 *
 * @param {Point}
 * @param [ {Point}, {Point} ] line defined through two points
 * @return {Float} distance
 */
function getDistancePointLine(point, line) {

  var pfPoint = perpendicularFoot(point, line);

  // distance vector
  var connectionVector = {
    x: pfPoint.x - point.x,
    y: pfPoint.y - point.y
  };

  return vectorLength(connectionVector);
}


/**
 * Calculates the distance between two points
 *
 * @param {Point}
 * @param {Point}
 * @return {Float} distance
 */
function getDistancePointPoint(point1, point2) {

  return vectorLength({
    x: point1.x - point2.x,
    y: point1.y - point2.y
  });
}

/***/ }),

/***/ "./lib/features/modeling/behavior/util/LabelLayoutUtil.js":
/*!****************************************************************!*\
  !*** ./lib/features/modeling/behavior/util/LabelLayoutUtil.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "findNewLabelLineStartIndex": () => (/* binding */ findNewLabelLineStartIndex),
/* harmony export */   "getLabelAdjustment": () => (/* binding */ getLabelAdjustment)
/* harmony export */ });
/* harmony import */ var _GeometricUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometricUtil */ "./lib/features/modeling/behavior/util/GeometricUtil.js");
/* harmony import */ var _LineAttachmentUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineAttachmentUtil */ "./lib/features/modeling/behavior/util/LineAttachmentUtil.js");
/* harmony import */ var diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");







function findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {

  var index = attachment.segmentIndex;

  var offset = newWaypoints.length - oldWaypoints.length;

  // segmentMove happened
  if (hints.segmentMove) {

    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,
        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;

    // if label was on moved segment return new segment index
    if (index === oldSegmentStartIndex) {
      return newSegmentStartIndex;
    }

    // label is after new segment index
    if (index >= newSegmentStartIndex) {
      return (index+offset < newSegmentStartIndex) ? newSegmentStartIndex : index+offset;
    }

    // if label is before new segment index
    return index;
  }

  // bendpointMove happened
  if (hints.bendpointMove) {

    var insert = hints.bendpointMove.insert,
        bendpointIndex = hints.bendpointMove.bendpointIndex,
        newIndex;

    // waypoints length didnt change
    if (offset === 0) {
      return index;
    }

    // label behind new/removed bendpoint
    if (index >= bendpointIndex) {
      newIndex = insert ? index + 1 : index - 1;
    }

    // label before new/removed bendpoint
    if (index < bendpointIndex) {

      newIndex = index;

      // decide label should take right or left segment
      if (insert && attachment.type !== 'bendpoint' && bendpointIndex-1 === index) {

        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);

        if (rel < attachment.relativeLocation) {
          newIndex++;
        }
      }
    }

    return newIndex;
  }

  // start/end changed
  if (offset === 0) {
    return index;
  }

  if (hints.connectionStart) {
    return (index === 0) ? 0 : null;
  }

  if (hints.connectionEnd) {
    return (index === oldWaypoints.length - 2) ? newWaypoints.length - 2 : null;
  }

  // if nothing fits, return null
  return null;
}


/**
 * Calculate the required adjustment (move delta) for the given label
 * after the connection waypoints got updated.
 *
 * @param {djs.model.Label} label
 * @param {Array<Point>} newWaypoints
 * @param {Array<Point>} oldWaypoints
 * @param {Object} hints
 *
 * @return {Point} delta
 */
function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {

  var x = 0,
      y = 0;

  var labelPosition = getLabelMid(label);

  // get closest attachment
  var attachment = (0,_LineAttachmentUtil__WEBPACK_IMPORTED_MODULE_0__.getAttachment)(labelPosition, oldWaypoints),
      oldLabelLineIndex = attachment.segmentIndex,
      newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);

  if (newLabelLineIndex === null) {
    return { x: x, y: y };
  }

  // should never happen
  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored
  if (newLabelLineIndex < 0 ||
      newLabelLineIndex > newWaypoints.length - 2) {
    return { x: x, y: y };
  }

  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),
      newLabelLine = getLine(newWaypoints, newLabelLineIndex),
      oldFoot = attachment.position;

  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),
      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);

  // special rule if label on bendpoint
  if (attachment.type === 'bendpoint') {

    var offset = newWaypoints.length - oldWaypoints.length,
        oldBendpointIndex = attachment.bendpointIndex,
        oldBendpoint = oldWaypoints[oldBendpointIndex];

    // bendpoint position hasn't changed, return same position
    if (newWaypoints.indexOf(oldBendpoint) !== -1) {
      return { x: x, y: y };
    }

    // new bendpoint and old bendpoint have same index, then just return the offset
    if (offset === 0) {
      var newBendpoint = newWaypoints[oldBendpointIndex];

      return {
        x: newBendpoint.x - attachment.position.x,
        y: newBendpoint.y - attachment.position.y
      };
    }

    // if bendpoints get removed
    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {
      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);
    }
  }

  var newFoot = {
    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,
    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y
  };

  // the rotated vector to label
  var newLabelVector = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.rotateVector)({
    x: labelPosition.x - oldFoot.x,
    y: labelPosition.y - oldFoot.y
  }, angleDelta);

  // the new relative position
  x = newFoot.x + newLabelVector.x - labelPosition.x;
  y = newFoot.y + newLabelVector.y - labelPosition.y;

  return (0,diagram_js_lib_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_2__.roundPoint)({
    x: x,
    y: y
  });
}


// HELPERS //////////////////////

function relativePositionMidWaypoint(waypoints, idx) {

  var distanceSegment1 = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getDistancePointPoint)(waypoints[idx-1], waypoints[idx]),
      distanceSegment2 = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getDistancePointPoint)(waypoints[idx], waypoints[idx+1]);

  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);

  return relativePosition;
}

function getLabelMid(label) {
  return {
    x: label.x + label.width / 2,
    y: label.y + label.height / 2
  };
}

function getAngleDelta(l1, l2) {
  var a1 = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getAngle)(l1),
      a2 = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getAngle)(l2);
  return a2 - a1;
}

function getLine(waypoints, idx) {
  return [ waypoints[idx], waypoints[idx+1] ];
}

function getRelativeFootPosition(line, foot) {

  var length = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getDistancePointPoint)(line[0], line[1]),
      lengthToFoot = (0,_GeometricUtil__WEBPACK_IMPORTED_MODULE_1__.getDistancePointPoint)(line[0], foot);

  return length === 0 ? 0 : lengthToFoot / length;
}


/***/ }),

/***/ "./lib/features/modeling/behavior/util/LineAttachmentUtil.js":
/*!*******************************************************************!*\
  !*** ./lib/features/modeling/behavior/util/LineAttachmentUtil.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAttachment": () => (/* binding */ getAttachment)
/* harmony export */ });
var sqrt = Math.sqrt,
    min = Math.min,
    max = Math.max,
    abs = Math.abs;

/**
 * Calculate the square (power to two) of a number.
 *
 * @param {Number} n
 *
 * @return {Number}
 */
function sq(n) {
  return Math.pow(n, 2);
}

/**
 * Get distance between two points.
 *
 * @param {Point} p1
 * @param {Point} p2
 *
 * @return {Number}
 */
function getDistance(p1, p2) {
  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));
}

/**
 * Return the attachment of the given point on the specified line.
 *
 * The attachment is either a bendpoint (attached to the given point)
 * or segment (attached to a location on a line segment) attachment:
 *
 * ```javascript
 * var pointAttachment = {
 *   type: 'bendpoint',
 *   bendpointIndex: 3,
 *   position: { x: 10, y: 10 } // the attach point on the line
 * };
 *
 * var segmentAttachment = {
 *   type: 'segment',
 *   segmentIndex: 2,
 *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)
 *   position: { x: 10, y: 10 } // the attach point on the line
 * };
 * ```
 *
 * @param {Point} point
 * @param {Array<Point>} line
 *
 * @return {Object} attachment
 */
function getAttachment(point, line) {

  var idx = 0,
      segmentStart,
      segmentEnd,
      segmentStartDistance,
      segmentEndDistance,
      attachmentPosition,
      minDistance,
      intersections,
      attachment,
      attachmentDistance,
      closestAttachmentDistance,
      closestAttachment;

  for (idx = 0; idx < line.length - 1; idx++) {

    segmentStart = line[idx];
    segmentEnd = line[idx + 1];

    if (pointsEqual(segmentStart, segmentEnd)) {
      intersections = [ segmentStart ];
    } else {
      segmentStartDistance = getDistance(point, segmentStart);
      segmentEndDistance = getDistance(point, segmentEnd);

      minDistance = min(segmentStartDistance, segmentEndDistance);

      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);
    }

    if (intersections.length < 1) {
      throw new Error('expected between [1, 2] circle -> line intersections');
    }

    // one intersection -> bendpoint attachment
    if (intersections.length === 1) {
      attachment = {
        type: 'bendpoint',
        position: intersections[0],
        segmentIndex: idx,
        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1
      };
    }

    // two intersections -> segment attachment
    if (intersections.length === 2) {

      attachmentPosition = mid(intersections[0], intersections[1]);

      attachment = {
        type: 'segment',
        position: attachmentPosition,
        segmentIndex: idx,
        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)
      };
    }

    attachmentDistance = getDistance(attachment.position, point);

    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {
      closestAttachment = attachment;
      closestAttachmentDistance = attachmentDistance;
    }
  }

  return closestAttachment;
}

/**
 * Gets the intersection between a circle and a line segment.
 *
 * @param {Point} s1 segment start
 * @param {Point} s2 segment end
 * @param {Point} cc circle center
 * @param {Number} cr circle radius
 *
 * @return {Array<Point>} intersections
 */
function getCircleSegmentIntersections(s1, s2, cc, cr) {

  var baX = s2.x - s1.x;
  var baY = s2.y - s1.y;
  var caX = cc.x - s1.x;
  var caY = cc.y - s1.y;

  var a = baX * baX + baY * baY;
  var bBy2 = baX * caX + baY * caY;
  var c = caX * caX + caY * caY - cr * cr;

  var pBy2 = bBy2 / a;
  var q = c / a;

  var disc = pBy2 * pBy2 - q;

  // check against negative value to work around
  // negative, very close to zero results (-4e-15)
  // being produced in some environments
  if (disc < 0 && disc > -0.000001) {
    disc = 0;
  }

  if (disc < 0) {
    return [];
  }

  // if disc == 0 ... dealt with later
  var tmpSqrt = sqrt(disc);
  var abScalingFactor1 = -pBy2 + tmpSqrt;
  var abScalingFactor2 = -pBy2 - tmpSqrt;

  var i1 = {
    x: s1.x - baX * abScalingFactor1,
    y: s1.y - baY * abScalingFactor1
  };

  if (disc === 0) { // abScalingFactor1 == abScalingFactor2
    return [ i1 ];
  }

  var i2 = {
    x: s1.x - baX * abScalingFactor2,
    y: s1.y - baY * abScalingFactor2
  };

  // return only points on line segment
  return [ i1, i2 ].filter(function(p) {
    return isPointInSegment(p, s1, s2);
  });
}


function isPointInSegment(p, segmentStart, segmentEnd) {
  return (
    fenced(p.x, segmentStart.x, segmentEnd.x) &&
    fenced(p.y, segmentStart.y, segmentEnd.y)
  );
}

function fenced(n, rangeStart, rangeEnd) {

  // use matching threshold to work around
  // precision errors in intersection computation

  return (
    n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD &&
    n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD
  );
}

/**
 * Calculate mid of two points.
 *
 * @param {Point} p1
 * @param {Point} p2
 *
 * @return {Point}
 */
function mid(p1, p2) {

  return {
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2
  };
}

var EQUAL_THRESHOLD = 0.1;

function pointsEqual(p1, p2) {

  return (
    abs(p1.x - p2.x) <= EQUAL_THRESHOLD &&
    abs(p1.y - p2.y) <= EQUAL_THRESHOLD
  );
}


/***/ }),

/***/ "./lib/features/modeling/behavior/util/LineIntersect.js":
/*!**************************************************************!*\
  !*** ./lib/features/modeling/behavior/util/LineIntersect.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lineIntersect)
/* harmony export */ });
/**
 * Returns the intersection between two line segments a and b.
 *
 * @param {Point} l1s
 * @param {Point} l1e
 * @param {Point} l2s
 * @param {Point} l2e
 *
 * @return {Point}
 */
function lineIntersect(l1s, l1e, l2s, l2e) {

  // if the lines intersect, the result contains the x and y of the
  // intersection (treating the lines as infinite) and booleans for
  // whether line segment 1 or line segment 2 contain the point
  var denominator, a, b, c, numerator;

  denominator = ((l2e.y - l2s.y) * (l1e.x - l1s.x)) - ((l2e.x - l2s.x) * (l1e.y - l1s.y));

  if (denominator == 0) {
    return null;
  }

  a = l1s.y - l2s.y;
  b = l1s.x - l2s.x;
  numerator = ((l2e.x - l2s.x) * a) - ((l2e.y - l2s.y) * b);

  c = numerator / denominator;

  // if we cast these lines infinitely in
  // both directions, they intersect here
  return {
    x: Math.round(l1s.x + (c * (l1e.x - l1s.x))),
    y: Math.round(l1s.y + (c * (l1e.y - l1s.y)))
  };
}

/***/ }),

/***/ "./lib/features/modeling/cmd/IdClaimHandler.js":
/*!*****************************************************!*\
  !*** ./lib/features/modeling/cmd/IdClaimHandler.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IdClaimHandler)
/* harmony export */ });
function IdClaimHandler(moddle) {
  this._moddle = moddle;
}

IdClaimHandler.$inject = [ 'moddle' ];


IdClaimHandler.prototype.execute = function(context) {
  var ids = this._moddle.ids,
      id = context.id,
      element = context.element,
      claiming = context.claiming;

  if (claiming) {
    ids.claim(id, element);
  } else {
    ids.unclaim(id);
  }
};

/**
 * Command revert implementation.
 */
IdClaimHandler.prototype.revert = function(context) {
  var ids = this._moddle.ids,
      id = context.id,
      element = context.element,
      claiming = context.claiming;

  if (claiming) {
    ids.unclaim(id);
  } else {
    ids.claim(id, element);
  }
};



/***/ }),

/***/ "./lib/features/modeling/cmd/SetColorHandler.js":
/*!******************************************************!*\
  !*** ./lib/features/modeling/cmd/SetColorHandler.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SetColorHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ColorUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/ColorUtil */ "./lib/util/ColorUtil.js");





var DEFAULT_COLOR = _util_ColorUtil__WEBPACK_IMPORTED_MODULE_0__.default.YELLOW;


function SetColorHandler(commandStack) {
  this._commandStack = commandStack;
}

SetColorHandler.$inject = [
  'commandStack'
];


SetColorHandler.prototype.postExecute = function(context) {
  var elements = context.elements,
      color = context.color || DEFAULT_COLOR;

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(elements, function(element) {

    self._commandStack.execute('element.updateProperties', {
      element: element,
      properties: {
        color: color
      }
    });
  });

};


/***/ }),

/***/ "./lib/features/modeling/cmd/UpdateCanvasRootHandler.js":
/*!**************************************************************!*\
  !*** ./lib/features/modeling/cmd/UpdateCanvasRootHandler.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpdateCanvasRootHandler)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");



function UpdateCanvasRootHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}

UpdateCanvasRootHandler.$inject = [
  'canvas',
  'modeling'
];


UpdateCanvasRootHandler.prototype.execute = function(context) {

  var canvas = this._canvas;

  var newRoot = context.newRoot,
      newRootBusinessObject = newRoot.businessObject,
      oldRoot = canvas.getRootElement(),
      oldRootBusinessObject = oldRoot.businessObject,
      postitDefinitions = oldRootBusinessObject.$parent,
      diPlane = oldRootBusinessObject.di;

  // (1) replace process old <> new root
  canvas.setRootElement(newRoot, true);

  // (2) update root elements
  (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(postitDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = postitDefinitions;

  (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_0__.remove)(postitDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = null;

  // (3) wire di
  oldRootBusinessObject.di = null;

  diPlane.boardElement = newRootBusinessObject;
  newRootBusinessObject.di = diPlane;

  context.oldRoot = oldRoot;

  // TODO(nikku): return changed elements?
  // return [ newRoot, oldRoot ];
};


UpdateCanvasRootHandler.prototype.revert = function(context) {

  var canvas = this._canvas;

  var newRoot = context.newRoot,
      newRootBusinessObject = newRoot.businessObject,
      oldRoot = context.oldRoot,
      oldRootBusinessObject = oldRoot.businessObject,
      postitDefinitions = newRootBusinessObject.$parent,
      diPlane = newRootBusinessObject.di;

  // (1) replace process old <> new root
  canvas.setRootElement(oldRoot, true);

  // (2) update root elements
  (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_0__.remove)(postitDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = null;

  (0,diagram_js_lib_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(postitDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = postitDefinitions;

  // (3) wire di
  newRootBusinessObject.di = null;

  diPlane.boardElement = oldRootBusinessObject;
  oldRootBusinessObject.di = diPlane;

  // TODO(nikku): return changed elements?
  // return [ newRoot, oldRoot ];
};

/***/ }),

/***/ "./lib/features/modeling/cmd/UpdatePropertiesHandler.js":
/*!**************************************************************!*\
  !*** ./lib/features/modeling/cmd/UpdatePropertiesHandler.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpdatePropertiesHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");




var ID = 'id',
    DI = 'di';

var NULL_DIMENSIONS = {
  width: 0,
  height: 0
};

/**
 * A handler that implements a postit elements property update.
 *
 * This should be used to set simple properties on elements with
 * an underlying XML business object.
 *
 * Use respective diagram-js provided handlers if you would
 * like to perform automated modeling.
 */
function UpdatePropertiesHandler(
    elementRegistry, moddle, translate,
    modeling, textRenderer) {

  this._elementRegistry = elementRegistry;
  this._moddle = moddle;
  this._translate = translate;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
}

UpdatePropertiesHandler.$inject = [
  'elementRegistry',
  'moddle',
  'translate',
  'modeling',
  'textRenderer'
];


// api //////////////////////

/**
 * Updates a board element with a list of new properties
 *
 * @param {Object} context
 * @param {djs.model.Base} context.element the element to update
 * @param {Object} context.properties a list of properties to set on the element's
 *                                    businessObject (the XML model element)
 *
 * @return {Array<djs.model.Base>} the updated element
 */
UpdatePropertiesHandler.prototype.execute = function(context) {

  var element = context.element,
      changed = [ element ],
      translate = this._translate;

  if (!element) {
    throw new Error(translate('element required'));
  }

  var elementRegistry = this._elementRegistry,
      ids = this._moddle.ids;

  var businessObject = element.businessObject,
      properties = unwrapBusinessObjects(context.properties),
      oldProperties = context.oldProperties || getProperties(businessObject, properties);

  if (isIdChange(properties, businessObject)) {
    ids.unclaim(businessObject[ID]);

    elementRegistry.updateId(element, properties[ID]);

    ids.claim(properties[ID], businessObject);
  }

  // update properties
  setProperties(businessObject, properties);

  // store old values
  context.oldProperties = oldProperties;
  context.changed = changed;

  // indicate changed on objects affected by the update
  return changed;
};


UpdatePropertiesHandler.prototype.postExecute = function(context) {
  var element = context.element,
      label = element.label;

  var text = label && (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.getBusinessObject)(label).name;

  if (!text) {
    return;
  }

  // get layouted text bounds and resize external
  // external label accordingly
  var newLabelBounds = this._textRenderer.getExternalLabelBounds(label, text);

  this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS);
};

/**
 * Reverts the update on a board elements properties.
 *
 * @param  {Object} context
 *
 * @return {djs.model.Base} the updated element
 */
UpdatePropertiesHandler.prototype.revert = function(context) {

  var element = context.element,
      properties = context.properties,
      oldProperties = context.oldProperties,
      businessObject = element.businessObject,
      elementRegistry = this._elementRegistry,
      ids = this._moddle.ids;

  // update properties
  setProperties(businessObject, oldProperties);

  if (isIdChange(properties, businessObject)) {
    ids.unclaim(properties[ID]);

    elementRegistry.updateId(element, oldProperties[ID]);

    ids.claim(oldProperties[ID], businessObject);
  }

  return context.changed;
};


function isIdChange(properties, businessObject) {
  return ID in properties && properties[ID] !== businessObject[ID];
}


function getProperties(businessObject, properties) {
  var propertyNames = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.keys)(properties);

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.reduce)(propertyNames, function(result, key) {

    // handle DI separately
    if (key !== DI) {
      result[key] = businessObject.get(key);
    } else {
      result[key] = getDiProperties(businessObject.di, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.keys)(properties.di));
    }

    return result;
  }, {});
}


function getDiProperties(di, propertyNames) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.reduce)(propertyNames, function(result, key) {
    result[key] = di.get(key);

    return result;
  }, {});
}


function setProperties(businessObject, properties) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(properties, function(value, key) {

    if (key !== DI) {
      businessObject.set(key, value);
    } else {

      // only update, if businessObject.di exists
      if (businessObject.di) {
        setDiProperties(businessObject.di, value);
      }
    }
  });
}


function setDiProperties(di, properties) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(properties, function(value, key) {
    di.set(key, value);
  });
}


var referencePropertyNames = [ 'default' ];

/**
 * Make sure we unwrap the actual business object
 * behind diagram element that may have been
 * passed as arguments.
 *
 * @param  {Object} properties
 *
 * @return {Object} unwrappedProps
 */
function unwrapBusinessObjects(properties) {

  var unwrappedProps = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({}, properties);

  referencePropertyNames.forEach(function(name) {
    if (name in properties) {
      unwrappedProps[name] = (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.getBusinessObject)(unwrappedProps[name]);
    }
  });

  return unwrappedProps;
}

/***/ }),

/***/ "./lib/features/modeling/index.js":
/*!****************************************!*\
  !*** ./lib/features/modeling/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./behavior */ "./lib/features/modeling/behavior/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules */ "./lib/features/rules/index.js");
/* harmony import */ var _di_ordering__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../di-ordering */ "./lib/features/di-ordering/index.js");
/* harmony import */ var _ordering__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ordering */ "./lib/features/ordering/index.js");
/* harmony import */ var _replace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../replace */ "./lib/features/replace/index.js");
/* harmony import */ var diagram_js_lib_command__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! diagram-js/lib/command */ "./node_modules/diagram-js/lib/command/index.js");
/* harmony import */ var diagram_js_lib_features_tooltips__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! diagram-js/lib/features/tooltips */ "./node_modules/diagram-js/lib/features/tooltips/index.js");
/* harmony import */ var diagram_js_lib_features_label_support__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! diagram-js/lib/features/label-support */ "./node_modules/diagram-js/lib/features/label-support/index.js");
/* harmony import */ var diagram_js_lib_features_attach_support__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! diagram-js/lib/features/attach-support */ "./node_modules/diagram-js/lib/features/attach-support/index.js");
/* harmony import */ var diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! diagram-js/lib/features/selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var diagram_js_lib_features_change_support__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! diagram-js/lib/features/change-support */ "./node_modules/diagram-js/lib/features/change-support/index.js");
/* harmony import */ var diagram_js_lib_features_space_tool__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! diagram-js/lib/features/space-tool */ "./node_modules/diagram-js/lib/features/space-tool/index.js");
/* harmony import */ var _PostitFactory__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./PostitFactory */ "./lib/features/modeling/PostitFactory.js");
/* harmony import */ var _PostitUpdater__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./PostitUpdater */ "./lib/features/modeling/PostitUpdater.js");
/* harmony import */ var _ElementFactory__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ElementFactory */ "./lib/features/modeling/ElementFactory.js");
/* harmony import */ var _Modeling__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Modeling */ "./lib/features/modeling/Modeling.js");
/* harmony import */ var diagram_js_lib_layout_BaseLayouter__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! diagram-js/lib/layout/BaseLayouter */ "./node_modules/diagram-js/lib/layout/BaseLayouter.js");
/* harmony import */ var diagram_js_lib_layout_CroppingConnectionDocking__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! diagram-js/lib/layout/CroppingConnectionDocking */ "./node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js");






















/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [
    'modeling',
    'postitUpdater'
  ],
  __depends__: [
    _behavior__WEBPACK_IMPORTED_MODULE_0__.default,
    _rules__WEBPACK_IMPORTED_MODULE_1__.default,
    _di_ordering__WEBPACK_IMPORTED_MODULE_2__.default,
    _ordering__WEBPACK_IMPORTED_MODULE_3__.default,
    _replace__WEBPACK_IMPORTED_MODULE_4__.default,
    diagram_js_lib_command__WEBPACK_IMPORTED_MODULE_5__.default,
    diagram_js_lib_features_tooltips__WEBPACK_IMPORTED_MODULE_6__.default,
    diagram_js_lib_features_label_support__WEBPACK_IMPORTED_MODULE_7__.default,
    diagram_js_lib_features_attach_support__WEBPACK_IMPORTED_MODULE_8__.default,
    diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_9__.default,
    diagram_js_lib_features_change_support__WEBPACK_IMPORTED_MODULE_10__.default,
    diagram_js_lib_features_space_tool__WEBPACK_IMPORTED_MODULE_11__.default
  ],
  postitFactory: [ 'type', _PostitFactory__WEBPACK_IMPORTED_MODULE_12__.default ],
  postitUpdater: [ 'type', _PostitUpdater__WEBPACK_IMPORTED_MODULE_13__.default ],
  elementFactory: [ 'type', _ElementFactory__WEBPACK_IMPORTED_MODULE_14__.default ],
  modeling: [ 'type', _Modeling__WEBPACK_IMPORTED_MODULE_15__.default ],
  layouter: [ 'type', diagram_js_lib_layout_BaseLayouter__WEBPACK_IMPORTED_MODULE_16__.default ],
  connectionDocking: [ 'type', diagram_js_lib_layout_CroppingConnectionDocking__WEBPACK_IMPORTED_MODULE_17__.default ]
});

/***/ }),

/***/ "./lib/features/modeling/util/ModelingUtil.js":
/*!****************************************************!*\
  !*** ./lib/features/modeling/util/ModelingUtil.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isAny": () => (/* binding */ isAny),
/* harmony export */   "getParent": () => (/* binding */ getParent)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/ModelUtil */ "./lib/util/ModelUtil.js");





/**
 * Return true if element has any of the given types.
 *
 * @param {djs.model.Base} element
 * @param {Array<String>} types
 *
 * @return {Boolean}
 */
function isAny(element, types) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.some)(types, function(t) {
    return (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_1__.is)(element, t);
  });
}


/**
 * Return the parent of the element with any of the given types.
 *
 * @param {djs.model.Base} element
 * @param {String|Array<String>} anyType
 *
 * @return {djs.model.Base}
 */
function getParent(element, anyType) {

  if (typeof anyType === 'string') {
    anyType = [ anyType ];
  }

  while ((element = element.parent)) {
    if (isAny(element, anyType)) {
      return element;
    }
  }

  return null;
}

/***/ }),

/***/ "./lib/features/ordering/PostitOrderingProvider.js":
/*!*********************************************************!*\
  !*** ./lib/features/ordering/PostitOrderingProvider.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitOrderingProvider)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_features_ordering_OrderingProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/ordering/OrderingProvider */ "./node_modules/diagram-js/lib/features/ordering/OrderingProvider.js");
/* harmony import */ var _modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modeling/util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");









/**
 * a simple ordering provider that makes sure:
 *
 * (0) labels and groups are rendered always on top
 * (1) elements are ordered by a {level} property
 */
function PostitOrderingProvider(eventBus, canvas, translate) {

  diagram_js_lib_features_ordering_OrderingProvider__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  var orders = [
    { type: 'postit:BoardElement', order: { level: 5 } }
  ];

  function computeOrder(element) {
    if (element.labelTarget) {
      return { level: 10 };
    }

    var entry = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.find)(orders, function(o) {
      return (0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_3__.isAny)(element, [ o.type ]);
    });

    return entry && entry.order || { level: 1 };
  }

  function getOrder(element) {

    var order = element.order;

    if (!order) {
      element.order = order = computeOrder(element);
    }

    return order;
  }

  function findActualParent(element, newParent, containers) {

    var actualParent = newParent;

    while (actualParent) {

      if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_3__.isAny)(actualParent, containers)) {
        break;
      }

      actualParent = actualParent.parent;
    }

    if (!actualParent) {
      throw new Error(translate('no parent for {element} in {parent}', {
        element: element.id,
        parent: newParent.id
      }));
    }

    return actualParent;
  }

  this.getOrdering = function(element, newParent) {

    // render labels always on top
    if (element.labelTarget) {
      return {
        parent: canvas.getRootElement(),
        index: -1
      };
    }

    var elementOrder = getOrder(element);


    if (elementOrder.containers) {
      newParent = findActualParent(element, newParent, elementOrder.containers);
    }


    var currentIndex = newParent.children.indexOf(element);

    var insertIndex = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.findIndex)(newParent.children, function(child) {

      // do not compare with labels, they are created
      // in the wrong order (right after elements) during import and
      // mess up the positioning.
      if (!element.labelTarget && child.labelTarget) {
        return false;
      }

      return elementOrder.level < getOrder(child).level;
    });


    // if the element is already in the child list at
    // a smaller index, we need to adjust the insert index.
    // this takes into account that the element is being removed
    // before being re-inserted
    if (insertIndex !== -1) {
      if (currentIndex !== -1 && currentIndex < insertIndex) {
        insertIndex -= 1;
      }
    }

    return {
      index: insertIndex,
      parent: newParent
    };
  };
}

PostitOrderingProvider.$inject = [ 'eventBus', 'canvas', 'translate' ];

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitOrderingProvider, diagram_js_lib_features_ordering_OrderingProvider__WEBPACK_IMPORTED_MODULE_1__.default);

/***/ }),

/***/ "./lib/features/ordering/index.js":
/*!****************************************!*\
  !*** ./lib/features/ordering/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/i18n/translate */ "./node_modules/diagram-js/lib/i18n/translate/index.js");
/* harmony import */ var _PostitOrderingProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitOrderingProvider */ "./lib/features/ordering/PostitOrderingProvider.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'postitOrderingProvider' ],
  postitOrderingProvider: [ 'type', _PostitOrderingProvider__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./lib/features/palette/PaletteProvider.js":
/*!*************************************************!*\
  !*** ./lib/features/palette/PaletteProvider.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PaletteProvider)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ColorUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ColorUtil */ "./lib/util/ColorUtil.js");





/**
 * A palette provider for postit elements.
 */
function PaletteProvider(
    palette, create, elementFactory,
    spaceTool, lassoTool, handTool, translate) {

  this._palette = palette;
  this._create = create;
  this._elementFactory = elementFactory;
  this._spaceTool = spaceTool;
  this._lassoTool = lassoTool;
  this._handTool = handTool;
  this._translate = translate;

  palette.registerProvider(this);
}

PaletteProvider.$inject = [
  'palette',
  'create',
  'elementFactory',
  'spaceTool',
  'lassoTool',
  'handTool',
  'translate'
];


PaletteProvider.prototype.getPaletteEntries = function(element) {

  var actions = {},
      create = this._create,
      elementFactory = this._elementFactory,
      spaceTool = this._spaceTool,
      lassoTool = this._lassoTool,
      handTool = this._handTool,
      translate = this._translate;

  function createAction(type, group, className, title, options) {

    function createListener(event) {
      var shape = elementFactory.createShape((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({ type: type }, options));
      create.start(event, shape);
    }

    var shortType = type.replace(/^postit:/, '');

    return {
      group: group,
      className: className,
      title: title || translate('Create {type}', { type: shortType }),
      action: {
        dragstart: createListener,
        click: createListener
      }
    };
  }

  function createImage(event) {
    var shape = elementFactory.createShape({
      type: 'postit:Image'
    });

    create.start(event, shape, {
      hints: { selectImage: true }
    });
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(actions, {
    'hand-tool': {
      group: 'tools',
      className: 'bpmn-icon-hand-tool',
      title: translate('Activate the hand tool'),
      action: {
        click: function(event) {
          handTool.activateHand(event);
        }
      }
    },
    'lasso-tool': {
      group: 'tools',
      className: 'bpmn-icon-lasso-tool',
      title: translate('Activate the lasso tool'),
      action: {
        click: function(event) {
          lassoTool.activateSelection(event);
        }
      }
    },
    'space-tool': {
      group: 'tools',
      className: 'bpmn-icon-space-tool',
      title: translate('Activate the create/remove space tool'),
      action: {
        click: function(event) {
          spaceTool.activateSelection(event);
        }
      }
    },
    'tool-separator': {
      group: 'tools',
      separator: true
    },
    'create.square-postit': createAction(
      'postit:SquarePostit', 'postits', 'pjs-postit-square',
      translate('Create Square Postit'), { color: _util_ColorUtil__WEBPACK_IMPORTED_MODULE_1__.default.YELLOW }
    ),
    'create.circle-postit': createAction(
      'postit:CirclePostit', 'postits', 'pjs-postit-circle',
      translate('Create Circle Postit'), { color: _util_ColorUtil__WEBPACK_IMPORTED_MODULE_1__.default.PINK }
    ),
    'postit-separator': {
      group: 'postits',
      separator: true
    },
    'create.image': {
      group: 'artifact',
      className: 'pjs-image',
      title: translate('Create Image'),
      action: {
        click: createImage,
        dragstart: createImage
      }
    },
    'create.text-box': createAction(
      'postit:TextBox', 'artifact', 'pjs-text-box',
      translate('Create Text')
    ),
    'create.group': createAction(
      'postit:Group', 'artifact', 'pjs-group',
      translate('Create Group')
    )
  });

  return actions;
};


/***/ }),

/***/ "./lib/features/palette/index.js":
/*!***************************************!*\
  !*** ./lib/features/palette/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/palette */ "./node_modules/diagram-js/lib/features/palette/index.js");
/* harmony import */ var diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/create */ "./node_modules/diagram-js/lib/features/create/index.js");
/* harmony import */ var diagram_js_lib_features_space_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/features/space-tool */ "./node_modules/diagram-js/lib/features/space-tool/index.js");
/* harmony import */ var diagram_js_lib_features_lasso_tool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! diagram-js/lib/features/lasso-tool */ "./node_modules/diagram-js/lib/features/lasso-tool/index.js");
/* harmony import */ var diagram_js_lib_features_hand_tool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! diagram-js/lib/features/hand-tool */ "./node_modules/diagram-js/lib/features/hand-tool/index.js");
/* harmony import */ var diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! diagram-js/lib/i18n/translate */ "./node_modules/diagram-js/lib/i18n/translate/index.js");
/* harmony import */ var _PaletteProvider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PaletteProvider */ "./lib/features/palette/PaletteProvider.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_palette__WEBPACK_IMPORTED_MODULE_0__.default,
    diagram_js_lib_features_create__WEBPACK_IMPORTED_MODULE_1__.default,
    diagram_js_lib_features_space_tool__WEBPACK_IMPORTED_MODULE_2__.default,
    diagram_js_lib_features_lasso_tool__WEBPACK_IMPORTED_MODULE_3__.default,
    diagram_js_lib_features_hand_tool__WEBPACK_IMPORTED_MODULE_4__.default,
    diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_5__.default
  ],
  __init__: [ 'paletteProvider' ],
  paletteProvider: [ 'type', _PaletteProvider__WEBPACK_IMPORTED_MODULE_6__.default ]
});


/***/ }),

/***/ "./lib/features/popup-menu/ReplaceMenuProvider.js":
/*!********************************************************!*\
  !*** ./lib/features/popup-menu/ReplaceMenuProvider.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReplaceMenuProvider)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * This module is an element agnostic replace menu provider for the popup menu.
 */
function ReplaceMenuProvider(
    popupMenu, modeling, moddle,
    postitReplace, rules, translate) {

  this._popupMenu = popupMenu;
  this._modeling = modeling;
  this._moddle = moddle;
  this._postitReplace = postitReplace;
  this._rules = rules;
  this._translate = translate;

  this.register();
}

ReplaceMenuProvider.$inject = [
  'popupMenu',
  'modeling',
  'moddle',
  'postitReplace',
  'rules',
  'translate'
];


/**
 * Register replace menu provider in the popup menu
 */
ReplaceMenuProvider.prototype.register = function() {
  this._popupMenu.registerProvider('postit-replace', this);
};


/**
 * Get all entries from replaceOptions for the given element and apply filters
 * on them. Get for example only elements, which are different from the current one.
 *
 * @param {djs.model.Base} element
 *
 * @return {Array<Object>} a list of menu entry items
 */
ReplaceMenuProvider.prototype.getEntries = function(element) {

  var rules = this._rules;

  var entries = [];

  if (!rules.allowed('shape.replace', { element: element })) {
    return [];
  }

  return entries;
};


/**
 * Get a list of header items for the given element. This includes buttons
 * for multi instance markers and for the ad hoc marker.
 *
 * @param {djs.model.Base} element
 *
 * @return {Array<Object>} a list of menu entry items
 */
ReplaceMenuProvider.prototype.getHeaderEntries = function(element) {

  var headerEntries = [];

  return headerEntries;
};


/**
 * Creates an array of menu entry objects for a given element and filters the replaceOptions
 * according to a filter function.
 *
 * @param  {djs.model.Base} element
 * @param  {Object} replaceOptions
 *
 * @return {Array<Object>} a list of menu items
 */
ReplaceMenuProvider.prototype._createEntries = function(element, replaceOptions) {
  var menuEntries = [];

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(replaceOptions, function(definition) {
    var entry = self._createMenuEntry(definition, element);

    menuEntries.push(entry);
  });

  return menuEntries;
};


/**
 * Creates and returns a single menu entry item.
 *
 * @param  {Object} definition a single replace options definition object
 * @param  {djs.model.Base} element
 * @param  {Function} [action] an action callback function which gets called when
 *                             the menu entry is being triggered.
 *
 * @return {Object} menu entry item
 */
ReplaceMenuProvider.prototype._createMenuEntry = function(definition, element, action) {
  var translate = this._translate;
  var replaceElement = this._postitReplace.replaceElement;

  var replaceAction = function() {
    return replaceElement(element, definition.target);
  };

  action = action || replaceAction;

  var menuEntry = {
    label: translate(definition.label),
    className: definition.className,
    id: definition.actionName,
    action: action
  };

  return menuEntry;
};


/***/ }),

/***/ "./lib/features/popup-menu/index.js":
/*!******************************************!*\
  !*** ./lib/features/popup-menu/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_popup_menu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/popup-menu */ "./node_modules/diagram-js/lib/features/popup-menu/index.js");
/* harmony import */ var _replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../replace */ "./lib/features/replace/index.js");
/* harmony import */ var _ReplaceMenuProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReplaceMenuProvider */ "./lib/features/popup-menu/ReplaceMenuProvider.js");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_popup_menu__WEBPACK_IMPORTED_MODULE_0__.default,
    _replace__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [ 'replaceMenuProvider' ],
  replaceMenuProvider: [ 'type', _ReplaceMenuProvider__WEBPACK_IMPORTED_MODULE_2__.default ]
});

/***/ }),

/***/ "./lib/features/replace-preview/PostitReplacePreview.js":
/*!**************************************************************!*\
  !*** ./lib/features/replace-preview/PostitReplacePreview.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitReplacePreview)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var css_escape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! css.escape */ "./node_modules/css.escape/css.escape.js");
/* harmony import */ var css_escape__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(css_escape__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");












var LOW_PRIORITY = 250;


function PostitReplacePreview(
    eventBus, elementRegistry, elementFactory,
    canvas, previewSupport) {

  diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_2__.default.call(this, eventBus);

  /**
   * Replace the visuals of all elements in the context which can be replaced
   *
   * @param  {Object} context
   */
  function replaceVisual(context) {

    var replacements = context.canExecute.replacements;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(replacements, function(replacement) {

      var id = replacement.oldElementId;

      var newElement = {
        type: replacement.newElementType
      };

      // if the visual of the element is already replaced
      if (context.visualReplacements[id]) {
        return;
      }

      var element = elementRegistry.get(id);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)(newElement, { x: element.x, y: element.y });

      // create a temporary shape
      var tempShape = elementFactory.createShape(newElement);

      canvas.addShape(tempShape, element.parent);

      // select the original SVG element related to the element and hide it
      var gfx = (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.query)('[data-element-id="' + css_escape__WEBPACK_IMPORTED_MODULE_1___default()(element.id) + '"]', context.dragGroup);

      if (gfx) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_5__.attr)(gfx, { display: 'none' });
      }

      // clone the gfx of the temporary shape and add it to the drag group
      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);

      context.visualReplacements[id] = dragger;

      canvas.removeShape(tempShape);
    });
  }

  /**
   * Restore the original visuals of the previously replaced elements
   *
   * @param  {Object} context
   */
  function restoreVisual(context) {

    var visualReplacements = context.visualReplacements;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(visualReplacements, function(dragger, id) {

      var originalGfx = (0,min_dom__WEBPACK_IMPORTED_MODULE_4__.query)('[data-element-id="' + css_escape__WEBPACK_IMPORTED_MODULE_1___default()(id) + '"]', context.dragGroup);

      if (originalGfx) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_5__.attr)(originalGfx, { display: 'inline' });
      }

      dragger.remove();

      if (visualReplacements[id]) {
        delete visualReplacements[id];
      }
    });
  }

  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {

    var context = event.context,
        canExecute = context.canExecute;

    if (!context.visualReplacements) {
      context.visualReplacements = {};
    }

    if (canExecute && canExecute.replacements) {
      replaceVisual(context);
    } else {
      restoreVisual(context);
    }
  });
}

PostitReplacePreview.$inject = [
  'eventBus',
  'elementRegistry',
  'elementFactory',
  'canvas',
  'previewSupport'
];

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitReplacePreview, diagram_js_lib_command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_2__.default);

/***/ }),

/***/ "./lib/features/replace-preview/index.js":
/*!***********************************************!*\
  !*** ./lib/features/replace-preview/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_preview_support__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/preview-support */ "./node_modules/diagram-js/lib/features/preview-support/index.js");
/* harmony import */ var _PostitReplacePreview__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitReplacePreview */ "./lib/features/replace-preview/PostitReplacePreview.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_preview_support__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'postitReplacePreview' ],
  postitReplacePreview: [ 'type', _PostitReplacePreview__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./lib/features/replace/PostitReplace.js":
/*!***********************************************!*\
  !*** ./lib/features/replace/PostitReplace.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitReplace)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _copy_paste_ModdleCopy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../copy-paste/ModdleCopy */ "./lib/features/copy-paste/ModdleCopy.js");




function copyProperties(source, target, properties) {
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(properties)) {
    properties = [ properties ];
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(properties, function(property) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(source[property])) {
      target[property] = source[property];
    }
  });
}

var CUSTOM_PROPERTIES = [
  'cancelActivity',
  'instantiate',
  'eventGatewayType',
  'triggeredByEvent',
  'isInterrupting'
];



/**
 * This module takes care of replacing postit elements
 */
function PostitReplace(
    postitFactory,
    elementFactory,
    moddleCopy,
    modeling,
    replace,
    selection
) {

  /**
   * Prepares a new business object for the replacement element
   * and triggers the replace operation.
   *
   * @param  {djs.model.Base} element
   * @param  {Object} target
   * @param  {Object} [hints]
   *
   * @return {djs.model.Base} the newly created element
   */
  function replaceElement(element, target, hints) {

    hints = hints || {};

    var type = target.type,
        oldBusinessObject = element.businessObject;

    var newBusinessObject = postitFactory.create(type);

    var newElement = {
      type: type,
      businessObject: newBusinessObject
    };

    var elementProps = (0,_copy_paste_ModdleCopy__WEBPACK_IMPORTED_MODULE_1__.getPropertyNames)(oldBusinessObject.$descriptor),
        newElementProps = (0,_copy_paste_ModdleCopy__WEBPACK_IMPORTED_MODULE_1__.getPropertyNames)(newBusinessObject.$descriptor, true),
        copyProps = intersection(elementProps, newElementProps);

    // initialize special properties defined in target definition
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(newBusinessObject, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.pick)(target, CUSTOM_PROPERTIES));

    var properties = copyProps;

    newBusinessObject = moddleCopy.copyElement(
      oldBusinessObject,
      newBusinessObject,
      properties
    );

    newBusinessObject.name = oldBusinessObject.name;

    newElement.di = {};

    // fill and stroke will be set to DI
    copyProperties(oldBusinessObject.di, newElement.di, [
      'fill',
      'stroke'
    ]);

    newElement = replace.replaceElement(element, newElement, hints);

    if (hints.select !== false) {
      selection.select(newElement);
    }

    return newElement;
  }

  this.replaceElement = replaceElement;
}

PostitReplace.$inject = [
  'postitFactory',
  'elementFactory',
  'moddleCopy',
  'modeling',
  'replace',
  'selection'
];

/**
 * Compute intersection between two arrays.
 */
function intersection(a1, a2) {
  return a1.filter(function(el) {
    return a2.indexOf(el) !== -1;
  });
}


/***/ }),

/***/ "./lib/features/replace/index.js":
/*!***************************************!*\
  !*** ./lib/features/replace/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copy_paste__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../copy-paste */ "./lib/features/copy-paste/index.js");
/* harmony import */ var diagram_js_lib_features_replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/replace */ "./node_modules/diagram-js/lib/features/replace/index.js");
/* harmony import */ var diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! diagram-js/lib/features/selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _PostitReplace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PostitReplace */ "./lib/features/replace/PostitReplace.js");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _copy_paste__WEBPACK_IMPORTED_MODULE_0__.default,
    diagram_js_lib_features_replace__WEBPACK_IMPORTED_MODULE_1__.default,
    diagram_js_lib_features_selection__WEBPACK_IMPORTED_MODULE_2__.default
  ],
  postitReplace: [ 'type', _PostitReplace__WEBPACK_IMPORTED_MODULE_3__.default ]
});


/***/ }),

/***/ "./lib/features/rules/PostitRules.js":
/*!*******************************************!*\
  !*** ./lib/features/rules/PostitRules.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitRules)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/LabelUtil */ "./lib/util/LabelUtil.js");
/* harmony import */ var diagram_js_lib_features_rules_RuleProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/rules/RuleProvider */ "./node_modules/diagram-js/lib/features/rules/RuleProvider.js");
/* harmony import */ var _modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../modeling/util/ModelingUtil */ "./lib/features/modeling/util/ModelingUtil.js");












/**
 * Postit specific modeling rule
 */
function PostitRules(eventBus) {
  diagram_js_lib_features_rules_RuleProvider__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitRules, diagram_js_lib_features_rules_RuleProvider__WEBPACK_IMPORTED_MODULE_1__.default);

PostitRules.$inject = [ 'eventBus' ];

PostitRules.prototype.init = function() {

  this.addRule('shape.resize', function(context) {

    var shape = context.shape,
        newBounds = context.newBounds;

    return canResize(shape, newBounds);
  });

  this.addRule('elements.create', function(context) {
    var elements = context.elements,
        position = context.position,
        target = context.target;

    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.every)(elements, function(element) {
      if (element.host) {
        return canAttach(element, element.host, null, position);
      }

      return canCreate(element, target, null, position);
    });
  });

  this.addRule('elements.move', function(context) {

    var target = context.target,
        shapes = context.shapes,
        position = context.position;

    return canAttach(shapes, target, null, position) ||
           canMove(shapes, target, position);
  });

  this.addRule('shape.create', function(context) {
    return canCreate(
      context.shape,
      context.target,
      context.source,
      context.position
    );
  });

  this.addRule('shape.attach', function(context) {

    return canAttach(
      context.shape,
      context.target,
      null,
      context.position
    );
  });

  this.addRule('element.copy', function(context) {
    var element = context.element,
        elements = context.elements;

    return canCopy(elements, element);
  });
};

PostitRules.prototype.canMove = canMove;

PostitRules.prototype.canAttach = canAttach;

PostitRules.prototype.canDrop = canDrop;

PostitRules.prototype.canCreate = canCreate;

PostitRules.prototype.canReplace = canReplace;

PostitRules.prototype.canResize = canResize;

PostitRules.prototype.canCopy = canCopy;

/**
 * Utility functions for rule checking
 */

function isSame(a, b) {
  return a === b;
}

function getParents(element) {

  var parents = [];

  while (element) {
    element = element.parent;

    if (element) {
      parents.push(element);
    }
  }

  return parents;
}

function isParent(possibleParent, element) {
  var allParents = getParents(element);
  return allParents.indexOf(possibleParent) !== -1;
}

function isGroup(element) {
  return (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(element, 'postit:Group') && !element.labelTarget;
}

/**
 * Can an element be dropped into the target element
 *
 * @return {Boolean}
 */
function canDrop(element, target) {

  // can move labels
  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.isLabel)(element) || isGroup(element)) {
    return true;
  }

  // drop board elements onto boards
  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(element, 'postit:BoardElement') && (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(target, 'postit:PostitBoard')) {
    return true;
  }

  return false;
}

function canReplace(elements, target) {

  if (!target) {
    return false;
  }

  return true;
}


function canAttach(elements, target) {

  if (!Array.isArray(elements)) {
    elements = [ elements ];
  }

  // only (re-)attach one element at a time
  if (elements.length !== 1) {
    return false;
  }

  var element = elements[0];

  // do not attach labels
  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.isLabel)(element)) {
    return false;
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(target, 'postit:BoardElement')) {
    return false;
  }

  return 'attach';
}


function canMove(elements, target) {

  // allow default move check to start move operation
  if (!target) {
    return true;
  }

  return elements.every(function(element) {
    return canDrop(element, target);
  });
}

function canCreate(shape, target, source, position) {

  if (!target) {
    return false;
  }

  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.isLabel)(shape) || isGroup(shape)) {
    return true;
  }

  if (isSame(source, target)) {
    return false;
  }

  // ensure we do not drop the element
  // into source
  if (source && isParent(source, target)) {
    return false;
  }

  return canDrop(shape, target, position);
}

function canResize(shape, newBounds) {

  if ((0,_modeling_util_ModelingUtil__WEBPACK_IMPORTED_MODULE_5__.isAny)(shape, [ 'postit:Postit', 'postit:TextBox' ])) {
    return !newBounds || (newBounds.width >= 50 && newBounds.height >= 50);
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(shape, 'postit:Group')) {
    return true;
  }

  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_3__.is)(shape, 'postit:Image')) {
    return true;
  }

  return false;
}

function canCopy(elements, element) {
  return true;
}


/***/ }),

/***/ "./lib/features/rules/index.js":
/*!*************************************!*\
  !*** ./lib/features/rules/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_rules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _PostitRules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitRules */ "./lib/features/rules/PostitRules.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_rules__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'postitRules' ],
  postitRules: [ 'type', _PostitRules__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./lib/features/snapping/PostitCreateMoveSnapping.js":
/*!***********************************************************!*\
  !*** ./lib/features/snapping/PostitCreateMoveSnapping.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitCreateMoveSnapping)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/snapping/CreateMoveSnapping */ "./node_modules/diagram-js/lib/features/snapping/CreateMoveSnapping.js");




/**
 * Snap during create and move.
 *
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */
function PostitCreateMoveSnapping(injector) {
  injector.invoke(diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default, this);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(PostitCreateMoveSnapping, diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default);

PostitCreateMoveSnapping.$inject = [
  'injector'
];

PostitCreateMoveSnapping.prototype.initSnap = function(event) {
  return diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default.prototype.initSnap.call(this, event);
};

PostitCreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  return diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);
};

PostitCreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return diagram_js_lib_features_snapping_CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default.prototype.getSnapTargets.call(this, shape, target);
};


/***/ }),

/***/ "./lib/features/snapping/index.js":
/*!****************************************!*\
  !*** ./lib/features/snapping/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PostitCreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitCreateMoveSnapping */ "./lib/features/snapping/PostitCreateMoveSnapping.js");
/* harmony import */ var diagram_js_lib_features_snapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/features/snapping */ "./node_modules/diagram-js/lib/features/snapping/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [ diagram_js_lib_features_snapping__WEBPACK_IMPORTED_MODULE_0__.default ],
  __init__: [
    'createMoveSnapping'
  ],
  createMoveSnapping: [ 'type', _PostitCreateMoveSnapping__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./lib/import/Importer.js":
/*!********************************!*\
  !*** ./lib/import/Importer.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "importPostitDiagram": () => (/* binding */ importPostitDiagram)
/* harmony export */ });
/* harmony import */ var _PostitTreeWalker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PostitTreeWalker */ "./lib/import/PostitTreeWalker.js");


/**
 * The importPostitDiagram result.
 *
 * @typedef {Object} importPostitDiagramResult
 *
 * @property {Array<string>} warnings
 */

/**
* The importPostitDiagram error.
*
* @typedef {Error} importPostitDiagramError
*
* @property {Array<string>} warnings
*/

/**
 * Import the definitions into a diagram.
 *
 * Errors and warnings are reported through the specified callback.
 *
 * @param  {djs.Diagram} diagram
 * @param  {ModdleElement<Definitions>} definitions
 * @param  {ModdleElement<PotitRootBoard>} [rootBoard] the diagram to be rendered
 * (if not provided, the first one will be rendered)
 *
 * Returns {Promise<importPostitDiagramResult, importPostitDiagramError>}
 */
function importPostitDiagram(diagram, definitions, rootBoard) {

  var importer,
      eventBus,
      translate;

  var error,
      warnings = [];

  /**
   * Walk the diagram semantically, importing (=drawing)
   * all elements you encounter.
   *
   * @param {ModdleElement<Definitions>} definitions
   * @param {ModdleElement<PostitRootBoard>} rootBoard
   */
  function render(definitions, rootBoard) {

    var visitor = {

      root: function(element) {
        return importer.add(element);
      },

      element: function(element, parentShape) {
        return importer.add(element, parentShape);
      },

      error: function(message, context) {
        warnings.push({ message: message, context: context });
      }
    };

    var walker = new _PostitTreeWalker__WEBPACK_IMPORTED_MODULE_0__.default(visitor, translate);

    // traverse xml document model,
    // starting at definitions
    walker.handleDefinitions(definitions, rootBoard);
  }

  return new Promise(function(resolve, reject) {
    try {
      importer = diagram.get('postitImporter');
      eventBus = diagram.get('eventBus');
      translate = diagram.get('translate');

      eventBus.fire('import.render.start', { definitions: definitions });

      render(definitions, rootBoard);

      eventBus.fire('import.render.complete', {
        error: error,
        warnings: warnings
      });

      return resolve({ warnings: warnings });
    } catch (e) {
      return reject(e);
    }
  });
}

/***/ }),

/***/ "./lib/import/PostitImporter.js":
/*!**************************************!*\
  !*** ./lib/import/PostitImporter.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitImporter)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/ModelUtil */ "./lib/util/ModelUtil.js");
/* harmony import */ var _util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/LabelUtil */ "./lib/util/LabelUtil.js");
/* harmony import */ var _features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../features/label-editing/LabelUtil */ "./lib/features/label-editing/LabelUtil.js");
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Util */ "./lib/import/Util.js");











function elementData(semantic, attrs) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
    id: semantic.id,
    type: semantic.$type,
    businessObject: semantic
  }, attrs);
}

function notYetDrawn(translate, semantic, refSemantic, property) {
  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {
    element: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(refSemantic),
    referenced: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(semantic),
    property: property
  }));
}


/**
 * An importer that adds postit elements to the canvas
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {ElementFactory} elementFactory
 * @param {ElementRegistry} elementRegistry
 * @param {Function} translate
 * @param {TextRenderer} textRenderer
 */
function PostitImporter(
    eventBus, canvas, elementFactory,
    elementRegistry, translate, textRenderer) {

  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementFactory = elementFactory;
  this._elementRegistry = elementRegistry;
  this._translate = translate;
  this._textRenderer = textRenderer;
}

PostitImporter.$inject = [
  'eventBus',
  'canvas',
  'elementFactory',
  'elementRegistry',
  'translate',
  'textRenderer'
];


/**
 * Add postit element (semantic) to the canvas onto the
 * specified parent shape.
 */
PostitImporter.prototype.add = function(semantic, parentElement) {

  var di = semantic.di,
      element,
      translate = this._translate,
      hidden;

  var parentIndex;

  // ROOT ELEMENT
  // handle the special case that we deal with a
  // invisible root element
  if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(di, 'postitDi:PostitPlane')) {

    // add a virtual element (not being drawn)
    element = this._elementFactory.createRoot(elementData(semantic));

    this._canvas.setRootElement(element);
  }

  // SHAPE
  else if ((0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(di, 'postitDi:PostitShape')) {

    var isFrame = isFrameElement(semantic);

    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);

    var bounds = semantic.di.bounds;

    element = this._elementFactory.createShape(elementData(semantic, {
      hidden: hidden,
      x: Math.round(bounds.x),
      y: Math.round(bounds.y),
      width: Math.round(bounds.width),
      height: Math.round(bounds.height),
      isFrame: isFrame
    }));

    this._canvas.addShape(element, parentElement, parentIndex);
  }

  else {
    throw new Error(translate('unknown di {di} for element {semantic}', {
      di: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(di),
      semantic: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(semantic)
    }));
  }

  // (optional) LABEL
  if ((0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.isLabelExternal)(semantic) && (0,_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.getLabel)(element)) {
    this.addLabel(semantic, element);
  }


  this._eventBus.fire('boardElement.added', { element: element });

  return element;
};


/**
 * Attach the boundary element to the given host
 *
 * @param {ModdleElement} boundarySemantic
 * @param {djs.model.Base} boundaryElement
 */
PostitImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {
  var translate = this._translate;
  var hostSemantic = boundarySemantic.attachedToRef;

  if (!hostSemantic) {
    throw new Error(translate('missing {semantic}#attachedToRef', {
      semantic: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(boundarySemantic)
    }));
  }

  var host = this._elementRegistry.get(hostSemantic.id),
      attachers = host && host.attachers;

  if (!host) {
    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');
  }

  // wire element.host <> host.attachers
  boundaryElement.host = host;

  if (!attachers) {
    host.attachers = attachers = [];
  }

  if (attachers.indexOf(boundaryElement) === -1) {
    attachers.push(boundaryElement);
  }
};


/**
 * add label for an element
 */
PostitImporter.prototype.addLabel = function(semantic, element) {
  var bounds,
      text,
      label;

  bounds = (0,_util_LabelUtil__WEBPACK_IMPORTED_MODULE_3__.getExternalLabelBounds)(semantic, element);

  text = (0,_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.getLabel)(element);

  if (text) {

    // get corrected bounds from actual layouted text
    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);
  }

  label = this._elementFactory.createLabel(elementData(semantic, {
    id: semantic.id + '_label',
    labelTarget: element,
    type: 'label',
    hidden: element.hidden || !(0,_features_label_editing_LabelUtil__WEBPACK_IMPORTED_MODULE_4__.getLabel)(element),
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  }));

  return this._canvas.addShape(label, element.parent);
};

/**
 * Return the drawn connection end based on the given side.
 *
 * @throws {Error} if the end is not yet drawn
 */
PostitImporter.prototype._getEnd = function(semantic, side) {

  var element,
      refSemantic,
      translate = this._translate;

  refSemantic = semantic[side + 'Ref'];


  element = refSemantic && this._getElement(refSemantic);

  if (element) {
    return element;
  }

  if (refSemantic) {
    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');
  } else {
    throw new Error(translate('{semantic}#{side} Ref not specified', {
      semantic: (0,_Util__WEBPACK_IMPORTED_MODULE_1__.elementToString)(semantic),
      side: side
    }));
  }
};

PostitImporter.prototype._getSource = function(semantic) {
  return this._getEnd(semantic, 'source');
};

PostitImporter.prototype._getTarget = function(semantic) {
  return this._getEnd(semantic, 'target');
};


PostitImporter.prototype._getElement = function(semantic) {
  return this._elementRegistry.get(semantic.id);
};


// helpers //////////

function isFrameElement(semantic) {
  return (0,_util_ModelUtil__WEBPACK_IMPORTED_MODULE_2__.is)(semantic, 'postit:Group');
}

/***/ }),

/***/ "./lib/import/PostitTreeWalker.js":
/*!****************************************!*\
  !*** ./lib/import/PostitTreeWalker.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitTreeWalker)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! object-refs */ "./node_modules/object-refs/index.js");
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_refs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Util */ "./lib/import/Util.js");






var diRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_0___default())(
  { name: 'boardElement', enumerable: true },
  { name: 'di', configurable: true }
);

/**
 * Returns true if an element has the given meta-model type
 *
 * @param  {ModdleElement}  element
 * @param  {String}         type
 *
 * @return {Boolean}
 */
function is(element, type) {
  return element.$instanceOf(type);
}


/**
 * Find a suitable display candidate for definitions where the DI does not
 * correctly specify one.
 */
function findDisplayCandidate(definitions) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(definitions.rootElements, function(e) {
    return is(e, 'postit:PostitBoard');
  });
}


function PostitTreeWalker(handler, translate) {

  // list of containers already walked
  var handledElements = {};

  // list of elements to handle deferred to ensure
  // prerequisites are drawn
  var deferred = [];

  // Helpers //////////////////////

  function visitRoot(element, diagram) {
    return handler.root(element, diagram);
  }

  function visit(element, ctx) {

    var gfx = element.gfx;

    // avoid multiple rendering of elements
    if (gfx) {
      throw new Error(
        translate('already rendered {element}', { element: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(element) })
      );
    }

    // call handler
    return handler.element(element, ctx);
  }

  function visitIfDi(element, ctx) {

    try {
      var gfx = element.di && visit(element, ctx);

      handled(element);

      return gfx;
    } catch (e) {
      logError(e.message, { element: element, error: e });

      console.error(translate('failed to import {element}', { element: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(element) }));
      console.error(e);
    }
  }

  function logError(message, context) {
    handler.error(message, context);
  }

  function handled(element) {
    handledElements[element.id] = element;
  }

  // DI handling //////////////////////

  function registerDi(di) {
    var boardElement = di.boardElement;

    if (boardElement) {
      if (boardElement.di) {
        logError(
          translate('multiple DI elements defined for {element}', {
            element: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(boardElement)
          }),
          { element: boardElement }
        );
      } else {
        diRefs.bind(boardElement, 'di');
        boardElement.di = di;
      }
    } else {
      logError(
        translate('no boardElement referenced in {element}', {
          element: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(di)
        }),
        { element: di }
      );
    }
  }

  function handleBoard(diagram) {
    handlePlane(diagram.plane);
  }

  function handlePlane(plane) {
    registerDi(plane);

    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(plane.planeElement, handlePlaneElement);
  }

  function handlePlaneElement(planeElement) {
    registerDi(planeElement);
  }


  // Semantic handling //////////////////////

  /**
   * Handle definitions and return the rendered board (if any)
   *
   * @param {ModdleElement} definitions to walk and import
   * @param {ModdleElement} [rootBoard] specific board to import and display
   *
   * @throws {Error} if no diagram to display could be found
   */
  function handleDefinitions(definitions, rootBoard) {

    // make sure we walk the correct boardElement

    var rootBoards = definitions.rootBoards;

    if (rootBoard && rootBoards.indexOf(rootBoard) === -1) {
      throw new Error(translate('rootBoard not part of postit:Definitions'));
    }

    if (!rootBoard && rootBoards && rootBoards.length) {
      rootBoard = rootBoards[0];
    }

    // no root board -> nothing to import
    if (!rootBoard) {
      throw new Error(translate('no rootBoard to display'));
    }

    // load DI from selected root board only
    handleBoard(rootBoard);

    var plane = rootBoard.plane;

    if (!plane) {
      throw new Error(translate(
        'no plane for {element}',
        { element: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(rootBoard) }
      ));
    }

    var rootElement = plane.boardElement;

    // ensure we default to a suitable display candidate (board),
    // even if non is specified in DI
    if (!rootElement) {
      rootElement = findDisplayCandidate(definitions);

      if (!rootElement) {
        throw new Error(translate('no board to display'));
      } else {

        logError(
          translate('correcting missing boardElement on {plane} to {rootElement}', {
            plane: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(plane),
            rootElement: (0,_Util__WEBPACK_IMPORTED_MODULE_2__.elementToString)(rootElement)
          })
        );

        // correct DI on the fly
        plane.boardElement = rootElement;
        registerDi(plane);
      }
    }


    var ctx = visitRoot(rootElement, plane);

    if (is(rootElement, 'postit:PostitBoard')) {
      handlePostitBoard(rootElement, ctx);
    }

    // handle all deferred elements
    handleDeferred(deferred);
  }

  function handleBoardElements(boardElements, context) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(boardElements, function(element) {
      visitIfDi(element, context);
    });
  }

  function handlePostitBoard(board, context) {
    handleBoardElements(board.boardElements, context);

    // log board handled
    handled(board);
  }

  function handleDeferred() {

    var fn;

    // drain deferred until empty
    while (deferred.length) {
      fn = deferred.shift();

      fn();
    }
  }




  // API //////////////////////

  return {
    handleDeferred: handleDeferred,
    handleDefinitions: handleDefinitions,
    registerDi: registerDi
  };
}

/***/ }),

/***/ "./lib/import/Util.js":
/*!****************************!*\
  !*** ./lib/import/Util.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "elementToString": () => (/* binding */ elementToString)
/* harmony export */ });
function elementToString(e) {
  if (!e) {
    return '<null>';
  }

  return '<' + e.$type + (e.id ? ' id="' + e.id : '') + '" />';
}

/***/ }),

/***/ "./lib/import/index.js":
/*!*****************************!*\
  !*** ./lib/import/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diagram-js/lib/i18n/translate */ "./node_modules/diagram-js/lib/i18n/translate/index.js");
/* harmony import */ var _PostitImporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PostitImporter */ "./lib/import/PostitImporter.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_i18n_translate__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  postitImporter: [ 'type', _PostitImporter__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Modeler = __webpack_require__(/*! ./Modeler */ "./lib/Modeler.js");

module.exports = Modeler;


/***/ }),

/***/ "./lib/moddle/Moddle.js":
/*!******************************!*\
  !*** ./lib/moddle/Moddle.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostitModdle)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var moddle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moddle */ "./node_modules/moddle/dist/index.esm.js");
/* harmony import */ var moddle_xml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moddle-xml */ "./node_modules/moddle-xml/dist/index.esm.js");






/**
 * A sub class of {@link Moddle} with support for import and export of Postit-js xml files.
 *
 * @class PostitModdle
 *
 * @extends Moddle
 *
 * @param {Object|Array} packages to use for instantiating the model
 * @param {Object} [options] additional options to pass over
 */
function PostitModdle(packages, options) {
  moddle__WEBPACK_IMPORTED_MODULE_0__.Moddle.call(this, packages, options);
}

PostitModdle.prototype = Object.create(moddle__WEBPACK_IMPORTED_MODULE_0__.Moddle.prototype);

/**
 * The fromXML result.
 *
 * @typedef {Object} ParseResult
 *
 * @property {ModdleElement} rootElement
 * @property {Array<Object>} references
 * @property {Array<Error>} warnings
 * @property {Object} elementsById - a mapping containing each ID -> ModdleElement
 */

/**
 * The fromXML error.
 *
 * @typedef {Error} ParseError
 *
 * @property {Array<Error>} warnings
 */

/**
 * Instantiates a Postit model tree from a given xml string.
 *
 * @param {String}   xmlStr
 * @param {String}   [typeName='postit:Definitions'] name of the root element
 * @param {Object}   [options]  options to pass to the underlying reader
 *
 * @returns {Promise<ParseResult, ParseError>}
 */
PostitModdle.prototype.fromXML = function(xmlStr, typeName, options) {
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isString)(typeName)) {
    options = typeName;
    typeName = 'postit:Definitions';
  }

  var reader = new moddle_xml__WEBPACK_IMPORTED_MODULE_2__.Reader((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({ model: this, lax: true }, options));
  var rootHandler = reader.handler(typeName);

  return reader.fromXML(xmlStr, rootHandler);
};

/**
 * The toXML result.
 *
 * @typedef {Object} SerializationResult
 *
 * @property {String} xml
 */

/**
 * Serializes a Postit object tree to XML.
 *
 * @param {String}   element    the root element, typically an instance of `postit:Definitions`
 * @param {Object}   [options]  to pass to the underlying writer
 *
 * @returns {Promise<SerializationResult, Error>}
 */
PostitModdle.prototype.toXML = function(element, options) {
  var writer = new moddle_xml__WEBPACK_IMPORTED_MODULE_2__.Writer(options);

  return new Promise(function(resolve, reject) {
    try {
      var result = writer.toXML(element);

      return resolve({
        xml: result
      });
    } catch (err) {
      return reject(err);
    }
  });
};


/***/ }),

/***/ "./lib/moddle/index.js":
/*!*****************************!*\
  !*** ./lib/moddle/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _Moddle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Moddle */ "./lib/moddle/Moddle.js");
/* harmony import */ var _resources_postit_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resources/postit.json */ "./lib/moddle/resources/postit.json");
/* harmony import */ var _resources_postitDi_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources/postitDi.json */ "./lib/moddle/resources/postitDi.json");
/* harmony import */ var _resources_dc_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resources/dc.json */ "./lib/moddle/resources/dc.json");









var packages = {
  postit: _resources_postit_json__WEBPACK_IMPORTED_MODULE_0__,
  postitDi: _resources_postitDi_json__WEBPACK_IMPORTED_MODULE_1__,
  dc: _resources_dc_json__WEBPACK_IMPORTED_MODULE_2__,
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(additionalPackages, options) {
  var pks = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)({}, packages, additionalPackages);

  return new _Moddle__WEBPACK_IMPORTED_MODULE_4__.default(pks, options);
}


/***/ }),

/***/ "./lib/moddle/resources/dc.json":
/*!**************************************!*\
  !*** ./lib/moddle/resources/dc.json ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"dc","uri":"http://www.omg.org/spec/DD/20100524/DC","prefix":"dc","types":[{"name":"Boolean"},{"name":"Integer"},{"name":"Real"},{"name":"String"},{"name":"Font","properties":[{"name":"name","type":"String","isAttr":true},{"name":"size","type":"Real","isAttr":true},{"name":"isBold","type":"Boolean","isAttr":true},{"name":"isItalic","type":"Boolean","isAttr":true},{"name":"isUnderline","type":"Boolean","isAttr":true},{"name":"isStrikeThrough","type":"Boolean","isAttr":true}]},{"name":"Point","properties":[{"name":"x","type":"Real","default":"0","isAttr":true},{"name":"y","type":"Real","default":"0","isAttr":true}]},{"name":"Bounds","properties":[{"name":"x","type":"Real","default":"0","isAttr":true},{"name":"y","type":"Real","default":"0","isAttr":true},{"name":"width","type":"Real","isAttr":true},{"name":"height","type":"Real","isAttr":true}]}],"associations":[]}');

/***/ }),

/***/ "./lib/moddle/resources/postit.json":
/*!******************************************!*\
  !*** ./lib/moddle/resources/postit.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"Postit","uri":"http://some-company/schema/postit","prefix":"postit","xml":{"tagAlias":"lowerCase"},"types":[{"name":"BoardElement","isAbstract":true,"properties":[{"name":"name","isAttr":true,"type":"String"},{"name":"id","isAttr":true,"type":"String","isId":true}]},{"name":"PostitBoard","superClass":["RootElement"],"properties":[{"name":"boardElements","isMany":true,"type":"BoardElement"}]},{"name":"Postit","superClass":["BoardElement"],"properties":[{"name":"color","isAttr":true,"type":"String"}]},{"name":"SquarePostit","superClass":["Postit"]},{"name":"CirclePostit","superClass":["Postit"]},{"name":"TextBox","superClass":["BoardElement"]},{"name":"Group","superClass":["BoardElement"]},{"name":"Image","superClass":["BoardElement"],"properties":[{"name":"source","isAttr":true,"type":"String"}]},{"name":"RootElement","isAbstract":true,"superClass":["BoardElement"]},{"name":"Definitions","superClass":["BoardElement"],"properties":[{"name":"targetNamespace","isAttr":true,"type":"String"},{"name":"expressionLanguage","default":"http://www.w3.org/1999/XPath","isAttr":true,"type":"String"},{"name":"typeLanguage","default":"http://www.w3.org/2001/XMLSchema","isAttr":true,"type":"String"},{"name":"rootElements","type":"RootElement","isMany":true},{"name":"rootBoards","isMany":true,"type":"postitDi:PostitRootBoard"},{"name":"exporter","isAttr":true,"type":"String"},{"name":"exporterVersion","isAttr":true,"type":"String"}]}]}');

/***/ }),

/***/ "./lib/moddle/resources/postitDi.json":
/*!********************************************!*\
  !*** ./lib/moddle/resources/postitDi.json ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"POSTITDI","uri":"http://some-company/schema/postitdi","prefix":"postitDi","xml":{"tagAlias":"lowerCase"},"types":[{"name":"PostitRootBoard","properties":[{"name":"plane","type":"PostitPlane","redefines":"Board#rootElement"},{"name":"labelStyle","type":"PostitLabelStyle","isMany":true}],"superClass":["Board"]},{"name":"PostitPlane","properties":[{"name":"boardElement","isAttr":true,"isReference":true,"type":"postit:BoardElement","redefines":"BoardElement#modelElement"}],"superClass":["Plane"]},{"name":"PostitShape","properties":[{"name":"boardElement","isAttr":true,"isReference":true,"type":"postit:BoardElement","redefines":"BoardElement#modelElement"},{"name":"label","type":"PostitLabel"}],"superClass":["LabeledShape"]},{"name":"PostitLabel","properties":[{"name":"labelStyle","type":"PostitLabelStyle","isAttr":true,"isReference":true,"redefines":"BoardElement#style"}],"superClass":["Label"]},{"name":"PostitLabelStyle","properties":[{"name":"font","type":"dc:Font"}],"superClass":["Style"]},{"name":"BoardElement","isAbstract":true,"properties":[{"name":"id","isAttr":true,"isId":true,"type":"String"},{"name":"owningBoard","type":"Board","isReadOnly":true,"isVirtual":true,"isReference":true},{"name":"owningElement","type":"BoardElement","isReadOnly":true,"isVirtual":true,"isReference":true},{"name":"modelElement","isReadOnly":true,"isVirtual":true,"isReference":true,"type":"Element"},{"name":"style","type":"Style","isReadOnly":true,"isVirtual":true,"isReference":true}]},{"name":"Node","isAbstract":true,"superClass":["BoardElement"]},{"name":"Board","isAbstract":true,"properties":[{"name":"id","isAttr":true,"isId":true,"type":"String"},{"name":"rootElement","type":"BoardElement","isReadOnly":true,"isVirtual":true},{"name":"name","isAttr":true,"type":"String"},{"name":"resolution","isAttr":true,"type":"Real"},{"name":"ownedStyle","type":"Style","isReadOnly":true,"isMany":true,"isVirtual":true}]},{"name":"Shape","isAbstract":true,"superClass":["Node"],"properties":[{"name":"bounds","type":"dc:Bounds"}]},{"name":"Plane","isAbstract":true,"superClass":["Node"],"properties":[{"name":"planeElement","type":"BoardElement","subsettedProperty":"BoardElement-ownedElement","isMany":true}]},{"name":"LabeledEdge","isAbstract":true,"superClass":["Edge"],"properties":[{"name":"ownedLabel","type":"Label","isReadOnly":true,"subsettedProperty":"BoardElement-ownedElement","isMany":true,"isVirtual":true}]},{"name":"LabeledShape","isAbstract":true,"superClass":["Shape"],"properties":[{"name":"ownedLabel","type":"Label","isReadOnly":true,"subsettedProperty":"BoardElement-ownedElement","isMany":true,"isVirtual":true}]},{"name":"Label","isAbstract":true,"superClass":["Node"],"properties":[{"name":"bounds","type":"dc:Bounds"}]},{"name":"Style","isAbstract":true,"properties":[{"name":"id","isAttr":true,"isId":true,"type":"String"}]},{"name":"Extension","properties":[{"name":"values","isMany":true,"type":"Element"}]}],"enumerations":[],"associations":[]}');

/***/ }),

/***/ "./lib/util/ColorUtil.js":
/*!*******************************!*\
  !*** ./lib/util/ColorUtil.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  YELLOW: '#FFFF88',
  GREEN: '#7EC845',
  PINK: '#F46F60',
  ICE_BLUE: '#B8D6F7',
  BLUE: '#23BFE7',
  ORANGE: '#FF9D48',
  BLACK: 'black'
});


/***/ }),

/***/ "./lib/util/FileUtil.js":
/*!******************************!*\
  !*** ./lib/util/FileUtil.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fileToDataURL": () => (/* binding */ fileToDataURL),
/* harmony export */   "imageProcessor": () => (/* binding */ imageProcessor),
/* harmony export */   "fileReader": () => (/* binding */ fileReader)
/* harmony export */ });
function fileToDataURL(file) {
  return new Promise((resolve, reject) => {
    try {
      var reader = new FileReader();
      reader.onloadend = function() {
        resolve(reader.result);
      };
      reader.readAsDataURL(file);
    } catch (e) {
      reject(e);
    }
  });
}


async function imageProcessor(ev, file) {
  const base64file = await fileToDataURL(file);

  // createImage(ev, base64file);
  return base64file; // passing any errors through
}

async function fileReader(ev, files) {
  let uploadResult = [];
  let errors;
  let fileItems = files;
  if (ev && (ev.dataTransfer.items || ev.dataTransfer.files)) {
    fileItems = ev.dataTransfer.items || ev.dataTransfer.files;
  }
  try {
    if (fileItems) {
      for (var i = 0; i < fileItems.length; i++) {
        if (ev && ev.dataTransfer.items) {
          if (fileItems[i].kind === 'file') {
            var file = fileItems[i].getAsFile();
            uploadResult.push(await imageProcessor(ev, file));
          }
        } else {
          uploadResult.push(await imageProcessor(ev, fileItems[i]));
        }
      }
    }
  } catch (e) {
    errors = e;
    uploadResult = null;
  }
  return { uploadResult, errors };
}



/***/ }),

/***/ "./lib/util/LabelUtil.js":
/*!*******************************!*\
  !*** ./lib/util/LabelUtil.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_LABEL_SIZE": () => (/* binding */ DEFAULT_LABEL_SIZE),
/* harmony export */   "FLOW_LABEL_INDENT": () => (/* binding */ FLOW_LABEL_INDENT),
/* harmony export */   "isLabelExternal": () => (/* binding */ isLabelExternal),
/* harmony export */   "hasExternalLabel": () => (/* binding */ hasExternalLabel),
/* harmony export */   "getWaypointsMid": () => (/* binding */ getWaypointsMid),
/* harmony export */   "getExternalLabelMid": () => (/* binding */ getExternalLabelMid),
/* harmony export */   "getExternalLabelBounds": () => (/* binding */ getExternalLabelBounds),
/* harmony export */   "isLabel": () => (/* binding */ isLabel)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _ModelUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelUtil */ "./lib/util/ModelUtil.js");





var DEFAULT_LABEL_SIZE = {
  width: 90,
  height: 20
};

var FLOW_LABEL_INDENT = 15;


/**
 * Returns true if the given semantic has an external label
 *
 * @param {BoardElement} semantic
 * @return {Boolean} true if has label
 */
function isLabelExternal(semantic) {
  return (0,_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.is)(semantic, 'postit:Group');
}

/**
 * Returns true if the given element has an external label
 *
 * @param {djs.model.shape} element
 * @return {Boolean} true if has label
 */
function hasExternalLabel(element) {
  return isLabel(element.label);
}


/**
 * Get the middle of a number of waypoints
 *
 * @param  {Array<Point>} waypoints
 * @return {Point} the mid point
 */
function getWaypointsMid(waypoints) {

  var mid = waypoints.length / 2 - 1;

  var first = waypoints[Math.floor(mid)];
  var second = waypoints[Math.ceil(mid + 0.01)];

  return {
    x: first.x + (second.x - first.x) / 2,
    y: first.y + (second.y - first.y) / 2
  };
}


function getExternalLabelMid(element) {

  if ((0,_ModelUtil__WEBPACK_IMPORTED_MODULE_0__.is)(element, 'postit:Group')) {
    return {
      x: element.x + element.width / 2,
      y: element.y + DEFAULT_LABEL_SIZE.height / 2
    };
  } else {
    return {
      x: element.x + element.width / 2,
      y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2
    };
  }
}


/**
 * Returns the bounds of an elements label, parsed from the elements DI or
 * generated from its bounds.
 *
 * @param {BoardElement} semantic
 * @param {djs.model.Base} element
 */
function getExternalLabelBounds(semantic, element) {

  var mid,
      size,
      bounds,
      di = semantic.di,
      label = di.label;

  if (label && label.bounds) {
    bounds = label.bounds;

    size = {
      width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),
      height: bounds.height
    };

    mid = {
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2
    };
  } else {

    mid = getExternalLabelMid(element);

    size = DEFAULT_LABEL_SIZE;
  }

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({
    x: mid.x - size.width / 2,
    y: mid.y - size.height / 2
  }, size);
}

function isLabel(element) {
  return element && !!element.labelTarget;
}


/***/ }),

/***/ "./lib/util/ModelUtil.js":
/*!*******************************!*\
  !*** ./lib/util/ModelUtil.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "is": () => (/* binding */ is),
/* harmony export */   "getBusinessObject": () => (/* binding */ getBusinessObject)
/* harmony export */ });
/**
 * Is an element of the given postit type?
 *
 * @param  {djs.model.Base|ModdleElement} element
 * @param  {String} type
 *
 * @return {Boolean}
 */
function is(element, type) {
  var bo = getBusinessObject(element);

  return bo && (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);
}


/**
 * Return the business object for a given element.
 *
 * @param  {djs.model.Base|ModdleElement} element
 *
 * @return {ModdleElement}
 */
function getBusinessObject(element) {
  return (element && element.businessObject) || element;
}

/***/ }),

/***/ "./lib/util/ScreenUtil.js":
/*!********************************!*\
  !*** ./lib/util/ScreenUtil.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getMousePosition": () => (/* binding */ getMousePosition)
/* harmony export */ });
function getMousePosition(event) {
  event = event || window.event;

  var pageX = event.pageX;
  var pageY = event.pageY;

  // IE 8
  if (pageX === undefined) {
    pageX = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
    pageY = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
  }

  return { pageX, pageY };
}



/***/ }),

/***/ "./node_modules/css.escape/css.escape.js":
/*!***********************************************!*\
  !*** ./node_modules/css.escape/css.escape.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
;(function(root, factory) {
	// https://github.com/umdjs/umd/blob/master/returnExports.js
	if (true) {
		// For Node.js.
		module.exports = factory(root);
	} else {}
}(typeof __webpack_require__.g != 'undefined' ? __webpack_require__.g : this, function(root) {

	if (root.CSS && root.CSS.escape) {
		return root.CSS.escape;
	}

	// https://drafts.csswg.org/cssom/#serialize-an-identifier
	var cssEscape = function(value) {
		if (arguments.length == 0) {
			throw new TypeError('`CSS.escape` requires an argument.');
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = '';
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: theres no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += '\uFFFD';
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, []
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), []
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += '\\' + codeUnit.toString(16) + ' ';
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, []
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += '\\' + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), []
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += '\\' + string.charAt(index);

		}
		return result;
	};

	if (!root.CSS) {
		root.CSS = {};
	}

	root.CSS.escape = cssEscape;
	return cssEscape;

}));


/***/ }),

/***/ "./node_modules/diagram-js-direct-editing/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/diagram-js-direct-editing/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var diagram_js_lib_features_interaction_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diagram-js/lib/features/interaction-events */ "./node_modules/diagram-js/lib/features/interaction-events/index.js");
/* harmony import */ var _lib_DirectEditing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/DirectEditing */ "./node_modules/diagram-js-direct-editing/lib/DirectEditing.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    diagram_js_lib_features_interaction_events__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [ 'directEditing' ],
  directEditing: [ 'type', _lib_DirectEditing__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js-direct-editing/lib/DirectEditing.js":
/*!*********************************************************************!*\
  !*** ./node_modules/diagram-js-direct-editing/lib/DirectEditing.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DirectEditing)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _TextBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextBox */ "./node_modules/diagram-js-direct-editing/lib/TextBox.js");





/**
 * A direct editing component that allows users
 * to edit an elements text directly in the diagram
 *
 * @param {EventBus} eventBus the event bus
 */
function DirectEditing(eventBus, canvas) {

  this._eventBus = eventBus;

  this._providers = [];
  this._textbox = new _TextBox__WEBPACK_IMPORTED_MODULE_0__.default({
    container: canvas.getContainer(),
    keyHandler: (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.bind)(this._handleKey, this),
    resizeHandler: (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.bind)(this._handleResize, this)
  });
}

DirectEditing.$inject = [ 'eventBus', 'canvas' ];


/**
 * Register a direct editing provider

 * @param {Object} provider the provider, must expose an #activate(element) method that returns
 *                          an activation context ({ bounds: {x, y, width, height }, text }) if
 *                          direct editing is available for the given element.
 *                          Additionally the provider must expose a #update(element, value) method
 *                          to receive direct editing updates.
 */
DirectEditing.prototype.registerProvider = function(provider) {
  this._providers.push(provider);
};


/**
 * Returns true if direct editing is currently active
 *
 * @return {Boolean}
 */
DirectEditing.prototype.isActive = function() {
  return !!this._active;
};


/**
 * Cancel direct editing, if it is currently active
 */
DirectEditing.prototype.cancel = function() {
  if (!this._active) {
    return;
  }

  this._fire('cancel');
  this.close();
};


DirectEditing.prototype._fire = function(event, context) {
  this._eventBus.fire('directEditing.' + event, context || { active: this._active });
};

DirectEditing.prototype.close = function() {
  this._textbox.destroy();

  this._fire('deactivate');

  this._active = null;

  this.resizable = undefined;
};


DirectEditing.prototype.complete = function() {

  var active = this._active;

  if (!active) {
    return;
  }

  var containerBounds,
      previousBounds = active.context.bounds,
      newBounds = this.$textbox.getBoundingClientRect(),
      newText = this.getValue(),
      previousText = active.context.text;

  if (
    newText !== previousText ||
    newBounds.height !== previousBounds.height ||
    newBounds.width !== previousBounds.width
  ) {
    containerBounds = this._textbox.container.getBoundingClientRect();

    active.provider.update(active.element, newText, active.context.text, {
      x: newBounds.left - containerBounds.left,
      y: newBounds.top - containerBounds.top,
      width: newBounds.width,
      height: newBounds.height
    });
  }

  this._fire('complete');

  this.close();
};


DirectEditing.prototype.getValue = function() {
  return this._textbox.getValue();
};


DirectEditing.prototype._handleKey = function(e) {

  // stop bubble
  e.stopPropagation();

  var key = e.keyCode || e.charCode;

  // ESC
  if (key === 27) {
    e.preventDefault();
    return this.cancel();
  }

  // Enter
  if (key === 13 && !e.shiftKey) {
    e.preventDefault();
    return this.complete();
  }
};


DirectEditing.prototype._handleResize = function(event) {
  this._fire('resize', event);
};


/**
 * Activate direct editing on the given element
 *
 * @param {Object} ElementDescriptor the descriptor for a shape or connection
 * @return {Boolean} true if the activation was possible
 */
DirectEditing.prototype.activate = function(element) {
  if (this.isActive()) {
    this.cancel();
  }

  // the direct editing context
  var context;

  var provider = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(this._providers, function(p) {
    return (context = p.activate(element)) ? p : null;
  });

  // check if activation took place
  if (context) {
    this.$textbox = this._textbox.create(
      context.bounds,
      context.style,
      context.text,
      context.options
    );

    this._active = {
      element: element,
      context: context,
      provider: provider
    };

    if (context.options && context.options.resizable) {
      this.resizable = true;
    }

    this._fire('activate');
  }

  return !!context;
};


/***/ }),

/***/ "./node_modules/diagram-js-direct-editing/lib/TextBox.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js-direct-editing/lib/TextBox.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextBox)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");




var min = Math.min,
    max = Math.max;

function preventDefault(e) {
  e.preventDefault();
}

function stopPropagation(e) {
  e.stopPropagation();
}

function isTextNode(node) {
  return node.nodeType === Node.TEXT_NODE;
}

function toArray(nodeList) {
  return [].slice.call(nodeList);
}

/**
 * Initializes a container for a content editable div.
 *
 * Structure:
 *
 * container
 *   parent
 *     content
 *     resize-handle
 *
 * @param {object} options
 * @param {DOMElement} options.container The DOM element to append the contentContainer to
 * @param {Function} options.keyHandler Handler for key events
 * @param {Function} options.resizeHandler Handler for resize events
 */
function TextBox(options) {
  this.container = options.container;

  this.parent = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(
    '<div class="djs-direct-editing-parent">' +
      '<div class="djs-direct-editing-content" contenteditable="true"></div>' +
    '</div>'
  );

  this.content = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.query)('[contenteditable]', this.parent);

  this.keyHandler = options.keyHandler || function() {};
  this.resizeHandler = options.resizeHandler || function() {};

  this.autoResize = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.bind)(this.autoResize, this);
  this.handlePaste = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.bind)(this.handlePaste, this);
}


/**
 * Create a text box with the given position, size, style and text content
 *
 * @param {Object} bounds
 * @param {Number} bounds.x absolute x position
 * @param {Number} bounds.y absolute y position
 * @param {Number} [bounds.width] fixed width value
 * @param {Number} [bounds.height] fixed height value
 * @param {Number} [bounds.maxWidth] maximum width value
 * @param {Number} [bounds.maxHeight] maximum height value
 * @param {Number} [bounds.minWidth] minimum width value
 * @param {Number} [bounds.minHeight] minimum height value
 * @param {Object} [style]
 * @param {String} value text content
 *
 * @return {DOMElement} The created content DOM element
 */
TextBox.prototype.create = function(bounds, style, value, options) {
  var self = this;

  var parent = this.parent,
      content = this.content,
      container = this.container;

  options = this.options = options || {};

  style = this.style = style || {};

  var parentStyle = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.pick)(style, [
    'width',
    'height',
    'maxWidth',
    'maxHeight',
    'minWidth',
    'minHeight',
    'left',
    'top',
    'backgroundColor',
    'position',
    'overflow',
    'border',
    'wordWrap',
    'textAlign',
    'outline',
    'transform'
  ]);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(parent.style, {
    width: bounds.width + 'px',
    height: bounds.height + 'px',
    maxWidth: bounds.maxWidth + 'px',
    maxHeight: bounds.maxHeight + 'px',
    minWidth: bounds.minWidth + 'px',
    minHeight: bounds.minHeight + 'px',
    left: bounds.x + 'px',
    top: bounds.y + 'px',
    backgroundColor: '#ffffff',
    position: 'absolute',
    overflow: 'visible',
    border: '1px solid #ccc',
    boxSizing: 'border-box',
    wordWrap: 'normal',
    textAlign: 'center',
    outline: 'none'
  }, parentStyle);

  var contentStyle = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.pick)(style, [
    'fontFamily',
    'fontSize',
    'fontWeight',
    'lineHeight',
    'padding',
    'paddingTop',
    'paddingRight',
    'paddingBottom',
    'paddingLeft'
  ]);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(content.style, {
    boxSizing: 'border-box',
    width: '100%',
    outline: 'none',
    wordWrap: 'break-word'
  }, contentStyle);

  if (options.centerVertically) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(content.style, {
      position: 'absolute',
      top: '50%',
      transform: 'translate(0, -50%)'
    }, contentStyle);
  }

  content.innerText = value;

  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(content, 'keydown', this.keyHandler);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(content, 'mousedown', stopPropagation);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(content, 'paste', self.handlePaste);

  if (options.autoResize) {
    min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(content, 'input', this.autoResize);
  }

  if (options.resizable) {
    this.resizable(style);
  }

  container.appendChild(parent);

  // set selection to end of text
  this.setSelection(content.lastChild, content.lastChild && content.lastChild.length);

  return parent;
};

/**
 * Intercept paste events to remove formatting from pasted text.
 */
TextBox.prototype.handlePaste = function(e) {
  var options = this.options,
      style = this.style;

  e.preventDefault();

  var text;

  if (e.clipboardData) {

    // Chrome, Firefox, Safari
    text = e.clipboardData.getData('text/plain');
  } else {

    // Internet Explorer
    text = window.clipboardData.getData('Text');
  }

  this.insertText(text);

  if (options.autoResize) {
    var hasResized = this.autoResize(style);

    if (hasResized) {
      this.resizeHandler(hasResized);
    }
  }
};

TextBox.prototype.insertText = function(text) {

  // insertText command not supported by Internet Explorer
  var success = document.execCommand('insertText', false, text);

  if (success) {
    return;
  }

  this._insertTextIE(text);
};

TextBox.prototype._insertTextIE = function(text) {

  // Internet Explorer
  var range = this.getSelection(),
      startContainer = range.startContainer,
      endContainer = range.endContainer,
      startOffset = range.startOffset,
      endOffset = range.endOffset,
      commonAncestorContainer = range.commonAncestorContainer;

  var childNodesArray = toArray(commonAncestorContainer.childNodes);

  var container,
      offset;

  if (isTextNode(commonAncestorContainer)) {
    var containerTextContent = startContainer.textContent;

    startContainer.textContent =
      containerTextContent.substring(0, startOffset)
      + text
      + containerTextContent.substring(endOffset);

    container = startContainer;
    offset = startOffset + text.length;

  } else if (startContainer === this.content && endContainer === this.content) {
    var textNode = document.createTextNode(text);

    this.content.insertBefore(textNode, childNodesArray[startOffset]);

    container = textNode;
    offset = textNode.textContent.length;
  } else {
    var startContainerChildIndex = childNodesArray.indexOf(startContainer),
        endContainerChildIndex = childNodesArray.indexOf(endContainer);

    childNodesArray.forEach(function(childNode, index) {

      if (index === startContainerChildIndex) {
        childNode.textContent =
          startContainer.textContent.substring(0, startOffset) +
          text +
          endContainer.textContent.substring(endOffset);
      } else if (index > startContainerChildIndex && index <= endContainerChildIndex) {
        (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.remove)(childNode);
      }
    });

    container = startContainer;
    offset = startOffset + text.length;
  }

  if (container && offset !== undefined) {

    // is necessary in Internet Explorer
    setTimeout(function() {
      self.setSelection(container, offset);
    });
  }
};

/**
 * Automatically resize element vertically to fit its content.
 */
TextBox.prototype.autoResize = function() {
  var parent = this.parent,
      content = this.content;

  var fontSize = parseInt(this.style.fontSize) || 12;

  if (content.scrollHeight > parent.offsetHeight ||
      content.scrollHeight < parent.offsetHeight - fontSize) {
    var bounds = parent.getBoundingClientRect();

    var height = content.scrollHeight;
    parent.style.height = height + 'px';

    this.resizeHandler({
      width: bounds.width,
      height: bounds.height,
      dx: 0,
      dy: height - bounds.height
    });
  }
};

/**
 * Make an element resizable by adding a resize handle.
 */
TextBox.prototype.resizable = function() {
  var self = this;

  var parent = this.parent,
      resizeHandle = this.resizeHandle;

  var minWidth = parseInt(this.style.minWidth) || 0,
      minHeight = parseInt(this.style.minHeight) || 0,
      maxWidth = parseInt(this.style.maxWidth) || Infinity,
      maxHeight = parseInt(this.style.maxHeight) || Infinity;

  if (!resizeHandle) {
    resizeHandle = this.resizeHandle = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(
      '<div class="djs-direct-editing-resize-handle"></div>'
    );

    var startX, startY, startWidth, startHeight;

    var onMouseDown = function(e) {
      preventDefault(e);
      stopPropagation(e);

      startX = e.clientX;
      startY = e.clientY;

      var bounds = parent.getBoundingClientRect();

      startWidth = bounds.width;
      startHeight = bounds.height;

      min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(document, 'mousemove', onMouseMove);
      min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(document, 'mouseup', onMouseUp);
    };

    var onMouseMove = function(e) {
      preventDefault(e);
      stopPropagation(e);

      var newWidth = min(max(startWidth + e.clientX - startX, minWidth), maxWidth);
      var newHeight = min(max(startHeight + e.clientY - startY, minHeight), maxHeight);

      parent.style.width = newWidth + 'px';
      parent.style.height = newHeight + 'px';

      self.resizeHandler({
        width: startWidth,
        height: startHeight,
        dx: e.clientX - startX,
        dy: e.clientY - startY
      });
    };

    var onMouseUp = function(e) {
      preventDefault(e);
      stopPropagation(e);

      min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(document,'mousemove', onMouseMove, false);
      min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(document, 'mouseup', onMouseUp, false);
    };

    min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(resizeHandle, 'mousedown', onMouseDown);
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(resizeHandle.style, {
    position: 'absolute',
    bottom: '0px',
    right: '0px',
    cursor: 'nwse-resize',
    width: '0',
    height: '0',
    borderTop: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent',
    borderRight: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
    borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
    borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent'
  });

  parent.appendChild(resizeHandle);
};


/**
 * Clear content and style of the textbox, unbind listeners and
 * reset CSS style.
 */
TextBox.prototype.destroy = function() {
  var parent = this.parent,
      content = this.content,
      resizeHandle = this.resizeHandle;

  // clear content
  content.innerText = '';

  // clear styles
  parent.removeAttribute('style');
  content.removeAttribute('style');

  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(content, 'keydown', this.keyHandler);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(content, 'mousedown', stopPropagation);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(content, 'input', this.autoResize);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(content, 'paste', this.handlePaste);

  if (resizeHandle) {
    resizeHandle.removeAttribute('style');

    (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.remove)(resizeHandle);
  }

  (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.remove)(parent);
};


TextBox.prototype.getValue = function() {
  return this.content.innerText.trim();
};


TextBox.prototype.getSelection = function() {
  var selection = window.getSelection(),
      range = selection.getRangeAt(0);

  return range;
};


TextBox.prototype.setSelection = function(container, offset) {
  var range = document.createRange();

  if (container === null) {
    range.selectNodeContents(this.content);
  } else {
    range.setStart(container, offset);
    range.setEnd(container, offset);
  }

  var selection = window.getSelection();

  selection.removeAllRanges();
  selection.addRange(range);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/Diagram.js":
/*!************************************************!*\
  !*** ./node_modules/diagram-js/lib/Diagram.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Diagram)
/* harmony export */ });
/* harmony import */ var didi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! didi */ "./node_modules/didi/dist/index.esm.js");
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ "./node_modules/diagram-js/lib/core/index.js");





/**
 * Bootstrap an injector from a list of modules, instantiating a number of default components
 *
 * @ignore
 * @param {Array<didi.Module>} bootstrapModules
 *
 * @return {didi.Injector} a injector to use to access the components
 */
function bootstrap(bootstrapModules) {

  var modules = [],
      components = [];

  function hasModule(m) {
    return modules.indexOf(m) >= 0;
  }

  function addModule(m) {
    modules.push(m);
  }

  function visit(m) {
    if (hasModule(m)) {
      return;
    }

    (m.__depends__ || []).forEach(visit);

    if (hasModule(m)) {
      return;
    }

    addModule(m);

    (m.__init__ || []).forEach(function(c) {
      components.push(c);
    });
  }

  bootstrapModules.forEach(visit);

  var injector = new didi__WEBPACK_IMPORTED_MODULE_0__.Injector(modules);

  components.forEach(function(c) {

    try {

      // eagerly resolve component (fn or string)
      injector[typeof c === 'string' ? 'get' : 'invoke'](c);
    } catch (e) {
      console.error('Failed to instantiate component');
      console.error(e.stack);

      throw e;
    }
  });

  return injector;
}

/**
 * Creates an injector from passed options.
 *
 * @ignore
 * @param  {Object} options
 * @return {didi.Injector}
 */
function createInjector(options) {

  options = options || {};

  var configModule = {
    'config': ['value', options]
  };

  var modules = [ configModule, _core__WEBPACK_IMPORTED_MODULE_1__.default ].concat(options.modules || []);

  return bootstrap(modules);
}


/**
 * The main diagram-js entry point that bootstraps the diagram with the given
 * configuration.
 *
 * To register extensions with the diagram, pass them as Array<didi.Module> to the constructor.
 *
 * @class djs.Diagram
 * @memberOf djs
 * @constructor
 *
 * @example
 *
 * <caption>Creating a plug-in that logs whenever a shape is added to the canvas.</caption>
 *
 * // plug-in implemenentation
 * function MyLoggingPlugin(eventBus) {
 *   eventBus.on('shape.added', function(event) {
 *     console.log('shape ', event.shape, ' was added to the diagram');
 *   });
 * }
 *
 * // export as module
 * export default {
 *   __init__: [ 'myLoggingPlugin' ],
 *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]
 * };
 *
 *
 * // instantiate the diagram with the new plug-in
 *
 * import MyLoggingModule from 'path-to-my-logging-plugin';
 *
 * var diagram = new Diagram({
 *   modules: [
 *     MyLoggingModule
 *   ]
 * });
 *
 * diagram.invoke([ 'canvas', function(canvas) {
 *   // add shape to drawing canvas
 *   canvas.addShape({ x: 10, y: 10 });
 * });
 *
 * // 'shape ... was added to the diagram' logged to console
 *
 * @param {Object} options
 * @param {Array<didi.Module>} [options.modules] external modules to instantiate with the diagram
 * @param {didi.Injector} [injector] an (optional) injector to bootstrap the diagram with
 */
function Diagram(options, injector) {

  // create injector unless explicitly specified
  this.injector = injector = injector || createInjector(options);

  // API

  /**
   * Resolves a diagram service
   *
   * @method Diagram#get
   *
   * @param {string} name the name of the diagram service to be retrieved
   * @param {boolean} [strict=true] if false, resolve missing services to null
   */
  this.get = injector.get;

  /**
   * Executes a function into which diagram services are injected
   *
   * @method Diagram#invoke
   *
   * @param {Function|Object[]} fn the function to resolve
   * @param {Object} locals a number of locals to use to resolve certain dependencies
   */
  this.invoke = injector.invoke;

  // init

  // indicate via event


  /**
   * An event indicating that all plug-ins are loaded.
   *
   * Use this event to fire other events to interested plug-ins
   *
   * @memberOf Diagram
   *
   * @event diagram.init
   *
   * @example
   *
   * eventBus.on('diagram.init', function() {
   *   eventBus.fire('my-custom-event', { foo: 'BAR' });
   * });
   *
   * @type {Object}
   */
  this.get('eventBus').fire('diagram.init');
}


/**
 * Destroys the diagram
 *
 * @method  Diagram#destroy
 */
Diagram.prototype.destroy = function() {
  this.get('eventBus').fire('diagram.destroy');
};

/**
 * Clear the diagram, removing all contents.
 */
Diagram.prototype.clear = function() {
  this.get('eventBus').fire('diagram.clear');
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/command/CommandInterceptor.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/command/CommandInterceptor.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CommandInterceptor)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



var DEFAULT_PRIORITY = 1000;

/**
 * A utility that can be used to plug-in into the command execution for
 * extension and/or validation.
 *
 * @param {EventBus} eventBus
 *
 * @example
 *
 * import inherits from 'inherits';
 *
 * import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';
 *
 * function CommandLogger(eventBus) {
 *   CommandInterceptor.call(this, eventBus);
 *
 *   this.preExecute(function(event) {
 *     console.log('command pre-execute', event);
 *   });
 * }
 *
 * inherits(CommandLogger, CommandInterceptor);
 *
 */
function CommandInterceptor(eventBus) {
  this._eventBus = eventBus;
}

CommandInterceptor.$inject = [ 'eventBus' ];

function unwrapEvent(fn, that) {
  return function(event) {
    return fn.call(that || null, event.context, event.command, event);
  };
}

/**
 * Register an interceptor for a command execution
 *
 * @param {string|Array<string>} [events] list of commands to register on
 * @param {string} [hook] command hook, i.e. preExecute, executed to listen on
 * @param {number} [priority] the priority on which to hook into the execution
 * @param {Function} handlerFn interceptor to be invoked with (event)
 * @param {boolean} unwrap if true, unwrap the event and pass (context, command, event) to the
 *                          listener instead
 * @param {Object} [that] Pass context (`this`) to the handler function
 */
CommandInterceptor.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(hook) || (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(hook)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = hook;
    hook = null;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(priority)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = DEFAULT_PRIORITY;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(unwrap)) {
    that = unwrap;
    unwrap = false;
  }

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(handlerFn)) {
    throw new Error('handlerFn must be a function');
  }

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(events)) {
    events = [ events ];
  }

  var eventBus = this._eventBus;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(events, function(event) {

    // concat commandStack(.event)?(.hook)?
    var fullEvent = [ 'commandStack', event, hook ].filter(function(e) { return e; }).join('.');

    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
  });
};


var hooks = [
  'canExecute',
  'preExecute',
  'preExecuted',
  'execute',
  'executed',
  'postExecute',
  'postExecuted',
  'revert',
  'reverted'
];

/*
 * Install hook shortcuts
 *
 * This will generate the CommandInterceptor#(preExecute|...|reverted) methods
 * which will in term forward to CommandInterceptor#on.
 */
(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(hooks, function(hook) {

  /**
   * {canExecute|preExecute|preExecuted|execute|executed|postExecute|postExecuted|revert|reverted}
   *
   * A named hook for plugging into the command execution
   *
   * @param {string|Array<string>} [events] list of commands to register on
   * @param {number} [priority] the priority on which to hook into the execution
   * @param {Function} handlerFn interceptor to be invoked with (event)
   * @param {boolean} [unwrap=false] if true, unwrap the event and pass (context, command, event) to the
   *                          listener instead
   * @param {Object} [that] Pass context (`this`) to the handler function
   */
  CommandInterceptor.prototype[hook] = function(events, priority, handlerFn, unwrap, that) {

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(events) || (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(events)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = events;
      events = null;
    }

    this.on(events, hook, priority, handlerFn, unwrap, that);
  };
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/command/CommandStack.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/command/CommandStack.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CommandStack)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A service that offers un- and redoable execution of commands.
 *
 * The command stack is responsible for executing modeling actions
 * in a un- and redoable manner. To do this it delegates the actual
 * command execution to {@link CommandHandler}s.
 *
 * Command handlers provide {@link CommandHandler#execute(ctx)} and
 * {@link CommandHandler#revert(ctx)} methods to un- and redo a command
 * identified by a command context.
 *
 *
 * ## Life-Cycle events
 *
 * In the process the command stack fires a number of life-cycle events
 * that other components to participate in the command execution.
 *
 *    * preExecute
 *    * preExecuted
 *    * execute
 *    * executed
 *    * postExecute
 *    * postExecuted
 *    * revert
 *    * reverted
 *
 * A special event is used for validating, whether a command can be
 * performed prior to its execution.
 *
 *    * canExecute
 *
 * Each of the events is fired as `commandStack.{eventName}` and
 * `commandStack.{commandName}.{eventName}`, respectively. This gives
 * components fine grained control on where to hook into.
 *
 * The event object fired transports `command`, the name of the
 * command and `context`, the command context.
 *
 *
 * ## Creating Command Handlers
 *
 * Command handlers should provide the {@link CommandHandler#execute(ctx)}
 * and {@link CommandHandler#revert(ctx)} methods to implement
 * redoing and undoing of a command.
 *
 * A command handler _must_ ensure undo is performed properly in order
 * not to break the undo chain. It must also return the shapes that
 * got changed during the `execute` and `revert` operations.
 *
 * Command handlers may execute other modeling operations (and thus
 * commands) in their `preExecute` and `postExecute` phases. The command
 * stack will properly group all commands together into a logical unit
 * that may be re- and undone atomically.
 *
 * Command handlers must not execute other commands from within their
 * core implementation (`execute`, `revert`).
 *
 *
 * ## Change Tracking
 *
 * During the execution of the CommandStack it will keep track of all
 * elements that have been touched during the command's execution.
 *
 * At the end of the CommandStack execution it will notify interested
 * components via an 'elements.changed' event with all the dirty
 * elements.
 *
 * The event can be picked up by components that are interested in the fact
 * that elements have been changed. One use case for this is updating
 * their graphical representation after moving / resizing or deletion.
 *
 * @see CommandHandler
 *
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */
function CommandStack(eventBus, injector) {

  /**
   * A map of all registered command handlers.
   *
   * @type {Object}
   */
  this._handlerMap = {};

  /**
   * A stack containing all re/undoable actions on the diagram
   *
   * @type {Array<Object>}
   */
  this._stack = [];

  /**
   * The current index on the stack
   *
   * @type {number}
   */
  this._stackIdx = -1;

  /**
   * Current active commandStack execution
   *
   * @type {Object}
   * @property {Object[]} actions
   * @property {Object[]} dirty
   * @property { 'undo' | 'redo' | 'clear' | 'execute' | null } trigger the cause of the current excecution
   */
  this._currentExecution = {
    actions: [],
    dirty: [],
    trigger: null
  };


  this._injector = injector;
  this._eventBus = eventBus;

  this._uid = 1;

  eventBus.on([
    'diagram.destroy',
    'diagram.clear'
  ], function() {
    this.clear(false);
  }, this);
}

CommandStack.$inject = [ 'eventBus', 'injector' ];


/**
 * Execute a command
 *
 * @param {string} command the command to execute
 * @param {Object} context the environment to execute the command in
 */
CommandStack.prototype.execute = function(command, context) {
  if (!command) {
    throw new Error('command required');
  }

  this._currentExecution.trigger = 'execute';

  var action = { command: command, context: context };

  this._pushAction(action);
  this._internalExecute(action);
  this._popAction(action);
};


/**
 * Ask whether a given command can be executed.
 *
 * Implementors may hook into the mechanism on two ways:
 *
 *   * in event listeners:
 *
 *     Users may prevent the execution via an event listener.
 *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.
 *
 *   * in command handlers:
 *
 *     If the method {@link CommandHandler#canExecute} is implemented in a handler
 *     it will be called to figure out whether the execution is allowed.
 *
 * @param  {string} command the command to execute
 * @param  {Object} context the environment to execute the command in
 *
 * @return {boolean} true if the command can be executed
 */
CommandStack.prototype.canExecute = function(command, context) {

  var action = { command: command, context: context };

  var handler = this._getHandler(command);

  var result = this._fire(command, 'canExecute', action);

  // handler#canExecute will only be called if no listener
  // decided on a result already
  if (result === undefined) {
    if (!handler) {
      return false;
    }

    if (handler.canExecute) {
      result = handler.canExecute(context);
    }
  }

  return result;
};


/**
 * Clear the command stack, erasing all undo / redo history
 */
CommandStack.prototype.clear = function(emit) {
  this._stack.length = 0;
  this._stackIdx = -1;

  if (emit !== false) {
    this._fire('changed', { trigger: 'clear' });
  }
};


/**
 * Undo last command(s)
 */
CommandStack.prototype.undo = function() {
  var action = this._getUndoAction(),
      next;

  if (action) {
    this._currentExecution.trigger = 'undo';

    this._pushAction(action);

    while (action) {
      this._internalUndo(action);
      next = this._getUndoAction();

      if (!next || next.id !== action.id) {
        break;
      }

      action = next;
    }

    this._popAction();
  }
};


/**
 * Redo last command(s)
 */
CommandStack.prototype.redo = function() {
  var action = this._getRedoAction(),
      next;

  if (action) {
    this._currentExecution.trigger = 'redo';

    this._pushAction(action);

    while (action) {
      this._internalExecute(action, true);
      next = this._getRedoAction();

      if (!next || next.id !== action.id) {
        break;
      }

      action = next;
    }

    this._popAction();
  }
};


/**
 * Register a handler instance with the command stack
 *
 * @param {string} command
 * @param {CommandHandler} handler
 */
CommandStack.prototype.register = function(command, handler) {
  this._setHandler(command, handler);
};


/**
 * Register a handler type with the command stack
 * by instantiating it and injecting its dependencies.
 *
 * @param {string} command
 * @param {Function} a constructor for a {@link CommandHandler}
 */
CommandStack.prototype.registerHandler = function(command, handlerCls) {

  if (!command || !handlerCls) {
    throw new Error('command and handlerCls must be defined');
  }

  var handler = this._injector.instantiate(handlerCls);
  this.register(command, handler);
};

CommandStack.prototype.canUndo = function() {
  return !!this._getUndoAction();
};

CommandStack.prototype.canRedo = function() {
  return !!this._getRedoAction();
};

// stack access  //////////////////////

CommandStack.prototype._getRedoAction = function() {
  return this._stack[this._stackIdx + 1];
};


CommandStack.prototype._getUndoAction = function() {
  return this._stack[this._stackIdx];
};


// internal functionality //////////////////////

CommandStack.prototype._internalUndo = function(action) {
  var self = this;

  var command = action.command,
      context = action.context;

  var handler = this._getHandler(command);

  // guard against illegal nested command stack invocations
  this._atomicDo(function() {
    self._fire(command, 'revert', action);

    if (handler.revert) {
      self._markDirty(handler.revert(context));
    }

    self._revertedAction(action);

    self._fire(command, 'reverted', action);
  });
};


CommandStack.prototype._fire = function(command, qualifier, event) {
  if (arguments.length < 3) {
    event = qualifier;
    qualifier = null;
  }

  var names = qualifier ? [ command + '.' + qualifier, qualifier ] : [ command ],
      i, name, result;

  event = this._eventBus.createEvent(event);

  for (i = 0; (name = names[i]); i++) {
    result = this._eventBus.fire('commandStack.' + name, event);

    if (event.cancelBubble) {
      break;
    }
  }

  return result;
};

CommandStack.prototype._createId = function() {
  return this._uid++;
};

CommandStack.prototype._atomicDo = function(fn) {

  var execution = this._currentExecution;

  execution.atomic = true;

  try {
    fn();
  } finally {
    execution.atomic = false;
  }
};

CommandStack.prototype._internalExecute = function(action, redo) {
  var self = this;

  var command = action.command,
      context = action.context;

  var handler = this._getHandler(command);

  if (!handler) {
    throw new Error('no command handler registered for <' + command + '>');
  }

  this._pushAction(action);

  if (!redo) {
    this._fire(command, 'preExecute', action);

    if (handler.preExecute) {
      handler.preExecute(context);
    }

    this._fire(command, 'preExecuted', action);
  }

  // guard against illegal nested command stack invocations
  this._atomicDo(function() {

    self._fire(command, 'execute', action);

    if (handler.execute) {

      // actual execute + mark return results as dirty
      self._markDirty(handler.execute(context));
    }

    // log to stack
    self._executedAction(action, redo);

    self._fire(command, 'executed', action);
  });

  if (!redo) {
    this._fire(command, 'postExecute', action);

    if (handler.postExecute) {
      handler.postExecute(context);
    }

    this._fire(command, 'postExecuted', action);
  }

  this._popAction(action);
};


CommandStack.prototype._pushAction = function(action) {

  var execution = this._currentExecution,
      actions = execution.actions;

  var baseAction = actions[0];

  if (execution.atomic) {
    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');
  }

  if (!action.id) {
    action.id = (baseAction && baseAction.id) || this._createId();
  }

  actions.push(action);
};


CommandStack.prototype._popAction = function() {
  var execution = this._currentExecution,
      trigger = execution.trigger,
      actions = execution.actions,
      dirty = execution.dirty;

  actions.pop();

  if (!actions.length) {
    this._eventBus.fire('elements.changed', { elements: (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.uniqueBy)('id', dirty.reverse()) });

    dirty.length = 0;

    this._fire('changed', { trigger: trigger });

    execution.trigger = null;
  }
};


CommandStack.prototype._markDirty = function(elements) {
  var execution = this._currentExecution;

  if (!elements) {
    return;
  }

  elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements) ? elements : [ elements ];

  execution.dirty = execution.dirty.concat(elements);
};


CommandStack.prototype._executedAction = function(action, redo) {
  var stackIdx = ++this._stackIdx;

  if (!redo) {
    this._stack.splice(stackIdx, this._stack.length, action);
  }
};


CommandStack.prototype._revertedAction = function(action) {
  this._stackIdx--;
};


CommandStack.prototype._getHandler = function(command) {
  return this._handlerMap[command];
};

CommandStack.prototype._setHandler = function(command, handler) {
  if (!command || !handler) {
    throw new Error('command and handler required');
  }

  if (this._handlerMap[command]) {
    throw new Error('overriding handler for command <' + command + '>');
  }

  this._handlerMap[command] = handler;
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/command/index.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/command/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CommandStack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CommandStack */ "./node_modules/diagram-js/lib/command/CommandStack.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  commandStack: [ 'type', _CommandStack__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/Canvas.js":
/*!****************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/Canvas.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Canvas)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");











function round(number, resolution) {
  return Math.round(number * resolution) / resolution;
}

function ensurePx(number) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(number) ? number + 'px' : number;
}

/**
 * Creates a HTML container element for a SVG element with
 * the given configuration
 *
 * @param  {Object} options
 * @return {HTMLElement} the container element
 */
function createContainer(options) {

  options = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, { width: '100%', height: '100%' }, options);

  var container = options.container || document.body;

  // create a <div> around the svg element with the respective size
  // this way we can always get the correct container size
  // (this is impossible for <svg> elements at the moment)
  var parent = document.createElement('div');
  parent.setAttribute('class', 'djs-container');

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(parent.style, {
    position: 'relative',
    overflow: 'hidden',
    width: ensurePx(options.width),
    height: ensurePx(options.height)
  });

  container.appendChild(parent);

  return parent;
}

function createGroup(parent, cls, childIndex) {
  var group = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(group).add(cls);

  var index = childIndex !== undefined ? childIndex : parent.childNodes.length - 1;

  // must ensure second argument is node or _null_
  // cf. https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore
  parent.insertBefore(group, parent.childNodes[index] || null);

  return group;
}

var BASE_LAYER = 'base';


var REQUIRED_MODEL_ATTRS = {
  shape: [ 'x', 'y', 'width', 'height' ],
  connection: [ 'waypoints' ]
};

/**
 * The main drawing canvas.
 *
 * @class
 * @constructor
 *
 * @emits Canvas#canvas.init
 *
 * @param {Object} config
 * @param {EventBus} eventBus
 * @param {GraphicsFactory} graphicsFactory
 * @param {ElementRegistry} elementRegistry
 */
function Canvas(config, eventBus, graphicsFactory, elementRegistry) {

  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;

  this._init(config || {});
}

Canvas.$inject = [
  'config.canvas',
  'eventBus',
  'graphicsFactory',
  'elementRegistry'
];


Canvas.prototype._init = function(config) {

  var eventBus = this._eventBus;

  // Creates a <svg> element that is wrapped into a <div>.
  // This way we are always able to correctly figure out the size of the svg element
  // by querying the parent node.
  //
  // (It is not possible to get the size of a svg element cross browser @ 2014-04-01)
  //
  // <div class="djs-container" style="width: {desired-width}, height: {desired-height}">
  //   <svg width="100%" height="100%">
  //    ...
  //   </svg>
  // </div>

  // html container
  var container = this._container = createContainer(config);

  var svg = this._svg = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('svg');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(svg, { width: '100%', height: '100%' });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(container, svg);

  var viewport = this._viewport = createGroup(svg, 'viewport');

  this._layers = {};

  // debounce canvas.viewbox.changed events
  // for smoother diagram interaction
  if (config.deferUpdate !== false) {
    this._viewboxChanged = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.debounce)((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(this._viewboxChanged, this), 300);
  }

  eventBus.on('diagram.init', function() {

    /**
     * An event indicating that the canvas is ready to be drawn on.
     *
     * @memberOf Canvas
     *
     * @event canvas.init
     *
     * @type {Object}
     * @property {SVGElement} svg the created svg element
     * @property {SVGElement} viewport the direct parent of diagram elements and shapes
     */
    eventBus.fire('canvas.init', {
      svg: svg,
      viewport: viewport
    });

  }, this);

  // reset viewbox on shape changes to
  // recompute the viewbox
  eventBus.on([
    'shape.added',
    'connection.added',
    'shape.removed',
    'connection.removed',
    'elements.changed'
  ], function() {
    delete this._cachedViewbox;
  }, this);

  eventBus.on('diagram.destroy', 500, this._destroy, this);
  eventBus.on('diagram.clear', 500, this._clear, this);
};

Canvas.prototype._destroy = function(emit) {
  this._eventBus.fire('canvas.destroy', {
    svg: this._svg,
    viewport: this._viewport
  });

  var parent = this._container.parentNode;

  if (parent) {
    parent.removeChild(this._container);
  }

  delete this._svg;
  delete this._container;
  delete this._layers;
  delete this._rootElement;
  delete this._viewport;
};

Canvas.prototype._clear = function() {

  var self = this;

  var allElements = this._elementRegistry.getAll();

  // remove all elements
  allElements.forEach(function(element) {
    var type = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getType)(element);

    if (type === 'root') {
      self.setRootElement(null, true);
    } else {
      self._removeElement(element, type);
    }
  });

  // force recomputation of view box
  delete this._cachedViewbox;
};

/**
 * Returns the default layer on which
 * all elements are drawn.
 *
 * @returns {SVGElement}
 */
Canvas.prototype.getDefaultLayer = function() {
  return this.getLayer(BASE_LAYER, 0);
};

/**
 * Returns a layer that is used to draw elements
 * or annotations on it.
 *
 * Non-existing layers retrieved through this method
 * will be created. During creation, the optional index
 * may be used to create layers below or above existing layers.
 * A layer with a certain index is always created above all
 * existing layers with the same index.
 *
 * @param {string} name
 * @param {number} index
 *
 * @returns {SVGElement}
 */
Canvas.prototype.getLayer = function(name, index) {

  if (!name) {
    throw new Error('must specify a name');
  }

  var layer = this._layers[name];

  if (!layer) {
    layer = this._layers[name] = this._createLayer(name, index);
  }

  // throw an error if layer creation / retrival is
  // requested on different index
  if (typeof index !== 'undefined' && layer.index !== index) {
    throw new Error('layer <' + name + '> already created at index <' + index + '>');
  }

  return layer.group;
};

/**
 * Creates a given layer and returns it.
 *
 * @param {string} name
 * @param {number} [index=0]
 *
 * @return {Object} layer descriptor with { index, group: SVGGroup }
 */
Canvas.prototype._createLayer = function(name, index) {

  if (!index) {
    index = 0;
  }

  var childIndex = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(this._layers, function(childIndex, layer) {
    if (index >= layer.index) {
      childIndex++;
    }

    return childIndex;
  }, 0);

  return {
    group: createGroup(this._viewport, 'layer-' + name, childIndex),
    index: index
  };

};

/**
 * Returns the html element that encloses the
 * drawing canvas.
 *
 * @return {DOMNode}
 */
Canvas.prototype.getContainer = function() {
  return this._container;
};


// markers //////////////////////

Canvas.prototype._updateMarker = function(element, marker, add) {
  var container;

  if (!element.id) {
    element = this._elementRegistry.get(element);
  }

  // we need to access all
  container = this._elementRegistry._elements[element.id];

  if (!container) {
    return;
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)([ container.gfx, container.secondaryGfx ], function(gfx) {
    if (gfx) {

      // invoke either addClass or removeClass based on mode
      if (add) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).add(marker);
      } else {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).remove(marker);
      }
    }
  });

  /**
   * An event indicating that a marker has been updated for an element
   *
   * @event element.marker.update
   * @type {Object}
   * @property {djs.model.Element} element the shape
   * @property {Object} gfx the graphical representation of the shape
   * @property {string} marker
   * @property {boolean} add true if the marker was added, false if it got removed
   */
  this._eventBus.fire('element.marker.update', { element: element, gfx: container.gfx, marker: marker, add: !!add });
};


/**
 * Adds a marker to an element (basically a css class).
 *
 * Fires the element.marker.update event, making it possible to
 * integrate extension into the marker life-cycle, too.
 *
 * @example
 * canvas.addMarker('foo', 'some-marker');
 *
 * var fooGfx = canvas.getGraphics('foo');
 *
 * fooGfx; // <g class="... some-marker"> ... </g>
 *
 * @param {string|djs.model.Base} element
 * @param {string} marker
 */
Canvas.prototype.addMarker = function(element, marker) {
  this._updateMarker(element, marker, true);
};


/**
 * Remove a marker from an element.
 *
 * Fires the element.marker.update event, making it possible to
 * integrate extension into the marker life-cycle, too.
 *
 * @param  {string|djs.model.Base} element
 * @param  {string} marker
 */
Canvas.prototype.removeMarker = function(element, marker) {
  this._updateMarker(element, marker, false);
};

/**
 * Check the existence of a marker on element.
 *
 * @param  {string|djs.model.Base} element
 * @param  {string} marker
 */
Canvas.prototype.hasMarker = function(element, marker) {
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }

  var gfx = this.getGraphics(element);

  return (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).has(marker);
};

/**
 * Toggles a marker on an element.
 *
 * Fires the element.marker.update event, making it possible to
 * integrate extension into the marker life-cycle, too.
 *
 * @param  {string|djs.model.Base} element
 * @param  {string} marker
 */
Canvas.prototype.toggleMarker = function(element, marker) {
  if (this.hasMarker(element, marker)) {
    this.removeMarker(element, marker);
  } else {
    this.addMarker(element, marker);
  }
};

Canvas.prototype.getRootElement = function() {
  if (!this._rootElement) {
    this.setRootElement({ id: '__implicitroot', children: [] });
  }

  return this._rootElement;
};



// root element handling //////////////////////

/**
 * Sets a given element as the new root element for the canvas
 * and returns the new root element.
 *
 * @param {Object|djs.model.Root} element
 * @param {boolean} [override] whether to override the current root element, if any
 *
 * @return {Object|djs.model.Root} new root element
 */
Canvas.prototype.setRootElement = function(element, override) {

  if (element) {
    this._ensureValid('root', element);
  }

  var currentRoot = this._rootElement,
      elementRegistry = this._elementRegistry,
      eventBus = this._eventBus;

  if (currentRoot) {
    if (!override) {
      throw new Error('rootElement already set, need to specify override');
    }

    // simulate element remove event sequence
    eventBus.fire('root.remove', { element: currentRoot });
    eventBus.fire('root.removed', { element: currentRoot });

    elementRegistry.remove(currentRoot);
  }

  if (element) {
    var gfx = this.getDefaultLayer();

    // resemble element add event sequence
    eventBus.fire('root.add', { element: element });

    elementRegistry.add(element, gfx, this._svg);

    eventBus.fire('root.added', { element: element, gfx: gfx });
  }

  this._rootElement = element;

  return element;
};



// add functionality //////////////////////

Canvas.prototype._ensureValid = function(type, element) {
  if (!element.id) {
    throw new Error('element must have an id');
  }

  if (this._elementRegistry.get(element.id)) {
    throw new Error('element with id ' + element.id + ' already exists');
  }

  var requiredAttrs = REQUIRED_MODEL_ATTRS[type];

  var valid = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.every)(requiredAttrs, function(attr) {
    return typeof element[attr] !== 'undefined';
  });

  if (!valid) {
    throw new Error(
      'must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);
  }
};

Canvas.prototype._setParent = function(element, parent, parentIndex) {
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_3__.add)(parent.children, element, parentIndex);
  element.parent = parent;
};

/**
 * Adds an element to the canvas.
 *
 * This wires the parent <-> child relationship between the element and
 * a explicitly specified parent or an implicit root element.
 *
 * During add it emits the events
 *
 *  * <{type}.add> (element, parent)
 *  * <{type}.added> (element, gfx)
 *
 * Extensions may hook into these events to perform their magic.
 *
 * @param {string} type
 * @param {Object|djs.model.Base} element
 * @param {Object|djs.model.Base} [parent]
 * @param {number} [parentIndex]
 *
 * @return {Object|djs.model.Base} the added element
 */
Canvas.prototype._addElement = function(type, element, parent, parentIndex) {

  parent = parent || this.getRootElement();

  var eventBus = this._eventBus,
      graphicsFactory = this._graphicsFactory;

  this._ensureValid(type, element);

  eventBus.fire(type + '.add', { element: element, parent: parent });

  this._setParent(element, parent, parentIndex);

  // create graphics
  var gfx = graphicsFactory.create(type, element, parentIndex);

  this._elementRegistry.add(element, gfx);

  // update its visual
  graphicsFactory.update(type, element, gfx);

  eventBus.fire(type + '.added', { element: element, gfx: gfx });

  return element;
};

/**
 * Adds a shape to the canvas
 *
 * @param {Object|djs.model.Shape} shape to add to the diagram
 * @param {djs.model.Base} [parent]
 * @param {number} [parentIndex]
 *
 * @return {djs.model.Shape} the added shape
 */
Canvas.prototype.addShape = function(shape, parent, parentIndex) {
  return this._addElement('shape', shape, parent, parentIndex);
};

/**
 * Adds a connection to the canvas
 *
 * @param {Object|djs.model.Connection} connection to add to the diagram
 * @param {djs.model.Base} [parent]
 * @param {number} [parentIndex]
 *
 * @return {djs.model.Connection} the added connection
 */
Canvas.prototype.addConnection = function(connection, parent, parentIndex) {
  return this._addElement('connection', connection, parent, parentIndex);
};


/**
 * Internal remove element
 */
Canvas.prototype._removeElement = function(element, type) {

  var elementRegistry = this._elementRegistry,
      graphicsFactory = this._graphicsFactory,
      eventBus = this._eventBus;

  element = elementRegistry.get(element.id || element);

  if (!element) {

    // element was removed already
    return;
  }

  eventBus.fire(type + '.remove', { element: element });

  graphicsFactory.remove(element);

  // unset parent <-> child relationship
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_3__.remove)(element.parent && element.parent.children, element);
  element.parent = null;

  eventBus.fire(type + '.removed', { element: element });

  elementRegistry.remove(element);

  return element;
};


/**
 * Removes a shape from the canvas
 *
 * @param {string|djs.model.Shape} shape or shape id to be removed
 *
 * @return {djs.model.Shape} the removed shape
 */
Canvas.prototype.removeShape = function(shape) {

  /**
   * An event indicating that a shape is about to be removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event shape.remove
   * @type {Object}
   * @property {djs.model.Shape} element the shape descriptor
   * @property {Object} gfx the graphical representation of the shape
   */

  /**
   * An event indicating that a shape has been removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event shape.removed
   * @type {Object}
   * @property {djs.model.Shape} element the shape descriptor
   * @property {Object} gfx the graphical representation of the shape
   */
  return this._removeElement(shape, 'shape');
};


/**
 * Removes a connection from the canvas
 *
 * @param {string|djs.model.Connection} connection or connection id to be removed
 *
 * @return {djs.model.Connection} the removed connection
 */
Canvas.prototype.removeConnection = function(connection) {

  /**
   * An event indicating that a connection is about to be removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event connection.remove
   * @type {Object}
   * @property {djs.model.Connection} element the connection descriptor
   * @property {Object} gfx the graphical representation of the connection
   */

  /**
   * An event indicating that a connection has been removed from the canvas.
   *
   * @memberOf Canvas
   *
   * @event connection.removed
   * @type {Object}
   * @property {djs.model.Connection} element the connection descriptor
   * @property {Object} gfx the graphical representation of the connection
   */
  return this._removeElement(connection, 'connection');
};


/**
 * Return the graphical object underlaying a certain diagram element
 *
 * @param {string|djs.model.Base} element descriptor of the element
 * @param {boolean} [secondary=false] whether to return the secondary connected element
 *
 * @return {SVGElement}
 */
Canvas.prototype.getGraphics = function(element, secondary) {
  return this._elementRegistry.getGraphics(element, secondary);
};


/**
 * Perform a viewbox update via a given change function.
 *
 * @param {Function} changeFn
 */
Canvas.prototype._changeViewbox = function(changeFn) {

  // notify others of the upcoming viewbox change
  this._eventBus.fire('canvas.viewbox.changing');

  // perform actual change
  changeFn.apply(this);

  // reset the cached viewbox so that
  // a new get operation on viewbox or zoom
  // triggers a viewbox re-computation
  this._cachedViewbox = null;

  // notify others of the change; this step
  // may or may not be debounced
  this._viewboxChanged();
};

Canvas.prototype._viewboxChanged = function() {
  this._eventBus.fire('canvas.viewbox.changed', { viewbox: this.viewbox() });
};


/**
 * Gets or sets the view box of the canvas, i.e. the
 * area that is currently displayed.
 *
 * The getter may return a cached viewbox (if it is currently
 * changing). To force a recomputation, pass `false` as the first argument.
 *
 * @example
 *
 * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })
 *
 * // sets the visible area of the diagram to (100|100) -> (600|100)
 * // and and scales it according to the diagram width
 *
 * var viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.
 *
 * console.log(viewbox);
 * // {
 * //   inner: Dimensions,
 * //   outer: Dimensions,
 * //   scale,
 * //   x, y,
 * //   width, height
 * // }
 *
 * // if the current diagram is zoomed and scrolled, you may reset it to the
 * // default zoom via this method, too:
 *
 * var zoomedAndScrolledViewbox = canvas.viewbox();
 *
 * canvas.viewbox({
 *   x: 0,
 *   y: 0,
 *   width: zoomedAndScrolledViewbox.outer.width,
 *   height: zoomedAndScrolledViewbox.outer.height
 * });
 *
 * @param  {Object} [box] the new view box to set
 * @param  {number} box.x the top left X coordinate of the canvas visible in view box
 * @param  {number} box.y the top left Y coordinate of the canvas visible in view box
 * @param  {number} box.width the visible width
 * @param  {number} box.height
 *
 * @return {Object} the current view box
 */
Canvas.prototype.viewbox = function(box) {

  if (box === undefined && this._cachedViewbox) {
    return this._cachedViewbox;
  }

  var viewport = this._viewport,
      innerBox,
      outerBox = this.getSize(),
      matrix,
      transform,
      scale,
      x, y;

  if (!box) {

    // compute the inner box based on the
    // diagrams default layer. This allows us to exclude
    // external components, such as overlays
    innerBox = this.getDefaultLayer().getBBox();

    transform = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.transform)(viewport);
    matrix = transform ? transform.matrix : (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.createMatrix)();
    scale = round(matrix.a, 1000);

    x = round(-matrix.e || 0, 1000);
    y = round(-matrix.f || 0, 1000);

    box = this._cachedViewbox = {
      x: x ? x / scale : 0,
      y: y ? y / scale : 0,
      width: outerBox.width / scale,
      height: outerBox.height / scale,
      scale: scale,
      inner: {
        width: innerBox.width,
        height: innerBox.height,
        x: innerBox.x,
        y: innerBox.y
      },
      outer: outerBox
    };

    return box;
  } else {

    this._changeViewbox(function() {
      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);

      var matrix = this._svg.createSVGMatrix()
        .scale(scale)
        .translate(-box.x, -box.y);

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.transform)(viewport, matrix);
    });
  }

  return box;
};


/**
 * Gets or sets the scroll of the canvas.
 *
 * @param {Object} [delta] the new scroll to apply.
 *
 * @param {number} [delta.dx]
 * @param {number} [delta.dy]
 */
Canvas.prototype.scroll = function(delta) {

  var node = this._viewport;
  var matrix = node.getCTM();

  if (delta) {
    this._changeViewbox(function() {
      delta = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({ dx: 0, dy: 0 }, delta || {});

      matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);

      setCTM(node, matrix);
    });
  }

  return { x: matrix.e, y: matrix.f };
};


/**
 * Gets or sets the current zoom of the canvas, optionally zooming
 * to the specified position.
 *
 * The getter may return a cached zoom level. Call it with `false` as
 * the first argument to force recomputation of the current level.
 *
 * @param {string|number} [newScale] the new zoom level, either a number, i.e. 0.9,
 *                                   or `fit-viewport` to adjust the size to fit the current viewport
 * @param {string|Point} [center] the reference point { x: .., y: ..} to zoom to, 'auto' to zoom into mid or null
 *
 * @return {number} the current scale
 */
Canvas.prototype.zoom = function(newScale, center) {

  if (!newScale) {
    return this.viewbox(newScale).scale;
  }

  if (newScale === 'fit-viewport') {
    return this._fitViewport(center);
  }

  var outer,
      matrix;

  this._changeViewbox(function() {

    if (typeof center !== 'object') {
      outer = this.viewbox().outer;

      center = {
        x: outer.width / 2,
        y: outer.height / 2
      };
    }

    matrix = this._setZoom(newScale, center);
  });

  return round(matrix.a, 1000);
};

function setCTM(node, m) {
  var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';
  node.setAttribute('transform', mstr);
}

Canvas.prototype._fitViewport = function(center) {

  var vbox = this.viewbox(),
      outer = vbox.outer,
      inner = vbox.inner,
      newScale,
      newViewbox;

  // display the complete diagram without zooming in.
  // instead of relying on internal zoom, we perform a
  // hard reset on the canvas viewbox to realize this
  //
  // if diagram does not need to be zoomed in, we focus it around
  // the diagram origin instead

  if (inner.x >= 0 &&
      inner.y >= 0 &&
      inner.x + inner.width <= outer.width &&
      inner.y + inner.height <= outer.height &&
      !center) {

    newViewbox = {
      x: 0,
      y: 0,
      width: Math.max(inner.width + inner.x, outer.width),
      height: Math.max(inner.height + inner.y, outer.height)
    };
  } else {

    newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);
    newViewbox = {
      x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),
      y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),
      width: outer.width / newScale,
      height: outer.height / newScale
    };
  }

  this.viewbox(newViewbox);

  return this.viewbox(false).scale;
};


Canvas.prototype._setZoom = function(scale, center) {

  var svg = this._svg,
      viewport = this._viewport;

  var matrix = svg.createSVGMatrix();
  var point = svg.createSVGPoint();

  var centerPoint,
      originalPoint,
      currentMatrix,
      scaleMatrix,
      newMatrix;

  currentMatrix = viewport.getCTM();

  var currentScale = currentMatrix.a;

  if (center) {
    centerPoint = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(point, center);

    // revert applied viewport transformations
    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());

    // create scale matrix
    scaleMatrix = matrix
      .translate(originalPoint.x, originalPoint.y)
      .scale(1 / currentScale * scale)
      .translate(-originalPoint.x, -originalPoint.y);

    newMatrix = currentMatrix.multiply(scaleMatrix);
  } else {
    newMatrix = matrix.scale(scale);
  }

  setCTM(this._viewport, newMatrix);

  return newMatrix;
};


/**
 * Returns the size of the canvas
 *
 * @return {Dimensions}
 */
Canvas.prototype.getSize = function() {
  return {
    width: this._container.clientWidth,
    height: this._container.clientHeight
  };
};


/**
 * Return the absolute bounding box for the given element
 *
 * The absolute bounding box may be used to display overlays in the
 * callers (browser) coordinate system rather than the zoomed in/out
 * canvas coordinates.
 *
 * @param  {ElementDescriptor} element
 * @return {Bounds} the absolute bounding box
 */
Canvas.prototype.getAbsoluteBBox = function(element) {
  var vbox = this.viewbox();
  var bbox;

  // connection
  // use svg bbox
  if (element.waypoints) {
    var gfx = this.getGraphics(element);

    bbox = gfx.getBBox();
  }

  // shapes
  // use data
  else {
    bbox = element;
  }

  var x = bbox.x * vbox.scale - vbox.x * vbox.scale;
  var y = bbox.y * vbox.scale - vbox.y * vbox.scale;

  var width = bbox.width * vbox.scale;
  var height = bbox.height * vbox.scale;

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
};

/**
 * Fires an event in order other modules can react to the
 * canvas resizing
 */
Canvas.prototype.resized = function() {

  // force recomputation of view box
  delete this._cachedViewbox;

  this._eventBus.fire('canvas.resized');
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/ElementFactory.js":
/*!************************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/ElementFactory.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementFactory)
/* harmony export */ });
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model */ "./node_modules/diagram-js/lib/model/index.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");




/**
 * A factory for diagram-js shapes
 */
function ElementFactory() {
  this._uid = 12;
}


ElementFactory.prototype.createRoot = function(attrs) {
  return this.create('root', attrs);
};

ElementFactory.prototype.createLabel = function(attrs) {
  return this.create('label', attrs);
};

ElementFactory.prototype.createShape = function(attrs) {
  return this.create('shape', attrs);
};

ElementFactory.prototype.createConnection = function(attrs) {
  return this.create('connection', attrs);
};

/**
 * Create a model element with the given type and
 * a number of pre-set attributes.
 *
 * @param  {string} type
 * @param  {Object} attrs
 * @return {djs.model.Base} the newly created model instance
 */
ElementFactory.prototype.create = function(type, attrs) {

  attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, attrs || {});

  if (!attrs.id) {
    attrs.id = type + '_' + (this._uid++);
  }

  return (0,_model__WEBPACK_IMPORTED_MODULE_1__.create)(type, attrs);
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/core/ElementRegistry.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/ElementRegistry.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementRegistry)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
var ELEMENT_ID = 'data-element-id';




/**
 * @class
 *
 * A registry that keeps track of all shapes in the diagram.
 */
function ElementRegistry(eventBus) {
  this._elements = {};

  this._eventBus = eventBus;
}

ElementRegistry.$inject = [ 'eventBus' ];

/**
 * Register a pair of (element, gfx, (secondaryGfx)).
 *
 * @param {djs.model.Base} element
 * @param {SVGElement} gfx
 * @param {SVGElement} [secondaryGfx] optional other element to register, too
 */
ElementRegistry.prototype.add = function(element, gfx, secondaryGfx) {

  var id = element.id;

  this._validateId(id);

  // associate dom node with element
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(gfx, ELEMENT_ID, id);

  if (secondaryGfx) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(secondaryGfx, ELEMENT_ID, id);
  }

  this._elements[id] = { element: element, gfx: gfx, secondaryGfx: secondaryGfx };
};

/**
 * Removes an element from the registry.
 *
 * @param {djs.model.Base} element
 */
ElementRegistry.prototype.remove = function(element) {
  var elements = this._elements,
      id = element.id || element,
      container = id && elements[id];

  if (container) {

    // unset element id on gfx
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(container.gfx, ELEMENT_ID, '');

    if (container.secondaryGfx) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(container.secondaryGfx, ELEMENT_ID, '');
    }

    delete elements[id];
  }
};

/**
 * Update the id of an element
 *
 * @param {djs.model.Base} element
 * @param {string} newId
 */
ElementRegistry.prototype.updateId = function(element, newId) {

  this._validateId(newId);

  if (typeof element === 'string') {
    element = this.get(element);
  }

  this._eventBus.fire('element.updateId', {
    element: element,
    newId: newId
  });

  var gfx = this.getGraphics(element),
      secondaryGfx = this.getGraphics(element, true);

  this.remove(element);

  element.id = newId;

  this.add(element, gfx, secondaryGfx);
};

/**
 * Return the model element for a given id or graphics.
 *
 * @example
 *
 * elementRegistry.get('SomeElementId_1');
 * elementRegistry.get(gfx);
 *
 *
 * @param {string|SVGElement} filter for selecting the element
 *
 * @return {djs.model.Base}
 */
ElementRegistry.prototype.get = function(filter) {
  var id;

  if (typeof filter === 'string') {
    id = filter;
  } else {
    id = filter && (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(filter, ELEMENT_ID);
  }

  var container = this._elements[id];
  return container && container.element;
};

/**
 * Return all elements that match a given filter function.
 *
 * @param {Function} fn
 *
 * @return {Array<djs.model.Base>}
 */
ElementRegistry.prototype.filter = function(fn) {

  var filtered = [];

  this.forEach(function(element, gfx) {
    if (fn(element, gfx)) {
      filtered.push(element);
    }
  });

  return filtered;
};

/**
 * Return the first element that satisfies the provided testing function.
 *
 * @param {Function} fn
 *
 * @return {djs.model.Base}
 */
ElementRegistry.prototype.find = function(fn) {
  var map = this._elements,
      keys = Object.keys(map);

  for (var i = 0; i < keys.length; i++) {
    var id = keys[i],
        container = map[id],
        element = container.element,
        gfx = container.gfx;

    if (fn(element, gfx)) {
      return element;
    }
  }
};

/**
 * Return all rendered model elements.
 *
 * @return {Array<djs.model.Base>}
 */
ElementRegistry.prototype.getAll = function() {
  return this.filter(function(e) { return e; });
};

/**
 * Iterate over all diagram elements.
 *
 * @param {Function} fn
 */
ElementRegistry.prototype.forEach = function(fn) {

  var map = this._elements;

  Object.keys(map).forEach(function(id) {
    var container = map[id],
        element = container.element,
        gfx = container.gfx;

    return fn(element, gfx);
  });
};

/**
 * Return the graphical representation of an element or its id.
 *
 * @example
 * elementRegistry.getGraphics('SomeElementId_1');
 * elementRegistry.getGraphics(rootElement); // <g ...>
 *
 * elementRegistry.getGraphics(rootElement, true); // <svg ...>
 *
 *
 * @param {string|djs.model.Base} filter
 * @param {boolean} [secondary=false] whether to return the secondary connected element
 *
 * @return {SVGElement}
 */
ElementRegistry.prototype.getGraphics = function(filter, secondary) {
  var id = filter.id || filter;

  var container = this._elements[id];
  return container && (secondary ? container.secondaryGfx : container.gfx);
};

/**
 * Validate the suitability of the given id and signals a problem
 * with an exception.
 *
 * @param {string} id
 *
 * @throws {Error} if id is empty or already assigned
 */
ElementRegistry.prototype._validateId = function(id) {
  if (!id) {
    throw new Error('element must have an id');
  }

  if (this._elements[id]) {
    throw new Error('element with id ' + id + ' already added');
  }
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/EventBus.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/EventBus.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventBus)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var FN_REF = '__fn';

var DEFAULT_PRIORITY = 1000;

var slice = Array.prototype.slice;

/**
 * A general purpose event bus.
 *
 * This component is used to communicate across a diagram instance.
 * Other parts of a diagram can use it to listen to and broadcast events.
 *
 *
 * ## Registering for Events
 *
 * The event bus provides the {@link EventBus#on} and {@link EventBus#once}
 * methods to register for events. {@link EventBus#off} can be used to
 * remove event registrations. Listeners receive an instance of {@link Event}
 * as the first argument. It allows them to hook into the event execution.
 *
 * ```javascript
 *
 * // listen for event
 * eventBus.on('foo', function(event) {
 *
 *   // access event type
 *   event.type; // 'foo'
 *
 *   // stop propagation to other listeners
 *   event.stopPropagation();
 *
 *   // prevent event default
 *   event.preventDefault();
 * });
 *
 * // listen for event with custom payload
 * eventBus.on('bar', function(event, payload) {
 *   console.log(payload);
 * });
 *
 * // listen for event returning value
 * eventBus.on('foobar', function(event) {
 *
 *   // stop event propagation + prevent default
 *   return false;
 *
 *   // stop event propagation + return custom result
 *   return {
 *     complex: 'listening result'
 *   };
 * });
 *
 *
 * // listen with custom priority (default=1000, higher is better)
 * eventBus.on('priorityfoo', 1500, function(event) {
 *   console.log('invoked first!');
 * });
 *
 *
 * // listen for event and pass the context (`this`)
 * eventBus.on('foobar', function(event) {
 *   this.foo();
 * }, this);
 * ```
 *
 *
 * ## Emitting Events
 *
 * Events can be emitted via the event bus using {@link EventBus#fire}.
 *
 * ```javascript
 *
 * // false indicates that the default action
 * // was prevented by listeners
 * if (eventBus.fire('foo') === false) {
 *   console.log('default has been prevented!');
 * };
 *
 *
 * // custom args + return value listener
 * eventBus.on('sum', function(event, a, b) {
 *   return a + b;
 * });
 *
 * // you can pass custom arguments + retrieve result values.
 * var sum = eventBus.fire('sum', 1, 2);
 * console.log(sum); // 3
 * ```
 */
function EventBus() {
  this._listeners = {};

  // cleanup on destroy on lowest priority to allow
  // message passing until the bitter end
  this.on('diagram.destroy', 1, this._destroy, this);
}


/**
 * Register an event listener for events with the given name.
 *
 * The callback will be invoked with `event, ...additionalArguments`
 * that have been passed to {@link EventBus#fire}.
 *
 * Returning false from a listener will prevent the events default action
 * (if any is specified). To stop an event from being processed further in
 * other listeners execute {@link Event#stopPropagation}.
 *
 * Returning anything but `undefined` from a listener will stop the listener propagation.
 *
 * @param {string|Array<string>} events
 * @param {number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback
 * @param {Object} [that] Pass context (`this`) to the callback
 */
EventBus.prototype.on = function(events, priority, callback, that) {

  events = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(events) ? events : [ events ];

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY;
  }

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(priority)) {
    throw new Error('priority must be a number');
  }

  var actualCallback = callback;

  if (that) {
    actualCallback = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(callback, that);

    // make sure we remember and are able to remove
    // bound callbacks via {@link #off} using the original
    // callback
    actualCallback[FN_REF] = callback[FN_REF] || callback;
  }

  var self = this;

  events.forEach(function(e) {
    self._addListener(e, {
      priority: priority,
      callback: actualCallback,
      next: null
    });
  });
};


/**
 * Register an event listener that is executed only once.
 *
 * @param {string} event the event name to register for
 * @param {number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback the callback to execute
 * @param {Object} [that] Pass context (`this`) to the callback
 */
EventBus.prototype.once = function(event, priority, callback, that) {
  var self = this;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY;
  }

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(priority)) {
    throw new Error('priority must be a number');
  }

  function wrappedCallback() {
    wrappedCallback.__isTomb = true;

    var result = callback.apply(that, arguments);

    self.off(event, wrappedCallback);

    return result;
  }

  // make sure we remember and are able to remove
  // bound callbacks via {@link #off} using the original
  // callback
  wrappedCallback[FN_REF] = callback;

  this.on(event, priority, wrappedCallback);
};


/**
 * Removes event listeners by event and callback.
 *
 * If no callback is given, all listeners for a given event name are being removed.
 *
 * @param {string|Array<string>} events
 * @param {Function} [callback]
 */
EventBus.prototype.off = function(events, callback) {

  events = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(events) ? events : [ events ];

  var self = this;

  events.forEach(function(event) {
    self._removeListener(event, callback);
  });

};


/**
 * Create an EventBus event.
 *
 * @param {Object} data
 *
 * @return {Object} event, recognized by the eventBus
 */
EventBus.prototype.createEvent = function(data) {
  var event = new InternalEvent();

  event.init(data);

  return event;
};


/**
 * Fires a named event.
 *
 * @example
 *
 * // fire event by name
 * events.fire('foo');
 *
 * // fire event object with nested type
 * var event = { type: 'foo' };
 * events.fire(event);
 *
 * // fire event with explicit type
 * var event = { x: 10, y: 20 };
 * events.fire('element.moved', event);
 *
 * // pass additional arguments to the event
 * events.on('foo', function(event, bar) {
 *   alert(bar);
 * });
 *
 * events.fire({ type: 'foo' }, 'I am bar!');
 *
 * @param {string} [name] the optional event name
 * @param {Object} [event] the event object
 * @param {...Object} additional arguments to be passed to the callback functions
 *
 * @return {boolean} the events return value, if specified or false if the
 *                   default action was prevented by listeners
 */
EventBus.prototype.fire = function(type, data) {
  var event,
      firstListener,
      returnValue,
      args;

  args = slice.call(arguments);

  if (typeof type === 'object') {
    data = type;
    type = data.type;
  }

  if (!type) {
    throw new Error('no event type specified');
  }

  firstListener = this._listeners[type];

  if (!firstListener) {
    return;
  }

  // we make sure we fire instances of our home made
  // events here. We wrap them only once, though
  if (data instanceof InternalEvent) {

    // we are fine, we alread have an event
    event = data;
  } else {
    event = this.createEvent(data);
  }

  // ensure we pass the event as the first parameter
  args[0] = event;

  // original event type (in case we delegate)
  var originalType = event.type;

  // update event type before delegation
  if (type !== originalType) {
    event.type = type;
  }

  try {
    returnValue = this._invokeListeners(event, args, firstListener);
  } finally {

    // reset event type after delegation
    if (type !== originalType) {
      event.type = originalType;
    }
  }

  // set the return value to false if the event default
  // got prevented and no other return value exists
  if (returnValue === undefined && event.defaultPrevented) {
    returnValue = false;
  }

  return returnValue;
};


EventBus.prototype.handleError = function(error) {
  return this.fire('error', { error: error }) === false;
};


EventBus.prototype._destroy = function() {
  this._listeners = {};
};

EventBus.prototype._invokeListeners = function(event, args, listener) {

  var returnValue;

  while (listener) {

    // handle stopped propagation
    if (event.cancelBubble) {
      break;
    }

    returnValue = this._invokeListener(event, args, listener);

    listener = listener.next;
  }

  return returnValue;
};

EventBus.prototype._invokeListener = function(event, args, listener) {

  var returnValue;

  if (listener.callback.__isTomb) {
    return returnValue;
  }

  try {

    // returning false prevents the default action
    returnValue = invokeFunction(listener.callback, args);

    // stop propagation on return value
    if (returnValue !== undefined) {
      event.returnValue = returnValue;
      event.stopPropagation();
    }

    // prevent default on return false
    if (returnValue === false) {
      event.preventDefault();
    }
  } catch (e) {
    if (!this.handleError(e)) {
      console.error('unhandled error in event listener');
      console.error(e.stack);

      throw e;
    }
  }

  return returnValue;
};

/*
 * Add new listener with a certain priority to the list
 * of listeners (for the given event).
 *
 * The semantics of listener registration / listener execution are
 * first register, first serve: New listeners will always be inserted
 * after existing listeners with the same priority.
 *
 * Example: Inserting two listeners with priority 1000 and 1300
 *
 *    * before: [ 1500, 1500, 1000, 1000 ]
 *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]
 *
 * @param {string} event
 * @param {Object} listener { priority, callback }
 */
EventBus.prototype._addListener = function(event, newListener) {

  var listener = this._getListeners(event),
      previousListener;

  // no prior listeners
  if (!listener) {
    this._setListeners(event, newListener);

    return;
  }

  // ensure we order listeners by priority from
  // 0 (high) to n > 0 (low)
  while (listener) {

    if (listener.priority < newListener.priority) {

      newListener.next = listener;

      if (previousListener) {
        previousListener.next = newListener;
      } else {
        this._setListeners(event, newListener);
      }

      return;
    }

    previousListener = listener;
    listener = listener.next;
  }

  // add new listener to back
  previousListener.next = newListener;
};


EventBus.prototype._getListeners = function(name) {
  return this._listeners[name];
};

EventBus.prototype._setListeners = function(name, listener) {
  this._listeners[name] = listener;
};

EventBus.prototype._removeListener = function(event, callback) {

  var listener = this._getListeners(event),
      nextListener,
      previousListener,
      listenerCallback;

  if (!callback) {

    // clear listeners
    this._setListeners(event, null);

    return;
  }

  while (listener) {

    nextListener = listener.next;

    listenerCallback = listener.callback;

    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
      if (previousListener) {
        previousListener.next = nextListener;
      } else {

        // new first listener
        this._setListeners(event, nextListener);
      }
    }

    previousListener = listener;
    listener = nextListener;
  }
};

/**
 * A event that is emitted via the event bus.
 */
function InternalEvent() { }

InternalEvent.prototype.stopPropagation = function() {
  this.cancelBubble = true;
};

InternalEvent.prototype.preventDefault = function() {
  this.defaultPrevented = true;
};

InternalEvent.prototype.init = function(data) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(this, data || {});
};


/**
 * Invoke function. Be fast...
 *
 * @param {Function} fn
 * @param {Array<Object>} args
 *
 * @return {Any}
 */
function invokeFunction(fn, args) {
  return fn.apply(null, args);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/GraphicsFactory.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/GraphicsFactory.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GraphicsFactory)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/GraphicsUtil */ "./node_modules/diagram-js/lib/util/GraphicsUtil.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");












/**
 * A factory that creates graphical elements
 *
 * @param {EventBus} eventBus
 * @param {ElementRegistry} elementRegistry
 */
function GraphicsFactory(eventBus, elementRegistry) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
}

GraphicsFactory.$inject = [ 'eventBus' , 'elementRegistry' ];


GraphicsFactory.prototype._getChildrenContainer = function(element) {

  var gfx = this._elementRegistry.getGraphics(element);

  var childrenGfx;

  // root element
  if (!element.parent) {
    childrenGfx = gfx;
  } else {
    childrenGfx = (0,_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_0__.getChildren)(gfx);
    if (!childrenGfx) {
      childrenGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(childrenGfx).add('djs-children');

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(gfx.parentNode, childrenGfx);
    }
  }

  return childrenGfx;
};

/**
 * Clears the graphical representation of the element and returns the
 * cleared visual (the <g class="djs-visual" /> element).
 */
GraphicsFactory.prototype._clear = function(gfx) {
  var visual = (0,_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_0__.getVisual)(gfx);

  (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.clear)(visual);

  return visual;
};

/**
 * Creates a gfx container for shapes and connections
 *
 * The layout is as follows:
 *
 * <g class="djs-group">
 *
 *   <!-- the gfx -->
 *   <g class="djs-element djs-(shape|connection|frame)">
 *     <g class="djs-visual">
 *       <!-- the renderer draws in here -->
 *     </g>
 *
 *     <!-- extensions (overlays, click box, ...) goes here
 *   </g>
 *
 *   <!-- the gfx child nodes -->
 *   <g class="djs-children"></g>
 * </g>
 *
 * @param {string} type the type of the element, i.e. shape | connection
 * @param {SVGElement} [childrenGfx]
 * @param {number} [parentIndex] position to create container in parent
 * @param {boolean} [isFrame] is frame element
 *
 * @return {SVGElement}
 */
GraphicsFactory.prototype._createContainer = function(
    type, childrenGfx, parentIndex, isFrame
) {
  var outerGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(outerGfx).add('djs-group');

  // insert node at position
  if (typeof parentIndex !== 'undefined') {
    prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);
  } else {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(childrenGfx, outerGfx);
  }

  var gfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).add('djs-element');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).add('djs-' + type);

  if (isFrame) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(gfx).add('djs-frame');
  }

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(outerGfx, gfx);

  // create visual
  var visual = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(visual).add('djs-visual');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(gfx, visual);

  return gfx;
};

GraphicsFactory.prototype.create = function(type, element, parentIndex) {
  var childrenGfx = this._getChildrenContainer(element.parent);
  return this._createContainer(type, childrenGfx, parentIndex, (0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.isFrameElement)(element));
};

GraphicsFactory.prototype.updateContainments = function(elements) {

  var self = this,
      elementRegistry = this._elementRegistry,
      parents;

  parents = (0,min_dash__WEBPACK_IMPORTED_MODULE_4__.reduce)(elements, function(map, e) {

    if (e.parent) {
      map[e.parent.id] = e.parent;
    }

    return map;
  }, {});

  // update all parents of changed and reorganized their children
  // in the correct order (as indicated in our model)
  (0,min_dash__WEBPACK_IMPORTED_MODULE_4__.forEach)(parents, function(parent) {

    var children = parent.children;

    if (!children) {
      return;
    }

    var childrenGfx = self._getChildrenContainer(parent);

    (0,min_dash__WEBPACK_IMPORTED_MODULE_4__.forEach)(children.slice().reverse(), function(child) {
      var childGfx = elementRegistry.getGraphics(child);

      prependTo(childGfx.parentNode, childrenGfx);
    });
  });
};

GraphicsFactory.prototype.drawShape = function(visual, element) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.shape', { gfx: visual, element: element });
};

GraphicsFactory.prototype.getShapePath = function(element) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.getShapePath', element);
};

GraphicsFactory.prototype.drawConnection = function(visual, element) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.connection', { gfx: visual, element: element });
};

GraphicsFactory.prototype.getConnectionPath = function(waypoints) {
  var eventBus = this._eventBus;

  return eventBus.fire('render.getConnectionPath', waypoints);
};

GraphicsFactory.prototype.update = function(type, element, gfx) {

  // do NOT update root element
  if (!element.parent) {
    return;
  }

  var visual = this._clear(gfx);

  // redraw
  if (type === 'shape') {
    this.drawShape(visual, element);

    // update positioning
    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__.translate)(gfx, element.x, element.y);
  } else
  if (type === 'connection') {
    this.drawConnection(visual, element);
  } else {
    throw new Error('unknown type: ' + type);
  }

  if (element.hidden) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(gfx, 'display', 'none');
  } else {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(gfx, 'display', 'block');
  }
};

GraphicsFactory.prototype.remove = function(element) {
  var gfx = this._elementRegistry.getGraphics(element);

  // remove
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(gfx.parentNode);
};


// helpers //////////

function prependTo(newNode, parentNode, siblingNode) {
  var node = siblingNode || parentNode.firstChild;

  // do not prepend node to itself to prevent IE from crashing
  // https://github.com/bpmn-io/bpmn-js/issues/746
  if (newNode === node) {
    return;
  }

  parentNode.insertBefore(newNode, node);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/core/index.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/core/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../draw */ "./node_modules/diagram-js/lib/draw/index.js");
/* harmony import */ var _Canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Canvas */ "./node_modules/diagram-js/lib/core/Canvas.js");
/* harmony import */ var _ElementRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ElementRegistry */ "./node_modules/diagram-js/lib/core/ElementRegistry.js");
/* harmony import */ var _ElementFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ElementFactory */ "./node_modules/diagram-js/lib/core/ElementFactory.js");
/* harmony import */ var _EventBus__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EventBus */ "./node_modules/diagram-js/lib/core/EventBus.js");
/* harmony import */ var _GraphicsFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GraphicsFactory */ "./node_modules/diagram-js/lib/core/GraphicsFactory.js");








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [ _draw__WEBPACK_IMPORTED_MODULE_0__.default ],
  __init__: [ 'canvas' ],
  canvas: [ 'type', _Canvas__WEBPACK_IMPORTED_MODULE_1__.default ],
  elementRegistry: [ 'type', _ElementRegistry__WEBPACK_IMPORTED_MODULE_2__.default ],
  elementFactory: [ 'type', _ElementFactory__WEBPACK_IMPORTED_MODULE_3__.default ],
  eventBus: [ 'type', _EventBus__WEBPACK_IMPORTED_MODULE_4__.default ],
  graphicsFactory: [ 'type', _GraphicsFactory__WEBPACK_IMPORTED_MODULE_5__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/BaseRenderer.js":
/*!**********************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/BaseRenderer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseRenderer)
/* harmony export */ });
var DEFAULT_RENDER_PRIORITY = 1000;

/**
 * The base implementation of shape and connection renderers.
 *
 * @param {EventBus} eventBus
 * @param {number} [renderPriority=1000]
 */
function BaseRenderer(eventBus, renderPriority) {
  var self = this;

  renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY;

  eventBus.on([ 'render.shape', 'render.connection' ], renderPriority, function(evt, context) {
    var type = evt.type,
        element = context.element,
        visuals = context.gfx;

    if (self.canRender(element)) {
      if (type === 'render.shape') {
        return self.drawShape(visuals, element);
      } else {
        return self.drawConnection(visuals, element);
      }
    }
  });

  eventBus.on([ 'render.getShapePath', 'render.getConnectionPath'], renderPriority, function(evt, element) {
    if (self.canRender(element)) {
      if (evt.type === 'render.getShapePath') {
        return self.getShapePath(element);
      } else {
        return self.getConnectionPath(element);
      }
    }
  });
}

/**
 * Should check whether *this* renderer can render
 * the element/connection.
 *
 * @param {element} element
 *
 * @returns {boolean}
 */
BaseRenderer.prototype.canRender = function() {};

/**
 * Provides the shape's snap svg element to be drawn on the `canvas`.
 *
 * @param {djs.Graphics} visuals
 * @param {Shape} shape
 *
 * @returns {Snap.svg} [returns a Snap.svg paper element ]
 */
BaseRenderer.prototype.drawShape = function() {};

/**
 * Provides the shape's snap svg element to be drawn on the `canvas`.
 *
 * @param {djs.Graphics} visuals
 * @param {Connection} connection
 *
 * @returns {Snap.svg} [returns a Snap.svg paper element ]
 */
BaseRenderer.prototype.drawConnection = function() {};

/**
 * Gets the SVG path of a shape that represents it's visual bounds.
 *
 * @param {Shape} shape
 *
 * @return {string} svg path
 */
BaseRenderer.prototype.getShapePath = function() {};

/**
 * Gets the SVG path of a connection that represents it's visual bounds.
 *
 * @param {Connection} connection
 *
 * @return {string} svg path
 */
BaseRenderer.prototype.getConnectionPath = function() {};


/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/DefaultRenderer.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/DefaultRenderer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DefaultRenderer)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseRenderer */ "./node_modules/diagram-js/lib/draw/BaseRenderer.js");
/* harmony import */ var _util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/RenderUtil */ "./node_modules/diagram-js/lib/util/RenderUtil.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");










// apply default renderer with lowest possible priority
// so that it only kicks in if noone else could render
var DEFAULT_RENDER_PRIORITY = 1;

/**
 * The default renderer used for shapes and connections.
 *
 * @param {EventBus} eventBus
 * @param {Styles} styles
 */
function DefaultRenderer(eventBus, styles) {

  //
  _BaseRenderer__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus, DEFAULT_RENDER_PRIORITY);

  this.CONNECTION_STYLE = styles.style([ 'no-fill' ], { strokeWidth: 5, stroke: 'fuchsia' });
  this.SHAPE_STYLE = styles.style({ fill: 'white', stroke: 'fuchsia', strokeWidth: 2 });
  this.FRAME_STYLE = styles.style([ 'no-fill' ], { stroke: 'fuchsia', strokeDasharray: 4, strokeWidth: 2 });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(DefaultRenderer, _BaseRenderer__WEBPACK_IMPORTED_MODULE_1__.default);


DefaultRenderer.prototype.canRender = function() {
  return true;
};

DefaultRenderer.prototype.drawShape = function drawShape(visuals, element) {
  var rect = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('rect');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(rect, {
    x: 0,
    y: 0,
    width: element.width || 0,
    height: element.height || 0
  });

  if ((0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.isFrameElement)(element)) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(rect, this.FRAME_STYLE);
  } else {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(rect, this.SHAPE_STYLE);
  }

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(visuals, rect);

  return rect;
};

DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection) {

  var line = (0,_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__.createLine)(connection.waypoints, this.CONNECTION_STYLE);
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(visuals, line);

  return line;
};

DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {

  var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;

  var shapePath = [
    ['M', x, y],
    ['l', width, 0],
    ['l', 0, height],
    ['l', -width, 0],
    ['z']
  ];

  return (0,_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__.componentsToPath)(shapePath);
};

DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {
  var waypoints = connection.waypoints;

  var idx, point, connectionPath = [];

  for (idx = 0; (point = waypoints[idx]); idx++) {

    // take invisible docking into account
    // when creating the path
    point = point.original || point;

    connectionPath.push([ idx === 0 ? 'M' : 'L', point.x, point.y ]);
  }

  return (0,_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__.componentsToPath)(connectionPath);
};


DefaultRenderer.$inject = [ 'eventBus', 'styles' ];


/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/Styles.js":
/*!****************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/Styles.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Styles)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A component that manages shape styles
 */
function Styles() {

  var defaultTraits = {

    'no-fill': {
      fill: 'none'
    },
    'no-border': {
      strokeOpacity: 0.0
    },
    'no-events': {
      pointerEvents: 'none'
    }
  };

  var self = this;

  /**
   * Builds a style definition from a className, a list of traits and an object of additional attributes.
   *
   * @param  {string} className
   * @param  {Array<string>} traits
   * @param  {Object} additionalAttrs
   *
   * @return {Object} the style defintion
   */
  this.cls = function(className, traits, additionalAttrs) {
    var attrs = this.style(traits, additionalAttrs);

    return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(attrs, { 'class': className });
  };

  /**
   * Builds a style definition from a list of traits and an object of additional attributes.
   *
   * @param  {Array<string>} traits
   * @param  {Object} additionalAttrs
   *
   * @return {Object} the style defintion
   */
  this.style = function(traits, additionalAttrs) {

    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(traits) && !additionalAttrs) {
      additionalAttrs = traits;
      traits = [];
    }

    var attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(traits, function(attrs, t) {
      return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(attrs, defaultTraits[t] || {});
    }, {});

    return additionalAttrs ? (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(attrs, additionalAttrs) : attrs;
  };

  this.computeStyle = function(custom, traits, defaultStyles) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(traits)) {
      defaultStyles = traits;
      traits = [];
    }

    return self.style(traits || [], (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, defaultStyles, custom || {}));
  };
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/draw/index.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/draw/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DefaultRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultRenderer */ "./node_modules/diagram-js/lib/draw/DefaultRenderer.js");
/* harmony import */ var _Styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Styles */ "./node_modules/diagram-js/lib/draw/Styles.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'defaultRenderer' ],
  defaultRenderer: [ 'type', _DefaultRenderer__WEBPACK_IMPORTED_MODULE_0__.default ],
  styles: [ 'type', _Styles__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/align-elements/AlignElements.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/align-elements/AlignElements.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AlignElements)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


function last(arr) {
  return arr && arr[arr.length - 1];
}

function sortTopOrMiddle(element) {
  return element.y;
}

function sortLeftOrCenter(element) {
  return element.x;
}

/**
 * Sorting functions for different types of alignment
 *
 * @type {Object}
 *
 * @return {Function}
 */
var ALIGNMENT_SORTING = {
  left: sortLeftOrCenter,
  center: sortLeftOrCenter,
  right: function(element) {
    return element.x + element.width;
  },
  top: sortTopOrMiddle,
  middle: sortTopOrMiddle,
  bottom: function(element) {
    return element.y + element.height;
  }
};


function AlignElements(modeling) {
  this._modeling = modeling;
}

AlignElements.$inject = [ 'modeling' ];


/**
 * Get the relevant "axis" and "dimension" related to the current type of alignment
 *
 * @param  {string} type left|right|center|top|bottom|middle
 *
 * @return {Object} { axis, dimension }
 */
AlignElements.prototype._getOrientationDetails = function(type) {
  var vertical = [ 'top', 'bottom', 'middle' ],
      axis = 'x',
      dimension = 'width';

  if (vertical.indexOf(type) !== -1) {
    axis = 'y';
    dimension = 'height';
  }

  return {
    axis: axis,
    dimension: dimension
  };
};

AlignElements.prototype._isType = function(type, types) {
  return types.indexOf(type) !== -1;
};

/**
 * Get a point on the relevant axis where elements should align to
 *
 * @param  {string} type left|right|center|top|bottom|middle
 * @param  {Array} sortedElements
 *
 * @return {Object}
 */
AlignElements.prototype._alignmentPosition = function(type, sortedElements) {
  var orientation = this._getOrientationDetails(type),
      axis = orientation.axis,
      dimension = orientation.dimension,
      alignment = {},
      centers = {},
      hasSharedCenters = false,
      centeredElements,
      firstElement,
      lastElement;

  function getMiddleOrTop(first, last) {
    return Math.round((first[axis] + last[axis] + last[dimension]) / 2);
  }

  if (this._isType(type, [ 'left', 'top' ])) {
    alignment[type] = sortedElements[0][axis];

  } else if (this._isType(type, [ 'right', 'bottom' ])) {
    lastElement = last(sortedElements);

    alignment[type] = lastElement[axis] + lastElement[dimension];

  } else if (this._isType(type, [ 'center', 'middle' ])) {

    // check if there is a center shared by more than one shape
    // if not, just take the middle of the range
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(sortedElements, function(element) {
      var center = element[axis] + Math.round(element[dimension] / 2);

      if (centers[center]) {
        centers[center].elements.push(element);
      } else {
        centers[center] = {
          elements: [ element ],
          center: center
        };
      }
    });

    centeredElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(centers, function(center) {
      if (center.elements.length > 1) {
        hasSharedCenters = true;
      }

      return center.elements.length;
    });

    if (hasSharedCenters) {
      alignment[type] = last(centeredElements).center;

      return alignment;
    }

    firstElement = sortedElements[0];

    sortedElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(sortedElements, function(element) {
      return element[axis] + element[dimension];
    });

    lastElement = last(sortedElements);

    alignment[type] = getMiddleOrTop(firstElement, lastElement);
  }

  return alignment;
};

/**
 * Executes the alignment of a selection of elements
 *
 * @param  {Array} elements [description]
 * @param  {string} type left|right|center|top|bottom|middle
 */
AlignElements.prototype.trigger = function(elements, type) {
  var modeling = this._modeling;

  var filteredElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.filter)(elements, function(element) {
    return !(element.waypoints || element.host || element.labelTarget);
  });

  if (filteredElements.length < 2) {
    return;
  }

  var sortFn = ALIGNMENT_SORTING[type];

  var sortedElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(filteredElements, sortFn);

  var alignment = this._alignmentPosition(type, sortedElements);

  modeling.alignElements(sortedElements, alignment);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/align-elements/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/align-elements/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AlignElements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignElements */ "./node_modules/diagram-js/lib/features/align-elements/AlignElements.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'alignElements' ],
  alignElements: [ 'type', _AlignElements__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/attach-support/AttachSupport.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/attach-support/AttachSupport.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AttachSupport)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Removal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Removal */ "./node_modules/diagram-js/lib/util/Removal.js");
/* harmony import */ var _util_AttachUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/AttachUtil */ "./node_modules/diagram-js/lib/util/AttachUtil.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");










var LOW_PRIORITY = 251,
    HIGH_PRIORITY = 1401;

var MARKER_ATTACH = 'attach-ok';


/**
 * Adds the notion of attached elements to the modeler.
 *
 * Optionally depends on `diagram-js/lib/features/move` to render
 * the attached elements during move preview.
 *
 * Optionally depends on `diagram-js/lib/features/label-support`
 * to render attached labels during move preview.
 *
 * @param {didi.Injector} injector
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {Rules} rules
 * @param {Modeling} modeling
 */
function AttachSupport(injector, eventBus, canvas, rules, modeling) {

  _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  var movePreview = injector.get('movePreview', false);


  // remove all the attached elements from the shapes to be validated
  // add all the attached shapes to the overall list of moved shapes
  eventBus.on('shape.move.start', HIGH_PRIORITY, function(e) {

    var context = e.context,
        shapes = context.shapes,
        validatedShapes = context.validatedShapes;

    context.shapes = addAttached(shapes);

    context.validatedShapes = removeAttached(validatedShapes);
  });

  // add attachers to the visual's group
  movePreview && eventBus.on('shape.move.start', LOW_PRIORITY, function(e) {

    var context = e.context,
        shapes = context.shapes,
        attachers = getAttachers(shapes);

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attachers, function(attacher) {
      movePreview.makeDraggable(context, attacher, true);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attacher.labels, function(label) {
        movePreview.makeDraggable(context, label, true);
      });
    });
  });

  // add attach-ok marker to current host
  movePreview && eventBus.on('shape.move.start', function(event) {
    var context = event.context,
        shapes = context.shapes;

    if (shapes.length !== 1) {
      return;
    }

    var shape = shapes[0];

    var host = shape.host;

    if (host) {
      canvas.addMarker(host, MARKER_ATTACH);

      eventBus.once([
        'shape.move.out',
        'shape.move.cleanup'
      ], function() {
        canvas.removeMarker(host, MARKER_ATTACH);
      });
    }
  });

  // add all attachers to move closure
  this.preExecuted('elements.move', HIGH_PRIORITY, function(e) {
    var context = e.context,
        closure = context.closure,
        shapes = context.shapes,
        attachers = getAttachers(shapes);

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attachers, function(attacher) {
      closure.add(attacher, closure.topLevel[attacher.host.id]);
    });
  });

  // perform the attaching after shapes are done moving
  this.postExecuted('elements.move', function(e) {

    var context = e.context,
        shapes = context.shapes,
        newHost = context.newHost,
        attachers;

    // only single elements can be attached
    // multiply elements can be detached
    if (newHost && shapes.length !== 1) {
      return;
    }

    if (newHost) {
      attachers = shapes;
    } else {

      // find attachers moved without host
      attachers = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(shapes, function(shape) {
        var host = shape.host;

        return isAttacher(shape) && !includes(shapes, host);
      });
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attachers, function(attacher) {
      modeling.updateAttachment(attacher, newHost);
    });
  });

  // ensure invalid attachment connections are removed
  this.postExecuted('elements.move', function(e) {

    var shapes = e.context.shapes;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(shapes, function(shape) {

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(shape.attachers, function(attacher) {

        // remove invalid outgoing connections
        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attacher.outgoing.slice(), function(connection) {
          var allowed = rules.allowed('connection.reconnect', {
            connection: connection,
            source: connection.source,
            target: connection.target
          });

          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });

        // remove invalid incoming connections
        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attacher.incoming.slice(), function(connection) {
          var allowed = rules.allowed('connection.reconnect', {
            connection: connection,
            source: connection.source,
            target: connection.target
          });

          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
      });
    });
  });

  this.postExecute('shape.create', function(e) {
    var context = e.context,
        shape = context.shape,
        host = context.host;

    if (host) {
      modeling.updateAttachment(shape, host);
    }
  });

  // update attachments if the host is replaced
  this.postExecute('shape.replace', function(e) {

    var context = e.context,
        oldShape = context.oldShape,
        newShape = context.newShape;

    // move the attachers to the new host
    (0,_util_Removal__WEBPACK_IMPORTED_MODULE_3__.saveClear)(oldShape.attachers, function(attacher) {
      var allowed = rules.allowed('elements.move', {
        target: newShape,
        shapes: [attacher]
      });

      if (allowed === 'attach') {
        modeling.updateAttachment(attacher, newShape);
      } else {
        modeling.removeShape(attacher);
      }
    });

    // move attachers if new host has different size
    if (newShape.attachers.length) {

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(newShape.attachers, function(attacher) {
        var delta = (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_4__.getNewAttachShapeDelta)(attacher, oldShape, newShape);
        modeling.moveShape(attacher, delta, attacher.parent);
      });
    }

  });

  // move shape on host resize
  this.postExecute('shape.resize', function(event) {
    var context = event.context,
        shape = context.shape,
        oldBounds = context.oldBounds,
        newBounds = context.newBounds,
        attachers = shape.attachers,
        hints = context.hints || {};

    if (hints.attachSupport === false) {
      return;
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attachers, function(attacher) {
      var delta = (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_4__.getNewAttachShapeDelta)(attacher, oldBounds, newBounds);

      modeling.moveShape(attacher, delta, attacher.parent);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attacher.labels, function(label) {
        modeling.moveShape(label, delta, label.parent);
      });
    });
  });

  // remove attachments
  this.preExecute('shape.delete', function(event) {

    var shape = event.context.shape;

    (0,_util_Removal__WEBPACK_IMPORTED_MODULE_3__.saveClear)(shape.attachers, function(attacher) {
      modeling.removeShape(attacher);
    });

    if (shape.host) {
      modeling.updateAttachment(shape, null);
    }
  });
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(AttachSupport, _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

AttachSupport.$inject = [
  'injector',
  'eventBus',
  'canvas',
  'rules',
  'modeling'
];


/**
 * Return attachers of the given shapes
 *
 * @param {Array<djs.model.Base>} shapes
 * @return {Array<djs.model.Base>}
 */
function getAttachers(shapes) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.flatten)((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.map)(shapes, function(s) {
    return s.attachers || [];
  }));
}

/**
 * Return a combined list of elements and
 * attachers.
 *
 * @param {Array<djs.model.Base>} elements
 * @return {Array<djs.model.Base>} filtered
 */
function addAttached(elements) {
  var attachers = getAttachers(elements);

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.unionBy)('id', elements, attachers);
}

/**
 * Return a filtered list of elements that do not
 * contain attached elements with hosts being part
 * of the selection.
 *
 * @param  {Array<djs.model.Base>} elements
 *
 * @return {Array<djs.model.Base>} filtered
 */
function removeAttached(elements) {

  var ids = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.groupBy)(elements, 'id');

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(elements, function(element) {
    while (element) {

      // host in selection
      if (element.host && ids[element.host.id]) {
        return false;
      }

      element = element.parent;
    }

    return true;
  });
}

function isAttacher(shape) {
  return !!shape.host;
}

function includes(array, item) {
  return array.indexOf(item) !== -1;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/attach-support/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/attach-support/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _AttachSupport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AttachSupport */ "./node_modules/diagram-js/lib/features/attach-support/AttachSupport.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _rules__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'attachSupport' ],
  attachSupport: [ 'type', _AttachSupport__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js":
/*!************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AutoScroll)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");





/**
 * Initiates canvas scrolling if current cursor point is close to a border.
 * Cancelled when current point moves back inside the scrolling borders
 * or cancelled manually.
 *
 * Default options :
 *   scrollThresholdIn: [ 20, 20, 20, 20 ],
 *   scrollThresholdOut: [ 0, 0, 0, 0 ],
 *   scrollRepeatTimeout: 15,
 *   scrollStep: 10
 *
 * Threshold order:
 *   [ left, top, right, bottom ]
 */
function AutoScroll(config, eventBus, canvas) {

  this._canvas = canvas;

  this._opts = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
    scrollThresholdIn: [ 20, 20, 20, 20 ],
    scrollThresholdOut: [ 0, 0, 0, 0 ],
    scrollRepeatTimeout: 15,
    scrollStep: 10
  }, config);

  var self = this;

  eventBus.on('drag.move', function(e) {
    var point = self._toBorderPoint(e);

    self.startScroll(point);
  });

  eventBus.on([ 'drag.cleanup' ], function() {
    self.stopScroll();
  });
}

AutoScroll.$inject = [
  'config.autoScroll',
  'eventBus',
  'canvas'
];


/**
 * Starts scrolling loop.
 * Point is given in global scale in canvas container box plane.
 *
 * @param  {Object} point { x: X, y: Y }
 */
AutoScroll.prototype.startScroll = function(point) {

  var canvas = this._canvas;
  var opts = this._opts;
  var self = this;

  var clientRect = canvas.getContainer().getBoundingClientRect();

  var diff = [
    point.x,
    point.y,
    clientRect.width - point.x,
    clientRect.height - point.y
  ];

  this.stopScroll();

  var dx = 0,
      dy = 0;

  for (var i = 0; i < 4; i++) {
    if (between(diff[i], opts.scrollThresholdOut[i], opts.scrollThresholdIn[i])) {
      if (i === 0) {
        dx = opts.scrollStep;
      } else if (i == 1) {
        dy = opts.scrollStep;
      } else if (i == 2) {
        dx = -opts.scrollStep;
      } else if (i == 3) {
        dy = -opts.scrollStep;
      }
    }
  }

  if (dx !== 0 || dy !== 0) {
    canvas.scroll({ dx: dx, dy: dy });

    this._scrolling = setTimeout(function() {
      self.startScroll(point);
    }, opts.scrollRepeatTimeout);
  }
};

function between(val, start, end) {
  if (start < val && val < end) {
    return true;
  }

  return false;
}


/**
 * Stops scrolling loop.
 */
AutoScroll.prototype.stopScroll = function() {
  clearTimeout(this._scrolling);
};


/**
 * Overrides defaults options.
 *
 * @param  {Object} options
 */
AutoScroll.prototype.setOptions = function(options) {
  this._opts = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, this._opts, options);
};


/**
 * Converts event to a point in canvas container plane in global scale.
 *
 * @param  {Event} event
 * @return {Point}
 */
AutoScroll.prototype._toBorderPoint = function(event) {
  var clientRect = this._canvas._container.getBoundingClientRect();

  var globalPosition = (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.toPoint)(event.originalEvent);

  return {
    x: globalPosition.x - clientRect.left,
    y: globalPosition.y - clientRect.top
  };
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/auto-scroll/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/auto-scroll/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _AutoScroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AutoScroll */ "./node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _dragging__WEBPACK_IMPORTED_MODULE_0__.default,
  ],
  __init__: [ 'autoScroll' ],
  autoScroll: [ 'type', _AutoScroll__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BendpointMove),
/* harmony export */   "isReverse": () => (/* binding */ isReverse)
/* harmony export */ });
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");


var round = Math.round;

var RECONNECT_START = 'reconnectStart',
    RECONNECT_END = 'reconnectEnd',
    UPDATE_WAYPOINTS = 'updateWaypoints';


/**
 * Move bendpoints through drag and drop to add/remove bendpoints or reconnect connection.
 */
function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {
  this._injector = injector;

  this.start = function(event, connection, bendpointIndex, insert) {
    var gfx = canvas.getGraphics(connection),
        source = connection.source,
        target = connection.target,
        waypoints = connection.waypoints,
        type;

    if (!insert && bendpointIndex === 0) {
      type = RECONNECT_START;
    } else
    if (!insert && bendpointIndex === waypoints.length - 1) {
      type = RECONNECT_END;
    } else {
      type = UPDATE_WAYPOINTS;
    }

    var command = type === UPDATE_WAYPOINTS ? 'connection.updateWaypoints' : 'connection.reconnect';

    var allowed = rules.allowed(command, {
      connection: connection,
      source: source,
      target: target
    });

    if (allowed === false) {
      allowed = rules.allowed(command, {
        connection: connection,
        source: target,
        target: source
      });
    }

    if (allowed === false) {
      return;
    }

    dragging.init(event, 'bendpoint.move', {
      data: {
        connection: connection,
        connectionGfx: gfx,
        context: {
          allowed: allowed,
          bendpointIndex: bendpointIndex,
          connection: connection,
          source: source,
          target: target,
          insert: insert,
          type: type
        }
      }
    });
  };

  eventBus.on('bendpoint.move.hover', function(event) {
    var context = event.context,
        connection = context.connection,
        source = connection.source,
        target = connection.target,
        hover = event.hover,
        type = context.type;

    // cache hover state
    context.hover = hover;

    var allowed;

    if (!hover) {
      return;
    }

    var command = type === UPDATE_WAYPOINTS ? 'connection.updateWaypoints' : 'connection.reconnect';

    allowed = context.allowed = rules.allowed(command, {
      connection: connection,
      source: type === RECONNECT_START ? hover : source,
      target: type === RECONNECT_END ? hover : target
    });

    if (allowed) {
      context.source = type === RECONNECT_START ? hover : source;
      context.target = type === RECONNECT_END ? hover : target;

      return;
    }

    if (allowed === false) {
      allowed = context.allowed = rules.allowed(command, {
        connection: connection,
        source: type === RECONNECT_END ? hover : target,
        target: type === RECONNECT_START ? hover : source
      });
    }

    if (allowed) {
      context.source = type === RECONNECT_END ? hover : target;
      context.target = type === RECONNECT_START ? hover : source;
    }
  });

  eventBus.on([ 'bendpoint.move.out', 'bendpoint.move.cleanup' ], function(event) {
    var context = event.context,
        type = context.type;

    context.hover = null;
    context.source = null;
    context.target = null;

    if (type !== UPDATE_WAYPOINTS) {
      context.allowed = false;
    }
  });

  eventBus.on('bendpoint.move.end', function(event) {
    var context = event.context,
        allowed = context.allowed,
        bendpointIndex = context.bendpointIndex,
        connection = context.connection,
        insert = context.insert,
        newWaypoints = connection.waypoints.slice(),
        source = context.source,
        target = context.target,
        type = context.type,
        hints = context.hints || {};

    // ensure integer values (important if zoom level was > 1 during move)
    var docking = {
      x: round(event.x),
      y: round(event.y)
    };

    if (!allowed) {
      return false;
    }

    if (type === UPDATE_WAYPOINTS) {
      if (insert) {

        // insert new bendpoint
        newWaypoints.splice(bendpointIndex, 0, docking);
      } else {

        // swap previous waypoint with moved one
        newWaypoints[bendpointIndex] = docking;
      }

      // pass hints about actual moved bendpoint
      // useful for connection/label layout
      hints.bendpointMove = {
        insert: insert,
        bendpointIndex: bendpointIndex
      };

      newWaypoints = this.cropWaypoints(connection, newWaypoints);

      modeling.updateWaypoints(connection, (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.filterRedundantWaypoints)(newWaypoints), hints);
    } else {
      if (type === RECONNECT_START) {
        hints.docking = 'source';

        if (isReverse(context)) {
          hints.docking = 'target';

          hints.newWaypoints = newWaypoints.reverse();
        }
      } else if (type === RECONNECT_END) {
        hints.docking = 'target';

        if (isReverse(context)) {
          hints.docking = 'source';

          hints.newWaypoints = newWaypoints.reverse();
        }
      }

      modeling.reconnect(connection, source, target, docking, hints);
    }
  }, this);
}

BendpointMove.$inject = [
  'injector',
  'eventBus',
  'canvas',
  'dragging',
  'rules',
  'modeling'
];

BendpointMove.prototype.cropWaypoints = function(connection, newWaypoints) {
  var connectionDocking = this._injector.get('connectionDocking', false);

  if (!connectionDocking) {
    return newWaypoints;
  }

  var waypoints = connection.waypoints;

  connection.waypoints = newWaypoints;

  connection.waypoints = connectionDocking.getCroppedWaypoints(connection);

  newWaypoints = connection.waypoints;

  connection.waypoints = waypoints;

  return newWaypoints;
};


// helpers //////////

function isReverse(context) {
  var hover = context.hover,
      source = context.source,
      target = context.target,
      type = context.type;

  if (type === RECONNECT_START) {
    return hover && target && hover === target && source !== target;
  }

  if (type === RECONNECT_END) {
    return hover && source && hover === source && source !== target;
  }
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/BendpointMovePreview.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/BendpointMovePreview.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BendpointMovePreview)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _BendpointUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BendpointUtil */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var _BendpointMove__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BendpointMove */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js");








var RECONNECT_START = 'reconnectStart',
    RECONNECT_END = 'reconnectEnd',
    UPDATE_WAYPOINTS = 'updateWaypoints';

var MARKER_OK = 'connect-ok',
    MARKER_NOT_OK = 'connect-not-ok',
    MARKER_CONNECT_HOVER = 'connect-hover',
    MARKER_CONNECT_UPDATING = 'djs-updating',
    MARKER_ELEMENT_HIDDEN = 'djs-element-hidden';

var HIGH_PRIORITY = 1100;

/**
 * Preview connection while moving bendpoints.
 */
function BendpointMovePreview(bendpointMove, injector, eventBus, canvas) {
  this._injector = injector;

  var connectionPreview = injector.get('connectionPreview', false);

  eventBus.on('bendpoint.move.start', function(event) {
    var context = event.context,
        bendpointIndex = context.bendpointIndex,
        connection = context.connection,
        insert = context.insert,
        waypoints = connection.waypoints,
        newWaypoints = waypoints.slice();

    context.waypoints = waypoints;

    if (insert) {

      // insert placeholder for new bendpoint
      newWaypoints.splice(bendpointIndex, 0, { x: event.x, y: event.y });
    }

    connection.waypoints = newWaypoints;

    // add dragger gfx
    var draggerGfx = context.draggerGfx = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_0__.addBendpoint)(canvas.getLayer('overlays'));

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(draggerGfx).add('djs-dragging');

    canvas.addMarker(connection, MARKER_ELEMENT_HIDDEN);
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
  });

  eventBus.on('bendpoint.move.hover', function(event) {
    var context = event.context,
        allowed = context.allowed,
        hover = context.hover,
        type = context.type;

    if (hover) {
      canvas.addMarker(hover, MARKER_CONNECT_HOVER);

      if (type === UPDATE_WAYPOINTS) {
        return;
      }

      if (allowed) {
        canvas.removeMarker(hover, MARKER_NOT_OK);
        canvas.addMarker(hover, MARKER_OK);
      } else if (allowed === false) {
        canvas.removeMarker(hover, MARKER_OK);
        canvas.addMarker(hover, MARKER_NOT_OK);
      }
    }
  });

  eventBus.on([
    'bendpoint.move.out',
    'bendpoint.move.cleanup'
  ], HIGH_PRIORITY, function(event) {
    var context = event.context,
        hover = context.hover,
        target = context.target;

    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);
    }
  });

  eventBus.on('bendpoint.move.move', function(event) {
    var context = event.context,
        allowed = context.allowed,
        bendpointIndex = context.bendpointIndex,
        draggerGfx = context.draggerGfx,
        hover = context.hover,
        type = context.type,
        connection = context.connection,
        source = connection.source,
        target = connection.target,
        newWaypoints = connection.waypoints.slice(),
        bendpoint = { x: event.x, y: event.y },
        hints = context.hints || {},
        drawPreviewHints = {};

    if (connectionPreview) {
      if (hints.connectionStart) {
        drawPreviewHints.connectionStart = hints.connectionStart;
      }

      if (hints.connectionEnd) {
        drawPreviewHints.connectionEnd = hints.connectionEnd;
      }


      if (type === RECONNECT_START) {
        if ((0,_BendpointMove__WEBPACK_IMPORTED_MODULE_2__.isReverse)(context)) {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;

          drawPreviewHints.source = target;
          drawPreviewHints.target = hover || source;

          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;

          drawPreviewHints.source = hover || source;
          drawPreviewHints.target = target;
        }
      } else if (type === RECONNECT_END) {
        if ((0,_BendpointMove__WEBPACK_IMPORTED_MODULE_2__.isReverse)(context)) {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;

          drawPreviewHints.source = hover || target;
          drawPreviewHints.target = source;

          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;

          drawPreviewHints.source = source;
          drawPreviewHints.target = hover || target;
        }

      } else {
        drawPreviewHints.noCropping = true;
        drawPreviewHints.noLayout = true;
        newWaypoints[ bendpointIndex ] = bendpoint;
      }

      if (type === UPDATE_WAYPOINTS) {
        newWaypoints = bendpointMove.cropWaypoints(connection, newWaypoints);
      }

      drawPreviewHints.waypoints = newWaypoints;

      connectionPreview.drawPreview(context, allowed, drawPreviewHints);
    }

    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__.translate)(draggerGfx, event.x, event.y);
  }, this);

  eventBus.on([
    'bendpoint.move.end',
    'bendpoint.move.cancel'
  ], HIGH_PRIORITY, function(event) {
    var context = event.context,
        connection = context.connection,
        draggerGfx = context.draggerGfx,
        hover = context.hover,
        target = context.target,
        waypoints = context.waypoints;

    connection.waypoints = waypoints;

    // remove dragger gfx
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(draggerGfx);

    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
    canvas.removeMarker(connection, MARKER_ELEMENT_HIDDEN);

    if (hover) {
      canvas.removeMarker(hover, MARKER_OK);
      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);
    }

    if (connectionPreview) {
      connectionPreview.cleanUp(context);
    }
  });
}

BendpointMovePreview.$inject = [
  'bendpointMove',
  'injector',
  'eventBus',
  'canvas'
];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BendpointSnapping)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _snapping_SnapUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../snapping/SnapUtil */ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js");




var abs= Math.abs,
    round = Math.round;

var TOLERANCE = 10;


function BendpointSnapping(eventBus) {

  function snapTo(values, value) {

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(values)) {
      var i = values.length;

      while (i--) if (abs(values[i] - value) <= TOLERANCE) {
        return values[i];
      }
    } else {
      values = +values;
      var rem = value % values;

      if (rem < TOLERANCE) {
        return value - rem;
      }

      if (rem > values - TOLERANCE) {
        return value - rem + values;
      }
    }

    return value;
  }

  function mid(element) {
    if (element.width) {
      return {
        x: round(element.width / 2 + element.x),
        y: round(element.height / 2 + element.y)
      };
    }
  }

  // connection segment snapping //////////////////////

  function getConnectionSegmentSnaps(context) {

    var snapPoints = context.snapPoints,
        connection = context.connection,
        waypoints = connection.waypoints,
        segmentStart = context.segmentStart,
        segmentStartIndex = context.segmentStartIndex,
        segmentEnd = context.segmentEnd,
        segmentEndIndex = context.segmentEndIndex,
        axis = context.axis;

    if (snapPoints) {
      return snapPoints;
    }

    var referenceWaypoints = [
      waypoints[segmentStartIndex - 1],
      segmentStart,
      segmentEnd,
      waypoints[segmentEndIndex + 1]
    ];

    if (segmentStartIndex < 2) {
      referenceWaypoints.unshift(mid(connection.source));
    }

    if (segmentEndIndex > waypoints.length - 3) {
      referenceWaypoints.unshift(mid(connection.target));
    }

    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(referenceWaypoints, function(p) {

      // we snap on existing bendpoints only,
      // not placeholders that are inserted during add
      if (p) {
        p = p.original || p;

        if (axis === 'y') {
          snapPoints.horizontal.push(p.y);
        }

        if (axis === 'x') {
          snapPoints.vertical.push(p.x);
        }
      }
    });

    return snapPoints;
  }

  eventBus.on('connectionSegment.move.move', 1500, function(event) {
    var context = event.context,
        snapPoints = getConnectionSegmentSnaps(context),
        x = event.x,
        y = event.y,
        sx, sy;

    if (!snapPoints) {
      return;
    }

    // snap
    sx = snapTo(snapPoints.vertical, x);
    sy = snapTo(snapPoints.horizontal, y);


    // correction x/y
    var cx = (x - sx),
        cy = (y - sy);

    // update delta
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(event, {
      dx: event.dx - cx,
      dy: event.dy - cy,
      x: sx,
      y: sy
    });

    // only set snapped if actually snapped
    if (cx || snapPoints.vertical.indexOf(x) !== -1) {
      (0,_snapping_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'x', sx);
    }

    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {
      (0,_snapping_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'y', sy);
    }
  });


  // bendpoint snapping //////////////////////

  function getBendpointSnaps(context) {

    var snapPoints = context.snapPoints,
        waypoints = context.connection.waypoints,
        bendpointIndex = context.bendpointIndex;

    if (snapPoints) {
      return snapPoints;
    }

    var referenceWaypoints = [ waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1] ];

    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(referenceWaypoints, function(p) {

      // we snap on existing bendpoints only,
      // not placeholders that are inserted during add
      if (p) {
        p = p.original || p;

        snapPoints.horizontal.push(p.y);
        snapPoints.vertical.push(p.x);
      }
    });

    return snapPoints;
  }


  eventBus.on([ 'bendpoint.move.move', 'bendpoint.move.end' ], 1500, function(event) {

    var context = event.context,
        snapPoints = getBendpointSnaps(context),
        hover = context.hover,
        hoverMid = hover && mid(hover),
        x = event.x,
        y = event.y,
        sx, sy;

    if (!snapPoints) {
      return;
    }

    // snap to hover mid
    sx = snapTo(hoverMid ? snapPoints.vertical.concat([ hoverMid.x ]) : snapPoints.vertical, x);
    sy = snapTo(hoverMid ? snapPoints.horizontal.concat([ hoverMid.y ]) : snapPoints.horizontal, y);

    // correction x/y
    var cx = (x - sx),
        cy = (y - sy);

    // update delta
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(event, {
      dx: event.dx - cx,
      dy: event.dy - cy,
      x: event.x - cx,
      y: event.y - cy
    });

    // only set snapped if actually snapped
    if (cx || snapPoints.vertical.indexOf(x) !== -1) {
      (0,_snapping_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'x', sx);
    }

    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {
      (0,_snapping_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'y', sy);
    }
  });
}


BendpointSnapping.$inject = [ 'eventBus' ];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BENDPOINT_CLS": () => (/* binding */ BENDPOINT_CLS),
/* harmony export */   "SEGMENT_DRAGGER_CLS": () => (/* binding */ SEGMENT_DRAGGER_CLS),
/* harmony export */   "toCanvasCoordinates": () => (/* binding */ toCanvasCoordinates),
/* harmony export */   "getConnectionIntersection": () => (/* binding */ getConnectionIntersection),
/* harmony export */   "addBendpoint": () => (/* binding */ addBendpoint),
/* harmony export */   "addSegmentDragger": () => (/* binding */ addSegmentDragger),
/* harmony export */   "calculateSegmentMoveRegion": () => (/* binding */ calculateSegmentMoveRegion)
/* harmony export */ });
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");
/* harmony import */ var _util_Geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Geometry */ "./node_modules/diagram-js/lib/util/Geometry.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var _util_LineIntersection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/LineIntersection */ "./node_modules/diagram-js/lib/util/LineIntersection.js");










var BENDPOINT_CLS = 'djs-bendpoint';
var SEGMENT_DRAGGER_CLS = 'djs-segment-dragger';

function toCanvasCoordinates(canvas, event) {

  var position = (0,_util_Event__WEBPACK_IMPORTED_MODULE_0__.toPoint)(event),
      clientRect = canvas._container.getBoundingClientRect(),
      offset;

  // canvas relative position

  offset = {
    x: clientRect.left,
    y: clientRect.top
  };

  // update actual event payload with canvas relative measures

  var viewbox = canvas.viewbox();

  return {
    x: viewbox.x + (position.x - offset.x) / viewbox.scale,
    y: viewbox.y + (position.y - offset.y) / viewbox.scale
  };
}

function getConnectionIntersection(canvas, waypoints, event) {
  var localPosition = toCanvasCoordinates(canvas, event),
      intersection = (0,_util_LineIntersection__WEBPACK_IMPORTED_MODULE_1__.getApproxIntersection)(waypoints, localPosition);

  return intersection;
}

function addBendpoint(parentGfx, cls) {
  var groupGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('g');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(groupGfx).add(BENDPOINT_CLS);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(parentGfx, groupGfx);

  var visual = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('circle');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(visual, {
    cx: 0,
    cy: 0,
    r: 4
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(visual).add('djs-visual');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(groupGfx, visual);

  var hit = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('circle');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(hit, {
    cx: 0,
    cy: 0,
    r: 10
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(hit).add('djs-hit');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(groupGfx, hit);

  if (cls) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(groupGfx).add(cls);
  }

  return groupGfx;
}

function createParallelDragger(parentGfx, segmentStart, segmentEnd, alignment) {
  var draggerGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('g');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(parentGfx, draggerGfx);

  var width = 14,
      height = 3,
      padding = 11,
      hitWidth = calculateHitWidth(segmentStart, segmentEnd, alignment),
      hitHeight = height + padding;

  var visual = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('rect');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(visual, {
    x: -width / 2,
    y: -height / 2,
    width: width,
    height: height
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(visual).add('djs-visual');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(draggerGfx, visual);

  var hit = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('rect');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(hit, {
    x: -hitWidth / 2,
    y: -hitHeight / 2,
    width: hitWidth,
    height: hitHeight
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(hit).add('djs-hit');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(draggerGfx, hit);

  (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__.rotate)(draggerGfx, alignment === 'v' ? 90 : 0, 0, 0);

  return draggerGfx;
}


function addSegmentDragger(parentGfx, segmentStart, segmentEnd) {

  var groupGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('g'),
      mid = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_4__.getMidPoint)(segmentStart, segmentEnd),
      alignment = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_4__.pointsAligned)(segmentStart, segmentEnd);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(parentGfx, groupGfx);

  createParallelDragger(groupGfx, segmentStart, segmentEnd, alignment);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(groupGfx).add(SEGMENT_DRAGGER_CLS);
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(groupGfx).add(alignment === 'h' ? 'horizontal' : 'vertical');

  (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__.translate)(groupGfx, mid.x, mid.y);

  return groupGfx;
}

/**
 * Calculates region for segment move which is 2/3 of the full segment length
 * @param {number} segmentLength
 *
 * @return {number}
 */
function calculateSegmentMoveRegion(segmentLength) {
  return Math.abs(Math.round(segmentLength * 2 / 3));
}

// helper //////////

function calculateHitWidth(segmentStart, segmentEnd, alignment) {
  var segmentLengthXAxis = segmentEnd.x - segmentStart.x,
      segmentLengthYAxis = segmentEnd.y - segmentStart.y;

  return alignment === 'h' ?
    calculateSegmentMoveRegion(segmentLengthXAxis) :
    calculateSegmentMoveRegion(segmentLengthYAxis);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js":
/*!***********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Bendpoints)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _BendpointUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BendpointUtil */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js");
/* harmony import */ var _util_EscapeUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/EscapeUtil */ "./node_modules/css.escape/css.escape.js");
/* harmony import */ var _util_EscapeUtil__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_util_EscapeUtil__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _util_Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Geometry */ "./node_modules/diagram-js/lib/util/Geometry.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");

















/**
 * A service that adds editable bendpoints to connections.
 */
function Bendpoints(
    eventBus, canvas, interactionEvents,
    bendpointMove, connectionSegmentMove) {

  /**
   * Returns true if intersection point is inside middle region of segment, adjusted by
   * optional threshold
   */
  function isIntersectionMiddle(intersection, waypoints, treshold) {
    var idx = intersection.index,
        p = intersection.point,
        p0, p1, mid, aligned, xDelta, yDelta;

    if (idx <= 0 || intersection.bendpoint) {
      return false;
    }

    p0 = waypoints[idx - 1];
    p1 = waypoints[idx];
    mid = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.getMidPoint)(p0, p1),
    aligned = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.pointsAligned)(p0, p1);
    xDelta = Math.abs(p.x - mid.x);
    yDelta = Math.abs(p.y - mid.y);

    return aligned && xDelta <= treshold && yDelta <= treshold;
  }

  /**
   * Calculates the threshold from a connection's middle which fits the two-third-region
   */
  function calculateIntersectionThreshold(connection, intersection) {
    var waypoints = connection.waypoints,
        relevantSegment, alignment, segmentLength, threshold;

    if (intersection.index <= 0 || intersection.bendpoint) {
      return null;
    }

    // segment relative to connection intersection
    relevantSegment = {
      start: waypoints[intersection.index - 1],
      end: waypoints[intersection.index]
    };

    alignment = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.pointsAligned)(relevantSegment.start, relevantSegment.end);

    if (!alignment) {
      return null;
    }

    if (alignment === 'h') {
      segmentLength = relevantSegment.end.x - relevantSegment.start.x;
    } else {
      segmentLength = relevantSegment.end.y - relevantSegment.start.y;
    }

    // calculate threshold relative to 2/3 of segment length
    threshold = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.calculateSegmentMoveRegion)(segmentLength) / 2;

    return threshold;
  }

  function activateBendpointMove(event, connection) {
    var waypoints = connection.waypoints,
        intersection = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.getConnectionIntersection)(canvas, waypoints, event),
        threshold;

    if (!intersection) {
      return;
    }

    threshold = calculateIntersectionThreshold(connection, intersection);

    if (isIntersectionMiddle(intersection, waypoints, threshold)) {
      connectionSegmentMove.start(event, connection, intersection.index);
    } else {
      bendpointMove.start(event, connection, intersection.index, !intersection.bendpoint);
    }

    // we've handled the event
    return true;
  }

  function bindInteractionEvents(node, eventName, element) {

    min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(node, eventName, function(event) {
      interactionEvents.triggerMouseEvent(eventName, event, element);
      event.stopPropagation();
    });
  }

  function getBendpointsContainer(element, create) {

    var layer = canvas.getLayer('overlays'),
        gfx = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)('.djs-bendpoints[data-element-id="' + _util_EscapeUtil__WEBPACK_IMPORTED_MODULE_3___default()(element.id) + '"]', layer);

    if (!gfx && create) {
      gfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.create)('g');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.attr)(gfx, { 'data-element-id': element.id });
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.classes)(gfx).add('djs-bendpoints');

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.append)(layer, gfx);

      bindInteractionEvents(gfx, 'mousedown', element);
      bindInteractionEvents(gfx, 'click', element);
      bindInteractionEvents(gfx, 'dblclick', element);
    }

    return gfx;
  }

  function getSegmentDragger(idx, parentGfx) {
    return (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)(
      '.djs-segment-dragger[data-segment-idx="' + idx + '"]',
      parentGfx
    );
  }

  function createBendpoints(gfx, connection) {
    connection.waypoints.forEach(function(p, idx) {
      var bendpoint = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.addBendpoint)(gfx);

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.append)(gfx, bendpoint);

      (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__.translate)(bendpoint, p.x, p.y);
    });

    // add floating bendpoint
    (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.addBendpoint)(gfx, 'floating');
  }

  function createSegmentDraggers(gfx, connection) {

    var waypoints = connection.waypoints;

    var segmentStart,
        segmentEnd,
        segmentDraggerGfx;

    for (var i = 1; i < waypoints.length; i++) {

      segmentStart = waypoints[i - 1];
      segmentEnd = waypoints[i];

      if ((0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.pointsAligned)(segmentStart, segmentEnd)) {
        segmentDraggerGfx = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.addSegmentDragger)(gfx, segmentStart, segmentEnd);

        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.attr)(segmentDraggerGfx, { 'data-segment-idx': i });

        bindInteractionEvents(segmentDraggerGfx, 'mousemove', connection);
      }
    }
  }

  function clearBendpoints(gfx) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_6__.forEach)((0,min_dom__WEBPACK_IMPORTED_MODULE_2__.queryAll)('.' + _BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.BENDPOINT_CLS, gfx), function(node) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.remove)(node);
    });
  }

  function clearSegmentDraggers(gfx) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_6__.forEach)((0,min_dom__WEBPACK_IMPORTED_MODULE_2__.queryAll)('.' + _BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.SEGMENT_DRAGGER_CLS, gfx), function(node) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.remove)(node);
    });
  }

  function addHandles(connection) {

    var gfx = getBendpointsContainer(connection);

    if (!gfx) {
      gfx = getBendpointsContainer(connection, true);

      createBendpoints(gfx, connection);
      createSegmentDraggers(gfx, connection);
    }

    return gfx;
  }

  function updateHandles(connection) {

    var gfx = getBendpointsContainer(connection);

    if (gfx) {
      clearSegmentDraggers(gfx);
      clearBendpoints(gfx);
      createSegmentDraggers(gfx, connection);
      createBendpoints(gfx, connection);
    }
  }

  function updateFloatingBendpointPosition(parentGfx, intersection) {
    var floating = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)('.floating', parentGfx),
        point = intersection.point;

    if (!floating) {
      return;
    }

    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__.translate)(floating, point.x, point.y);

  }

  function updateSegmentDraggerPosition(parentGfx, intersection, waypoints) {

    var draggerGfx = getSegmentDragger(intersection.index, parentGfx),
        segmentStart = waypoints[intersection.index - 1],
        segmentEnd = waypoints[intersection.index],
        point = intersection.point,
        mid = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.getMidPoint)(segmentStart, segmentEnd),
        alignment = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_0__.pointsAligned)(segmentStart, segmentEnd),
        draggerVisual, relativePosition;

    if (!draggerGfx) {
      return;
    }

    draggerVisual = getDraggerVisual(draggerGfx);

    relativePosition = {
      x: point.x - mid.x,
      y: point.y - mid.y
    };

    if (alignment === 'v') {

      // rotate position
      relativePosition = {
        x: relativePosition.y,
        y: relativePosition.x
      };
    }

    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_5__.translate)(draggerVisual, relativePosition.x, relativePosition.y);
  }

  eventBus.on('connection.changed', function(event) {
    updateHandles(event.element);
  });

  eventBus.on('connection.remove', function(event) {
    var gfx = getBendpointsContainer(event.element);

    if (gfx) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.remove)(gfx);
    }
  });

  eventBus.on('element.marker.update', function(event) {

    var element = event.element,
        bendpointsGfx;

    if (!element.waypoints) {
      return;
    }

    bendpointsGfx = addHandles(element);

    if (event.add) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.classes)(bendpointsGfx).add(event.marker);
    } else {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.classes)(bendpointsGfx).remove(event.marker);
    }
  });

  eventBus.on('element.mousemove', function(event) {

    var element = event.element,
        waypoints = element.waypoints,
        bendpointsGfx,
        intersection;

    if (waypoints) {
      bendpointsGfx = getBendpointsContainer(element, true);

      intersection = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.getConnectionIntersection)(canvas, waypoints, event.originalEvent);

      if (!intersection) {
        return;
      }

      updateFloatingBendpointPosition(bendpointsGfx, intersection);

      if (!intersection.bendpoint) {
        updateSegmentDraggerPosition(bendpointsGfx, intersection, waypoints);
      }

    }
  });

  eventBus.on('element.mousedown', function(event) {

    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_7__.isPrimaryButton)(event)) {
      return;
    }

    var originalEvent = event.originalEvent,
        element = event.element;

    if (!element.waypoints) {
      return;
    }

    return activateBendpointMove(originalEvent, element);
  });

  eventBus.on('selection.changed', function(event) {
    var newSelection = event.newSelection,
        primary = newSelection[0];

    if (primary && primary.waypoints) {
      addHandles(primary);
    }
  });

  eventBus.on('element.hover', function(event) {
    var element = event.element;

    if (element.waypoints) {
      addHandles(element);
      interactionEvents.registerEvent(event.gfx, 'mousemove', 'element.mousemove');
    }
  });

  eventBus.on('element.out', function(event) {
    interactionEvents.unregisterEvent(event.gfx, 'mousemove', 'element.mousemove');
  });

  // update bendpoint container data attribute on element ID change
  eventBus.on('element.updateId', function(context) {
    var element = context.element,
        newId = context.newId;

    if (element.waypoints) {
      var bendpointContainer = getBendpointsContainer(element);

      if (bendpointContainer) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.attr)(bendpointContainer, { 'data-element-id': newId });
      }
    }
  });

  // API

  this.addHandles = addHandles;
  this.updateHandles = updateHandles;
  this.getBendpointsContainer = getBendpointsContainer;
  this.getSegmentDragger = getSegmentDragger;
}

Bendpoints.$inject = [
  'eventBus',
  'canvas',
  'interactionEvents',
  'bendpointMove',
  'connectionSegmentMove'
];



// helper /////////////

function getDraggerVisual(draggerGfx) {
  return (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)('.djs-visual', draggerGfx);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ConnectionSegmentMove)
/* harmony export */ });
/* harmony import */ var _util_Geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Geometry */ "./node_modules/diagram-js/lib/util/Geometry.js");
/* harmony import */ var _BendpointUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BendpointUtil */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");






var MARKER_CONNECT_HOVER = 'connect-hover',
    MARKER_CONNECT_UPDATING = 'djs-updating';






function axisAdd(point, axis, delta) {
  return axisSet(point, axis, point[axis] + delta);
}

function axisSet(point, axis, value) {
  return {
    x: (axis === 'x' ? value : point.x),
    y: (axis === 'y' ? value : point.y)
  };
}

function axisFenced(position, segmentStart, segmentEnd, axis) {

  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),
      minValue = Math.min(segmentStart[axis], segmentEnd[axis]);

  var padding = 20;

  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);

  return axisSet(segmentStart, axis, fencedValue);
}

function flipAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/**
 * Get the docking point on the given element.
 *
 * Compute a reasonable docking, if non exists.
 *
 * @param  {Point} point
 * @param  {djs.model.Shape} referenceElement
 * @param  {string} moveAxis (x|y)
 *
 * @return {Point}
 */
function getDocking(point, referenceElement, moveAxis) {

  var referenceMid,
      inverseAxis;

  if (point.original) {
    return point.original;
  } else {
    referenceMid = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.getMid)(referenceElement);
    inverseAxis = flipAxis(moveAxis);

    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);
  }
}

/**
 * A component that implements moving of bendpoints
 */
function ConnectionSegmentMove(
    injector, eventBus, canvas,
    dragging, graphicsFactory, modeling) {

  // optional connection docking integration
  var connectionDocking = injector.get('connectionDocking', false);


  // API

  this.start = function(event, connection, idx) {

    var context,
        gfx = canvas.getGraphics(connection),
        segmentStartIndex = idx - 1,
        segmentEndIndex = idx,
        waypoints = connection.waypoints,
        segmentStart = waypoints[segmentStartIndex],
        segmentEnd = waypoints[segmentEndIndex],
        intersection = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.getConnectionIntersection)(canvas, waypoints, event),
        direction, axis, dragPosition;

    direction = (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_2__.pointsAligned)(segmentStart, segmentEnd);

    // do not move diagonal connection
    if (!direction) {
      return;
    }

    // the axis where we are going to move things
    axis = direction === 'v' ? 'x' : 'y';

    if (segmentStartIndex === 0) {
      segmentStart = getDocking(segmentStart, connection.source, axis);
    }

    if (segmentEndIndex === waypoints.length - 1) {
      segmentEnd = getDocking(segmentEnd, connection.target, axis);
    }

    if (intersection) {
      dragPosition = intersection.point;
    } else {

      // set to segment center as default
      dragPosition = {
        x: (segmentStart.x + segmentEnd.x) / 2,
        y: (segmentStart.y + segmentEnd.y) / 2
      };
    }

    context = {
      connection: connection,
      segmentStartIndex: segmentStartIndex,
      segmentEndIndex: segmentEndIndex,
      segmentStart: segmentStart,
      segmentEnd: segmentEnd,
      axis: axis,
      dragPosition: dragPosition
    };

    dragging.init(event, dragPosition, 'connectionSegment.move', {
      cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',
      data: {
        connection: connection,
        connectionGfx: gfx,
        context: context
      }
    });
  };

  /**
   * Crop connection if connection cropping is provided.
   *
   * @param {Connection} connection
   * @param {Array<Point>} newWaypoints
   *
   * @return {Array<Point>} cropped connection waypoints
   */
  function cropConnection(connection, newWaypoints) {

    // crop connection, if docking service is provided only
    if (!connectionDocking) {
      return newWaypoints;
    }

    var oldWaypoints = connection.waypoints,
        croppedWaypoints;

    // temporary set new waypoints
    connection.waypoints = newWaypoints;

    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);

    // restore old waypoints
    connection.waypoints = oldWaypoints;

    return croppedWaypoints;
  }

  // DRAGGING IMPLEMENTATION

  function redrawConnection(data) {
    graphicsFactory.update('connection', data.connection, data.connectionGfx);
  }

  function updateDragger(context, segmentOffset, event) {

    var newWaypoints = context.newWaypoints,
        segmentStartIndex = context.segmentStartIndex + segmentOffset,
        segmentStart = newWaypoints[segmentStartIndex],
        segmentEndIndex = context.segmentEndIndex + segmentOffset,
        segmentEnd = newWaypoints[segmentEndIndex],
        axis = flipAxis(context.axis);

    // make sure the dragger does not move
    // outside the connection
    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);

    // update dragger
    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__.translate)(context.draggerGfx, draggerPosition.x, draggerPosition.y);
  }

  /**
   * Filter waypoints for redundant ones (i.e. on the same axis).
   * Returns the filtered waypoints and the offset related to the segment move.
   *
   * @param {Array<Point>} waypoints
   * @param {Integer} segmentStartIndex of moved segment start
   *
   * @return {Object} { filteredWaypoints, segmentOffset }
   */
  function filterRedundantWaypoints(waypoints, segmentStartIndex) {

    var segmentOffset = 0;

    var filteredWaypoints = waypoints.filter(function(r, idx) {
      if ((0,_util_Geometry__WEBPACK_IMPORTED_MODULE_2__.pointsOnLine)(waypoints[idx - 1], waypoints[idx + 1], r)) {

        // remove point and increment offset
        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;
        return false;
      }

      // dont remove point
      return true;
    });

    return {
      waypoints: filteredWaypoints,
      segmentOffset: segmentOffset
    };
  }

  eventBus.on('connectionSegment.move.start', function(event) {

    var context = event.context,
        connection = event.connection,
        layer = canvas.getLayer('overlays');

    context.originalWaypoints = connection.waypoints.slice();

    // add dragger gfx
    context.draggerGfx = (0,_BendpointUtil__WEBPACK_IMPORTED_MODULE_1__.addSegmentDragger)(layer, context.segmentStart, context.segmentEnd);
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.classes)(context.draggerGfx).add('djs-dragging');

    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
  });

  eventBus.on('connectionSegment.move.move', function(event) {

    var context = event.context,
        connection = context.connection,
        segmentStartIndex = context.segmentStartIndex,
        segmentEndIndex = context.segmentEndIndex,
        segmentStart = context.segmentStart,
        segmentEnd = context.segmentEnd,
        axis = context.axis;

    var newWaypoints = context.originalWaypoints.slice(),
        newSegmentStart = axisAdd(segmentStart, axis, event['d' + axis]),
        newSegmentEnd = axisAdd(segmentEnd, axis, event['d' + axis]);

    // original waypoint count and added / removed
    // from start waypoint delta. We use the later
    // to retrieve the updated segmentStartIndex / segmentEndIndex
    var waypointCount = newWaypoints.length,
        segmentOffset = 0;

    // move segment start / end by axis delta
    newWaypoints[segmentStartIndex] = newSegmentStart;
    newWaypoints[segmentEndIndex] = newSegmentEnd;

    var sourceToSegmentOrientation,
        targetToSegmentOrientation;

    // handle first segment
    if (segmentStartIndex < 2) {
      sourceToSegmentOrientation = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.getOrientation)(connection.source, newSegmentStart);

      // first bendpoint, remove first segment if intersecting
      if (segmentStartIndex === 1) {

        if (sourceToSegmentOrientation === 'intersect') {
          newWaypoints.shift();
          newWaypoints[0] = newSegmentStart;
          segmentOffset--;
        }
      }

      // docking point, add segment if not intersecting anymore
      else {
        if (sourceToSegmentOrientation !== 'intersect') {
          newWaypoints.unshift(segmentStart);
          segmentOffset++;
        }
      }
    }

    // handle last segment
    if (segmentEndIndex > waypointCount - 3) {
      targetToSegmentOrientation = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.getOrientation)(connection.target, newSegmentEnd);

      // last bendpoint, remove last segment if intersecting
      if (segmentEndIndex === waypointCount - 2) {

        if (targetToSegmentOrientation === 'intersect') {
          newWaypoints.pop();
          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;
        }
      }

      // last bendpoint, remove last segment if intersecting
      else {
        if (targetToSegmentOrientation !== 'intersect') {
          newWaypoints.push(segmentEnd);
        }
      }
    }

    // update connection waypoints
    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);

    // update dragger position
    updateDragger(context, segmentOffset, event);

    // save segmentOffset in context
    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;

    // redraw connection
    redrawConnection(event);
  });

  eventBus.on('connectionSegment.move.hover', function(event) {

    event.context.hover = event.hover;
    canvas.addMarker(event.hover, MARKER_CONNECT_HOVER);
  });

  eventBus.on([
    'connectionSegment.move.out',
    'connectionSegment.move.cleanup'
  ], function(event) {

    // remove connect marker
    // if it was added
    var hover = event.context.hover;

    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
    }
  });

  eventBus.on('connectionSegment.move.cleanup', function(event) {

    var context = event.context,
        connection = context.connection;

    // remove dragger gfx
    if (context.draggerGfx) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_4__.remove)(context.draggerGfx);
    }

    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
  });

  eventBus.on([
    'connectionSegment.move.cancel',
    'connectionSegment.move.end'
  ], function(event) {
    var context = event.context,
        connection = context.connection;

    connection.waypoints = context.originalWaypoints;

    redrawConnection(event);
  });

  eventBus.on('connectionSegment.move.end', function(event) {

    var context = event.context,
        connection = context.connection,
        newWaypoints = context.newWaypoints,
        newSegmentStartIndex = context.newSegmentStartIndex;

    // ensure we have actual pixel values bendpoint
    // coordinates (important when zoom level was > 1 during move)
    newWaypoints = newWaypoints.map(function(p) {
      return {
        original: p.original,
        x: Math.round(p.x),
        y: Math.round(p.y)
      };
    });

    // apply filter redunant waypoints
    var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);

    // get filtered waypoints
    var filteredWaypoints = filtered.waypoints,
        croppedWaypoints = cropConnection(connection, filteredWaypoints),
        segmentOffset = filtered.segmentOffset;

    var hints = {
      segmentMove: {
        segmentStartIndex: context.segmentStartIndex,
        newSegmentStartIndex: newSegmentStartIndex + segmentOffset
      }
    };

    modeling.updateWaypoints(connection, croppedWaypoints, hints);
  });
}

ConnectionSegmentMove.$inject = [
  'injector',
  'eventBus',
  'canvas',
  'dragging',
  'graphicsFactory',
  'modeling'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/bendpoints/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/bendpoints/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _Bendpoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bendpoints */ "./node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js");
/* harmony import */ var _BendpointMove__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BendpointMove */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js");
/* harmony import */ var _BendpointMovePreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BendpointMovePreview */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointMovePreview.js");
/* harmony import */ var _ConnectionSegmentMove__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ConnectionSegmentMove */ "./node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js");
/* harmony import */ var _BendpointSnapping__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BendpointSnapping */ "./node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js");










/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _dragging__WEBPACK_IMPORTED_MODULE_0__.default,
    _rules__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [ 'bendpoints', 'bendpointSnapping', 'bendpointMovePreview' ],
  bendpoints: [ 'type', _Bendpoints__WEBPACK_IMPORTED_MODULE_2__.default ],
  bendpointMove: [ 'type', _BendpointMove__WEBPACK_IMPORTED_MODULE_3__.default ],
  bendpointMovePreview: [ 'type', _BendpointMovePreview__WEBPACK_IMPORTED_MODULE_4__.default ],
  connectionSegmentMove: [ 'type', _ConnectionSegmentMove__WEBPACK_IMPORTED_MODULE_5__.default ],
  bendpointSnapping: [ 'type', _BendpointSnapping__WEBPACK_IMPORTED_MODULE_6__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/change-support/ChangeSupport.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/change-support/ChangeSupport.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ChangeSupport)
/* harmony export */ });
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");


/**
 * Adds change support to the diagram, including
 *
 * <ul>
 *   <li>redrawing shapes and connections on change</li>
 * </ul>
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {ElementRegistry} elementRegistry
 * @param {GraphicsFactory} graphicsFactory
 */
function ChangeSupport(
    eventBus, canvas, elementRegistry,
    graphicsFactory) {


  // redraw shapes / connections on change

  eventBus.on('element.changed', function(event) {

    var element = event.element;

    // element might have been deleted and replaced by new element with same ID
    // thus check for parent of element except for root element
    if (element.parent || element === canvas.getRootElement()) {
      event.gfx = elementRegistry.getGraphics(element);
    }

    // shape + gfx may have been deleted
    if (!event.gfx) {
      return;
    }

    eventBus.fire((0,_util_Elements__WEBPACK_IMPORTED_MODULE_0__.getType)(element) + '.changed', event);
  });

  eventBus.on('elements.changed', function(event) {

    var elements = event.elements;

    elements.forEach(function(e) {
      eventBus.fire('element.changed', { element: e });
    });

    graphicsFactory.updateContainments(elements);
  });

  eventBus.on('shape.changed', function(event) {
    graphicsFactory.update('shape', event.element, event.gfx);
  });

  eventBus.on('connection.changed', function(event) {
    graphicsFactory.update('connection', event.element, event.gfx);
  });
}

ChangeSupport.$inject = [
  'eventBus',
  'canvas',
  'elementRegistry',
  'graphicsFactory'
];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/change-support/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/change-support/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ChangeSupport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChangeSupport */ "./node_modules/diagram-js/lib/features/change-support/ChangeSupport.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'changeSupport'],
  changeSupport: [ 'type', _ChangeSupport__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/clipboard/Clipboard.js":
/*!*********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/clipboard/Clipboard.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Clipboard)
/* harmony export */ });
/**
 * A clip board stub
 */
function Clipboard() {}


Clipboard.prototype.get = function() {
  return this._data;
};

Clipboard.prototype.set = function(data) {
  this._data = data;
};

Clipboard.prototype.clear = function() {
  var data = this._data;

  delete this._data;

  return data;
};

Clipboard.prototype.isEmpty = function() {
  return !this._data;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/clipboard/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/clipboard/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Clipboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clipboard */ "./node_modules/diagram-js/lib/features/clipboard/Clipboard.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  clipboard: [ 'type', _Clipboard__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/connect/Connect.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/connect/Connect.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Connect),
/* harmony export */   "isReverse": () => (/* binding */ isReverse)
/* harmony export */ });
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");





function Connect(eventBus, dragging, modeling, rules) {

  // rules

  function canConnect(source, target) {
    return rules.allowed('connection.create', {
      source: source,
      target: target
    });
  }

  function canConnectReverse(source, target) {
    return canConnect(target, source);
  }


  // event handlers

  eventBus.on('connect.hover', function(event) {
    var context = event.context,
        start = context.start,
        hover = event.hover,
        canExecute;

    // cache hover state
    context.hover = hover;

    canExecute = context.canExecute = canConnect(start, hover);

    // ignore hover
    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNil)(canExecute)) {
      return;
    }

    if (canExecute !== false) {
      context.source = start;
      context.target = hover;

      return;
    }

    canExecute = context.canExecute = canConnectReverse(start, hover);

    // ignore hover
    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNil)(canExecute)) {
      return;
    }

    if (canExecute !== false) {
      context.source = hover;
      context.target = start;
    }
  });

  eventBus.on([ 'connect.out', 'connect.cleanup' ], function(event) {
    var context = event.context;

    context.hover = null;
    context.source = null;
    context.target = null;

    context.canExecute = false;
  });

  eventBus.on('connect.end', function(event) {
    var context = event.context,
        canExecute = context.canExecute,
        connectionStart = context.connectionStart,
        connectionEnd = {
          x: event.x,
          y: event.y
        },
        source = context.source,
        target = context.target;

    if (!canExecute) {
      return false;
    }

    var attrs = null,
        hints = {
          connectionStart: isReverse(context) ? connectionEnd : connectionStart,
          connectionEnd: isReverse(context) ? connectionStart : connectionEnd
        };

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(canExecute)) {
      attrs = canExecute;
    }

    modeling.connect(source, target, attrs, hints);
  });


  // API

  /**
   * Start connect operation.
   *
   * @param {DOMEvent} event
   * @param {djs.model.Base} start
   * @param {Point} [connectionStart]
   * @param {boolean} [autoActivate=false]
   */
  this.start = function(event, start, connectionStart, autoActivate) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(connectionStart)) {
      autoActivate = connectionStart;
      connectionStart = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(start);
    }

    dragging.init(event, 'connect', {
      autoActivate: autoActivate,
      data: {
        shape: start,
        context: {
          start: start,
          connectionStart: connectionStart
        }
      }
    });
  };
}

Connect.$inject = [
  'eventBus',
  'dragging',
  'modeling',
  'rules'
];


// helpers //////////

function isReverse(context) {
  var hover = context.hover,
      source = context.source,
      target = context.target;

  return hover && source && hover === source && source !== target;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/connect/ConnectPreview.js":
/*!************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/connect/ConnectPreview.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ConnectPreview)
/* harmony export */ });
/* harmony import */ var _Connect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Connect */ "./node_modules/diagram-js/lib/features/connect/Connect.js");


var HIGH_PRIORITY = 1100,
    LOW_PRIORITY = 900;

var MARKER_OK = 'connect-ok',
    MARKER_NOT_OK = 'connect-not-ok';

/**
 * Shows connection preview during connect.
 *
 * @param {didi.Injector} injector
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function ConnectPreview(injector, eventBus, canvas) {
  var connectionPreview = injector.get('connectionPreview', false);

  connectionPreview && eventBus.on('connect.move', function(event) {
    var context = event.context,
        canConnect = context.canExecute,
        hover = context.hover,
        source = context.source,
        start = context.start,
        startPosition = context.startPosition,
        connectionStart = context.connectionStart,
        connectionEnd = context.connectionEnd,
        target = context.target;

    if (!connectionStart) {
      connectionStart = (0,_Connect__WEBPACK_IMPORTED_MODULE_0__.isReverse)(context) ? {
        x: event.x,
        y: event.y
      } : startPosition;
    }

    if (!connectionEnd) {
      connectionEnd = (0,_Connect__WEBPACK_IMPORTED_MODULE_0__.isReverse)(context) ? startPosition : {
        x: event.x,
        y: event.y
      };
    }

    connectionPreview.drawPreview(context, canConnect, {
      source: source || start,
      target: target || hover,
      connectionStart: connectionStart,
      connectionEnd: connectionEnd
    });
  });

  eventBus.on('connect.hover', LOW_PRIORITY, function(event) {
    var context = event.context,
        hover = event.hover,
        canExecute = context.canExecute;

    // ignore hover
    if (canExecute === null) {
      return;
    }

    canvas.addMarker(hover, canExecute ? MARKER_OK : MARKER_NOT_OK);
  });

  eventBus.on([
    'connect.out',
    'connect.cleanup'
  ], HIGH_PRIORITY, function(event) {
    var hover = event.hover;

    if (hover) {
      canvas.removeMarker(hover, MARKER_OK);
      canvas.removeMarker(hover, MARKER_NOT_OK);
    }
  });

  connectionPreview && eventBus.on('connect.cleanup', function(event) {
    connectionPreview.cleanUp(event.context);
  });
}

ConnectPreview.$inject = [
  'injector',
  'eventBus',
  'canvas'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/connect/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/connect/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _Connect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Connect */ "./node_modules/diagram-js/lib/features/connect/Connect.js");
/* harmony import */ var _ConnectPreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ConnectPreview */ "./node_modules/diagram-js/lib/features/connect/ConnectPreview.js");







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _selection__WEBPACK_IMPORTED_MODULE_0__.default,
    _rules__WEBPACK_IMPORTED_MODULE_1__.default,
    _dragging__WEBPACK_IMPORTED_MODULE_2__.default
  ],
  __init__: [
    'connectPreview'
  ],
  connect: [ 'type', _Connect__WEBPACK_IMPORTED_MODULE_3__.default ],
  connectPreview: [ 'type', _ConnectPreview__WEBPACK_IMPORTED_MODULE_4__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/connection-preview/ConnectionPreview.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/connection-preview/ConnectionPreview.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ConnectionPreview)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");







var MARKER_CONNECTION_PREVIEW = 'djs-connection-preview';

/**
 * Draws connection preview. Optionally, this can use layouter and connection docking to draw
 * better looking previews.
 *
 * @param {didi.Injector} injector
 * @param {Canvas} canvas
 * @param {GraphicsFactory} graphicsFactory
 * @param {ElementFactory} elementFactory
 */
function ConnectionPreview(
    injector,
    canvas,
    graphicsFactory,
    elementFactory
) {
  this._canvas = canvas;
  this._graphicsFactory = graphicsFactory;
  this._elementFactory = elementFactory;

  // optional components
  this._connectionDocking = injector.get('connectionDocking', false);
  this._layouter = injector.get('layouter', false);
}

ConnectionPreview.$inject = [
  'injector',
  'canvas',
  'graphicsFactory',
  'elementFactory'
];

/**
 * Draw connection preview.
 *
 * Provide at least one of <source, connectionStart> and <target, connectionEnd> to create a preview.
 * In the clean up stage, call `connectionPreview#cleanUp` with the context to remove preview.
 *
 * @param {Object} context
 * @param {Object|boolean} canConnect
 * @param {Object} hints
 * @param {djs.model.shape} [hints.source] source element
 * @param {djs.model.shape} [hints.target] target element
 * @param {Point} [hints.connectionStart] connection preview start
 * @param {Point} [hints.connectionEnd] connection preview end
 * @param {Array<Point>} [hints.waypoints] provided waypoints for preview
 * @param {boolean} [hints.noLayout] true if preview should not be laid out
 * @param {boolean} [hints.noCropping] true if preview should not be cropped
 * @param {boolean} [hints.noNoop] true if simple connection should not be drawn
 */
ConnectionPreview.prototype.drawPreview = function(context, canConnect, hints) {

  hints = hints || {};

  var connectionPreviewGfx = context.connectionPreviewGfx,
      getConnection = context.getConnection,
      source = hints.source,
      target = hints.target,
      waypoints = hints.waypoints,
      connectionStart = hints.connectionStart,
      connectionEnd = hints.connectionEnd,
      noLayout = hints.noLayout,
      noCropping = hints.noCropping,
      noNoop = hints.noNoop,
      connection;

  var self = this;

  if (!connectionPreviewGfx) {
    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();
  }

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.clear)(connectionPreviewGfx);

  if (!getConnection) {
    getConnection = context.getConnection = cacheReturnValues(function(canConnect, source, target) {
      return self.getConnection(canConnect, source, target);
    });
  }

  if (canConnect) {
    connection = getConnection(canConnect, source, target);
  }

  if (!connection) {
    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);
    return;
  }

  connection.waypoints = waypoints || [];

  // optional layout
  if (this._layouter && !noLayout) {
    connection.waypoints = this._layouter.layoutConnection(connection, {
      source: source,
      target: target,
      connectionStart: connectionStart,
      connectionEnd: connectionEnd,
      waypoints: hints.waypoints || connection.waypoints
    });
  }

  // fallback if no waypoints were provided nor created with layouter
  if (!connection.waypoints || !connection.waypoints.length) {
    connection.waypoints = [
      source ? (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(source) : connectionStart,
      target ? (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(target) : connectionEnd
    ];
  }

  // optional cropping
  if (this._connectionDocking && (source || target) && !noCropping) {
    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);
  }

  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection);
};

/**
 * Draw simple connection between source and target or provided points.
 *
 * @param {SVGElement} connectionPreviewGfx container for the connection
 * @param {Object} hints
 * @param {djs.model.shape} [hints.source] source element
 * @param {djs.model.shape} [hints.target] target element
 * @param {Point} [hints.connectionStart] required if source is not provided
 * @param {Point} [hints.connectionEnd] required if target is not provided
 */
ConnectionPreview.prototype.drawNoopPreview = function(connectionPreviewGfx, hints) {
  var source = hints.source,
      target = hints.target,
      start = hints.connectionStart || (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(source),
      end = hints.connectionEnd || (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(target);

  var waypoints = this.cropWaypoints(start, end, source, target);

  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(connectionPreviewGfx, connection);
};

/**
 * Return cropped waypoints.
 *
 * @param {Point} start
 * @param {Point} end
 * @param {djs.model.shape} source
 * @param {djs.model.shape} target
 *
 * @returns {Array}
 */
ConnectionPreview.prototype.cropWaypoints = function(start, end, source, target) {
  var graphicsFactory = this._graphicsFactory,
      sourcePath = source && graphicsFactory.getShapePath(source),
      targetPath = target && graphicsFactory.getShapePath(target),
      connectionPath = graphicsFactory.getConnectionPath({ waypoints: [ start, end ] });

  start = (source && (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getElementLineIntersection)(sourcePath, connectionPath, true)) || start;
  end = (target && (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getElementLineIntersection)(targetPath, connectionPath, false)) || end;

  return [ start, end ];
};

/**
 * Remove connection preview container if it exists.
 *
 * @param {Object} [context]
 * @param {SVGElement} [context.connectionPreviewGfx] preview container
 */
ConnectionPreview.prototype.cleanUp = function(context) {
  if (context && context.connectionPreviewGfx) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.remove)(context.connectionPreviewGfx);
  }
};

/**
 * Get connection that connects source and target.
 *
 * @param {Object|boolean} canConnect
 *
 * @returns {djs.model.connection}
 */
ConnectionPreview.prototype.getConnection = function(canConnect) {
  var attrs = ensureConnectionAttrs(canConnect);

  return this._elementFactory.createConnection(attrs);
};


/**
 * Add and return preview graphics.
 *
 * @returns {SVGElement}
 */
ConnectionPreview.prototype.createConnectionPreviewGfx = function() {
  var gfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('g');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(gfx, {
    pointerEvents: 'none'
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.classes)(gfx).add(MARKER_CONNECTION_PREVIEW);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(this._canvas.getDefaultLayer(), gfx);

  return gfx;
};

/**
 * Create and return simple connection.
 *
 * @param {Point} start
 * @param {Point} end
 *
 * @returns {SVGElement}
 */
ConnectionPreview.prototype.createNoopConnection = function(start, end) {
  var connection = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('polyline');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(connection, {
    'stroke': '#333',
    'strokeDasharray': [ 1 ],
    'strokeWidth': 2,
    'pointer-events': 'none'
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(connection, { 'points': [ start.x, start.y, end.x, end.y ] });

  return connection;
};

// helpers //////////

/**
 * Returns function that returns cached return values referenced by stringified first argument.
 *
 * @param {Function} fn
 *
 * @return {Function}
 */
function cacheReturnValues(fn) {
  var returnValues = {};

  /**
   * Return cached return value referenced by stringified first argument.
   *
   * @returns {*}
   */
  return function(firstArgument) {
    var key = JSON.stringify(firstArgument);

    var returnValue = returnValues[key];

    if (!returnValue) {
      returnValue = returnValues[key] = fn.apply(null, arguments);
    }

    return returnValue;
  };
}

/**
 * Ensure connection attributes is object.
 *
 * @param {Object|boolean} canConnect
 *
 * @returns {Object}
 */
function ensureConnectionAttrs(canConnect) {
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isObject)(canConnect)) {
    return canConnect;
  } else {
    return {};
  }
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/connection-preview/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/connection-preview/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ConnectionPreview__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConnectionPreview */ "./node_modules/diagram-js/lib/features/connection-preview/ConnectionPreview.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'connectionPreview' ],
  connectionPreview: [ 'type', _ConnectionPreview__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/context-pad/ContextPad.js":
/*!************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/context-pad/ContextPad.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ContextPad)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");




var entrySelector = '.entry';

var DEFAULT_PRIORITY = 1000;


/**
 * A context pad that displays element specific, contextual actions next
 * to a diagram element.
 *
 * @param {Object} config
 * @param {boolean|Object} [config.scale={ min: 1.0, max: 1.5 }]
 * @param {number} [config.scale.min]
 * @param {number} [config.scale.max]
 * @param {EventBus} eventBus
 * @param {Overlays} overlays
 */
function ContextPad(config, eventBus, overlays) {

  this._eventBus = eventBus;
  this._overlays = overlays;

  var scale = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isDefined)(config && config.scale) ? config.scale : {
    min: 1,
    max: 1.5
  };

  this._overlaysConfig = {
    position: {
      right: -9,
      top: -6
    },
    scale: scale
  };

  this._current = null;

  this._init();
}

ContextPad.$inject = [
  'config.contextPad',
  'eventBus',
  'overlays'
];


/**
 * Registers events needed for interaction with other components
 */
ContextPad.prototype._init = function() {

  var eventBus = this._eventBus;

  var self = this;

  eventBus.on('selection.changed', function(e) {

    var selection = e.newSelection;

    if (selection.length === 1) {
      self.open(selection[0]);
    } else {
      self.close();
    }
  });

  eventBus.on('elements.delete', function(event) {
    var elements = event.elements;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(e) {
      if (self.isOpen(e)) {
        self.close();
      }
    });
  });

  eventBus.on('element.changed', function(event) {
    var element = event.element,
        current = self._current;

    // force reopen if element for which we are currently opened changed
    if (current && current.element === element) {
      self.open(element, true);
    }
  });
};


/**
 * Register a provider with the context pad
 *
 * @param  {number} [priority=1000]
 * @param  {ContextPadProvider} provider
 *
 * @example
 * const contextPadProvider = {
  *   getContextPadEntries: function(element) {
  *     return function(entries) {
  *       return {
  *         ...entries,
  *         'entry-1': {
  *           label: 'My Entry',
  *           action: function() { alert("I have been clicked!"); }
  *         }
  *       };
  *     }
  *   }
  * };
  *
 * contextPad.registerProvider(800, contextPadProvider);
 */
ContextPad.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY;
  }

  this._eventBus.on('contextPad.getProviders', priority, function(event) {
    event.providers.push(provider);
  });
};


/**
 * Returns the context pad entries for a given element
 *
 * @param {djs.element.Base} element
 *
 * @return {Array<ContextPadEntryDescriptor>} list of entries
 */
ContextPad.prototype.getEntries = function(element) {
  var providers = this._getProviders();

  var entries = {};

  // loop through all providers and their entries.
  // group entries by id so that overriding an entry is possible
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(providers, function(provider) {
    var entriesOrUpdater = provider.getContextPadEntries(element);

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });

  return entries;
};


/**
 * Trigger an action available on the opened context pad
 *
 * @param  {string} action
 * @param  {Event} event
 * @param  {boolean} [autoActivate=false]
 */
ContextPad.prototype.trigger = function(action, event, autoActivate) {

  var element = this._current.element,
      entries = this._current.entries,
      entry,
      handler,
      originalEvent,
      button = event.delegateTarget || event.target;

  if (!button) {
    return event.preventDefault();
  }

  entry = entries[(0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(button, 'data-action')];
  handler = entry.action;

  originalEvent = event.originalEvent || event;

  // simple action (via callback function)
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(handler)) {
    if (action === 'click') {
      return handler(originalEvent, element, autoActivate);
    }
  } else {
    if (handler[action]) {
      return handler[action](originalEvent, element, autoActivate);
    }
  }

  // silence other actions
  event.preventDefault();
};


/**
 * Open the context pad for the given element
 *
 * @param {djs.model.Base} element
 * @param {boolean} force if true, force reopening the context pad
 */
ContextPad.prototype.open = function(element, force) {
  if (!force && this.isOpen(element)) {
    return;
  }

  this.close();
  this._updateAndOpen(element);
};

ContextPad.prototype._getProviders = function() {

  var event = this._eventBus.createEvent({
    type: 'contextPad.getProviders',
    providers: []
  });

  this._eventBus.fire(event);

  return event.providers;
};

ContextPad.prototype._updateAndOpen = function(element) {

  var entries = this.getEntries(element),
      pad = this.getPad(element),
      html = pad.html;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(entries, function(entry, id) {
    var grouping = entry.group || 'default',
        control = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)(entry.html || '<div class="entry" draggable="true"></div>'),
        container;

    (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(control, 'data-action', id);

    container = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.query)('[data-group=' + grouping + ']', html);
    if (!container) {
      container = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div class="group" data-group="' + grouping + '"></div>');
      html.appendChild(container);
    }

    container.appendChild(control);

    if (entry.className) {
      addClasses(control, entry.className);
    }

    if (entry.title) {
      (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(control, 'title', entry.title);
    }

    if (entry.imageUrl) {
      control.appendChild((0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<img src="' + entry.imageUrl + '">'));
    }
  });

  (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(html).add('open');

  this._current = {
    element: element,
    pad: pad,
    entries: entries
  };

  this._eventBus.fire('contextPad.open', { current: this._current });
};


ContextPad.prototype.getPad = function(element) {
  if (this.isOpen()) {
    return this._current.pad;
  }

  var self = this;

  var overlays = this._overlays;

  var html = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div class="djs-context-pad"></div>');

  var overlaysConfig = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
    html: html
  }, this._overlaysConfig);

  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(html, entrySelector, 'click', function(event) {
    self.trigger('click', event);
  });

  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(html, entrySelector, 'dragstart', function(event) {
    self.trigger('dragstart', event);
  });

  // stop propagation of mouse events
  min_dom__WEBPACK_IMPORTED_MODULE_1__.event.bind(html, 'mousedown', function(event) {
    event.stopPropagation();
  });

  this._overlayId = overlays.add(element, 'context-pad', overlaysConfig);

  var pad = overlays.get(this._overlayId);

  this._eventBus.fire('contextPad.create', { element: element, pad: pad });

  return pad;
};


/**
 * Close the context pad
 */
ContextPad.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }

  this._overlays.remove(this._overlayId);

  this._overlayId = null;

  this._eventBus.fire('contextPad.close', { current: this._current });

  this._current = null;
};

/**
 * Check if pad is open. If element is given, will check
 * if pad is opened with given element.
 *
 * @param {Element} element
 * @return {boolean}
 */
ContextPad.prototype.isOpen = function(element) {
  return !!this._current && (!element ? true : this._current.element === element);
};




// helpers //////////////////////

function addClasses(element, classNames) {

  var classes = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(element);

  var actualClassNames = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(classNames) ? classNames : classNames.split(/\s+/g);
  actualClassNames.forEach(function(cls) {
    classes.add(cls);
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/context-pad/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/context-pad/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interaction_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interaction-events */ "./node_modules/diagram-js/lib/features/interaction-events/index.js");
/* harmony import */ var _overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../overlays */ "./node_modules/diagram-js/lib/features/overlays/index.js");
/* harmony import */ var _ContextPad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ContextPad */ "./node_modules/diagram-js/lib/features/context-pad/ContextPad.js");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _interaction_events__WEBPACK_IMPORTED_MODULE_0__.default,
    _overlays__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  contextPad: [ 'type', _ContextPad__WEBPACK_IMPORTED_MODULE_2__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CopyPaste)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");






/**
 * @typedef {Function} <copyPaste.canCopyElements> listener
 *
 * @param {Object} context
 * @param {Array<djs.model.Base>} context.elements
 *
 * @returns {Array<djs.model.Base>|boolean} - Return elements to be copied or false to disallow
 * copying.
 */

/**
 * @typedef {Function} <copyPaste.copyElement> listener
 *
 * @param {Object} context
 * @param {Object} context.descriptor
 * @param {djs.model.Base} context.element
 * @param {Array<djs.model.Base>} context.elements
 */

/**
 * @typedef {Function} <copyPaste.elementsCopied> listener
 *
 * @param {Object} context
 * @param {Object} context.elements
 * @param {Object} context.tree
 */

/**
 * @typedef {Function} <copyPaste.pasteElement> listener
 *
 * @param {Object} context
 * @param {Object} context.cache - Already created elements.
 * @param {Object} context.descriptor
 */

/**
 * @typedef {Function} <copyPaste.pasteElements> listener
 *
 * @param {Object} context
 * @param {Object} context.hints - Add hints before pasting.
 */

/**
 * Copy and paste elements.
 *
 * @param {Canvas} canvas
 * @param {Create} create
 * @param {Clipboard} clipboard
 * @param {ElementFactory} elementFactory
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 * @param {Mouse} mouse
 * @param {Rules} rules
 */
function CopyPaste(
    canvas,
    create,
    clipboard,
    elementFactory,
    eventBus,
    modeling,
    mouse,
    rules
) {

  this._canvas = canvas;
  this._create = create;
  this._clipboard = clipboard;
  this._elementFactory = elementFactory;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._mouse = mouse;
  this._rules = rules;

  eventBus.on('copyPaste.copyElement', function(context) {
    var descriptor = context.descriptor,
        element = context.element,
        elements = context.elements;

    // default priority (priority = 1)
    descriptor.priority = 1;

    descriptor.id = element.id;

    var parentCopied = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, function(e) {
      return e === element.parent;
    });

    // do NOT reference parent if parent wasn't copied
    if (parentCopied) {
      descriptor.parent = element.parent.id;
    }

    // attachers (priority = 2)
    if (isAttacher(element)) {
      descriptor.priority = 2;

      descriptor.host = element.host.id;
    }

    // connections (priority = 3)
    if (isConnection(element)) {
      descriptor.priority = 3;

      descriptor.source = element.source.id;
      descriptor.target = element.target.id;

      descriptor.waypoints = copyWaypoints(element);
    }

    // labels (priority = 4)
    if (isLabel(element)) {
      descriptor.priority = 4;

      descriptor.labelTarget = element.labelTarget.id;
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)([ 'x', 'y', 'width', 'height' ], function(property) {
      if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element[ property ])) {
        descriptor[ property ] = element[ property ];
      }
    });

    descriptor.hidden = element.hidden;
    descriptor.collapsed = element.collapsed;

  });

  eventBus.on('copyPaste.pasteElements', function(context) {
    var hints = context.hints;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(hints, {
      createElementsBehavior: false
    });
  });
}

CopyPaste.$inject = [
  'canvas',
  'create',
  'clipboard',
  'elementFactory',
  'eventBus',
  'modeling',
  'mouse',
  'rules'
];


/**
 * Copy elements.
 *
 * @param {Array<djs.model.Base>} elements
 *
 * @returns {Object}
 */
CopyPaste.prototype.copy = function(elements) {
  var allowed,
      tree;

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements)) {
    elements = elements ? [ elements ] : [];
  }

  allowed = this._eventBus.fire('copyPaste.canCopyElements', {
    elements: elements
  });

  if (allowed === false) {
    tree = {};
  } else {
    tree = this.createTree((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(allowed) ? allowed : elements);
  }

  // we set an empty tree, selection of elements
  // to copy was empty.
  this._clipboard.set(tree);

  this._eventBus.fire('copyPaste.elementsCopied', {
    elements: elements,
    tree: tree
  });

  return tree;
};

/**
 * Paste elements.
 *
 * @param {Object} [context]
 * @param {djs.model.base} [context.element] - Parent.
 * @param {Point} [context.point] - Position.
 * @param {Object} [context.hints] - Hints.
 */
CopyPaste.prototype.paste = function(context) {
  var tree = this._clipboard.get();

  if (this._clipboard.isEmpty()) {
    return;
  }

  var hints = context && context.hints || {};

  this._eventBus.fire('copyPaste.pasteElements', {
    hints: hints
  });

  var elements = this._createElements(tree);

  // paste directly
  if (context && context.element && context.point) {
    return this._paste(elements, context.element, context.point, hints);
  }

  this._create.start(this._mouse.getLastMoveEvent(), elements, {
    hints: hints || {}
  });
};

/**
 * Paste elements directly.
 *
 * @param {Array<djs.model.Base>} elements
 * @param {djs.model.base} target
 * @param {Point} position
 * @param {Object} [hints]
 */
CopyPaste.prototype._paste = function(elements, target, position, hints) {

  // make sure each element has x and y
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.x)) {
      element.x = 0;
    }

    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.y)) {
      element.y = 0;
    }
  });

  var bbox = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.getBBox)(elements);

  // center elements around cursor
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    if (isConnection(element)) {
      element.waypoints = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(element.waypoints, function(waypoint) {
        return {
          x: waypoint.x - bbox.x - bbox.width / 2,
          y: waypoint.y - bbox.y - bbox.height / 2
        };
      });
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(element, {
      x: element.x - bbox.x - bbox.width / 2,
      y: element.y - bbox.y - bbox.height / 2
    });
  });

  return this._modeling.createElements(elements, position, target, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, hints));
};

/**
 * Create elements from tree.
 */
CopyPaste.prototype._createElements = function(tree) {
  var self = this;

  var eventBus = this._eventBus;

  var cache = {};

  var elements = [];

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(tree, function(branch, depth) {

    depth = parseInt(depth, 10);

    // sort by priority
    branch = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(branch, 'priority');

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(branch, function(descriptor) {

      // remove priority
      var attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(descriptor, [ 'priority' ]));

      if (cache[ descriptor.parent ]) {
        attrs.parent = cache[ descriptor.parent ];
      } else {
        delete attrs.parent;
      }

      eventBus.fire('copyPaste.pasteElement', {
        cache: cache,
        descriptor: attrs
      });

      var element;

      if (isConnection(attrs)) {
        attrs.source = cache[ descriptor.source ];
        attrs.target = cache[ descriptor.target ];

        element = cache[ descriptor.id ] = self.createConnection(attrs);

        elements.push(element);

        return;
      }

      if (isLabel(attrs)) {
        attrs.labelTarget = cache[ attrs.labelTarget ];

        element = cache[ descriptor.id ] = self.createLabel(attrs);

        elements.push(element);

        return;
      }

      if (attrs.host) {
        attrs.host = cache[ attrs.host ];
      }

      element = cache[ descriptor.id ] = self.createShape(attrs);

      elements.push(element);
    });

  });

  return elements;
};

CopyPaste.prototype.createConnection = function(attrs) {
  var connection = this._elementFactory.createConnection((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(attrs, [ 'id' ]));

  return connection;
};

CopyPaste.prototype.createLabel = function(attrs) {
  var label = this._elementFactory.createLabel((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(attrs, [ 'id' ]));

  return label;
};

CopyPaste.prototype.createShape = function(attrs) {
  var shape = this._elementFactory.createShape((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(attrs, [ 'id' ]));

  return shape;
};

/**
 * Check wether element has relations to other elements e.g. attachers, labels and connections.
 *
 * @param  {Object} element
 * @param  {Array<djs.model.Base>} elements
 *
 * @returns {boolean}
 */
CopyPaste.prototype.hasRelations = function(element, elements) {
  var labelTarget,
      source,
      target;

  if (isConnection(element)) {
    source = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.matchPattern)({ id: element.source.id }));
    target = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.matchPattern)({ id: element.target.id }));

    if (!source || !target) {
      return false;
    }
  }

  if (isLabel(element)) {
    labelTarget = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.matchPattern)({ id: element.labelTarget.id }));

    if (!labelTarget) {
      return false;
    }
  }

  return true;
};

/**
 * Create a tree-like structure from elements.
 *
 * @example
 * tree: {
  *  0: [
  *    { id: 'Shape_1', priority: 1, ... },
  *    { id: 'Shape_2', priority: 1, ... },
  *    { id: 'Connection_1', source: 'Shape_1', target: 'Shape_2', priority: 3, ... },
  *    ...
  *  ],
  *  1: [
  *    { id: 'Shape_3', parent: 'Shape1', priority: 1, ... },
  *    ...
  *  ]
  * };
  *
  * @param  {Array<djs.model.base>} elements
  *
  * @return {Object}
  */
CopyPaste.prototype.createTree = function(elements) {
  var rules = this._rules,
      self = this;

  var tree = {},
      elementsData = [];

  var parents = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.getParents)(elements);

  function canCopy(element, elements) {
    return rules.allowed('element.copy', {
      element: element,
      elements: elements
    });
  }

  function addElementData(element, depth) {

    // (1) check wether element has already been added
    var foundElementData = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elementsData, function(elementsData) {
      return element === elementsData.element;
    });

    // (2) add element if not already added
    if (!foundElementData) {
      elementsData.push({
        element: element,
        depth: depth
      });

      return;
    }

    // (3) update depth
    if (foundElementData.depth < depth) {
      elementsData = removeElementData(foundElementData, elementsData);

      elementsData.push({
        element: foundElementData.element,
        depth: depth
      });
    }
  }

  function removeElementData(elementData, elementsData) {
    var index = elementsData.indexOf(elementData);

    if (index !== -1) {
      elementsData.splice(index, 1);
    }

    return elementsData;
  }

  // (1) add elements
  (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.eachElement)(parents, function(element, _index, depth) {

    // do NOT add external labels directly
    if (isLabel(element)) {
      return;
    }

    // always copy external labels
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(element.labels, function(label) {
      addElementData(label, depth);
    });

    function addRelatedElements(elements) {
      elements && elements.length && (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {

        // add external labels
        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(element.labels, function(label) {
          addElementData(label, depth);
        });

        addElementData(element, depth);
      });
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)([ element.attachers, element.incoming, element.outgoing ], addRelatedElements);

    addElementData(element, depth);

    return element.children;
  });

  elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(elementsData, function(elementData) {
    return elementData.element;
  });

  // (2) copy elements
  elementsData = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(elementsData, function(elementData) {
    elementData.descriptor = {};

    self._eventBus.fire('copyPaste.copyElement', {
      descriptor: elementData.descriptor,
      element: elementData.element,
      elements: elements
    });

    return elementData;
  });

  // (3) sort elements by priority
  elementsData = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(elementsData, function(elementData) {
    return elementData.descriptor.priority;
  });

  elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(elementsData, function(elementData) {
    return elementData.element;
  });

  // (4) create tree
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elementsData, function(elementData) {
    var depth = elementData.depth;

    if (!self.hasRelations(elementData.element, elements)) {
      removeElement(elementData.element, elements);

      return;
    }

    if (!canCopy(elementData.element, elements)) {
      removeElement(elementData.element, elements);

      return;
    }

    if (!tree[depth]) {
      tree[depth] = [];
    }

    tree[depth].push(elementData.descriptor);
  });

  return tree;
};

// helpers //////////

function isAttacher(element) {
  return !!element.host;
}

function isConnection(element) {
  return !!element.waypoints;
}

function isLabel(element) {
  return !!element.labelTarget;
}

function copyWaypoints(element) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(element.waypoints, function(waypoint) {

    waypoint = copyWaypoint(waypoint);

    if (waypoint.original) {
      waypoint.original = copyWaypoint(waypoint.original);
    }

    return waypoint;
  });
}

function copyWaypoint(waypoint) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, waypoint);
}

function removeElement(element, elements) {
  var index = elements.indexOf(element);

  if (index === -1) {
    return elements;
  }

  return elements.splice(index, 1);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/copy-paste/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/copy-paste/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clipboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clipboard */ "./node_modules/diagram-js/lib/features/clipboard/index.js");
/* harmony import */ var _create__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../create */ "./node_modules/diagram-js/lib/features/create/index.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mouse */ "./node_modules/diagram-js/lib/features/mouse/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _CopyPaste__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CopyPaste */ "./node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js");








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _clipboard__WEBPACK_IMPORTED_MODULE_0__.default,
    _create__WEBPACK_IMPORTED_MODULE_1__.default,
    _mouse__WEBPACK_IMPORTED_MODULE_2__.default,
    _rules__WEBPACK_IMPORTED_MODULE_3__.default
  ],
  __init__: [ 'copyPaste' ],
  copyPaste: [ 'type', _CopyPaste__WEBPACK_IMPORTED_MODULE_4__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/create/Create.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/create/Create.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Create)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
var MARKER_OK = 'drop-ok',
    MARKER_NOT_OK = 'drop-not-ok',
    MARKER_ATTACH = 'attach-ok',
    MARKER_NEW_PARENT = 'new-parent';





var PREFIX = 'create';

var HIGH_PRIORITY = 2000;


/**
 * Create new elements through drag and drop.
 *
 * @param {Canvas} canvas
 * @param {Dragging} dragging
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 * @param {Rules} rules
 */
function Create(
    canvas,
    dragging,
    eventBus,
    modeling,
    rules
) {

  // rules //////////

  /**
   * Check wether elements can be created.
   *
   * @param {Array<djs.model.Base>} elements
   * @param {djs.model.Base} target
   * @param {Point} position
   * @param {djs.model.Base} [source]
   *
   * @returns {boolean|null|Object}
   */
  function canCreate(elements, target, position, source, hints) {
    if (!target) {
      return false;
    }

    // ignore child elements and external labels
    elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.filter)(elements, function(element) {
      var labelTarget = element.labelTarget;

      return !element.parent && !(isLabel(element) && elements.indexOf(labelTarget) !== -1);
    });

    var shape = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, function(element) {
      return !isConnection(element);
    });

    var attach = false,
        connect = false,
        create = false;

    // (1) attaching single shapes
    if (isSingleShape(elements)) {
      attach = rules.allowed('shape.attach', {
        position: position,
        shape: shape,
        target: target
      });
    }

    if (!attach) {

      // (2) creating elements
      if (isSingleShape(elements)) {
        create = rules.allowed('shape.create', {
          position: position,
          shape: shape,
          source: source,
          target: target
        });
      } else {
        create = rules.allowed('elements.create', {
          elements: elements,
          position: position,
          target: target
        });
      }

    }

    var connectionTarget = hints.connectionTarget;

    // (3) appending single shapes
    if (create || attach) {
      if (shape && source) {
        connect = rules.allowed('connection.create', {
          source: connectionTarget === source ? shape : source,
          target: connectionTarget === source ? source : shape,
          hints: {
            targetParent: target,
            targetAttach: attach
          }
        });
      }

      return {
        attach: attach,
        connect: connect
      };
    }

    // ignore wether or not elements can be created
    if (create === null || attach === null) {
      return null;
    }

    return false;
  }

  function setMarker(element, marker) {
    [ MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT ].forEach(function(m) {

      if (m === marker) {
        canvas.addMarker(element, m);
      } else {
        canvas.removeMarker(element, m);
      }
    });
  }

  // event handling //////////

  eventBus.on([ 'create.move', 'create.hover' ], function(event) {
    var context = event.context,
        elements = context.elements,
        hover = event.hover,
        source = context.source,
        hints = context.hints || {};

    if (!hover) {
      context.canExecute = false;
      context.target = null;

      return;
    }

    ensureConstraints(event);

    var position = {
      x: event.x,
      y: event.y
    };

    var canExecute = context.canExecute = hover && canCreate(elements, hover, position, source, hints);

    if (hover && canExecute !== null) {
      context.target = hover;

      if (canExecute && canExecute.attach) {
        setMarker(hover, MARKER_ATTACH);
      } else {
        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);
      }
    }
  });

  eventBus.on([ 'create.end', 'create.out', 'create.cleanup' ], function(event) {
    var hover = event.hover;

    if (hover) {
      setMarker(hover, null);
    }
  });

  eventBus.on('create.end', function(event) {
    var context = event.context,
        source = context.source,
        shape = context.shape,
        elements = context.elements,
        target = context.target,
        canExecute = context.canExecute,
        attach = canExecute && canExecute.attach,
        connect = canExecute && canExecute.connect,
        hints = context.hints || {};

    if (canExecute === false || !target) {
      return false;
    }

    ensureConstraints(event);

    var position = {
      x: event.x,
      y: event.y
    };

    if (connect) {
      shape = modeling.appendShape(source, shape, position, target, {
        attach: attach,
        connection: connect === true ? {} : connect,
        connectionTarget: hints.connectionTarget
      });
    } else {
      elements = modeling.createElements(elements, position, target, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, hints, {
        attach: attach
      }));

      // update shape
      shape = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, function(element) {
        return !isConnection(element);
      });
    }

    // update elements and shape
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(context, {
      elements: elements,
      shape: shape
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(event, {
      elements: elements,
      shape: shape
    });
  });

  function cancel() {
    var context = dragging.context();

    if (context && context.prefix === PREFIX) {
      dragging.cancel();
    }
  }

  // cancel on <elements.changed> that is not result of <drag.end>
  eventBus.on('create.init', function() {
    eventBus.on('elements.changed', cancel);

    eventBus.once([ 'create.cancel', 'create.end' ], HIGH_PRIORITY, function() {
      eventBus.off('elements.changed', cancel);
    });
  });

  // API //////////

  this.start = function(event, elements, context) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements)) {
      elements = [ elements ];
    }

    var shape = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, function(element) {
      return !isConnection(element);
    });

    if (!shape) {

      // at least one shape is required
      return;
    }

    context = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
      elements: elements,
      hints: {},
      shape: shape
    }, context || {});

    // make sure each element has x and y
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
      if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.x)) {
        element.x = 0;
      }

      if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.y)) {
        element.y = 0;
      }
    });

    var bbox = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.getBBox)(elements);

    // center elements around cursor
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
      if (isConnection(element)) {
        element.waypoints = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(element.waypoints, function(waypoint) {
          return {
            x: waypoint.x - bbox.x - bbox.width / 2,
            y: waypoint.y - bbox.y - bbox.height / 2
          };
        });
      }

      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(element, {
        x: element.x - bbox.x - bbox.width / 2,
        y: element.y - bbox.y - bbox.height / 2
      });
    });

    dragging.init(event, PREFIX, {
      cursor: 'grabbing',
      autoActivate: true,
      data: {
        shape: shape,
        elements: elements,
        context: context
      }
    });
  };
}

Create.$inject = [
  'canvas',
  'dragging',
  'eventBus',
  'modeling',
  'rules'
];

// helpers //////////

function ensureConstraints(event) {
  var context = event.context,
      createConstraints = context.createConstraints;

  if (!createConstraints) {
    return;
  }

  if (createConstraints.left) {
    event.x = Math.max(event.x, createConstraints.left);
  }

  if (createConstraints.right) {
    event.x = Math.min(event.x, createConstraints.right);
  }

  if (createConstraints.top) {
    event.y = Math.max(event.y, createConstraints.top);
  }

  if (createConstraints.bottom) {
    event.y = Math.min(event.y, createConstraints.bottom);
  }
}

function isConnection(element) {
  return !!element.waypoints;
}

function isSingleShape(elements) {
  return elements && elements.length === 1 && !isConnection(elements[0]);
}

function isLabel(element) {
  return !!element.labelTarget;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/create/CreatePreview.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/create/CreatePreview.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreatePreview)
/* harmony export */ });
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var _util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/GraphicsUtil */ "./node_modules/diagram-js/lib/util/GraphicsUtil.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");






var LOW_PRIORITY = 750;


function CreatePreview(
    canvas,
    eventBus,
    graphicsFactory,
    previewSupport,
    styles
) {
  function createDragGroup(elements) {
    var dragGroup = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('g');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(dragGroup, styles.cls('djs-drag-group', [ 'no-events' ]));

    var childrenGfx = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('g');

    elements.forEach(function(element) {

      // create graphics
      var gfx;

      if (element.hidden) {
        return;
      }

      if (element.waypoints) {
        gfx = graphicsFactory._createContainer('connection', childrenGfx);

        graphicsFactory.drawConnection((0,_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_1__.getVisual)(gfx), element);
      } else {
        gfx = graphicsFactory._createContainer('shape', childrenGfx);

        graphicsFactory.drawShape((0,_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_1__.getVisual)(gfx), element);

        (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__.translate)(gfx, element.x, element.y);
      }

      // add preview
      previewSupport.addDragger(element, dragGroup, gfx);
    });

    return dragGroup;
  }

  eventBus.on('create.move', LOW_PRIORITY, function(event) {

    var hover = event.hover,
        context = event.context,
        elements = context.elements,
        dragGroup = context.dragGroup;

    // lazily create previews
    if (!dragGroup) {
      dragGroup = context.dragGroup = createDragGroup(elements);
    }

    var defaultLayer;

    if (hover) {
      if (!dragGroup.parentNode) {
        defaultLayer = canvas.getDefaultLayer();

        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(defaultLayer, dragGroup);
      }

      (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__.translate)(dragGroup, event.x, event.y);
    } else {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.remove)(dragGroup);
    }
  });

  eventBus.on('create.cleanup', function(event) {
    var context = event.context,
        dragGroup = context.dragGroup;

    if (dragGroup) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.remove)(dragGroup);
    }
  });
}

CreatePreview.$inject = [
  'canvas',
  'eventBus',
  'graphicsFactory',
  'previewSupport',
  'styles'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/create/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/create/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _preview_support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../preview-support */ "./node_modules/diagram-js/lib/features/preview-support/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _Create__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Create */ "./node_modules/diagram-js/lib/features/create/Create.js");
/* harmony import */ var _CreatePreview__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CreatePreview */ "./node_modules/diagram-js/lib/features/create/CreatePreview.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _dragging__WEBPACK_IMPORTED_MODULE_0__.default,
    _preview_support__WEBPACK_IMPORTED_MODULE_1__.default,
    _rules__WEBPACK_IMPORTED_MODULE_2__.default,
    _selection__WEBPACK_IMPORTED_MODULE_3__.default
  ],
  __init__: [
    'create',
    'createPreview'
  ],
  create: [ 'type', _Create__WEBPACK_IMPORTED_MODULE_4__.default ],
  createPreview: [ 'type', _CreatePreview__WEBPACK_IMPORTED_MODULE_5__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/dragging/Dragging.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/dragging/Dragging.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Dragging)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");
/* harmony import */ var _util_Cursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Cursor */ "./node_modules/diagram-js/lib/util/Cursor.js");
/* harmony import */ var _util_ClickTrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/ClickTrap */ "./node_modules/diagram-js/lib/util/ClickTrap.js");
/* harmony import */ var _util_PositionUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/PositionUtil */ "./node_modules/diagram-js/lib/util/PositionUtil.js");
var round = Math.round;













var DRAG_ACTIVE_CLS = 'djs-drag-active';


function preventDefault(event) {
  event.preventDefault();
}

function isTouchEvent(event) {

  // check for TouchEvent being available first
  // (i.e. not available on desktop Firefox)
  return typeof TouchEvent !== 'undefined' && event instanceof TouchEvent;
}

function getLength(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}

/**
 * A helper that fires canvas localized drag events and realizes
 * the general "drag-and-drop" look and feel.
 *
 * Calling {@link Dragging#activate} activates dragging on a canvas.
 *
 * It provides the following:
 *
 *   * emits life cycle events, namespaced with a prefix assigned
 *     during dragging activation
 *   * sets and restores the cursor
 *   * sets and restores the selection if elements still exist
 *   * ensures there can be only one drag operation active at a time
 *
 * Dragging may be canceled manually by calling {@link Dragging#cancel}
 * or by pressing ESC.
 *
 *
 * ## Life-cycle events
 *
 * Dragging can be in three different states, off, initialized
 * and active.
 *
 * (1) off: no dragging operation is in progress
 * (2) initialized: a new drag operation got initialized but not yet
 *                  started (i.e. because of no initial move)
 * (3) started: dragging is in progress
 *
 * Eventually dragging will be off again after a drag operation has
 * been ended or canceled via user click or ESC key press.
 *
 * To indicate transitions between these states dragging emits generic
 * life-cycle events with the `drag.` prefix _and_ events namespaced
 * to a prefix choosen by a user during drag initialization.
 *
 * The following events are emitted (appropriately prefixed) via
 * the {@link EventBus}.
 *
 * * `init`
 * * `start`
 * * `move`
 * * `end`
 * * `ended` (dragging already in off state)
 * * `cancel` (only if previously started)
 * * `canceled` (dragging already in off state, only if previously started)
 * * `cleanup`
 *
 *
 * @example
 *
 * function MyDragComponent(eventBus, dragging) {
 *
 *   eventBus.on('mydrag.start', function(event) {
 *     console.log('yes, we start dragging');
 *   });
 *
 *   eventBus.on('mydrag.move', function(event) {
 *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);
 *
 *     // local drag data is passed with the event
 *     event.context.foo; // "BAR"
 *
 *     // the original mouse event, too
 *     event.originalEvent; // MouseEvent(...)
 *   });
 *
 *   eventBus.on('element.click', function(event) {
 *     dragging.init(event, 'mydrag', {
 *       cursor: 'grabbing',
 *       data: {
 *         context: {
 *           foo: "BAR"
 *         }
 *       }
 *     });
 *   });
 * }
 */
function Dragging(eventBus, canvas, selection, elementRegistry) {

  var defaultOptions = {
    threshold: 5,
    trapClick: true
  };

  // the currently active drag operation
  // dragging is active as soon as this context exists.
  //
  // it is visually _active_ only when a context.active flag is set to true.
  var context;

  /* convert a global event into local coordinates */
  function toLocalPoint(globalPosition) {

    var viewbox = canvas.viewbox();

    var clientRect = canvas._container.getBoundingClientRect();

    return {
      x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,
      y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale
    };
  }

  // helpers

  function fire(type, dragContext) {
    dragContext = dragContext || context;

    var event = eventBus.createEvent(
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(
        {},
        dragContext.payload,
        dragContext.data,
        { isTouch: dragContext.isTouch }
      )
    );

    // default integration
    if (eventBus.fire('drag.' + type, event) === false) {
      return false;
    }

    return eventBus.fire(dragContext.prefix + '.' + type, event);
  }

  function restoreSelection(previousSelection) {
    var existingSelection = previousSelection.filter(function(element) {
      return elementRegistry.get(element.id);
    });

    existingSelection.length && selection.select(existingSelection);
  }

  // event listeners

  function move(event, activate) {
    var payload = context.payload,
        displacement = context.displacement;

    var globalStart = context.globalStart,
        globalCurrent = (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.toPoint)(event),
        globalDelta = (0,_util_PositionUtil__WEBPACK_IMPORTED_MODULE_2__.delta)(globalCurrent, globalStart);

    var localStart = context.localStart,
        localCurrent = toLocalPoint(globalCurrent),
        localDelta = (0,_util_PositionUtil__WEBPACK_IMPORTED_MODULE_2__.delta)(localCurrent, localStart);


    // activate context explicitly or once threshold is reached
    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {

      // fire start event with original
      // starting coordinates

      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(payload, {
        x: round(localStart.x + displacement.x),
        y: round(localStart.y + displacement.y),
        dx: 0,
        dy: 0
      }, { originalEvent: event });

      if (false === fire('start')) {
        return cancel();
      }

      context.active = true;

      // unset selection and remember old selection
      // the previous (old) selection will always passed
      // with the event via the event.previousSelection property
      if (!context.keepSelection) {
        payload.previousSelection = selection.get();
        selection.select(null);
      }

      // allow custom cursor
      if (context.cursor) {
        (0,_util_Cursor__WEBPACK_IMPORTED_MODULE_3__.set)(context.cursor);
      }

      // indicate dragging via marker on root element
      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    }

    (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.stopPropagation)(event);

    if (context.active) {

      // update payload with actual coordinates
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(payload, {
        x: round(localCurrent.x + displacement.x),
        y: round(localCurrent.y + displacement.y),
        dx: round(localDelta.x),
        dy: round(localDelta.y)
      }, { originalEvent: event });

      // emit move event
      fire('move');
    }
  }

  function end(event) {
    var previousContext,
        returnValue = true;

    if (context.active) {

      if (event) {
        context.payload.originalEvent = event;

        // suppress original event (click, ...)
        // because we just ended a drag operation
        (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.stopPropagation)(event);
      }

      // implementations may stop restoring the
      // original state (selections, ...) by preventing the
      // end events default action
      returnValue = fire('end');
    }

    if (returnValue === false) {
      fire('rejected');
    }

    previousContext = cleanup(returnValue !== true);

    // last event to be fired when all drag operations are done
    // at this point in time no drag operation is in progress anymore
    fire('ended', previousContext);
  }


  // cancel active drag operation if the user presses
  // the ESC key on the keyboard

  function checkCancel(event) {

    if (event.which === 27) {
      preventDefault(event);

      cancel();
    }
  }


  // prevent ghost click that might occur after a finished
  // drag and drop session

  function trapClickAndEnd(event) {

    var untrap;

    // trap the click in case we are part of an active
    // drag operation. This will effectively prevent
    // the ghost click that cannot be canceled otherwise.
    if (context.active) {

      untrap = (0,_util_ClickTrap__WEBPACK_IMPORTED_MODULE_4__.install)(eventBus);

      // remove trap after minimal delay
      setTimeout(untrap, 400);

      // prevent default action (click)
      preventDefault(event);
    }

    end(event);
  }

  function trapTouch(event) {
    move(event);
  }

  // update the drag events hover (djs.model.Base) and hoverGfx (Snap<SVGElement>)
  // properties during hover and out and fire {prefix}.hover and {prefix}.out properties
  // respectively

  function hover(event) {
    var payload = context.payload;

    payload.hoverGfx = event.gfx;
    payload.hover = event.element;

    fire('hover');
  }

  function out(event) {
    fire('out');

    var payload = context.payload;

    payload.hoverGfx = null;
    payload.hover = null;
  }


  // life-cycle methods

  function cancel(restore) {
    var previousContext;

    if (!context) {
      return;
    }

    var wasActive = context.active;

    if (wasActive) {
      fire('cancel');
    }

    previousContext = cleanup(restore);

    if (wasActive) {

      // last event to be fired when all drag operations are done
      // at this point in time no drag operation is in progress anymore
      fire('canceled', previousContext);
    }
  }

  function cleanup(restore) {
    var previousContext,
        endDrag;

    fire('cleanup');

    // reset cursor
    (0,_util_Cursor__WEBPACK_IMPORTED_MODULE_3__.unset)();

    if (context.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }

    // reset dom listeners
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'mousemove', move);

    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'dragstart', preventDefault);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'selectstart', preventDefault);

    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'mousedown', endDrag, true);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'mouseup', endDrag, true);

    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'keyup', checkCancel);

    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'touchstart', trapTouch, true);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'touchcancel', cancel, true);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'touchmove', move, true);
    min_dom__WEBPACK_IMPORTED_MODULE_5__.event.unbind(document, 'touchend', end, true);

    eventBus.off('element.hover', hover);
    eventBus.off('element.out', out);

    // remove drag marker on root element
    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);

    // restore selection, unless it has changed
    var previousSelection = context.payload.previousSelection;

    if (restore !== false && previousSelection && !selection.get().length) {
      restoreSelection(previousSelection);
    }

    previousContext = context;

    context = null;

    return previousContext;
  }

  /**
   * Initialize a drag operation.
   *
   * If `localPosition` is given, drag events will be emitted
   * relative to it.
   *
   * @param {MouseEvent|TouchEvent} [event]
   * @param {Point} [localPosition] actual diagram local position this drag operation should start at
   * @param {string} prefix
   * @param {Object} [options]
   */
  function init(event, relativeTo, prefix, options) {

    // only one drag operation may be active, at a time
    if (context) {
      cancel(false);
    }

    if (typeof relativeTo === 'string') {
      options = prefix;
      prefix = relativeTo;
      relativeTo = null;
    }

    options = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, defaultOptions, options || {});

    var data = options.data || {},
        originalEvent,
        globalStart,
        localStart,
        endDrag,
        isTouch;

    if (options.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }

    if (event) {
      originalEvent = (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.getOriginal)(event) || event;
      globalStart = (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.toPoint)(event);

      (0,_util_Event__WEBPACK_IMPORTED_MODULE_1__.stopPropagation)(event);

      // prevent default browser dragging behavior
      if (originalEvent.type === 'dragstart') {
        preventDefault(originalEvent);
      }
    } else {
      originalEvent = null;
      globalStart = { x: 0, y: 0 };
    }

    localStart = toLocalPoint(globalStart);

    if (!relativeTo) {
      relativeTo = localStart;
    }

    isTouch = isTouchEvent(originalEvent);

    context = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({
      prefix: prefix,
      data: data,
      payload: {},
      globalStart: globalStart,
      displacement: (0,_util_PositionUtil__WEBPACK_IMPORTED_MODULE_2__.delta)(relativeTo, localStart),
      localStart: localStart,
      isTouch: isTouch
    }, options);

    // skip dom registration if trigger
    // is set to manual (during testing)
    if (!options.manual) {

      // add dom listeners

      if (isTouch) {
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'touchstart', trapTouch, true);
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'touchcancel', cancel, true);
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'touchmove', move, true);
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'touchend', end, true);
      } else {

        // assume we use the mouse to interact per default
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'mousemove', move);

        // prevent default browser drag and text selection behavior
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'dragstart', preventDefault);
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'selectstart', preventDefault);

        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'mousedown', endDrag, true);
        min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'mouseup', endDrag, true);
      }

      min_dom__WEBPACK_IMPORTED_MODULE_5__.event.bind(document, 'keyup', checkCancel);

      eventBus.on('element.hover', hover);
      eventBus.on('element.out', out);
    }

    fire('init');

    if (options.autoActivate) {
      move(event, true);
    }
  }

  // cancel on diagram destruction
  eventBus.on('diagram.destroy', cancel);


  // API

  this.init = init;
  this.move = move;
  this.hover = hover;
  this.out = out;
  this.end = end;

  this.cancel = cancel;

  // for introspection

  this.context = function() {
    return context;
  };

  this.setOptions = function(options) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(defaultOptions, options);
  };
}

Dragging.$inject = [
  'eventBus',
  'canvas',
  'selection',
  'elementRegistry'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/dragging/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/dragging/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _hover_fix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../hover-fix */ "./node_modules/diagram-js/lib/features/hover-fix/index.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _Dragging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dragging */ "./node_modules/diagram-js/lib/features/dragging/Dragging.js");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _hover_fix__WEBPACK_IMPORTED_MODULE_0__.default,
    _selection__WEBPACK_IMPORTED_MODULE_1__.default,
  ],
  dragging: [ 'type', _Dragging__WEBPACK_IMPORTED_MODULE_2__.default ],
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/editor-actions/EditorActions.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/editor-actions/EditorActions.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EditorActions)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var NOT_REGISTERED_ERROR = 'is not a registered action',
    IS_REGISTERED_ERROR = 'is already registered';


/**
 * An interface that provides access to modeling actions by decoupling
 * the one who requests the action to be triggered and the trigger itself.
 *
 * It's possible to add new actions by registering them with registerAction
 * and likewise unregister existing ones with unregisterAction.
 *
 *
 * ## Life-Cycle and configuration
 *
 * The editor actions will wait for diagram initialization before
 * registering default actions _and_ firing an `editorActions.init` event.
 *
 * Interested parties may listen to the `editorActions.init` event with
 * low priority to check, which actions got registered. Other components
 * may use the event to register their own actions via `registerAction`.
 *
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */
function EditorActions(eventBus, injector) {

  // initialize actions
  this._actions = {};

  var self = this;

  eventBus.on('diagram.init', function() {

    // all diagram modules got loaded; check which ones
    // are available and register the respective default actions
    self._registerDefaultActions(injector);

    // ask interested parties to register available editor
    // actions on diagram initialization
    eventBus.fire('editorActions.init', {
      editorActions: self
    });
  });

}

EditorActions.$inject = [
  'eventBus',
  'injector'
];

/**
 * Register default actions.
 *
 * @param {Injector} injector
 */
EditorActions.prototype._registerDefaultActions = function(injector) {

  // (1) retrieve optional components to integrate with

  var commandStack = injector.get('commandStack', false);
  var modeling = injector.get('modeling', false);
  var selection = injector.get('selection', false);
  var zoomScroll = injector.get('zoomScroll', false);
  var copyPaste = injector.get('copyPaste', false);
  var canvas = injector.get('canvas', false);
  var rules = injector.get('rules', false);
  var keyboardMove = injector.get('keyboardMove', false);
  var keyboardMoveSelection = injector.get('keyboardMoveSelection', false);

  // (2) check components and register actions

  if (commandStack) {
    this.register('undo', function() {
      commandStack.undo();
    });

    this.register('redo', function() {
      commandStack.redo();
    });
  }

  if (copyPaste && selection) {
    this.register('copy', function() {
      var selectedElements = selection.get();

      copyPaste.copy(selectedElements);
    });
  }

  if (copyPaste) {
    this.register('paste', function() {
      copyPaste.paste();
    });
  }

  if (zoomScroll) {
    this.register('stepZoom', function(opts) {
      zoomScroll.stepZoom(opts.value);
    });
  }

  if (canvas) {
    this.register('zoom', function(opts) {
      canvas.zoom(opts.value);
    });
  }

  if (modeling && selection && rules) {
    this.register('removeSelection', function() {

      var selectedElements = selection.get();

      if (!selectedElements.length) {
        return;
      }

      var allowed = rules.allowed('elements.delete', { elements: selectedElements }),
          removableElements;

      if (allowed === false) {
        return;
      }
      else if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(allowed)) {
        removableElements = allowed;
      }
      else {
        removableElements = selectedElements;
      }

      if (removableElements.length) {
        modeling.removeElements(removableElements.slice());
      }
    });
  }

  if (keyboardMove) {
    this.register('moveCanvas', function(opts) {
      keyboardMove.moveCanvas(opts);
    });
  }

  if (keyboardMoveSelection) {
    this.register('moveSelection', function(opts) {
      keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
    });
  }

};


/**
 * Triggers a registered action
 *
 * @param  {string} action
 * @param  {Object} opts
 *
 * @return {Unknown} Returns what the registered listener returns
 */
EditorActions.prototype.trigger = function(action, opts) {
  if (!this._actions[action]) {
    throw error(action, NOT_REGISTERED_ERROR);
  }

  return this._actions[action](opts);
};


/**
 * Registers a collections of actions.
 * The key of the object will be the name of the action.
 *
 * @example
 * 
 * var actions = {
 *   spaceTool: function() {
 *     spaceTool.activateSelection();
 *   },
 *   lassoTool: function() {
 *     lassoTool.activateSelection();
 *   }
 * ];
 *
 * editorActions.register(actions);
 *
 * editorActions.isRegistered('spaceTool'); // true
 * 
 *
 * @param  {Object} actions
 */
EditorActions.prototype.register = function(actions, listener) {
  var self = this;

  if (typeof actions === 'string') {
    return this._registerAction(actions, listener);
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(actions, function(listener, action) {
    self._registerAction(action, listener);
  });
};

/**
 * Registers a listener to an action key
 *
 * @param  {string} action
 * @param  {Function} listener
 */
EditorActions.prototype._registerAction = function(action, listener) {
  if (this.isRegistered(action)) {
    throw error(action, IS_REGISTERED_ERROR);
  }

  this._actions[action] = listener;
};

/**
 * Unregister an existing action
 *
 * @param {string} action
 */
EditorActions.prototype.unregister = function(action) {
  if (!this.isRegistered(action)) {
    throw error(action, NOT_REGISTERED_ERROR);
  }

  this._actions[action] = undefined;
};

/**
 * Returns the number of actions that are currently registered
 *
 * @return {number}
 */
EditorActions.prototype.getActions = function() {
  return Object.keys(this._actions);
};

/**
 * Checks wether the given action is registered
 *
 * @param {string} action
 *
 * @return {boolean}
 */
EditorActions.prototype.isRegistered = function(action) {
  return !!this._actions[action];
};


function error(action, message) {
  return new Error(action + ' ' + message);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/editor-actions/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/editor-actions/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _EditorActions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorActions */ "./node_modules/diagram-js/lib/features/editor-actions/EditorActions.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'editorActions' ],
  editorActions: [ 'type', _EditorActions__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/hand-tool/HandTool.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/hand-tool/HandTool.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HandTool)
/* harmony export */ });
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var _features_keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../features/keyboard/KeyboardUtil */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js");




var HIGH_PRIORITY = 1500;
var HAND_CURSOR = 'grab';


function HandTool(
    eventBus, canvas, dragging,
    injector, toolManager, mouse) {

  this._dragging = dragging;
  this._mouse = mouse;

  var self = this,
      keyboard = injector.get('keyboard', false);

  toolManager.registerTool('hand', {
    tool: 'hand',
    dragging: 'hand.move'
  });

  eventBus.on('element.mousedown', HIGH_PRIORITY, function(event) {

    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.hasPrimaryModifier)(event)) {
      return;
    }

    self.activateMove(event.originalEvent, true);

    return false;
  });

  keyboard && keyboard.addListener(HIGH_PRIORITY, function(e) {
    if (!isSpace(e.keyEvent) || self.isActive()) {
      return;
    }

    var mouseEvent = self._mouse.getLastMoveEvent();

    self.activateMove(mouseEvent, !!mouseEvent);
  }, 'keyboard.keydown');

  keyboard && keyboard.addListener(HIGH_PRIORITY, function(e) {
    if (!isSpace(e.keyEvent) || !self.isActive()) {
      return;
    }

    self.toggle();
  }, 'keyboard.keyup');

  eventBus.on('hand.end', function(event) {
    var target = event.originalEvent.target;

    // only reactive on diagram click
    // on some occasions, event.hover is not set and we have to check if the target is an svg
    if (!event.hover && !(target instanceof SVGElement)) {
      return false;
    }

    eventBus.once('hand.ended', function() {
      self.activateMove(event.originalEvent, { reactivate: true });
    });

  });

  eventBus.on('hand.move.move', function(event) {
    var scale = canvas.viewbox().scale;

    canvas.scroll({
      dx: event.dx * scale,
      dy: event.dy * scale
    });
  });

  eventBus.on('hand.move.end', function(event) {
    var context = event.context,
        reactivate = context.reactivate;

    // Don't reactivate if the user is using the keyboard keybinding
    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.hasPrimaryModifier)(event) && reactivate) {

      eventBus.once('hand.move.ended', function(event) {
        self.activateHand(event.originalEvent, true, true);
      });

    }

    return false;
  });

}

HandTool.$inject = [
  'eventBus',
  'canvas',
  'dragging',
  'injector',
  'toolManager',
  'mouse'
];


HandTool.prototype.activateMove = function(event, autoActivate, context) {
  if (typeof autoActivate === 'object') {
    context = autoActivate;
    autoActivate = false;
  }

  this._dragging.init(event, 'hand.move', {
    autoActivate: autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: context || {}
    }
  });
};

HandTool.prototype.activateHand = function(event, autoActivate, reactivate) {
  this._dragging.init(event, 'hand', {
    trapClick: false,
    autoActivate: autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: {
        reactivate: reactivate
      }
    }
  });
};

HandTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }

  var mouseEvent = this._mouse.getLastMoveEvent();

  this.activateHand(mouseEvent, !!mouseEvent);
};

HandTool.prototype.isActive = function() {
  var context = this._dragging.context();

  if (context) {
    return /^(hand|hand\.move)$/.test(context.prefix);
  }

  return false;
};

// helpers //////////

function isSpace(keyEvent) {
  return (0,_features_keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_1__.isKey)(' ', keyEvent);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/hand-tool/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/hand-tool/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tool_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tool-manager */ "./node_modules/diagram-js/lib/features/tool-manager/index.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mouse */ "./node_modules/diagram-js/lib/features/mouse/index.js");
/* harmony import */ var _HandTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HandTool */ "./node_modules/diagram-js/lib/features/hand-tool/HandTool.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _tool_manager__WEBPACK_IMPORTED_MODULE_0__.default,
    _mouse__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [ 'handTool' ],
  handTool: [ 'type', _HandTool__WEBPACK_IMPORTED_MODULE_2__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/hover-fix/HoverFix.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/hover-fix/HoverFix.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HoverFix)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");




var HIGH_PRIORITY = 1500;


/**
 * Browsers may swallow certain events (hover, out ...) if users are to
 * fast with the mouse.
 *
 * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event
 *
 * The fix implemented in this component ensure that we
 *
 * 1) have a hover state after a successful drag.move event
 * 2) have an out event when dragging leaves an element
 *
 * @param {ElementRegistry} elementRegistry
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */
function HoverFix(elementRegistry, eventBus, injector) {

  var self = this;

  var dragging = injector.get('dragging', false);

  /**
   * Make sure we are god damn hovering!
   *
   * @param {Event} dragging event
   */
  function ensureHover(event) {

    if (event.hover) {
      return;
    }

    var originalEvent = event.originalEvent;

    var gfx = self._findTargetGfx(originalEvent);

    var element = gfx && elementRegistry.get(gfx);

    if (gfx && element) {

      // 1) cancel current mousemove
      event.stopPropagation();

      // 2) emit fake hover for new target
      dragging.hover({ element: element, gfx: gfx });

      // 3) re-trigger move event
      dragging.move(originalEvent);
    }
  }


  if (dragging) {

    /**
     * We wait for a specific sequence of events before
     * emitting a fake drag.hover event.
     *
     * Event Sequence:
     *
     * drag.start
     * drag.move >> ensure we are hovering
     */
    eventBus.on('drag.start', function(event) {

      eventBus.once('drag.move', HIGH_PRIORITY, function(event) {

        ensureHover(event);

      });

    });
  }


  /**
   * We make sure that element.out is always fired, even if the
   * browser swallows an element.out event.
   *
   * Event sequence:
   *
   * element.hover
   * (element.out >> sometimes swallowed)
   * element.hover >> ensure we fired element.out
   */
  (function() {
    var hoverGfx;
    var hover;

    eventBus.on('element.hover', function(event) {

      // (1) remember current hover element
      hoverGfx = event.gfx;
      hover = event.element;
    });

    eventBus.on('element.hover', HIGH_PRIORITY, function(event) {

      // (3) am I on an element still?
      if (hover) {

        // (4) that is a problem, gotta "simulate the out"
        eventBus.fire('element.out', {
          element: hover,
          gfx: hoverGfx
        });
      }

    });

    eventBus.on('element.out', function() {

      // (2) unset hover state if we correctly outed us *GG*
      hoverGfx = null;
      hover = null;
    });

  })();

  this._findTargetGfx = function(event) {
    var position,
        target;

    if (!(event instanceof MouseEvent)) {
      return;
    }

    position = (0,_util_Event__WEBPACK_IMPORTED_MODULE_0__.toPoint)(event);

    // damn expensive operation, ouch!
    target = document.elementFromPoint(position.x, position.y);

    return getGfx(target);
  };

}

HoverFix.$inject = [
  'elementRegistry',
  'eventBus',
  'injector'
];


// helpers /////////////////////

function getGfx(target) {
  return (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.closest)(target, 'svg, .djs-element', true);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/hover-fix/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/hover-fix/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _HoverFix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HoverFix */ "./node_modules/diagram-js/lib/features/hover-fix/HoverFix.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [
    'hoverFix'
  ],
  hoverFix: [ 'type', _HoverFix__WEBPACK_IMPORTED_MODULE_0__.default ],
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ InteractionEvents)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/RenderUtil */ "./node_modules/diagram-js/lib/util/RenderUtil.js");










function allowAll(event) { return true; }

function allowPrimaryAndAuxiliary(event) {
  return (0,_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.isPrimaryButton)(event) || (0,_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.isAuxiliaryButton)(event);
}

var LOW_PRIORITY = 500;


/**
 * A plugin that provides interaction events for diagram elements.
 *
 * It emits the following events:
 *
 *   * element.click
 *   * element.contextmenu
 *   * element.dblclick
 *   * element.hover
 *   * element.mousedown
 *   * element.mousemove
 *   * element.mouseup
 *   * element.out
 *
 * Each event is a tuple { element, gfx, originalEvent }.
 *
 * Canceling the event via Event#preventDefault()
 * prevents the original DOM operation.
 *
 * @param {EventBus} eventBus
 */
function InteractionEvents(eventBus, elementRegistry, styles) {

  var self = this;

  /**
   * Fire an interaction event.
   *
   * @param {string} type local event name, e.g. element.click.
   * @param {DOMEvent} event native event
   * @param {djs.model.Base} [element] the diagram element to emit the event on;
   *                                   defaults to the event target
   */
  function fire(type, event, element) {

    if (isIgnored(type, event)) {
      return;
    }

    var target, gfx, returnValue;

    if (!element) {
      target = event.delegateTarget || event.target;

      if (target) {
        gfx = target;
        element = elementRegistry.get(gfx);
      }
    } else {
      gfx = elementRegistry.getGraphics(element);
    }

    if (!gfx || !element) {
      return;
    }

    returnValue = eventBus.fire(type, {
      element: element,
      gfx: gfx,
      originalEvent: event
    });

    if (returnValue === false) {
      event.stopPropagation();
      event.preventDefault();
    }
  }

  // TODO(nikku): document this
  var handlers = {};

  function mouseHandler(localEventName) {
    return handlers[localEventName];
  }

  function isIgnored(localEventName, event) {

    var filter = ignoredFilters[localEventName] || _util_Mouse__WEBPACK_IMPORTED_MODULE_0__.isPrimaryButton;

    // only react on left mouse button interactions
    // except for interaction events that are enabled
    // for secundary mouse button
    return !filter(event);
  }

  var bindings = {
    click: 'element.click',
    contextmenu: 'element.contextmenu',
    dblclick: 'element.dblclick',
    mousedown: 'element.mousedown',
    mousemove: 'element.mousemove',
    mouseover: 'element.hover',
    mouseout: 'element.out',
    mouseup: 'element.mouseup',
  };

  var ignoredFilters = {
    'element.contextmenu': allowAll,
    'element.mousedown': allowPrimaryAndAuxiliary,
    'element.mouseup': allowPrimaryAndAuxiliary,
    'element.click': allowPrimaryAndAuxiliary,
    'element.dblclick': allowPrimaryAndAuxiliary
  };


  // manual event trigger //////////

  /**
   * Trigger an interaction event (based on a native dom event)
   * on the target shape or connection.
   *
   * @param {string} eventName the name of the triggered DOM event
   * @param {MouseEvent} event
   * @param {djs.model.Base} targetElement
   */
  function triggerMouseEvent(eventName, event, targetElement) {

    // i.e. element.mousedown...
    var localEventName = bindings[eventName];

    if (!localEventName) {
      throw new Error('unmapped DOM event name <' + eventName + '>');
    }

    return fire(localEventName, event, targetElement);
  }


  var ELEMENT_SELECTOR = 'svg, .djs-element';

  // event handling ///////

  function registerEvent(node, event, localEvent, ignoredFilter) {

    var handler = handlers[localEvent] = function(event) {
      fire(localEvent, event);
    };

    if (ignoredFilter) {
      ignoredFilters[localEvent] = ignoredFilter;
    }

    handler.$delegate = min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(node, ELEMENT_SELECTOR, event, handler);
  }

  function unregisterEvent(node, event, localEvent) {

    var handler = mouseHandler(localEvent);

    if (!handler) {
      return;
    }

    min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.unbind(node, event, handler.$delegate);
  }

  function registerEvents(svg) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(bindings, function(val, key) {
      registerEvent(svg, key, val);
    });
  }

  function unregisterEvents(svg) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(bindings, function(val, key) {
      unregisterEvent(svg, key, val);
    });
  }

  eventBus.on('canvas.destroy', function(event) {
    unregisterEvents(event.svg);
  });

  eventBus.on('canvas.init', function(event) {
    registerEvents(event.svg);
  });


  // hit box updating ////////////////

  eventBus.on([ 'shape.added', 'connection.added' ], function(event) {
    var element = event.element,
        gfx = event.gfx;

    eventBus.fire('interactionEvents.createHit', { element: element, gfx: gfx });
  });

  // Update djs-hit on change.
  // A low priortity is necessary, because djs-hit of labels has to be updated
  // after the label bounds have been updated in the renderer.
  eventBus.on([
    'shape.changed',
    'connection.changed'
  ], LOW_PRIORITY, function(event) {

    var element = event.element,
        gfx = event.gfx;

    eventBus.fire('interactionEvents.updateHit', { element: element, gfx: gfx });
  });

  eventBus.on('interactionEvents.createHit', LOW_PRIORITY, function(event) {
    var element = event.element,
        gfx = event.gfx;

    self.createDefaultHit(element, gfx);
  });

  eventBus.on('interactionEvents.updateHit', function(event) {
    var element = event.element,
        gfx = event.gfx;

    self.updateDefaultHit(element, gfx);
  });


  // hit styles ////////////

  var STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-stroke');

  var CLICK_STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-click-stroke');

  var ALL_HIT_STYLE = createHitStyle('djs-hit djs-hit-all');

  var HIT_TYPES = {
    'all': ALL_HIT_STYLE,
    'click-stroke': CLICK_STROKE_HIT_STYLE,
    'stroke': STROKE_HIT_STYLE
  };

  function createHitStyle(classNames, attrs) {

    attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
      stroke: 'white',
      strokeWidth: 15
    }, attrs || {});

    return styles.cls(classNames, [ 'no-fill', 'no-border' ], attrs);
  }


  // style helpers ///////////////

  function applyStyle(hit, type) {

    var attrs = HIT_TYPES[type];

    if (!attrs) {
      throw new Error('invalid hit type <' + type + '>');
    }

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(hit, attrs);

    return hit;
  }

  function appendHit(gfx, hit) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(gfx, hit);
  }


  // API

  /**
   * Remove hints on the given graphics.
   *
   * @param {SVGElement} gfx
   */
  this.removeHits = function(gfx) {
    var hits = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.queryAll)('.djs-hit', gfx);

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(hits, tiny_svg__WEBPACK_IMPORTED_MODULE_3__.remove);
  };

  /**
   * Create default hit for the given element.
   *
   * @param {djs.model.Base} element
   * @param {SVGElement} gfx
   *
   * @return {SVGElement} created hit
   */
  this.createDefaultHit = function(element, gfx) {
    var waypoints = element.waypoints,
        isFrame = element.isFrame,
        boxType;

    if (waypoints) {
      return this.createWaypointsHit(gfx, waypoints);
    } else {

      boxType = isFrame ? 'stroke' : 'all';

      return this.createBoxHit(gfx, boxType, {
        width: element.width,
        height: element.height
      });
    }
  };

  /**
   * Create hits for the given waypoints.
   *
   * @param {SVGElement} gfx
   * @param {Array<Point>} waypoints
   *
   * @return {SVGElement}
   */
  this.createWaypointsHit = function(gfx, waypoints) {

    var hit = (0,_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__.createLine)(waypoints);

    applyStyle(hit, 'stroke');

    appendHit(gfx, hit);

    return hit;
  };

  /**
   * Create hits for a box.
   *
   * @param {SVGElement} gfx
   * @param {string} hitType
   * @param {Object} attrs
   *
   * @return {SVGElement}
   */
  this.createBoxHit = function(gfx, type, attrs) {

    attrs = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({
      x: 0,
      y: 0
    }, attrs);

    var hit = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('rect');

    applyStyle(hit, type);

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(hit, attrs);

    appendHit(gfx, hit);

    return hit;
  };

  /**
   * Update default hit of the element.
   *
   * @param  {djs.model.Base} element
   * @param  {SVGElement} gfx
   *
   * @return {SVGElement} updated hit
   */
  this.updateDefaultHit = function(element, gfx) {

    var hit = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.query)('.djs-hit', gfx);

    if (!hit) {
      return;
    }

    if (element.waypoints) {
      (0,_util_RenderUtil__WEBPACK_IMPORTED_MODULE_4__.updateLine)(hit, element.waypoints);
    } else {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(hit, {
        width: element.width,
        height: element.height
      });
    }

    return hit;
  };

  this.fire = fire;

  this.triggerMouseEvent = triggerMouseEvent;

  this.mouseHandler = mouseHandler;

  this.registerEvent = registerEvent;
  this.unregisterEvent = unregisterEvent;
}


InteractionEvents.$inject = [
  'eventBus',
  'elementRegistry',
  'styles'
];


/**
 * An event indicating that the mouse hovered over an element
 *
 * @event element.hover
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has left an element
 *
 * @event element.out
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has clicked an element
 *
 * @event element.click
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has double clicked an element
 *
 * @event element.dblclick
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has gone down on an element.
 *
 * @event element.mousedown
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the mouse has gone up on an element.
 *
 * @event element.mouseup
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/**
 * An event indicating that the context menu action is triggered
 * via mouse or touch controls.
 *
 * @event element.contextmenu
 *
 * @type {Object}
 * @property {djs.model.Base} element
 * @property {SVGElement} gfx
 * @property {Event} originalEvent
 */

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/interaction-events/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/interaction-events/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _InteractionEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InteractionEvents */ "./node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'interactionEvents' ],
  interactionEvents: [ 'type', _InteractionEvents__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard-move-selection/KeyboardMoveSelection.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard-move-selection/KeyboardMoveSelection.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ KeyboardMoveSelection)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



var DEFAULT_CONFIG = {
  moveSpeed: 1,
  moveSpeedAccelerated: 10
};

var HIGHER_PRIORITY = 1500;

var LEFT = 'left';
var UP = 'up';
var RIGHT = 'right';
var DOWN = 'down';

var KEY_TO_DIRECTION = {
  ArrowLeft: LEFT,
  Left: LEFT,
  ArrowUp: UP,
  Up: UP,
  ArrowRight: RIGHT,
  Right: RIGHT,
  ArrowDown: DOWN,
  Down: DOWN
};

var DIRECTIONS_DELTA = {
  left: function(speed) {
    return {
      x: -speed,
      y: 0
    };
  },
  up: function(speed) {
    return {
      x: 0,
      y: -speed
    };
  },
  right: function(speed) {
    return {
      x: speed,
      y: 0
    };
  },
  down: function(speed) {
    return {
      x: 0,
      y: speed
    };
  }
};


/**
 * Enables to move selection with keyboard arrows.
 * Use with Shift for modified speed (default=1, with Shift=10).
 * Pressed Cmd/Ctrl turns the feature off.
 *
 * @param {Object} config
 * @param {number} [config.moveSpeed=1]
 * @param {number} [config.moveSpeedAccelerated=10]
 * @param {Keyboard} keyboard
 * @param {Modeling} modeling
 * @param {Selection} selection
 */
function KeyboardMoveSelection(
    config,
    keyboard,
    modeling,
    rules,
    selection
) {

  var self = this;

  this._config = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, DEFAULT_CONFIG, config || {});

  keyboard.addListener(HIGHER_PRIORITY, function(event) {

    var keyEvent = event.keyEvent;

    var direction = KEY_TO_DIRECTION[keyEvent.key];

    if (!direction) {
      return;
    }

    if (keyboard.isCmd(keyEvent)) {
      return;
    }

    var accelerated = keyboard.isShift(keyEvent);

    self.moveSelection(direction, accelerated);

    return true;
  });


  /**
   * Move selected elements in the given direction,
   * optionally specifying accelerated movement.
   *
   * @param {string} direction
   * @param {boolean} [accelerated=false]
   */
  this.moveSelection = function(direction, accelerated) {

    var selectedElements = selection.get();

    if (!selectedElements.length) {
      return;
    }

    var speed = this._config[
      accelerated ?
        'moveSpeedAccelerated' :
        'moveSpeed'
    ];

    var delta = DIRECTIONS_DELTA[direction](speed);

    var canMove = rules.allowed('elements.move', {
      shapes: selectedElements
    });

    if (canMove) {
      modeling.moveElements(selectedElements, delta);
    }
  };

}

KeyboardMoveSelection.$inject = [
  'config.keyboardMoveSelection',
  'keyboard',
  'modeling',
  'rules',
  'selection'
];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard-move-selection/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard-move-selection/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../keyboard */ "./node_modules/diagram-js/lib/features/keyboard/index.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _KeyboardMoveSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KeyboardMoveSelection */ "./node_modules/diagram-js/lib/features/keyboard-move-selection/KeyboardMoveSelection.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _keyboard__WEBPACK_IMPORTED_MODULE_0__.default,
    _selection__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [
    'keyboardMoveSelection'
  ],
  keyboardMoveSelection: [ 'type', _KeyboardMoveSelection__WEBPACK_IMPORTED_MODULE_2__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard/Keyboard.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard/Keyboard.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Keyboard)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _KeyboardUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KeyboardUtil */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js");






var KEYDOWN_EVENT = 'keyboard.keydown',
    KEYUP_EVENT = 'keyboard.keyup';

var DEFAULT_PRIORITY = 1000;


/**
 * A keyboard abstraction that may be activated and
 * deactivated by users at will, consuming key events
 * and triggering diagram actions.
 *
 * For keys pressed down, keyboard fires `keyboard.keydown` event.
 * The event context contains one field which is `KeyboardEvent` event.
 *
 * The implementation fires the following key events that allow
 * other components to hook into key handling:
 *
 *  - keyboard.bind
 *  - keyboard.unbind
 *  - keyboard.init
 *  - keyboard.destroy
 *
 * All events contain one field which is node.
 *
 * A default binding for the keyboard may be specified via the
 * `keyboard.bindTo` configuration option.
 *
 * @param {Config} config
 * @param {EventBus} eventBus
 */
function Keyboard(config, eventBus) {
  var self = this;

  this._config = config || {};
  this._eventBus = eventBus;

  this._keydownHandler = this._keydownHandler.bind(this);
  this._keyupHandler = this._keyupHandler.bind(this);

  // properly clean dom registrations
  eventBus.on('diagram.destroy', function() {
    self._fire('destroy');

    self.unbind();
  });

  eventBus.on('diagram.init', function() {
    self._fire('init');
  });

  eventBus.on('attach', function() {
    if (config && config.bindTo) {
      self.bind(config.bindTo);
    }
  });

  eventBus.on('detach', function() {
    self.unbind();
  });
}

Keyboard.$inject = [
  'config.keyboard',
  'eventBus'
];

Keyboard.prototype._keydownHandler = function(event) {
  this._keyHandler(event, KEYDOWN_EVENT);
};

Keyboard.prototype._keyupHandler = function(event) {
  this._keyHandler(event, KEYUP_EVENT);
};

Keyboard.prototype._keyHandler = function(event, type) {
  var target = event.target,
      eventBusResult;

  if (isInput(target)) {
    return;
  }

  var context = {
    keyEvent: event
  };

  eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);

  if (eventBusResult) {
    event.preventDefault();
  }
};

Keyboard.prototype.bind = function(node) {

  // make sure that the keyboard is only bound once to the DOM
  this.unbind();

  this._node = node;

  // bind key events
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(node, 'keydown', this._keydownHandler, true);
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(node, 'keyup', this._keyupHandler, true);

  this._fire('bind');
};

Keyboard.prototype.getBinding = function() {
  return this._node;
};

Keyboard.prototype.unbind = function() {
  var node = this._node;

  if (node) {
    this._fire('unbind');

    // unbind key events
    min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(node, 'keydown', this._keydownHandler, true);
    min_dom__WEBPACK_IMPORTED_MODULE_0__.event.unbind(node, 'keyup', this._keyupHandler, true);
  }

  this._node = null;
};

Keyboard.prototype._fire = function(event) {
  this._eventBus.fire('keyboard.' + event, { node: this._node });
};

/**
 * Add a listener function that is notified with `KeyboardEvent` whenever
 * the keyboard is bound and the user presses a key. If no priority is
 * provided, the default value of 1000 is used.
 *
 * @param {number} [priority]
 * @param {Function} listener
 * @param {string} type
 */
Keyboard.prototype.addListener = function(priority, listener, type) {
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isFunction)(priority)) {
    type = listener;
    listener = priority;
    priority = DEFAULT_PRIORITY;
  }

  this._eventBus.on(type || KEYDOWN_EVENT, priority, listener);
};

Keyboard.prototype.removeListener = function(listener, type) {
  this._eventBus.off(type || KEYDOWN_EVENT, listener);
};

Keyboard.prototype.hasModifier = _KeyboardUtil__WEBPACK_IMPORTED_MODULE_2__.hasModifier;
Keyboard.prototype.isCmd = _KeyboardUtil__WEBPACK_IMPORTED_MODULE_2__.isCmd;
Keyboard.prototype.isShift = _KeyboardUtil__WEBPACK_IMPORTED_MODULE_2__.isShift;
Keyboard.prototype.isKey = _KeyboardUtil__WEBPACK_IMPORTED_MODULE_2__.isKey;



// helpers ///////

function isInput(target) {
  return target && ((0,min_dom__WEBPACK_IMPORTED_MODULE_0__.matches)(target, 'input, textarea') || target.contentEditable === 'true');
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard/KeyboardBindings.js":
/*!***************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard/KeyboardBindings.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KEYCODE_C": () => (/* binding */ KEYCODE_C),
/* harmony export */   "KEYCODE_V": () => (/* binding */ KEYCODE_V),
/* harmony export */   "KEYCODE_Y": () => (/* binding */ KEYCODE_Y),
/* harmony export */   "KEYCODE_Z": () => (/* binding */ KEYCODE_Z),
/* harmony export */   "KEYS_COPY": () => (/* binding */ KEYS_COPY),
/* harmony export */   "KEYS_PASTE": () => (/* binding */ KEYS_PASTE),
/* harmony export */   "KEYS_REDO": () => (/* binding */ KEYS_REDO),
/* harmony export */   "KEYS_UNDO": () => (/* binding */ KEYS_UNDO),
/* harmony export */   "default": () => (/* binding */ KeyboardBindings)
/* harmony export */ });
/* harmony import */ var _KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KeyboardUtil */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js");


var LOW_PRIORITY = 500;

var KEYCODE_C = 67;
var KEYCODE_V = 86;
var KEYCODE_Y = 89;
var KEYCODE_Z = 90;

var KEYS_COPY = ['c', 'C', KEYCODE_C ];
var KEYS_PASTE = [ 'v', 'V', KEYCODE_V ];
var KEYS_REDO = [ 'y', 'Y', KEYCODE_Y ];
var KEYS_UNDO = [ 'z', 'Z', KEYCODE_Z ];


/**
 * Adds default keyboard bindings.
 *
 * This does not pull in any features will bind only actions that
 * have previously been registered against the editorActions component.
 *
 * @param {EventBus} eventBus
 * @param {Keyboard} keyboard
 */
function KeyboardBindings(eventBus, keyboard) {

  var self = this;

  eventBus.on('editorActions.init', LOW_PRIORITY, function(event) {

    var editorActions = event.editorActions;

    self.registerBindings(keyboard, editorActions);
  });
}

KeyboardBindings.$inject = [
  'eventBus',
  'keyboard'
];


/**
 * Register available keyboard bindings.
 *
 * @param {Keyboard} keyboard
 * @param {EditorActions} editorActions
 */
KeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {

  /**
   * Add keyboard binding if respective editor action
   * is registered.
   *
   * @param {string} action name
   * @param {Function} fn that implements the key binding
   */
  function addListener(action, fn) {

    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  }


  // undo
  // (CTRL|CMD) + Z
  addListener('undo', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event) && !(0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isShift)(event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(KEYS_UNDO, event)) {
      editorActions.trigger('undo');

      return true;
    }
  });

  // redo
  // CTRL + Y
  // CMD + SHIFT + Z
  addListener('redo', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event) && ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(KEYS_REDO, event) || ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(KEYS_UNDO, event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isShift)(event)))) {
      editorActions.trigger('redo');

      return true;
    }
  });

  // copy
  // CTRL/CMD + C
  addListener('copy', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(KEYS_COPY, event)) {
      editorActions.trigger('copy');

      return true;
    }
  });

  // paste
  // CTRL/CMD + V
  addListener('paste', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(KEYS_PASTE, event)) {
      editorActions.trigger('paste');

      return true;
    }
  });

  // zoom in one step
  // CTRL/CMD + +
  addListener('stepZoom', function(context) {

    var event = context.keyEvent;

    // quirk: it has to be triggered by `=` as well to work on international keyboard layout
    // cf: https://github.com/bpmn-io/bpmn-js/issues/1362#issuecomment-722989754
    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)([ '+', 'Add', '=' ], event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event)) {
      editorActions.trigger('stepZoom', { value: 1 });

      return true;
    }
  });

  // zoom out one step
  // CTRL + -
  addListener('stepZoom', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)([ '-', 'Subtract' ], event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event)) {
      editorActions.trigger('stepZoom', { value: -1 });

      return true;
    }
  });

  // zoom to the default level
  // CTRL + 0
  addListener('zoom', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)('0', event) && (0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event)) {
      editorActions.trigger('zoom', { value: 1 });

      return true;
    }
  });

  // delete selected element
  // DEL
  addListener('removeSelection', function(context) {

    var event = context.keyEvent;

    if ((0,_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isKey)(['Backspace', 'Delete', 'Del' ], event)) {
      editorActions.trigger('removeSelection');

      return true;
    }
  });
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js":
/*!***********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasModifier": () => (/* binding */ hasModifier),
/* harmony export */   "isCmd": () => (/* binding */ isCmd),
/* harmony export */   "isKey": () => (/* binding */ isKey),
/* harmony export */   "isShift": () => (/* binding */ isShift)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * Returns true if event was triggered with any modifier
 * @param {KeyboardEvent} event
 */
function hasModifier(event) {
  return (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey);
}

/**
 * @param {KeyboardEvent} event
 */
function isCmd(event) {

  // ensure we don't react to AltGr
  // (mapped to CTRL + ALT)
  if (event.altKey) {
    return false;
  }

  return event.ctrlKey || event.metaKey;
}

/**
 * Checks if key pressed is one of provided keys.
 *
 * @param {string|Array<string>} keys
 * @param {KeyboardEvent} event
 */
function isKey(keys, event) {
  keys = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(keys) ? keys : [ keys ];

  return keys.indexOf(event.key) !== -1 || keys.indexOf(event.keyCode) !== -1;
}

/**
 * @param {KeyboardEvent} event
 */
function isShift(event) {
  return event.shiftKey;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/keyboard/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/keyboard/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Keyboard */ "./node_modules/diagram-js/lib/features/keyboard/Keyboard.js");
/* harmony import */ var _KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyboardBindings */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardBindings.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'keyboard', 'keyboardBindings' ],
  keyboard: [ 'type', _Keyboard__WEBPACK_IMPORTED_MODULE_0__.default ],
  keyboardBindings: [ 'type', _KeyboardBindings__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/label-support/LabelSupport.js":
/*!****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/label-support/LabelSupport.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LabelSupport)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");
/* harmony import */ var _util_Removal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Removal */ "./node_modules/diagram-js/lib/util/Removal.js");
/* harmony import */ var _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");




var LOW_PRIORITY = 250,
    HIGH_PRIORITY = 1400;








/**
 * A handler that makes sure labels are properly moved with
 * their label targets.
 *
 * @param {didi.Injector} injector
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 */
function LabelSupport(injector, eventBus, modeling) {

  _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  var movePreview = injector.get('movePreview', false);

  // remove labels from the collection that are being
  // moved with other elements anyway
  eventBus.on('shape.move.start', HIGH_PRIORITY, function(e) {

    var context = e.context,
        shapes = context.shapes,
        validatedShapes = context.validatedShapes;

    context.shapes = removeLabels(shapes);
    context.validatedShapes = removeLabels(validatedShapes);
  });

  // add labels to visual's group
  movePreview && eventBus.on('shape.move.start', LOW_PRIORITY, function(e) {

    var context = e.context,
        shapes = context.shapes;

    var labels = [];

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(shapes, function(element) {

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(element.labels, function(label) {

        if (!label.hidden && context.shapes.indexOf(label) === -1) {
          labels.push(label);
        }

        if (element.labelTarget) {
          labels.push(element);
        }
      });
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(labels, function(label) {
      movePreview.makeDraggable(context, label, true);
    });

  });

  // add all labels to move closure
  this.preExecuted('elements.move', HIGH_PRIORITY, function(e) {
    var context = e.context,
        closure = context.closure,
        enclosedElements = closure.enclosedElements;

    var enclosedLabels = [];

    // find labels that are not part of
    // move closure yet and add them
    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(enclosedElements, function(element) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(element.labels, function(label) {

        if (!enclosedElements[label.id]) {
          enclosedLabels.push(label);
        }
      });
    });

    closure.addAll(enclosedLabels);
  });


  this.preExecute([
    'connection.delete',
    'shape.delete'
  ], function(e) {

    var context = e.context,
        element = context.connection || context.shape;

    (0,_util_Removal__WEBPACK_IMPORTED_MODULE_3__.saveClear)(element.labels, function(label) {
      modeling.removeShape(label, { nested: true });
    });
  });


  this.execute('shape.delete', function(e) {

    var context = e.context,
        shape = context.shape,
        labelTarget = shape.labelTarget;

    // unset labelTarget
    if (labelTarget) {
      context.labelTargetIndex = (0,_util_Collections__WEBPACK_IMPORTED_MODULE_4__.indexOf)(labelTarget.labels, shape);
      context.labelTarget = labelTarget;

      shape.labelTarget = null;
    }
  });

  this.revert('shape.delete', function(e) {

    var context = e.context,
        shape = context.shape,
        labelTarget = context.labelTarget,
        labelTargetIndex = context.labelTargetIndex;

    // restore labelTarget
    if (labelTarget) {
      (0,_util_Collections__WEBPACK_IMPORTED_MODULE_4__.add)(labelTarget.labels, shape, labelTargetIndex);

      shape.labelTarget = labelTarget;
    }
  });

}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(LabelSupport, _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

LabelSupport.$inject = [
  'injector',
  'eventBus',
  'modeling'
];


/**
 * Return a filtered list of elements that do not
 * contain attached elements with hosts being part
 * of the selection.
 *
 * @param  {Array<djs.model.Base>} elements
 *
 * @return {Array<djs.model.Base>} filtered
 */
function removeLabels(elements) {

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(elements, function(element) {

    // filter out labels that are move together
    // with their label targets
    return elements.indexOf(element.labelTarget) === -1;
  });
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/label-support/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/label-support/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _LabelSupport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LabelSupport */ "./node_modules/diagram-js/lib/features/label-support/LabelSupport.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'labelSupport'],
  labelSupport: [ 'type', _LabelSupport__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LassoTool)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");








var LASSO_TOOL_CURSOR = 'crosshair';


function LassoTool(
    eventBus, canvas, dragging,
    elementRegistry, selection, toolManager,
    mouse) {

  this._selection = selection;
  this._dragging = dragging;
  this._mouse = mouse;

  var self = this;

  // lasso visuals implementation

  /**
  * A helper that realizes the selection box visual
  */
  var visuals = {

    create: function(context) {
      var container = canvas.getDefaultLayer(),
          frame;

      frame = context.frame = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('rect');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(frame, {
        class: 'djs-lasso-overlay',
        width:  1,
        height: 1,
        x: 0,
        y: 0
      });

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(container, frame);
    },

    update: function(context) {
      var frame = context.frame,
          bbox = context.bbox;

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(frame, {
        x: bbox.x,
        y: bbox.y,
        width: bbox.width,
        height: bbox.height
      });
    },

    remove: function(context) {

      if (context.frame) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.remove)(context.frame);
      }
    }
  };

  toolManager.registerTool('lasso', {
    tool: 'lasso.selection',
    dragging: 'lasso'
  });

  eventBus.on('lasso.selection.end', function(event) {
    var target = event.originalEvent.target;

    // only reactive on diagram click
    // on some occasions, event.hover is not set and we have to check if the target is an svg
    if (!event.hover && !(target instanceof SVGElement)) {
      return;
    }

    eventBus.once('lasso.selection.ended', function() {
      self.activateLasso(event.originalEvent, true);
    });
  });

  // lasso interaction implementation

  eventBus.on('lasso.end', function(event) {

    var bbox = toBBox(event);

    var elements = elementRegistry.filter(function(element) {
      return element;
    });

    self.select(elements, bbox);
  });

  eventBus.on('lasso.start', function(event) {

    var context = event.context;

    context.bbox = toBBox(event);
    visuals.create(context);
  });

  eventBus.on('lasso.move', function(event) {

    var context = event.context;

    context.bbox = toBBox(event);
    visuals.update(context);
  });

  eventBus.on('lasso.cleanup', function(event) {

    var context = event.context;

    visuals.remove(context);
  });


  // event integration

  eventBus.on('element.mousedown', 1500, function(event) {

    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.hasSecondaryModifier)(event)) {
      return;
    }

    self.activateLasso(event.originalEvent);

    // we've handled the event
    return true;
  });
}

LassoTool.$inject = [
  'eventBus',
  'canvas',
  'dragging',
  'elementRegistry',
  'selection',
  'toolManager',
  'mouse'
];


LassoTool.prototype.activateLasso = function(event, autoActivate) {

  this._dragging.init(event, 'lasso', {
    autoActivate: autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    }
  });
};

LassoTool.prototype.activateSelection = function(event, autoActivate) {

  this._dragging.init(event, 'lasso.selection', {
    trapClick: false,
    autoActivate: autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    }
  });
};

LassoTool.prototype.select = function(elements, bbox) {
  var selectedElements = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getEnclosedElements)(elements, bbox);

  this._selection.select((0,min_dash__WEBPACK_IMPORTED_MODULE_3__.values)(selectedElements));
};

LassoTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }

  var mouseEvent = this._mouse.getLastMoveEvent();

  this.activateSelection(mouseEvent, !!mouseEvent);
};

LassoTool.prototype.isActive = function() {
  var context = this._dragging.context();

  return context && /^lasso/.test(context.prefix);
};



function toBBox(event) {

  var start = {

    x: event.x - event.dx,
    y: event.y - event.dy
  };

  var end = {
    x: event.x,
    y: event.y
  };

  var bbox;

  if ((start.x <= end.x && start.y < end.y) ||
      (start.x < end.x && start.y <= end.y)) {

    bbox = {
      x: start.x,
      y: start.y,
      width:  end.x - start.x,
      height: end.y - start.y
    };
  } else if ((start.x >= end.x && start.y < end.y) ||
             (start.x > end.x && start.y <= end.y)) {

    bbox = {
      x: end.x,
      y: start.y,
      width:  start.x - end.x,
      height: end.y - start.y
    };
  } else if ((start.x <= end.x && start.y > end.y) ||
             (start.x < end.x && start.y >= end.y)) {

    bbox = {
      x: start.x,
      y: end.y,
      width:  end.x - start.x,
      height: start.y - end.y
    };
  } else if ((start.x >= end.x && start.y > end.y) ||
             (start.x > end.x && start.y >= end.y)) {

    bbox = {
      x: end.x,
      y: end.y,
      width:  start.x - end.x,
      height: start.y - end.y
    };
  } else {

    bbox = {
      x: end.x,
      y: end.y,
      width:  0,
      height: 0
    };
  }
  return bbox;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/lasso-tool/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/lasso-tool/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tool_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tool-manager */ "./node_modules/diagram-js/lib/features/tool-manager/index.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mouse */ "./node_modules/diagram-js/lib/features/mouse/index.js");
/* harmony import */ var _LassoTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LassoTool */ "./node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _tool_manager__WEBPACK_IMPORTED_MODULE_0__.default,
    _mouse__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  __init__: [ 'lassoTool' ],
  lassoTool: [ 'type', _LassoTool__WEBPACK_IMPORTED_MODULE_2__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/Modeling.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/Modeling.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Modeling)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../model */ "./node_modules/diagram-js/lib/model/index.js");
/* harmony import */ var _cmd_AlignElementsHandler__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./cmd/AlignElementsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/AlignElementsHandler.js");
/* harmony import */ var _cmd_AppendShapeHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cmd/AppendShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js");
/* harmony import */ var _cmd_CreateConnectionHandler__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cmd/CreateConnectionHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js");
/* harmony import */ var _cmd_CreateElementsHandler__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./cmd/CreateElementsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateElementsHandler.js");
/* harmony import */ var _cmd_CreateLabelHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cmd/CreateLabelHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js");
/* harmony import */ var _cmd_CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cmd/CreateShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js");
/* harmony import */ var _cmd_DeleteConnectionHandler__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cmd/DeleteConnectionHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js");
/* harmony import */ var _cmd_DeleteElementsHandler__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./cmd/DeleteElementsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js");
/* harmony import */ var _cmd_DeleteShapeHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cmd/DeleteShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js");
/* harmony import */ var _cmd_DistributeElementsHandler__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cmd/DistributeElementsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js");
/* harmony import */ var _cmd_LayoutConnectionHandler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./cmd/LayoutConnectionHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js");
/* harmony import */ var _cmd_MoveConnectionHandler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./cmd/MoveConnectionHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js");
/* harmony import */ var _cmd_MoveElementsHandler__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./cmd/MoveElementsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveElementsHandler.js");
/* harmony import */ var _cmd_MoveShapeHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cmd/MoveShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js");
/* harmony import */ var _cmd_ReconnectConnectionHandler__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./cmd/ReconnectConnectionHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js");
/* harmony import */ var _cmd_ReplaceShapeHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cmd/ReplaceShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js");
/* harmony import */ var _cmd_ResizeShapeHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cmd/ResizeShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js");
/* harmony import */ var _cmd_SpaceToolHandler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cmd/SpaceToolHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js");
/* harmony import */ var _cmd_ToggleShapeCollapseHandler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cmd/ToggleShapeCollapseHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js");
/* harmony import */ var _cmd_UpdateAttachmentHandler__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./cmd/UpdateAttachmentHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/UpdateAttachmentHandler.js");
/* harmony import */ var _cmd_UpdateWaypointsHandler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./cmd/UpdateWaypointsHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js");



























/**
 * The basic modeling entry point.
 *
 * @param {EventBus} eventBus
 * @param {ElementFactory} elementFactory
 * @param {CommandStack} commandStack
 */
function Modeling(eventBus, elementFactory, commandStack) {
  this._eventBus = eventBus;
  this._elementFactory = elementFactory;
  this._commandStack = commandStack;

  var self = this;

  eventBus.on('diagram.init', function() {

    // register modeling handlers
    self.registerHandlers(commandStack);
  });
}

Modeling.$inject = [ 'eventBus', 'elementFactory', 'commandStack' ];


Modeling.prototype.getHandlers = function() {
  return {
    'shape.append': _cmd_AppendShapeHandler__WEBPACK_IMPORTED_MODULE_0__.default,
    'shape.create': _cmd_CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__.default,
    'shape.delete': _cmd_DeleteShapeHandler__WEBPACK_IMPORTED_MODULE_2__.default,
    'shape.move': _cmd_MoveShapeHandler__WEBPACK_IMPORTED_MODULE_3__.default,
    'shape.resize': _cmd_ResizeShapeHandler__WEBPACK_IMPORTED_MODULE_4__.default,
    'shape.replace': _cmd_ReplaceShapeHandler__WEBPACK_IMPORTED_MODULE_5__.default,
    'shape.toggleCollapse': _cmd_ToggleShapeCollapseHandler__WEBPACK_IMPORTED_MODULE_6__.default,

    'spaceTool': _cmd_SpaceToolHandler__WEBPACK_IMPORTED_MODULE_7__.default,

    'label.create': _cmd_CreateLabelHandler__WEBPACK_IMPORTED_MODULE_8__.default,

    'connection.create': _cmd_CreateConnectionHandler__WEBPACK_IMPORTED_MODULE_9__.default,
    'connection.delete': _cmd_DeleteConnectionHandler__WEBPACK_IMPORTED_MODULE_10__.default,
    'connection.move': _cmd_MoveConnectionHandler__WEBPACK_IMPORTED_MODULE_11__.default,
    'connection.layout': _cmd_LayoutConnectionHandler__WEBPACK_IMPORTED_MODULE_12__.default,

    'connection.updateWaypoints': _cmd_UpdateWaypointsHandler__WEBPACK_IMPORTED_MODULE_13__.default,

    'connection.reconnect': _cmd_ReconnectConnectionHandler__WEBPACK_IMPORTED_MODULE_14__.default,

    'elements.create': _cmd_CreateElementsHandler__WEBPACK_IMPORTED_MODULE_15__.default,
    'elements.move': _cmd_MoveElementsHandler__WEBPACK_IMPORTED_MODULE_16__.default,
    'elements.delete': _cmd_DeleteElementsHandler__WEBPACK_IMPORTED_MODULE_17__.default,

    'elements.distribute': _cmd_DistributeElementsHandler__WEBPACK_IMPORTED_MODULE_18__.default,
    'elements.align': _cmd_AlignElementsHandler__WEBPACK_IMPORTED_MODULE_19__.default,

    'element.updateAttachment': _cmd_UpdateAttachmentHandler__WEBPACK_IMPORTED_MODULE_20__.default
  };
};

/**
 * Register handlers with the command stack
 *
 * @param {CommandStack} commandStack
 */
Modeling.prototype.registerHandlers = function(commandStack) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_21__.forEach)(this.getHandlers(), function(handler, id) {
    commandStack.registerHandler(id, handler);
  });
};


// modeling helpers //////////////////////

Modeling.prototype.moveShape = function(shape, delta, newParent, newParentIndex, hints) {

  if (typeof newParentIndex === 'object') {
    hints = newParentIndex;
    newParentIndex = null;
  }

  var context = {
    shape: shape,
    delta:  delta,
    newParent: newParent,
    newParentIndex: newParentIndex,
    hints: hints || {}
  };

  this._commandStack.execute('shape.move', context);
};


/**
 * Update the attachment of the given shape.
 *
 * @param {djs.mode.Base} shape
 * @param {djs.model.Base} [newHost]
 */
Modeling.prototype.updateAttachment = function(shape, newHost) {
  var context = {
    shape: shape,
    newHost: newHost
  };

  this._commandStack.execute('element.updateAttachment', context);
};


/**
 * Move a number of shapes to a new target, either setting it as
 * the new parent or attaching it.
 *
 * @param {Array<djs.mode.Base>} shapes
 * @param {Point} delta
 * @param {djs.model.Base} [target]
 * @param {Object} [hints]
 * @param {boolean} [hints.attach=false]
 */
Modeling.prototype.moveElements = function(shapes, delta, target, hints) {

  hints = hints || {};

  var attach = hints.attach;

  var newParent = target,
      newHost;

  if (attach === true) {
    newHost = target;
    newParent = target.parent;
  } else

  if (attach === false) {
    newHost = null;
  }

  var context = {
    shapes: shapes,
    delta: delta,
    newParent: newParent,
    newHost: newHost,
    hints: hints
  };

  this._commandStack.execute('elements.move', context);
};


Modeling.prototype.moveConnection = function(connection, delta, newParent, newParentIndex, hints) {

  if (typeof newParentIndex === 'object') {
    hints = newParentIndex;
    newParentIndex = undefined;
  }

  var context = {
    connection: connection,
    delta: delta,
    newParent: newParent,
    newParentIndex: newParentIndex,
    hints: hints || {}
  };

  this._commandStack.execute('connection.move', context);
};


Modeling.prototype.layoutConnection = function(connection, hints) {
  var context = {
    connection: connection,
    hints: hints || {}
  };

  this._commandStack.execute('connection.layout', context);
};


/**
 * Create connection.
 *
 * @param {djs.model.Base} source
 * @param {djs.model.Base} target
 * @param {number} [parentIndex]
 * @param {Object|djs.model.Connection} connection
 * @param {djs.model.Base} parent
 * @param {Object} hints
 *
 * @return {djs.model.Connection} the created connection.
 */
Modeling.prototype.createConnection = function(source, target, parentIndex, connection, parent, hints) {

  if (typeof parentIndex === 'object') {
    hints = parent;
    parent = connection;
    connection = parentIndex;
    parentIndex = undefined;
  }

  connection = this._create('connection', connection);

  var context = {
    source: source,
    target: target,
    parent: parent,
    parentIndex: parentIndex,
    connection: connection,
    hints: hints
  };

  this._commandStack.execute('connection.create', context);

  return context.connection;
};


/**
 * Create a shape at the specified position.
 *
 * @param {djs.model.Shape|Object} shape
 * @param {Point} position
 * @param {djs.model.Shape|djs.model.Root} target
 * @param {number} [parentIndex] position in parents children list
 * @param {Object} [hints]
 * @param {boolean} [hints.attach] whether to attach to target or become a child
 *
 * @return {djs.model.Shape} the created shape
 */
Modeling.prototype.createShape = function(shape, position, target, parentIndex, hints) {

  if (typeof parentIndex !== 'number') {
    hints = parentIndex;
    parentIndex = undefined;
  }

  hints = hints || {};

  var attach = hints.attach,
      parent,
      host;

  shape = this._create('shape', shape);

  if (attach) {
    parent = target.parent;
    host = target;
  } else {
    parent = target;
  }

  var context = {
    position: position,
    shape: shape,
    parent: parent,
    parentIndex: parentIndex,
    host: host,
    hints: hints
  };

  this._commandStack.execute('shape.create', context);

  return context.shape;
};


Modeling.prototype.createElements = function(elements, position, parent, parentIndex, hints) {
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_21__.isArray)(elements)) {
    elements = [ elements ];
  }

  if (typeof parentIndex !== 'number') {
    hints = parentIndex;
    parentIndex = undefined;
  }

  hints = hints || {};

  var context = {
    position: position,
    elements: elements,
    parent: parent,
    parentIndex: parentIndex,
    hints: hints
  };

  this._commandStack.execute('elements.create', context);

  return context.elements;
};


Modeling.prototype.createLabel = function(labelTarget, position, label, parent) {

  label = this._create('label', label);

  var context = {
    labelTarget: labelTarget,
    position: position,
    parent: parent || labelTarget.parent,
    shape: label
  };

  this._commandStack.execute('label.create', context);

  return context.shape;
};


/**
 * Append shape to given source, drawing a connection
 * between source and the newly created shape.
 *
 * @param {djs.model.Shape} source
 * @param {djs.model.Shape|Object} shape
 * @param {Point} position
 * @param {djs.model.Shape} target
 * @param {Object} [hints]
 * @param {boolean} [hints.attach]
 * @param {djs.model.Connection|Object} [hints.connection]
 * @param {djs.model.Base} [hints.connectionParent]
 *
 * @return {djs.model.Shape} the newly created shape
 */
Modeling.prototype.appendShape = function(source, shape, position, target, hints) {

  hints = hints || {};

  shape = this._create('shape', shape);

  var context = {
    source: source,
    position: position,
    target: target,
    shape: shape,
    connection: hints.connection,
    connectionParent: hints.connectionParent,
    hints: hints
  };

  this._commandStack.execute('shape.append', context);

  return context.shape;
};


Modeling.prototype.removeElements = function(elements) {
  var context = {
    elements: elements
  };

  this._commandStack.execute('elements.delete', context);
};


Modeling.prototype.distributeElements = function(groups, axis, dimension) {
  var context = {
    groups: groups,
    axis: axis,
    dimension: dimension
  };

  this._commandStack.execute('elements.distribute', context);
};


Modeling.prototype.removeShape = function(shape, hints) {
  var context = {
    shape: shape,
    hints: hints || {}
  };

  this._commandStack.execute('shape.delete', context);
};


Modeling.prototype.removeConnection = function(connection, hints) {
  var context = {
    connection: connection,
    hints: hints || {}
  };

  this._commandStack.execute('connection.delete', context);
};

Modeling.prototype.replaceShape = function(oldShape, newShape, hints) {
  var context = {
    oldShape: oldShape,
    newData: newShape,
    hints: hints || {}
  };

  this._commandStack.execute('shape.replace', context);

  return context.newShape;
};

Modeling.prototype.alignElements = function(elements, alignment) {
  var context = {
    elements: elements,
    alignment: alignment
  };

  this._commandStack.execute('elements.align', context);
};

Modeling.prototype.resizeShape = function(shape, newBounds, minBounds, hints) {
  var context = {
    shape: shape,
    newBounds: newBounds,
    minBounds: minBounds,
    hints: hints
  };

  this._commandStack.execute('shape.resize', context);
};

Modeling.prototype.createSpace = function(movingShapes, resizingShapes, delta, direction, start) {
  var context = {
    delta: delta,
    direction: direction,
    movingShapes: movingShapes,
    resizingShapes: resizingShapes,
    start: start
  };

  this._commandStack.execute('spaceTool', context);
};

Modeling.prototype.updateWaypoints = function(connection, newWaypoints, hints) {
  var context = {
    connection: connection,
    newWaypoints: newWaypoints,
    hints: hints || {}
  };

  this._commandStack.execute('connection.updateWaypoints', context);
};

Modeling.prototype.reconnect = function(connection, source, target, dockingOrPoints, hints) {
  var context = {
    connection: connection,
    newSource: source,
    newTarget: target,
    dockingOrPoints: dockingOrPoints,
    hints: hints || {}
  };

  this._commandStack.execute('connection.reconnect', context);
};

Modeling.prototype.reconnectStart = function(connection, newSource, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }

  this.reconnect(connection, newSource, connection.target, dockingOrPoints, (0,min_dash__WEBPACK_IMPORTED_MODULE_21__.assign)(hints, {
    docking: 'source'
  }));
};

Modeling.prototype.reconnectEnd = function(connection, newTarget, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }

  this.reconnect(connection, connection.source, newTarget, dockingOrPoints, (0,min_dash__WEBPACK_IMPORTED_MODULE_21__.assign)(hints, {
    docking: 'target'
  }));
};

Modeling.prototype.connect = function(source, target, attrs, hints) {
  return this.createConnection(source, target, attrs || {}, source.parent, hints);
};

Modeling.prototype._create = function(type, attrs) {
  if (attrs instanceof _model__WEBPACK_IMPORTED_MODULE_22__.Base) {
    return attrs;
  } else {
    return this._elementFactory.create(type, attrs);
  }
};

Modeling.prototype.toggleCollapse = function(shape, hints) {
  var context = {
    shape: shape,
    hints: hints || {}
  };

  this._commandStack.execute('shape.toggleCollapse', context);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/AlignElementsHandler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/AlignElementsHandler.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AlignElements)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * A handler that align elements in a certain way.
 *
 */
function AlignElements(modeling, canvas) {
  this._modeling = modeling;
  this._canvas = canvas;
}

AlignElements.$inject = [ 'modeling', 'canvas' ];


AlignElements.prototype.preExecute = function(context) {
  var modeling = this._modeling;

  var elements = context.elements,
      alignment = context.alignment;


  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    var delta = {
      x: 0,
      y: 0
    };

    if (alignment.left) {
      delta.x = alignment.left - element.x;

    } else if (alignment.right) {
      delta.x = (alignment.right - element.width) - element.x;

    } else if (alignment.center) {
      delta.x = (alignment.center - Math.round(element.width / 2)) - element.x;

    } else if (alignment.top) {
      delta.y = alignment.top - element.y;

    } else if (alignment.bottom) {
      delta.y = (alignment.bottom - element.height) - element.y;

    } else if (alignment.middle) {
      delta.y = (alignment.middle - Math.round(element.height / 2)) - element.y;
    }

    modeling.moveElements([ element ], delta, element.parent);
  });
};

AlignElements.prototype.postExecute = function(context) {

};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AppendShapeHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A handler that implements reversible appending of shapes
 * to a source shape.
 *
 * @param {canvas} Canvas
 * @param {elementFactory} ElementFactory
 * @param {modeling} Modeling
 */
function AppendShapeHandler(modeling) {
  this._modeling = modeling;
}

AppendShapeHandler.$inject = [ 'modeling' ];


// api //////////////////////


/**
 * Creates a new shape
 *
 * @param {Object} context
 * @param {ElementDescriptor} context.shape the new shape
 * @param {ElementDescriptor} context.source the source object
 * @param {ElementDescriptor} context.parent the parent object
 * @param {Point} context.position position of the new element
 */
AppendShapeHandler.prototype.preExecute = function(context) {

  var source = context.source;

  if (!source) {
    throw new Error('source required');
  }

  var target = context.target || source.parent,
      shape = context.shape,
      hints = context.hints || {};

  shape = context.shape =
    this._modeling.createShape(
      shape,
      context.position,
      target, { attach: hints.attach });

  context.shape = shape;
};

AppendShapeHandler.prototype.postExecute = function(context) {
  var hints = context.hints || {};

  if (!existsConnection(context.source, context.shape)) {

    // create connection
    if (hints.connectionTarget === context.source) {
      this._modeling.connect(context.shape, context.source, context.connection);
    } else {
      this._modeling.connect(context.source, context.shape, context.connection);
    }
  }
};


function existsConnection(source, target) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.some)(source.outgoing, function(c) {
    return c.target === target;
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateConnectionHandler)
/* harmony export */ });
function CreateConnectionHandler(canvas, layouter) {
  this._canvas = canvas;
  this._layouter = layouter;
}

CreateConnectionHandler.$inject = [ 'canvas', 'layouter' ];


// api //////////////////////


/**
 * Appends a shape to a target shape
 *
 * @param {Object} context
 * @param {djs.element.Base} context.source the source object
 * @param {djs.element.Base} context.target the parent object
 * @param {Point} context.position position of the new element
 */
CreateConnectionHandler.prototype.execute = function(context) {

  var connection = context.connection,
      source = context.source,
      target = context.target,
      parent = context.parent,
      parentIndex = context.parentIndex,
      hints = context.hints;

  if (!source || !target) {
    throw new Error('source and target required');
  }

  if (!parent) {
    throw new Error('parent required');
  }

  connection.source = source;
  connection.target = target;

  if (!connection.waypoints) {
    connection.waypoints = this._layouter.layoutConnection(connection, hints);
  }

  // add connection
  this._canvas.addConnection(connection, parent, parentIndex);

  return connection;
};

CreateConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;

  this._canvas.removeConnection(connection);

  connection.source = null;
  connection.target = null;

  return connection;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateElementsHandler.js":
/*!************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/CreateElementsHandler.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateElementsHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");




var round = Math.round;

function CreateElementsHandler(modeling) {
  this._modeling = modeling;
}

CreateElementsHandler.$inject = [
  'modeling'
];

CreateElementsHandler.prototype.preExecute = function(context) {
  var elements = context.elements,
      parent = context.parent,
      parentIndex = context.parentIndex,
      position = context.position,
      hints = context.hints;

  var modeling = this._modeling;

  // make sure each element has x and y
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.x)) {
      element.x = 0;
    }

    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(element.y)) {
      element.y = 0;
    }
  });

  var bbox = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.getBBox)(elements);

  // center elements around position
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    if (isConnection(element)) {
      element.waypoints = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(element.waypoints, function(waypoint) {
        return {
          x: round(waypoint.x - bbox.x - bbox.width / 2 + position.x),
          y: round(waypoint.y - bbox.y - bbox.height / 2 + position.y)
        };
      });
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(element, {
      x: round(element.x - bbox.x - bbox.width / 2 + position.x),
      y: round(element.y - bbox.y - bbox.height / 2 + position.y)
    });
  });

  var parents = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_1__.getParents)(elements);

  var cache = {};

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    if (isConnection(element)) {
      cache[ element.id ] = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(parentIndex) ?
        modeling.createConnection(
          cache[ element.source.id ],
          cache[ element.target.id ],
          parentIndex,
          element,
          element.parent || parent,
          hints
        ) :
        modeling.createConnection(
          cache[ element.source.id ],
          cache[ element.target.id ],
          element,
          element.parent || parent,
          hints
        );

      return;
    }

    var createShapeHints = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, hints);

    if (parents.indexOf(element) === -1) {
      createShapeHints.autoResize = false;
    }

    cache[ element.id ] = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(parentIndex) ?
      modeling.createShape(
        element,
        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.pick)(element, [ 'x', 'y', 'width', 'height' ]),
        element.parent || parent,
        parentIndex,
        createShapeHints
      ) :
      modeling.createShape(
        element,
        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.pick)(element, [ 'x', 'y', 'width', 'height' ]),
        element.parent || parent,
        createShapeHints
      );
  });

  context.elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.values)(cache);
};

// helpers //////////

function isConnection(element) {
  return !!element.waypoints;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateLabelHandler)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CreateShapeHandler */ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js");





/**
 * A handler that attaches a label to a given target shape.
 *
 * @param {Canvas} canvas
 */
function CreateLabelHandler(canvas) {
  _CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__.default.call(this, canvas);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(CreateLabelHandler, _CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__.default);

CreateLabelHandler.$inject = [ 'canvas' ];


// api //////////////////////


var originalExecute = _CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__.default.prototype.execute;

/**
 * Appends a label to a target shape.
 *
 * @method CreateLabelHandler#execute
 *
 * @param {Object} context
 * @param {ElementDescriptor} context.target the element the label is attached to
 * @param {ElementDescriptor} context.parent the parent object
 * @param {Point} context.position position of the new element
 */
CreateLabelHandler.prototype.execute = function(context) {

  var label = context.shape;

  ensureValidDimensions(label);

  label.labelTarget = context.labelTarget;

  return originalExecute.call(this, context);
};

var originalRevert = _CreateShapeHandler__WEBPACK_IMPORTED_MODULE_1__.default.prototype.revert;

/**
 * Undo append by removing the shape
 */
CreateLabelHandler.prototype.revert = function(context) {
  context.shape.labelTarget = null;

  return originalRevert.call(this, context);
};


// helpers //////////////////////

function ensureValidDimensions(label) {

  // make sure a label has valid { width, height } dimensions
  [ 'width', 'height' ].forEach(function(prop) {
    if (typeof label[prop] === 'undefined') {
      label[prop] = 0;
    }
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateShapeHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var round = Math.round;


/**
 * A handler that implements reversible addition of shapes.
 *
 * @param {canvas} Canvas
 */
function CreateShapeHandler(canvas) {
  this._canvas = canvas;
}

CreateShapeHandler.$inject = [ 'canvas' ];


// api //////////////////////


/**
 * Appends a shape to a target shape
 *
 * @param {Object} context
 * @param {djs.model.Base} context.parent the parent object
 * @param {Point} context.position position of the new element
 */
CreateShapeHandler.prototype.execute = function(context) {

  var shape = context.shape,
      positionOrBounds = context.position,
      parent = context.parent,
      parentIndex = context.parentIndex;

  if (!parent) {
    throw new Error('parent required');
  }

  if (!positionOrBounds) {
    throw new Error('position required');
  }

  // (1) add at event center position _or_ at given bounds
  if (positionOrBounds.width !== undefined) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(shape, positionOrBounds);
  } else {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(shape, {
      x: positionOrBounds.x - round(shape.width / 2),
      y: positionOrBounds.y - round(shape.height / 2)
    });
  }

  // (2) add to canvas
  this._canvas.addShape(shape, parent, parentIndex);

  return shape;
};


/**
 * Undo append by removing the shape
 */
CreateShapeHandler.prototype.revert = function(context) {

  var shape = context.shape;

  // (3) remove form canvas
  this._canvas.removeShape(shape);

  return shape;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DeleteConnectionHandler)
/* harmony export */ });
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");



/**
 * A handler that implements reversible deletion of Connections.
 */
function DeleteConnectionHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}

DeleteConnectionHandler.$inject = [
  'canvas',
  'modeling'
];


DeleteConnectionHandler.prototype.execute = function(context) {

  var connection = context.connection,
      parent = connection.parent;

  context.parent = parent;

  // remember containment
  context.parentIndex = (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.indexOf)(parent.children, connection);

  context.source = connection.source;
  context.target = connection.target;

  this._canvas.removeConnection(connection);

  connection.source = null;
  connection.target = null;

  return connection;
};

/**
 * Command revert implementation.
 */
DeleteConnectionHandler.prototype.revert = function(context) {

  var connection = context.connection,
      parent = context.parent,
      parentIndex = context.parentIndex;

  connection.source = context.source;
  connection.target = context.target;

  // restore containment
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(parent.children, connection, parentIndex);

  this._canvas.addConnection(connection, parent);

  return connection;
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js":
/*!************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DeleteElementsHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



function DeleteElementsHandler(modeling, elementRegistry) {
  this._modeling = modeling;
  this._elementRegistry = elementRegistry;
}

DeleteElementsHandler.$inject = [
  'modeling',
  'elementRegistry'
];


DeleteElementsHandler.prototype.postExecute = function(context) {

  var modeling = this._modeling,
      elementRegistry = this._elementRegistry,
      elements = context.elements;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {

    // element may have been removed with previous
    // remove operations already (e.g. in case of nesting)
    if (!elementRegistry.get(element.id)) {
      return;
    }

    if (element.waypoints) {
      modeling.removeConnection(element);
    } else {
      modeling.removeShape(element);
    }
  });
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DeleteShapeHandler)
/* harmony export */ });
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");
/* harmony import */ var _util_Removal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Removal */ "./node_modules/diagram-js/lib/util/Removal.js");





/**
 * A handler that implements reversible deletion of shapes.
 *
 */
function DeleteShapeHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}

DeleteShapeHandler.$inject = [ 'canvas', 'modeling' ];


/**
 * - Remove connections
 * - Remove all direct children
 */
DeleteShapeHandler.prototype.preExecute = function(context) {

  var modeling = this._modeling;

  var shape = context.shape;

  // remove connections
  (0,_util_Removal__WEBPACK_IMPORTED_MODULE_0__.saveClear)(shape.incoming, function(connection) {

    // To make sure that the connection isn't removed twice
    // For example if a container is removed
    modeling.removeConnection(connection, { nested: true });
  });

  (0,_util_Removal__WEBPACK_IMPORTED_MODULE_0__.saveClear)(shape.outgoing, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });

  // remove child shapes and connections
  (0,_util_Removal__WEBPACK_IMPORTED_MODULE_0__.saveClear)(shape.children, function(child) {
    if (isConnection(child)) {
      modeling.removeConnection(child, { nested: true });
    } else {
      modeling.removeShape(child, { nested: true });
    }
  });
};

/**
 * Remove shape and remember the parent
 */
DeleteShapeHandler.prototype.execute = function(context) {
  var canvas = this._canvas;

  var shape = context.shape,
      oldParent = shape.parent;

  context.oldParent = oldParent;

  // remove containment
  context.oldParentIndex = (0,_util_Collections__WEBPACK_IMPORTED_MODULE_1__.indexOf)(oldParent.children, shape);

  // remove shape
  canvas.removeShape(shape);

  return shape;
};


/**
 * Command revert implementation
 */
DeleteShapeHandler.prototype.revert = function(context) {

  var canvas = this._canvas;

  var shape = context.shape,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex;

  // restore containment
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_1__.add)(oldParent.children, shape, oldParentIndex);

  canvas.addShape(shape, oldParent);

  return shape;
};

function isConnection(element) {
  return element.waypoints;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DistributeElements)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A handler that distributes elements evenly.
 */
function DistributeElements(modeling) {
  this._modeling = modeling;
}

DistributeElements.$inject = [ 'modeling' ];

var OFF_AXIS = {
  x: 'y',
  y: 'x'
};

DistributeElements.prototype.preExecute = function(context) {
  var modeling = this._modeling;

  var groups = context.groups,
      axis = context.axis,
      dimension = context.dimension;

  function updateRange(group, element) {
    group.range.min = Math.min(element[axis], group.range.min);
    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);
  }

  function center(element) {
    return element[axis] + element[dimension] / 2;
  }

  function lastIdx(arr) {
    return arr.length - 1;
  }

  function rangeDiff(range) {
    return range.max - range.min;
  }

  function centerElement(refCenter, element) {
    var delta = { y: 0 };

    delta[axis] = refCenter - center(element);

    if (delta[axis]) {

      delta[OFF_AXIS[axis]] = 0;

      modeling.moveElements([ element ], delta, element.parent);
    }
  }

  var firstGroup = groups[0],
      lastGroupIdx = lastIdx(groups),
      lastGroup = groups[ lastGroupIdx ];

  var margin,
      spaceInBetween,
      groupsSize = 0; // the size of each range

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(groups, function(group, idx) {
    var sortedElements,
        refElem,
        refCenter;

    if (group.elements.length < 2) {
      if (idx && idx !== groups.length - 1) {
        updateRange(group, group.elements[0]);

        groupsSize += rangeDiff(group.range);
      }
      return;
    }

    sortedElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.sortBy)(group.elements, axis);

    refElem = sortedElements[0];

    if (idx === lastGroupIdx) {
      refElem = sortedElements[lastIdx(sortedElements)];
    }

    refCenter = center(refElem);

    // wanna update the ranges after the shapes have been centered
    group.range = null;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(sortedElements, function(element) {

      centerElement(refCenter, element);

      if (group.range === null) {
        group.range = {
          min: element[axis],
          max: element[axis] + element[dimension]
        };

        return;
      }

      // update group's range after centering the range elements
      updateRange(group, element);
    });

    if (idx && idx !== groups.length - 1) {
      groupsSize += rangeDiff(group.range);
    }
  });

  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);

  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));

  if (margin < groups.length - 1) {
    return;
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(groups, function(group, groupIdx) {
    var delta = {},
        prevGroup;

    if (group === firstGroup || group === lastGroup) {
      return;
    }

    prevGroup = groups[groupIdx - 1];

    group.range.max = 0;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(group.elements, function(element, idx) {
      delta[OFF_AXIS[axis]] = 0;
      delta[axis] = (prevGroup.range.max - element[axis]) + margin;

      if (group.range.min !== element[axis]) {
        delta[axis] += element[axis] - group.range.min;
      }

      if (delta[axis]) {
        modeling.moveElements([ element ], delta, element.parent);
      }

      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);
    });
  });
};

DistributeElements.prototype.postExecute = function(context) {

};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LayoutConnectionHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A handler that implements reversible moving of shapes.
 */
function LayoutConnectionHandler(layouter, canvas) {
  this._layouter = layouter;
  this._canvas = canvas;
}

LayoutConnectionHandler.$inject = [ 'layouter', 'canvas' ];

LayoutConnectionHandler.prototype.execute = function(context) {

  var connection = context.connection;

  var oldWaypoints = connection.waypoints;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(context, {
    oldWaypoints: oldWaypoints
  });

  connection.waypoints = this._layouter.layoutConnection(connection, context.hints);

  return connection;
};

LayoutConnectionHandler.prototype.revert = function(context) {

  var connection = context.connection;

  connection.waypoints = context.oldWaypoints;

  return connection;
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js":
/*!************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveConnectionHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");






/**
 * A handler that implements reversible moving of connections.
 *
 * The handler differs from the layout connection handler in a sense
 * that it preserves the connection layout.
 */
function MoveConnectionHandler() { }


MoveConnectionHandler.prototype.execute = function(context) {

  var connection = context.connection,
      delta = context.delta;

  var newParent = context.newParent || connection.parent,
      newParentIndex = context.newParentIndex,
      oldParent = connection.parent;

  // save old parent in context
  context.oldParent = oldParent;
  context.oldParentIndex = (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.remove)(oldParent.children, connection);

  // add to new parent at position
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(newParent.children, connection, newParentIndex);

  // update parent
  connection.parent = newParent;

  // update waypoint positions
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(connection.waypoints, function(p) {
    p.x += delta.x;
    p.y += delta.y;

    if (p.original) {
      p.original.x += delta.x;
      p.original.y += delta.y;
    }
  });

  return connection;
};

MoveConnectionHandler.prototype.revert = function(context) {

  var connection = context.connection,
      newParent = connection.parent,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex,
      delta = context.delta;

  // remove from newParent
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.remove)(newParent.children, connection);

  // restore previous location in old parent
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(oldParent.children, connection, oldParentIndex);

  // restore parent
  connection.parent = oldParent;

  // revert to old waypoint positions
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(connection.waypoints, function(p) {
    p.x -= delta.x;
    p.y -= delta.y;

    if (p.original) {
      p.original.x -= delta.x;
      p.original.y -= delta.y;
    }
  });

  return connection;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveElementsHandler.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/MoveElementsHandler.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveElementsHandler)
/* harmony export */ });
/* harmony import */ var _helper_MoveHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper/MoveHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js");



/**
 * A handler that implements reversible moving of shapes.
 */
function MoveElementsHandler(modeling) {
  this._helper = new _helper_MoveHelper__WEBPACK_IMPORTED_MODULE_0__.default(modeling);
}

MoveElementsHandler.$inject = [ 'modeling' ];

MoveElementsHandler.prototype.preExecute = function(context) {
  context.closure = this._helper.getClosure(context.shapes);
};

MoveElementsHandler.prototype.postExecute = function(context) {

  var hints = context.hints,
      primaryShape;

  if (hints && hints.primaryShape) {
    primaryShape = hints.primaryShape;
    hints.oldParent = primaryShape.parent;
  }

  this._helper.moveClosure(
    context.closure,
    context.delta,
    context.newParent,
    context.newHost,
    primaryShape
  );
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveShapeHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _helper_MoveHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper/MoveHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js");
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");
/* harmony import */ var _helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helper/AnchorsHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js");









/**
 * A handler that implements reversible moving of shapes.
 */
function MoveShapeHandler(modeling) {
  this._modeling = modeling;

  this._helper = new _helper_MoveHelper__WEBPACK_IMPORTED_MODULE_0__.default(modeling);
}

MoveShapeHandler.$inject = [ 'modeling' ];


MoveShapeHandler.prototype.execute = function(context) {

  var shape = context.shape,
      delta = context.delta,
      newParent = context.newParent || shape.parent,
      newParentIndex = context.newParentIndex,
      oldParent = shape.parent;

  context.oldBounds = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.pick)(shape, [ 'x', 'y', 'width', 'height']);

  // save old parent in context
  context.oldParent = oldParent;
  context.oldParentIndex = (0,_util_Collections__WEBPACK_IMPORTED_MODULE_2__.remove)(oldParent.children, shape);

  // add to new parent at position
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_2__.add)(newParent.children, shape, newParentIndex);

  // update shape parent + position
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(shape, {
    parent: newParent,
    x: shape.x + delta.x,
    y: shape.y + delta.y
  });

  return shape;
};

MoveShapeHandler.prototype.postExecute = function(context) {

  var shape = context.shape,
      delta = context.delta,
      hints = context.hints;

  var modeling = this._modeling;

  if (hints.layout !== false) {

    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(shape.incoming, function(c) {
      modeling.layoutConnection(c, {
        connectionEnd: (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_3__.getMovedTargetAnchor)(c, shape, delta)
      });
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(shape.outgoing, function(c) {
      modeling.layoutConnection(c, {
        connectionStart: (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_3__.getMovedSourceAnchor)(c, shape, delta)
      });
    });
  }

  if (hints.recurse !== false) {
    this.moveChildren(context);
  }
};

MoveShapeHandler.prototype.revert = function(context) {

  var shape = context.shape,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex,
      delta = context.delta;

  // restore previous location in old parent
  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_2__.add)(oldParent.children, shape, oldParentIndex);

  // revert to old position and parent
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(shape, {
    parent: oldParent,
    x: shape.x - delta.x,
    y: shape.y - delta.y
  });

  return shape;
};

MoveShapeHandler.prototype.moveChildren = function(context) {

  var delta = context.delta,
      shape = context.shape;

  this._helper.moveRecursive(shape.children, delta, null);
};

MoveShapeHandler.prototype.getNewParent = function(context) {
  return context.newParent || context.shape.parent;
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReconnectConnectionHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * Reconnect connection handler
 */
function ReconnectConnectionHandler(modeling) {
  this._modeling = modeling;
}

ReconnectConnectionHandler.$inject = [ 'modeling' ];

ReconnectConnectionHandler.prototype.execute = function(context) {
  var newSource = context.newSource,
      newTarget = context.newTarget,
      connection = context.connection,
      dockingOrPoints = context.dockingOrPoints;

  if (!newSource && !newTarget) {
    throw new Error('newSource or newTarget required');
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(dockingOrPoints)) {
    context.oldWaypoints = connection.waypoints;
    connection.waypoints = dockingOrPoints;
  }

  if (newSource) {
    context.oldSource = connection.source;
    connection.source = newSource;
  }

  if (newTarget) {
    context.oldTarget = connection.target;
    connection.target = newTarget;
  }

  return connection;
};

ReconnectConnectionHandler.prototype.postExecute = function(context) {
  var connection = context.connection,
      newSource = context.newSource,
      newTarget = context.newTarget,
      dockingOrPoints = context.dockingOrPoints,
      hints = context.hints || {};

  var layoutConnectionHints = {};

  if (hints.connectionStart) {
    layoutConnectionHints.connectionStart = hints.connectionStart;
  }

  if (hints.connectionEnd) {
    layoutConnectionHints.connectionEnd = hints.connectionEnd;
  }

  if (hints.layoutConnection === false) {
    return;
  }

  if (newSource && (!newTarget || hints.docking === 'source')) {
    layoutConnectionHints.connectionStart = layoutConnectionHints.connectionStart
      || getDocking((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(dockingOrPoints) ? dockingOrPoints[ 0 ] : dockingOrPoints);
  }

  if (newTarget && (!newSource || hints.docking === 'target')) {
    layoutConnectionHints.connectionEnd = layoutConnectionHints.connectionEnd
      || getDocking((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(dockingOrPoints) ? dockingOrPoints[ dockingOrPoints.length - 1 ] : dockingOrPoints);
  }

  if (hints.newWaypoints) {
    layoutConnectionHints.waypoints = hints.newWaypoints;
  }

  this._modeling.layoutConnection(connection, layoutConnectionHints);
};

ReconnectConnectionHandler.prototype.revert = function(context) {
  var oldSource = context.oldSource,
      oldTarget = context.oldTarget,
      oldWaypoints = context.oldWaypoints,
      connection = context.connection;

  if (oldSource) {
    connection.source = oldSource;
  }

  if (oldTarget) {
    connection.target = oldTarget;
  }

  if (oldWaypoints) {
    connection.waypoints = oldWaypoints;
  }

  return connection;
};



// helpers //////////

function getDocking(point) {
  return point.original || point;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReplaceShapeHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper/AnchorsHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js");




/**
 * Replace shape by adding new shape and removing old shape. Incoming and outgoing connections will
 * be kept if possible.
 *
 * @class
 * @constructor
 *
 * @param {Modeling} modeling
 * @param {Rules} rules
 */
function ReplaceShapeHandler(modeling, rules) {
  this._modeling = modeling;
  this._rules = rules;
}

ReplaceShapeHandler.$inject = [ 'modeling', 'rules' ];


/**
 * Add new shape.
 *
 * @param {Object} context
 * @param {djs.model.Shape} context.oldShape
 * @param {Object} context.newData
 * @param {string} context.newData.type
 * @param {number} context.newData.x
 * @param {number} context.newData.y
 * @param {Object} [hints]
 */
ReplaceShapeHandler.prototype.preExecute = function(context) {
  var self = this,
      modeling = this._modeling,
      rules = this._rules;

  var oldShape = context.oldShape,
      newData = context.newData,
      hints = context.hints || {},
      newShape;

  function canReconnect(source, target, connection) {
    return rules.allowed('connection.reconnect', {
      connection: connection,
      source: source,
      target: target
    });
  }

  // (1) add new shape at given position
  var position = {
    x: newData.x,
    y: newData.y
  };

  var oldBounds = {
    x: oldShape.x,
    y: oldShape.y,
    width: oldShape.width,
    height: oldShape.height
  };

  newShape = context.newShape =
    context.newShape ||
    self.createShape(newData, position, oldShape.parent, hints);

  // (2) update host
  if (oldShape.host) {
    modeling.updateAttachment(newShape, oldShape.host);
  }

  // (3) adopt all children from old shape
  var children;

  if (hints.moveChildren !== false) {
    children = oldShape.children.slice();

    modeling.moveElements(children, { x: 0, y: 0 }, newShape, hints);
  }

  // (4) reconnect connections to new shape if possible
  var incoming = oldShape.incoming.slice(),
      outgoing = oldShape.outgoing.slice();

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(incoming, function(connection) {
    var source = connection.source,
        allowed = canReconnect(source, newShape, connection);

    if (allowed) {
      self.reconnectEnd(
        connection, newShape,
        (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getResizedTargetAnchor)(connection, newShape, oldBounds),
        hints
      );
    }
  });

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(outgoing, function(connection) {
    var target = connection.target,
        allowed = canReconnect(newShape, target, connection);

    if (allowed) {
      self.reconnectStart(
        connection, newShape,
        (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getResizedSourceAnchor)(connection, newShape, oldBounds),
        hints
      );
    }
  });
};


/**
 * Remove old shape.
 */
ReplaceShapeHandler.prototype.postExecute = function(context) {
  var oldShape = context.oldShape;

  this._modeling.removeShape(oldShape);
};


ReplaceShapeHandler.prototype.execute = function(context) {};


ReplaceShapeHandler.prototype.revert = function(context) {};


ReplaceShapeHandler.prototype.createShape = function(shape, position, target, hints) {
  return this._modeling.createShape(shape, position, target, hints);
};


ReplaceShapeHandler.prototype.reconnectStart = function(connection, newSource, dockingPoint, hints) {
  this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);
};


ReplaceShapeHandler.prototype.reconnectEnd = function(connection, newTarget, dockingPoint, hints) {
  this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResizeShapeHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper/AnchorsHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js");





/**
 * A handler that implements reversible resizing of shapes.
 *
 * @param {Modeling} modeling
 */
function ResizeShapeHandler(modeling) {
  this._modeling = modeling;
}

ResizeShapeHandler.$inject = [ 'modeling' ];

/**
 * {
 *   shape: {....}
 *   newBounds: {
 *     width:  20,
 *     height: 40,
 *     x:       5,
 *     y:      10
 *   }
 *
 * }
 */
ResizeShapeHandler.prototype.execute = function(context) {
  var shape = context.shape,
      newBounds = context.newBounds,
      minBounds = context.minBounds;

  if (newBounds.x === undefined || newBounds.y === undefined ||
      newBounds.width === undefined || newBounds.height === undefined) {
    throw new Error('newBounds must have {x, y, width, height} properties');
  }

  if (minBounds && (newBounds.width < minBounds.width
    || newBounds.height < minBounds.height)) {
    throw new Error('width and height cannot be less than minimum height and width');
  } else if (!minBounds
    && newBounds.width < 10 || newBounds.height < 10) {
    throw new Error('width and height cannot be less than 10px');
  }

  // save old bbox in context
  context.oldBounds = {
    width:  shape.width,
    height: shape.height,
    x:      shape.x,
    y:      shape.y
  };

  // update shape
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(shape, {
    width:  newBounds.width,
    height: newBounds.height,
    x:      newBounds.x,
    y:      newBounds.y
  });

  return shape;
};

ResizeShapeHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling;

  var shape = context.shape,
      oldBounds = context.oldBounds,
      hints = context.hints || {};

  if (hints.layout === false) {
    return;
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.incoming, function(c) {
    modeling.layoutConnection(c, {
      connectionEnd: (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getResizedTargetAnchor)(c, shape, oldBounds)
    });
  });

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.outgoing, function(c) {
    modeling.layoutConnection(c, {
      connectionStart: (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getResizedSourceAnchor)(c, shape, oldBounds)
    });
  });

};

ResizeShapeHandler.prototype.revert = function(context) {

  var shape = context.shape,
      oldBounds = context.oldBounds;

  // restore previous bbox
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(shape, {
    width:  oldBounds.width,
    height: oldBounds.height,
    x:      oldBounds.x,
    y:      oldBounds.y
  });

  return shape;
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpaceToolHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _space_tool_SpaceUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../space-tool/SpaceUtil */ "./node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js");
/* harmony import */ var _helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper/AnchorsHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js");







/**
 * Add or remove space by moving and resizing shapes and updating connection waypoints.
 */
function SpaceToolHandler(modeling) {
  this._modeling = modeling;
}

SpaceToolHandler.$inject = [ 'modeling' ];

SpaceToolHandler.prototype.preExecute = function(context) {
  var delta = context.delta,
      direction = context.direction,
      movingShapes = context.movingShapes,
      resizingShapes = context.resizingShapes,
      start = context.start,
      oldBounds = {};

  // (1) move shapes
  this.moveShapes(movingShapes, delta);

  // (2a) save old bounds of resized shapes
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(resizingShapes, function(shape) {
    oldBounds[shape.id] = getBounds(shape);
  });

  // (2b) resize shapes
  this.resizeShapes(resizingShapes, delta, direction);

  // (3) update connection waypoints
  this.updateConnectionWaypoints(
    (0,_space_tool_SpaceUtil__WEBPACK_IMPORTED_MODULE_1__.getWaypointsUpdatingConnections)(movingShapes, resizingShapes),
    delta,
    direction,
    start,
    movingShapes,
    resizingShapes,
    oldBounds
  );
};

SpaceToolHandler.prototype.execute = function() {};
SpaceToolHandler.prototype.revert = function() {};

SpaceToolHandler.prototype.moveShapes = function(shapes, delta) {
  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shapes, function(element) {
    self._modeling.moveShape(element, delta, null, {
      autoResize: false,
      layout: false,
      recurse: false
    });
  });
};

SpaceToolHandler.prototype.resizeShapes = function(shapes, delta, direction) {
  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shapes, function(shape) {
    var newBounds = (0,_space_tool_SpaceUtil__WEBPACK_IMPORTED_MODULE_1__.resizeBounds)(shape, direction, delta);

    self._modeling.resizeShape(shape, newBounds, null, {
      attachSupport: false,
      autoResize: false,
      layout: false
    });
  });
};

/**
 * Update connections waypoints according to the rules:
 *   1. Both source and target are moved/resized => move waypoints by the delta
 *   2. Only one of source and target is moved/resized => re-layout connection with moved start/end
 */
SpaceToolHandler.prototype.updateConnectionWaypoints = function(
    connections,
    delta,
    direction,
    start,
    movingShapes,
    resizingShapes,
    oldBounds
) {
  var self = this,
      affectedShapes = movingShapes.concat(resizingShapes);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(connections, function(connection) {
    var source = connection.source,
        target = connection.target,
        waypoints = copyWaypoints(connection),
        axis = getAxisFromDirection(direction),
        layoutHints = {
          labelBehavior: false
        };

    if (includes(affectedShapes, source) && includes(affectedShapes, target)) {

      // move waypoints
      waypoints = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(waypoints, function(waypoint) {
        if (shouldMoveWaypoint(waypoint, start, direction)) {

          // move waypoint
          waypoint[ axis ] = waypoint[ axis ] + delta[ axis ];
        }

        if (waypoint.original && shouldMoveWaypoint(waypoint.original, start, direction)) {

          // move waypoint original
          waypoint.original[ axis ] = waypoint.original[ axis ] + delta[ axis ];
        }

        return waypoint;
      });

      self._modeling.updateWaypoints(connection, waypoints, {
        labelBehavior: false
      });
    } else if (includes(affectedShapes, source) || includes(affectedShapes, target)) {

      // re-layout connection with moved start/end
      if (includes(movingShapes, source)) {
        layoutHints.connectionStart = (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_2__.getMovedSourceAnchor)(connection, source, delta);
      } else if (includes(movingShapes, target)) {
        layoutHints.connectionEnd = (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_2__.getMovedTargetAnchor)(connection, target, delta);
      } else if (includes(resizingShapes, source)) {
        layoutHints.connectionStart = (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_2__.getResizedSourceAnchor)(
          connection, source, oldBounds[source.id]
        );
      } else if (includes(resizingShapes, target)) {
        layoutHints.connectionEnd = (0,_helper_AnchorsHelper__WEBPACK_IMPORTED_MODULE_2__.getResizedTargetAnchor)(
          connection, target, oldBounds[target.id]
        );
      }

      self._modeling.layoutConnection(connection, layoutHints);
    }
  });
};


// helpers //////////

function copyWaypoint(waypoint) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, waypoint);
}

function copyWaypoints(connection) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.map)(connection.waypoints, function(waypoint) {

    waypoint = copyWaypoint(waypoint);

    if (waypoint.original) {
      waypoint.original = copyWaypoint(waypoint.original);
    }

    return waypoint;
  });
}

function getAxisFromDirection(direction) {
  switch (direction) {
  case 'n':
    return 'y';
  case 'w':
    return 'x';
  case 's':
    return 'y';
  case 'e':
    return 'x';
  }
}

function shouldMoveWaypoint(waypoint, start, direction) {
  var relevantAxis = getAxisFromDirection(direction);

  if (/e|s/.test(direction)) {
    return waypoint[ relevantAxis ] > start;
  } else if (/n|w/.test(direction)) {
    return waypoint[ relevantAxis ] < start;
  }
}

function includes(array, item) {
  return array.indexOf(item) !== -1;
}

function getBounds(shape) {
  return {
    x: shape.x,
    y: shape.y,
    height: shape.height,
    width: shape.width
  };
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ToggleShapeCollapseHandler)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * A handler that toggles the collapsed state of an element
 * and the visibility of all its children.
 *
 * @param {Modeling} modeling
 */
function ToggleShapeCollapseHandler(modeling) {
  this._modeling = modeling;
}

ToggleShapeCollapseHandler.$inject = [ 'modeling' ];


ToggleShapeCollapseHandler.prototype.execute = function(context) {

  var shape = context.shape,
      children = shape.children;

  // recursively remember previous visibility of children
  context.oldChildrenVisibility = getElementsVisibilityRecursive(children);

  // toggle state
  shape.collapsed = !shape.collapsed;

  // recursively hide/show children
  var result = setHiddenRecursive(children, shape.collapsed);

  return [shape].concat(result);
};


ToggleShapeCollapseHandler.prototype.revert = function(context) {

  var shape = context.shape,
      oldChildrenVisibility = context.oldChildrenVisibility;

  var children = shape.children;

  // recursively set old visability of children
  var result = restoreVisibilityRecursive(children, oldChildrenVisibility);

  // retoggle state
  shape.collapsed = !shape.collapsed;

  return [shape].concat(result);
};


// helpers //////////////////////

/**
 * Return a map { elementId -> hiddenState}.
 *
 * @param {Array<djs.model.Shape>} elements
 *
 * @return {Object}
 */
function getElementsVisibilityRecursive(elements) {

  var result = {};

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    result[element.id] = element.hidden;

    if (element.children) {
      result = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, result, getElementsVisibilityRecursive(element.children));
    }
  });

  return result;
}


function setHiddenRecursive(elements, newHidden) {
  var result = [];
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    element.hidden = newHidden;

    result = result.concat(element);

    if (element.children) {
      result = result.concat(setHiddenRecursive(element.children, element.collapsed || newHidden));
    }
  });

  return result;
}

function restoreVisibilityRecursive(elements, lastState) {
  var result = [];
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
    element.hidden = lastState[element.id];

    result = result.concat(element);

    if (element.children) {
      result = result.concat(restoreVisibilityRecursive(element.children, lastState));
    }
  });

  return result;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/UpdateAttachmentHandler.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/UpdateAttachmentHandler.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpdateAttachmentHandler)
/* harmony export */ });
/* harmony import */ var _util_Collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Collections */ "./node_modules/diagram-js/lib/util/Collections.js");


/**
 * A handler that implements reversible attaching/detaching of shapes.
 */
function UpdateAttachmentHandler(modeling) {
  this._modeling = modeling;
}

UpdateAttachmentHandler.$inject = [ 'modeling' ];


UpdateAttachmentHandler.prototype.execute = function(context) {
  var shape = context.shape,
      newHost = context.newHost,
      oldHost = shape.host;

  // (0) detach from old host
  context.oldHost = oldHost;
  context.attacherIdx = removeAttacher(oldHost, shape);

  // (1) attach to new host
  addAttacher(newHost, shape);

  // (2) update host
  shape.host = newHost;

  return shape;
};

UpdateAttachmentHandler.prototype.revert = function(context) {
  var shape = context.shape,
      newHost = context.newHost,
      oldHost = context.oldHost,
      attacherIdx = context.attacherIdx;

  // (2) update host
  shape.host = oldHost;

  // (1) attach to new host
  removeAttacher(newHost, shape);

  // (0) detach from old host
  addAttacher(oldHost, shape, attacherIdx);

  return shape;
};


function removeAttacher(host, attacher) {

  // remove attacher from host
  return (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.remove)(host && host.attachers, attacher);
}

function addAttacher(host, attacher, idx) {

  if (!host) {
    return;
  }

  var attachers = host.attachers;

  if (!attachers) {
    host.attachers = attachers = [];
  }

  (0,_util_Collections__WEBPACK_IMPORTED_MODULE_0__.add)(attachers, attacher, idx);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpdateWaypointsHandler)
/* harmony export */ });
function UpdateWaypointsHandler() { }

UpdateWaypointsHandler.prototype.execute = function(context) {

  var connection = context.connection,
      newWaypoints = context.newWaypoints;

  context.oldWaypoints = connection.waypoints;

  connection.waypoints = newWaypoints;

  return connection;
};

UpdateWaypointsHandler.prototype.revert = function(context) {

  var connection = context.connection,
      oldWaypoints = context.oldWaypoints;

  connection.waypoints = oldWaypoints;

  return connection;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getResizedSourceAnchor": () => (/* binding */ getResizedSourceAnchor),
/* harmony export */   "getResizedTargetAnchor": () => (/* binding */ getResizedTargetAnchor),
/* harmony export */   "getMovedSourceAnchor": () => (/* binding */ getMovedSourceAnchor),
/* harmony export */   "getMovedTargetAnchor": () => (/* binding */ getMovedTargetAnchor)
/* harmony export */ });
/* harmony import */ var _util_AttachUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../util/AttachUtil */ "./node_modules/diagram-js/lib/util/AttachUtil.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");







function getResizedSourceAnchor(connection, shape, oldBounds) {

  var waypoints = safeGetWaypoints(connection),
      waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),
      oldAnchor = waypoints[0];

  // new anchor is the last waypoint enclosed be resized source
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[ waypointsInsideNewBounds.length - 1 ];
  }

  return (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_0__.getNewAttachPoint)(oldAnchor.original || oldAnchor, oldBounds, shape);
}


function getResizedTargetAnchor(connection, shape, oldBounds) {

  var waypoints = safeGetWaypoints(connection),
      waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),
      oldAnchor = waypoints[waypoints.length - 1];

  // new anchor is the first waypoint enclosed be resized target
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[ 0 ];
  }

  return (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_0__.getNewAttachPoint)(oldAnchor.original || oldAnchor, oldBounds, shape);
}


function getMovedSourceAnchor(connection, source, moveDelta) {

  var waypoints = safeGetWaypoints(connection),
      oldBounds = subtract(source, moveDelta),
      oldAnchor = waypoints[ 0 ];

  return (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_0__.getNewAttachPoint)(oldAnchor.original || oldAnchor, oldBounds, source);
}


function getMovedTargetAnchor(connection, target, moveDelta) {

  var waypoints = safeGetWaypoints(connection),
      oldBounds = subtract(target, moveDelta),
      oldAnchor = waypoints[ waypoints.length - 1 ];

  return (0,_util_AttachUtil__WEBPACK_IMPORTED_MODULE_0__.getNewAttachPoint)(oldAnchor.original || oldAnchor, oldBounds, target);
}


// helpers //////////////////////

function subtract(bounds, delta) {
  return {
    x: bounds.x - delta.x,
    y: bounds.y - delta.y,
    width: bounds.width,
    height: bounds.height
  };
}


/**
 * Return waypoints of given connection; throw if non exists (should not happen!!).
 *
 * @param {Connection} connection
 *
 * @return {Array<Point>}
 */
function safeGetWaypoints(connection) {

  var waypoints = connection.waypoints;

  if (!waypoints.length) {
    throw new Error('connection#' + connection.id + ': no waypoints');
  }

  return waypoints;
}

function getWaypointsInsideBounds(waypoints, bounds) {
  var originalWaypoints = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.map)(waypoints, getOriginal);

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.filter)(originalWaypoints, function(waypoint) {
    return isInsideBounds(waypoint, bounds);
  });
}

/**
 * Checks if point is inside bounds, incl. edges.
 *
 * @param {Point} point
 * @param {Bounds} bounds
 */
function isInsideBounds(point, bounds) {
  return (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_2__.getOrientation)(bounds, point, 1) === 'intersect';
}

function getOriginal(point) {
  return point.original || point;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveClosure.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveClosure.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveClosure)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");





function MoveClosure() {

  this.allShapes = {};
  this.allConnections = {};

  this.enclosedElements = {};
  this.enclosedConnections = {};

  this.topLevel = {};
}


MoveClosure.prototype.add = function(element, isTopLevel) {
  return this.addAll([ element ], isTopLevel);
};


MoveClosure.prototype.addAll = function(elements, isTopLevel) {

  var newClosure = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_0__.getClosure)(elements, !!isTopLevel, this);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(this, newClosure);

  return this;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js":
/*!********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveHelper)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnchorsHelper */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js");
/* harmony import */ var _MoveClosure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MoveClosure */ "./node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveClosure.js");







/**
 * A helper that is able to carry out serialized move
 * operations on multiple elements.
 *
 * @param {Modeling} modeling
 */
function MoveHelper(modeling) {
  this._modeling = modeling;
}

/**
 * Move the specified elements and all children by the given delta.
 *
 * This moves all enclosed connections, too and layouts all affected
 * external connections.
 *
 * @param  {Array<djs.model.Base>} elements
 * @param  {Point} delta
 * @param  {djs.model.Base} newParent applied to the first level of shapes
 *
 * @return {Array<djs.model.Base>} list of touched elements
 */
MoveHelper.prototype.moveRecursive = function(elements, delta, newParent) {
  if (!elements) {
    return [];
  } else {
    return this.moveClosure(this.getClosure(elements), delta, newParent);
  }
};

/**
 * Move the given closure of elmements.
 *
 * @param {Object} closure
 * @param {Point} delta
 * @param {djs.model.Base} [newParent]
 * @param {djs.model.Base} [newHost]
 */
MoveHelper.prototype.moveClosure = function(closure, delta, newParent, newHost, primaryShape) {
  var modeling = this._modeling;

  var allShapes = closure.allShapes,
      allConnections = closure.allConnections,
      enclosedConnections = closure.enclosedConnections,
      topLevel = closure.topLevel,
      keepParent = false;

  if (primaryShape && primaryShape.parent === newParent) {
    keepParent = true;
  }

  // move all shapes
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(allShapes, function(shape) {

    // move the element according to the given delta
    modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {
      recurse: false,
      layout: false
    });
  });

  // move all child connections / layout external connections
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(allConnections, function(c) {

    var sourceMoved = !!allShapes[c.source.id],
        targetMoved = !!allShapes[c.target.id];

    if (enclosedConnections[c.id] && sourceMoved && targetMoved) {
      modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);
    } else {
      modeling.layoutConnection(c, {
        connectionStart: sourceMoved && (0,_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getMovedSourceAnchor)(c, c.source, delta),
        connectionEnd: targetMoved && (0,_AnchorsHelper__WEBPACK_IMPORTED_MODULE_1__.getMovedTargetAnchor)(c, c.target, delta)
      });
    }
  });
};

/**
 * Returns the closure for the selected elements
 *
 * @param  {Array<djs.model.Base>} elements
 * @return {MoveClosure} closure
 */
MoveHelper.prototype.getClosure = function(elements) {
  return new _MoveClosure__WEBPACK_IMPORTED_MODULE_2__.default().addAll(elements, true);
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/mouse/Mouse.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/mouse/Mouse.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Mouse),
/* harmony export */   "createMoveEvent": () => (/* binding */ createMoveEvent)
/* harmony export */ });
function Mouse(eventBus) {
  var self = this;

  this._lastMoveEvent = null;

  function setLastMoveEvent(mousemoveEvent) {
    self._lastMoveEvent = mousemoveEvent;
  }

  eventBus.on('canvas.init', function(context) {
    var svg = self._svg = context.svg;

    svg.addEventListener('mousemove', setLastMoveEvent);
  });

  eventBus.on('canvas.destroy', function() {
    self._lastMouseEvent = null;

    self._svg.removeEventListener('mousemove', setLastMoveEvent);
  });
}

Mouse.$inject = [ 'eventBus' ];

Mouse.prototype.getLastMoveEvent = function() {
  return this._lastMoveEvent || createMoveEvent(0, 0);
};

// helpers //////////

function createMoveEvent(x, y) {
  var event = document.createEvent('MouseEvent');

  var screenX = x,
      screenY = y,
      clientX = x,
      clientY = y;

  if (event.initMouseEvent) {
    event.initMouseEvent(
      'mousemove',
      true,
      true,
      window,
      0,
      screenX,
      screenY,
      clientX,
      clientY,
      false,
      false,
      false,
      false,
      0,
      null
    );
  }

  return event;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/mouse/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/mouse/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mouse */ "./node_modules/diagram-js/lib/features/mouse/Mouse.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'mouse' ],
  mouse: [ 'type', _Mouse__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/move/Move.js":
/*!***********************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/move/Move.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveEvents)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");


var LOW_PRIORITY = 500,
    MEDIUM_PRIORITY = 1250,
    HIGH_PRIORITY = 1500;





var round = Math.round;

function mid(element) {
  return {
    x: element.x + round(element.width / 2),
    y: element.y + round(element.height / 2)
  };
}

/**
 * A plugin that makes shapes draggable / droppable.
 *
 * @param {EventBus} eventBus
 * @param {Dragging} dragging
 * @param {Modeling} modeling
 * @param {Selection} selection
 * @param {Rules} rules
 */
function MoveEvents(
    eventBus, dragging, modeling,
    selection, rules) {

  // rules

  function canMove(shapes, delta, position, target) {

    return rules.allowed('elements.move', {
      shapes: shapes,
      delta: delta,
      position: position,
      target: target
    });
  }


  // move events

  // assign a high priority to this handler to setup the environment
  // others may hook up later, e.g. at default priority and modify
  // the move environment.
  //
  // This sets up the context with
  //
  // * shape: the primary shape being moved
  // * shapes: a list of shapes to be moved
  // * validatedShapes: a list of shapes that are being checked
  //                    against the rules before and during move
  //
  eventBus.on('shape.move.start', HIGH_PRIORITY, function(event) {

    var context = event.context,
        shape = event.shape,
        shapes = selection.get().slice();

    // move only single shape if the dragged element
    // is not part of the current selection
    if (shapes.indexOf(shape) === -1) {
      shapes = [ shape ];
    }

    // ensure we remove nested elements in the collection
    // and add attachers for a proper dragger
    shapes = removeNested(shapes);

    // attach shapes to drag context
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(context, {
      shapes: shapes,
      validatedShapes: shapes,
      shape: shape
    });
  });


  // assign a high priority to this handler to setup the environment
  // others may hook up later, e.g. at default priority and modify
  // the move environment
  //
  eventBus.on('shape.move.start', MEDIUM_PRIORITY, function(event) {

    var context = event.context,
        validatedShapes = context.validatedShapes,
        canExecute;

    canExecute = context.canExecute = canMove(validatedShapes);

    // check if we can move the elements
    if (!canExecute) {
      return false;
    }
  });

  // assign a low priority to this handler
  // to let others modify the move event before we update
  // the context
  //
  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {

    var context = event.context,
        validatedShapes = context.validatedShapes,
        hover = event.hover,
        delta = { x: event.dx, y: event.dy },
        position = { x: event.x, y: event.y },
        canExecute;

    // check if we can move the elements
    canExecute = canMove(validatedShapes, delta, position, hover);

    context.delta = delta;
    context.canExecute = canExecute;

    // simply ignore move over
    if (canExecute === null) {
      context.target = null;

      return;
    }

    context.target = hover;
  });

  eventBus.on('shape.move.end', function(event) {

    var context = event.context;

    var delta = context.delta,
        canExecute = context.canExecute,
        isAttach = canExecute === 'attach',
        shapes = context.shapes;

    if (canExecute === false) {
      return false;
    }

    // ensure we have actual pixel values deltas
    // (important when zoom level was > 1 during move)
    delta.x = round(delta.x);
    delta.y = round(delta.y);

    if (delta.x === 0 && delta.y === 0) {

      // didn't move
      return;
    }

    modeling.moveElements(shapes, delta, context.target, {
      primaryShape: context.shape,
      attach: isAttach
    });
  });


  // move activation

  eventBus.on('element.mousedown', function(event) {

    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.isPrimaryButton)(event)) {
      return;
    }

    var originalEvent = (0,_util_Event__WEBPACK_IMPORTED_MODULE_2__.getOriginal)(event);

    if (!originalEvent) {
      throw new Error('must supply DOM mousedown event');
    }

    return start(originalEvent, event.element);
  });

  /**
   * Start move.
   *
   * @param {MouseEvent} event
   * @param {djs.model.Shape} shape
   * @param {boolean} [activate]
   * @param {Object} [context]
   */
  function start(event, element, activate, context) {
    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(activate)) {
      context = activate;
      activate = false;
    }

    // do not move connections or the root element
    if (element.waypoints || !element.parent) {
      return;
    }

    var referencePoint = mid(element);

    dragging.init(event, referencePoint, 'shape.move', {
      cursor: 'grabbing',
      autoActivate: activate,
      data: {
        shape: element,
        context: context || {}
      }
    });

    // we've handled the event
    return true;
  }

  // API

  this.start = start;
}

MoveEvents.$inject = [
  'eventBus',
  'dragging',
  'modeling',
  'selection',
  'rules'
];


/**
 * Return a filtered list of elements that do not contain
 * those nested into others.
 *
 * @param  {Array<djs.model.Base>} elements
 *
 * @return {Array<djs.model.Base>} filtered
 */
function removeNested(elements) {

  var ids = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.groupBy)(elements, 'id');

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.filter)(elements, function(element) {
    while ((element = element.parent)) {

      // parent in selection
      if (ids[element.id]) {
        return false;
      }
    }

    return true;
  });
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/move/MovePreview.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/move/MovePreview.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MovePreview)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");








var LOW_PRIORITY = 499;

var MARKER_DRAGGING = 'djs-dragging',
    MARKER_OK = 'drop-ok',
    MARKER_NOT_OK = 'drop-not-ok',
    MARKER_NEW_PARENT = 'new-parent',
    MARKER_ATTACH = 'attach-ok';


/**
 * Provides previews for moving shapes when moving.
 *
 * @param {EventBus} eventBus
 * @param {ElementRegistry} elementRegistry
 * @param {Canvas} canvas
 * @param {Styles} styles
 */
function MovePreview(
    eventBus, canvas, styles, previewSupport) {

  function getVisualDragShapes(shapes) {
    var elements = getAllDraggedElements(shapes);

    var filteredElements = removeEdges(elements);

    return filteredElements;
  }

  function getAllDraggedElements(shapes) {
    var allShapes = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_0__.selfAndAllChildren)(shapes, true);

    var allConnections = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.map)(allShapes, function(shape) {
      return (shape.incoming || []).concat(shape.outgoing || []);
    });

    return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.flatten)(allShapes.concat(allConnections));
  }

  /**
   * Sets drop marker on an element.
   */
  function setMarker(element, marker) {

    [ MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT ].forEach(function(m) {

      if (m === marker) {
        canvas.addMarker(element, m);
      } else {
        canvas.removeMarker(element, m);
      }
    });
  }

  /**
   * Make an element draggable.
   *
   * @param {Object} context
   * @param {djs.model.Base} element
   * @param {boolean} addMarker
   */
  function makeDraggable(context, element, addMarker) {

    previewSupport.addDragger(element, context.dragGroup);

    if (addMarker) {
      canvas.addMarker(element, MARKER_DRAGGING);
    }

    if (context.allDraggedElements) {
      context.allDraggedElements.push(element);
    } else {
      context.allDraggedElements = [ element ];
    }
  }

  // assign a low priority to this handler
  // to let others modify the move context before
  // we draw things
  eventBus.on('shape.move.start', LOW_PRIORITY, function(event) {
    var context = event.context,
        dragShapes = context.shapes,
        allDraggedElements = context.allDraggedElements;

    var visuallyDraggedShapes = getVisualDragShapes(dragShapes);

    if (!context.dragGroup) {
      var dragGroup = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('g');

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(dragGroup, styles.cls('djs-drag-group', [ 'no-events' ]));

      var defaultLayer = canvas.getDefaultLayer();

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(defaultLayer, dragGroup);

      context.dragGroup = dragGroup;
    }

    // add previews
    visuallyDraggedShapes.forEach(function(shape) {
      previewSupport.addDragger(shape, context.dragGroup);
    });

    // cache all dragged elements / gfx
    // so that we can quickly undo their state changes later
    if (!allDraggedElements) {
      allDraggedElements = getAllDraggedElements(dragShapes);
    } else {
      allDraggedElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.flatten)([
        allDraggedElements,
        getAllDraggedElements(dragShapes)
      ]);
    }

    // add dragging marker
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(allDraggedElements, function(e) {
      canvas.addMarker(e, MARKER_DRAGGING);
    });

    context.allDraggedElements = allDraggedElements;

    // determine, if any of the dragged elements have different parents
    context.differentParents = haveDifferentParents(dragShapes);
  });

  // update previews
  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {

    var context = event.context,
        dragGroup = context.dragGroup,
        target = context.target,
        parent = context.shape.parent,
        canExecute = context.canExecute;

    if (target) {
      if (canExecute === 'attach') {
        setMarker(target, MARKER_ATTACH);
      } else if (context.canExecute && target && target.id !== parent.id) {
        setMarker(target, MARKER_NEW_PARENT);
      } else {
        setMarker(target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);
      }
    }

    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_3__.translate)(dragGroup, event.dx, event.dy);
  });

  eventBus.on([ 'shape.move.out', 'shape.move.cleanup' ], function(event) {
    var context = event.context,
        target = context.target;

    if (target) {
      setMarker(target, null);
    }
  });

  // remove previews
  eventBus.on('shape.move.cleanup', function(event) {

    var context = event.context,
        allDraggedElements = context.allDraggedElements,
        dragGroup = context.dragGroup;


    // remove dragging marker
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(allDraggedElements, function(e) {
      canvas.removeMarker(e, MARKER_DRAGGING);
    });

    if (dragGroup) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.remove)(dragGroup);
    }
  });


  // API //////////////////////

  /**
   * Make an element draggable.
   *
   * @param {Object} context
   * @param {djs.model.Base} element
   * @param {boolean} addMarker
   */
  this.makeDraggable = makeDraggable;
}

MovePreview.$inject = [
  'eventBus',
  'canvas',
  'styles',
  'previewSupport'
];


// helpers //////////////////////

/**
 * returns elements minus all connections
 * where source or target is not elements
 */
function removeEdges(elements) {

  var filteredElements = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.filter)(elements, function(element) {

    if (!isConnection(element)) {
      return true;
    } else {

      return (
        (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(elements, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.matchPattern)({ id: element.source.id })) &&
        (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(elements, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.matchPattern)({ id: element.target.id }))
      );
    }
  });

  return filteredElements;
}

function haveDifferentParents(elements) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.size)((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.groupBy)(elements, function(e) { return e.parent && e.parent.id; })) !== 1;
}

/**
 * Checks if an element is a connection.
 */
function isConnection(element) {
  return element.waypoints;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/move/index.js":
/*!************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/move/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interaction_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interaction-events */ "./node_modules/diagram-js/lib/features/interaction-events/index.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection */ "./node_modules/diagram-js/lib/features/selection/index.js");
/* harmony import */ var _outline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../outline */ "./node_modules/diagram-js/lib/features/outline/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _preview_support__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../preview-support */ "./node_modules/diagram-js/lib/features/preview-support/index.js");
/* harmony import */ var _Move__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Move */ "./node_modules/diagram-js/lib/features/move/Move.js");
/* harmony import */ var _MovePreview__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MovePreview */ "./node_modules/diagram-js/lib/features/move/MovePreview.js");










/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _interaction_events__WEBPACK_IMPORTED_MODULE_0__.default,
    _selection__WEBPACK_IMPORTED_MODULE_1__.default,
    _outline__WEBPACK_IMPORTED_MODULE_2__.default,
    _rules__WEBPACK_IMPORTED_MODULE_3__.default,
    _dragging__WEBPACK_IMPORTED_MODULE_4__.default,
    _preview_support__WEBPACK_IMPORTED_MODULE_5__.default
  ],
  __init__: [
    'move',
    'movePreview'
  ],
  move: [ 'type', _Move__WEBPACK_IMPORTED_MODULE_6__.default ],
  movePreview: [ 'type', _MovePreview__WEBPACK_IMPORTED_MODULE_7__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/ordering/OrderingProvider.js":
/*!***************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/ordering/OrderingProvider.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OrderingProvider)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");





/**
 * An abstract provider that allows modelers to implement a custom
 * ordering of diagram elements on the canvas.
 *
 * It makes sure that the order is always preserved during element
 * creation and move operations.
 *
 * In order to use this behavior, inherit from it and override
 * the method {@link OrderingProvider#getOrdering}.
 *
 * @example
 *
 * ```javascript
 * function CustomOrderingProvider(eventBus) {
 *   OrderingProvider.call(this, eventBus);
 *
 *   this.getOrdering = function(element, newParent) {
 *     // always insert elements at the front
 *     // when moving
 *     return {
 *       index: 0,
 *       parent: newParent
 *     };
 *   };
 * }
 * ```
 *
 * @param {EventBus} eventBus
 */
function OrderingProvider(eventBus) {

  _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);


  var self = this;

  this.preExecute([ 'shape.create', 'connection.create' ], function(event) {

    var context = event.context,
        element = context.shape || context.connection,
        parent = context.parent;

    var ordering = self.getOrdering(element, parent);

    if (ordering) {

      if (ordering.parent !== undefined) {
        context.parent = ordering.parent;
      }

      context.parentIndex = ordering.index;
    }
  });

  this.preExecute([ 'shape.move', 'connection.move' ], function(event) {

    var context = event.context,
        element = context.shape || context.connection,
        parent = context.newParent || element.parent;

    var ordering = self.getOrdering(element, parent);

    if (ordering) {

      if (ordering.parent !== undefined) {
        context.newParent = ordering.parent;
      }

      context.newParentIndex = ordering.index;
    }
  });
}

/**
 * Return a custom ordering of the element, both in terms
 * of parent element and index in the new parent.
 *
 * Implementors of this method must return an object with
 * `parent` _and_ `index` in it.
 *
 * @param {djs.model.Base} element
 * @param {djs.model.Shape} newParent
 *
 * @return {Object} ordering descriptor
 */
OrderingProvider.prototype.getOrdering = function(element, newParent) {
  return null;
};

inherits__WEBPACK_IMPORTED_MODULE_0___default()(OrderingProvider, _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/outline/Outline.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/outline/Outline.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Outline)
/* harmony export */ });
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var LOW_PRIORITY = 500;








/**
 * @class
 *
 * A plugin that adds an outline to shapes and connections that may be activated and styled
 * via CSS classes.
 *
 * @param {EventBus} eventBus
 * @param {Styles} styles
 * @param {ElementRegistry} elementRegistry
 */
function Outline(eventBus, styles, elementRegistry) {

  this.offset = 6;

  var OUTLINE_STYLE = styles.cls('djs-outline', [ 'no-fill' ]);

  var self = this;

  function createOutline(gfx, bounds) {
    var outline = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('rect');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(outline, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({
      x: 10,
      y: 10,
      width: 100,
      height: 100
    }, OUTLINE_STYLE));

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(gfx, outline);

    return outline;
  }

  // A low priortity is necessary, because outlines of labels have to be updated
  // after the label bounds have been updated in the renderer.
  eventBus.on([ 'shape.added', 'shape.changed' ], LOW_PRIORITY, function(event) {
    var element = event.element,
        gfx = event.gfx;

    var outline = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)('.djs-outline', gfx);

    if (!outline) {
      outline = createOutline(gfx, element);
    }

    self.updateShapeOutline(outline, element);
  });

  eventBus.on([ 'connection.added', 'connection.changed' ], function(event) {
    var element = event.element,
        gfx = event.gfx;

    var outline = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.query)('.djs-outline', gfx);

    if (!outline) {
      outline = createOutline(gfx, element);
    }

    self.updateConnectionOutline(outline, element);
  });
}


/**
 * Updates the outline of a shape respecting the dimension of the
 * element and an outline offset.
 *
 * @param  {SVGElement} outline
 * @param  {djs.model.Base} element
 */
Outline.prototype.updateShapeOutline = function(outline, element) {

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(outline, {
    x: -this.offset,
    y: -this.offset,
    width: element.width + this.offset * 2,
    height: element.height + this.offset * 2
  });

};


/**
 * Updates the outline of a connection respecting the bounding box of
 * the connection and an outline offset.
 *
 * @param  {SVGElement} outline
 * @param  {djs.model.Base} element
 */
Outline.prototype.updateConnectionOutline = function(outline, connection) {

  var bbox = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.getBBox)(connection);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(outline, {
    x: bbox.x - this.offset,
    y: bbox.y - this.offset,
    width: bbox.width + this.offset * 2,
    height: bbox.height + this.offset * 2
  });

};


Outline.$inject = ['eventBus', 'styles', 'elementRegistry'];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/outline/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/outline/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Outline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Outline */ "./node_modules/diagram-js/lib/features/outline/Outline.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'outline' ],
  outline: [ 'type', _Outline__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/overlays/Overlays.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/overlays/Overlays.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Overlays)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var _util_IdGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/IdGenerator */ "./node_modules/diagram-js/lib/util/IdGenerator.js");








// document wide unique overlay ids
var ids = new _util_IdGenerator__WEBPACK_IMPORTED_MODULE_0__.default('ov');

var LOW_PRIORITY = 500;


/**
 * A service that allows users to attach overlays to diagram elements.
 *
 * The overlay service will take care of overlay positioning during updates.
 *
 * @example
 *
 * // add a pink badge on the top left of the shape
 * overlays.add(someShape, {
 *   position: {
 *     top: -5,
 *     left: -5
 *   },
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
 *
 * // or add via shape id
 *
 * overlays.add('some-element-id', {
 *   position: {
 *     top: -5,
 *     left: -5
 *   }
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
 *
 * // or add with optional type
 *
 * overlays.add(someShape, 'badge', {
 *   position: {
 *     top: -5,
 *     left: -5
 *   }
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
 *
 *
 * // remove an overlay
 *
 * var id = overlays.add(...);
 * overlays.remove(id);
 *
 *
 * You may configure overlay defaults during tool by providing a `config` module
 * with `overlays.defaults` as an entry:
 *
 * {
 *   overlays: {
 *     defaults: {
 *       show: {
 *         minZoom: 0.7,
 *         maxZoom: 5.0
 *       },
 *       scale: {
 *         min: 1
 *       }
 *     }
 * }
 *
 * @param {Object} config
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {ElementRegistry} elementRegistry
 */
function Overlays(config, eventBus, canvas, elementRegistry) {

  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementRegistry = elementRegistry;

  this._ids = ids;

  this._overlayDefaults = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({

    // no show constraints
    show: null,

    // always scale
    scale: true
  }, config && config.defaults);

  /**
   * Mapping overlayId -> overlay
   */
  this._overlays = {};

  /**
   * Mapping elementId -> overlay container
   */
  this._overlayContainers = [];

  // root html element for all overlays
  this._overlayRoot = createRoot(canvas.getContainer());

  this._init();
}


Overlays.$inject = [
  'config.overlays',
  'eventBus',
  'canvas',
  'elementRegistry'
];


/**
 * Returns the overlay with the specified id or a list of overlays
 * for an element with a given type.
 *
 * @example
 *
 * // return the single overlay with the given id
 * overlays.get('some-id');
 *
 * // return all overlays for the shape
 * overlays.get({ element: someShape });
 *
 * // return all overlays on shape with type 'badge'
 * overlays.get({ element: someShape, type: 'badge' });
 *
 * // shape can also be specified as id
 * overlays.get({ element: 'element-id', type: 'badge' });
 *
 *
 * @param {Object} search
 * @param {string} [search.id]
 * @param {string|djs.model.Base} [search.element]
 * @param {string} [search.type]
 *
 * @return {Object|Array<Object>} the overlay(s)
 */
Overlays.prototype.get = function(search) {

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isString)(search)) {
    search = { id: search };
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isString)(search.element)) {
    search.element = this._elementRegistry.get(search.element);
  }

  if (search.element) {
    var container = this._getOverlayContainer(search.element, true);

    // return a list of overlays when searching by element (+type)
    if (container) {
      return search.type ? (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.filter)(container.overlays, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.matchPattern)({ type: search.type })) : container.overlays.slice();
    } else {
      return [];
    }
  } else
  if (search.type) {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.filter)(this._overlays, (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.matchPattern)({ type: search.type }));
  } else {

    // return single element when searching by id
    return search.id ? this._overlays[search.id] : null;
  }
};

/**
 * Adds a HTML overlay to an element.
 *
 * @param {string|djs.model.Base}   element   attach overlay to this shape
 * @param {string}                  [type]    optional type to assign to the overlay
 * @param {Object}                  overlay   the overlay configuration
 *
 * @param {string|DOMElement}       overlay.html                 html element to use as an overlay
 * @param {Object}                  [overlay.show]               show configuration
 * @param {number}                  [overlay.show.minZoom]       minimal zoom level to show the overlay
 * @param {number}                  [overlay.show.maxZoom]       maximum zoom level to show the overlay
 * @param {Object}                  overlay.position             where to attach the overlay
 * @param {number}                  [overlay.position.left]      relative to element bbox left attachment
 * @param {number}                  [overlay.position.top]       relative to element bbox top attachment
 * @param {number}                  [overlay.position.bottom]    relative to element bbox bottom attachment
 * @param {number}                  [overlay.position.right]     relative to element bbox right attachment
 * @param {boolean|Object}          [overlay.scale=true]         false to preserve the same size regardless of
 *                                                               diagram zoom
 * @param {number}                  [overlay.scale.min]
 * @param {number}                  [overlay.scale.max]
 *
 * @return {string}                 id that may be used to reference the overlay for update or removal
 */
Overlays.prototype.add = function(element, type, overlay) {

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isObject)(type)) {
    overlay = type;
    type = null;
  }

  if (!element.id) {
    element = this._elementRegistry.get(element);
  }

  if (!overlay.position) {
    throw new Error('must specifiy overlay position');
  }

  if (!overlay.html) {
    throw new Error('must specifiy overlay html');
  }

  if (!element) {
    throw new Error('invalid element specified');
  }

  var id = this._ids.next();

  overlay = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)({}, this._overlayDefaults, overlay, {
    id: id,
    type: type,
    element: element,
    html: overlay.html
  });

  this._addOverlay(overlay);

  return id;
};


/**
 * Remove an overlay with the given id or all overlays matching the given filter.
 *
 * @see Overlays#get for filter options.
 *
 * @param {string} [id]
 * @param {Object} [filter]
 */
Overlays.prototype.remove = function(filter) {

  var overlays = this.get(filter) || [];

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isArray)(overlays)) {
    overlays = [ overlays ];
  }

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(overlays, function(overlay) {

    var container = self._getOverlayContainer(overlay.element, true);

    if (overlay) {
      (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.remove)(overlay.html);
      (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.remove)(overlay.htmlContainer);

      delete overlay.htmlContainer;
      delete overlay.element;

      delete self._overlays[overlay.id];
    }

    if (container) {
      var idx = container.overlays.indexOf(overlay);
      if (idx !== -1) {
        container.overlays.splice(idx, 1);
      }
    }
  });

};


Overlays.prototype.show = function() {
  setVisible(this._overlayRoot);
};


Overlays.prototype.hide = function() {
  setVisible(this._overlayRoot, false);
};

Overlays.prototype.clear = function() {
  this._overlays = {};

  this._overlayContainers = [];

  (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.clear)(this._overlayRoot);
};

Overlays.prototype._updateOverlayContainer = function(container) {
  var element = container.element,
      html = container.html;

  // update container left,top according to the elements x,y coordinates
  // this ensures we can attach child elements relative to this container

  var x = element.x,
      y = element.y;

  if (element.waypoints) {
    var bbox = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.getBBox)(element);
    x = bbox.x;
    y = bbox.y;
  }

  setPosition(html, x, y);

  (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.attr)(container.html, 'data-container-id', element.id);
};


Overlays.prototype._updateOverlay = function(overlay) {

  var position = overlay.position,
      htmlContainer = overlay.htmlContainer,
      element = overlay.element;

  // update overlay html relative to shape because
  // it is already positioned on the element

  // update relative
  var left = position.left,
      top = position.top;

  if (position.right !== undefined) {

    var width;

    if (element.waypoints) {
      width = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.getBBox)(element).width;
    } else {
      width = element.width;
    }

    left = position.right * -1 + width;
  }

  if (position.bottom !== undefined) {

    var height;

    if (element.waypoints) {
      height = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_3__.getBBox)(element).height;
    } else {
      height = element.height;
    }

    top = position.bottom * -1 + height;
  }

  setPosition(htmlContainer, left || 0, top || 0);
};


Overlays.prototype._createOverlayContainer = function(element) {
  var html = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.domify)('<div class="djs-overlays" style="position: absolute" />');

  this._overlayRoot.appendChild(html);

  var container = {
    html: html,
    element: element,
    overlays: []
  };

  this._updateOverlayContainer(container);

  this._overlayContainers.push(container);

  return container;
};


Overlays.prototype._updateRoot = function(viewbox) {
  var scale = viewbox.scale || 1;

  var matrix = 'matrix(' +
  [
    scale,
    0,
    0,
    scale,
    -1 * viewbox.x * scale,
    -1 * viewbox.y * scale
  ].join(',') +
  ')';

  setTransform(this._overlayRoot, matrix);
};


Overlays.prototype._getOverlayContainer = function(element, raw) {
  var container = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.find)(this._overlayContainers, function(c) {
    return c.element === element;
  });


  if (!container && !raw) {
    return this._createOverlayContainer(element);
  }

  return container;
};


Overlays.prototype._addOverlay = function(overlay) {

  var id = overlay.id,
      element = overlay.element,
      html = overlay.html,
      htmlContainer,
      overlayContainer;

  // unwrap jquery (for those who need it)
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }

  // create proper html elements from
  // overlay HTML strings
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isString)(html)) {
    html = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.domify)(html);
  }

  overlayContainer = this._getOverlayContainer(element);

  htmlContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.domify)('<div class="djs-overlay" data-overlay-id="' + id + '" style="position: absolute">');

  htmlContainer.appendChild(html);

  if (overlay.type) {
    (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.classes)(htmlContainer).add('djs-overlay-' + overlay.type);
  }

  overlay.htmlContainer = htmlContainer;

  overlayContainer.overlays.push(overlay);
  overlayContainer.html.appendChild(htmlContainer);

  this._overlays[id] = overlay;

  this._updateOverlay(overlay);
  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
};


Overlays.prototype._updateOverlayVisibilty = function(overlay, viewbox) {
  var show = overlay.show,
      minZoom = show && show.minZoom,
      maxZoom = show && show.maxZoom,
      htmlContainer = overlay.htmlContainer,
      visible = true;

  if (show) {
    if (
      ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isDefined)(minZoom) && minZoom > viewbox.scale) ||
      ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isDefined)(maxZoom) && maxZoom < viewbox.scale)
    ) {
      visible = false;
    }

    setVisible(htmlContainer, visible);
  }

  this._updateOverlayScale(overlay, viewbox);
};


Overlays.prototype._updateOverlayScale = function(overlay, viewbox) {
  var shouldScale = overlay.scale,
      minScale,
      maxScale,
      htmlContainer = overlay.htmlContainer;

  var scale, transform = '';

  if (shouldScale !== true) {

    if (shouldScale === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = shouldScale.min;
      maxScale = shouldScale.max;
    }

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isDefined)(minScale) && viewbox.scale < minScale) {
      scale = (1 / viewbox.scale || 1) * minScale;
    }

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isDefined)(maxScale) && viewbox.scale > maxScale) {
      scale = (1 / viewbox.scale || 1) * maxScale;
    }
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isDefined)(scale)) {
    transform = 'scale(' + scale + ',' + scale + ')';
  }

  setTransform(htmlContainer, transform);
};


Overlays.prototype._updateOverlaysVisibilty = function(viewbox) {

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(this._overlays, function(overlay) {
    self._updateOverlayVisibilty(overlay, viewbox);
  });
};


Overlays.prototype._init = function() {

  var eventBus = this._eventBus;

  var self = this;


  // scroll/zoom integration

  function updateViewbox(viewbox) {
    self._updateRoot(viewbox);
    self._updateOverlaysVisibilty(viewbox);

    self.show();
  }

  eventBus.on('canvas.viewbox.changing', function(event) {
    self.hide();
  });

  eventBus.on('canvas.viewbox.changed', function(event) {
    updateViewbox(event.viewbox);
  });


  // remove integration

  eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {
    var element = e.element;
    var overlays = self.get({ element: element });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(overlays, function(o) {
      self.remove(o.id);
    });

    var container = self._getOverlayContainer(element);

    if (container) {
      (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.remove)(container.html);
      var i = self._overlayContainers.indexOf(container);
      if (i !== -1) {
        self._overlayContainers.splice(i, 1);
      }
    }
  });


  // move integration

  eventBus.on('element.changed', LOW_PRIORITY, function(e) {
    var element = e.element;

    var container = self._getOverlayContainer(element, true);

    if (container) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(container.overlays, function(overlay) {
        self._updateOverlay(overlay);
      });

      self._updateOverlayContainer(container);
    }
  });


  // marker integration, simply add them on the overlays as classes, too.

  eventBus.on('element.marker.update', function(e) {
    var container = self._getOverlayContainer(e.element, true);
    if (container) {
      (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.classes)(container.html)[e.add ? 'add' : 'remove'](e.marker);
    }
  });


  // clear overlays with diagram

  eventBus.on('diagram.clear', this.clear, this);
};



// helpers /////////////////////////////

function createRoot(parentNode) {
  var root = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.domify)(
    '<div class="djs-overlay-container" style="position: absolute; width: 0; height: 0;" />'
  );

  parentNode.insertBefore(root, parentNode.firstChild);

  return root;
}

function setPosition(el, x, y) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.assign)(el.style, { left: x + 'px', top: y + 'px' });
}

function setVisible(el, visible) {
  el.style.display = visible === false ? 'none' : '';
}

function setTransform(el, transform) {

  el.style['transform-origin'] = 'top left';

  [ '', '-ms-', '-webkit-' ].forEach(function(prefix) {
    el.style[prefix + 'transform'] = transform;
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/overlays/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/overlays/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Overlays__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Overlays */ "./node_modules/diagram-js/lib/features/overlays/Overlays.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'overlays' ],
  overlays: [ 'type', _Overlays__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/palette/Palette.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/palette/Palette.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Palette)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");





var TOGGLE_SELECTOR = '.djs-palette-toggle',
    ENTRY_SELECTOR = '.entry',
    ELEMENT_SELECTOR = TOGGLE_SELECTOR + ', ' + ENTRY_SELECTOR;

var PALETTE_OPEN_CLS = 'open',
    PALETTE_TWO_COLUMN_CLS = 'two-column';

var DEFAULT_PRIORITY = 1000;


/**
 * A palette containing modeling elements.
 */
function Palette(eventBus, canvas) {

  this._eventBus = eventBus;
  this._canvas = canvas;

  var self = this;

  eventBus.on('tool-manager.update', function(event) {
    var tool = event.tool;

    self.updateToolHighlight(tool);
  });

  eventBus.on('i18n.changed', function() {
    self._update();
  });

  eventBus.on('diagram.init', function() {

    self._diagramInitialized = true;

    self._rebuild();
  });
}

Palette.$inject = [ 'eventBus', 'canvas' ];


/**
 * Register a provider with the palette
 *
 * @param  {number} [priority=1000]
 * @param  {PaletteProvider} provider
 *
 * @example
 * const paletteProvider = {
 *   getPaletteEntries: function() {
 *     return function(entries) {
 *       return {
 *         ...entries,
 *         'entry-1': {
 *           label: 'My Entry',
 *           action: function() { alert("I have been clicked!"); }
 *         }
 *       };
 *     }
 *   }
 * };
 *
 * palette.registerProvider(800, paletteProvider);
 */
Palette.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY;
  }

  this._eventBus.on('palette.getProviders', priority, function(event) {
    event.providers.push(provider);
  });

  this._rebuild();
};


/**
 * Returns the palette entries
 *
 * @return {Object<string, PaletteEntryDescriptor>} map of entries
 */
Palette.prototype.getEntries = function() {
  var providers = this._getProviders();

  return providers.reduce(addPaletteEntries, {});
};

Palette.prototype._rebuild = function() {

  if (!this._diagramInitialized) {
    return;
  }

  var providers = this._getProviders();

  if (!providers.length) {
    return;
  }

  if (!this._container) {
    this._init();
  }

  this._update();
};

/**
 * Initialize
 */
Palette.prototype._init = function() {

  var self = this;

  var eventBus = this._eventBus;

  var parentContainer = this._getParentContainer();

  var container = this._container = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(Palette.HTML_MARKUP);

  parentContainer.appendChild(container);

  min_dom__WEBPACK_IMPORTED_MODULE_0__.delegate.bind(container, ELEMENT_SELECTOR, 'click', function(event) {

    var target = event.delegateTarget;

    if ((0,min_dom__WEBPACK_IMPORTED_MODULE_0__.matches)(target, TOGGLE_SELECTOR)) {
      return self.toggle();
    }

    self.trigger('click', event);
  });

  // prevent drag propagation
  min_dom__WEBPACK_IMPORTED_MODULE_0__.event.bind(container, 'mousedown', function(event) {
    event.stopPropagation();
  });

  // prevent drag propagation
  min_dom__WEBPACK_IMPORTED_MODULE_0__.delegate.bind(container, ENTRY_SELECTOR, 'dragstart', function(event) {
    self.trigger('dragstart', event);
  });

  eventBus.on('canvas.resized', this._layoutChanged, this);

  eventBus.fire('palette.create', {
    container: container
  });
};

Palette.prototype._getProviders = function(id) {

  var event = this._eventBus.createEvent({
    type: 'palette.getProviders',
    providers: []
  });

  this._eventBus.fire(event);

  return event.providers;
};

/**
 * Update palette state.
 *
 * @param  {Object} [state] { open, twoColumn }
 */
Palette.prototype._toggleState = function(state) {

  state = state || {};

  var parent = this._getParentContainer(),
      container = this._container;

  var eventBus = this._eventBus;

  var twoColumn;

  var cls = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(container);

  if ('twoColumn' in state) {
    twoColumn = state.twoColumn;
  } else {
    twoColumn = this._needsCollapse(parent.clientHeight, this._entries || {});
  }

  // always update two column
  cls.toggle(PALETTE_TWO_COLUMN_CLS, twoColumn);

  if ('open' in state) {
    cls.toggle(PALETTE_OPEN_CLS, state.open);
  }

  eventBus.fire('palette.changed', {
    twoColumn: twoColumn,
    open: this.isOpen()
  });
};

Palette.prototype._update = function() {

  var entriesContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.djs-palette-entries', this._container),
      entries = this._entries = this.getEntries();

  (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.clear)(entriesContainer);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(entries, function(entry, id) {

    var grouping = entry.group || 'default';

    var container = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.query)('[data-group=' + grouping + ']', entriesContainer);
    if (!container) {
      container = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)('<div class="group" data-group="' + grouping + '"></div>');
      entriesContainer.appendChild(container);
    }

    var html = entry.html || (
      entry.separator ?
        '<hr class="separator" />' :
        '<div class="entry" draggable="true"></div>');


    var control = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)(html);
    container.appendChild(control);

    if (!entry.separator) {
      (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.attr)(control, 'data-action', id);

      if (entry.title) {
        (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.attr)(control, 'title', entry.title);
      }

      if (entry.className) {
        addClasses(control, entry.className);
      }

      if (entry.imageUrl) {
        control.appendChild((0,min_dom__WEBPACK_IMPORTED_MODULE_0__.domify)('<img src="' + entry.imageUrl + '">'));
      }
    }
  });

  // open after update
  this.open();
};


/**
 * Trigger an action available on the palette
 *
 * @param  {string} action
 * @param  {Event} event
 */
Palette.prototype.trigger = function(action, event, autoActivate) {
  var entries = this._entries,
      entry,
      handler,
      originalEvent,
      button = event.delegateTarget || event.target;

  if (!button) {
    return event.preventDefault();
  }

  entry = entries[(0,min_dom__WEBPACK_IMPORTED_MODULE_0__.attr)(button, 'data-action')];

  // when user clicks on the palette and not on an action
  if (!entry) {
    return;
  }

  handler = entry.action;

  originalEvent = event.originalEvent || event;

  // simple action (via callback function)
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
    if (action === 'click') {
      handler(originalEvent, autoActivate);
    }
  } else {
    if (handler[action]) {
      handler[action](originalEvent, autoActivate);
    }
  }

  // silence other actions
  event.preventDefault();
};

Palette.prototype._layoutChanged = function() {
  this._toggleState({});
};

/**
 * Do we need to collapse to two columns?
 *
 * @param {number} availableHeight
 * @param {Object} entries
 *
 * @return {boolean}
 */
Palette.prototype._needsCollapse = function(availableHeight, entries) {

  // top margin + bottom toggle + bottom margin
  // implementors must override this method if they
  // change the palette styles
  var margin = 20 + 10 + 20;

  var entriesHeight = Object.keys(entries).length * 46;

  return availableHeight < entriesHeight + margin;
};

/**
 * Close the palette
 */
Palette.prototype.close = function() {

  this._toggleState({
    open: false,
    twoColumn: false
  });
};


/**
 * Open the palette
 */
Palette.prototype.open = function() {
  this._toggleState({ open: true });
};


Palette.prototype.toggle = function(open) {
  if (this.isOpen()) {
    this.close();
  } else {
    this.open();
  }
};

Palette.prototype.isActiveTool = function(tool) {
  return tool && this._activeTool === tool;
};

Palette.prototype.updateToolHighlight = function(name) {
  var entriesContainer,
      toolsContainer;

  if (!this._toolsContainer) {
    entriesContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.djs-palette-entries', this._container);

    this._toolsContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.query)('[data-group=tools]', entriesContainer);
  }

  toolsContainer = this._toolsContainer;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(toolsContainer.children, function(tool) {
    var actionName = tool.getAttribute('data-action');

    if (!actionName) {
      return;
    }

    var toolClasses = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(tool);

    actionName = actionName.replace('-tool', '');

    if (toolClasses.contains('entry') && actionName === name) {
      toolClasses.add('highlighted-entry');
    } else {
      toolClasses.remove('highlighted-entry');
    }
  });
};


/**
 * Return true if the palette is opened.
 *
 * @example
 *
 * palette.open();
 *
 * if (palette.isOpen()) {
 *   // yes, we are open
 * }
 *
 * @return {boolean} true if palette is opened
 */
Palette.prototype.isOpen = function() {
  return (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(this._container).has(PALETTE_OPEN_CLS);
};

/**
 * Get container the palette lives in.
 *
 * @return {Element}
 */
Palette.prototype._getParentContainer = function() {
  return this._canvas.getContainer();
};


/* markup definition */

Palette.HTML_MARKUP =
  '<div class="djs-palette">' +
    '<div class="djs-palette-entries"></div>' +
    '<div class="djs-palette-toggle"></div>' +
  '</div>';


// helpers //////////////////////

function addClasses(element, classNames) {

  var classes = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(element);

  var actualClassNames = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isArray)(classNames) ? classNames : classNames.split(/\s+/g);
  actualClassNames.forEach(function(cls) {
    classes.add(cls);
  });
}

function addPaletteEntries(entries, provider) {

  var entriesOrUpdater = provider.getPaletteEntries();

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isFunction)(entriesOrUpdater)) {
    return entriesOrUpdater(entries);
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(entriesOrUpdater, function(entry, id) {
    entries[id] = entry;
  });

  return entries;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/palette/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/palette/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Palette */ "./node_modules/diagram-js/lib/features/palette/Palette.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'palette' ],
  palette: [ 'type', _Palette__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PopupMenu)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");




var DATA_REF = 'data-id';

var CLOSE_EVENTS = [
  'contextPad.close',
  'canvas.viewbox.changing',
  'commandStack.changed'
];

var DEFAULT_PRIORITY = 1000;


/**
 * A popup menu that can be used to display a list of actions anywhere in the canvas.
 *
 * @param {Object} config
 * @param {boolean|Object} [config.scale={ min: 1.0, max: 1.5 }]
 * @param {number} [config.scale.min]
 * @param {number} [config.scale.max]
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 *
 * @class
 * @constructor
 */
function PopupMenu(config, eventBus, canvas) {

  var scale = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isDefined)(config && config.scale) ? config.scale : {
    min: 1,
    max: 1.5
  };

  this._config = {
    scale: scale
  };

  this._eventBus = eventBus;
  this._canvas = canvas;
  this._providers = {};
  this._current = {};
}

PopupMenu.$inject = [
  'config.popupMenu',
  'eventBus',
  'canvas'
];

/**
 * Registers a popup menu provider
 *
 * @param  {string} id
 * @param {number} [priority=1000]
 * @param  {Object} provider
 *
 * @example
 * const popupMenuProvider = {
 *   getPopupMenuEntries: function(element) {
 *     return {
 *       'entry-1': {
 *         label: 'My Entry',
 *         action: function() { alert("I have been clicked!"); }
 *       }
 *     }
 *   }
 * };
 *
 * popupMenu.registerProvider('myMenuID', popupMenuProvider);
 */
PopupMenu.prototype.registerProvider = function(id, priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY;
  }

  this._eventBus.on('popupMenu.getProviders.' + id, priority, function(event) {
    event.providers.push(provider);
  });
};

/**
 * Determine if the popup menu has entries.
 *
 * @return {boolean} true if empty
 */
PopupMenu.prototype.isEmpty = function(element, providerId) {
  if (!element) {
    throw new Error('element parameter is missing');
  }

  if (!providerId) {
    throw new Error('providerId parameter is missing');
  }

  var providers = this._getProviders(providerId);

  if (!providers) {
    return true;
  }

  var entries = this._getEntries(element, providers),
      headerEntries = this._getHeaderEntries(element, providers);

  var hasEntries = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.size)(entries) > 0,
      hasHeaderEntries = headerEntries && (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.size)(headerEntries) > 0;

  return !hasEntries && !hasHeaderEntries;
};


/**
 * Create entries and open popup menu at given position
 *
 * @param  {Object} element
 * @param  {string} id provider id
 * @param  {Object} position
 *
 * @return {Object} popup menu instance
 */
PopupMenu.prototype.open = function(element, id, position) {

  var providers = this._getProviders(id);

  if (!element) {
    throw new Error('Element is missing');
  }

  if (!providers || !providers.length) {
    throw new Error('No registered providers for: ' + id);
  }

  if (!position) {
    throw new Error('the position argument is missing');
  }

  if (this.isOpen()) {
    this.close();
  }

  this._emit('open');

  var current = this._current = {
    className: id,
    element: element,
    position: position
  };

  var entries = this._getEntries(element, providers),
      headerEntries = this._getHeaderEntries(element, providers);

  current.entries = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, entries, headerEntries);

  current.container = this._createContainer();

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.size)(headerEntries)) {
    current.container.appendChild(
      this._createEntries(headerEntries, 'djs-popup-header')
    );
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.size)(entries)) {
    current.container.appendChild(
      this._createEntries(entries, 'djs-popup-body')
    );
  }

  var canvas = this._canvas,
      parent = canvas.getContainer();

  this._attachContainer(current.container, parent, position.cursor);
  this._bindAutoClose();
};


/**
 * Removes the popup menu and unbinds the event handlers.
 */
PopupMenu.prototype.close = function() {

  if (!this.isOpen()) {
    return;
  }

  this._emit('close');

  this._unbindAutoClose();
  (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.remove)(this._current.container);
  this._current.container = null;
};


/**
 * Determine if an open popup menu exist.
 *
 * @return {boolean} true if open
 */
PopupMenu.prototype.isOpen = function() {
  return !!this._current.container;
};


/**
 * Trigger an action associated with an entry.
 *
 * @param {Object} event
 *
 * @return the result of the action callback, if any
 */
PopupMenu.prototype.trigger = function(event) {

  // silence other actions
  event.preventDefault();

  var element = event.delegateTarget || event.target,
      entryId = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(element, DATA_REF);

  var entry = this._getEntry(entryId);

  if (entry.action) {
    return entry.action.call(null, event, entry);
  }
};

PopupMenu.prototype._getProviders = function(id) {

  var event = this._eventBus.createEvent({
    type: 'popupMenu.getProviders.' + id,
    providers: []
  });

  this._eventBus.fire(event);

  return event.providers;
};

PopupMenu.prototype._getEntries = function(element, providers) {

  var entries = {};

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(providers, function(provider) {

    // handle legacy method
    if (!provider.getPopupMenuEntries) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(provider.getEntries(element), function(entry) {
        var id = entry.id;

        if (!id) {
          throw new Error('every entry must have the id property set');
        }

        entries[id] = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(entry, [ 'id' ]);
      });

      return;
    }

    var entriesOrUpdater = provider.getPopupMenuEntries(element);

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });

  return entries;
};

PopupMenu.prototype._getHeaderEntries = function(element, providers) {

  var entries = {};

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(providers, function(provider) {

    // handle legacy method
    if (!provider.getPopupMenuHeaderEntries) {
      if (!provider.getHeaderEntries) {
        return;
      }

      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(provider.getHeaderEntries(element), function(entry) {
        var id = entry.id;

        if (!id) {
          throw new Error('every entry must have the id property set');
        }

        entries[id] = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.omit)(entry, [ 'id' ]);
      });

      return;
    }

    var entriesOrUpdater = provider.getPopupMenuHeaderEntries(element);

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });

  return entries;


};

/**
 * Gets an entry instance (either entry or headerEntry) by id.
 *
 * @param  {string} entryId
 *
 * @return {Object} entry instance
 */
PopupMenu.prototype._getEntry = function(entryId) {

  var entry = this._current.entries[entryId];

  if (!entry) {
    throw new Error('entry not found');
  }

  return entry;
};

PopupMenu.prototype._emit = function(eventName) {
  this._eventBus.fire('popupMenu.' + eventName);
};

/**
 * Creates the popup menu container.
 *
 * @return {Object} a DOM container
 */
PopupMenu.prototype._createContainer = function() {
  var container = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div class="djs-popup">'),
      position = this._current.position,
      className = this._current.className;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(container.style, {
    position: 'absolute',
    left: position.x + 'px',
    top: position.y + 'px',
    visibility: 'hidden'
  });

  (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(container).add(className);

  return container;
};


/**
 * Attaches the container to the DOM.
 *
 * @param {Object} container
 * @param {Object} parent
 */
PopupMenu.prototype._attachContainer = function(container, parent, cursor) {
  var self = this;

  // Event handler
  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(container, '.entry' ,'click', function(event) {
    self.trigger(event);
  });

  this._updateScale(container);

  // Attach to DOM
  parent.appendChild(container);

  if (cursor) {
    this._assureIsInbounds(container, cursor);
  }
};


/**
 * Updates popup style.transform with respect to the config and zoom level.
 *
 * @method _updateScale
 *
 * @param {Object} container
 */
PopupMenu.prototype._updateScale = function(container) {
  var zoom = this._canvas.zoom();

  var scaleConfig = this._config.scale,
      minScale,
      maxScale,
      scale = zoom;

  if (scaleConfig !== true) {

    if (scaleConfig === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = scaleConfig.min;
      maxScale = scaleConfig.max;
    }

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isDefined)(minScale) && zoom < minScale) {
      scale = minScale;
    }

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isDefined)(maxScale) && zoom > maxScale) {
      scale = maxScale;
    }

  }

  setTransform(container, 'scale(' + scale + ')');
};


/**
 * Make sure that the menu is always fully shown
 *
 * @method function
 *
 * @param  {Object} container
 * @param  {Position} cursor {x, y}
 */
PopupMenu.prototype._assureIsInbounds = function(container, cursor) {
  var canvas = this._canvas,
      clientRect = canvas._container.getBoundingClientRect();

  var containerX = container.offsetLeft,
      containerY = container.offsetTop,
      containerWidth = container.scrollWidth,
      containerHeight = container.scrollHeight,
      overAxis = {},
      left, top;

  var cursorPosition = {
    x: cursor.x - clientRect.left,
    y: cursor.y - clientRect.top
  };

  if (containerX + containerWidth > clientRect.width) {
    overAxis.x = true;
  }

  if (containerY + containerHeight > clientRect.height) {
    overAxis.y = true;
  }

  if (overAxis.x && overAxis.y) {
    left = cursorPosition.x - containerWidth + 'px';
    top = cursorPosition.y - containerHeight + 'px';
  } else if (overAxis.x) {
    left = cursorPosition.x - containerWidth + 'px';
    top = cursorPosition.y + 'px';
  } else if (overAxis.y && cursorPosition.y < containerHeight) {
    left = cursorPosition.x + 'px';
    top = 10 + 'px';
  } else if (overAxis.y) {
    left = cursorPosition.x + 'px';
    top = cursorPosition.y - containerHeight + 'px';
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(container.style, { left: left, top: top }, { visibility: 'visible', 'z-index': 1000 });
};


/**
 * Creates a list of entries and returns them as a DOM container.
 *
 * @param {Array<Object>} entries an array of entry objects
 * @param {string} className the class name of the entry container
 *
 * @return {Object} a DOM container
 */
PopupMenu.prototype._createEntries = function(entries, className) {

  var entriesContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div>'),
      self = this;

  (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(entriesContainer).add(className);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(entries, function(entry, id) {
    var entryContainer = self._createEntry(entry, id);
    entriesContainer.appendChild(entryContainer);
  });

  return entriesContainer;
};


/**
 * Creates a single entry and returns it as a DOM container.
 *
 * @param  {Object} entry
 *
 * @return {Object} a DOM container
 */
PopupMenu.prototype._createEntry = function(entry, id) {

  var entryContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div>'),
      entryClasses = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(entryContainer);

  entryClasses.add('entry');

  if (entry.className) {
    entry.className.split(' ').forEach(function(className) {
      entryClasses.add(className);
    });
  }

  (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(entryContainer, DATA_REF, id);

  if (entry.label) {
    var label = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<span>');
    label.textContent = entry.label;
    entryContainer.appendChild(label);
  }

  if (entry.imageUrl) {
    entryContainer.appendChild((0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<img src="' + entry.imageUrl + '" />'));
  }

  if (entry.active === true) {
    entryClasses.add('active');
  }

  if (entry.disabled === true) {
    entryClasses.add('disabled');
  }

  if (entry.title) {
    entryContainer.title = entry.title;
  }

  return entryContainer;
};


/**
 * Set up listener to close popup automatically on certain events.
 */
PopupMenu.prototype._bindAutoClose = function() {
  this._eventBus.once(CLOSE_EVENTS, this.close, this);
};


/**
 * Remove the auto-closing listener.
 */
PopupMenu.prototype._unbindAutoClose = function() {
  this._eventBus.off(CLOSE_EVENTS, this.close, this);
};



// helpers /////////////////////////////

function setTransform(element, transform) {
  element.style['transform-origin'] = 'top left';

  [ '', '-ms-', '-webkit-' ].forEach(function(prefix) {
    element.style[prefix + 'transform'] = transform;
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/popup-menu/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/popup-menu/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PopupMenu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PopupMenu */ "./node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'popupMenu' ],
  popupMenu: [ 'type', _PopupMenu__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js":
/*!********************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PreviewSupport)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/GraphicsUtil */ "./node_modules/diagram-js/lib/util/GraphicsUtil.js");








var MARKER_TYPES = [
  'marker-start',
  'marker-mid',
  'marker-end'
];

var NODES_CAN_HAVE_MARKER = [
  'circle',
  'ellipse',
  'line',
  'path',
  'polygon',
  'polyline',
  'rect'
];


/**
 * Adds support for previews of moving/resizing elements.
 */
function PreviewSupport(elementRegistry, eventBus, canvas, styles) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  this._styles = styles;

  this._clonedMarkers = {};

  var self = this;

  eventBus.on('drag.cleanup', function() {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(self._clonedMarkers, function(clonedMarker) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(clonedMarker);
    });

    self._clonedMarkers = {};
  });
}

PreviewSupport.$inject = [
  'elementRegistry',
  'eventBus',
  'canvas',
  'styles'
];


/**
 * Returns graphics of an element.
 *
 * @param {djs.model.Base} element
 *
 * @return {SVGElement}
 */
PreviewSupport.prototype.getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};

/**
 * Adds a move preview of a given shape to a given svg group.
 *
 * @param {djs.model.Base} element
 * @param {SVGElement} group
 * @param {SVGElement} [gfx]
 *
 * @return {SVGElement} dragger
 */
PreviewSupport.prototype.addDragger = function(element, group, gfx) {
  gfx = gfx || this.getGfx(element);

  var dragger = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.clone)(gfx);
  var bbox = gfx.getBoundingClientRect();

  this._cloneMarkers((0,_util_GraphicsUtil__WEBPACK_IMPORTED_MODULE_2__.getVisual)(dragger));

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(dragger, this._styles.cls('djs-dragger', [], {
    x: bbox.top,
    y: bbox.left
  }));

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(group, dragger);

  return dragger;
};

/**
 * Adds a resize preview of a given shape to a given svg group.
 *
 * @param {djs.model.Base} element
 * @param {SVGElement} group
 *
 * @return {SVGElement} frame
 */
PreviewSupport.prototype.addFrame = function(shape, group) {

  var frame = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('rect', {
    class: 'djs-resize-overlay',
    width:  shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(group, frame);

  return frame;
};

/**
 * Clone all markers referenced by a node and its child nodes.
 *
 * @param {SVGElement} gfx
 */
PreviewSupport.prototype._cloneMarkers = function(gfx) {
  var self = this;

  if (gfx.childNodes) {

    // TODO: use forEach once we drop PhantomJS
    for (var i = 0; i < gfx.childNodes.length; i++) {

      // recursively clone markers of child nodes
      self._cloneMarkers(gfx.childNodes[ i ]);
    }
  }

  if (!canHaveMarker(gfx)) {
    return;
  }

  MARKER_TYPES.forEach(function(markerType) {
    if ((0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(gfx, markerType)) {
      var marker = getMarker(gfx, markerType, self._canvas.getContainer());

      self._cloneMarker(gfx, marker, markerType);
    }
  });
};

/**
 * Clone marker referenced by an element.
 *
 * @param {SVGElement} gfx
 * @param {SVGElement} marker
 * @param {string} markerType
 */
PreviewSupport.prototype._cloneMarker = function(gfx, marker, markerType) {
  var markerId = marker.id;

  var clonedMarker = this._clonedMarkers[ markerId ];

  if (!clonedMarker) {
    clonedMarker = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.clone)(marker);

    var clonedMarkerId = markerId + '-clone';

    clonedMarker.id = clonedMarkerId;

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(clonedMarker)
      .add('djs-dragger')
      .add('djs-dragger-marker');

    this._clonedMarkers[ markerId ] = clonedMarker;

    var defs = (0,min_dom__WEBPACK_IMPORTED_MODULE_3__.query)('defs', this._canvas._svg);

    if (!defs) {
      defs = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('defs');

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(this._canvas._svg, defs);
    }

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(defs, clonedMarker);
  }

  var reference = idToReference(this._clonedMarkers[ markerId ].id);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(gfx, markerType, reference);
};

// helpers //////////

/**
 * Get marker of given type referenced by node.
 *
 * @param {Node} node
 * @param {string} markerType
 * @param {Node} [parentNode]
 *
 * @param {Node}
 */
function getMarker(node, markerType, parentNode) {
  var id = referenceToId((0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(node, markerType));

  return (0,min_dom__WEBPACK_IMPORTED_MODULE_3__.query)('marker#' + id, parentNode || document);
}

/**
 * Get ID of fragment within current document from its functional IRI reference.
 * References may use single or double quotes.
 *
 * @param {string} reference
 *
 * @returns {string}
 */
function referenceToId(reference) {
  return reference.match(/url\(['"]?#([^'"]*)['"]?\)/)[1];
}

/**
 * Get functional IRI reference for given ID of fragment within current document.
 *
 * @param {string} id
 *
 * @returns {string}
 */
function idToReference(id) {
  return 'url(#' + id + ')';
}

/**
 * Check wether node type can have marker attributes.
 *
 * @param {Node} node
 *
 * @returns {boolean}
 */
function canHaveMarker(node) {
  return NODES_CAN_HAVE_MARKER.indexOf(node.nodeName) !== -1;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/preview-support/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/preview-support/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PreviewSupport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PreviewSupport */ "./node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'previewSupport' ],
  previewSupport: [ 'type', _PreviewSupport__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/replace/Replace.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/replace/Replace.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Replace)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var round = Math.round;

/**
 * Service that allow replacing of elements.
 */
function Replace(modeling) {

  this._modeling = modeling;
}

Replace.$inject = [ 'modeling' ];

/**
 * @param {Element} oldElement - Element to be replaced
 * @param {Object}  newElementData - Containing information about the new element,
 *                                   for example the new bounds and type.
 * @param {Object}  options - Custom options that will be attached to the context. It can be used to inject data
 *                            that is needed in the command chain. For example it could be used in
 *                            eventbus.on('commandStack.shape.replace.postExecute') to change shape attributes after
 *                            shape creation.
 */
Replace.prototype.replaceElement = function(oldElement, newElementData, options) {

  if (oldElement.waypoints) {

    // TODO(nikku): we do not replace connections, yet
    return null;
  }

  var modeling = this._modeling;

  var width = newElementData.width || oldElement.width,
      height = newElementData.height || oldElement.height,
      x = newElementData.x || oldElement.x,
      y = newElementData.y || oldElement.y,
      centerX = round(x + width / 2),
      centerY = round(y + height / 2);

  // modeling API requires center coordinates,
  // account for that when handling shape bounds

  return modeling.replaceShape(
    oldElement,
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(
      {},
      newElementData,
      {
        x: centerX,
        y: centerY,
        width: width,
        height: height
      }
    ),
    options
  );
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/replace/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/replace/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Replace */ "./node_modules/diagram-js/lib/features/replace/Replace.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'replace' ],
  replace: [ 'type', _Replace__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/resize/Resize.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/resize/Resize.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Resize),
/* harmony export */   "getReferencePoint": () => (/* binding */ getReferencePoint)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _ResizeUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeUtil */ "./node_modules/diagram-js/lib/features/resize/ResizeUtil.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");






var DEFAULT_MIN_WIDTH = 10;


/**
 * A component that provides resizing of shapes on the canvas.
 *
 * The following components are part of shape resize:
 *
 *  * adding resize handles,
 *  * creating a visual during resize
 *  * checking resize rules
 *  * committing a change once finished
 *
 *
 * ## Customizing
 *
 * It's possible to customize the resizing behaviour by intercepting 'resize.start'
 * and providing the following parameters through the 'context':
 *
 *   * minDimensions ({ width, height }): minimum shape dimensions
 *
 *   * childrenBoxPadding ({ left, top, bottom, right } || number):
 *     gap between the minimum bounding box and the container
 *
 * f.ex:
 *
 * ```javascript
 * eventBus.on('resize.start', 1500, function(event) {
 *   var context = event.context,
 *
 *  context.minDimensions = { width: 140, height: 120 };
 *
 *  // Passing general padding
 *  context.childrenBoxPadding = 30;
 *
 *  // Passing padding to a specific side
 *  context.childrenBoxPadding.left = 20;
 * });
 * ```
 */
function Resize(eventBus, rules, modeling, dragging) {

  this._dragging = dragging;
  this._rules = rules;

  var self = this;


  /**
   * Handle resize move by specified delta.
   *
   * @param {Object} context
   * @param {Point} delta
   */
  function handleMove(context, delta) {

    var shape = context.shape,
        direction = context.direction,
        resizeConstraints = context.resizeConstraints,
        newBounds;

    context.delta = delta;

    newBounds = (0,_ResizeUtil__WEBPACK_IMPORTED_MODULE_0__.resizeBounds)(shape, direction, delta);

    // ensure constraints during resize
    context.newBounds = (0,_ResizeUtil__WEBPACK_IMPORTED_MODULE_0__.ensureConstraints)(newBounds, resizeConstraints);

    // update + cache executable state
    context.canExecute = self.canResize(context);
  }

  /**
   * Handle resize start.
   *
   * @param  {Object} context
   */
  function handleStart(context) {

    var resizeConstraints = context.resizeConstraints,

        // evaluate minBounds for backwards compatibility
        minBounds = context.minBounds;

    if (resizeConstraints !== undefined) {
      return;
    }

    if (minBounds === undefined) {
      minBounds = self.computeMinResizeBox(context);
    }

    context.resizeConstraints = {
      min: (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(minBounds)
    };
  }

  /**
   * Handle resize end.
   *
   * @param  {Object} context
   */
  function handleEnd(context) {
    var shape = context.shape,
        canExecute = context.canExecute,
        newBounds = context.newBounds;

    if (canExecute) {

      // ensure we have actual pixel values for new bounds
      // (important when zoom level was > 1 during move)
      newBounds = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.roundBounds)(newBounds);

      if (!boundsChanged(shape, newBounds)) {

        // no resize necessary
        return;
      }

      // perform the actual resize
      modeling.resizeShape(shape, newBounds);
    }
  }


  eventBus.on('resize.start', function(event) {
    handleStart(event.context);
  });

  eventBus.on('resize.move', function(event) {
    var delta = {
      x: event.dx,
      y: event.dy
    };

    handleMove(event.context, delta);
  });

  eventBus.on('resize.end', function(event) {
    handleEnd(event.context);
  });

}


Resize.prototype.canResize = function(context) {
  var rules = this._rules;

  var ctx = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.pick)(context, [ 'newBounds', 'shape', 'delta', 'direction' ]);

  return rules.allowed('shape.resize', ctx);
};

/**
 * Activate a resize operation.
 *
 * You may specify additional contextual information and must specify a
 * resize direction during activation of the resize event.
 *
 * @param {MouseEvent} event
 * @param {djs.model.Shape} shape
 * @param {Object|string} contextOrDirection
 */
Resize.prototype.activate = function(event, shape, contextOrDirection) {
  var dragging = this._dragging,
      context,
      direction;

  if (typeof contextOrDirection === 'string') {
    contextOrDirection = {
      direction: contextOrDirection
    };
  }

  context = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ shape: shape }, contextOrDirection);

  direction = context.direction;

  if (!direction) {
    throw new Error('must provide a direction (n|w|s|e|nw|se|ne|sw)');
  }

  dragging.init(event, getReferencePoint(shape, direction), 'resize', {
    autoActivate: true,
    cursor: getCursor(direction),
    data: {
      shape: shape,
      context: context
    }
  });
};

Resize.prototype.computeMinResizeBox = function(context) {
  var shape = context.shape,
      direction = context.direction,
      minDimensions,
      childrenBounds;

  minDimensions = context.minDimensions || {
    width: DEFAULT_MIN_WIDTH,
    height: DEFAULT_MIN_WIDTH
  };

  // get children bounds
  childrenBounds = (0,_ResizeUtil__WEBPACK_IMPORTED_MODULE_0__.computeChildrenBBox)(shape, context.childrenBoxPadding);

  // get correct minimum bounds from given resize direction
  // basically ensures that the minBounds is max(childrenBounds, minDimensions)
  return (0,_ResizeUtil__WEBPACK_IMPORTED_MODULE_0__.getMinResizeBounds)(direction, shape, minDimensions, childrenBounds);
};


Resize.$inject = [
  'eventBus',
  'rules',
  'modeling',
  'dragging'
];

// helpers //////////

function boundsChanged(shape, newBounds) {
  return shape.x !== newBounds.x ||
    shape.y !== newBounds.y ||
    shape.width !== newBounds.width ||
    shape.height !== newBounds.height;
}

function getReferencePoint(shape, direction) {
  var mid = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getMid)(shape),
      trbl = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(shape);

  var referencePoint = {
    x: mid.x,
    y: mid.y
  };

  if (direction.indexOf('n') !== -1) {
    referencePoint.y = trbl.top;
  } else if (direction.indexOf('s') !== -1) {
    referencePoint.y = trbl.bottom;
  }

  if (direction.indexOf('e') !== -1) {
    referencePoint.x = trbl.right;
  } else if (direction.indexOf('w') !== -1) {
    referencePoint.x = trbl.left;
  }

  return referencePoint;
}

function getCursor(direction) {
  var prefix = 'resize-';

  if (direction === 'n' || direction === 's') {
    return prefix + 'ns';
  } else if (direction === 'e' || direction === 'w') {
    return prefix + 'ew';
  } else if (direction === 'nw' || direction === 'se') {
    return prefix + 'nwse';
  } else {
    return prefix + 'nesw';
  }
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/resize/ResizeHandles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/resize/ResizeHandles.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResizeHandles)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");
/* harmony import */ var _Resize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Resize */ "./node_modules/diagram-js/lib/features/resize/Resize.js");












var HANDLE_OFFSET = -6,
    HANDLE_SIZE = 4,
    HANDLE_HIT_SIZE = 20;

var CLS_RESIZER = 'djs-resizer';

var directions = [ 'n', 'w', 's', 'e', 'nw', 'ne', 'se', 'sw' ];


/**
 * This component is responsible for adding resize handles.
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {Selection} selection
 * @param {Resize} resize
 */
function ResizeHandles(eventBus, canvas, selection, resize) {

  this._resize = resize;
  this._canvas = canvas;

  var self = this;

  eventBus.on('selection.changed', function(e) {
    var newSelection = e.newSelection;

    // remove old selection markers
    self.removeResizers();

    // add new selection markers ONLY if single selection
    if (newSelection.length === 1) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(newSelection, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(self.addResizer, self));
    }
  });

  eventBus.on('shape.changed', function(e) {
    var shape = e.element;

    if (selection.isSelected(shape)) {
      self.removeResizers();

      self.addResizer(shape);
    }
  });
}


ResizeHandles.prototype.makeDraggable = function(element, gfx, direction) {
  var resize = this._resize;

  function startResize(event) {

    // only trigger on left mouse button
    if ((0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.isPrimaryButton)(event)) {
      resize.activate(event, element, direction);
    }
  }

  min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(gfx, 'mousedown', startResize);
  min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(gfx, 'touchstart', startResize);
};


ResizeHandles.prototype._createResizer = function(element, x, y, direction) {
  var resizersParent = this._getResizersParent();

  var offset = getHandleOffset(direction);

  var group = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('g');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(group).add(CLS_RESIZER);
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(group).add(CLS_RESIZER + '-' + element.id);
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(group).add(CLS_RESIZER + '-' + direction);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(resizersParent, group);

  var visual = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('rect');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(visual, {
    x: -HANDLE_SIZE / 2 + offset.x,
    y: -HANDLE_SIZE / 2 + offset.y,
    width: HANDLE_SIZE,
    height: HANDLE_SIZE
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(visual).add(CLS_RESIZER + '-visual');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(group, visual);

  var hit = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.create)('rect');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.attr)(hit, {
    x: -HANDLE_HIT_SIZE / 2 + offset.x,
    y: -HANDLE_HIT_SIZE / 2 + offset.y,
    width: HANDLE_HIT_SIZE,
    height: HANDLE_HIT_SIZE
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.classes)(hit).add(CLS_RESIZER + '-hit');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.append)(group, hit);

  (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_4__.transform)(group, x, y);

  return group;
};

ResizeHandles.prototype.createResizer = function(element, direction) {
  var point = (0,_Resize__WEBPACK_IMPORTED_MODULE_5__.getReferencePoint)(element, direction);

  var resizer = this._createResizer(element, point.x, point.y, direction);

  this.makeDraggable(element, resizer, direction);
};

// resize handles implementation ///////////////////////////////

/**
 * Add resizers for a given element.
 *
 * @param {djs.model.Shape} shape
 */
ResizeHandles.prototype.addResizer = function(shape) {
  var self = this;

  var resize = this._resize;

  if (!resize.canResize({ shape: shape })) {
    return;
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(directions, function(direction) {
    self.createResizer(shape, direction);
  });
};

/**
 * Remove all resizers
 */
ResizeHandles.prototype.removeResizers = function() {
  var resizersParent = this._getResizersParent();

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_3__.clear)(resizersParent);
};

ResizeHandles.prototype._getResizersParent = function() {
  return this._canvas.getLayer('resizers');
};

ResizeHandles.$inject = [
  'eventBus',
  'canvas',
  'selection',
  'resize'
];

// helpers //////////

function getHandleOffset(direction) {
  var offset = {
    x: 0,
    y: 0
  };

  if (direction.indexOf('e') !== -1) {
    offset.x = -HANDLE_OFFSET;
  } else if (direction.indexOf('w') !== -1) {
    offset.x = HANDLE_OFFSET;
  }

  if (direction.indexOf('s') !== -1) {
    offset.y = -HANDLE_OFFSET;
  } else if (direction.indexOf('n') !== -1) {
    offset.y = HANDLE_OFFSET;
  }

  return offset;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/resize/ResizePreview.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/resize/ResizePreview.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResizePreview)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
var MARKER_RESIZING = 'djs-resizing',
    MARKER_RESIZE_NOT_OK = 'resize-not-ok';

var LOW_PRIORITY = 500;




/**
 * Provides previews for resizing shapes when resizing.
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 * @param {PreviewSupport} previewSupport
 */
function ResizePreview(eventBus, canvas, previewSupport) {

  /**
   * Update resizer frame.
   *
   * @param {Object} context
   */
  function updateFrame(context) {

    var shape = context.shape,
        bounds = context.newBounds,
        frame = context.frame;

    if (!frame) {
      frame = context.frame = previewSupport.addFrame(shape, canvas.getDefaultLayer());

      canvas.addMarker(shape, MARKER_RESIZING);
    }

    if (bounds.width > 5) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(frame, { x: bounds.x, width: bounds.width });
    }

    if (bounds.height > 5) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(frame, { y: bounds.y, height: bounds.height });
    }

    if (context.canExecute) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.classes)(frame).remove(MARKER_RESIZE_NOT_OK);
    } else {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.classes)(frame).add(MARKER_RESIZE_NOT_OK);
    }
  }

  /**
   * Remove resizer frame.
   *
   * @param {Object} context
   */
  function removeFrame(context) {
    var shape = context.shape,
        frame = context.frame;

    if (frame) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.remove)(context.frame);
    }

    canvas.removeMarker(shape, MARKER_RESIZING);
  }

  // add and update previews
  eventBus.on('resize.move', LOW_PRIORITY, function(event) {
    updateFrame(event.context);
  });

  // remove previews
  eventBus.on('resize.cleanup', function(event) {
    removeFrame(event.context);
  });

}

ResizePreview.$inject = [
  'eventBus',
  'canvas',
  'previewSupport'
];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/resize/ResizeUtil.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/resize/ResizeUtil.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "substractTRBL": () => (/* binding */ substractTRBL),
/* harmony export */   "resizeBounds": () => (/* binding */ resizeBounds),
/* harmony export */   "resizeTRBL": () => (/* binding */ resizeTRBL),
/* harmony export */   "reattachPoint": () => (/* binding */ reattachPoint),
/* harmony export */   "ensureConstraints": () => (/* binding */ ensureConstraints),
/* harmony export */   "getMinResizeBounds": () => (/* binding */ getMinResizeBounds),
/* harmony export */   "addPadding": () => (/* binding */ addPadding),
/* harmony export */   "computeChildrenBBox": () => (/* binding */ computeChildrenBBox)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");


var max = Math.max,
    min = Math.min;

var DEFAULT_CHILD_BOX_PADDING = 20;






/**
 * Substract a TRBL from another
 *
 * @param  {TRBL} trblA
 * @param  {TRBL} trblB
 *
 * @return {TRBL}
 */
function substractTRBL(trblA, trblB) {
  return {
    top: trblA.top - trblB.top,
    right: trblA.right - trblB.right,
    bottom: trblA.bottom - trblB.bottom,
    left: trblA.left - trblB.left
  };
}

/**
 * Resize the given bounds by the specified delta from a given anchor point.
 *
 * @param {Bounds} bounds the bounding box that should be resized
 * @param {string} direction in which the element is resized (nw, ne, se, sw)
 * @param {Point} delta of the resize operation
 *
 * @return {Bounds} resized bounding box
 */
function resizeBounds(bounds, direction, delta) {
  var dx = delta.x,
      dy = delta.y;

  var newBounds = {
    x: bounds.x,
    y: bounds.y,
    width: bounds.width,
    height: bounds.height
  };

  if (direction.indexOf('n') !== -1) {
    newBounds.y = bounds.y + dy;
    newBounds.height = bounds.height - dy;
  } else if (direction.indexOf('s') !== -1) {
    newBounds.height = bounds.height + dy;
  }

  if (direction.indexOf('e') !== -1) {
    newBounds.width = bounds.width + dx;
  } else if (direction.indexOf('w') !== -1) {
    newBounds.x = bounds.x + dx;
    newBounds.width = bounds.width - dx;
  }

  return newBounds;
}


/**
 * Resize the given bounds by applying the passed
 * { top, right, bottom, left } delta.
 *
 * @param {Bounds} bounds
 * @param {TRBL} trblResize
 *
 * @return {Bounds}
 */
function resizeTRBL(bounds, resize) {
  return {
    x: bounds.x + (resize.left || 0),
    y: bounds.y + (resize.top || 0),
    width: bounds.width - (resize.left || 0) + (resize.right || 0),
    height: bounds.height - (resize.top || 0) + (resize.bottom || 0)
  };
}


function reattachPoint(bounds, newBounds, point) {

  var sx = bounds.width / newBounds.width,
      sy = bounds.height / newBounds.height;

  return {
    x: Math.round((newBounds.x + newBounds.width / 2)) - Math.floor(((bounds.x + bounds.width / 2) - point.x) / sx),
    y: Math.round((newBounds.y + newBounds.height / 2)) - Math.floor(((bounds.y + bounds.height / 2) - point.y) / sy)
  };
}


function applyConstraints(attr, trbl, resizeConstraints) {

  var value = trbl[attr],
      minValue = resizeConstraints.min && resizeConstraints.min[attr],
      maxValue = resizeConstraints.max && resizeConstraints.max[attr];

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(minValue)) {
    value = (/top|left/.test(attr) ? min : max)(value, minValue);
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(maxValue)) {
    value = (/top|left/.test(attr) ? max : min)(value, maxValue);
  }

  return value;
}

function ensureConstraints(currentBounds, resizeConstraints) {

  if (!resizeConstraints) {
    return currentBounds;
  }

  var currentTrbl = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(currentBounds);

  return (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asBounds)({
    top: applyConstraints('top', currentTrbl, resizeConstraints),
    right: applyConstraints('right', currentTrbl, resizeConstraints),
    bottom: applyConstraints('bottom', currentTrbl, resizeConstraints),
    left: applyConstraints('left', currentTrbl, resizeConstraints)
  });
}


function getMinResizeBounds(direction, currentBounds, minDimensions, childrenBounds) {

  var currentBox = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(currentBounds);

  var minBox = {
    top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,
    left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,
    bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,
    right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right
  };

  var childrenBox = childrenBounds ? (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(childrenBounds) : minBox;

  var combinedBox = {
    top: min(minBox.top, childrenBox.top),
    left: min(minBox.left, childrenBox.left),
    bottom: max(minBox.bottom, childrenBox.bottom),
    right: max(minBox.right, childrenBox.right)
  };

  return (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asBounds)(combinedBox);
}

function asPadding(mayBePadding, defaultValue) {
  if (typeof mayBePadding !== 'undefined') {
    return mayBePadding;
  } else {
    return DEFAULT_CHILD_BOX_PADDING;
  }
}

function addPadding(bbox, padding) {
  var left, right, top, bottom;

  if (typeof padding === 'object') {
    left = asPadding(padding.left);
    right = asPadding(padding.right);
    top = asPadding(padding.top);
    bottom = asPadding(padding.bottom);
  } else {
    left = right = top = bottom = asPadding(padding);
  }

  return {
    x: bbox.x - left,
    y: bbox.y - top,
    width: bbox.width + left + right,
    height: bbox.height + top + bottom
  };
}


/**
 * Is the given element part of the resize
 * targets min boundary box?
 *
 * This is the default implementation which excludes
 * connections and labels.
 *
 * @param {djs.model.Base} element
 */
function isBBoxChild(element) {

  // exclude connections
  if (element.waypoints) {
    return false;
  }

  // exclude labels
  if (element.type === 'label') {
    return false;
  }

  return true;
}

/**
 * Return children bounding computed from a shapes children
 * or a list of prefiltered children.
 *
 * @param  {djs.model.Shape|Array<djs.model.Shape>} shapeOrChildren
 * @param  {number|Object} padding
 *
 * @return {Bounds}
 */
function computeChildrenBBox(shapeOrChildren, padding) {

  var elements;

  // compute based on shape
  if (shapeOrChildren.length === undefined) {

    // grab all the children that are part of the
    // parents children box
    elements = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.filter)(shapeOrChildren.children, isBBoxChild);

  } else {
    elements = shapeOrChildren;
  }

  if (elements.length) {
    return addPadding((0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getBBox)(elements), padding);
  }
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/resize/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/resize/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _preview_support__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../preview-support */ "./node_modules/diagram-js/lib/features/preview-support/index.js");
/* harmony import */ var _Resize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Resize */ "./node_modules/diagram-js/lib/features/resize/Resize.js");
/* harmony import */ var _ResizePreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ResizePreview */ "./node_modules/diagram-js/lib/features/resize/ResizePreview.js");
/* harmony import */ var _ResizeHandles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ResizeHandles */ "./node_modules/diagram-js/lib/features/resize/ResizeHandles.js");








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _rules__WEBPACK_IMPORTED_MODULE_0__.default,
    _dragging__WEBPACK_IMPORTED_MODULE_1__.default,
    _preview_support__WEBPACK_IMPORTED_MODULE_2__.default
  ],
  __init__: [
    'resize',
    'resizePreview',
    'resizeHandles'
  ],
  resize: [ 'type', _Resize__WEBPACK_IMPORTED_MODULE_3__.default ],
  resizePreview: [ 'type', _ResizePreview__WEBPACK_IMPORTED_MODULE_4__.default ],
  resizeHandles: [ 'type', _ResizeHandles__WEBPACK_IMPORTED_MODULE_5__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/rules/RuleProvider.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/rules/RuleProvider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RuleProvider)
/* harmony export */ });
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../command/CommandInterceptor */ "./node_modules/diagram-js/lib/command/CommandInterceptor.js");




/**
 * A basic provider that may be extended to implement modeling rules.
 *
 * Extensions should implement the init method to actually add their custom
 * modeling checks. Checks may be added via the #addRule(action, fn) method.
 *
 * @param {EventBus} eventBus
 */
function RuleProvider(eventBus) {
  _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default.call(this, eventBus);

  this.init();
}

RuleProvider.$inject = [ 'eventBus' ];

inherits__WEBPACK_IMPORTED_MODULE_0___default()(RuleProvider, _command_CommandInterceptor__WEBPACK_IMPORTED_MODULE_1__.default);


/**
 * Adds a modeling rule for the given action, implemented through
 * a callback function.
 *
 * The function will receive the modeling specific action context
 * to perform its check. It must return `false` to disallow the
 * action from happening or `true` to allow the action.
 *
 * A rule provider may pass over the evaluation to lower priority
 * rules by returning return nothing (or <code>undefined</code>).
 *
 * @example
 *
 * ResizableRules.prototype.init = function() {
 *
 *   \/**
 *    * Return `true`, `false` or nothing to denote
 *    * _allowed_, _not allowed_ and _continue evaluating_.
 *    *\/
 *   this.addRule('shape.resize', function(context) {
 *
 *     var shape = context.shape;
 *
 *     if (!context.newBounds) {
 *       // check general resizability
 *       if (!shape.resizable) {
 *         return false;
 *       }
 *
 *       // not returning anything (read: undefined)
 *       // will continue the evaluation of other rules
 *       // (with lower priority)
 *       return;
 *     } else {
 *       // element must have minimum size of 10*10 points
 *       return context.newBounds.width > 10 && context.newBounds.height > 10;
 *     }
 *   });
 * };
 *
 * @param {string|Array<string>} actions the identifier for the modeling action to check
 * @param {number} [priority] the priority at which this rule is being applied
 * @param {Function} fn the callback function that performs the actual check
 */
RuleProvider.prototype.addRule = function(actions, priority, fn) {

  var self = this;

  if (typeof actions === 'string') {
    actions = [ actions ];
  }

  actions.forEach(function(action) {

    self.canExecute(action, priority, function(context, action, event) {
      return fn(context);
    }, true);
  });
};

/**
 * Implement this method to add new rules during provider initialization.
 */
RuleProvider.prototype.init = function() {};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/rules/Rules.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/rules/Rules.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Rules)
/* harmony export */ });
/**
 * A service that provides rules for certain diagram actions.
 *
 * The default implementation will hook into the {@link CommandStack}
 * to perform the actual rule evaluation. Make sure to provide the
 * `commandStack` service with this module if you plan to use it.
 *
 * Together with this implementation you may use the {@link RuleProvider}
 * to implement your own rule checkers.
 *
 * This module is ment to be easily replaced, thus the tiny foot print.
 *
 * @param {Injector} injector
 */
function Rules(injector) {
  this._commandStack = injector.get('commandStack', false);
}

Rules.$inject = [ 'injector' ];


/**
 * Returns whether or not a given modeling action can be executed
 * in the specified context.
 *
 * This implementation will respond with allow unless anyone
 * objects.
 *
 * @param {string} action the action to be checked
 * @param {Object} [context] the context to check the action in
 *
 * @return {boolean} returns true, false or null depending on whether the
 *                   operation is allowed, not allowed or should be ignored.
 */
Rules.prototype.allowed = function(action, context) {
  var allowed = true;

  var commandStack = this._commandStack;

  if (commandStack) {
    allowed = commandStack.canExecute(action, context);
  }

  // map undefined to true, i.e. no rules
  return allowed === undefined ? true : allowed;
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/rules/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/rules/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Rules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rules */ "./node_modules/diagram-js/lib/features/rules/Rules.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'rules' ],
  rules: [ 'type', _Rules__WEBPACK_IMPORTED_MODULE_0__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/Selection.js":
/*!*********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/Selection.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Selection)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * A service that offers the current selection in a diagram.
 * Offers the api to control the selection, too.
 *
 * @class
 *
 * @param {EventBus} eventBus the event bus
 */
function Selection(eventBus) {

  this._eventBus = eventBus;

  this._selectedElements = [];

  var self = this;

  eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {
    var element = e.element;
    self.deselect(element);
  });

  eventBus.on([ 'diagram.clear' ], function(e) {
    self.select(null);
  });
}

Selection.$inject = [ 'eventBus' ];


Selection.prototype.deselect = function(element) {
  var selectedElements = this._selectedElements;

  var idx = selectedElements.indexOf(element);

  if (idx !== -1) {
    var oldSelection = selectedElements.slice();

    selectedElements.splice(idx, 1);

    this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });
  }
};


Selection.prototype.get = function() {
  return this._selectedElements;
};

Selection.prototype.isSelected = function(element) {
  return this._selectedElements.indexOf(element) !== -1;
};


/**
 * This method selects one or more elements on the diagram.
 *
 * By passing an additional add parameter you can decide whether or not the element(s)
 * should be added to the already existing selection or not.
 *
 * @method Selection#select
 *
 * @param  {Object|Object[]} elements element or array of elements to be selected
 * @param  {boolean} [add] whether the element(s) should be appended to the current selection, defaults to false
 */
Selection.prototype.select = function(elements, add) {
  var selectedElements = this._selectedElements,
      oldSelection = selectedElements.slice();

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements)) {
    elements = elements ? [ elements ] : [];
  }

  // selection may be cleared by passing an empty array or null
  // to the method
  if (add) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {
      if (selectedElements.indexOf(element) !== -1) {

        // already selected
        return;
      } else {
        selectedElements.push(element);
      }
    });
  } else {
    this._selectedElements = selectedElements = elements.slice();
  }

  this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/SelectionBehavior.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/SelectionBehavior.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectionBehavior)
/* harmony export */ });
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");





function SelectionBehavior(eventBus, selection, canvas, elementRegistry) {

  // Select elements on create
  eventBus.on('create.end', 500, function(event) {
    var context = event.context,
        canExecute = context.canExecute,
        elements = context.elements,
        hints = context.hints || {},
        autoSelect = hints.autoSelect;

    if (canExecute) {
      if (autoSelect === false) {

        // Select no elements
        return;
      }

      if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(autoSelect)) {
        selection.select(autoSelect);
      } else {

        // Select all elements by default
        selection.select(elements.filter(isShown));
      }
    }
  });

  // Select connection targets on connect
  eventBus.on('connect.end', 500, function(event) {
    var context = event.context,
        canExecute = context.canExecute,
        hover = context.hover;

    if (canExecute && hover) {
      selection.select(hover);
    }
  });

  // Select shapes on move
  eventBus.on('shape.move.end', 500, function(event) {
    var previousSelection = event.previousSelection || [];

    var shape = elementRegistry.get(event.context.shape.id);

    // Always select main shape on move
    var isSelected = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(previousSelection, function(selectedShape) {
      return shape.id === selectedShape.id;
    });

    if (!isSelected) {
      selection.select(shape);
    }
  });

  // Select elements on click
  eventBus.on('element.click', function(event) {

    if (!(0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.isPrimaryButton)(event)) {
      return;
    }

    var element = event.element;

    if (element === canvas.getRootElement()) {
      element = null;
    }

    var isSelected = selection.isSelected(element),
        isMultiSelect = selection.get().length > 1;

    // Add to selection if CTRL or SHIFT pressed
    var add = (0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.hasPrimaryModifier)(event) || (0,_util_Mouse__WEBPACK_IMPORTED_MODULE_1__.hasSecondaryModifier)(event);

    if (isSelected && isMultiSelect) {
      if (add) {

        // Deselect element
        return selection.deselect(element);
      } else {

        // Select element only
        return selection.select(element);
      }
    } else if (!isSelected) {

      // Select element
      selection.select(element, add);
    } else {

      // Deselect element
      selection.deselect(element);
    }
  });
}

SelectionBehavior.$inject = [
  'eventBus',
  'selection',
  'canvas',
  'elementRegistry'
];


function isShown(element) {
  return !element.hidden;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/SelectionVisuals.js":
/*!****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/SelectionVisuals.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectionVisuals)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


var MARKER_HOVER = 'hover',
    MARKER_SELECTED = 'selected';


/**
 * A plugin that adds a visible selection UI to shapes and connections
 * by appending the <code>hover</code> and <code>selected</code> classes to them.
 *
 * @class
 *
 * Makes elements selectable, too.
 *
 * @param {EventBus} events
 * @param {SelectionService} selection
 * @param {Canvas} canvas
 */
function SelectionVisuals(events, canvas, selection, styles) {

  this._multiSelectionBox = null;

  function addMarker(e, cls) {
    canvas.addMarker(e, cls);
  }

  function removeMarker(e, cls) {
    canvas.removeMarker(e, cls);
  }

  events.on('element.hover', function(event) {
    addMarker(event.element, MARKER_HOVER);
  });

  events.on('element.out', function(event) {
    removeMarker(event.element, MARKER_HOVER);
  });

  events.on('selection.changed', function(event) {

    function deselect(s) {
      removeMarker(s, MARKER_SELECTED);
    }

    function select(s) {
      addMarker(s, MARKER_SELECTED);
    }

    var oldSelection = event.oldSelection,
        newSelection = event.newSelection;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(oldSelection, function(e) {
      if (newSelection.indexOf(e) === -1) {
        deselect(e);
      }
    });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(newSelection, function(e) {
      if (oldSelection.indexOf(e) === -1) {
        select(e);
      }
    });
  });
}

SelectionVisuals.$inject = [
  'eventBus',
  'canvas',
  'selection',
  'styles'
];

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/selection/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/selection/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interaction_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interaction-events */ "./node_modules/diagram-js/lib/features/interaction-events/index.js");
/* harmony import */ var _outline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../outline */ "./node_modules/diagram-js/lib/features/outline/index.js");
/* harmony import */ var _Selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Selection */ "./node_modules/diagram-js/lib/features/selection/Selection.js");
/* harmony import */ var _SelectionVisuals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SelectionVisuals */ "./node_modules/diagram-js/lib/features/selection/SelectionVisuals.js");
/* harmony import */ var _SelectionBehavior__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SelectionBehavior */ "./node_modules/diagram-js/lib/features/selection/SelectionBehavior.js");








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'selectionVisuals', 'selectionBehavior' ],
  __depends__: [
    _interaction_events__WEBPACK_IMPORTED_MODULE_0__.default,
    _outline__WEBPACK_IMPORTED_MODULE_1__.default
  ],
  selection: [ 'type', _Selection__WEBPACK_IMPORTED_MODULE_2__.default ],
  selectionVisuals: [ 'type', _SelectionVisuals__WEBPACK_IMPORTED_MODULE_3__.default ],
  selectionBehavior: [ 'type', _SelectionBehavior__WEBPACK_IMPORTED_MODULE_4__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/CreateMoveSnapping.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/CreateMoveSnapping.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CreateMoveSnapping)
/* harmony export */ });
/* harmony import */ var _SnapContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SnapContext */ "./node_modules/diagram-js/lib/features/snapping/SnapContext.js");
/* harmony import */ var _SnapUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SnapUtil */ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js");
/* harmony import */ var _keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../keyboard/KeyboardUtil */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");








var HIGHER_PRIORITY = 1250;


/**
 * Snap during create and move.
 *
 * @param {EventBus} elementRegistry
 * @param {EventBus} eventBus
 * @param {Snapping} snapping
 */
function CreateMoveSnapping(elementRegistry, eventBus, snapping) {
  var self = this;

  this._elementRegistry = elementRegistry;

  eventBus.on([
    'create.start',
    'shape.move.start'
  ], function(event) {
    self.initSnap(event);
  });

  eventBus.on([
    'create.move',
    'create.end',
    'shape.move.move',
    'shape.move.end'
  ], HIGHER_PRIORITY, function(event) {
    var context = event.context,
        shape = context.shape,
        snapContext = context.snapContext,
        target = context.target;

    if (event.originalEvent && (0,_keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event.originalEvent)) {
      return;
    }

    if ((0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.isSnapped)(event) || !target) {
      return;
    }

    var snapPoints = snapContext.pointsForTarget(target);

    if (!snapPoints.initialized) {
      snapPoints = self.addSnapTargetPoints(snapPoints, shape, target);

      snapPoints.initialized = true;
    }

    snapping.snap(event, snapPoints);
  });

  eventBus.on([
    'create.cleanup',
    'shape.move.cleanup'
  ], function() {
    snapping.hide();
  });
}

CreateMoveSnapping.$inject = [
  'elementRegistry',
  'eventBus',
  'snapping'
];

CreateMoveSnapping.prototype.initSnap = function(event) {
  var elementRegistry = this._elementRegistry;

  var context = event.context,
      shape = context.shape,
      snapContext = context.snapContext;

  if (!snapContext) {
    snapContext = context.snapContext = new _SnapContext__WEBPACK_IMPORTED_MODULE_2__.default();
  }

  var shapeMid;

  if (elementRegistry.get(shape.id)) {

    // move
    shapeMid = (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(shape, event);
  } else {

    // create
    shapeMid = {
      x: event.x + (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(shape).x,
      y: event.y + (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(shape).y
    };
  }

  var shapeTopLeft = {
        x: shapeMid.x - shape.width / 2,
        y: shapeMid.y - shape.height / 2
      },
      shapeBottomRight = {
        x: shapeMid.x + shape.width / 2,
        y: shapeMid.y + shape.height / 2
      };

  snapContext.setSnapOrigin('mid', {
    x: shapeMid.x - event.x,
    y: shapeMid.y - event.y
  });

  // snap labels to mid only
  if (isLabel(shape)) {
    return snapContext;
  }

  snapContext.setSnapOrigin('top-left', {
    x: shapeTopLeft.x - event.x,
    y: shapeTopLeft.y - event.y
  });

  snapContext.setSnapOrigin('bottom-right', {
    x: shapeBottomRight.x - event.x,
    y: shapeBottomRight.y - event.y
  });

  return snapContext;
};

CreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  var snapTargets = this.getSnapTargets(shape, target);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(snapTargets, function(snapTarget) {

    // handle labels
    if (isLabel(snapTarget)) {

      if (isLabel(shape)) {
        snapPoints.add('mid', (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(snapTarget));
      }

      return;
    }

    // handle connections
    if (isConnection(snapTarget)) {

      // ignore single segment connections
      if (snapTarget.waypoints.length < 3) {
        return;
      }

      // ignore first and last waypoint
      var waypoints = snapTarget.waypoints.slice(1, -1);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(waypoints, function(waypoint) {
        snapPoints.add('mid', waypoint);
      });

      return;
    }

    // handle shapes
    snapPoints.add('mid', (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(snapTarget));
  });

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(shape.x) || !(0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(shape.y)) {
    return snapPoints;
  }

  // snap to original position when moving
  if (this._elementRegistry.get(shape.id)) {
    snapPoints.add('mid', (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.mid)(shape));
  }

  return snapPoints;
};

CreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.getChildren)(target).filter(function(child) {
    return !isHidden(child);
  });
};

// helpers //////////

function isConnection(element) {
  return !!element.waypoints;
}

function isHidden(element) {
  return !!element.hidden;
}

function isLabel(element) {
  return !!element.labelTarget;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/ResizeSnapping.js":
/*!*************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/ResizeSnapping.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResizeSnapping)
/* harmony export */ });
/* harmony import */ var _SnapContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SnapContext */ "./node_modules/diagram-js/lib/features/snapping/SnapContext.js");
/* harmony import */ var _SnapUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SnapUtil */ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js");
/* harmony import */ var _keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../keyboard/KeyboardUtil */ "./node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");










var HIGHER_PRIORITY = 1250;


/**
 * Snap during resize.
 *
 * @param {EventBus} eventBus
 * @param {Snapping} snapping
 */
function ResizeSnapping(eventBus, snapping) {
  var self = this;

  eventBus.on([ 'resize.start' ], function(event) {
    self.initSnap(event);
  });

  eventBus.on([
    'resize.move',
    'resize.end',
  ], HIGHER_PRIORITY, function(event) {
    var context = event.context,
        shape = context.shape,
        parent = shape.parent,
        direction = context.direction,
        snapContext = context.snapContext;

    if (event.originalEvent && (0,_keyboard_KeyboardUtil__WEBPACK_IMPORTED_MODULE_0__.isCmd)(event.originalEvent)) {
      return;
    }

    if ((0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.isSnapped)(event)) {
      return;
    }

    var snapPoints = snapContext.pointsForTarget(parent);

    if (!snapPoints.initialized) {
      snapPoints = self.addSnapTargetPoints(snapPoints, shape, parent, direction);

      snapPoints.initialized = true;
    }

    if (isHorizontal(direction)) {
      (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'x', event.x);
    }

    if (isVertical(direction)) {
      (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, 'y', event.y);
    }

    snapping.snap(event, snapPoints);
  });

  eventBus.on([ 'resize.cleanup' ], function() {
    snapping.hide();
  });
}

ResizeSnapping.prototype.initSnap = function(event) {
  var context = event.context,
      shape = context.shape,
      direction = context.direction,
      snapContext = context.snapContext;

  if (!snapContext) {
    snapContext = context.snapContext = new _SnapContext__WEBPACK_IMPORTED_MODULE_2__.default();
  }

  var snapOrigin = getSnapOrigin(shape, direction);

  snapContext.setSnapOrigin('corner', {
    x: snapOrigin.x - event.x,
    y: snapOrigin.y - event.y
  });

  return snapContext;
};

ResizeSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target, direction) {
  var snapTargets = this.getSnapTargets(shape, target);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(snapTargets, function(snapTarget) {
    snapPoints.add('corner', (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.bottomRight)(snapTarget));
    snapPoints.add('corner', (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.topLeft)(snapTarget));
  });

  snapPoints.add('corner', getSnapOrigin(shape, direction));

  return snapPoints;
};

ResizeSnapping.$inject = [
  'eventBus',
  'snapping'
];

ResizeSnapping.prototype.getSnapTargets = function(shape, target) {
  return (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.getChildren)(target).filter(function(child) {
    return !isAttached(child, shape)
      && !isConnection(child)
      && !isHidden(child)
      && !isLabel(child);
  });
};

// helpers //////////

function getSnapOrigin(shape, direction) {
  var mid = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_4__.getMid)(shape),
      trbl = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_4__.asTRBL)(shape);

  var snapOrigin = {
    x: mid.x,
    y: mid.y
  };

  if (direction.indexOf('n') !== -1) {
    snapOrigin.y = trbl.top;
  } else if (direction.indexOf('s') !== -1) {
    snapOrigin.y = trbl.bottom;
  }

  if (direction.indexOf('e') !== -1) {
    snapOrigin.x = trbl.right;
  } else if (direction.indexOf('w') !== -1) {
    snapOrigin.x = trbl.left;
  }

  return snapOrigin;
}

function isAttached(element, host) {
  return element.host === host;
}

function isConnection(element) {
  return !!element.waypoints;
}

function isHidden(element) {
  return !!element.hidden;
}

function isLabel(element) {
  return !!element.labelTarget;
}

function isHorizontal(direction) {
  return direction === 'n' || direction === 's';
}

function isVertical(direction) {
  return direction === 'e' || direction === 'w';
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/SnapContext.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/SnapContext.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SnapContext),
/* harmony export */   "SnapPoints": () => (/* binding */ SnapPoints)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _SnapUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SnapUtil */ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js");





/**
 * A snap context, containing the (possibly incomplete)
 * mappings of drop targets (to identify the snapping)
 * to computed snap points.
 */
function SnapContext() {

  /**
   * Map<String, SnapPoints> mapping drop targets to
   * a list of possible snappings.
   *
   * @type {Object}
   */
  this._targets = {};

  /**
   * Map<String, Point> initial positioning of element
   * regarding various snap directions.
   *
   * @type {Object}
   */
  this._snapOrigins = {};

  /**
   * List of snap locations
   *
   * @type {Array<string>}
   */
  this._snapLocations = [];

  /**
   * Map<String, Array<Point>> of default snapping locations
   *
   * @type {Object}
   */
  this._defaultSnaps = {};
}


SnapContext.prototype.getSnapOrigin = function(snapLocation) {
  return this._snapOrigins[snapLocation];
};


SnapContext.prototype.setSnapOrigin = function(snapLocation, initialValue) {
  this._snapOrigins[snapLocation] = initialValue;

  if (this._snapLocations.indexOf(snapLocation) === -1) {
    this._snapLocations.push(snapLocation);
  }
};


SnapContext.prototype.addDefaultSnap = function(type, point) {

  var snapValues = this._defaultSnaps[type];

  if (!snapValues) {
    snapValues = this._defaultSnaps[type] = [];
  }

  snapValues.push(point);
};

/**
 * Return a number of initialized snaps, i.e. snap locations such as
 * top-left, mid, bottom-right and so forth.
 *
 * @return {Array<string>} snapLocations
 */
SnapContext.prototype.getSnapLocations = function() {
  return this._snapLocations;
};

/**
 * Set the snap locations for this context.
 *
 * The order of locations determines precedence.
 *
 * @param {Array<string>} snapLocations
 */
SnapContext.prototype.setSnapLocations = function(snapLocations) {
  this._snapLocations = snapLocations;
};

/**
 * Get snap points for a given target
 *
 * @param {Element|string} target
 */
SnapContext.prototype.pointsForTarget = function(target) {

  var targetId = target.id || target;

  var snapPoints = this._targets[targetId];

  if (!snapPoints) {
    snapPoints = this._targets[targetId] = new SnapPoints();
    snapPoints.initDefaults(this._defaultSnaps);
  }

  return snapPoints;
};


/**
 * Creates the snap points and initializes them with the
 * given default values.
 *
 * @param {Object<string, Array<Point>>} [defaultPoints]
 */
function SnapPoints(defaultSnaps) {

  /**
   * Map<String, Map<(x|y), Array<number>>> mapping snap locations,
   * i.e. top-left, bottom-right, center to actual snap values.
   *
   * @type {Object}
   */
  this._snapValues = {};
}

SnapPoints.prototype.add = function(snapLocation, point) {

  var snapValues = this._snapValues[snapLocation];

  if (!snapValues) {
    snapValues = this._snapValues[snapLocation] = { x: [], y: [] };
  }

  if (snapValues.x.indexOf(point.x) === -1) {
    snapValues.x.push(point.x);
  }

  if (snapValues.y.indexOf(point.y) === -1) {
    snapValues.y.push(point.y);
  }
};


SnapPoints.prototype.snap = function(point, snapLocation, axis, tolerance) {
  var snappingValues = this._snapValues[snapLocation];

  return snappingValues && (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_0__.snapTo)(point[axis], snappingValues[axis], tolerance);
};

/**
 * Initialize a number of default snapping points.
 *
 * @param  {Object} defaultSnaps
 */
SnapPoints.prototype.initDefaults = function(defaultSnaps) {

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(defaultSnaps || {}, function(snapPoints, snapLocation) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(snapPoints, function(point) {
      self.add(snapLocation, point);
    });
  });
};

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/SnapUtil.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "snapTo": () => (/* binding */ snapTo),
/* harmony export */   "topLeft": () => (/* binding */ topLeft),
/* harmony export */   "topRight": () => (/* binding */ topRight),
/* harmony export */   "bottomLeft": () => (/* binding */ bottomLeft),
/* harmony export */   "bottomRight": () => (/* binding */ bottomRight),
/* harmony export */   "mid": () => (/* binding */ mid),
/* harmony export */   "isSnapped": () => (/* binding */ isSnapped),
/* harmony export */   "setSnapped": () => (/* binding */ setSnapped),
/* harmony export */   "getChildren": () => (/* binding */ getChildren)
/* harmony export */ });
var abs = Math.abs,
    round = Math.round;


/**
 * Snap value to a collection of reference values.
 *
 * @param  {number} value
 * @param  {Array<number>} values
 * @param  {number} [tolerance=10]
 *
 * @return {number} the value we snapped to or null, if none snapped
 */
function snapTo(value, values, tolerance) {
  tolerance = tolerance === undefined ? 10 : tolerance;

  var idx, snapValue;

  for (idx = 0; idx < values.length; idx++) {
    snapValue = values[idx];

    if (abs(snapValue - value) <= tolerance) {
      return snapValue;
    }
  }
}


function topLeft(bounds) {
  return {
    x: bounds.x,
    y: bounds.y
  };
}

function topRight(bounds) {
  return {
    x: bounds.x + bounds.width,
    y: bounds.y
  };
}

function bottomLeft(bounds) {
  return {
    x: bounds.x,
    y: bounds.y + bounds.height
  };
}

function bottomRight(bounds) {
  return {
    x: bounds.x + bounds.width,
    y: bounds.y + bounds.height
  };
}

function mid(bounds, defaultValue) {

  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {
    return defaultValue;
  }

  return {
    x: round(bounds.x + bounds.width / 2),
    y: round(bounds.y + bounds.height / 2)
  };
}


/**
 * Retrieve the snap state of the given event.
 *
 * @param  {Event} event
 * @param  {string} axis
 *
 * @return {boolean} the snapped state
 *
 */
function isSnapped(event, axis) {
  var snapped = event.snapped;

  if (!snapped) {
    return false;
  }

  if (typeof axis === 'string') {
    return snapped[axis];
  }

  return snapped.x && snapped.y;
}


/**
 * Set the given event as snapped.
 *
 * This method may change the x and/or y position of the shape
 * from the given event!
 *
 * @param {Event} event
 * @param {string} axis
 * @param {number|boolean} value
 *
 * @return {number} old value
 */
function setSnapped(event, axis, value) {
  if (typeof axis !== 'string') {
    throw new Error('axis must be in [x, y]');
  }

  if (typeof value !== 'number' && value !== false) {
    throw new Error('value must be Number or false');
  }

  var delta,
      previousValue = event[axis];

  var snapped = event.snapped = (event.snapped || {});


  if (value === false) {
    snapped[axis] = false;
  } else {
    snapped[axis] = true;

    delta = value - previousValue;

    event[axis] += delta;
    event['d' + axis] += delta;
  }

  return previousValue;
}

/**
 * Get children of a shape.
 *
 * @param {djs.model.Shape} parent
 *
 * @returns {Array<djs.model.Shape|djs.model.Connection>}
 */
function getChildren(parent) {
  return parent.children || [];
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/Snapping.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/Snapping.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SNAP_LINE_HIDE_DELAY": () => (/* binding */ SNAP_LINE_HIDE_DELAY),
/* harmony export */   "default": () => (/* binding */ Snapping)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _SnapUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SnapUtil */ "./node_modules/diagram-js/lib/features/snapping/SnapUtil.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");






var SNAP_TOLERANCE = 7;

var SNAP_LINE_HIDE_DELAY = 1000;


/**
 * Generic snapping feature.
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function Snapping(canvas) {
  this._canvas = canvas;

  // delay hide by 1000 seconds since last snap
  this._asyncHide = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.debounce)((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(this.hide, this), SNAP_LINE_HIDE_DELAY);
}

Snapping.$inject = [ 'canvas' ];

/**
 * Snap an event to given snap points.
 *
 * @param {Event} event
 * @param {SnapPoints} snapPoints
 */
Snapping.prototype.snap = function(event, snapPoints) {
  var context = event.context,
      snapContext = context.snapContext,
      snapLocations = snapContext.getSnapLocations();

  var snapping = {
    x: (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.isSnapped)(event, 'x'),
    y: (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.isSnapped)(event, 'y')
  };

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(snapLocations, function(location) {
    var snapOrigin = snapContext.getSnapOrigin(location);

    var snapCurrent = {
      x: event.x + snapOrigin.x,
      y: event.y + snapOrigin.y
    };

    // snap both axis if not snapped already
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)([ 'x', 'y' ], function(axis) {
      var locationSnapping;

      if (!snapping[axis]) {
        locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);

        if (locationSnapping !== undefined) {
          snapping[axis] = {
            value: locationSnapping,
            originValue: locationSnapping - snapOrigin[axis]
          };
        }
      }
    });

    // no need to continue snapping
    if (snapping.x && snapping.y) {
      return false;
    }
  });

  // show snap lines
  this.showSnapLine('vertical', snapping.x && snapping.x.value);
  this.showSnapLine('horizontal', snapping.y && snapping.y.value);

  // snap event
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)([ 'x', 'y' ], function(axis) {
    var axisSnapping = snapping[axis];

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(axisSnapping)) {
      (0,_SnapUtil__WEBPACK_IMPORTED_MODULE_1__.setSnapped)(event, axis, axisSnapping.originValue);
    }
  });
};

Snapping.prototype._createLine = function(orientation) {
  var root = this._canvas.getLayer('snap');

  var line = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.create)('path');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(line, { d: 'M0,0 L0,0' });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.classes)(line).add('djs-snap-line');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.append)(root, line);

  return {
    update: function(position) {

      if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(position)) {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(line, { display: 'none' });
      } else {
        if (orientation === 'horizontal') {
          (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(line, {
            d: 'M-100000,' + position + ' L+100000,' + position,
            display: ''
          });
        } else {
          (0,tiny_svg__WEBPACK_IMPORTED_MODULE_2__.attr)(line, {
            d: 'M ' + position + ',-100000 L ' + position + ', +100000',
            display: ''
          });
        }
      }
    }
  };
};

Snapping.prototype._createSnapLines = function() {
  this._snapLines = {
    horizontal: this._createLine('horizontal'),
    vertical: this._createLine('vertical')
  };
};

Snapping.prototype.showSnapLine = function(orientation, position) {

  var line = this.getSnapLine(orientation);

  if (line) {
    line.update(position);
  }

  this._asyncHide();
};

Snapping.prototype.getSnapLine = function(orientation) {
  if (!this._snapLines) {
    this._createSnapLines();
  }

  return this._snapLines[orientation];
};

Snapping.prototype.hide = function() {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(this._snapLines, function(snapLine) {
    snapLine.update();
  });
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/snapping/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/snapping/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreateMoveSnapping */ "./node_modules/diagram-js/lib/features/snapping/CreateMoveSnapping.js");
/* harmony import */ var _ResizeSnapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResizeSnapping */ "./node_modules/diagram-js/lib/features/snapping/ResizeSnapping.js");
/* harmony import */ var _Snapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Snapping */ "./node_modules/diagram-js/lib/features/snapping/Snapping.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [
    'createMoveSnapping',
    'resizeSnapping',
    'snapping'
  ],
  createMoveSnapping: [ 'type', _CreateMoveSnapping__WEBPACK_IMPORTED_MODULE_0__.default ],
  resizeSnapping: [ 'type', _ResizeSnapping__WEBPACK_IMPORTED_MODULE_1__.default ],
  snapping: [ 'type', _Snapping__WEBPACK_IMPORTED_MODULE_2__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/space-tool/SpaceTool.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/space-tool/SpaceTool.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpaceTool)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var _util_Elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Elements */ "./node_modules/diagram-js/lib/util/Elements.js");
/* harmony import */ var _SpaceUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SpaceUtil */ "./node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js");
/* harmony import */ var _util_Mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Mouse */ "./node_modules/diagram-js/lib/util/Mouse.js");
/* harmony import */ var _util_Cursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Cursor */ "./node_modules/diagram-js/lib/util/Cursor.js");














var abs = Math.abs,
    round = Math.round;

var AXIS_TO_DIMENSION = {
  x: 'width',
  y: 'height'
};

var CURSOR_CROSSHAIR = 'crosshair';

var DIRECTION_TO_TRBL = {
  n: 'top',
  w: 'left',
  s: 'bottom',
  e: 'right'
};

var HIGH_PRIORITY = 1500;

var DIRECTION_TO_OPPOSITE = {
  n: 's',
  w: 'e',
  s: 'n',
  e: 'w'
};

var PADDING = 20;


/**
 * Add or remove space by moving and resizing elements.
 *
 * @param {Canvas} canvas
 * @param {Dragging} dragging
 * @param {EventBus} eventBus
 * @param {Modeling} modeling
 * @param {Rules} rules
 * @param {ToolManager} toolManager
 * @param {Mouse} mouse
 */
function SpaceTool(
    canvas, dragging, eventBus,
    modeling, rules, toolManager,
    mouse) {

  this._canvas = canvas;
  this._dragging = dragging;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._rules = rules;
  this._toolManager = toolManager;
  this._mouse = mouse;

  var self = this;

  toolManager.registerTool('space', {
    tool: 'spaceTool.selection',
    dragging: 'spaceTool'
  });

  eventBus.on('spaceTool.selection.end', function(event) {
    eventBus.once('spaceTool.selection.ended', function() {
      self.activateMakeSpace(event.originalEvent);
    });
  });

  eventBus.on('spaceTool.move', HIGH_PRIORITY , function(event) {
    var context = event.context,
        initialized = context.initialized;

    if (!initialized) {
      initialized = context.initialized = self.init(event, context);
    }

    if (initialized) {
      ensureConstraints(event);
    }
  });

  eventBus.on('spaceTool.end', function(event) {
    var context = event.context,
        axis = context.axis,
        direction = context.direction,
        movingShapes = context.movingShapes,
        resizingShapes = context.resizingShapes,
        start = context.start;

    if (!context.initialized) {
      return;
    }

    ensureConstraints(event);

    var delta = {
      x: 0,
      y: 0
    };

    delta[ axis ] = round(event[ 'd' + axis ]);

    self.makeSpace(movingShapes, resizingShapes, delta, direction, start);

    eventBus.once('spaceTool.ended', function(event) {

      // activate space tool selection after make space
      self.activateSelection(event.originalEvent, true, true);
    });
  });
}

SpaceTool.$inject = [
  'canvas',
  'dragging',
  'eventBus',
  'modeling',
  'rules',
  'toolManager',
  'mouse'
];

/**
 * Activate space tool selection.
 *
 * @param {Object} event
 * @param {boolean} autoActivate
 */
SpaceTool.prototype.activateSelection = function(event, autoActivate, reactivate) {
  this._dragging.init(event, 'spaceTool.selection', {
    autoActivate: autoActivate,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {
        reactivate: reactivate
      }
    },
    trapClick: false
  });
};

/**
 * Activate space tool make space.
 *
 * @param  {MouseEvent} event
 */
SpaceTool.prototype.activateMakeSpace = function(event) {
  this._dragging.init(event, 'spaceTool', {
    autoActivate: true,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {}
    }
  });
};

/**
 * Make space.
 *
 * @param  {Array<djs.model.Shape>} movingShapes
 * @param  {Array<djs.model.Shape>} resizingShapes
 * @param  {Object} delta
 * @param  {number} delta.x
 * @param  {number} delta.y
 * @param  {string} direction
 * @param  {number} start
 */
SpaceTool.prototype.makeSpace = function(movingShapes, resizingShapes, delta, direction, start) {
  return this._modeling.createSpace(movingShapes, resizingShapes, delta, direction, start);
};

/**
 * Initialize make space and return true if that was successful.
 *
 * @param {Object} event
 * @param {Object} context
 *
 * @return {boolean}
 */
SpaceTool.prototype.init = function(event, context) {
  var axis = abs(event.dx) > abs(event.dy) ? 'x' : 'y',
      delta = event[ 'd' + axis ],
      start = event[ axis ] - delta;

  if (abs(delta) < 5) {
    return false;
  }

  // invert delta to remove space when moving left
  if (delta < 0) {
    delta *= -1;
  }

  // invert delta to add/remove space when removing/adding space if modifier key is pressed
  if ((0,_util_Mouse__WEBPACK_IMPORTED_MODULE_0__.hasPrimaryModifier)(event)) {
    delta *= -1;
  }

  var direction = (0,_SpaceUtil__WEBPACK_IMPORTED_MODULE_1__.getDirection)(axis, delta);

  var root = this._canvas.getRootElement();

  var children = (0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.selfAndAllChildren)(root, true);

  var elements = this.calculateAdjustments(children, axis, delta, start);

  var minDimensions = this._eventBus.fire('spaceTool.getMinDimensions', {
    axis: axis,
    direction: direction,
    shapes: elements.resizingShapes,
    start: start
  });

  var spaceToolConstraints = getSpaceToolConstraints(elements, axis, direction, start, minDimensions);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.assign)(
    context,
    elements,
    {
      axis: axis,
      direction: direction,
      spaceToolConstraints: spaceToolConstraints,
      start: start
    }
  );

  (0,_util_Cursor__WEBPACK_IMPORTED_MODULE_4__.set)('resize-' + (axis === 'x' ? 'ew' : 'ns'));

  return true;
};

/**
 * Get elements to be moved and resized.
 *
 * @param  {Array<djs.model.Shape>} elements
 * @param  {string} axis
 * @param  {number} delta
 * @param  {number} start
 *
 * @return {Object}
 */
SpaceTool.prototype.calculateAdjustments = function(elements, axis, delta, start) {
  var rules = this._rules;

  var movingShapes = [],
      resizingShapes = [];

  (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(elements, function(element) {
    if (!element.parent || isConnection(element)) {
      return;
    }

    var shapeStart = element[ axis ],
        shapeEnd = shapeStart + element[ AXIS_TO_DIMENSION[ axis ] ];

    // shape to be moved
    if ((delta > 0 && shapeStart > start) || (delta < 0 && shapeEnd < start)) {
      return movingShapes.push(element);
    }

    // shape to be resized
    if (shapeStart < start &&
      shapeEnd > start &&
      rules.allowed('shape.resize', { shape: element })
    ) {

      return resizingShapes.push(element);
    }
  });

  return {
    movingShapes: movingShapes,
    resizingShapes: resizingShapes
  };
};

SpaceTool.prototype.toggle = function() {

  if (this.isActive()) {
    return this._dragging.cancel();
  }

  var mouseEvent = this._mouse.getLastMoveEvent();

  this.activateSelection(mouseEvent, !!mouseEvent);
};

SpaceTool.prototype.isActive = function() {
  var context = this._dragging.context();

  return context && /^spaceTool/.test(context.prefix);
};

// helpers //////////

function addPadding(trbl) {
  return {
    top: trbl.top - PADDING,
    right: trbl.right + PADDING,
    bottom: trbl.bottom + PADDING,
    left: trbl.left - PADDING
  };
}

function ensureConstraints(event) {
  var context = event.context,
      spaceToolConstraints = context.spaceToolConstraints;

  if (!spaceToolConstraints) {
    return;
  }

  var x, y;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(spaceToolConstraints.left)) {
    x = Math.max(event.x, spaceToolConstraints.left);

    event.dx = event.dx + x - event.x;
    event.x = x;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(spaceToolConstraints.right)) {
    x = Math.min(event.x, spaceToolConstraints.right);

    event.dx = event.dx + x - event.x;
    event.x = x;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(spaceToolConstraints.top)) {
    y = Math.max(event.y, spaceToolConstraints.top);

    event.dy = event.dy + y - event.y;
    event.y = y;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(spaceToolConstraints.bottom)) {
    y = Math.min(event.y, spaceToolConstraints.bottom);

    event.dy = event.dy + y - event.y;
    event.y = y;
  }
}

function getSpaceToolConstraints(elements, axis, direction, start, minDimensions) {
  var movingShapes = elements.movingShapes,
      resizingShapes = elements.resizingShapes;

  if (!resizingShapes.length) {
    return;
  }

  var spaceToolConstraints = {},
      min,
      max;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.forEach)(resizingShapes, function(resizingShape) {
    var resizingShapeBBox = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_5__.asTRBL)(resizingShape);

    // find children that are not moving or resizing
    var nonMovingResizingChildren = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.filter)(resizingShape.children, function(child) {
      return !isConnection(child) &&
        !isLabel(child) &&
        !includes(movingShapes, child) &&
        !includes(resizingShapes, child);
    });

    // find children that are moving
    var movingChildren = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.filter)(resizingShape.children, function(child) {
      return !isConnection(child) && !isLabel(child) && includes(movingShapes, child);
    });

    var minOrMax,
        nonMovingResizingChildrenBBox,
        movingChildrenBBox;

    if (nonMovingResizingChildren.length) {
      nonMovingResizingChildrenBBox = addPadding((0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_5__.asTRBL)((0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getBBox)(nonMovingResizingChildren)));

      minOrMax = start -
        resizingShapeBBox[ DIRECTION_TO_TRBL[ direction ] ] +
        nonMovingResizingChildrenBBox[ DIRECTION_TO_TRBL[ direction ] ];

      if (direction === 'n') {
        spaceToolConstraints.bottom = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 'w') {
        spaceToolConstraints.right = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 's') {
        spaceToolConstraints.top = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      } else if (direction === 'e') {
        spaceToolConstraints.left = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      }
    }

    if (movingChildren.length) {
      movingChildrenBBox = addPadding((0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_5__.asTRBL)((0,_util_Elements__WEBPACK_IMPORTED_MODULE_2__.getBBox)(movingChildren)));

      minOrMax = start -
        movingChildrenBBox[ DIRECTION_TO_TRBL[ DIRECTION_TO_OPPOSITE[ direction ] ] ] +
        resizingShapeBBox[ DIRECTION_TO_TRBL[ DIRECTION_TO_OPPOSITE[ direction ] ] ];

      if (direction === 'n') {
        spaceToolConstraints.bottom = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 'w') {
        spaceToolConstraints.right = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 's') {
        spaceToolConstraints.top = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      } else if (direction === 'e') {
        spaceToolConstraints.left = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      }
    }

    var resizingShapeMinDimensions = minDimensions && minDimensions[ resizingShape.id ];

    if (resizingShapeMinDimensions) {
      if (direction === 'n') {
        minOrMax = start +
          resizingShape[ AXIS_TO_DIMENSION [ axis ] ] -
          resizingShapeMinDimensions[ AXIS_TO_DIMENSION[ axis ] ];

        spaceToolConstraints.bottom = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 'w') {
        minOrMax = start +
          resizingShape[ AXIS_TO_DIMENSION [ axis ] ] -
          resizingShapeMinDimensions[ AXIS_TO_DIMENSION[ axis ] ];

        spaceToolConstraints.right = max = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(max) ? Math.min(max, minOrMax) : minOrMax;
      } else if (direction === 's') {
        minOrMax = start -
          resizingShape[ AXIS_TO_DIMENSION [ axis ] ] +
          resizingShapeMinDimensions[ AXIS_TO_DIMENSION[ axis ] ];

        spaceToolConstraints.top = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      } else if (direction === 'e') {
        minOrMax = start -
          resizingShape[ AXIS_TO_DIMENSION [ axis ] ] +
          resizingShapeMinDimensions[ AXIS_TO_DIMENSION[ axis ] ];

        spaceToolConstraints.left = min = (0,min_dash__WEBPACK_IMPORTED_MODULE_3__.isNumber)(min) ? Math.max(min, minOrMax) : minOrMax;
      }
    }
  });

  return spaceToolConstraints;
}

function includes(array, item) {
  return array.indexOf(item) !== -1;
}

function isConnection(element) {
  return !!element.waypoints;
}

function isLabel(element) {
  return !!element.labelTarget;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/space-tool/SpaceToolPreview.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/space-tool/SpaceToolPreview.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpaceToolPreview)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");
/* harmony import */ var _util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/SvgTransformUtil */ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js");


var MARKER_DRAGGING = 'djs-dragging',
    MARKER_RESIZING = 'djs-resizing';

var LOW_PRIORITY = 250;





var max = Math.max;


/**
 * Provides previews for selecting/moving/resizing shapes when creating/removing space.
 *
 * @param {EventBus} eventBus
 * @param {ElementRegistry} elementRegistry
 * @param {Canvas} canvas
 * @param {Styles} styles
 */
function SpaceToolPreview(
    eventBus, elementRegistry, canvas,
    styles, previewSupport) {

  function addPreviewGfx(collection, dragGroup) {
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(collection, function(element) {
      previewSupport.addDragger(element, dragGroup);

      canvas.addMarker(element, MARKER_DRAGGING);
    });
  }

  // add crosshair
  eventBus.on('spaceTool.selection.start', function(event) {
    var space = canvas.getLayer('space'),
        context = event.context;

    var orientation = {
      x: 'M 0,-10000 L 0,10000',
      y: 'M -10000,0 L 10000,0'
    };

    var crosshairGroup = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(crosshairGroup, styles.cls('djs-crosshair-group', [ 'no-events' ]));

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(space, crosshairGroup);

    // horizontal path
    var pathX = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('path');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(pathX, 'd', orientation.x);
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(pathX).add('djs-crosshair');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(crosshairGroup, pathX);

    // vertical path
    var pathY = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('path');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(pathY, 'd', orientation.y);
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(pathY).add('djs-crosshair');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(crosshairGroup, pathY);

    context.crosshairGroup = crosshairGroup;
  });

  // update crosshair
  eventBus.on('spaceTool.selection.move', function(event) {
    var crosshairGroup = event.context.crosshairGroup;

    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__.translate)(crosshairGroup, event.x, event.y);
  });

  // remove crosshair
  eventBus.on('spaceTool.selection.cleanup', function(event) {
    var context = event.context,
        crosshairGroup = context.crosshairGroup;

    if (crosshairGroup) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(crosshairGroup);
    }
  });

  // add and update move/resize previews
  eventBus.on('spaceTool.move', LOW_PRIORITY, function(event) {

    var context = event.context,
        line = context.line,
        axis = context.axis,
        movingShapes = context.movingShapes,
        resizingShapes = context.resizingShapes;

    if (!context.initialized) {
      return;
    }

    if (!context.dragGroup) {
      var spaceLayer = canvas.getLayer('space');

      line = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('path');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(line, 'd', 'M0,0 L0,0');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.classes)(line).add('djs-crosshair');

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(spaceLayer, line);

      context.line = line;

      var dragGroup = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(dragGroup, styles.cls('djs-drag-group', [ 'no-events' ]));

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(canvas.getDefaultLayer(), dragGroup);

      // shapes
      addPreviewGfx(movingShapes, dragGroup);

      // connections
      var movingConnections = context.movingConnections = elementRegistry.filter(function(element) {
        var sourceIsMoving = false;

        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(movingShapes, function(shape) {
          (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsMoving = true;
            }
          });
        });

        var targetIsMoving = false;

        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(movingShapes, function(shape) {
          (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsMoving = true;
            }
          });
        });

        var sourceIsResizing = false;

        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(resizingShapes, function(shape) {
          (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsResizing = true;
            }
          });
        });

        var targetIsResizing = false;

        (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(resizingShapes, function(shape) {
          (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsResizing = true;
            }
          });
        });

        return isConnection(element)
          && (sourceIsMoving || sourceIsResizing)
          && (targetIsMoving || targetIsResizing);
      });


      addPreviewGfx(movingConnections, dragGroup);

      context.dragGroup = dragGroup;
    }

    if (!context.frameGroup) {
      var frameGroup = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('g');
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(frameGroup, styles.cls('djs-frame-group', [ 'no-events' ]));

      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(canvas.getDefaultLayer(), frameGroup);

      var frames = [];

      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(resizingShapes, function(shape) {
        var frame = previewSupport.addFrame(shape, frameGroup);

        var initialBounds = frame.getBBox();

        frames.push({
          element: frame,
          initialBounds: initialBounds
        });

        canvas.addMarker(shape, MARKER_RESIZING);
      });

      context.frameGroup = frameGroup;
      context.frames = frames;
    }

    var orientation = {
      x: 'M' + event.x + ', -10000 L' + event.x + ', 10000',
      y: 'M -10000, ' + event.y + ' L 10000, ' + event.y
    };

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(line, { d: orientation[ axis ] });

    var opposite = { x: 'y', y: 'x' };
    var delta = { x: event.dx, y: event.dy };
    delta[ opposite[ context.axis ] ] = 0;

    // update move previews
    (0,_util_SvgTransformUtil__WEBPACK_IMPORTED_MODULE_2__.translate)(context.dragGroup, delta.x, delta.y);

    // update resize previews
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(context.frames, function(frame) {
      var element = frame.element,
          initialBounds = frame.initialBounds,
          width,
          height;

      if (context.direction === 'e') {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(element, {
          width: max(initialBounds.width + delta.x, 5)
        });
      } else {
        width = max(initialBounds.width - delta.x, 5);

        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(element, {
          width: width,
          x: initialBounds.x + initialBounds.width - width
        });
      }

      if (context.direction === 's') {
        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(element, {
          height: max(initialBounds.height + delta.y, 5)
        });
      } else {
        height = max(initialBounds.height - delta.y, 5);

        (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(element, {
          height: height,
          y: initialBounds.y + initialBounds.height - height
        });
      }
    });

  });

  // remove move/resize previews
  eventBus.on('spaceTool.cleanup', function(event) {

    var context = event.context,
        movingShapes = context.movingShapes,
        movingConnections = context.movingConnections,
        resizingShapes = context.resizingShapes,
        line = context.line,
        dragGroup = context.dragGroup,
        frameGroup = context.frameGroup;

    // moving shapes
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(movingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_DRAGGING);
    });

    // moving connections
    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(movingConnections, function(connection) {
      canvas.removeMarker(connection, MARKER_DRAGGING);
    });

    if (dragGroup) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(line);
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(dragGroup);
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(resizingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_RESIZING);
    });

    if (frameGroup) {
      (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(frameGroup);
    }
  });
}

SpaceToolPreview.$inject = [
  'eventBus',
  'elementRegistry',
  'canvas',
  'styles',
  'previewSupport'
];


// helpers //////////////////////

/**
 * Checks if an element is a connection.
 */
function isConnection(element) {
  return element.waypoints;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDirection": () => (/* binding */ getDirection),
/* harmony export */   "getWaypointsUpdatingConnections": () => (/* binding */ getWaypointsUpdatingConnections),
/* harmony export */   "resizeBounds": () => (/* binding */ resizeBounds)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * Return direction given axis and delta.
 *
 * @param {string} axis
 * @param {number} delta
 *
 * @return {string}
 */
function getDirection(axis, delta) {

  if (axis === 'x') {
    if (delta > 0) {
      return 'e';
    }

    if (delta < 0) {
      return 'w';
    }
  }

  if (axis === 'y') {
    if (delta > 0) {
      return 's';
    }

    if (delta < 0) {
      return 'n';
    }
  }

  return null;
}

/**
 * Returns connections whose waypoints are to be updated. Waypoints are to be updated if start
 * or end is to be moved or resized.
 *
 * @param {Array<djs.model.Shape} movingShapes
 * @param {Array<djs.model.Shape} resizingShapes
 *
 * @returns {Array<djs.model.Connection>}
 */
function getWaypointsUpdatingConnections(movingShapes, resizingShapes) {
  var waypointsUpdatingConnections = [];

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(movingShapes.concat(resizingShapes), function(shape) {
    var incoming = shape.incoming,
        outgoing = shape.outgoing;

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(incoming.concat(outgoing), function(connection) {
      var source = connection.source,
          target = connection.target;

      if (includes(movingShapes, source) ||
        includes(movingShapes, target) ||
        includes(resizingShapes, source) ||
        includes(resizingShapes, target)) {

        if (!includes(waypointsUpdatingConnections, connection)) {
          waypointsUpdatingConnections.push(connection);
        }
      }
    });
  });

  return waypointsUpdatingConnections;
}

function includes(array, item) {
  return array.indexOf(item) !== -1;
}

/**
 * Resize bounds.
 *
 * @param {Object} bounds
 * @param {number} bounds.x
 * @param {number} bounds.y
 * @param {number} bounds.width
 * @param {number} bounds.height
 * @param {string} direction
 * @param {Object} delta
 * @param {number} delta.x
 * @param {number} delta.y
 *
 * @return {Object}
 */
function resizeBounds(bounds, direction, delta) {
  var x = bounds.x,
      y = bounds.y,
      width = bounds.width,
      height = bounds.height,
      dx = delta.x,
      dy = delta.y;

  switch (direction) {
  case 'n':
    return {
      x: x,
      y: y + dy,
      width: width,
      height: height - dy
    };
  case 's':
    return {
      x: x,
      y: y,
      width: width,
      height: height + dy
    };
  case 'w':
    return {
      x: x + dx,
      y: y,
      width: width - dx,
      height: height
    };
  case 'e':
    return {
      x: x,
      y: y,
      width: width + dx,
      height: height
    };
  default:
    throw new Error('unknown direction: ' + direction);
  }
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/space-tool/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/space-tool/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules */ "./node_modules/diagram-js/lib/features/rules/index.js");
/* harmony import */ var _tool_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tool-manager */ "./node_modules/diagram-js/lib/features/tool-manager/index.js");
/* harmony import */ var _preview_support__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../preview-support */ "./node_modules/diagram-js/lib/features/preview-support/index.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mouse */ "./node_modules/diagram-js/lib/features/mouse/index.js");
/* harmony import */ var _SpaceTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SpaceTool */ "./node_modules/diagram-js/lib/features/space-tool/SpaceTool.js");
/* harmony import */ var _SpaceToolPreview__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SpaceToolPreview */ "./node_modules/diagram-js/lib/features/space-tool/SpaceToolPreview.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: ['spaceToolPreview'],
  __depends__: [
    _dragging__WEBPACK_IMPORTED_MODULE_0__.default,
    _rules__WEBPACK_IMPORTED_MODULE_1__.default,
    _tool_manager__WEBPACK_IMPORTED_MODULE_2__.default,
    _preview_support__WEBPACK_IMPORTED_MODULE_3__.default,
    _mouse__WEBPACK_IMPORTED_MODULE_4__.default
  ],
  spaceTool: ['type', _SpaceTool__WEBPACK_IMPORTED_MODULE_5__.default ],
  spaceToolPreview: ['type', _SpaceToolPreview__WEBPACK_IMPORTED_MODULE_6__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/tool-manager/ToolManager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/tool-manager/ToolManager.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ToolManager)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");




var LOW_PRIORITY = 250;

/**
 * The tool manager acts as middle-man between the available tool's and the Palette,
 * it takes care of making sure that the correct active state is set.
 *
 * @param  {Object}    eventBus
 * @param  {Object}    dragging
 */
function ToolManager(eventBus, dragging) {
  this._eventBus = eventBus;
  this._dragging = dragging;

  this._tools = [];
  this._active = null;
}

ToolManager.$inject = [ 'eventBus', 'dragging' ];

ToolManager.prototype.registerTool = function(name, events) {
  var tools = this._tools;

  if (!events) {
    throw new Error('A tool has to be registered with it\'s "events"');
  }

  tools.push(name);

  this.bindEvents(name, events);
};

ToolManager.prototype.isActive = function(tool) {
  return tool && this._active === tool;
};

ToolManager.prototype.length = function(tool) {
  return this._tools.length;
};

ToolManager.prototype.setActive = function(tool) {
  var eventBus = this._eventBus;

  if (this._active !== tool) {
    this._active = tool;

    eventBus.fire('tool-manager.update', { tool: tool });
  }
};

ToolManager.prototype.bindEvents = function(name, events) {
  var eventBus = this._eventBus,
      dragging = this._dragging;

  var eventsToRegister = [];

  eventBus.on(events.tool + '.init', function(event) {
    var context = event.context;

    // Active tools that want to reactivate themselves must do this explicitly
    if (!context.reactivate && this.isActive(name)) {
      this.setActive(null);

      dragging.cancel();
      return;
    }

    this.setActive(name);

  }, this);

  // Todo[ricardo]: add test cases
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(events, function(event) {
    eventsToRegister.push(event + '.ended');
    eventsToRegister.push(event + '.canceled');
  });

  eventBus.on(eventsToRegister, LOW_PRIORITY, function(event) {

    // We defer the de-activation of the tool to the .activate phase,
    // so we're able to check if we want to toggle off the current
    // active tool or switch to a new one
    if (!this._active) {
      return;
    }

    if (isPaletteClick(event)) {
      return;
    }

    this.setActive(null);
  }, this);

};


// helpers ///////////////

/**
 * Check if a given event is a palette click event.
 *
 * @param {EventBus.Event} event
 *
 * @return {boolean}
 */
function isPaletteClick(event) {
  var target = event.originalEvent && event.originalEvent.target;

  return target && (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.closest)(target, '.group[data-group="tools"]');
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/tool-manager/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/tool-manager/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dragging */ "./node_modules/diagram-js/lib/features/dragging/index.js");
/* harmony import */ var _ToolManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ToolManager */ "./node_modules/diagram-js/lib/features/tool-manager/ToolManager.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _dragging__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'toolManager' ],
  toolManager: [ 'type', _ToolManager__WEBPACK_IMPORTED_MODULE_1__.default ]
});


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/tooltips/Tooltips.js":
/*!*******************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/tooltips/Tooltips.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tooltips)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_IdGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/IdGenerator */ "./node_modules/diagram-js/lib/util/IdGenerator.js");






// document wide unique tooltip ids
var ids = new _util_IdGenerator__WEBPACK_IMPORTED_MODULE_0__.default('tt');


function createRoot(parentNode) {
  var root = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)(
    '<div class="djs-tooltip-container" style="position: absolute; width: 0; height: 0;" />'
  );

  parentNode.insertBefore(root, parentNode.firstChild);

  return root;
}


function setPosition(el, x, y) {
  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(el.style, { left: x + 'px', top: y + 'px' });
}

function setVisible(el, visible) {
  el.style.display = visible === false ? 'none' : '';
}


var tooltipClass = 'djs-tooltip',
    tooltipSelector = '.' + tooltipClass;

/**
 * A service that allows users to render tool tips on the diagram.
 *
 * The tooltip service will take care of updating the tooltip positioning
 * during navigation + zooming.
 *
 * @example
 *
 * ```javascript
 *
 * // add a pink badge on the top left of the shape
 * tooltips.add({
 *   position: {
 *     x: 50,
 *     y: 100
 *   },
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
 *
 * // or with optional life span
 * tooltips.add({
 *   position: {
 *     top: -5,
 *     left: -5
 *   },
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>',
 *   ttl: 2000
 * });
 *
 * // remove a tool tip
 * var id = tooltips.add(...);
 * tooltips.remove(id);
 * ```
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function Tooltips(eventBus, canvas) {

  this._eventBus = eventBus;
  this._canvas = canvas;

  this._ids = ids;

  this._tooltipDefaults = {
    show: {
      minZoom: 0.7,
      maxZoom: 5.0
    }
  };

  /**
   * Mapping tooltipId -> tooltip
   */
  this._tooltips = {};

  // root html element for all tooltips
  this._tooltipRoot = createRoot(canvas.getContainer());


  var self = this;

  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(this._tooltipRoot, tooltipSelector, 'mousedown', function(event) {
    event.stopPropagation();
  });

  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(this._tooltipRoot, tooltipSelector, 'mouseover', function(event) {
    self.trigger('mouseover', event);
  });

  min_dom__WEBPACK_IMPORTED_MODULE_1__.delegate.bind(this._tooltipRoot, tooltipSelector, 'mouseout', function(event) {
    self.trigger('mouseout', event);
  });

  this._init();
}


Tooltips.$inject = [ 'eventBus', 'canvas' ];


/**
 * Adds a HTML tooltip to the diagram
 *
 * @param {Object}               tooltip   the tooltip configuration
 *
 * @param {string|DOMElement}    tooltip.html                 html element to use as an tooltip
 * @param {Object}               [tooltip.show]               show configuration
 * @param {number}               [tooltip.show.minZoom]       minimal zoom level to show the tooltip
 * @param {number}               [tooltip.show.maxZoom]       maximum zoom level to show the tooltip
 * @param {Object}               tooltip.position             where to attach the tooltip
 * @param {number}               [tooltip.position.left]      relative to element bbox left attachment
 * @param {number}               [tooltip.position.top]       relative to element bbox top attachment
 * @param {number}               [tooltip.position.bottom]    relative to element bbox bottom attachment
 * @param {number}               [tooltip.position.right]     relative to element bbox right attachment
 * @param {number}               [tooltip.timeout=-1]
 *
 * @return {string}              id that may be used to reference the tooltip for update or removal
 */
Tooltips.prototype.add = function(tooltip) {

  if (!tooltip.position) {
    throw new Error('must specifiy tooltip position');
  }

  if (!tooltip.html) {
    throw new Error('must specifiy tooltip html');
  }

  var id = this._ids.next();

  tooltip = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, this._tooltipDefaults, tooltip, {
    id: id
  });

  this._addTooltip(tooltip);

  if (tooltip.timeout) {
    this.setTimeout(tooltip);
  }

  return id;
};

Tooltips.prototype.trigger = function(action, event) {

  var node = event.delegateTarget || event.target;

  var tooltip = this.get((0,min_dom__WEBPACK_IMPORTED_MODULE_1__.attr)(node, 'data-tooltip-id'));

  if (!tooltip) {
    return;
  }

  if (action === 'mouseover' && tooltip.timeout) {
    this.clearTimeout(tooltip);
  }

  if (action === 'mouseout' && tooltip.timeout) {

    // cut timeout after mouse out
    tooltip.timeout = 1000;

    this.setTimeout(tooltip);
  }
};

/**
 * Get a tooltip with the given id
 *
 * @param {string} id
 */
Tooltips.prototype.get = function(id) {

  if (typeof id !== 'string') {
    id = id.id;
  }

  return this._tooltips[id];
};

Tooltips.prototype.clearTimeout = function(tooltip) {

  tooltip = this.get(tooltip);

  if (!tooltip) {
    return;
  }

  var removeTimer = tooltip.removeTimer;

  if (removeTimer) {
    clearTimeout(removeTimer);
    tooltip.removeTimer = null;
  }
};

Tooltips.prototype.setTimeout = function(tooltip) {

  tooltip = this.get(tooltip);

  if (!tooltip) {
    return;
  }

  this.clearTimeout(tooltip);

  var self = this;

  tooltip.removeTimer = setTimeout(function() {
    self.remove(tooltip);
  }, tooltip.timeout);
};

/**
 * Remove an tooltip with the given id
 *
 * @param {string} id
 */
Tooltips.prototype.remove = function(id) {

  var tooltip = this.get(id);

  if (tooltip) {
    (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.remove)(tooltip.html);
    (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.remove)(tooltip.htmlContainer);

    delete tooltip.htmlContainer;

    delete this._tooltips[tooltip.id];
  }
};


Tooltips.prototype.show = function() {
  setVisible(this._tooltipRoot);
};


Tooltips.prototype.hide = function() {
  setVisible(this._tooltipRoot, false);
};


Tooltips.prototype._updateRoot = function(viewbox) {
  var a = viewbox.scale || 1;
  var d = viewbox.scale || 1;

  var matrix = 'matrix(' + a + ',0,0,' + d + ',' + (-1 * viewbox.x * a) + ',' + (-1 * viewbox.y * d) + ')';

  this._tooltipRoot.style.transform = matrix;
  this._tooltipRoot.style['-ms-transform'] = matrix;
};


Tooltips.prototype._addTooltip = function(tooltip) {

  var id = tooltip.id,
      html = tooltip.html,
      htmlContainer,
      tooltipRoot = this._tooltipRoot;

  // unwrap jquery (for those who need it)
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }

  // create proper html elements from
  // tooltip HTML strings
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(html)) {
    html = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)(html);
  }

  htmlContainer = (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.domify)('<div data-tooltip-id="' + id + '" class="' + tooltipClass + '" style="position: absolute">');

  htmlContainer.appendChild(html);

  if (tooltip.type) {
    (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(htmlContainer).add('djs-tooltip-' + tooltip.type);
  }

  if (tooltip.className) {
    (0,min_dom__WEBPACK_IMPORTED_MODULE_1__.classes)(htmlContainer).add(tooltip.className);
  }

  tooltip.htmlContainer = htmlContainer;

  tooltipRoot.appendChild(htmlContainer);

  this._tooltips[id] = tooltip;

  this._updateTooltip(tooltip);
};


Tooltips.prototype._updateTooltip = function(tooltip) {

  var position = tooltip.position,
      htmlContainer = tooltip.htmlContainer;

  // update overlay html based on tooltip x, y

  setPosition(htmlContainer, position.x, position.y);
};


Tooltips.prototype._updateTooltipVisibilty = function(viewbox) {

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(this._tooltips, function(tooltip) {
    var show = tooltip.show,
        htmlContainer = tooltip.htmlContainer,
        visible = true;

    if (show) {
      if (show.minZoom > viewbox.scale ||
          show.maxZoom < viewbox.scale) {
        visible = false;
      }

      setVisible(htmlContainer, visible);
    }
  });
};

Tooltips.prototype._init = function() {

  var self = this;

  // scroll/zoom integration

  function updateViewbox(viewbox) {
    self._updateRoot(viewbox);
    self._updateTooltipVisibilty(viewbox);

    self.show();
  }

  this._eventBus.on('canvas.viewbox.changing', function(event) {
    self.hide();
  });

  this._eventBus.on('canvas.viewbox.changed', function(event) {
    updateViewbox(event.viewbox);
  });
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/tooltips/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/tooltips/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Tooltips__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tooltips */ "./node_modules/diagram-js/lib/features/tooltips/Tooltips.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'tooltips' ],
  tooltips: [ 'type', _Tooltips__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/features/touch/TouchFix.js":
/*!****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/touch/TouchFix.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TouchFix)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");



function TouchFix(canvas, eventBus) {

  var self = this;

  eventBus.on('canvas.init', function(e) {
    self.addBBoxMarker(e.svg);
  });
}

TouchFix.$inject = [ 'canvas', 'eventBus' ];


/**
 * Safari mobile (iOS 7) does not fire touchstart event in <SVG> element
 * if there is no shape between 0,0 and viewport elements origin.
 *
 * So touchstart event is only fired when the <g class="viewport"> element was hit.
 * Putting an element over and below the 'viewport' fixes that behavior.
 */
TouchFix.prototype.addBBoxMarker = function(svg) {

  var markerStyle = {
    fill: 'none',
    class: 'outer-bound-marker'
  };

  var rect1 = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('rect');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(rect1, {
    x: -10000,
    y: 10000,
    width: 10,
    height: 10
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(rect1, markerStyle);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(svg, rect1);

  var rect2 = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('rect');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(rect2, {
    x: 10000,
    y: 10000,
    width: 10,
    height: 10
  });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(rect2, markerStyle);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.append)(svg, rect2);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/touch/TouchInteractionEvents.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/touch/TouchInteractionEvents.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TouchInteractionEvents)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hammerjs */ "./node_modules/hammerjs/hammer.js");
/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hammerjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");








var MIN_ZOOM = 0.2,
    MAX_ZOOM = 4;

var mouseEvents = [
  'mousedown',
  'mouseup',
  'mouseover',
  'mouseout',
  'click',
  'dblclick'
];

function log() {

  // console.log.apply(console, arguments);
}

function get(service, injector) {
  return injector.get(service, false);
}

function stopEvent(event) {

  event.preventDefault();

  if (typeof event.stopPropagation === 'function') {
    event.stopPropagation();
  } else if (event.srcEvent && typeof event.srcEvent.stopPropagation === 'function') {

    // iPhone & iPad
    event.srcEvent.stopPropagation();
  }

  if (typeof event.stopImmediatePropagation === 'function') {
    event.stopImmediatePropagation();
  }
}


function createTouchRecognizer(node) {

  function stopMouse(event) {

    (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(mouseEvents, function(e) {
      min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(node, e, stopEvent, true);
    });
  }

  function allowMouse(event) {
    setTimeout(function() {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.forEach)(mouseEvents, function(e) {
        min_dom__WEBPACK_IMPORTED_MODULE_2__.event.unbind(node, e, stopEvent, true);
      });
    }, 500);
  }

  min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(node, 'touchstart', stopMouse, true);
  min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(node, 'touchend', allowMouse, true);
  min_dom__WEBPACK_IMPORTED_MODULE_2__.event.bind(node, 'touchcancel', allowMouse, true);

  // A touch event recognizer that handles
  // touch events only (we know, we can already handle
  // mouse events out of the box)

  var recognizer = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Manager)(node, {
    inputClass: (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().TouchInput),
    recognizers: [],
    domEvents: true
  });


  var tap = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Tap)();
  var pan = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Pan)({ threshold: 10 });
  var press = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Press)();
  var pinch = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Pinch)();

  var doubleTap = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Tap)({ event: 'doubletap', taps: 2 });

  pinch.requireFailure(pan);
  pinch.requireFailure(press);

  recognizer.add([ pan, press, pinch, doubleTap, tap ]);

  recognizer.reset = function(force) {
    var recognizers = this.recognizers,
        session = this.session;

    if (session.stopped) {
      return;
    }

    log('recognizer', 'stop');

    recognizer.stop(force);

    setTimeout(function() {
      var i, r;

      log('recognizer', 'reset');
      for (i = 0; (r = recognizers[i]); i++) {
        r.reset();
        r.state = 8; // FAILED STATE
      }

      session.curRecognizer = null;
    }, 0);
  };

  recognizer.on('hammer.input', function(event) {
    if (event.srcEvent.defaultPrevented) {
      recognizer.reset(true);
    }
  });

  return recognizer;
}

/**
 * A plugin that provides touch events for elements.
 *
 * @param {EventBus} eventBus
 * @param {InteractionEvents} interactionEvents
 */
function TouchInteractionEvents(
    injector, canvas, eventBus,
    elementRegistry, interactionEvents) {

  // optional integrations
  var dragging = get('dragging', injector),
      move = get('move', injector),
      contextPad = get('contextPad', injector),
      palette = get('palette', injector);

  // the touch recognizer
  var recognizer;

  function handler(type) {

    return function(event) {
      log('element', type, event);

      interactionEvents.fire(type, event);
    };
  }

  function getGfx(target) {
    var node = (0,min_dom__WEBPACK_IMPORTED_MODULE_2__.closest)(target, 'svg, .djs-element', true);
    return node;
  }

  function initEvents(svg) {

    // touch recognizer
    recognizer = createTouchRecognizer(svg);

    recognizer.on('doubletap', handler('element.dblclick'));

    recognizer.on('tap', handler('element.click'));

    function startGrabCanvas(event) {

      log('canvas', 'grab start');

      var lx = 0, ly = 0;

      function update(e) {

        var dx = e.deltaX - lx,
            dy = e.deltaY - ly;

        canvas.scroll({ dx: dx, dy: dy });

        lx = e.deltaX;
        ly = e.deltaY;
      }

      function end(e) {
        recognizer.off('panmove', update);
        recognizer.off('panend', end);
        recognizer.off('pancancel', end);

        log('canvas', 'grab end');
      }

      recognizer.on('panmove', update);
      recognizer.on('panend', end);
      recognizer.on('pancancel', end);
    }

    function startGrab(event) {

      var gfx = getGfx(event.target),
          element = gfx && elementRegistry.get(gfx);

      // recognizer
      if (move && canvas.getRootElement() !== element) {
        log('element', 'move start', element, event, true);
        return move.start(event, element, true);
      } else {
        startGrabCanvas(event);
      }
    }

    function startZoom(e) {

      log('canvas', 'zoom start');

      var zoom = canvas.zoom(),
          mid = e.center;

      function update(e) {

        var ratio = 1 - (1 - e.scale) / 1.50,
            newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, ratio * zoom));

        canvas.zoom(newZoom, mid);

        stopEvent(e);
      }

      function end(e) {
        recognizer.off('pinchmove', update);
        recognizer.off('pinchend', end);
        recognizer.off('pinchcancel', end);

        recognizer.reset(true);

        log('canvas', 'zoom end');
      }

      recognizer.on('pinchmove', update);
      recognizer.on('pinchend', end);
      recognizer.on('pinchcancel', end);
    }

    recognizer.on('panstart', startGrab);
    recognizer.on('press', startGrab);

    recognizer.on('pinchstart', startZoom);
  }

  if (dragging) {

    // simulate hover during dragging
    eventBus.on('drag.move', function(event) {

      var originalEvent = event.originalEvent;

      if (!originalEvent || originalEvent instanceof MouseEvent) {
        return;
      }

      var position = (0,_util_Event__WEBPACK_IMPORTED_MODULE_3__.toPoint)(originalEvent);

      // this gets really expensive ...
      var node = document.elementFromPoint(position.x, position.y),
          gfx = getGfx(node),
          element = gfx && elementRegistry.get(gfx);

      if (element !== event.hover) {
        if (event.hover) {
          dragging.out(event);
        }

        if (element) {
          dragging.hover({ element: element, gfx: gfx });

          event.hover = element;
          event.hoverGfx = gfx;
        }
      }
    });
  }

  if (contextPad) {

    eventBus.on('contextPad.create', function(event) {
      var node = event.pad.html;

      // touch recognizer
      var padRecognizer = createTouchRecognizer(node);

      padRecognizer.on('panstart', function(event) {
        log('context-pad', 'panstart', event);
        contextPad.trigger('dragstart', event, true);
      });

      padRecognizer.on('press', function(event) {
        log('context-pad', 'press', event);
        contextPad.trigger('dragstart', event, true);
      });

      padRecognizer.on('tap', function(event) {
        log('context-pad', 'tap', event);
        contextPad.trigger('click', event);
      });
    });
  }

  if (palette) {
    eventBus.on('palette.create', function(event) {
      var node = event.container;

      // touch recognizer
      var padRecognizer = createTouchRecognizer(node);

      padRecognizer.on('panstart', function(event) {
        log('palette', 'panstart', event);
        palette.trigger('dragstart', event, true);
      });

      padRecognizer.on('press', function(event) {
        log('palette', 'press', event);
        palette.trigger('dragstart', event, true);
      });

      padRecognizer.on('tap', function(event) {
        log('palette', 'tap', event);
        palette.trigger('click', event);
      });
    });
  }

  eventBus.on('canvas.init', function(event) {
    initEvents(event.svg);
  });
}


TouchInteractionEvents.$inject = [
  'injector',
  'canvas',
  'eventBus',
  'elementRegistry',
  'interactionEvents',
  'touchFix'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/features/touch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/features/touch/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interaction_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interaction-events */ "./node_modules/diagram-js/lib/features/interaction-events/index.js");
/* harmony import */ var _TouchInteractionEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TouchInteractionEvents */ "./node_modules/diagram-js/lib/features/touch/TouchInteractionEvents.js");
/* harmony import */ var _TouchFix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TouchFix */ "./node_modules/diagram-js/lib/features/touch/TouchFix.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [ _interaction_events__WEBPACK_IMPORTED_MODULE_0__.default ],
  __init__: [ 'touchInteractionEvents' ],
  touchInteractionEvents: [ 'type', _TouchInteractionEvents__WEBPACK_IMPORTED_MODULE_1__.default ],
  touchFix: [ 'type', _TouchFix__WEBPACK_IMPORTED_MODULE_2__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/i18n/translate/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagram-js/lib/i18n/translate/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _translate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./translate */ "./node_modules/diagram-js/lib/i18n/translate/translate.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  translate: [ 'value', _translate__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/i18n/translate/translate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diagram-js/lib/i18n/translate/translate.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ translate)
/* harmony export */ });
/**
 * A simple translation stub to be used for multi-language support
 * in diagrams. Can be easily replaced with a more sophisticated
 * solution.
 *
 * @example
 *
 * // use it inside any diagram component by injecting `translate`.
 *
 * function MyService(translate) {
 *   alert(translate('HELLO {you}', { you: 'You!' }));
 * }
 *
 * @param {string} template to interpolate
 * @param {Object} [replacements] a map with substitutes
 *
 * @return {string} the translated string
 */
function translate(template, replacements) {

  replacements = replacements || {};

  return template.replace(/{([^}]+)}/g, function(_, key) {
    return replacements[key] || '{' + key + '}';
  });
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/layout/BaseLayouter.js":
/*!************************************************************!*\
  !*** ./node_modules/diagram-js/lib/layout/BaseLayouter.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseLayouter)
/* harmony export */ });
/* harmony import */ var _LayoutUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");



/**
 * A base connection layouter implementation
 * that layouts the connection by directly connecting
 * mid(source) + mid(target).
 */
function BaseLayouter() {}


/**
 * Return the new layouted waypoints for the given connection.
 *
 * The connection passed is still unchanged; you may figure out about
 * the new connection start / end via the layout hints provided.
 *
 * @param {djs.model.Connection} connection
 * @param {Object} [hints]
 * @param {Point} [hints.connectionStart]
 * @param {Point} [hints.connectionEnd]
 * @param {Point} [hints.source]
 * @param {Point} [hints.target]
 *
 * @return {Array<Point>} the layouted connection waypoints
 */
BaseLayouter.prototype.layoutConnection = function(connection, hints) {

  hints = hints || {};

  return [
    hints.connectionStart || (0,_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.getMid)(hints.source || connection.source),
    hints.connectionEnd || (0,_LayoutUtil__WEBPACK_IMPORTED_MODULE_0__.getMid)(hints.target || connection.target)
  ];
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js":
/*!*************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CroppingConnectionDocking)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");





function dockingToPoint(docking) {

  // use the dockings actual point and
  // retain the original docking
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({ original: docking.point.original || docking.point }, docking.actual);
}


/**
 * A {@link ConnectionDocking} that crops connection waypoints based on
 * the path(s) of the connection source and target.
 *
 * @param {djs.core.ElementRegistry} elementRegistry
 */
function CroppingConnectionDocking(elementRegistry, graphicsFactory) {
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;
}

CroppingConnectionDocking.$inject = [ 'elementRegistry', 'graphicsFactory' ];


/**
 * @inheritDoc ConnectionDocking#getCroppedWaypoints
 */
CroppingConnectionDocking.prototype.getCroppedWaypoints = function(connection, source, target) {

  source = source || connection.source;
  target = target || connection.target;

  var sourceDocking = this.getDockingPoint(connection, source, true),
      targetDocking = this.getDockingPoint(connection, target);

  var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);

  croppedWaypoints.unshift(dockingToPoint(sourceDocking));
  croppedWaypoints.push(dockingToPoint(targetDocking));

  return croppedWaypoints;
};

/**
 * Return the connection docking point on the specified shape
 *
 * @inheritDoc ConnectionDocking#getDockingPoint
 */
CroppingConnectionDocking.prototype.getDockingPoint = function(connection, shape, dockStart) {

  var waypoints = connection.waypoints,
      dockingIdx,
      dockingPoint,
      croppedPoint;

  dockingIdx = dockStart ? 0 : waypoints.length - 1;
  dockingPoint = waypoints[dockingIdx];

  croppedPoint = this._getIntersection(shape, connection, dockStart);

  return {
    point: dockingPoint,
    actual: croppedPoint || dockingPoint,
    idx: dockingIdx
  };
};


// helpers //////////////////////

CroppingConnectionDocking.prototype._getIntersection = function(shape, connection, takeFirst) {

  var shapePath = this._getShapePath(shape),
      connectionPath = this._getConnectionPath(connection);

  return (0,_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getElementLineIntersection)(shapePath, connectionPath, takeFirst);
};

CroppingConnectionDocking.prototype._getConnectionPath = function(connection) {
  return this._graphicsFactory.getConnectionPath(connection);
};

CroppingConnectionDocking.prototype._getShapePath = function(shape) {
  return this._graphicsFactory.getShapePath(shape);
};

CroppingConnectionDocking.prototype._getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/layout/LayoutUtil.js":
/*!**********************************************************!*\
  !*** ./node_modules/diagram-js/lib/layout/LayoutUtil.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "roundBounds": () => (/* binding */ roundBounds),
/* harmony export */   "roundPoint": () => (/* binding */ roundPoint),
/* harmony export */   "asTRBL": () => (/* binding */ asTRBL),
/* harmony export */   "asBounds": () => (/* binding */ asBounds),
/* harmony export */   "getMid": () => (/* binding */ getMid),
/* harmony export */   "getOrientation": () => (/* binding */ getOrientation),
/* harmony export */   "getElementLineIntersection": () => (/* binding */ getElementLineIntersection),
/* harmony export */   "getIntersections": () => (/* binding */ getIntersections),
/* harmony export */   "filterRedundantWaypoints": () => (/* binding */ filterRedundantWaypoints)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var _util_Geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Geometry */ "./node_modules/diagram-js/lib/util/Geometry.js");
/* harmony import */ var path_intersection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path-intersection */ "./node_modules/path-intersection/intersect.js");
/* harmony import */ var path_intersection__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path_intersection__WEBPACK_IMPORTED_MODULE_0__);







function roundBounds(bounds) {
  return {
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  };
}


function roundPoint(point) {

  return {
    x: Math.round(point.x),
    y: Math.round(point.y)
  };
}


/**
 * Convert the given bounds to a { top, left, bottom, right } descriptor.
 *
 * @param {Bounds|Point} bounds
 *
 * @return {Object}
 */
function asTRBL(bounds) {
  return {
    top: bounds.y,
    right: bounds.x + (bounds.width || 0),
    bottom: bounds.y + (bounds.height || 0),
    left: bounds.x
  };
}


/**
 * Convert a { top, left, bottom, right } to an objects bounds.
 *
 * @param {Object} trbl
 *
 * @return {Bounds}
 */
function asBounds(trbl) {
  return {
    x: trbl.left,
    y: trbl.top,
    width: trbl.right - trbl.left,
    height: trbl.bottom - trbl.top
  };
}


/**
 * Get the mid of the given bounds or point.
 *
 * @param {Bounds|Point} bounds
 *
 * @return {Point}
 */
function getMid(bounds) {
  return roundPoint({
    x: bounds.x + (bounds.width || 0) / 2,
    y: bounds.y + (bounds.height || 0) / 2
  });
}


// orientation utils //////////////////////

/**
 * Get orientation of the given rectangle with respect to
 * the reference rectangle.
 *
 * A padding (positive or negative) may be passed to influence
 * horizontal / vertical orientation and intersection.
 *
 * @param {Bounds} rect
 * @param {Bounds} reference
 * @param {Point|number} padding
 *
 * @return {string} the orientation; one of top, top-left, left, ..., bottom, right or intersect.
 */
function getOrientation(rect, reference, padding) {

  padding = padding || 0;

  // make sure we can use an object, too
  // for individual { x, y } padding
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_1__.isObject)(padding)) {
    padding = { x: padding, y: padding };
  }


  var rectOrientation = asTRBL(rect),
      referenceOrientation = asTRBL(reference);

  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,
      right = rectOrientation.left - padding.x >= referenceOrientation.right,
      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,
      left = rectOrientation.right + padding.x <= referenceOrientation.left;

  var vertical = top ? 'top' : (bottom ? 'bottom' : null),
      horizontal = left ? 'left' : (right ? 'right' : null);

  if (horizontal && vertical) {
    return vertical + '-' + horizontal;
  } else {
    return horizontal || vertical || 'intersect';
  }
}


// intersection utils //////////////////////

/**
 * Get intersection between an element and a line path.
 *
 * @param {PathDef} elementPath
 * @param {PathDef} linePath
 * @param {boolean} cropStart crop from start or end
 *
 * @return {Point}
 */
function getElementLineIntersection(elementPath, linePath, cropStart) {

  var intersections = getIntersections(elementPath, linePath);

  // recognize intersections
  // only one -> choose
  // two close together -> choose first
  // two or more distinct -> pull out appropriate one
  // none -> ok (fallback to point itself)
  if (intersections.length === 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length === 2 && (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_2__.pointDistance)(intersections[0], intersections[1]) < 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length > 1) {

    // sort by intersections based on connection segment +
    // distance from start
    intersections = (0,min_dash__WEBPACK_IMPORTED_MODULE_1__.sortBy)(intersections, function(i) {
      var distance = Math.floor(i.t2 * 100) || 1;

      distance = 100 - distance;

      distance = (distance < 10 ? '0' : '') + distance;

      // create a sort string that makes sure we sort
      // line segment ASC + line segment position DESC (for cropStart)
      // line segment ASC + line segment position ASC (for cropEnd)
      return i.segment2 + '#' + distance;
    });

    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
  }

  return null;
}


function getIntersections(a, b) {
  return path_intersection__WEBPACK_IMPORTED_MODULE_0___default()(a, b);
}


function filterRedundantWaypoints(waypoints) {

  // alter copy of waypoints, not original
  waypoints = waypoints.slice();

  var idx = 0,
      point,
      previousPoint,
      nextPoint;

  while (waypoints[idx]) {
    point = waypoints[idx];
    previousPoint = waypoints[idx - 1];
    nextPoint = waypoints[idx + 1];

    if ((0,_util_Geometry__WEBPACK_IMPORTED_MODULE_2__.pointDistance)(point, nextPoint) === 0 ||
        (0,_util_Geometry__WEBPACK_IMPORTED_MODULE_2__.pointsOnLine)(previousPoint, nextPoint, point)) {

      // remove point, if overlapping with {nextPoint}
      // or on line with {previousPoint} -> {point} -> {nextPoint}
      waypoints.splice(idx, 1);
    } else {
      idx++;
    }
  }

  return waypoints;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/model/index.js":
/*!****************************************************!*\
  !*** ./node_modules/diagram-js/lib/model/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Base": () => (/* binding */ Base),
/* harmony export */   "Shape": () => (/* binding */ Shape),
/* harmony export */   "Root": () => (/* binding */ Root),
/* harmony export */   "Label": () => (/* binding */ Label),
/* harmony export */   "Connection": () => (/* binding */ Connection),
/* harmony export */   "create": () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! object-refs */ "./node_modules/object-refs/index.js");
/* harmony import */ var object_refs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(object_refs__WEBPACK_IMPORTED_MODULE_1__);





var parentRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_1___default())({ name: 'children', enumerable: true, collection: true }, { name: 'parent' }),
    labelRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_1___default())({ name: 'labels', enumerable: true, collection: true }, { name: 'labelTarget' }),
    attacherRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_1___default())({ name: 'attachers', collection: true }, { name: 'host' }),
    outgoingRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_1___default())({ name: 'outgoing', collection: true }, { name: 'source' }),
    incomingRefs = new (object_refs__WEBPACK_IMPORTED_MODULE_1___default())({ name: 'incoming', collection: true }, { name: 'target' });

/**
 * @namespace djs.model
 */

/**
 * @memberOf djs.model
 */

/**
 * The basic graphical representation
 *
 * @class
 *
 * @abstract
 */
function Base() {

  /**
   * The object that backs up the shape
   *
   * @name Base#businessObject
   * @type Object
   */
  Object.defineProperty(this, 'businessObject', {
    writable: true
  });


  /**
   * Single label support, will mapped to multi label array
   *
   * @name Base#label
   * @type Object
   */
  Object.defineProperty(this, 'label', {
    get: function() {
      return this.labels[0];
    },
    set: function(newLabel) {

      var label = this.label,
          labels = this.labels;

      if (!newLabel && label) {
        labels.remove(label);
      } else {
        labels.add(newLabel, 0);
      }
    }
  });

  /**
   * The parent shape
   *
   * @name Base#parent
   * @type Shape
   */
  parentRefs.bind(this, 'parent');

  /**
   * The list of labels
   *
   * @name Base#labels
   * @type Label
   */
  labelRefs.bind(this, 'labels');

  /**
   * The list of outgoing connections
   *
   * @name Base#outgoing
   * @type Array<Connection>
   */
  outgoingRefs.bind(this, 'outgoing');

  /**
   * The list of incoming connections
   *
   * @name Base#incoming
   * @type Array<Connection>
   */
  incomingRefs.bind(this, 'incoming');
}


/**
 * A graphical object
 *
 * @class
 * @constructor
 *
 * @extends Base
 */
function Shape() {
  Base.call(this);

  /**
   * Indicates frame shapes
   *
   * @name Shape#isFrame
   * @type boolean
   */

  /**
   * The list of children
   *
   * @name Shape#children
   * @type Array<Base>
   */
  parentRefs.bind(this, 'children');

  /**
   * @name Shape#host
   * @type Shape
   */
  attacherRefs.bind(this, 'host');

  /**
   * @name Shape#attachers
   * @type Shape
   */
  attacherRefs.bind(this, 'attachers');
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Shape, Base);


/**
 * A root graphical object
 *
 * @class
 * @constructor
 *
 * @extends Shape
 */
function Root() {
  Shape.call(this);
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Root, Shape);


/**
 * A label for an element
 *
 * @class
 * @constructor
 *
 * @extends Shape
 */
function Label() {
  Shape.call(this);

  /**
   * The labeled element
   *
   * @name Label#labelTarget
   * @type Base
   */
  labelRefs.bind(this, 'labelTarget');
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Label, Shape);


/**
 * A connection between two elements
 *
 * @class
 * @constructor
 *
 * @extends Base
 */
function Connection() {
  Base.call(this);

  /**
   * The element this connection originates from
   *
   * @name Connection#source
   * @type Base
   */
  outgoingRefs.bind(this, 'source');

  /**
   * The element this connection points to
   *
   * @name Connection#target
   * @type Base
   */
  incomingRefs.bind(this, 'target');
}

inherits__WEBPACK_IMPORTED_MODULE_0___default()(Connection, Base);


var types = {
  connection: Connection,
  shape: Shape,
  label: Label,
  root: Root
};

/**
 * Creates a new model element of the specified type
 *
 * @method create
 *
 * @example
 *
 * var shape1 = Model.create('shape', { x: 10, y: 10, width: 100, height: 100 });
 * var shape2 = Model.create('shape', { x: 210, y: 210, width: 100, height: 100 });
 *
 * var connection = Model.create('connection', { waypoints: [ { x: 110, y: 55 }, {x: 210, y: 55 } ] });
 *
 * @param  {string} type lower-cased model name
 * @param  {Object} attrs attributes to initialize the new model instance with
 *
 * @return {Base} the new model instance
 */
function create(type, attrs) {
  var Type = types[type];
  if (!Type) {
    throw new Error('unknown type: <' + type + '>');
  }
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(new Type(), attrs);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/keyboard-move/KeyboardMove.js":
/*!******************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/keyboard-move/KeyboardMove.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ KeyboardMove)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



var DEFAULT_CONFIG = {
  moveSpeed: 50,
  moveSpeedAccelerated: 200
};


/**
 * A feature that allows users to move the canvas using the keyboard.
 *
 * @param {Object} config
 * @param {number} [config.moveSpeed=50]
 * @param {number} [config.moveSpeedAccelerated=200]
 * @param {Keyboard} keyboard
 * @param {Canvas} canvas
 */
function KeyboardMove(
    config,
    keyboard,
    canvas
) {

  var self = this;

  this._config = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, DEFAULT_CONFIG, config || {});

  keyboard.addListener(arrowsListener);


  function arrowsListener(context) {

    var event = context.keyEvent,
        config = self._config;

    if (!keyboard.isCmd(event)) {
      return;
    }

    if (keyboard.isKey([
      'ArrowLeft', 'Left',
      'ArrowUp', 'Up',
      'ArrowDown', 'Down',
      'ArrowRight', 'Right'
    ], event)) {

      var speed = (
        keyboard.isShift(event) ?
          config.moveSpeedAccelerated :
          config.moveSpeed
      );

      var direction;

      switch (event.key) {
      case 'ArrowLeft':
      case 'Left':
        direction = 'left';
        break;
      case 'ArrowUp':
      case 'Up':
        direction = 'up';
        break;
      case 'ArrowRight':
      case 'Right':
        direction = 'right';
        break;
      case 'ArrowDown':
      case 'Down':
        direction = 'down';
        break;
      }

      self.moveCanvas({
        speed: speed,
        direction: direction
      });

      return true;
    }
  }

  this.moveCanvas = function(opts) {

    var dx = 0,
        dy = 0,
        speed = opts.speed;

    var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);

    switch (opts.direction) {
    case 'left': // Left
      dx = actualSpeed;
      break;
    case 'up': // Up
      dy = actualSpeed;
      break;
    case 'right': // Right
      dx = -actualSpeed;
      break;
    case 'down': // Down
      dy = -actualSpeed;
      break;
    }

    canvas.scroll({
      dx: dx,
      dy: dy
    });
  };

}


KeyboardMove.$inject = [
  'config.keyboardMove',
  'keyboard',
  'canvas'
];


/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/keyboard-move/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/keyboard-move/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _features_keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../features/keyboard */ "./node_modules/diagram-js/lib/features/keyboard/index.js");
/* harmony import */ var _KeyboardMove__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyboardMove */ "./node_modules/diagram-js/lib/navigation/keyboard-move/KeyboardMove.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _features_keyboard__WEBPACK_IMPORTED_MODULE_0__.default
  ],
  __init__: [ 'keyboardMove' ],
  keyboardMove: [ 'type', _KeyboardMove__WEBPACK_IMPORTED_MODULE_1__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js":
/*!*************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveCanvas)
/* harmony export */ });
/* harmony import */ var _util_Cursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Cursor */ "./node_modules/diagram-js/lib/util/Cursor.js");
/* harmony import */ var _util_ClickTrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/ClickTrap */ "./node_modules/diagram-js/lib/util/ClickTrap.js");
/* harmony import */ var _util_PositionUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/PositionUtil */ "./node_modules/diagram-js/lib/util/PositionUtil.js");
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _util_Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Event */ "./node_modules/diagram-js/lib/util/Event.js");











var THRESHOLD = 15;


/**
 * Move the canvas via mouse.
 *
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function MoveCanvas(eventBus, canvas) {

  var context;


  // listen for move on element mouse down;
  // allow others to hook into the event before us though
  // (dragging / element moving will do this)
  eventBus.on('element.mousedown', 500, function(e) {
    return handleStart(e.originalEvent);
  });


  function handleMove(event) {

    var start = context.start,
        button = context.button,
        position = (0,_util_Event__WEBPACK_IMPORTED_MODULE_0__.toPoint)(event),
        delta = (0,_util_PositionUtil__WEBPACK_IMPORTED_MODULE_1__.delta)(position, start);

    if (!context.dragging && length(delta) > THRESHOLD) {
      context.dragging = true;

      if (button === 0) {
        (0,_util_ClickTrap__WEBPACK_IMPORTED_MODULE_2__.install)(eventBus);
      }

      (0,_util_Cursor__WEBPACK_IMPORTED_MODULE_3__.set)('grab');
    }

    if (context.dragging) {

      var lastPosition = context.last || context.start;

      delta = (0,_util_PositionUtil__WEBPACK_IMPORTED_MODULE_1__.delta)(position, lastPosition);

      canvas.scroll({
        dx: delta.x,
        dy: delta.y
      });

      context.last = position;
    }

    // prevent select
    event.preventDefault();
  }


  function handleEnd(event) {
    min_dom__WEBPACK_IMPORTED_MODULE_4__.event.unbind(document, 'mousemove', handleMove);
    min_dom__WEBPACK_IMPORTED_MODULE_4__.event.unbind(document, 'mouseup', handleEnd);

    context = null;

    (0,_util_Cursor__WEBPACK_IMPORTED_MODULE_3__.unset)();
  }

  function handleStart(event) {

    // event is already handled by '.djs-draggable'
    if ((0,min_dom__WEBPACK_IMPORTED_MODULE_4__.closest)(event.target, '.djs-draggable')) {
      return;
    }

    var button = event.button;

    // reject right mouse button or modifier key
    if (button >= 2 || event.ctrlKey || event.shiftKey || event.altKey) {
      return;
    }

    context = {
      button: button,
      start: (0,_util_Event__WEBPACK_IMPORTED_MODULE_0__.toPoint)(event)
    };

    min_dom__WEBPACK_IMPORTED_MODULE_4__.event.bind(document, 'mousemove', handleMove);
    min_dom__WEBPACK_IMPORTED_MODULE_4__.event.bind(document, 'mouseup', handleEnd);

    // we've handled the event
    return true;
  }

  this.isActive = function() {
    return !!context;
  };

}


MoveCanvas.$inject = [
  'eventBus',
  'canvas'
];



// helpers ///////

function length(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/movecanvas/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/movecanvas/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MoveCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MoveCanvas */ "./node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'moveCanvas' ],
  moveCanvas: [ 'type', _MoveCanvas__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/touch/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/touch/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _features_touch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../features/touch */ "./node_modules/diagram-js/lib/features/touch/index.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __depends__: [
    _features_touch__WEBPACK_IMPORTED_MODULE_0__.default
  ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js":
/*!*************************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZoomScroll)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");
/* harmony import */ var _ZoomUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ZoomUtil */ "./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomUtil.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Math */ "./node_modules/diagram-js/lib/util/Math.js");
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");








var sign = Math.sign || function(n) {
  return n >= 0 ? 1 : -1;
};

var RANGE = { min: 0.2, max: 4 },
    NUM_STEPS = 10;

var DELTA_THRESHOLD = 0.1;

var DEFAULT_SCALE = 0.75;

/**
 * An implementation of zooming and scrolling within the
 * {@link Canvas} via the mouse wheel.
 *
 * Mouse wheel zooming / scrolling may be disabled using
 * the {@link toggle(enabled)} method.
 *
 * @param {Object} [config]
 * @param {boolean} [config.enabled=true] default enabled state
 * @param {number} [config.scale=.75] scroll sensivity
 * @param {EventBus} eventBus
 * @param {Canvas} canvas
 */
function ZoomScroll(config, eventBus, canvas) {

  config = config || {};

  this._enabled = false;

  this._canvas = canvas;
  this._container = canvas._container;

  this._handleWheel = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(this._handleWheel, this);

  this._totalDelta = 0;
  this._scale = config.scale || DEFAULT_SCALE;

  var self = this;

  eventBus.on('canvas.init', function(e) {
    self._init(config.enabled !== false);
  });
}

ZoomScroll.$inject = [
  'config.zoomScroll',
  'eventBus',
  'canvas'
];

ZoomScroll.prototype.scroll = function scroll(delta) {
  this._canvas.scroll(delta);
};


ZoomScroll.prototype.reset = function reset() {
  this._canvas.zoom('fit-viewport');
};

/**
 * Zoom depending on delta.
 *
 * @param {number} delta
 * @param {Object} position
 */
ZoomScroll.prototype.zoom = function zoom(delta, position) {

  // zoom with half the step size of stepZoom
  var stepSize = (0,_ZoomUtil__WEBPACK_IMPORTED_MODULE_1__.getStepSize)(RANGE, NUM_STEPS * 2);

  // add until threshold reached
  this._totalDelta += delta;

  if (Math.abs(this._totalDelta) > DELTA_THRESHOLD) {
    this._zoom(delta, position, stepSize);

    // reset
    this._totalDelta = 0;
  }
};


ZoomScroll.prototype._handleWheel = function handleWheel(event) {

  // event is already handled by '.djs-scrollable'
  if ((0,min_dom__WEBPACK_IMPORTED_MODULE_2__.closest)(event.target, '.djs-scrollable', true)) {
    return;
  }

  var element = this._container;

  event.preventDefault();

  // pinch to zoom is mapped to wheel + ctrlKey = true
  // in modern browsers (!)

  var isZoom = event.ctrlKey;

  var isHorizontalScroll = event.shiftKey;

  var factor = -1 * this._scale,
      delta;

  if (isZoom) {
    factor *= event.deltaMode === 0 ? 0.020 : 0.32;
  } else {
    factor *= event.deltaMode === 0 ? 1.0 : 16.0;
  }

  if (isZoom) {
    var elementRect = element.getBoundingClientRect();

    var offset = {
      x: event.clientX - elementRect.left,
      y: event.clientY - elementRect.top
    };

    delta = (
      Math.sqrt(
        Math.pow(event.deltaY, 2) +
        Math.pow(event.deltaX, 2)
      ) * sign(event.deltaY) * factor
    );

    // zoom in relative to diagram {x,y} coordinates
    this.zoom(delta, offset);
  } else {

    if (isHorizontalScroll) {
      delta = {
        dx: factor * event.deltaY,
        dy: 0
      };
    } else {
      delta = {
        dx: factor * event.deltaX,
        dy: factor * event.deltaY
      };
    }

    this.scroll(delta);
  }
};

/**
 * Zoom with fixed step size.
 *
 * @param {number} delta - Zoom delta (1 for zooming in, -1 for out).
 * @param {Object} position
 */
ZoomScroll.prototype.stepZoom = function stepZoom(delta, position) {

  var stepSize = (0,_ZoomUtil__WEBPACK_IMPORTED_MODULE_1__.getStepSize)(RANGE, NUM_STEPS);

  this._zoom(delta, position, stepSize);
};


/**
 * Zoom in/out given a step size.
 *
 * @param {number} delta
 * @param {Object} position
 * @param {number} stepSize
 */
ZoomScroll.prototype._zoom = function(delta, position, stepSize) {
  var canvas = this._canvas;

  var direction = delta > 0 ? 1 : -1;

  var currentLinearZoomLevel = (0,_util_Math__WEBPACK_IMPORTED_MODULE_3__.log10)(canvas.zoom());

  // snap to a proximate zoom step
  var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;

  // increase or decrease one zoom step in the given direction
  newLinearZoomLevel += stepSize * direction;

  // calculate the absolute logarithmic zoom level based on the linear zoom level
  // (e.g. 2 for an absolute x2 zoom)
  var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);

  canvas.zoom((0,_ZoomUtil__WEBPACK_IMPORTED_MODULE_1__.cap)(RANGE, newLogZoomLevel), position);
};


/**
 * Toggle the zoom scroll ability via mouse wheel.
 *
 * @param  {boolean} [newEnabled] new enabled state
 */
ZoomScroll.prototype.toggle = function toggle(newEnabled) {

  var element = this._container;
  var handleWheel = this._handleWheel;

  var oldEnabled = this._enabled;

  if (typeof newEnabled === 'undefined') {
    newEnabled = !oldEnabled;
  }

  // only react on actual changes
  if (oldEnabled !== newEnabled) {

    // add or remove wheel listener based on
    // changed enabled state
    min_dom__WEBPACK_IMPORTED_MODULE_2__.event[newEnabled ? 'bind' : 'unbind'](element, 'wheel', handleWheel, false);
  }

  this._enabled = newEnabled;

  return newEnabled;
};


ZoomScroll.prototype._init = function(newEnabled) {
  this.toggle(newEnabled);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomUtil.js":
/*!***********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomUtil.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getStepSize": () => (/* binding */ getStepSize),
/* harmony export */   "cap": () => (/* binding */ cap)
/* harmony export */ });
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Math */ "./node_modules/diagram-js/lib/util/Math.js");


/**
 * Get step size for given range and number of steps.
 *
 * @param {Object} range
 * @param {number} range.min
 * @param {number} range.max
 */
function getStepSize(range, steps) {

  var minLinearRange = (0,_util_Math__WEBPACK_IMPORTED_MODULE_0__.log10)(range.min),
      maxLinearRange = (0,_util_Math__WEBPACK_IMPORTED_MODULE_0__.log10)(range.max);

  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);

  return absoluteLinearRange / steps;
}

function cap(range, scale) {
  return Math.max(range.min, Math.min(range.max, scale));
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/navigation/zoomscroll/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/diagram-js/lib/navigation/zoomscroll/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ZoomScroll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ZoomScroll */ "./node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __init__: [ 'zoomScroll' ],
  zoomScroll: [ 'type', _ZoomScroll__WEBPACK_IMPORTED_MODULE_0__.default ]
});

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/AttachUtil.js":
/*!********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/AttachUtil.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNewAttachPoint": () => (/* binding */ getNewAttachPoint),
/* harmony export */   "getNewAttachShapeDelta": () => (/* binding */ getNewAttachShapeDelta)
/* harmony export */ });
/* harmony import */ var _layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layout/LayoutUtil */ "./node_modules/diagram-js/lib/layout/LayoutUtil.js");
/* harmony import */ var _PositionUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PositionUtil */ "./node_modules/diagram-js/lib/util/PositionUtil.js");





/**
 * Calculates the absolute point relative to the new element's position
 *
 * @param {point} point [absolute]
 * @param {bounds} oldBounds
 * @param {bounds} newBounds
 *
 * @return {point} point [absolute]
 */
function getNewAttachPoint(point, oldBounds, newBounds) {
  var oldCenter = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.center)(oldBounds),
      newCenter = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.center)(newBounds),
      oldDelta = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.delta)(point, oldCenter);

  var newDelta = {
    x: oldDelta.x * (newBounds.width / oldBounds.width),
    y: oldDelta.y * (newBounds.height / oldBounds.height)
  };

  return (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.roundPoint)({
    x: newCenter.x + newDelta.x,
    y: newCenter.y + newDelta.y
  });
}


/**
 * Calculates the shape's delta relative to a new position
 * of a certain element's bounds
 *
 * @param {djs.model.Shape} point [absolute]
 * @param {bounds} oldBounds
 * @param {bounds} newBounds
 *
 * @return {delta} delta
 */
function getNewAttachShapeDelta(shape, oldBounds, newBounds) {
  var shapeCenter = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.center)(shape),
      oldCenter = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.center)(oldBounds),
      newCenter = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.center)(newBounds),
      shapeDelta = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.delta)(shape, shapeCenter),
      oldCenterDelta = (0,_PositionUtil__WEBPACK_IMPORTED_MODULE_0__.delta)(shapeCenter, oldCenter),
      stickyPositionDelta = getStickyPositionDelta(shapeCenter, oldBounds, newBounds);

  if (stickyPositionDelta) {
    return stickyPositionDelta;
  }

  var newCenterDelta = {
    x: oldCenterDelta.x * (newBounds.width / oldBounds.width),
    y: oldCenterDelta.y * (newBounds.height / oldBounds.height)
  };

  var newShapeCenter = {
    x: newCenter.x + newCenterDelta.x,
    y: newCenter.y + newCenterDelta.y
  };

  return (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.roundPoint)({
    x: newShapeCenter.x + shapeDelta.x - shape.x,
    y: newShapeCenter.y + shapeDelta.y - shape.y
  });
}

function getStickyPositionDelta(oldShapeCenter, oldBounds, newBounds) {
  var oldTRBL = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(oldBounds),
      newTRBL = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.asTRBL)(newBounds);

  if (isMoved(oldTRBL, newTRBL)) {
    return null;
  }

  var oldOrientation = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getOrientation)(oldBounds, oldShapeCenter),
      stickyPositionDelta,
      newShapeCenter,
      newOrientation;

  if (oldOrientation === 'top') {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.bottom - oldTRBL.bottom
    };
  } else if (oldOrientation === 'bottom') {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.top - oldTRBL.top
    };
  } else if (oldOrientation === 'right') {
    stickyPositionDelta = {
      x: newTRBL.left - oldTRBL.left,
      y: 0
    };
  } else if (oldOrientation === 'left') {
    stickyPositionDelta = {
      x: newTRBL.right - oldTRBL.right,
      y: 0
    };
  } else {

    // fallback to proportional movement for corner-placed attachments
    return null;
  }

  newShapeCenter = {
    x: oldShapeCenter.x + stickyPositionDelta.x,
    y: oldShapeCenter.y + stickyPositionDelta.y
  };

  newOrientation = (0,_layout_LayoutUtil__WEBPACK_IMPORTED_MODULE_1__.getOrientation)(newBounds, newShapeCenter);

  if (newOrientation !== oldOrientation) {

    // fallback to proportional movement if orientation would otherwise change
    return null;
  }

  return stickyPositionDelta;
}

function isMoved(oldTRBL, newTRBL) {
  return isHorizontallyMoved(oldTRBL, newTRBL) || isVerticallyMoved(oldTRBL, newTRBL);
}

function isHorizontallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.right !== newTRBL.right && oldTRBL.left !== newTRBL.left;
}

function isVerticallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.top !== newTRBL.top && oldTRBL.bottom !== newTRBL.bottom;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/ClickTrap.js":
/*!*******************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/ClickTrap.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
var TRAP_PRIORITY = 5000;

/**
 * Installs a click trap that prevents a ghost click following a dragging operation.
 *
 * @return {Function} a function to immediately remove the installed trap.
 */
function install(eventBus, eventName) {

  eventName = eventName || 'element.click';

  function trap() {
    return false;
  }

  eventBus.once(eventName, TRAP_PRIORITY, trap);

  return function() {
    eventBus.off(eventName, trap);
  };
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Collections.js":
/*!*********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Collections.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "indexOf": () => (/* binding */ indexOf)
/* harmony export */ });
/**
 * Failsafe remove an element from a collection
 *
 * @param  {Array<Object>} [collection]
 * @param  {Object} [element]
 *
 * @return {number} the previous index of the element
 */
function remove(collection, element) {

  if (!collection || !element) {
    return -1;
  }

  var idx = collection.indexOf(element);

  if (idx !== -1) {
    collection.splice(idx, 1);
  }

  return idx;
}

/**
 * Fail save add an element to the given connection, ensuring
 * it does not yet exist.
 *
 * @param {Array<Object>} collection
 * @param {Object} element
 * @param {number} idx
 */
function add(collection, element, idx) {

  if (!collection || !element) {
    return;
  }

  if (typeof idx !== 'number') {
    idx = -1;
  }

  var currentIdx = collection.indexOf(element);

  if (currentIdx !== -1) {

    if (currentIdx === idx) {

      // nothing to do, position has not changed
      return;
    } else {

      if (idx !== -1) {

        // remove from current position
        collection.splice(currentIdx, 1);
      } else {

        // already exists in collection
        return;
      }
    }
  }

  if (idx !== -1) {

    // insert at specified position
    collection.splice(idx, 0, element);
  } else {

    // push to end
    collection.push(element);
  }
}


/**
 * Fail save get the index of an element in a collection.
 *
 * @param {Array<Object>} collection
 * @param {Object} element
 *
 * @return {number} the index or -1 if collection or element do
 *                  not exist or the element is not contained.
 */
function indexOf(collection, element) {

  if (!collection || !element) {
    return -1;
  }

  return collection.indexOf(element);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Cursor.js":
/*!****************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Cursor.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "unset": () => (/* binding */ unset),
/* harmony export */   "has": () => (/* binding */ has)
/* harmony export */ });
/* harmony import */ var min_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dom */ "./node_modules/min-dom/dist/index.esm.js");


var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;


function set(mode) {
  var classes = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(document.body);

  classes.removeMatching(CURSOR_CLS_PATTERN);

  if (mode) {
    classes.add('djs-cursor-' + mode);
  }
}

function unset() {
  set(null);
}

function has(mode) {
  var classes = (0,min_dom__WEBPACK_IMPORTED_MODULE_0__.classes)(document.body);

  return classes.has('djs-cursor-' + mode);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Elements.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Elements.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getParents": () => (/* binding */ getParents),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "eachElement": () => (/* binding */ eachElement),
/* harmony export */   "selfAndChildren": () => (/* binding */ selfAndChildren),
/* harmony export */   "selfAndDirectChildren": () => (/* binding */ selfAndDirectChildren),
/* harmony export */   "selfAndAllChildren": () => (/* binding */ selfAndAllChildren),
/* harmony export */   "getClosure": () => (/* binding */ getClosure),
/* harmony export */   "getBBox": () => (/* binding */ getBBox),
/* harmony export */   "getEnclosedElements": () => (/* binding */ getEnclosedElements),
/* harmony export */   "getType": () => (/* binding */ getType),
/* harmony export */   "isFrameElement": () => (/* binding */ isFrameElement)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");



/**
 * Get parent elements.
 *
 * @param {Array<djs.model.base>} elements
 *
 * @returns {Array<djs.model.Base>}
 */
function getParents(elements) {

  // find elements that are not children of any other elements
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.filter)(elements, function(element) {
    return !(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.find)(elements, function(e) {
      return e !== element && getParent(element, e);
    });
  });
}


function getParent(element, parent) {
  if (!parent) {
    return;
  }

  if (element === parent) {
    return parent;
  }

  if (!element.parent) {
    return;
  }

  return getParent(element.parent, parent);
}


/**
 * Adds an element to a collection and returns true if the
 * element was added.
 *
 * @param {Array<Object>} elements
 * @param {Object} e
 * @param {boolean} unique
 */
function add(elements, e, unique) {
  var canAdd = !unique || elements.indexOf(e) === -1;

  if (canAdd) {
    elements.push(e);
  }

  return canAdd;
}


/**
 * Iterate over each element in a collection, calling the iterator function `fn`
 * with (element, index, recursionDepth).
 *
 * Recurse into all elements that are returned by `fn`.
 *
 * @param  {Object|Array<Object>} elements
 * @param  {Function} fn iterator function called with (element, index, recursionDepth)
 * @param  {number} [depth] maximum recursion depth
 */
function eachElement(elements, fn, depth) {

  depth = depth || 0;

  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements)) {
    elements = [ elements ];
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(s, i) {
    var filter = fn(s, i, depth);

    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(filter) && filter.length) {
      eachElement(filter, fn, depth + 1);
    }
  });
}


/**
 * Collects self + child elements up to a given depth from a list of elements.
 *
 * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from
 * @param  {boolean} unique whether to return a unique result set (no duplicates)
 * @param  {number} maxDepth the depth to search through or -1 for infinite
 *
 * @return {Array<djs.model.Base>} found elements
 */
function selfAndChildren(elements, unique, maxDepth) {
  var result = [],
      processedChildren = [];

  eachElement(elements, function(element, i, depth) {
    add(result, element, unique);

    var children = element.children;

    // max traversal depth not reached yet
    if (maxDepth === -1 || depth < maxDepth) {

      // children exist && children not yet processed
      if (children && add(processedChildren, children, unique)) {
        return children;
      }
    }
  });

  return result;
}

/**
 * Return self + direct children for a number of elements
 *
 * @param  {Array<djs.model.Base>} elements to query
 * @param  {boolean} allowDuplicates to allow duplicates in the result set
 *
 * @return {Array<djs.model.Base>} the collected elements
 */
function selfAndDirectChildren(elements, allowDuplicates) {
  return selfAndChildren(elements, !allowDuplicates, 1);
}


/**
 * Return self + ALL children for a number of elements
 *
 * @param  {Array<djs.model.Base>} elements to query
 * @param  {boolean} allowDuplicates to allow duplicates in the result set
 *
 * @return {Array<djs.model.Base>} the collected elements
 */
function selfAndAllChildren(elements, allowDuplicates) {
  return selfAndChildren(elements, !allowDuplicates, -1);
}


/**
 * Gets the the closure for all selected elements,
 * their enclosed children and connections.
 *
 * @param {Array<djs.model.Base>} elements
 * @param {boolean} [isTopLevel=true]
 * @param {Object} [existingClosure]
 *
 * @return {Object} newClosure
 */
function getClosure(elements, isTopLevel, closure) {

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(isTopLevel)) {
    isTopLevel = true;
  }

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(isTopLevel)) {
    closure = isTopLevel;
    isTopLevel = true;
  }


  closure = closure || {};

  var allShapes = copyObject(closure.allShapes),
      allConnections = copyObject(closure.allConnections),
      enclosedElements = copyObject(closure.enclosedElements),
      enclosedConnections = copyObject(closure.enclosedConnections);

  var topLevel = copyObject(
    closure.topLevel,
    isTopLevel && (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.groupBy)(elements, function(e) { return e.id; })
  );


  function handleConnection(c) {
    if (topLevel[c.source.id] && topLevel[c.target.id]) {
      topLevel[c.id] = [ c ];
    }

    // not enclosed as a child, but maybe logically
    // (connecting two moved elements?)
    if (allShapes[c.source.id] && allShapes[c.target.id]) {
      enclosedConnections[c.id] = enclosedElements[c.id] = c;
    }

    allConnections[c.id] = c;
  }

  function handleElement(element) {

    enclosedElements[element.id] = element;

    if (element.waypoints) {

      // remember connection
      enclosedConnections[element.id] = allConnections[element.id] = element;
    } else {

      // remember shape
      allShapes[element.id] = element;

      // remember all connections
      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(element.incoming, handleConnection);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(element.outgoing, handleConnection);

      // recurse into children
      return element.children;
    }
  }

  eachElement(elements, handleElement);

  return {
    allShapes: allShapes,
    allConnections: allConnections,
    topLevel: topLevel,
    enclosedConnections: enclosedConnections,
    enclosedElements: enclosedElements
  };
}

/**
 * Returns the surrounding bbox for all elements in
 * the array or the element primitive.
 *
 * @param {Array<djs.model.Shape>|djs.model.Shape} elements
 * @param {boolean} stopRecursion
 */
function getBBox(elements, stopRecursion) {

  stopRecursion = !!stopRecursion;
  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements)) {
    elements = [elements];
  }

  var minX,
      minY,
      maxX,
      maxY;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {

    // If element is a connection the bbox must be computed first
    var bbox = element;
    if (element.waypoints && !stopRecursion) {
      bbox = getBBox(element.waypoints, true);
    }

    var x = bbox.x,
        y = bbox.y,
        height = bbox.height || 0,
        width = bbox.width || 0;

    if (x < minX || minX === undefined) {
      minX = x;
    }
    if (y < minY || minY === undefined) {
      minY = y;
    }

    if ((x + width) > maxX || maxX === undefined) {
      maxX = x + width;
    }
    if ((y + height) > maxY || maxY === undefined) {
      maxY = y + height;
    }
  });

  return {
    x: minX,
    y: minY,
    height: maxY - minY,
    width: maxX - minX
  };
}


/**
 * Returns all elements that are enclosed from the bounding box.
 *
 *   * If bbox.(width|height) is not specified the method returns
 *     all elements with element.x/y > bbox.x/y
 *   * If only bbox.x or bbox.y is specified, method return all elements with
 *     e.x > bbox.x or e.y > bbox.y
 *
 * @param {Array<djs.model.Shape>} elements List of Elements to search through
 * @param {djs.model.Shape} bbox the enclosing bbox.
 *
 * @return {Array<djs.model.Shape>} enclosed elements
 */
function getEnclosedElements(elements, bbox) {

  var filteredElements = {};

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(elements, function(element) {

    var e = element;

    if (e.waypoints) {
      e = getBBox(e);
    }

    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.y) && (e.x > bbox.x)) {
      filteredElements[element.id] = element;
    }
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.x) && (e.y > bbox.y)) {
      filteredElements[element.id] = element;
    }
    if (e.x > bbox.x && e.y > bbox.y) {
      if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.width) && (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.height) &&
          e.width + e.x < bbox.width + bbox.x &&
          e.height + e.y < bbox.height + bbox.y) {

        filteredElements[element.id] = element;
      } else if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.width) || !(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(bbox.height)) {
        filteredElements[element.id] = element;
      }
    }
  });

  return filteredElements;
}


function getType(element) {

  if ('waypoints' in element) {
    return 'connection';
  }

  if ('x' in element) {
    return 'shape';
  }

  return 'root';
}

function isFrameElement(element) {

  return !!(element && element.isFrame);
}

// helpers ///////////////////////////////

function copyObject(src1, src2) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, src1 || {}, src2 || {});
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Event.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Event.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOriginal": () => (/* binding */ getOriginal),
/* harmony export */   "stopPropagation": () => (/* binding */ stopPropagation),
/* harmony export */   "toPoint": () => (/* binding */ toPoint)
/* harmony export */ });
function __stopPropagation(event) {
  if (!event || typeof event.stopPropagation !== 'function') {
    return;
  }

  event.stopPropagation();
}


function getOriginal(event) {
  return event.originalEvent || event.srcEvent;
}


function stopPropagation(event, immediate) {
  __stopPropagation(event, immediate);
  __stopPropagation(getOriginal(event), immediate);
}


function toPoint(event) {

  if (event.pointers && event.pointers.length) {
    event = event.pointers[0];
  }

  if (event.touches && event.touches.length) {
    event = event.touches[0];
  }

  return event ? {
    x: event.clientX,
    y: event.clientY
  } : null;
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Geometry.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Geometry.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pointDistance": () => (/* binding */ pointDistance),
/* harmony export */   "pointsOnLine": () => (/* binding */ pointsOnLine),
/* harmony export */   "pointsAligned": () => (/* binding */ pointsAligned),
/* harmony export */   "pointsAlignedHorizontally": () => (/* binding */ pointsAlignedHorizontally),
/* harmony export */   "pointsAlignedVertically": () => (/* binding */ pointsAlignedVertically),
/* harmony export */   "pointInRect": () => (/* binding */ pointInRect),
/* harmony export */   "getMidPoint": () => (/* binding */ getMidPoint)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * Computes the distance between two points
 *
 * @param  {Point}  p
 * @param  {Point}  q
 *
 * @return {number}  distance
 */
function pointDistance(a, b) {
  if (!a || !b) {
    return -1;
  }

  return Math.sqrt(
    Math.pow(a.x - b.x, 2) +
    Math.pow(a.y - b.y, 2)
  );
}


/**
 * Returns true if the point r is on the line between p and q
 *
 * @param  {Point}  p
 * @param  {Point}  q
 * @param  {Point}  r
 * @param  {number} [accuracy=5] accuracy for points on line check (lower is better)
 *
 * @return {boolean}
 */
function pointsOnLine(p, q, r, accuracy) {

  if (typeof accuracy === 'undefined') {
    accuracy = 5;
  }

  if (!p || !q || !r) {
    return false;
  }

  var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),
      dist = pointDistance(p, q);

  // @see http://stackoverflow.com/a/907491/412190
  return Math.abs(val / dist) <= accuracy;
}


var ALIGNED_THRESHOLD = 2;

/**
 * Check whether two points are horizontally or vertically aligned.
 *
 * @param {Array<Point>|Point}
 * @param {Point}
 *
 * @return {string|boolean}
 */
function pointsAligned(a, b) {
  var points;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(a)) {
    points = a;
  } else {
    points = [ a, b ];
  }

  if (pointsAlignedHorizontally(points)) {
    return 'h';
  }

  if (pointsAlignedVertically(points)) {
    return 'v';
  }

  return false;
}

function pointsAlignedHorizontally(a, b) {
  var points;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(a)) {
    points = a;
  } else {
    points = [ a, b ];
  }

  var firstPoint = points.slice().shift();

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.every)(points, function(point) {
    return Math.abs(firstPoint.y - point.y) <= ALIGNED_THRESHOLD;
  });
}

function pointsAlignedVertically(a, b) {
  var points;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isArray)(a)) {
    points = a;
  } else {
    points = [ a, b ];
  }

  var firstPoint = points.slice().shift();

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.every)(points, function(point) {
    return Math.abs(firstPoint.x - point.x) <= ALIGNED_THRESHOLD;
  });
}



/**
 * Returns true if the point p is inside the rectangle rect
 *
 * @param  {Point}  p
 * @param  {Rect} rect
 * @param  {number} tolerance
 *
 * @return {boolean}
 */
function pointInRect(p, rect, tolerance) {
  tolerance = tolerance || 0;

  return p.x > rect.x - tolerance &&
         p.y > rect.y - tolerance &&
         p.x < rect.x + rect.width + tolerance &&
         p.y < rect.y + rect.height + tolerance;
}

/**
 * Returns a point in the middle of points p and q
 *
 * @param  {Point}  p
 * @param  {Point}  q
 *
 * @return {Point} middle point
 */
function getMidPoint(p, q) {
  return {
    x: Math.round(p.x + ((q.x - p.x) / 2.0)),
    y: Math.round(p.y + ((q.y - p.y) / 2.0))
  };
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/GraphicsUtil.js":
/*!**********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/GraphicsUtil.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getVisual": () => (/* binding */ getVisual),
/* harmony export */   "getChildren": () => (/* binding */ getChildren)
/* harmony export */ });
/**
 * SVGs for elements are generated by the {@link GraphicsFactory}.
 *
 * This utility gives quick access to the important semantic
 * parts of an element.
 */

/**
 * Returns the visual part of a diagram element
 *
 * @param {Snap<SVGElement>} gfx
 *
 * @return {Snap<SVGElement>}
 */
function getVisual(gfx) {
  return gfx.childNodes[0];
}

/**
 * Returns the children for a given diagram element.
 *
 * @param {Snap<SVGElement>} gfx
 * @return {Snap<SVGElement>}
 */
function getChildren(gfx) {
  return gfx.parentNode.childNodes[1];
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/IdGenerator.js":
/*!*********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/IdGenerator.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IdGenerator)
/* harmony export */ });
/**
 * Util that provides unique IDs.
 *
 * @class djs.util.IdGenerator
 * @constructor
 * @memberOf djs.util
 *
 * The ids can be customized via a given prefix and contain a random value to avoid collisions.
 *
 * @param {string} prefix a prefix to prepend to generated ids (for better readability)
 */
function IdGenerator(prefix) {

  this._counter = 0;
  this._prefix = (prefix ? prefix + '-' : '') + Math.floor(Math.random() * 1000000000) + '-';
}

/**
 * Returns a next unique ID.
 *
 * @method djs.util.IdGenerator#next
 *
 * @returns {string} the id
 */
IdGenerator.prototype.next = function() {
  return this._prefix + (++this._counter);
};


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/LineIntersection.js":
/*!**************************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/LineIntersection.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getApproxIntersection": () => (/* binding */ getApproxIntersection)
/* harmony export */ });
/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Geometry */ "./node_modules/diagram-js/lib/util/Geometry.js");
/* harmony import */ var path_intersection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path-intersection */ "./node_modules/path-intersection/intersect.js");
/* harmony import */ var path_intersection__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path_intersection__WEBPACK_IMPORTED_MODULE_0__);




var round = Math.round,
    max = Math.max;


function circlePath(center, r) {
  var x = center.x,
      y = center.y;

  return [
    ['M', x, y],
    ['m', 0, -r],
    ['a', r, r, 0, 1, 1, 0, 2 * r],
    ['a', r, r, 0, 1, 1, 0, -2 * r],
    ['z']
  ];
}

function linePath(points) {
  var segments = [];

  points.forEach(function(p, idx) {
    segments.push([ idx === 0 ? 'M' : 'L', p.x, p.y ]);
  });

  return segments;
}


var INTERSECTION_THRESHOLD = 10;

function getBendpointIntersection(waypoints, reference) {

  var i, w;

  for (i = 0; (w = waypoints[i]); i++) {

    if ((0,_Geometry__WEBPACK_IMPORTED_MODULE_1__.pointDistance)(w, reference) <= INTERSECTION_THRESHOLD) {
      return {
        point: waypoints[i],
        bendpoint: true,
        index: i
      };
    }
  }

  return null;
}

function getPathIntersection(waypoints, reference) {

  var intersections = path_intersection__WEBPACK_IMPORTED_MODULE_0___default()(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));

  var a = intersections[0],
      b = intersections[intersections.length - 1],
      idx;

  if (!a) {

    // no intersection
    return null;
  }

  if (a !== b) {

    if (a.segment2 !== b.segment2) {

      // we use the bendpoint in between both segments
      // as the intersection point

      idx = max(a.segment2, b.segment2) - 1;

      return {
        point: waypoints[idx],
        bendpoint: true,
        index: idx
      };
    }

    return {
      point: {
        x: (round(a.x + b.x) / 2),
        y: (round(a.y + b.y) / 2)
      },
      index: a.segment2
    };
  }

  return {
    point: {
      x: round(a.x),
      y: round(a.y)
    },
    index: a.segment2
  };
}

/**
 * Returns the closest point on the connection towards a given reference point.
 *
 * @param  {Array<Point>} waypoints
 * @param  {Point} reference
 *
 * @return {Object} intersection data (segment, point)
 */
function getApproxIntersection(waypoints, reference) {
  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Math.js":
/*!**************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Math.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "log10": () => (/* binding */ log10),
/* harmony export */   "substract": () => (/* reexport safe */ _PositionUtil__WEBPACK_IMPORTED_MODULE_0__.delta)
/* harmony export */ });
/* harmony import */ var _PositionUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PositionUtil */ "./node_modules/diagram-js/lib/util/PositionUtil.js");
/**
 * Get the logarithm of x with base 10
 * @param  {Integer} value
 */
function log10(x) {
  return Math.log(x) / Math.log(10);
}




/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Mouse.js":
/*!***************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Mouse.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isMac": () => (/* reexport safe */ _Platform__WEBPACK_IMPORTED_MODULE_0__.isMac),
/* harmony export */   "isButton": () => (/* binding */ isButton),
/* harmony export */   "isPrimaryButton": () => (/* binding */ isPrimaryButton),
/* harmony export */   "isAuxiliaryButton": () => (/* binding */ isAuxiliaryButton),
/* harmony export */   "isSecondaryButton": () => (/* binding */ isSecondaryButton),
/* harmony export */   "hasPrimaryModifier": () => (/* binding */ hasPrimaryModifier),
/* harmony export */   "hasSecondaryModifier": () => (/* binding */ hasSecondaryModifier)
/* harmony export */ });
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./node_modules/diagram-js/lib/util/Event.js");
/* harmony import */ var _Platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Platform */ "./node_modules/diagram-js/lib/util/Platform.js");






function isButton(event, button) {
  return ((0,_Event__WEBPACK_IMPORTED_MODULE_1__.getOriginal)(event) || event).button === button;
}

function isPrimaryButton(event) {

  // button === 0 -> left ka primary mouse button
  return isButton(event, 0);
}

function isAuxiliaryButton(event) {

  // button === 1 -> auxiliary ka wheel button
  return isButton(event, 1);
}

function isSecondaryButton(event) {

  // button === 2 -> right ka secondary button
  return isButton(event, 2);
}

function hasPrimaryModifier(event) {
  var originalEvent = (0,_Event__WEBPACK_IMPORTED_MODULE_1__.getOriginal)(event) || event;

  if (!isPrimaryButton(event)) {
    return false;
  }

  // Use cmd as primary modifier key for mac OS
  if ((0,_Platform__WEBPACK_IMPORTED_MODULE_0__.isMac)()) {
    return originalEvent.metaKey;
  } else {
    return originalEvent.ctrlKey;
  }
}


function hasSecondaryModifier(event) {
  var originalEvent = (0,_Event__WEBPACK_IMPORTED_MODULE_1__.getOriginal)(event) || event;

  return isPrimaryButton(event) && originalEvent.shiftKey;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Platform.js":
/*!******************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Platform.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isMac": () => (/* binding */ isMac)
/* harmony export */ });
function isMac() {
  return (/mac/i).test(navigator.platform);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/PositionUtil.js":
/*!**********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/PositionUtil.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "center": () => (/* binding */ center),
/* harmony export */   "delta": () => (/* binding */ delta)
/* harmony export */ });
function center(bounds) {
  return {
    x: bounds.x + (bounds.width / 2),
    y: bounds.y + (bounds.height / 2)
  };
}


function delta(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Removal.js":
/*!*****************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Removal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "saveClear": () => (/* binding */ saveClear)
/* harmony export */ });
/**
 * Remove from the beginning of a collection until it is empty.
 *
 * This is a null-safe operation that ensures elements
 * are being removed from the given collection until the
 * collection is empty.
 *
 * The implementation deals with the fact that a remove operation
 * may touch, i.e. remove multiple elements in the collection
 * at a time.
 *
 * @param {Array<Object>} [collection]
 * @param {Function} removeFn
 *
 * @return {Array<Object>} the cleared collection
 */
function saveClear(collection, removeFn) {

  if (typeof removeFn !== 'function') {
    throw new Error('removeFn iterator must be a function');
  }

  if (!collection) {
    return;
  }

  var e;

  while ((e = collection[0])) {
    removeFn(e);
  }

  return collection;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/RenderUtil.js":
/*!********************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/RenderUtil.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "componentsToPath": () => (/* binding */ componentsToPath),
/* harmony export */   "toSVGPoints": () => (/* binding */ toSVGPoints),
/* harmony export */   "createLine": () => (/* binding */ createLine),
/* harmony export */   "updateLine": () => (/* binding */ updateLine)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");



function componentsToPath(elements) {
  return elements.join(',').replace(/,?([A-z]),?/g, '$1');
}

function toSVGPoints(points) {
  var result = '';

  for (var i = 0, p; (p = points[i]); i++) {
    result += p.x + ',' + p.y + ' ';
  }

  return result;
}

function createLine(points, attrs) {

  var line = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.create)('polyline');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(line, { points: toSVGPoints(points) });

  if (attrs) {
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(line, attrs);
  }

  return line;
}

function updateLine(gfx, points) {
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.attr)(gfx, { points: toSVGPoints(points) });

  return gfx;
}


/***/ }),

/***/ "./node_modules/diagram-js/lib/util/SvgTransformUtil.js":
/*!**************************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/SvgTransformUtil.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "scale": () => (/* binding */ scale)
/* harmony export */ });
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");



/**
 * @param {<SVGElement>} element
 * @param {number} x
 * @param {number} y
 * @param {number} angle
 * @param {number} amount
 */
function transform(gfx, x, y, angle, amount) {
  var translate = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  translate.setTranslate(x, y);

  var rotate = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  rotate.setRotate(angle || 0, 0, 0);

  var scale = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  scale.setScale(amount || 1, amount || 1);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.transform)(gfx, [ translate, rotate, scale ]);
}


/**
 * @param {SVGElement} element
 * @param {number} x
 * @param {number} y
 */
function translate(gfx, x, y) {
  var translate = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  translate.setTranslate(x, y);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.transform)(gfx, translate);
}


/**
 * @param {SVGElement} element
 * @param {number} angle
 */
function rotate(gfx, angle) {
  var rotate = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  rotate.setRotate(angle, 0, 0);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.transform)(gfx, rotate);
}


/**
 * @param {SVGElement} element
 * @param {number} amount
 */
function scale(gfx, amount) {
  var scale = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.createTransform)();
  scale.setScale(amount, amount);

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_0__.transform)(gfx, scale);
}

/***/ }),

/***/ "./node_modules/diagram-js/lib/util/Text.js":
/*!**************************************************!*\
  !*** ./node_modules/diagram-js/lib/util/Text.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Text)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var tiny_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-svg */ "./node_modules/tiny-svg/dist/index.esm.js");




var DEFAULT_BOX_PADDING = 0;

var DEFAULT_LABEL_SIZE = {
  width: 150,
  height: 50
};


function parseAlign(align) {

  var parts = align.split('-');

  return {
    horizontal: parts[0] || 'center',
    vertical: parts[1] || 'top'
  };
}

function parsePadding(padding) {

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(padding)) {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({ top: 0, left: 0, right: 0, bottom: 0 }, padding);
  } else {
    return {
      top: padding,
      left: padding,
      right: padding,
      bottom: padding
    };
  }
}

function getTextBBox(text, fakeText) {

  fakeText.textContent = text;

  var textBBox;

  try {
    var bbox,
        emptyLine = text === '';

    // add dummy text, when line is empty to
    // determine correct height
    fakeText.textContent = emptyLine ? 'dummy' : text;

    textBBox = fakeText.getBBox();

    // take text rendering related horizontal
    // padding into account
    bbox = {
      width: textBBox.width + textBBox.x * 2,
      height: textBBox.height
    };

    if (emptyLine) {

      // correct width
      bbox.width = 0;
    }

    return bbox;
  } catch (e) {
    return { width: 0, height: 0 };
  }
}


/**
 * Layout the next line and return the layouted element.
 *
 * Alters the lines passed.
 *
 * @param  {Array<string>} lines
 * @return {Object} the line descriptor, an object { width, height, text }
 */
function layoutNext(lines, maxWidth, fakeText) {

  var originalLine = lines.shift(),
      fitLine = originalLine;

  var textBBox;

  for (;;) {
    textBBox = getTextBBox(fitLine, fakeText);

    textBBox.width = fitLine ? textBBox.width : 0;

    // try to fit
    if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {
      return fit(lines, fitLine, originalLine, textBBox);
    }

    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
  }
}

function fit(lines, fitLine, originalLine, textBBox) {
  if (fitLine.length < originalLine.length) {
    var remainder = originalLine.slice(fitLine.length).trim();

    lines.unshift(remainder);
  }

  return {
    width: textBBox.width,
    height: textBBox.height,
    text: fitLine
  };
}

var SOFT_BREAK = '\u00AD';


/**
 * Shortens a line based on spacing and hyphens.
 * Returns the shortened result on success.
 *
 * @param  {string} line
 * @param  {number} maxLength the maximum characters of the string
 * @return {string} the shortened string
 */
function semanticShorten(line, maxLength) {

  var parts = line.split(/(\s|-|\u00AD)/g),
      part,
      shortenedParts = [],
      length = 0;

  // try to shorten via break chars
  if (parts.length > 1) {

    while ((part = parts.shift())) {
      if (part.length + length < maxLength) {
        shortenedParts.push(part);
        length += part.length;
      } else {

        // remove previous part, too if hyphen does not fit anymore
        if (part === '-' || part === SOFT_BREAK) {
          shortenedParts.pop();
        }

        break;
      }
    }
  }

  var last = shortenedParts[shortenedParts.length - 1];

  // translate trailing soft break to actual hyphen
  if (last && last === SOFT_BREAK) {
    shortenedParts[shortenedParts.length - 1] = '-';
  }

  return shortenedParts.join('');
}


function shortenLine(line, width, maxWidth) {
  var length = Math.max(line.length * (maxWidth / width), 1);

  // try to shorten semantically (i.e. based on spaces and hyphens)
  var shortenedLine = semanticShorten(line, length);

  if (!shortenedLine) {

    // force shorten by cutting the long word
    shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));
  }

  return shortenedLine;
}


function getHelperSvg() {
  var helperSvg = document.getElementById('helper-svg');

  if (!helperSvg) {
    helperSvg = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('svg');

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(helperSvg, {
      id: 'helper-svg',
      width: 0,
      height: 0,
      style: 'visibility: hidden; position: fixed'
    });

    document.body.appendChild(helperSvg);
  }

  return helperSvg;
}


/**
 * Creates a new label utility
 *
 * @param {Object} config
 * @param {Dimensions} config.size
 * @param {number} config.padding
 * @param {Object} config.style
 * @param {string} config.align
 */
function Text(config) {

  this._config = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, {
    size: DEFAULT_LABEL_SIZE,
    padding: DEFAULT_BOX_PADDING,
    style: {},
    align: 'center-top'
  }, config || {});
}

/**
 * Returns the layouted text as an SVG element.
 *
 * @param {string} text
 * @param {Object} options
 *
 * @return {SVGElement}
 */
Text.prototype.createText = function(text, options) {
  return this.layoutText(text, options).element;
};

/**
 * Returns a labels layouted dimensions.
 *
 * @param {string} text to layout
 * @param {Object} options
 *
 * @return {Dimensions}
 */
Text.prototype.getDimensions = function(text, options) {
  return this.layoutText(text, options).dimensions;
};

/**
 * Creates and returns a label and its bounding box.
 *
 * @method Text#createText
 *
 * @param {string} text the text to render on the label
 * @param {Object} options
 * @param {string} options.align how to align in the bounding box.
 *                               Any of { 'center-middle', 'center-top' },
 *                               defaults to 'center-top'.
 * @param {string} options.style style to be applied to the text
 * @param {boolean} options.fitBox indicates if box will be recalculated to
 *                                 fit text
 *
 * @return {Object} { element, dimensions }
 */
Text.prototype.layoutText = function(text, options) {
  var box = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, this._config.size, options.box),
      style = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, this._config.style, options.style),
      align = parseAlign(options.align || this._config.align),
      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),
      fitBox = options.fitBox || false;

  var lineHeight = getLineHeight(style);

  // we split text by lines and normalize
  // {soft break} + {line break} => { line break }
  var lines = text.split(/\u00AD?\r?\n/),
      layouted = [];

  var maxWidth = box.width - padding.left - padding.right;

  // ensure correct rendering by attaching helper text node to invisible SVG
  var helperText = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('text');
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(helperText, { x: 0, y: 0 });
  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(helperText, style);

  var helperSvg = getHelperSvg();

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(helperSvg, helperText);

  while (lines.length) {
    layouted.push(layoutNext(lines, maxWidth, helperText));
  }

  if (align.vertical === 'middle') {
    padding.top = padding.bottom = 0;
  }

  var totalHeight = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(layouted, function(sum, line, idx) {
    return sum + (lineHeight || line.height);
  }, 0) + padding.top + padding.bottom;

  var maxLineWidth = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.reduce)(layouted, function(sum, line, idx) {
    return line.width > sum ? line.width : sum;
  }, 0);

  // the y position of the next line
  var y = padding.top;

  if (align.vertical === 'middle') {
    y += (box.height - totalHeight) / 2;
  }

  // magic number initial offset
  y -= (lineHeight || layouted[0].height) / 4;


  var textElement = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('text');

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(textElement, style);

  // layout each line taking into account that parent
  // shape might resize to fit text size
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(layouted, function(line) {

    var x;

    y += (lineHeight || line.height);

    switch (align.horizontal) {
    case 'left':
      x = padding.left;
      break;

    case 'right':
      x = ((fitBox ? maxLineWidth : maxWidth)
        - padding.right - line.width);
      break;

    default:

      // aka center
      x = Math.max((((fitBox ? maxLineWidth : maxWidth)
        - line.width) / 2 + padding.left), 0);
    }

    var tspan = (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.create)('tspan');
    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.attr)(tspan, { x: x, y: y });

    tspan.textContent = line.text;

    (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.append)(textElement, tspan);
  });

  (0,tiny_svg__WEBPACK_IMPORTED_MODULE_1__.remove)(helperText);

  var dimensions = {
    width: maxLineWidth,
    height: totalHeight
  };

  return {
    dimensions: dimensions,
    element: textElement
  };
};


function getLineHeight(style) {
  if ('fontSize' in style && 'lineHeight' in style) {
    return style.lineHeight * parseInt(style.fontSize, 10);
  }
}

/***/ }),

/***/ "./node_modules/didi/dist/index.esm.js":
/*!*********************************************!*\
  !*** ./node_modules/didi/dist/index.esm.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "annotate": () => (/* binding */ annotate),
/* harmony export */   "parseAnnotations": () => (/* binding */ parseAnnotations),
/* harmony export */   "Module": () => (/* binding */ Module),
/* harmony export */   "Injector": () => (/* binding */ Injector)
/* harmony export */ });
var CLASS_PATTERN = /^class /;

function isClass(fn) {
  return CLASS_PATTERN.test(fn.toString());
}

function isArray(obj) {
  return Object.prototype.toString.call(obj) === '[object Array]';
}

function hasOwnProp(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function annotate() {
  var args = Array.prototype.slice.call(arguments);

  if (args.length === 1 && isArray(args[0])) {
    args = args[0];
  }

  var fn = args.pop();

  fn.$inject = args;

  return fn;
}


// Current limitations:
// - can't put into "function arg" comments
// function /* (no parenthesis like this) */ (){}
// function abc( /* xx (no parenthesis like this) */ a, b) {}
//
// Just put the comment before function or inside:
// /* (((this is fine))) */ function(a, b) {}
// function abc(a) { /* (((this is fine))) */}
//
// - can't reliably auto-annotate constructor; we'll match the
// first constructor(...) pattern found which may be the one
// of a nested class, too.

var CONSTRUCTOR_ARGS = /constructor\s*[^(]*\(\s*([^)]*)\)/m;
var FN_ARGS = /^(?:async )?(?:function\s*)?[^(]*\(\s*([^)]*)\)/m;
var FN_ARG = /\/\*([^*]*)\*\//m;

function parseAnnotations(fn) {

  if (typeof fn !== 'function') {
    throw new Error('Cannot annotate "' + fn + '". Expected a function!');
  }

  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);

  // may parse class without constructor
  if (!match) {
    return [];
  }

  return match[1] && match[1].split(',').map(function(arg) {
    match = arg.match(FN_ARG);
    return match ? match[1].trim() : arg.trim();
  }) || [];
}

function Module() {
  var providers = [];

  this.factory = function(name, factory) {
    providers.push([name, 'factory', factory]);
    return this;
  };

  this.value = function(name, value) {
    providers.push([name, 'value', value]);
    return this;
  };

  this.type = function(name, type) {
    providers.push([name, 'type', type]);
    return this;
  };

  this.forEach = function(iterator) {
    providers.forEach(iterator);
  };

}

function Injector(modules, parent) {
  parent = parent || {
    get: function(name, strict) {
      currentlyResolving.push(name);

      if (strict === false) {
        return null;
      } else {
        throw error('No provider for "' + name + '"!');
      }
    }
  };

  var currentlyResolving = [];
  var providers = this._providers = Object.create(parent._providers || null);
  var instances = this._instances = Object.create(null);

  var self = instances.injector = this;

  var error = function(msg) {
    var stack = currentlyResolving.join(' -> ');
    currentlyResolving.length = 0;
    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);
  };

  /**
   * Return a named service.
   *
   * @param {String} name
   * @param {Boolean} [strict=true] if false, resolve missing services to null
   *
   * @return {Object}
   */
  var get = function(name, strict) {
    if (!providers[name] && name.indexOf('.') !== -1) {
      var parts = name.split('.');
      var pivot = get(parts.shift());

      while (parts.length) {
        pivot = pivot[parts.shift()];
      }

      return pivot;
    }

    if (hasOwnProp(instances, name)) {
      return instances[name];
    }

    if (hasOwnProp(providers, name)) {
      if (currentlyResolving.indexOf(name) !== -1) {
        currentlyResolving.push(name);
        throw error('Cannot resolve circular dependency!');
      }

      currentlyResolving.push(name);
      instances[name] = providers[name][0](providers[name][1]);
      currentlyResolving.pop();

      return instances[name];
    }

    return parent.get(name, strict);
  };

  var fnDef = function(fn, locals) {

    if (typeof locals === 'undefined') {
      locals = {};
    }

    if (typeof fn !== 'function') {
      if (isArray(fn)) {
        fn = annotate(fn.slice());
      } else {
        throw new Error('Cannot invoke "' + fn + '". Expected a function!');
      }
    }

    var inject = fn.$inject || parseAnnotations(fn);
    var dependencies = inject.map(function(dep) {
      if (hasOwnProp(locals, dep)) {
        return locals[dep];
      } else {
        return get(dep);
      }
    });

    return {
      fn: fn,
      dependencies: dependencies
    };
  };

  var instantiate = function(Type) {
    var def = fnDef(Type);

    var fn = def.fn,
        dependencies = def.dependencies;

    // instantiate var args constructor
    var Constructor = Function.prototype.bind.apply(fn, [ null ].concat(dependencies));

    return new Constructor();
  };

  var invoke = function(func, context, locals) {
    var def = fnDef(func, locals);

    var fn = def.fn,
        dependencies = def.dependencies;

    return fn.apply(context, dependencies);
  };


  var createPrivateInjectorFactory = function(privateChildInjector) {
    return annotate(function(key) {
      return privateChildInjector.get(key);
    });
  };

  var createChild = function(modules, forceNewInstances) {
    if (forceNewInstances && forceNewInstances.length) {
      var fromParentModule = Object.create(null);
      var matchedScopes = Object.create(null);

      var privateInjectorsCache = [];
      var privateChildInjectors = [];
      var privateChildFactories = [];

      var provider;
      var cacheIdx;
      var privateChildInjector;
      var privateChildInjectorFactory;
      for (var name in providers) {
        provider = providers[name];

        if (forceNewInstances.indexOf(name) !== -1) {
          if (provider[2] === 'private') {
            cacheIdx = privateInjectorsCache.indexOf(provider[3]);
            if (cacheIdx === -1) {
              privateChildInjector = provider[3].createChild([], forceNewInstances);
              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
              privateInjectorsCache.push(provider[3]);
              privateChildInjectors.push(privateChildInjector);
              privateChildFactories.push(privateChildInjectorFactory);
              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];
            } else {
              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];
            }
          } else {
            fromParentModule[name] = [provider[2], provider[1]];
          }
          matchedScopes[name] = true;
        }

        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {
          /* jshint -W083 */
          forceNewInstances.forEach(function(scope) {
            if (provider[1].$scope.indexOf(scope) !== -1) {
              fromParentModule[name] = [provider[2], provider[1]];
              matchedScopes[scope] = true;
            }
          });
        }
      }

      forceNewInstances.forEach(function(scope) {
        if (!matchedScopes[scope]) {
          throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
        }
      });

      modules.unshift(fromParentModule);
    }

    return new Injector(modules, self);
  };

  var factoryMap = {
    factory: invoke,
    type: instantiate,
    value: function(value) {
      return value;
    }
  };

  modules.forEach(function(module) {

    function arrayUnwrap(type, value) {
      if (type !== 'value' && isArray(value)) {
        value = annotate(value.slice());
      }

      return value;
    }

    // TODO(vojta): handle wrong inputs (modules)
    if (module instanceof Module) {
      module.forEach(function(provider) {
        var name = provider[0];
        var type = provider[1];
        var value = provider[2];

        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
      });
    } else if (typeof module === 'object') {
      if (module.__exports__) {
        var clonedModule = Object.keys(module).reduce(function(m, key) {
          if (key.substring(0, 2) !== '__') {
            m[key] = module[key];
          }
          return m;
        }, Object.create(null));

        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);
        var getFromPrivateInjector = annotate(function(key) {
          return privateInjector.get(key);
        });
        module.__exports__.forEach(function(key) {
          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];
        });
      } else {
        Object.keys(module).forEach(function(name) {
          if (module[name][2] === 'private') {
            providers[name] = module[name];
            return;
          }

          var type = module[name][0];
          var value = module[name][1];

          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
        });
      }
    }
  });

  // public API
  this.get = get;
  this.invoke = invoke;
  this.instantiate = instantiate;
  this.createChild = createChild;
}




/***/ }),

/***/ "./node_modules/hammerjs/hammer.js":
/*!*****************************************!*\
  !*** ./node_modules/hammerjs/hammer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return Hammer;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

})(window, document, 'Hammer');


/***/ }),

/***/ "./node_modules/ids/dist/index.esm.js":
/*!********************************************!*\
  !*** ./node_modules/ids/dist/index.esm.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var hat_1 = createCommonjsModule(function (module) {
var hat = module.exports = function (bits, base) {
    if (!base) base = 16;
    if (bits === undefined) bits = 128;
    if (bits <= 0) return '0';
    
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    }
    
    var rem = digits - Math.floor(digits);
    
    var res = '';
    
    for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    
    if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base)
    }
    else return res;
};

hat.rack = function (bits, base, expandBy) {
    var fn = function (data) {
        var iters = 0;
        do {
            if (iters ++ > 10) {
                if (expandBy) bits += expandBy;
                else throw new Error('too many ID collisions, use more bits')
            }
            
            var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        
        hats[id] = data;
        return id;
    };
    var hats = fn.hats = {};
    
    fn.get = function (id) {
        return fn.hats[id];
    };
    
    fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
    };
    
    fn.bits = bits || 128;
    fn.base = base || 16;
    return fn;
};
});

/**
 * Create a new id generator / cache instance.
 *
 * You may optionally provide a seed that is used internally.
 *
 * @param {Seed} seed
 */

function Ids(seed) {
  if (!(this instanceof Ids)) {
    return new Ids(seed);
  }

  seed = seed || [128, 36, 1];
  this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;
}
/**
 * Generate a next id.
 *
 * @param {Object} [element] element to bind the id to
 *
 * @return {String} id
 */

Ids.prototype.next = function (element) {
  return this._seed(element || true);
};
/**
 * Generate a next id with a given prefix.
 *
 * @param {Object} [element] element to bind the id to
 *
 * @return {String} id
 */


Ids.prototype.nextPrefixed = function (prefix, element) {
  var id;

  do {
    id = prefix + this.next(true);
  } while (this.assigned(id)); // claim {prefix}{random}


  this.claim(id, element); // return

  return id;
};
/**
 * Manually claim an existing id.
 *
 * @param {String} id
 * @param {String} [element] element the id is claimed by
 */


Ids.prototype.claim = function (id, element) {
  this._seed.set(id, element || true);
};
/**
 * Returns true if the given id has already been assigned.
 *
 * @param  {String} id
 * @return {Boolean}
 */


Ids.prototype.assigned = function (id) {
  return this._seed.get(id) || false;
};
/**
 * Unclaim an id.
 *
 * @param  {String} id the id to unclaim
 */


Ids.prototype.unclaim = function (id) {
  delete this._seed.hats[id];
};
/**
 * Clear all claimed ids.
 */


Ids.prototype.clear = function () {
  var hats = this._seed.hats,
      id;

  for (id in hats) {
    this.unclaim(id);
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Ids);
//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/min-dash/dist/index.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/min-dash/dist/index.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assign": () => (/* binding */ assign),
/* harmony export */   "bind": () => (/* binding */ bind),
/* harmony export */   "debounce": () => (/* binding */ debounce),
/* harmony export */   "ensureArray": () => (/* binding */ ensureArray),
/* harmony export */   "every": () => (/* binding */ every),
/* harmony export */   "filter": () => (/* binding */ filter),
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "findIndex": () => (/* binding */ findIndex),
/* harmony export */   "flatten": () => (/* binding */ flatten),
/* harmony export */   "forEach": () => (/* binding */ forEach),
/* harmony export */   "get": () => (/* binding */ get),
/* harmony export */   "groupBy": () => (/* binding */ groupBy),
/* harmony export */   "has": () => (/* binding */ has),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isDefined": () => (/* binding */ isDefined),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isNil": () => (/* binding */ isNil),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined),
/* harmony export */   "keys": () => (/* binding */ keys),
/* harmony export */   "map": () => (/* binding */ map),
/* harmony export */   "matchPattern": () => (/* binding */ matchPattern),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "omit": () => (/* binding */ omit),
/* harmony export */   "pick": () => (/* binding */ pick),
/* harmony export */   "reduce": () => (/* binding */ reduce),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "size": () => (/* binding */ size),
/* harmony export */   "some": () => (/* binding */ some),
/* harmony export */   "sortBy": () => (/* binding */ sortBy),
/* harmony export */   "throttle": () => (/* binding */ throttle),
/* harmony export */   "unionBy": () => (/* binding */ unionBy),
/* harmony export */   "uniqueBy": () => (/* binding */ uniqueBy),
/* harmony export */   "values": () => (/* binding */ values),
/* harmony export */   "without": () => (/* binding */ without)
/* harmony export */ });
/**
 * Flatten array, one level deep.
 *
 * @param {Array<?>} arr
 *
 * @return {Array<?>}
 */
function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

var nativeToString = Object.prototype.toString;
var nativeHasOwnProperty = Object.prototype.hasOwnProperty;
function isUndefined(obj) {
  return obj === undefined;
}
function isDefined(obj) {
  return obj !== undefined;
}
function isNil(obj) {
  return obj == null;
}
function isArray(obj) {
  return nativeToString.call(obj) === '[object Array]';
}
function isObject(obj) {
  return nativeToString.call(obj) === '[object Object]';
}
function isNumber(obj) {
  return nativeToString.call(obj) === '[object Number]';
}
function isFunction(obj) {
  var tag = nativeToString.call(obj);
  return tag === '[object Function]' || tag === '[object AsyncFunction]' || tag === '[object GeneratorFunction]' || tag === '[object AsyncGeneratorFunction]' || tag === '[object Proxy]';
}
function isString(obj) {
  return nativeToString.call(obj) === '[object String]';
}
/**
 * Ensure collection is an array.
 *
 * @param {Object} obj
 */

function ensureArray(obj) {
  if (isArray(obj)) {
    return;
  }

  throw new Error('must supply array');
}
/**
 * Return true, if target owns a property with the given key.
 *
 * @param {Object} target
 * @param {String} key
 *
 * @return {Boolean}
 */

function has(target, key) {
  return nativeHasOwnProperty.call(target, key);
}

/**
 * Find element in collection.
 *
 * @param  {Array|Object} collection
 * @param  {Function|Object} matcher
 *
 * @return {Object}
 */

function find(collection, matcher) {
  matcher = toMatcher(matcher);
  var match;
  forEach(collection, function (val, key) {
    if (matcher(val, key)) {
      match = val;
      return false;
    }
  });
  return match;
}
/**
 * Find element index in collection.
 *
 * @param  {Array|Object} collection
 * @param  {Function} matcher
 *
 * @return {Object}
 */

function findIndex(collection, matcher) {
  matcher = toMatcher(matcher);
  var idx = isArray(collection) ? -1 : undefined;
  forEach(collection, function (val, key) {
    if (matcher(val, key)) {
      idx = key;
      return false;
    }
  });
  return idx;
}
/**
 * Find element in collection.
 *
 * @param  {Array|Object} collection
 * @param  {Function} matcher
 *
 * @return {Array} result
 */

function filter(collection, matcher) {
  var result = [];
  forEach(collection, function (val, key) {
    if (matcher(val, key)) {
      result.push(val);
    }
  });
  return result;
}
/**
 * Iterate over collection; returning something
 * (non-undefined) will stop iteration.
 *
 * @param  {Array|Object} collection
 * @param  {Function} iterator
 *
 * @return {Object} return result that stopped the iteration
 */

function forEach(collection, iterator) {
  var val, result;

  if (isUndefined(collection)) {
    return;
  }

  var convertKey = isArray(collection) ? toNum : identity;

  for (var key in collection) {
    if (has(collection, key)) {
      val = collection[key];
      result = iterator(val, convertKey(key));

      if (result === false) {
        return val;
      }
    }
  }
}
/**
 * Return collection without element.
 *
 * @param  {Array} arr
 * @param  {Function} matcher
 *
 * @return {Array}
 */

function without(arr, matcher) {
  if (isUndefined(arr)) {
    return [];
  }

  ensureArray(arr);
  matcher = toMatcher(matcher);
  return arr.filter(function (el, idx) {
    return !matcher(el, idx);
  });
}
/**
 * Reduce collection, returning a single result.
 *
 * @param  {Object|Array} collection
 * @param  {Function} iterator
 * @param  {Any} result
 *
 * @return {Any} result returned from last iterator
 */

function reduce(collection, iterator, result) {
  forEach(collection, function (value, idx) {
    result = iterator(result, value, idx);
  });
  return result;
}
/**
 * Return true if every element in the collection
 * matches the criteria.
 *
 * @param  {Object|Array} collection
 * @param  {Function} matcher
 *
 * @return {Boolean}
 */

function every(collection, matcher) {
  return !!reduce(collection, function (matches, val, key) {
    return matches && matcher(val, key);
  }, true);
}
/**
 * Return true if some elements in the collection
 * match the criteria.
 *
 * @param  {Object|Array} collection
 * @param  {Function} matcher
 *
 * @return {Boolean}
 */

function some(collection, matcher) {
  return !!find(collection, matcher);
}
/**
 * Transform a collection into another collection
 * by piping each member through the given fn.
 *
 * @param  {Object|Array}   collection
 * @param  {Function} fn
 *
 * @return {Array} transformed collection
 */

function map(collection, fn) {
  var result = [];
  forEach(collection, function (val, key) {
    result.push(fn(val, key));
  });
  return result;
}
/**
 * Get the collections keys.
 *
 * @param  {Object|Array} collection
 *
 * @return {Array}
 */

function keys(collection) {
  return collection && Object.keys(collection) || [];
}
/**
 * Shorthand for `keys(o).length`.
 *
 * @param  {Object|Array} collection
 *
 * @return {Number}
 */

function size(collection) {
  return keys(collection).length;
}
/**
 * Get the values in the collection.
 *
 * @param  {Object|Array} collection
 *
 * @return {Array}
 */

function values(collection) {
  return map(collection, function (val) {
    return val;
  });
}
/**
 * Group collection members by attribute.
 *
 * @param  {Object|Array} collection
 * @param  {Function} extractor
 *
 * @return {Object} map with { attrValue => [ a, b, c ] }
 */

function groupBy(collection, extractor) {
  var grouped = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  extractor = toExtractor(extractor);
  forEach(collection, function (val) {
    var discriminator = extractor(val) || '_';
    var group = grouped[discriminator];

    if (!group) {
      group = grouped[discriminator] = [];
    }

    group.push(val);
  });
  return grouped;
}
function uniqueBy(extractor) {
  extractor = toExtractor(extractor);
  var grouped = {};

  for (var _len = arguments.length, collections = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    collections[_key - 1] = arguments[_key];
  }

  forEach(collections, function (c) {
    return groupBy(c, extractor, grouped);
  });
  var result = map(grouped, function (val, key) {
    return val[0];
  });
  return result;
}
var unionBy = uniqueBy;
/**
 * Sort collection by criteria.
 *
 * @param  {Object|Array} collection
 * @param  {String|Function} extractor
 *
 * @return {Array}
 */

function sortBy(collection, extractor) {
  extractor = toExtractor(extractor);
  var sorted = [];
  forEach(collection, function (value, key) {
    var disc = extractor(value, key);
    var entry = {
      d: disc,
      v: value
    };

    for (var idx = 0; idx < sorted.length; idx++) {
      var d = sorted[idx].d;

      if (disc < d) {
        sorted.splice(idx, 0, entry);
        return;
      }
    } // not inserted, append (!)


    sorted.push(entry);
  });
  return map(sorted, function (e) {
    return e.v;
  });
}
/**
 * Create an object pattern matcher.
 *
 * @example
 *
 * const matcher = matchPattern({ id: 1 });
 *
 * var element = find(elements, matcher);
 *
 * @param  {Object} pattern
 *
 * @return {Function} matcherFn
 */

function matchPattern(pattern) {
  return function (el) {
    return every(pattern, function (val, key) {
      return el[key] === val;
    });
  };
}

function toExtractor(extractor) {
  return isFunction(extractor) ? extractor : function (e) {
    return e[extractor];
  };
}

function toMatcher(matcher) {
  return isFunction(matcher) ? matcher : function (e) {
    return e === matcher;
  };
}

function identity(arg) {
  return arg;
}

function toNum(arg) {
  return Number(arg);
}

/**
 * Debounce fn, calling it only once if
 * the given time elapsed between calls.
 *
 * @param  {Function} fn
 * @param  {Number} timeout
 *
 * @return {Function} debounced function
 */
function debounce(fn, timeout) {
  var timer;
  var lastArgs;
  var lastThis;
  var lastNow;

  function fire() {
    var now = Date.now();
    var scheduledDiff = lastNow + timeout - now;

    if (scheduledDiff > 0) {
      return schedule(scheduledDiff);
    }

    fn.apply(lastThis, lastArgs);
    timer = lastNow = lastArgs = lastThis = undefined;
  }

  function schedule(timeout) {
    timer = setTimeout(fire, timeout);
  }

  return function () {
    lastNow = Date.now();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    lastArgs = args;
    lastThis = this; // ensure an execution is scheduled

    if (!timer) {
      schedule(timeout);
    }
  };
}
/**
 * Throttle fn, calling at most once
 * in the given interval.
 *
 * @param  {Function} fn
 * @param  {Number} interval
 *
 * @return {Function} throttled function
 */

function throttle(fn, interval) {
  var throttling = false;
  return function () {
    if (throttling) {
      return;
    }

    fn.apply(void 0, arguments);
    throttling = true;
    setTimeout(function () {
      throttling = false;
    }, interval);
  };
}
/**
 * Bind function against target <this>.
 *
 * @param  {Function} fn
 * @param  {Object}   target
 *
 * @return {Function} bound function
 */

function bind(fn, target) {
  return fn.bind(target);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * Convenience wrapper for `Object.assign`.
 *
 * @param {Object} target
 * @param {...Object} others
 *
 * @return {Object} the target
 */

function assign(target) {
  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    others[_key - 1] = arguments[_key];
  }

  return _extends.apply(void 0, [target].concat(others));
}
/**
 * Sets a nested property of a given object to the specified value.
 *
 * This mutates the object and returns it.
 *
 * @param {Object} target The target of the set operation.
 * @param {(string|number)[]} path The path to the nested value.
 * @param {any} value The value to set.
 */

function set(target, path, value) {
  var currentTarget = target;
  forEach(path, function (key, idx) {
    if (key === '__proto__') {
      throw new Error('illegal key: __proto__');
    }

    var nextKey = path[idx + 1];
    var nextTarget = currentTarget[key];

    if (isDefined(nextKey) && isNil(nextTarget)) {
      nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];
    }

    if (isUndefined(nextKey)) {
      if (isUndefined(value)) {
        delete currentTarget[key];
      } else {
        currentTarget[key] = value;
      }
    } else {
      currentTarget = nextTarget;
    }
  });
  return target;
}
/**
 * Gets a nested property of a given object.
 *
 * @param {Object} target The target of the get operation.
 * @param {(string|number)[]} path The path to the nested value.
 * @param {any} [defaultValue] The value to return if no value exists.
 */

function get(target, path, defaultValue) {
  var currentTarget = target;
  forEach(path, function (key) {
    // accessing nil property yields <undefined>
    if (isNil(currentTarget)) {
      currentTarget = undefined;
      return false;
    }

    currentTarget = currentTarget[key];
  });
  return isUndefined(currentTarget) ? defaultValue : currentTarget;
}
/**
 * Pick given properties from the target object.
 *
 * @param {Object} target
 * @param {Array} properties
 *
 * @return {Object} target
 */

function pick(target, properties) {
  var result = {};
  var obj = Object(target);
  forEach(properties, function (prop) {
    if (prop in obj) {
      result[prop] = target[prop];
    }
  });
  return result;
}
/**
 * Pick all target properties, excluding the given ones.
 *
 * @param {Object} target
 * @param {Array} properties
 *
 * @return {Object} target
 */

function omit(target, properties) {
  var result = {};
  var obj = Object(target);
  forEach(obj, function (prop, key) {
    if (properties.indexOf(key) === -1) {
      result[key] = prop;
    }
  });
  return result;
}
/**
 * Recursively merge `...sources` into given target.
 *
 * Does support merging objects; does not support merging arrays.
 *
 * @param {Object} target
 * @param {...Object} sources
 *
 * @return {Object} the target
 */

function merge(target) {
  for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    sources[_key2 - 1] = arguments[_key2];
  }

  if (!sources.length) {
    return target;
  }

  forEach(sources, function (source) {
    // skip non-obj sources, i.e. null
    if (!source || !isObject(source)) {
      return;
    }

    forEach(source, function (sourceVal, key) {
      if (key === '__proto__') {
        return;
      }

      var targetVal = target[key];

      if (isObject(sourceVal)) {
        if (!isObject(targetVal)) {
          // override target[key] with object
          targetVal = {};
        }

        target[key] = merge(targetVal, sourceVal);
      } else {
        target[key] = sourceVal;
      }
    });
  });
  return target;
}




/***/ }),

/***/ "./node_modules/min-dom/dist/index.esm.js":
/*!************************************************!*\
  !*** ./node_modules/min-dom/dist/index.esm.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "attr": () => (/* binding */ attr),
/* harmony export */   "classes": () => (/* binding */ classes),
/* harmony export */   "clear": () => (/* binding */ clear),
/* harmony export */   "closest": () => (/* binding */ closest),
/* harmony export */   "delegate": () => (/* binding */ delegate),
/* harmony export */   "domify": () => (/* binding */ domify),
/* harmony export */   "event": () => (/* binding */ componentEvent),
/* harmony export */   "matches": () => (/* binding */ matchesSelector),
/* harmony export */   "query": () => (/* binding */ query),
/* harmony export */   "queryAll": () => (/* binding */ all),
/* harmony export */   "remove": () => (/* binding */ remove)
/* harmony export */ });
/**
 * Set attribute `name` to `val`, or get attr `name`.
 *
 * @param {Element} el
 * @param {String} name
 * @param {String} [val]
 * @api public
 */
function attr(el, name, val) {
  // get
  if (arguments.length == 2) {
    return el.getAttribute(name);
  }

  // remove
  if (val === null) {
    return el.removeAttribute(name);
  }

  // set
  el.setAttribute(name, val);

  return el;
}

var indexOf = [].indexOf;

var indexof = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/**
 * Taken from https://github.com/component/classes
 *
 * Without the component bits.
 */

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

function classes(el) {
  return new ClassList(el);
}

/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function (name) {
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = indexof(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function (name) {
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = indexof(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function (re) {
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function (name, force) {
  // classList
  if (this.list) {
    if ('undefined' !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ('undefined' !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function () {
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has = ClassList.prototype.contains = function (name) {
  return this.list ? this.list.contains(name) : !!~indexof(this.array(), name);
};

/**
 * Remove all children from the given element.
 */
function clear(el) {

  var c;

  while (el.childNodes.length) {
    c = el.childNodes[0];
    el.removeChild(c);
  }

  return el;
}

var proto = typeof Element !== 'undefined' ? Element.prototype : {};
var vendor = proto.matches
  || proto.matchesSelector
  || proto.webkitMatchesSelector
  || proto.mozMatchesSelector
  || proto.msMatchesSelector
  || proto.oMatchesSelector;

var matchesSelector = match;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match(el, selector) {
  if (!el || el.nodeType !== 1) return false;
  if (vendor) return vendor.call(el, selector);
  var nodes = el.parentNode.querySelectorAll(selector);
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] == el) return true;
  }
  return false;
}

/**
 * Closest
 *
 * @param {Element} el
 * @param {String} selector
 * @param {Boolean} checkYourSelf (optional)
 */
function closest (element, selector, checkYourSelf) {
  var currentElem = checkYourSelf ? element : element.parentNode;

  while (currentElem && currentElem.nodeType !== document.DOCUMENT_NODE && currentElem.nodeType !== document.DOCUMENT_FRAGMENT_NODE) {

    if (matchesSelector(currentElem, selector)) {
      return currentElem;
    }

    currentElem = currentElem.parentNode;
  }

  return matchesSelector(currentElem, selector) ? currentElem : null;
}

var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
    prefix = bind !== 'addEventListener' ? 'on' : '';

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

var bind_1 = function(el, type, fn, capture){
  el[bind](prefix + type, fn, capture || false);
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

var unbind_1 = function(el, type, fn, capture){
  el[unbind](prefix + type, fn, capture || false);
  return fn;
};

var componentEvent = {
	bind: bind_1,
	unbind: unbind_1
};

/**
 * Module dependencies.
 */

/**
 * Delegate event `type` to `selector`
 * and invoke `fn(e)`. A callback function
 * is returned which may be passed to `.unbind()`.
 *
 * @param {Element} el
 * @param {String} selector
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

// Some events don't bubble, so we want to bind to the capture phase instead
// when delegating.
var forceCaptureEvents = ['focus', 'blur'];

function bind$1(el, selector, type, fn, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }

  return componentEvent.bind(el, type, function (e) {
    var target = e.target || e.srcElement;
    e.delegateTarget = closest(target, selector, true, el);
    if (e.delegateTarget) {
      fn.call(el, e);
    }
  }, capture);
}

/**
 * Unbind event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */
function unbind$1(el, type, fn, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }

  return componentEvent.unbind(el, type, fn, capture);
}

var delegate = {
  bind: bind$1,
  unbind: unbind$1
};

/**
 * Expose `parse`.
 */

var domify = parse;

/**
 * Tests for browser support.
 */

var innerHTMLBug = false;
var bugTestDiv;
if (typeof document !== 'undefined') {
  bugTestDiv = document.createElement('div');
  // Setup
  bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
  // Make sure that link elements get serialized correctly by innerHTML
  // This requires a wrapper element in IE
  innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;
  bugTestDiv = undefined;
}

/**
 * Wrap map from jquery.
 */

var map = {
  legend: [1, '<fieldset>', '</fieldset>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  // for script/link/style tags to work in IE6-8, you have to wrap
  // in a div with a non-whitespace character in front, ha!
  _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
};

map.td =
map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

map.option =
map.optgroup = [1, '<select multiple="multiple">', '</select>'];

map.thead =
map.tbody =
map.colgroup =
map.caption =
map.tfoot = [1, '<table>', '</table>'];

map.polyline =
map.ellipse =
map.polygon =
map.circle =
map.text =
map.line =
map.path =
map.rect =
map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">','</svg>'];

/**
 * Parse `html` and return a DOM Node instance, which could be a TextNode,
 * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
 * instance, depending on the contents of the `html` string.
 *
 * @param {String} html - HTML string to "domify"
 * @param {Document} doc - The `document` instance to create the Node for
 * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
 * @api private
 */

function parse(html, doc) {
  if ('string' != typeof html) throw new TypeError('String expected');

  // default to the global `document` object
  if (!doc) doc = document;

  // tag name
  var m = /<([\w:]+)/.exec(html);
  if (!m) return doc.createTextNode(html);

  html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

  var tag = m[1];

  // body support
  if (tag == 'body') {
    var el = doc.createElement('html');
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }

  // wrap map
  var wrap = map[tag] || map._default;
  var depth = wrap[0];
  var prefix = wrap[1];
  var suffix = wrap[2];
  var el = doc.createElement('div');
  el.innerHTML = prefix + html + suffix;
  while (depth--) el = el.lastChild;

  // one element
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }

  // several elements
  var fragment = doc.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }

  return fragment;
}

function query(selector, el) {
  el = el || document;

  return el.querySelector(selector);
}

function all(selector, el) {
  el = el || document;

  return el.querySelectorAll(selector);
}

function remove(el) {
  el.parentNode && el.parentNode.removeChild(el);
}




/***/ }),

/***/ "./node_modules/moddle-xml/dist/index.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/moddle-xml/dist/index.esm.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Reader": () => (/* binding */ Reader),
/* harmony export */   "Writer": () => (/* binding */ Writer)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");
/* harmony import */ var saxen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! saxen */ "./node_modules/saxen/dist/index.esm.js");
/* harmony import */ var moddle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moddle */ "./node_modules/moddle/dist/index.esm.js");




function hasLowerCaseAlias(pkg) {
  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';
}

var DEFAULT_NS_MAP = {
  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',
  'xml': 'http://www.w3.org/XML/1998/namespace'
};

var XSI_TYPE = 'xsi:type';

function serializeFormat(element) {
  return element.xml && element.xml.serialize;
}

function serializeAsType(element) {
  return serializeFormat(element) === XSI_TYPE;
}

function serializeAsProperty(element) {
  return serializeFormat(element) === 'property';
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function aliasToName(aliasNs, pkg) {

  if (!hasLowerCaseAlias(pkg)) {
    return aliasNs.name;
  }

  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);
}

function prefixedToName(nameNs, pkg) {

  var name = nameNs.name,
      localName = nameNs.localName;

  var typePrefix = pkg.xml && pkg.xml.typePrefix;

  if (typePrefix && localName.indexOf(typePrefix) === 0) {
    return nameNs.prefix + ':' + localName.slice(typePrefix.length);
  } else {
    return name;
  }
}

function normalizeXsiTypeName(name, model) {

  var nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name);
  var pkg = model.getPackage(nameNs.prefix);

  return prefixedToName(nameNs, pkg);
}

function error(message) {
  return new Error(message);
}

/**
 * Get the moddle descriptor for a given instance or type.
 *
 * @param  {ModdleElement|Function} element
 *
 * @return {Object} the moddle descriptor
 */
function getModdleDescriptor(element) {
  return element.$descriptor;
}


/**
 * A parse context.
 *
 * @class
 *
 * @param {Object} options
 * @param {ElementHandler} options.rootHandler the root handler for parsing a document
 * @param {boolean} [options.lax=false] whether or not to ignore invalid elements
 */
function Context(options) {

  /**
   * @property {ElementHandler} rootHandler
   */

  /**
   * @property {Boolean} lax
   */

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(this, options);

  this.elementsById = {};
  this.references = [];
  this.warnings = [];

  /**
   * Add an unresolved reference.
   *
   * @param {Object} reference
   */
  this.addReference = function(reference) {
    this.references.push(reference);
  };

  /**
   * Add a processed element.
   *
   * @param {ModdleElement} element
   */
  this.addElement = function(element) {

    if (!element) {
      throw error('expected element');
    }

    var elementsById = this.elementsById;

    var descriptor = getModdleDescriptor(element);

    var idProperty = descriptor.idProperty,
        id;

    if (idProperty) {
      id = element.get(idProperty.name);

      if (id) {

        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar
        if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(id)) {
          throw new Error('illegal ID <' + id + '>');
        }

        if (elementsById[id]) {
          throw error('duplicate ID <' + id + '>');
        }

        elementsById[id] = element;
      }
    }
  };

  /**
   * Add an import warning.
   *
   * @param {Object} warning
   * @param {String} warning.message
   * @param {Error} [warning.error]
   */
  this.addWarning = function(warning) {
    this.warnings.push(warning);
  };
}

function BaseHandler() {}

BaseHandler.prototype.handleEnd = function() {};
BaseHandler.prototype.handleText = function() {};
BaseHandler.prototype.handleNode = function() {};


/**
 * A simple pass through handler that does nothing except for
 * ignoring all input it receives.
 *
 * This is used to ignore unknown elements and
 * attributes.
 */
function NoopHandler() { }

NoopHandler.prototype = Object.create(BaseHandler.prototype);

NoopHandler.prototype.handleNode = function() {
  return this;
};

function BodyHandler() {}

BodyHandler.prototype = Object.create(BaseHandler.prototype);

BodyHandler.prototype.handleText = function(text) {
  this.body = (this.body || '') + text;
};

function ReferenceHandler(property, context) {
  this.property = property;
  this.context = context;
}

ReferenceHandler.prototype = Object.create(BodyHandler.prototype);

ReferenceHandler.prototype.handleNode = function(node) {

  if (this.element) {
    throw error('expected no sub nodes');
  } else {
    this.element = this.createReference(node);
  }

  return this;
};

ReferenceHandler.prototype.handleEnd = function() {
  this.element.id = this.body;
};

ReferenceHandler.prototype.createReference = function(node) {
  return {
    property: this.property.ns.name,
    id: ''
  };
};

function ValueHandler(propertyDesc, element) {
  this.element = element;
  this.propertyDesc = propertyDesc;
}

ValueHandler.prototype = Object.create(BodyHandler.prototype);

ValueHandler.prototype.handleEnd = function() {

  var value = this.body || '',
      element = this.element,
      propertyDesc = this.propertyDesc;

  value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(propertyDesc.type, value);

  if (propertyDesc.isMany) {
    element.get(propertyDesc.name).push(value);
  } else {
    element.set(propertyDesc.name, value);
  }
};


function BaseElementHandler() {}

BaseElementHandler.prototype = Object.create(BodyHandler.prototype);

BaseElementHandler.prototype.handleNode = function(node) {
  var parser = this,
      element = this.element;

  if (!element) {
    element = this.element = this.createElement(node);

    this.context.addElement(element);
  } else {
    parser = this.handleChild(node);
  }

  return parser;
};

/**
 * @class Reader.ElementHandler
 *
 */
function ElementHandler(model, typeName, context) {
  this.model = model;
  this.type = model.getType(typeName);
  this.context = context;
}

ElementHandler.prototype = Object.create(BaseElementHandler.prototype);

ElementHandler.prototype.addReference = function(reference) {
  this.context.addReference(reference);
};

ElementHandler.prototype.handleText = function(text) {

  var element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;

  if (!bodyProperty) {
    throw error('unexpected body text <' + text + '>');
  }

  BodyHandler.prototype.handleText.call(this, text);
};

ElementHandler.prototype.handleEnd = function() {

  var value = this.body,
      element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;

  if (bodyProperty && value !== undefined) {
    value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(bodyProperty.type, value);
    element.set(bodyProperty.name, value);
  }
};

/**
 * Create an instance of the model from the given node.
 *
 * @param  {Element} node the xml node
 */
ElementHandler.prototype.createElement = function(node) {
  var attributes = node.attributes,
      Type = this.type,
      descriptor = getModdleDescriptor(Type),
      context = this.context,
      instance = new Type({}),
      model = this.model,
      propNameNs;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attributes, function(value, name) {

    var prop = descriptor.propertiesByName[name],
        values;

    if (prop && prop.isReference) {

      if (!prop.isMany) {
        context.addReference({
          element: instance,
          property: prop.ns.name,
          id: value
        });
      } else {

        // IDREFS: parse references as whitespace-separated list
        values = value.split(' ');

        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(values, function(v) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: v
          });
        });
      }

    } else {
      if (prop) {
        value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(prop.type, value);
      } else
      if (name !== 'xmlns') {
        propNameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name, descriptor.ns.prefix);

        // check whether attribute is defined in a well-known namespace
        // if that is the case we emit a warning to indicate potential misuse
        if (model.getPackage(propNameNs.prefix)) {

          context.addWarning({
            message: 'unknown attribute <' + name + '>',
            element: instance,
            property: name,
            value: value
          });
        }
      }

      instance.set(name, value);
    }
  });

  return instance;
};

ElementHandler.prototype.getPropertyForNode = function(node) {

  var name = node.name;
  var nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name);

  var type = this.type,
      model = this.model,
      descriptor = getModdleDescriptor(type);

  var propertyName = nameNs.name,
      property = descriptor.propertiesByName[propertyName],
      elementTypeName,
      elementType;

  // search for properties by name first

  if (property && !property.isAttr) {

    if (serializeAsType(property)) {
      elementTypeName = node.attributes[XSI_TYPE];

      // xsi type is optional, if it does not exists the
      // default type is assumed
      if (elementTypeName) {

        // take possible type prefixes from XML
        // into account, i.e.: xsi:type="t{ActualType}"
        elementTypeName = normalizeXsiTypeName(elementTypeName, model);

        elementType = model.getType(elementTypeName);

        return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, property, {
          effectiveType: getModdleDescriptor(elementType).name
        });
      }
    }

    // search for properties by name first
    return property;
  }

  var pkg = model.getPackage(nameNs.prefix);

  if (pkg) {
    elementTypeName = aliasToName(nameNs, pkg);
    elementType = model.getType(elementTypeName);

    // search for collection members later
    property = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.find)(descriptor.properties, function(p) {
      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);
    });

    if (property) {
      return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, property, {
        effectiveType: getModdleDescriptor(elementType).name
      });
    }
  } else {

    // parse unknown element (maybe extension)
    property = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.find)(descriptor.properties, function(p) {
      return !p.isReference && !p.isAttribute && p.type === 'Element';
    });

    if (property) {
      return property;
    }
  }

  throw error('unrecognized element <' + nameNs.name + '>');
};

ElementHandler.prototype.toString = function() {
  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';
};

ElementHandler.prototype.valueHandler = function(propertyDesc, element) {
  return new ValueHandler(propertyDesc, element);
};

ElementHandler.prototype.referenceHandler = function(propertyDesc) {
  return new ReferenceHandler(propertyDesc, this.context);
};

ElementHandler.prototype.handler = function(type) {
  if (type === 'Element') {
    return new GenericElementHandler(this.model, type, this.context);
  } else {
    return new ElementHandler(this.model, type, this.context);
  }
};

/**
 * Handle the child element parsing
 *
 * @param  {Element} node the xml node
 */
ElementHandler.prototype.handleChild = function(node) {
  var propertyDesc, type, element, childHandler;

  propertyDesc = this.getPropertyForNode(node);
  element = this.element;

  type = propertyDesc.effectiveType || propertyDesc.type;

  if ((0,moddle__WEBPACK_IMPORTED_MODULE_1__.isSimpleType)(type)) {
    return this.valueHandler(propertyDesc, element);
  }

  if (propertyDesc.isReference) {
    childHandler = this.referenceHandler(propertyDesc).handleNode(node);
  } else {
    childHandler = this.handler(type).handleNode(node);
  }

  var newElement = childHandler.element;

  // child handles may decide to skip elements
  // by not returning anything
  if (newElement !== undefined) {

    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(newElement);
    } else {
      element.set(propertyDesc.name, newElement);
    }

    if (propertyDesc.isReference) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(newElement, {
        element: element
      });

      this.context.addReference(newElement);
    } else {

      // establish child -> parent relationship
      newElement.$parent = element;
    }
  }

  return childHandler;
};

/**
 * An element handler that performs special validation
 * to ensure the node it gets initialized with matches
 * the handlers type (namespace wise).
 *
 * @param {Moddle} model
 * @param {String} typeName
 * @param {Context} context
 */
function RootElementHandler(model, typeName, context) {
  ElementHandler.call(this, model, typeName, context);
}

RootElementHandler.prototype = Object.create(ElementHandler.prototype);

RootElementHandler.prototype.createElement = function(node) {

  var name = node.name,
      nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name),
      model = this.model,
      type = this.type,
      pkg = model.getPackage(nameNs.prefix),
      typeName = pkg && aliasToName(nameNs, pkg) || name;

  // verify the correct namespace if we parse
  // the first element in the handler tree
  //
  // this ensures we don't mistakenly import wrong namespace elements
  if (!type.hasType(typeName)) {
    throw error('unexpected element <' + node.originalName + '>');
  }

  return ElementHandler.prototype.createElement.call(this, node);
};


function GenericElementHandler(model, typeName, context) {
  this.model = model;
  this.context = context;
}

GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);

GenericElementHandler.prototype.createElement = function(node) {

  var name = node.name,
      ns = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name),
      prefix = ns.prefix,
      uri = node.ns[prefix + '$uri'],
      attributes = node.attributes;

  return this.model.createAny(name, uri, attributes);
};

GenericElementHandler.prototype.handleChild = function(node) {

  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),
      element = this.element;

  var newElement = handler.element,
      children;

  if (newElement !== undefined) {
    children = element.$children = element.$children || [];
    children.push(newElement);

    // establish child -> parent relationship
    newElement.$parent = element;
  }

  return handler;
};

GenericElementHandler.prototype.handleEnd = function() {
  if (this.body) {
    this.element.$body = this.body;
  }
};

/**
 * A reader for a meta-model
 *
 * @param {Object} options
 * @param {Model} options.model used to read xml files
 * @param {Boolean} options.lax whether to make parse errors warnings
 */
function Reader(options) {

  if (options instanceof moddle__WEBPACK_IMPORTED_MODULE_1__.Moddle) {
    options = {
      model: options
    };
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(this, { lax: false }, options);
}

/**
 * The fromXML result.
 *
 * @typedef {Object} ParseResult
 *
 * @property {ModdleElement} rootElement
 * @property {Array<Object>} references
 * @property {Array<Error>} warnings
 * @property {Object} elementsById - a mapping containing each ID -> ModdleElement
 */

/**
 * The fromXML result.
 *
 * @typedef {Error} ParseError
 *
 * @property {Array<Error>} warnings
 */

/**
 * Parse the given XML into a moddle document tree.
 *
 * @param {String} xml
 * @param {ElementHandler|Object} options or rootHandler
 *
 * @returns {Promise<ParseResult, ParseError>}
 */
Reader.prototype.fromXML = function(xml, options, done) {

  var rootHandler = options.rootHandler;

  if (options instanceof ElementHandler) {

    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)
    rootHandler = options;
    options = {};
  } else {
    if (typeof options === 'string') {

      // rootHandler passed via (xml, 'someString', ...)
      rootHandler = this.handler(options);
      options = {};
    } else if (typeof rootHandler === 'string') {

      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)
      rootHandler = this.handler(rootHandler);
    }
  }

  var model = this.model,
      lax = this.lax;

  var context = new Context((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, options, { rootHandler: rootHandler })),
      parser = new saxen__WEBPACK_IMPORTED_MODULE_0__.Parser({ proxy: true }),
      stack = createStack();

  rootHandler.context = context;

  // push root handler
  stack.push(rootHandler);


  /**
   * Handle error.
   *
   * @param  {Error} err
   * @param  {Function} getContext
   * @param  {boolean} lax
   *
   * @return {boolean} true if handled
   */
  function handleError(err, getContext, lax) {

    var ctx = getContext();

    var line = ctx.line,
        column = ctx.column,
        data = ctx.data;

    // we receive the full context data here,
    // for elements trim down the information
    // to the tag name, only
    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {
      data = data.slice(0, data.indexOf(' ')) + '>';
    }

    var message =
      'unparsable content ' + (data ? data + ' ' : '') + 'detected\n\t' +
        'line: ' + line + '\n\t' +
        'column: ' + column + '\n\t' +
        'nested error: ' + err.message;

    if (lax) {
      context.addWarning({
        message: message,
        error: err
      });

      return true;
    } else {
      throw error(message);
    }
  }

  function handleWarning(err, getContext) {

    // just like handling errors in <lax=true> mode
    return handleError(err, getContext, true);
  }

  /**
   * Resolve collected references on parse end.
   */
  function resolveReferences() {

    var elementsById = context.elementsById;
    var references = context.references;

    var i, r;

    for (i = 0; (r = references[i]); i++) {
      var element = r.element;
      var reference = elementsById[r.id];
      var property = getModdleDescriptor(element).propertiesByName[r.property];

      if (!reference) {
        context.addWarning({
          message: 'unresolved reference <' + r.id + '>',
          element: r.element,
          property: r.property,
          value: r.id
        });
      }

      if (property.isMany) {
        var collection = element.get(property.name),
            idx = collection.indexOf(r);

        // we replace an existing place holder (idx != -1) or
        // append to the collection instead
        if (idx === -1) {
          idx = collection.length;
        }

        if (!reference) {

          // remove unresolvable reference
          collection.splice(idx, 1);
        } else {

          // add or update reference in collection
          collection[idx] = reference;
        }
      } else {
        element.set(property.name, reference);
      }
    }
  }

  function handleClose() {
    stack.pop().handleEnd();
  }

  var PREAMBLE_START_PATTERN = /^<\?xml /i;

  var ENCODING_PATTERN = / encoding="([^"]+)"/i;

  var UTF_8_PATTERN = /^utf-8$/i;

  function handleQuestion(question) {

    if (!PREAMBLE_START_PATTERN.test(question)) {
      return;
    }

    var match = ENCODING_PATTERN.exec(question);
    var encoding = match && match[1];

    if (!encoding || UTF_8_PATTERN.test(encoding)) {
      return;
    }

    context.addWarning({
      message:
        'unsupported document encoding <' + encoding + '>, ' +
        'falling back to UTF-8'
    });
  }

  function handleOpen(node, getContext) {
    var handler = stack.peek();

    try {
      stack.push(handler.handleNode(node));
    } catch (err) {

      if (handleError(err, getContext, lax)) {
        stack.push(new NoopHandler());
      }
    }
  }

  function handleCData(text, getContext) {

    try {
      stack.peek().handleText(text);
    } catch (err) {
      handleWarning(err, getContext);
    }
  }

  function handleText(text, getContext) {

    // strip whitespace only nodes, i.e. before
    // <!CDATA[ ... ]> sections and in between tags
    text = text.trim();

    if (!text) {
      return;
    }

    handleCData(text, getContext);
  }

  var uriMap = model.getPackages().reduce(function(uriMap, p) {
    uriMap[p.uri] = p.prefix;

    return uriMap;
  }, {
    'http://www.w3.org/XML/1998/namespace': 'xml' // add default xml ns
  });
  parser
    .ns(uriMap)
    .on('openTag', function(obj, decodeStr, selfClosing, getContext) {

      // gracefully handle unparsable attributes (attrs=false)
      var attrs = obj.attrs || {};

      var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {
        var value = decodeStr(attrs[key]);

        d[key] = value;

        return d;
      }, {});

      var node = {
        name: obj.name,
        originalName: obj.originalName,
        attributes: decodedAttrs,
        ns: obj.ns
      };

      handleOpen(node, getContext);
    })
    .on('question', handleQuestion)
    .on('closeTag', handleClose)
    .on('cdata', handleCData)
    .on('text', function(text, decodeEntities, getContext) {
      handleText(decodeEntities(text), getContext);
    })
    .on('error', handleError)
    .on('warn', handleWarning);

  // async XML parsing to make sure the execution environment
  // (node or brower) is kept responsive and that certain optimization
  // strategies can kick in.
  return new Promise(function(resolve, reject) {

    var err;

    try {
      parser.parse(xml);

      resolveReferences();
    } catch (e) {
      err = e;
    }

    var rootElement = rootHandler.element;

    if (!err && !rootElement) {
      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');
    }

    var warnings = context.warnings;
    var references = context.references;
    var elementsById = context.elementsById;

    if (err) {
      err.warnings = warnings;

      return reject(err);
    } else {
      return resolve({
        rootElement: rootElement,
        elementsById: elementsById,
        references: references,
        warnings: warnings
      });
    }
  });
};

Reader.prototype.handler = function(name) {
  return new RootElementHandler(this.model, name);
};


// helpers //////////////////////////

function createStack() {
  var stack = [];

  Object.defineProperty(stack, 'peek', {
    value: function() {
      return this[this.length - 1];
    }
  });

  return stack;
}

var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';

var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
var ESCAPE_CHARS = /<|>|&/g;


function Namespaces(parent) {

  var prefixMap = {};
  var uriMap = {};
  var used = {};

  var wellknown = [];
  var custom = [];

  // API

  this.byUri = function(uri) {
    return uriMap[uri] || (
      parent && parent.byUri(uri)
    );
  };

  this.add = function(ns, isWellknown) {

    uriMap[ns.uri] = ns;

    if (isWellknown) {
      wellknown.push(ns);
    } else {
      custom.push(ns);
    }

    this.mapPrefix(ns.prefix, ns.uri);
  };

  this.uriByPrefix = function(prefix) {
    return prefixMap[prefix || 'xmlns'];
  };

  this.mapPrefix = function(prefix, uri) {
    prefixMap[prefix || 'xmlns'] = uri;
  };

  this.getNSKey = function(ns) {
    return (ns.prefix !== undefined) ? (ns.uri + '|' + ns.prefix) : ns.uri;
  };

  this.logUsed = function(ns) {

    var uri = ns.uri;
    var nsKey = this.getNSKey(ns);

    used[nsKey] = this.byUri(uri);

    // Inform parent recursively about the usage of this NS
    if (parent) {
      parent.logUsed(ns);
    }
  };

  this.getUsed = function(ns) {

    function isUsed(ns) {
      var nsKey = self.getNSKey(ns);

      return used[nsKey];
    }

    var self = this;

    var allNs = [].concat(wellknown, custom);

    return allNs.filter(isUsed);
  };

}

function lower(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}

function nameToAlias(name, pkg) {
  if (hasLowerCaseAlias(pkg)) {
    return lower(name);
  } else {
    return name;
  }
}

function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}

function nsName(ns) {
  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(ns)) {
    return ns;
  } else {
    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;
  }
}

function getNsAttrs(namespaces) {

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.map)(namespaces.getUsed(), function(ns) {
    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');
    return { name: name, value: ns.uri };
  });

}

function getElementNs(ns, descriptor) {
  if (descriptor.isGeneric) {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: descriptor.ns.localName }, ns);
  } else {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);
  }
}

function getPropertyNs(ns, descriptor) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: descriptor.ns.localName }, ns);
}

function getSerializableProperties(element) {
  var descriptor = element.$descriptor;

  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(descriptor.properties, function(p) {
    var name = p.name;

    if (p.isVirtual) {
      return false;
    }

    // do not serialize defaults
    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_2__.has)(element, name)) {
      return false;
    }

    var value = element[name];

    // do not serialize default equals
    if (value === p.default) {
      return false;
    }

    // do not serialize null properties
    if (value === null) {
      return false;
    }

    return p.isMany ? value.length : true;
  });
}

var ESCAPE_ATTR_MAP = {
  '\n': '#10',
  '\n\r': '#10',
  '"': '#34',
  '\'': '#39',
  '<': '#60',
  '>': '#62',
  '&': '#38'
};

var ESCAPE_MAP = {
  '<': 'lt',
  '>': 'gt',
  '&': 'amp'
};

function escape(str, charPattern, replaceMap) {

  // ensure we are handling strings here
  str = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(str) ? str : '' + str;

  return str.replace(charPattern, function(s) {
    return '&' + replaceMap[s] + ';';
  });
}

/**
 * Escape a string attribute to not contain any bad values (line breaks, '"', ...)
 *
 * @param {String} str the string to escape
 * @return {String} the escaped string
 */
function escapeAttr(str) {
  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
}

function escapeBody(str) {
  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);
}

function filterAttributes(props) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(props, function(p) { return p.isAttr; });
}

function filterContained(props) {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(props, function(p) { return !p.isAttr; });
}


function ReferenceSerializer(tagName) {
  this.tagName = tagName;
}

ReferenceSerializer.prototype.build = function(element) {
  this.element = element;
  return this;
};

ReferenceSerializer.prototype.serializeTo = function(writer) {
  writer
    .appendIndent()
    .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')
    .appendNewLine();
};

function BodySerializer() {}

BodySerializer.prototype.serializeValue =
BodySerializer.prototype.serializeTo = function(writer) {
  writer.append(
    this.escape
      ? escapeBody(this.value)
      : this.value
  );
};

BodySerializer.prototype.build = function(prop, value) {
  this.value = value;

  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {
    this.escape = true;
  }

  return this;
};

function ValueSerializer(tagName) {
  this.tagName = tagName;
}

inherits(ValueSerializer, BodySerializer);

ValueSerializer.prototype.serializeTo = function(writer) {

  writer
    .appendIndent()
    .append('<' + this.tagName + '>');

  this.serializeValue(writer);

  writer
    .append('</' + this.tagName + '>')
    .appendNewLine();
};

function ElementSerializer(parent, propertyDescriptor) {
  this.body = [];
  this.attrs = [];

  this.parent = parent;
  this.propertyDescriptor = propertyDescriptor;
}

ElementSerializer.prototype.build = function(element) {
  this.element = element;

  var elementDescriptor = element.$descriptor,
      propertyDescriptor = this.propertyDescriptor;

  var otherAttrs,
      properties;

  var isGeneric = elementDescriptor.isGeneric;

  if (isGeneric) {
    otherAttrs = this.parseGeneric(element);
  } else {
    otherAttrs = this.parseNsAttributes(element);
  }

  if (propertyDescriptor) {
    this.ns = this.nsPropertyTagName(propertyDescriptor);
  } else {
    this.ns = this.nsTagName(elementDescriptor);
  }

  // compute tag name
  this.tagName = this.addTagName(this.ns);

  if (!isGeneric) {
    properties = getSerializableProperties(element);

    this.parseAttributes(filterAttributes(properties));
    this.parseContainments(filterContained(properties));
  }

  this.parseGenericAttributes(element, otherAttrs);

  return this;
};

ElementSerializer.prototype.nsTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getElementNs(effectiveNs, descriptor);
};

ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getPropertyNs(effectiveNs, descriptor);
};

ElementSerializer.prototype.isLocalNs = function(ns) {
  return ns.uri === this.ns.uri;
};

/**
 * Get the actual ns attribute name for the given element.
 *
 * @param {Object} element
 * @param {Boolean} [element.inherited=false]
 *
 * @return {Object} nsName
 */
ElementSerializer.prototype.nsAttributeName = function(element) {

  var ns;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(element)) {
    ns = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(element);
  } else {
    ns = element.ns;
  }

  // return just local name for inherited attributes
  if (element.inherited) {
    return { localName: ns.localName };
  }

  // parse + log effective ns
  var effectiveNs = this.logNamespaceUsed(ns);

  // LOG ACTUAL namespace use
  this.getNamespaces().logUsed(effectiveNs);

  // strip prefix if same namespace like parent
  if (this.isLocalNs(effectiveNs)) {
    return { localName: ns.localName };
  } else {
    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: ns.localName }, effectiveNs);
  }
};

ElementSerializer.prototype.parseGeneric = function(element) {

  var self = this,
      body = this.body;

  var attributes = [];

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(element, function(val, key) {

    var nonNsAttr;

    if (key === '$body') {
      body.push(new BodySerializer().build({ type: 'String' }, val));
    } else
    if (key === '$children') {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(val, function(child) {
        body.push(new ElementSerializer(self).build(child));
      });
    } else
    if (key.indexOf('$') !== 0) {
      nonNsAttr = self.parseNsAttribute(element, key, val);

      if (nonNsAttr) {
        attributes.push({ name: key, value: val });
      }
    }
  });

  return attributes;
};

ElementSerializer.prototype.parseNsAttribute = function(element, name, value) {
  var model = element.$model;

  var nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name);

  var ns;

  // parse xmlns:foo="http://foo.bar"
  if (nameNs.prefix === 'xmlns') {
    ns = { prefix: nameNs.localName, uri: value };
  }

  // parse xmlns="http://foo.bar"
  if (!nameNs.prefix && nameNs.localName === 'xmlns') {
    ns = { uri: value };
  }

  if (!ns) {
    return {
      name: name,
      value: value
    };
  }

  if (model && model.getPackage(value)) {

    // register well known namespace
    this.logNamespace(ns, true, true);
  } else {

    // log custom namespace directly as used
    var actualNs = this.logNamespaceUsed(ns, true);

    this.getNamespaces().logUsed(actualNs);
  }
};


/**
 * Parse namespaces and return a list of left over generic attributes
 *
 * @param  {Object} element
 * @return {Array<Object>}
 */
ElementSerializer.prototype.parseNsAttributes = function(element, attrs) {
  var self = this;

  var genericAttrs = element.$attrs;

  var attributes = [];

  // parse namespace attributes first
  // and log them. push non namespace attributes to a list
  // and process them later
  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(genericAttrs, function(value, name) {

    var nonNsAttr = self.parseNsAttribute(element, name, value);

    if (nonNsAttr) {
      attributes.push(nonNsAttr);
    }
  });

  return attributes;
};

ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {

  var self = this;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attributes, function(attr) {

    // do not serialize xsi:type attribute
    // it is set manually based on the actual implementation type
    if (attr.name === XSI_TYPE) {
      return;
    }

    try {
      self.addAttribute(self.nsAttributeName(attr.name), attr.value);
    } catch (e) {
      console.warn(
        'missing namespace information for ',
        attr.name, '=', attr.value, 'on', element,
        e);
    }
  });
};

ElementSerializer.prototype.parseContainments = function(properties) {

  var self = this,
      body = this.body,
      element = this.element;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(properties, function(p) {
    var value = element.get(p.name),
        isReference = p.isReference,
        isMany = p.isMany;

    if (!isMany) {
      value = [ value ];
    }

    if (p.isBody) {
      body.push(new BodySerializer().build(p, value[0]));
    } else
    if ((0,moddle__WEBPACK_IMPORTED_MODULE_1__.isSimpleType)(p.type)) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {
        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));
      });
    } else
    if (isReference) {
      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {
        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));
      });
    } else {

      // allow serialization via type
      // rather than element name
      var asType = serializeAsType(p),
          asProperty = serializeAsProperty(p);

      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {
        var serializer;

        if (asType) {
          serializer = new TypeSerializer(self, p);
        } else
        if (asProperty) {
          serializer = new ElementSerializer(self, p);
        } else {
          serializer = new ElementSerializer(self);
        }

        body.push(serializer.build(v));
      });
    }
  });
};

ElementSerializer.prototype.getNamespaces = function(local) {

  var namespaces = this.namespaces,
      parent = this.parent,
      parentNamespaces;

  if (!namespaces) {
    parentNamespaces = parent && parent.getNamespaces();

    if (local || !parentNamespaces) {
      this.namespaces = namespaces = new Namespaces(parentNamespaces);
    } else {
      namespaces = parentNamespaces;
    }
  }

  return namespaces;
};

ElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {
  var namespaces = this.getNamespaces(local);

  var nsUri = ns.uri,
      nsPrefix = ns.prefix;

  var existing = namespaces.byUri(nsUri);

  if (nsPrefix !== 'xml' && (!existing || local)) {
    namespaces.add(ns, wellknown);
  }

  namespaces.mapPrefix(nsPrefix, nsUri);

  return ns;
};

ElementSerializer.prototype.logNamespaceUsed = function(ns, local) {
  var element = this.element,
      model = element.$model,
      namespaces = this.getNamespaces(local);

  // ns may be
  //
  //   * prefix only
  //   * prefix:uri
  //   * localName only

  var prefix = ns.prefix,
      uri = ns.uri,
      newPrefix, idx,
      wellknownUri;

  // handle anonymous namespaces (elementForm=unqualified), cf. #23
  if (!prefix && !uri) {
    return { localName: ns.localName };
  }

  wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;

  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);

  if (!uri) {
    throw new Error('no namespace uri given for prefix <' + prefix + '>');
  }

  ns = namespaces.byUri(uri);

  if (!ns) {
    newPrefix = prefix;
    idx = 1;

    // find a prefix that is not mapped yet
    while (namespaces.uriByPrefix(newPrefix)) {
      newPrefix = prefix + '_' + idx++;
    }

    ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);
  }

  if (prefix) {
    namespaces.mapPrefix(prefix, uri);
  }

  return ns;
};

ElementSerializer.prototype.parseAttributes = function(properties) {
  var self = this,
      element = this.element;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(properties, function(p) {

    var value = element.get(p.name);

    if (p.isReference) {

      if (!p.isMany) {
        value = value.id;
      }
      else {
        var values = [];
        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {
          values.push(v.id);
        });

        // IDREFS is a whitespace-separated list of references.
        value = values.join(' ');
      }

    }

    self.addAttribute(self.nsAttributeName(p), value);
  });
};

ElementSerializer.prototype.addTagName = function(nsTagName) {
  var actualNs = this.logNamespaceUsed(nsTagName);

  this.getNamespaces().logUsed(actualNs);

  return nsName(nsTagName);
};

ElementSerializer.prototype.addAttribute = function(name, value) {
  var attrs = this.attrs;

  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(value)) {
    value = escapeAttr(value);
  }

  attrs.push({ name: name, value: value });
};

ElementSerializer.prototype.serializeAttributes = function(writer) {
  var attrs = this.attrs,
      namespaces = this.namespaces;

  if (namespaces) {
    attrs = getNsAttrs(namespaces).concat(attrs);
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attrs, function(a) {
    writer
      .append(' ')
      .append(nsName(a.name)).append('="').append(a.value).append('"');
  });
};

ElementSerializer.prototype.serializeTo = function(writer) {
  var firstBody = this.body[0],
      indent = firstBody && firstBody.constructor !== BodySerializer;

  writer
    .appendIndent()
    .append('<' + this.tagName);

  this.serializeAttributes(writer);

  writer.append(firstBody ? '>' : ' />');

  if (firstBody) {

    if (indent) {
      writer
        .appendNewLine()
        .indent();
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(this.body, function(b) {
      b.serializeTo(writer);
    });

    if (indent) {
      writer
        .unindent()
        .appendIndent();
    }

    writer.append('</' + this.tagName + '>');
  }

  writer.appendNewLine();
};

/**
 * A serializer for types that handles serialization of data types
 */
function TypeSerializer(parent, propertyDescriptor) {
  ElementSerializer.call(this, parent, propertyDescriptor);
}

inherits(TypeSerializer, ElementSerializer);

TypeSerializer.prototype.parseNsAttributes = function(element) {

  // extracted attributes
  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);

  var descriptor = element.$descriptor;

  // only serialize xsi:type if necessary
  if (descriptor.name === this.propertyDescriptor.type) {
    return attributes;
  }

  var typeNs = this.typeNs = this.nsTagName(descriptor);
  this.getNamespaces().logUsed(this.typeNs);

  // add xsi:type attribute to represent the elements
  // actual type

  var pkg = element.$model.getPackage(typeNs.uri),
      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';

  this.addAttribute(
    this.nsAttributeName(XSI_TYPE),
    (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName
  );

  return attributes;
};

TypeSerializer.prototype.isLocalNs = function(ns) {
  return ns.uri === (this.typeNs || this.ns).uri;
};

function SavingWriter() {
  this.value = '';

  this.write = function(str) {
    this.value += str;
  };
}

function FormatingWriter(out, format) {

  var indent = [''];

  this.append = function(str) {
    out.write(str);

    return this;
  };

  this.appendNewLine = function() {
    if (format) {
      out.write('\n');
    }

    return this;
  };

  this.appendIndent = function() {
    if (format) {
      out.write(indent.join('  '));
    }

    return this;
  };

  this.indent = function() {
    indent.push('');
    return this;
  };

  this.unindent = function() {
    indent.pop();
    return this;
  };
}

/**
 * A writer for meta-model backed document trees
 *
 * @param {Object} options output options to pass into the writer
 */
function Writer(options) {

  options = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ format: false, preamble: true }, options || {});

  function toXML(tree, writer) {
    var internalWriter = writer || new SavingWriter();
    var formatingWriter = new FormatingWriter(internalWriter, options.format);

    if (options.preamble) {
      formatingWriter.append(XML_PREAMBLE);
    }

    new ElementSerializer().build(tree).serializeTo(formatingWriter);

    if (!writer) {
      return internalWriter.value;
    }
  }

  return {
    toXML: toXML
  };
}




/***/ }),

/***/ "./node_modules/moddle/dist/index.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/moddle/dist/index.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Moddle": () => (/* binding */ Moddle),
/* harmony export */   "coerceType": () => (/* binding */ coerceType),
/* harmony export */   "isBuiltInType": () => (/* binding */ isBuiltIn),
/* harmony export */   "isSimpleType": () => (/* binding */ isSimple),
/* harmony export */   "parseNameNS": () => (/* binding */ parseName)
/* harmony export */ });
/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ "./node_modules/min-dash/dist/index.esm.js");


/**
 * Moddle base element.
 */
function Base() { }

Base.prototype.get = function(name) {
  return this.$model.properties.get(this, name);
};

Base.prototype.set = function(name, value) {
  this.$model.properties.set(this, name, value);
};

/**
 * A model element factory.
 *
 * @param {Moddle} model
 * @param {Properties} properties
 */
function Factory(model, properties) {
  this.model = model;
  this.properties = properties;
}


Factory.prototype.createType = function(descriptor) {

  var model = this.model;

  var props = this.properties,
      prototype = Object.create(Base.prototype);

  // initialize default values
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(descriptor.properties, function(p) {
    if (!p.isMany && p.default !== undefined) {
      prototype[p.name] = p.default;
    }
  });

  props.defineModel(prototype, model);
  props.defineDescriptor(prototype, descriptor);

  var name = descriptor.ns.name;

  /**
   * The new type constructor
   */
  function ModdleElement(attrs) {
    props.define(this, '$type', { value: name, enumerable: true });
    props.define(this, '$attrs', { value: {} });
    props.define(this, '$parent', { writable: true });

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(attrs, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(val, key) {
      this.set(key, val);
    }, this));
  }

  ModdleElement.prototype = prototype;

  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;

  // static links
  props.defineModel(ModdleElement, model);
  props.defineDescriptor(ModdleElement, descriptor);

  return ModdleElement;
};

/**
 * Built-in moddle types
 */
var BUILTINS = {
  String: true,
  Boolean: true,
  Integer: true,
  Real: true,
  Element: true
};

/**
 * Converters for built in types from string representations
 */
var TYPE_CONVERTERS = {
  String: function(s) { return s; },
  Boolean: function(s) { return s === 'true'; },
  Integer: function(s) { return parseInt(s, 10); },
  Real: function(s) { return parseFloat(s, 10); }
};

/**
 * Convert a type to its real representation
 */
function coerceType(type, value) {

  var converter = TYPE_CONVERTERS[type];

  if (converter) {
    return converter(value);
  } else {
    return value;
  }
}

/**
 * Return whether the given type is built-in
 */
function isBuiltIn(type) {
  return !!BUILTINS[type];
}

/**
 * Return whether the given type is simple
 */
function isSimple(type) {
  return !!TYPE_CONVERTERS[type];
}

/**
 * Parses a namespaced attribute name of the form (ns:)localName to an object,
 * given a default prefix to assume in case no explicit namespace is given.
 *
 * @param {String} name
 * @param {String} [defaultPrefix] the default prefix to take, if none is present.
 *
 * @return {Object} the parsed name
 */
function parseName(name, defaultPrefix) {
  var parts = name.split(/:/),
      localName, prefix;

  // no prefix (i.e. only local name)
  if (parts.length === 1) {
    localName = name;
    prefix = defaultPrefix;
  } else
  // prefix + local name
  if (parts.length === 2) {
    localName = parts[1];
    prefix = parts[0];
  } else {
    throw new Error('expected <prefix:localName> or <localName>, got ' + name);
  }

  name = (prefix ? prefix + ':' : '') + localName;

  return {
    name: name,
    prefix: prefix,
    localName: localName
  };
}

/**
 * A utility to build element descriptors.
 */
function DescriptorBuilder(nameNs) {
  this.ns = nameNs;
  this.name = nameNs.name;
  this.allTypes = [];
  this.allTypesByName = {};
  this.properties = [];
  this.propertiesByName = {};
}


DescriptorBuilder.prototype.build = function() {
  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.pick)(this, [
    'ns',
    'name',
    'allTypes',
    'allTypesByName',
    'properties',
    'propertiesByName',
    'bodyProperty',
    'idProperty'
  ]);
};

/**
 * Add property at given index.
 *
 * @param {Object} p
 * @param {Number} [idx]
 * @param {Boolean} [validate=true]
 */
DescriptorBuilder.prototype.addProperty = function(p, idx, validate) {

  if (typeof idx === 'boolean') {
    validate = idx;
    idx = undefined;
  }

  this.addNamedProperty(p, validate !== false);

  var properties = this.properties;

  if (idx !== undefined) {
    properties.splice(idx, 0, p);
  } else {
    properties.push(p);
  }
};


DescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {
  var oldNameNs = oldProperty.ns;

  var props = this.properties,
      propertiesByName = this.propertiesByName,
      rename = oldProperty.name !== newProperty.name;

  if (oldProperty.isId) {
    if (!newProperty.isId) {
      throw new Error(
        'property <' + newProperty.ns.name + '> must be id property ' +
        'to refine <' + oldProperty.ns.name + '>');
    }

    this.setIdProperty(newProperty, false);
  }

  if (oldProperty.isBody) {

    if (!newProperty.isBody) {
      throw new Error(
        'property <' + newProperty.ns.name + '> must be body property ' +
        'to refine <' + oldProperty.ns.name + '>');
    }

    // TODO: Check compatibility
    this.setBodyProperty(newProperty, false);
  }

  // validate existence and get location of old property
  var idx = props.indexOf(oldProperty);
  if (idx === -1) {
    throw new Error('property <' + oldNameNs.name + '> not found in property list');
  }

  // remove old property
  props.splice(idx, 1);

  // replacing the named property is intentional
  //
  //  * validate only if this is a "rename" operation
  //  * add at specific index unless we "replace"
  //
  this.addProperty(newProperty, replace ? undefined : idx, rename);

  // make new property available under old name
  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
};


DescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {

  var nsPrefix = p.ns.prefix;
  var parts = targetPropertyName.split('#');

  var name = parseName(parts[0], nsPrefix);
  var attrName = parseName(parts[1], name.prefix).name;

  var redefinedProperty = this.propertiesByName[attrName];
  if (!redefinedProperty) {
    throw new Error('refined property <' + attrName + '> not found');
  } else {
    this.replaceProperty(redefinedProperty, p, replace);
  }

  delete p.redefines;
};

DescriptorBuilder.prototype.addNamedProperty = function(p, validate) {
  var ns = p.ns,
      propsByName = this.propertiesByName;

  if (validate) {
    this.assertNotDefined(p, ns.name);
    this.assertNotDefined(p, ns.localName);
  }

  propsByName[ns.name] = propsByName[ns.localName] = p;
};

DescriptorBuilder.prototype.removeNamedProperty = function(p) {
  var ns = p.ns,
      propsByName = this.propertiesByName;

  delete propsByName[ns.name];
  delete propsByName[ns.localName];
};

DescriptorBuilder.prototype.setBodyProperty = function(p, validate) {

  if (validate && this.bodyProperty) {
    throw new Error(
      'body property defined multiple times ' +
      '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');
  }

  this.bodyProperty = p;
};

DescriptorBuilder.prototype.setIdProperty = function(p, validate) {

  if (validate && this.idProperty) {
    throw new Error(
      'id property defined multiple times ' +
      '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');
  }

  this.idProperty = p;
};

DescriptorBuilder.prototype.assertNotDefined = function(p, name) {
  var propertyName = p.name,
      definedProperty = this.propertiesByName[propertyName];

  if (definedProperty) {
    throw new Error(
      'property <' + propertyName + '> already defined; ' +
      'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +
      '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');
  }
};

DescriptorBuilder.prototype.hasProperty = function(name) {
  return this.propertiesByName[name];
};

DescriptorBuilder.prototype.addTrait = function(t, inherited) {

  var typesByName = this.allTypesByName,
      types = this.allTypes;

  var typeName = t.name;

  if (typeName in typesByName) {
    return;
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(t.properties, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(p) {

    // clone property to allow extensions
    p = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, p, {
      name: p.ns.localName,
      inherited: inherited
    });

    Object.defineProperty(p, 'definedBy', {
      value: t
    });

    var replaces = p.replaces,
        redefines = p.redefines;

    // add replace/redefine support
    if (replaces || redefines) {
      this.redefineProperty(p, replaces || redefines, replaces);
    } else {
      if (p.isBody) {
        this.setBodyProperty(p);
      }
      if (p.isId) {
        this.setIdProperty(p);
      }
      this.addProperty(p);
    }
  }, this));

  types.push(t);
  typesByName[typeName] = t;
};

/**
 * A registry of Moddle packages.
 *
 * @param {Array<Package>} packages
 * @param {Properties} properties
 */
function Registry(packages, properties) {
  this.packageMap = {};
  this.typeMap = {};

  this.packages = [];

  this.properties = properties;

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(packages, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(this.registerPackage, this));
}


Registry.prototype.getPackage = function(uriOrPrefix) {
  return this.packageMap[uriOrPrefix];
};

Registry.prototype.getPackages = function() {
  return this.packages;
};


Registry.prototype.registerPackage = function(pkg) {

  // copy package
  pkg = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, pkg);

  var pkgMap = this.packageMap;

  ensureAvailable(pkgMap, pkg, 'prefix');
  ensureAvailable(pkgMap, pkg, 'uri');

  // register types
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(pkg.types, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(descriptor) {
    this.registerType(descriptor, pkg);
  }, this));

  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;
  this.packages.push(pkg);
};


/**
 * Register a type from a specific package with us
 */
Registry.prototype.registerType = function(type, pkg) {

  type = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, type, {
    superClass: (type.superClass || []).slice(),
    extends: (type.extends || []).slice(),
    properties: (type.properties || []).slice(),
    meta: (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)((type.meta || {}))
  });

  var ns = parseName(type.name, pkg.prefix),
      name = ns.name,
      propertiesByName = {};

  // parse properties
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.properties, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(p) {

    // namespace property names
    var propertyNs = parseName(p.name, ns.prefix),
        propertyName = propertyNs.name;

    // namespace property types
    if (!isBuiltIn(p.type)) {
      p.type = parseName(p.type, propertyNs.prefix).name;
    }

    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(p, {
      ns: propertyNs,
      name: propertyName
    });

    propertiesByName[propertyName] = p;
  }, this));

  // update ns + name
  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(type, {
    ns: ns,
    name: name,
    propertiesByName: propertiesByName
  });

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.extends, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(extendsName) {
    var extended = this.typeMap[extendsName];

    extended.traits = extended.traits || [];
    extended.traits.push(name);
  }, this));

  // link to package
  this.definePackage(type, pkg);

  // register
  this.typeMap[name] = type;
};


/**
 * Traverse the type hierarchy from bottom to top,
 * calling iterator with (type, inherited) for all elements in
 * the inheritance chain.
 *
 * @param {Object} nsName
 * @param {Function} iterator
 * @param {Boolean} [trait=false]
 */
Registry.prototype.mapTypes = function(nsName, iterator, trait) {

  var type = isBuiltIn(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];

  var self = this;

  /**
   * Traverse the selected trait.
   *
   * @param {String} cls
   */
  function traverseTrait(cls) {
    return traverseSuper(cls, true);
  }

  /**
   * Traverse the selected super type or trait
   *
   * @param {String} cls
   * @param {Boolean} [trait=false]
   */
  function traverseSuper(cls, trait) {
    var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);
    self.mapTypes(parentNs, iterator, trait);
  }

  if (!type) {
    throw new Error('unknown type <' + nsName.name + '>');
  }

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.superClass, trait ? traverseTrait : traverseSuper);

  // call iterator with (type, inherited=!trait)
  iterator(type, !trait);

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.traits, traverseTrait);
};


/**
 * Returns the effective descriptor for a type.
 *
 * @param  {String} type the namespaced name (ns:localName) of the type
 *
 * @return {Descriptor} the resulting effective descriptor
 */
Registry.prototype.getEffectiveDescriptor = function(name) {

  var nsName = parseName(name);

  var builder = new DescriptorBuilder(nsName);

  this.mapTypes(nsName, function(type, inherited) {
    builder.addTrait(type, inherited);
  });

  var descriptor = builder.build();

  // define package link
  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);

  return descriptor;
};


Registry.prototype.definePackage = function(target, pkg) {
  this.properties.define(target, '$pkg', { value: pkg });
};



///////// helpers ////////////////////////////

function ensureAvailable(packageMap, pkg, identifierKey) {

  var value = pkg[identifierKey];

  if (value in packageMap) {
    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');
  }
}

/**
 * A utility that gets and sets properties of model elements.
 *
 * @param {Model} model
 */
function Properties(model) {
  this.model = model;
}


/**
 * Sets a named property on the target element.
 * If the value is undefined, the property gets deleted.
 *
 * @param {Object} target
 * @param {String} name
 * @param {Object} value
 */
Properties.prototype.set = function(target, name, value) {

  var property = this.model.getPropertyDescriptor(target, name);

  var propertyName = property && property.name;

  if (isUndefined(value)) {
    // unset the property, if the specified value is undefined;
    // delete from $attrs (for extensions) or the target itself
    if (property) {
      delete target[propertyName];
    } else {
      delete target.$attrs[name];
    }
  } else {
    // set the property, defining well defined properties on the fly
    // or simply updating them in target.$attrs (for extensions)
    if (property) {
      if (propertyName in target) {
        target[propertyName] = value;
      } else {
        defineProperty(target, property, value);
      }
    } else {
      target.$attrs[name] = value;
    }
  }
};

/**
 * Returns the named property of the given element
 *
 * @param  {Object} target
 * @param  {String} name
 *
 * @return {Object}
 */
Properties.prototype.get = function(target, name) {

  var property = this.model.getPropertyDescriptor(target, name);

  if (!property) {
    return target.$attrs[name];
  }

  var propertyName = property.name;

  // check if access to collection property and lazily initialize it
  if (!target[propertyName] && property.isMany) {
    defineProperty(target, property, []);
  }

  return target[propertyName];
};


/**
 * Define a property on the target element
 *
 * @param  {Object} target
 * @param  {String} name
 * @param  {Object} options
 */
Properties.prototype.define = function(target, name, options) {
  Object.defineProperty(target, name, options);
};


/**
 * Define the descriptor for an element
 */
Properties.prototype.defineDescriptor = function(target, descriptor) {
  this.define(target, '$descriptor', { value: descriptor });
};

/**
 * Define the model for an element
 */
Properties.prototype.defineModel = function(target, model) {
  this.define(target, '$model', { value: model });
};


function isUndefined(val) {
  return typeof val === 'undefined';
}

function defineProperty(target, property, value) {
  Object.defineProperty(target, property.name, {
    enumerable: !property.isReference,
    writable: true,
    value: value,
    configurable: true
  });
}

//// Moddle implementation /////////////////////////////////////////////////

/**
 * @class Moddle
 *
 * A model that can be used to create elements of a specific type.
 *
 * @example
 *
 * var Moddle = require('moddle');
 *
 * var pkg = {
 *   name: 'mypackage',
 *   prefix: 'my',
 *   types: [
 *     { name: 'Root' }
 *   ]
 * };
 *
 * var moddle = new Moddle([pkg]);
 *
 * @param {Array<Package>} packages the packages to contain
 */
function Moddle(packages) {

  this.properties = new Properties(this);

  this.factory = new Factory(this, this.properties);
  this.registry = new Registry(packages, this.properties);

  this.typeCache = {};
}


/**
 * Create an instance of the specified type.
 *
 * @method Moddle#create
 *
 * @example
 *
 * var foo = moddle.create('my:Foo');
 * var bar = moddle.create('my:Bar', { id: 'BAR_1' });
 *
 * @param  {String|Object} descriptor the type descriptor or name know to the model
 * @param  {Object} attrs   a number of attributes to initialize the model instance with
 * @return {Object}         model instance
 */
Moddle.prototype.create = function(descriptor, attrs) {
  var Type = this.getType(descriptor);

  if (!Type) {
    throw new Error('unknown type <' + descriptor + '>');
  }

  return new Type(attrs);
};


/**
 * Returns the type representing a given descriptor
 *
 * @method Moddle#getType
 *
 * @example
 *
 * var Foo = moddle.getType('my:Foo');
 * var foo = new Foo({ 'id' : 'FOO_1' });
 *
 * @param  {String|Object} descriptor the type descriptor or name know to the model
 * @return {Object}         the type representing the descriptor
 */
Moddle.prototype.getType = function(descriptor) {

  var cache = this.typeCache;

  var name = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isString)(descriptor) ? descriptor : descriptor.ns.name;

  var type = cache[name];

  if (!type) {
    descriptor = this.registry.getEffectiveDescriptor(name);
    type = cache[name] = this.factory.createType(descriptor);
  }

  return type;
};


/**
 * Creates an any-element type to be used within model instances.
 *
 * This can be used to create custom elements that lie outside the meta-model.
 * The created element contains all the meta-data required to serialize it
 * as part of meta-model elements.
 *
 * @method Moddle#createAny
 *
 * @example
 *
 * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {
 *   value: 'bar'
 * });
 *
 * var container = moddle.create('my:Container', 'http://my', {
 *   any: [ foo ]
 * });
 *
 * // go ahead and serialize the stuff
 *
 *
 * @param  {String} name  the name of the element
 * @param  {String} nsUri the namespace uri of the element
 * @param  {Object} [properties] a map of properties to initialize the instance with
 * @return {Object} the any type instance
 */
Moddle.prototype.createAny = function(name, nsUri, properties) {

  var nameNs = parseName(name);

  var element = {
    $type: name,
    $instanceOf: function(type) {
      return type === this.$type;
    }
  };

  var descriptor = {
    name: name,
    isGeneric: true,
    ns: {
      prefix: nameNs.prefix,
      localName: nameNs.localName,
      uri: nsUri
    }
  };

  this.properties.defineDescriptor(element, descriptor);
  this.properties.defineModel(element, this);
  this.properties.define(element, '$parent', { enumerable: false, writable: true });

  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(properties, function(a, key) {
    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(a) && a.value !== undefined) {
      element[a.name] = a.value;
    } else {
      element[key] = a;
    }
  });

  return element;
};

/**
 * Returns a registered package by uri or prefix
 *
 * @return {Object} the package
 */
Moddle.prototype.getPackage = function(uriOrPrefix) {
  return this.registry.getPackage(uriOrPrefix);
};

/**
 * Returns a snapshot of all known packages
 *
 * @return {Object} the package
 */
Moddle.prototype.getPackages = function() {
  return this.registry.getPackages();
};

/**
 * Returns the descriptor for an element
 */
Moddle.prototype.getElementDescriptor = function(element) {
  return element.$descriptor;
};

/**
 * Returns true if the given descriptor or instance
 * represents the given type.
 *
 * May be applied to this, if element is omitted.
 */
Moddle.prototype.hasType = function(element, type) {
  if (type === undefined) {
    type = element;
    element = this;
  }

  var descriptor = element.$model.getElementDescriptor(element);

  return (type in descriptor.allTypesByName);
};

/**
 * Returns the descriptor of an elements named property
 */
Moddle.prototype.getPropertyDescriptor = function(element, property) {
  return this.getElementDescriptor(element).propertiesByName[property];
};

/**
 * Returns a mapped type's descriptor
 */
Moddle.prototype.getTypeDescriptor = function(type) {
  return this.registry.typeMap[type];
};




/***/ }),

/***/ "./node_modules/object-refs/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-refs/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/refs */ "./node_modules/object-refs/lib/refs.js");

module.exports.Collection = __webpack_require__(/*! ./lib/collection */ "./node_modules/object-refs/lib/collection.js");

/***/ }),

/***/ "./node_modules/object-refs/lib/collection.js":
/*!****************************************************!*\
  !*** ./node_modules/object-refs/lib/collection.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";


/**
 * An empty collection stub. Use {@link RefsCollection.extend} to extend a
 * collection with ref semantics.
 *
 * @class RefsCollection
 */

/**
 * Extends a collection with {@link Refs} aware methods
 *
 * @memberof RefsCollection
 * @static
 *
 * @param  {Array<Object>} collection
 * @param  {Refs} refs instance
 * @param  {Object} property represented by the collection
 * @param  {Object} target object the collection is attached to
 *
 * @return {RefsCollection<Object>} the extended array
 */
function extend(collection, refs, property, target) {

  var inverseProperty = property.inverse;

  /**
   * Removes the given element from the array and returns it.
   *
   * @method RefsCollection#remove
   *
   * @param {Object} element the element to remove
   */
  Object.defineProperty(collection, 'remove', {
    value: function(element) {
      var idx = this.indexOf(element);
      if (idx !== -1) {
        this.splice(idx, 1);

        // unset inverse
        refs.unset(element, inverseProperty, target);
      }

      return element;
    }
  });

  /**
   * Returns true if the collection contains the given element
   *
   * @method RefsCollection#contains
   *
   * @param {Object} element the element to check for
   */
  Object.defineProperty(collection, 'contains', {
    value: function(element) {
      return this.indexOf(element) !== -1;
    }
  });

  /**
   * Adds an element to the array, unless it exists already (set semantics).
   *
   * @method RefsCollection#add
   *
   * @param {Object} element the element to add
   * @param {Number} optional index to add element to
   *                 (possibly moving other elements around)
   */
  Object.defineProperty(collection, 'add', {
    value: function(element, idx) {

      var currentIdx = this.indexOf(element);

      if (typeof idx === 'undefined') {

        if (currentIdx !== -1) {
          // element already in collection (!)
          return;
        }

        // add to end of array, as no idx is specified
        idx = this.length;
      }

      // handle already in collection
      if (currentIdx !== -1) {

        // remove element from currentIdx
        this.splice(currentIdx, 1);
      }

      // add element at idx
      this.splice(idx, 0, element);

      if (currentIdx === -1) {
        // set inverse, unless element was
        // in collection already
        refs.set(element, inverseProperty, target);
      }
    }
  });

  // a simple marker, identifying this element
  // as being a refs collection
  Object.defineProperty(collection, '__refs_collection', {
    value: true
  });

  return collection;
}


function isExtended(collection) {
  return collection.__refs_collection === true;
}

module.exports.extend = extend;

module.exports.isExtended = isExtended;

/***/ }),

/***/ "./node_modules/object-refs/lib/refs.js":
/*!**********************************************!*\
  !*** ./node_modules/object-refs/lib/refs.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Collection = __webpack_require__(/*! ./collection */ "./node_modules/object-refs/lib/collection.js");

function hasOwnProperty(e, property) {
  return Object.prototype.hasOwnProperty.call(e, property.name || property);
}

function defineCollectionProperty(ref, property, target) {

  var collection = Collection.extend(target[property.name] || [], ref, property, target);

  Object.defineProperty(target, property.name, {
    enumerable: property.enumerable,
    value: collection
  });

  if (collection.length) {

    collection.forEach(function(o) {
      ref.set(o, property.inverse, target);
    });
  }
}


function defineProperty(ref, property, target) {

  var inverseProperty = property.inverse;

  var _value = target[property.name];

  Object.defineProperty(target, property.name, {
    configurable: property.configurable,
    enumerable: property.enumerable,

    get: function() {
      return _value;
    },

    set: function(value) {

      // return if we already performed all changes
      if (value === _value) {
        return;
      }

      var old = _value;

      // temporary set null
      _value = null;

      if (old) {
        ref.unset(old, inverseProperty, target);
      }

      // set new value
      _value = value;

      // set inverse value
      ref.set(_value, inverseProperty, target);
    }
  });

}

/**
 * Creates a new references object defining two inversly related
 * attribute descriptors a and b.
 *
 * <p>
 *   When bound to an object using {@link Refs#bind} the references
 *   get activated and ensure that add and remove operations are applied
 *   reversely, too.
 * </p>
 *
 * <p>
 *   For attributes represented as collections {@link Refs} provides the
 *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions
 *   that must be used to properly hook into the inverse change mechanism.
 * </p>
 *
 * @class Refs
 *
 * @classdesc A bi-directional reference between two attributes.
 *
 * @param {Refs.AttributeDescriptor} a property descriptor
 * @param {Refs.AttributeDescriptor} b property descriptor
 *
 * @example
 *
 * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });
 *
 * var car = { name: 'toyota' };
 * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];
 *
 * refs.bind(car, 'wheels');
 *
 * car.wheels // []
 * car.wheels.add(wheels[0]);
 * car.wheels.add(wheels[1]);
 *
 * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]
 *
 * wheels[0].car // { name: 'toyota' };
 * car.wheels.remove(wheels[0]);
 *
 * wheels[0].car // undefined
 */
function Refs(a, b) {

  if (!(this instanceof Refs)) {
    return new Refs(a, b);
  }

  // link
  a.inverse = b;
  b.inverse = a;

  this.props = {};
  this.props[a.name] = a;
  this.props[b.name] = b;
}

/**
 * Binds one side of a bi-directional reference to a
 * target object.
 *
 * @memberOf Refs
 *
 * @param  {Object} target
 * @param  {String} property
 */
Refs.prototype.bind = function(target, property) {
  if (typeof property === 'string') {
    if (!this.props[property]) {
      throw new Error('no property <' + property + '> in ref');
    }
    property = this.props[property];
  }

  if (property.collection) {
    defineCollectionProperty(this, property, target);
  } else {
    defineProperty(this, property, target);
  }
};

Refs.prototype.ensureRefsCollection = function(target, property) {

  var collection = target[property.name];

  if (!Collection.isExtended(collection)) {
    defineCollectionProperty(this, property, target);
  }

  return collection;
};

Refs.prototype.ensureBound = function(target, property) {
  if (!hasOwnProperty(target, property)) {
    this.bind(target, property);
  }
};

Refs.prototype.unset = function(target, property, value) {

  if (target) {
    this.ensureBound(target, property);

    if (property.collection) {
      this.ensureRefsCollection(target, property).remove(value);
    } else {
      target[property.name] = undefined;
    }
  }
};

Refs.prototype.set = function(target, property, value) {

  if (target) {
    this.ensureBound(target, property);

    if (property.collection) {
      this.ensureRefsCollection(target, property).add(value);
    } else {
      target[property.name] = value;
    }
  }
};

module.exports = Refs;


/**
 * An attribute descriptor to be used specify an attribute in a {@link Refs} instance
 *
 * @typedef {Object} Refs.AttributeDescriptor
 * @property {String} name
 * @property {boolean} [collection=false]
 * @property {boolean} [enumerable=false]
 */

/***/ }),

/***/ "./node_modules/path-intersection/intersect.js":
/*!*****************************************************!*\
  !*** ./node_modules/path-intersection/intersect.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * This file contains source code adapted from Snap.svg (licensed Apache-2.0).
 *
 * @see https://github.com/adobe-webplatform/Snap.svg/blob/master/src/path.js
 */

/* eslint no-fallthrough: "off" */

var p2s = /,?([a-z]),?/gi,
    toFloat = parseFloat,
    math = Math,
    PI = math.PI,
    mmin = math.min,
    mmax = math.max,
    pow = math.pow,
    abs = math.abs,
    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?[\s]*,?[\s]*)+)/ig,
    pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)[\s]*,?[\s]*/ig;

var isArray = Array.isArray || function(o) { return o instanceof Array; };

function hasProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}

function clone(obj) {

  if (typeof obj == 'function' || Object(obj) !== obj) {
    return obj;
  }

  var res = new obj.constructor;

  for (var key in obj) {
    if (hasProperty(obj, key)) {
      res[key] = clone(obj[key]);
    }
  }

  return res;
}

function repush(array, item) {
  for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
    return array.push(array.splice(i, 1)[0]);
  }
}

function cacher(f) {

  function newf() {

    var arg = Array.prototype.slice.call(arguments, 0),
        args = arg.join('\u2400'),
        cache = newf.cache = newf.cache || {},
        count = newf.count = newf.count || [];

    if (hasProperty(cache, args)) {
      repush(count, args);
      return cache[args];
    }

    count.length >= 1e3 && delete cache[count.shift()];
    count.push(args);
    cache[args] = f.apply(0, arg);

    return cache[args];
  }
  return newf;
}

function parsePathString(pathString) {

  if (!pathString) {
    return null;
  }

  var pth = paths(pathString);

  if (pth.arr) {
    return clone(pth.arr);
  }

  var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 },
      data = [];

  if (isArray(pathString) && isArray(pathString[0])) { // rough assumption
    data = clone(pathString);
  }

  if (!data.length) {

    String(pathString).replace(pathCommand, function(a, b, c) {
      var params = [],
          name = b.toLowerCase();

      c.replace(pathValues, function(a, b) {
        b && params.push(+b);
      });

      if (name == 'm' && params.length > 2) {
        data.push([b].concat(params.splice(0, 2)));
        name = 'l';
        b = b == 'm' ? 'l' : 'L';
      }

      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    });
  }

  data.toString = paths.toString;
  pth.arr = clone(data);

  return data;
}

function paths(ps) {
  var p = paths.ps = paths.ps || {};

  if (p[ps]) {
    p[ps].sleep = 100;
  } else {
    p[ps] = {
      sleep: 100
    };
  }

  setTimeout(function() {
    for (var key in p) {
      if (hasProperty(p, key) && key != ps) {
        p[key].sleep--;
        !p[key].sleep && delete p[key];
      }
    }
  });

  return p[ps];
}

function rectBBox(x, y, width, height) {

  if (arguments.length === 1) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }

  return {
    x: x,
    y: y,
    width: width,
    height: height,
    x2: x + width,
    y2: y + height
  };
}

function pathToString() {
  return this.join(',').replace(p2s, '$1');
}

function pathClone(pathArray) {
  var res = clone(pathArray);
  res.toString = pathToString;
  return res;
}

function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t,
      t13 = pow(t1, 3),
      t12 = pow(t1, 2),
      t2 = t * t,
      t3 = t2 * t,
      x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
      y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;

  return {
    x: fixError(x),
    y: fixError(y)
  };
}

function bezierBBox(points) {

  var bbox = curveBBox.apply(null, points);

  return rectBBox(
    bbox.x0,
    bbox.y0,
    bbox.x1 - bbox.x0,
    bbox.y1 - bbox.y0
  );
}

function isPointInsideBBox(bbox, x, y) {
  return x >= bbox.x &&
    x <= bbox.x + bbox.width &&
    y >= bbox.y &&
    y <= bbox.y + bbox.height;
}

function isBBoxIntersect(bbox1, bbox2) {
  bbox1 = rectBBox(bbox1);
  bbox2 = rectBBox(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
    || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
    || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
    || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
    || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
    || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
    || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
    || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
    || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
        || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
    && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
        || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
}

function base3(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
      t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
}

function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {

  if (z == null) {
    z = 1;
  }

  z = z > 1 ? 1 : z < 0 ? 0 : z;

  var z2 = z / 2,
      n = 12,
      Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],
      Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
      sum = 0;

  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2,
        xbase = base3(ct, x1, x2, x3, x4),
        ybase = base3(ct, y1, y2, y3, y4),
        comb = xbase * xbase + ybase * ybase;

    sum += Cvalues[i] * math.sqrt(comb);
  }

  return z2 * sum;
}


function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4) {

  if (
    mmax(x1, x2) < mmin(x3, x4) ||
      mmin(x1, x2) > mmax(x3, x4) ||
      mmax(y1, y2) < mmin(y3, y4) ||
      mmin(y1, y2) > mmax(y3, y4)
  ) {
    return;
  }

  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
      denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

  if (!denominator) {
    return;
  }

  var px = fixError(nx / denominator),
      py = fixError(ny / denominator),
      px2 = +px.toFixed(2),
      py2 = +py.toFixed(2);

  if (
    px2 < +mmin(x1, x2).toFixed(2) ||
      px2 > +mmax(x1, x2).toFixed(2) ||
      px2 < +mmin(x3, x4).toFixed(2) ||
      px2 > +mmax(x3, x4).toFixed(2) ||
      py2 < +mmin(y1, y2).toFixed(2) ||
      py2 > +mmax(y1, y2).toFixed(2) ||
      py2 < +mmin(y3, y4).toFixed(2) ||
      py2 > +mmax(y3, y4).toFixed(2)
  ) {
    return;
  }

  return { x: px, y: py };
}

function fixError(number) {
  return Math.round(number * 100000000000) / 100000000000;
}

function findBezierIntersections(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1),
      bbox2 = bezierBBox(bez2);

  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }

  // As an optimization, lines will have only 1 segment

  var l1 = bezlen.apply(0, bez1),
      l2 = bezlen.apply(0, bez2),
      n1 = isLine(bez1) ? 1 : ~~(l1 / 5) || 1,
      n2 = isLine(bez2) ? 1 : ~~(l2 / 5) || 1,
      dots1 = [],
      dots2 = [],
      xy = {},
      res = justCount ? 0 : [];

  for (var i = 0; i < n1 + 1; i++) {
    var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({ x: p.x, y: p.y, t: i / n1 });
  }

  for (i = 0; i < n2 + 1; i++) {
    p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({ x: p.x, y: p.y, t: i / n2 });
  }

  for (i = 0; i < n1; i++) {

    for (var j = 0; j < n2; j++) {
      var di = dots1[i],
          di1 = dots1[i + 1],
          dj = dots2[j],
          dj1 = dots2[j + 1],
          ci = abs(di1.x - di.x) < .01 ? 'y' : 'x',
          cj = abs(dj1.x - dj.x) < .01 ? 'y' : 'x',
          is = intersectLines(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y),
          key;

      if (is) {
        key = is.x.toFixed(9) + '#' + is.y.toFixed(9);

        if (xy[key]) {
          continue;
        }

        xy[key] = true;

        var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
            t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);

        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {

          if (justCount) {
            res++;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1: t1,
              t2: t2
            });
          }
        }
      }
    }
  }

  return res;
}


/**
 * Find or counts the intersections between two SVG paths.
 *
 * Returns a number in counting mode and a list of intersections otherwise.
 *
 * A single intersection entry contains the intersection coordinates (x, y)
 * as well as additional information regarding the intersecting segments
 * on each path (segment1, segment2) and the relative location of the
 * intersection on these segments (t1, t2).
 *
 * The path may be an SVG path string or a list of path components
 * such as `[ [ 'M', 0, 10 ], [ 'L', 20, 0 ] ]`.
 *
 * @example
 *
 * var intersections = findPathIntersections(
 *   'M0,0L100,100',
 *   [ [ 'M', 0, 100 ], [ 'L', 100, 0 ] ]
 * );
 *
 * // intersections = [
 * //   { x: 50, y: 50, segment1: 1, segment2: 1, t1: 0.5, t2: 0.5 }
 * // ]
 *
 * @param {String|Array<PathDef>} path1
 * @param {String|Array<PathDef>} path2
 * @param {Boolean} [justCount=false]
 *
 * @return {Array<Intersection>|Number}
 */
function findPathIntersections(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);

  var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
      res = justCount ? 0 : [];

  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi = path1[i];

    if (pi[0] == 'M') {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {

      if (pi[0] == 'C') {
        bez1 = [x1, y1].concat(pi.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }

      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];

        if (pj[0] == 'M') {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {

          if (pj[0] == 'C') {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }

          var intr = findBezierIntersections(bez1, bez2, justCount);

          if (justCount) {
            res += intr;
          } else {

            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }

            res = res.concat(intr);
          }
        }
      }
    }
  }

  return res;
}


function pathToAbsolute(pathArray) {
  var pth = paths(pathArray);

  if (pth.abs) {
    return pathClone(pth.abs);
  }

  if (!isArray(pathArray) || !isArray(pathArray && pathArray[0])) { // rough assumption
    pathArray = parsePathString(pathArray);
  }

  if (!pathArray || !pathArray.length) {
    return [['M', 0, 0]];
  }

  var res = [],
      x = 0,
      y = 0,
      mx = 0,
      my = 0,
      start = 0,
      pa0;

  if (pathArray[0][0] == 'M') {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ['M', x, y];
  }

  for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];

    if (pa0 != pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();

      switch (r[0]) {
      case 'A':
        r[1] = pa[1];
        r[2] = pa[2];
        r[3] = pa[3];
        r[4] = pa[4];
        r[5] = pa[5];
        r[6] = +pa[6] + x;
        r[7] = +pa[7] + y;
        break;
      case 'V':
        r[1] = +pa[1] + y;
        break;
      case 'H':
        r[1] = +pa[1] + x;
        break;
      case 'M':
        mx = +pa[1] + x;
        my = +pa[2] + y;
      default:
        for (var j = 1, jj = pa.length; j < jj; j++) {
          r[j] = +pa[j] + ((j % 2) ? x : y);
        }
      }
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }
    pa0 = pa0.toUpperCase();

    switch (r[0]) {
    case 'Z':
      x = +mx;
      y = +my;
      break;
    case 'H':
      x = r[1];
      break;
    case 'V':
      y = r[1];
      break;
    case 'M':
      mx = r[r.length - 2];
      my = r[r.length - 1];
    default:
      x = r[r.length - 2];
      y = r[r.length - 1];
    }
  }

  res.toString = pathToString;
  pth.abs = pathClone(res);

  return res;
}

function isLine(bez) {
  return (
    bez[0] === bez[2] &&
    bez[1] === bez[3] &&
    bez[4] === bez[6] &&
    bez[5] === bez[7]
  );
}

function lineToCurve(x1, y1, x2, y2) {
  return [
    x1, y1, x2,
    y2, x2, y2
  ];
}

function qubicToCurve(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3,
      _23 = 2 / 3;

  return [
    _13 * x1 + _23 * ax,
    _13 * y1 + _23 * ay,
    _13 * x2 + _23 * ax,
    _13 * y2 + _23 * ay,
    x2,
    y2
  ];
}

function arcToCurve(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {

  // for more information of where this math came from visit:
  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  var _120 = PI * 120 / 180,
      rad = PI / 180 * (+angle || 0),
      res = [],
      xy,
      rotate = cacher(function(x, y, rad) {
        var X = x * math.cos(rad) - y * math.sin(rad),
            Y = x * math.sin(rad) + y * math.cos(rad);

        return { x: X, y: Y };
      });

  if (!recursive) {
    xy = rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;

    var x = (x1 - x2) / 2,
        y = (y1 - y2) / 2;

    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);

    if (h > 1) {
      h = math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }

    var rx2 = rx * rx,
        ry2 = ry * ry,
        k = (large_arc_flag == sweep_flag ? -1 : 1) *
            math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
        cx = k * rx * y / ry + (x1 + x2) / 2,
        cy = k * -ry * x / rx + (y1 + y2) / 2,
        f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
        f2 = math.asin(((y2 - cy) / ry).toFixed(9));

    f1 = x1 < cx ? PI - f1 : f1;
    f2 = x2 < cx ? PI - f2 : f2;
    f1 < 0 && (f1 = PI * 2 + f1);
    f2 < 0 && (f2 = PI * 2 + f2);

    if (sweep_flag && f1 > f2) {
      f1 = f1 - PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }

  var df = f2 - f1;

  if (abs(df) > _120) {
    var f2old = f2,
        x2old = x2,
        y2old = y2;

    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * math.cos(f2);
    y2 = cy + ry * math.sin(f2);
    res = arcToCurve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }

  df = f2 - f1;

  var c1 = math.cos(f1),
      s1 = math.sin(f1),
      c2 = math.cos(f2),
      s2 = math.sin(f2),
      t = math.tan(df / 4),
      hx = 4 / 3 * rx * t,
      hy = 4 / 3 * ry * t,
      m1 = [x1, y1],
      m2 = [x1 + hx * s1, y1 - hy * c1],
      m3 = [x2 + hx * s2, y2 - hy * c2],
      m4 = [x2, y2];

  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];

  if (recursive) {
    return [m2, m3, m4].concat(res);
  } else {
    res = [m2, m3, m4].concat(res).join().split(',');
    var newres = [];

    for (var i = 0, ii = res.length; i < ii; i++) {
      newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
    }

    return newres;
  }
}

// Returns bounding box of cubic bezier curve.
// Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
// Original version: NISHIO Hirokazu
// Modifications: https://github.com/timo22345
function curveBBox(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [],
      bounds = [[], []],
      a, b, c, t, t1, t2, b2ac, sqrtb2ac;

  for (var i = 0; i < 2; ++i) {

    if (i == 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }

    if (abs(a) < 1e-12) {

      if (abs(b) < 1e-12) {
        continue;
      }

      t = -c / b;

      if (0 < t && t < 1) {
        tvalues.push(t);
      }

      continue;
    }

    b2ac = b * b - 4 * c * a;
    sqrtb2ac = math.sqrt(b2ac);

    if (b2ac < 0) {
      continue;
    }

    t1 = (-b + sqrtb2ac) / (2 * a);

    if (0 < t1 && t1 < 1) {
      tvalues.push(t1);
    }

    t2 = (-b - sqrtb2ac) / (2 * a);

    if (0 < t2 && t2 < 1) {
      tvalues.push(t2);
    }
  }

  var j = tvalues.length,
      jlen = j,
      mt;

  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
    bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
  }

  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;

  return {
    x0: mmin.apply(0, bounds[0]),
    y0: mmin.apply(0, bounds[1]),
    x1: mmax.apply(0, bounds[0]),
    y1: mmax.apply(0, bounds[1])
  };
}

function pathToCurve(path) {

  var pth = paths(path);

  // return cached curve, if existing
  if (pth.curve) {
    return pathClone(pth.curve);
  }

  var curvedPath = pathToAbsolute(path),
      attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
      processPath = function(path, d, pathCommand) {
        var nx, ny;

        if (!path) {
          return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
        }

        !(path[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);

        switch (path[0]) {
        case 'M':
          d.X = path[1];
          d.Y = path[2];
          break;
        case 'A':
          path = ['C'].concat(arcToCurve.apply(0, [d.x, d.y].concat(path.slice(1))));
          break;
        case 'S':
          if (pathCommand == 'C' || pathCommand == 'S') {

            // In 'S' case we have to take into account, if the previous command is C/S.
            nx = d.x * 2 - d.bx;

            // And reflect the previous
            ny = d.y * 2 - d.by;

            // command's control point relative to the current point.
          }
          else {

            // or some else or nothing
            nx = d.x;
            ny = d.y;
          }
          path = ['C', nx, ny].concat(path.slice(1));
          break;
        case 'T':
          if (pathCommand == 'Q' || pathCommand == 'T') {

            // In 'T' case we have to take into account, if the previous command is Q/T.
            d.qx = d.x * 2 - d.qx;

            // And make a reflection similar
            d.qy = d.y * 2 - d.qy;

            // to case 'S'.
          }
          else {

            // or something else or nothing
            d.qx = d.x;
            d.qy = d.y;
          }
          path = ['C'].concat(qubicToCurve(d.x, d.y, d.qx, d.qy, path[1], path[2]));
          break;
        case 'Q':
          d.qx = path[1];
          d.qy = path[2];
          path = ['C'].concat(qubicToCurve(d.x, d.y, path[1], path[2], path[3], path[4]));
          break;
        case 'L':
          path = ['C'].concat(lineToCurve(d.x, d.y, path[1], path[2]));
          break;
        case 'H':
          path = ['C'].concat(lineToCurve(d.x, d.y, path[1], d.y));
          break;
        case 'V':
          path = ['C'].concat(lineToCurve(d.x, d.y, d.x, path[1]));
          break;
        case 'Z':
          path = ['C'].concat(lineToCurve(d.x, d.y, d.X, d.Y));
          break;
        }

        return path;
      },

      fixArc = function(pp, i) {

        if (pp[i].length > 7) {
          pp[i].shift();
          var pi = pp[i];

          while (pi.length) {
            pathCommands[i] = 'A'; // if created multiple C:s, their original seg is saved
            pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
          }

          pp.splice(i, 1);
          ii = curvedPath.length;
        }
      },

      pathCommands = [], // path commands of original path p
      pfirst = '', // temporary holder for original path command
      pathCommand = ''; // holder for previous path command of original path

  for (var i = 0, ii = curvedPath.length; i < ii; i++) {
    curvedPath[i] && (pfirst = curvedPath[i][0]); // save current path command

    if (pfirst != 'C') // C is not saved yet, because it may be result of conversion
    {
      pathCommands[i] = pfirst; // Save current path command
      i && (pathCommand = pathCommands[i - 1]); // Get previous path command pathCommand
    }
    curvedPath[i] = processPath(curvedPath[i], attrs, pathCommand); // Previous path command is inputted to processPath

    if (pathCommands[i] != 'A' && pfirst == 'C') pathCommands[i] = 'C'; // A is the only command
    // which may produce multiple C:s
    // so we have to make sure that C is also C in original path

    fixArc(curvedPath, i); // fixArc adds also the right amount of A:s to pathCommands

    var seg = curvedPath[i],
        seglen = seg.length;

    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
  }

  // cache curve
  pth.curve = pathClone(curvedPath);

  return curvedPath;
}

module.exports = findPathIntersections;


/***/ }),

/***/ "./node_modules/saxen/dist/index.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/saxen/dist/index.esm.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Parser": () => (/* binding */ Parser),
/* harmony export */   "decode": () => (/* binding */ decodeEntities)
/* harmony export */ });
var fromCharCode = String.fromCharCode;

var hasOwnProperty = Object.prototype.hasOwnProperty;

var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;

var ENTITY_MAPPING = {
  'amp': '&',
  'apos': '\'',
  'gt': '>',
  'lt': '<',
  'quot': '"'
};

// map UPPERCASE variants of supported special chars
Object.keys(ENTITY_MAPPING).forEach(function(k) {
  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];
});


function replaceEntities(_, d, x, z) {

  // reserved names, i.e. &nbsp;
  if (z) {
    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {
      return ENTITY_MAPPING[z];
    } else {

      // fall back to original value
      return '&' + z + ';';
    }
  }

  // decimal encoded char
  if (d) {
    return fromCharCode(d);
  }

  // hex encoded char
  return fromCharCode(parseInt(x, 16));
}


/**
 * A basic entity decoder that can decode a minimal
 * sub-set of reserved names (&amp;) as well as
 * hex (&#xaaf;) and decimal (&#1231;) encoded characters.
 *
 * @param {string} str
 *
 * @return {string} decoded string
 */
function decodeEntities(s) {
  if (s.length > 3 && s.indexOf('&') !== -1) {
    return s.replace(ENTITY_PATTERN, replaceEntities);
  }

  return s;
}

var XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';
var XSI_PREFIX = 'xsi';
var XSI_TYPE = 'xsi:type';

var NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';

function error(msg) {
  return new Error(msg);
}

function missingNamespaceForPrefix(prefix) {
  return 'missing namespace for prefix <' + prefix + '>';
}

function getter(getFn) {
  return {
    'get': getFn,
    'enumerable': true
  };
}

function cloneNsMatrix(nsMatrix) {
  var clone = {}, key;
  for (key in nsMatrix) {
    clone[key] = nsMatrix[key];
  }
  return clone;
}

function uriPrefix(prefix) {
  return prefix + '$uri';
}

function buildNsMatrix(nsUriToPrefix) {
  var nsMatrix = {},
      uri,
      prefix;

  for (uri in nsUriToPrefix) {
    prefix = nsUriToPrefix[uri];
    nsMatrix[prefix] = prefix;
    nsMatrix[uriPrefix(prefix)] = uri;
  }

  return nsMatrix;
}

function noopGetContext() {
  return { 'line': 0, 'column': 0 };
}

function throwFunc(err) {
  throw err;
}

/**
 * Creates a new parser with the given options.
 *
 * @constructor
 *
 * @param  {!Object<string, ?>=} options
 */
function Parser(options) {

  if (!this) {
    return new Parser(options);
  }

  var proxy = options && options['proxy'];

  var onText,
      onOpenTag,
      onCloseTag,
      onCDATA,
      onError = throwFunc,
      onWarning,
      onComment,
      onQuestion,
      onAttention;

  var getContext = noopGetContext;

  /**
   * Do we need to parse the current elements attributes for namespaces?
   *
   * @type {boolean}
   */
  var maybeNS = false;

  /**
   * Do we process namespaces at all?
   *
   * @type {boolean}
   */
  var isNamespace = false;

  /**
   * The caught error returned on parse end
   *
   * @type {Error}
   */
  var returnError = null;

  /**
   * Should we stop parsing?
   *
   * @type {boolean}
   */
  var parseStop = false;

  /**
   * A map of { uri: prefix } used by the parser.
   *
   * This map will ensure we can normalize prefixes during processing;
   * for each uri, only one prefix will be exposed to the handlers.
   *
   * @type {!Object<string, string>}}
   */
  var nsUriToPrefix;

  /**
   * Handle parse error.
   *
   * @param  {string|Error} err
   */
  function handleError(err) {
    if (!(err instanceof Error)) {
      err = error(err);
    }

    returnError = err;

    onError(err, getContext);
  }

  /**
   * Handle parse error.
   *
   * @param  {string|Error} err
   */
  function handleWarning(err) {

    if (!onWarning) {
      return;
    }

    if (!(err instanceof Error)) {
      err = error(err);
    }

    onWarning(err, getContext);
  }

  /**
   * Register parse listener.
   *
   * @param  {string}   name
   * @param  {Function} cb
   *
   * @return {Parser}
   */
  this['on'] = function(name, cb) {

    if (typeof cb !== 'function') {
      throw error('required args <name, cb>');
    }

    switch (name) {
    case 'openTag': onOpenTag = cb; break;
    case 'text': onText = cb; break;
    case 'closeTag': onCloseTag = cb; break;
    case 'error': onError = cb; break;
    case 'warn': onWarning = cb; break;
    case 'cdata': onCDATA = cb; break;
    case 'attention': onAttention = cb; break; // <!XXXXX zzzz="eeee">
    case 'question': onQuestion = cb; break; // <? ....  ?>
    case 'comment': onComment = cb; break;
    default:
      throw error('unsupported event: ' + name);
    }

    return this;
  };

  /**
   * Set the namespace to prefix mapping.
   *
   * @example
   *
   * parser.ns({
   *   'http://foo': 'foo',
   *   'http://bar': 'bar'
   * });
   *
   * @param  {!Object<string, string>} nsMap
   *
   * @return {Parser}
   */
  this['ns'] = function(nsMap) {

    if (typeof nsMap === 'undefined') {
      nsMap = {};
    }

    if (typeof nsMap !== 'object') {
      throw error('required args <nsMap={}>');
    }

    var _nsUriToPrefix = {}, k;

    for (k in nsMap) {
      _nsUriToPrefix[k] = nsMap[k];
    }

    // FORCE default mapping for schema instance
    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;

    isNamespace = true;
    nsUriToPrefix = _nsUriToPrefix;

    return this;
  };

  /**
   * Parse xml string.
   *
   * @param  {string} xml
   *
   * @return {Error} returnError, if not thrown
   */
  this['parse'] = function(xml) {
    if (typeof xml !== 'string') {
      throw error('required args <xml=string>');
    }

    returnError = null;

    parse(xml);

    getContext = noopGetContext;
    parseStop = false;

    return returnError;
  };

  /**
   * Stop parsing.
   */
  this['stop'] = function() {
    parseStop = true;
  };

  /**
   * Parse string, invoking configured listeners on element.
   *
   * @param  {string} xml
   */
  function parse(xml) {
    var nsMatrixStack = isNamespace ? [] : null,
        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,
        _nsMatrix,
        nodeStack = [],
        anonymousNsCount = 0,
        tagStart = false,
        tagEnd = false,
        i = 0, j = 0,
        x, y, q, w, v,
        xmlns,
        elementName,
        _elementName,
        elementProxy
        ;

    var attrsString = '',
        attrsStart = 0,
        cachedAttrs // false = parsed with errors, null = needs parsing
        ;

    /**
     * Parse attributes on demand and returns the parsed attributes.
     *
     * Return semantics: (1) `false` on attribute parse error,
     * (2) object hash on extracted attrs.
     *
     * @return {boolean|Object}
     */
    function getAttrs() {
      if (cachedAttrs !== null) {
        return cachedAttrs;
      }

      var nsUri,
          nsUriPrefix,
          nsName,
          defaultAlias = isNamespace && nsMatrix['xmlns'],
          attrList = isNamespace && maybeNS ? [] : null,
          i = attrsStart,
          s = attrsString,
          l = s.length,
          hasNewMatrix,
          newalias,
          value,
          alias,
          name,
          attrs = {},
          seenAttrs = {},
          skipAttr,
          w,
          j;

      parseAttr:
      for (; i < l; i++) {
        skipAttr = false;
        w = s.charCodeAt(i);

        if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \f\n\r\t\v}
          continue;
        }

        // wait for non whitespace character
        if (w < 65 || w > 122 || (w > 90 && w < 97)) {
          if (w !== 95 && w !== 58) { // char 95"_" 58":"
            handleWarning('illegal first char attribute name');
            skipAttr = true;
          }
        }

        // parse attribute name
        for (j = i + 1; j < l; j++) {
          w = s.charCodeAt(j);

          if (
            w > 96 && w < 123 ||
            w > 64 && w < 91 ||
            w > 47 && w < 59 ||
            w === 46 || // '.'
            w === 45 || // '-'
            w === 95 // '_'
          ) {
            continue;
          }

          // unexpected whitespace
          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
            handleWarning('missing attribute value');
            i = j;

            continue parseAttr;
          }

          // expected "="
          if (w === 61) { // "=" == 61
            break;
          }

          handleWarning('illegal attribute name char');
          skipAttr = true;
        }

        name = s.substring(i, j);

        if (name === 'xmlns:xmlns') {
          handleWarning('illegal declaration of xmlns');
          skipAttr = true;
        }

        w = s.charCodeAt(j + 1);

        if (w === 34) { // '"'
          j = s.indexOf('"', i = j + 2);

          if (j === -1) {
            j = s.indexOf('\'', i);

            if (j !== -1) {
              handleWarning('attribute value quote missmatch');
              skipAttr = true;
            }
          }

        } else if (w === 39) { // "'"
          j = s.indexOf('\'', i = j + 2);

          if (j === -1) {
            j = s.indexOf('"', i);

            if (j !== -1) {
              handleWarning('attribute value quote missmatch');
              skipAttr = true;
            }
          }

        } else {
          handleWarning('missing attribute value quotes');
          skipAttr = true;

          // skip to next space
          for (j = j + 1; j < l; j++) {
            w = s.charCodeAt(j + 1);

            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
              break;
            }
          }

        }

        if (j === -1) {
          handleWarning('missing closing quotes');

          j = l;
          skipAttr = true;
        }

        if (!skipAttr) {
          value = s.substring(i, j);
        }

        i = j;

        // ensure SPACE follows attribute
        // skip illegal content otherwise
        // example a="b"c
        for (; j + 1 < l; j++) {
          w = s.charCodeAt(j + 1);

          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE
            break;
          }

          // FIRST ILLEGAL CHAR
          if (i === j) {
            handleWarning('illegal character after attribute end');
            skipAttr = true;
          }
        }

        // advance cursor to next attribute
        i = j + 1;

        if (skipAttr) {
          continue parseAttr;
        }

        // check attribute re-declaration
        if (name in seenAttrs) {
          handleWarning('attribute <' + name + '> already defined');
          continue;
        }

        seenAttrs[name] = true;

        if (!isNamespace) {
          attrs[name] = value;
          continue;
        }

        // try to extract namespace information
        if (maybeNS) {
          newalias = (
            name === 'xmlns'
              ? 'xmlns'
              : (name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:')
                ? name.substr(6)
                : null
          );

          // handle xmlns(:alias) assignment
          if (newalias !== null) {
            nsUri = decodeEntities(value);
            nsUriPrefix = uriPrefix(newalias);

            alias = nsUriToPrefix[nsUri];

            if (!alias) {

              // no prefix defined or prefix collision
              if (
                (newalias === 'xmlns') ||
                (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)
              ) {

                // alocate free ns prefix
                do {
                  alias = 'ns' + (anonymousNsCount++);
                } while (typeof nsMatrix[alias] !== 'undefined');
              } else {
                alias = newalias;
              }

              nsUriToPrefix[nsUri] = alias;
            }

            if (nsMatrix[newalias] !== alias) {
              if (!hasNewMatrix) {
                nsMatrix = cloneNsMatrix(nsMatrix);
                hasNewMatrix = true;
              }

              nsMatrix[newalias] = alias;
              if (newalias === 'xmlns') {
                nsMatrix[uriPrefix(alias)] = nsUri;
                defaultAlias = alias;
              }

              nsMatrix[nsUriPrefix] = nsUri;
            }

            // expose xmlns(:asd)="..." in attributes
            attrs[name] = value;
            continue;
          }

          // collect attributes until all namespace
          // declarations are processed
          attrList.push(name, value);
          continue;

        } /** end if (maybeNs) */

        // handle attributes on element without
        // namespace declarations
        w = name.indexOf(':');
        if (w === -1) {
          attrs[name] = value;
          continue;
        }

        // normalize ns attribute name
        if (!(nsName = nsMatrix[name.substring(0, w)])) {
          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
          continue;
        }

        name = defaultAlias === nsName
          ? name.substr(w + 1)
          : nsName + name.substr(w);

        // end: normalize ns attribute name

        // normalize xsi:type ns attribute value
        if (name === XSI_TYPE) {
          w = value.indexOf(':');

          if (w !== -1) {
            nsName = value.substring(0, w);

            // handle default prefixes, i.e. xs:String gracefully
            nsName = nsMatrix[nsName] || nsName;
            value = nsName + value.substring(w);
          } else {
            value = defaultAlias + ':' + value;
          }
        }

        // end: normalize xsi:type ns attribute value

        attrs[name] = value;
      }


      // handle deferred, possibly namespaced attributes
      if (maybeNS) {

        // normalize captured attributes
        for (i = 0, l = attrList.length; i < l; i++) {

          name = attrList[i++];
          value = attrList[i];

          w = name.indexOf(':');

          if (w !== -1) {

            // normalize ns attribute name
            if (!(nsName = nsMatrix[name.substring(0, w)])) {
              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
              continue;
            }

            name = defaultAlias === nsName
              ? name.substr(w + 1)
              : nsName + name.substr(w);

            // end: normalize ns attribute name

            // normalize xsi:type ns attribute value
            if (name === XSI_TYPE) {
              w = value.indexOf(':');

              if (w !== -1) {
                nsName = value.substring(0, w);

                // handle default prefixes, i.e. xs:String gracefully
                nsName = nsMatrix[nsName] || nsName;
                value = nsName + value.substring(w);
              } else {
                value = defaultAlias + ':' + value;
              }
            }

            // end: normalize xsi:type ns attribute value
          }

          attrs[name] = value;
        }

        // end: normalize captured attributes
      }

      return cachedAttrs = attrs;
    }

    /**
     * Extract the parse context { line, column, part }
     * from the current parser position.
     *
     * @return {Object} parse context
     */
    function getParseContext() {
      var splitsRe = /(\r\n|\r|\n)/g;

      var line = 0;
      var column = 0;
      var startOfLine = 0;
      var endOfLine = j;
      var match;
      var data;

      while (i >= startOfLine) {

        match = splitsRe.exec(xml);

        if (!match) {
          break;
        }

        // end of line = (break idx + break chars)
        endOfLine = match[0].length + match.index;

        if (endOfLine > i) {
          break;
        }

        // advance to next line
        line += 1;

        startOfLine = endOfLine;
      }

      // EOF errors
      if (i == -1) {
        column = endOfLine;
        data = xml.substring(j);
      } else

      // start errors
      if (j === 0) {
        data = xml.substring(j, i);
      }

      // other errors
      else {
        column = i - startOfLine;
        data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));
      }

      return {
        'data': data,
        'line': line,
        'column': column
      };
    }

    getContext = getParseContext;


    if (proxy) {
      elementProxy = Object.create({}, {
        'name': getter(function() {
          return elementName;
        }),
        'originalName': getter(function() {
          return _elementName;
        }),
        'attrs': getter(getAttrs),
        'ns': getter(function() {
          return nsMatrix;
        })
      });
    }

    // actual parse logic
    while (j !== -1) {

      if (xml.charCodeAt(j) === 60) { // "<"
        i = j;
      } else {
        i = xml.indexOf('<', j);
      }

      // parse end
      if (i === -1) {
        if (nodeStack.length) {
          return handleError('unexpected end of file');
        }

        if (j === 0) {
          return handleError('missing start tag');
        }

        if (j < xml.length) {
          if (xml.substring(j).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
          }
        }

        return;
      }

      // parse text
      if (j !== i) {

        if (nodeStack.length) {
          if (onText) {
            onText(xml.substring(j, i), decodeEntities, getContext);

            if (parseStop) {
              return;
            }
          }
        } else {
          if (xml.substring(j, i).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);

            if (parseStop) {
              return;
            }
          }
        }
      }

      w = xml.charCodeAt(i+1);

      // parse comments + CDATA
      if (w === 33) { // "!"
        q = xml.charCodeAt(i+2);

        // CDATA section
        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') { // 91 == "["
          j = xml.indexOf(']]>', i);
          if (j === -1) {
            return handleError('unclosed cdata');
          }

          if (onCDATA) {
            onCDATA(xml.substring(i + 9, j), getContext);
            if (parseStop) {
              return;
            }
          }

          j += 3;
          continue;
        }

        // comment
        if (q === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == "-"
          j = xml.indexOf('-->', i);
          if (j === -1) {
            return handleError('unclosed comment');
          }


          if (onComment) {
            onComment(xml.substring(i + 4, j), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }

          j += 3;
          continue;
        }
      }

      // parse question <? ... ?>
      if (w === 63) { // "?"
        j = xml.indexOf('?>', i);
        if (j === -1) {
          return handleError('unclosed question');
        }

        if (onQuestion) {
          onQuestion(xml.substring(i, j + 2), getContext);
          if (parseStop) {
            return;
          }
        }

        j += 2;
        continue;
      }

      // find matching closing tag for attention or standard tags
      // for that we must skip through attribute values
      // (enclosed in single or double quotes)
      for (x = i + 1; ; x++) {
        v = xml.charCodeAt(x);
        if (isNaN(v)) {
          j = -1;
          return handleError('unclosed tag');
        }

        // [10] AttValue ::= '"' ([^<&"] | Reference)* '"' | "'" ([^<&'] | Reference)* "'"
        // skips the quoted string
        // (double quotes) does not appear in a literal enclosed by (double quotes)
        // (single quote) does not appear in a literal enclosed by (single quote)
        if (v === 34) { //  '"'
          q = xml.indexOf('"', x + 1);
          x = q !== -1 ? q : x;
        } else if (v === 39) { // "'"
          q = xml.indexOf("'", x + 1);
          x = q !== -1 ? q : x;
        } else if (v === 62) { // '>'
          j = x;
          break;
        }
      }


      // parse attention <! ...>
      // previously comment and CDATA have already been parsed
      if (w === 33) { // "!"

        if (onAttention) {
          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);
          if (parseStop) {
            return;
          }
        }

        j += 1;
        continue;
      }

      // don't process attributes;
      // there are none
      cachedAttrs = {};

      // if (xml.charCodeAt(i+1) === 47) { // </...
      if (w === 47) { // </...
        tagStart = false;
        tagEnd = true;

        if (!nodeStack.length) {
          return handleError('missing open tag');
        }

        // verify open <-> close tag match
        x = elementName = nodeStack.pop();
        q = i + 2 + x.length;

        if (xml.substring(i + 2, q) !== x) {
          return handleError('closing tag mismatch');
        }

        // verify chars in close tag
        for (; q < j; q++) {
          w = xml.charCodeAt(q);

          if (w === 32 || (w > 8 && w < 14)) { // \f\n\r\t\v space
            continue;
          }

          return handleError('close tag');
        }

      } else {
        if (xml.charCodeAt(j - 1) === 47) { // .../>
          x = elementName = xml.substring(i + 1, j - 1);

          tagStart = true;
          tagEnd = true;

        } else {
          x = elementName = xml.substring(i + 1, j);

          tagStart = true;
          tagEnd = false;
        }

        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95"_" 58":"
          return handleError('illegal first char nodeName');
        }

        for (q = 1, y = x.length; q < y; q++) {
          w = x.charCodeAt(q);

          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {
            continue;
          }

          if (w === 32 || (w < 14 && w > 8)) { // \f\n\r\t\v space
            elementName = x.substring(0, q);

            // maybe there are attributes
            cachedAttrs = null;
            break;
          }

          return handleError('invalid nodeName');
        }

        if (!tagEnd) {
          nodeStack.push(elementName);
        }
      }

      if (isNamespace) {

        _nsMatrix = nsMatrix;

        if (tagStart) {

          // remember old namespace
          // unless we're self-closing
          if (!tagEnd) {
            nsMatrixStack.push(_nsMatrix);
          }

          if (cachedAttrs === null) {

            // quick check, whether there may be namespace
            // declarations on the node; if that is the case
            // we need to eagerly parse the node attributes
            if ((maybeNS = x.indexOf('xmlns', q) !== -1)) {
              attrsStart = q;
              attrsString = x;

              getAttrs();

              maybeNS = false;
            }
          }
        }

        _elementName = elementName;

        w = elementName.indexOf(':');
        if (w !== -1) {
          xmlns = nsMatrix[elementName.substring(0, w)];

          // prefix given; namespace must exist
          if (!xmlns) {
            return handleError('missing namespace on <' + _elementName + '>');
          }

          elementName = elementName.substr(w + 1);
        } else {
          xmlns = nsMatrix['xmlns'];

          // if no default namespace is defined,
          // we'll import the element as anonymous.
          //
          // it is up to users to correct that to the document defined
          // targetNamespace, or whatever their undersanding of the
          // XML spec mandates.
        }

        // adjust namespace prefixs as configured
        if (xmlns) {
          elementName = xmlns + ':' + elementName;
        }

      }

      if (tagStart) {
        attrsStart = q;
        attrsString = x;

        if (onOpenTag) {
          if (proxy) {
            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
          } else {
            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);
          }

          if (parseStop) {
            return;
          }
        }

      }

      if (tagEnd) {

        if (onCloseTag) {
          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);

          if (parseStop) {
            return;
          }
        }

        // restore old namespace
        if (isNamespace) {
          if (!tagStart) {
            nsMatrix = nsMatrixStack.pop();
          } else {
            nsMatrix = _nsMatrix;
          }
        }
      }

      j += 1;
    }
  } /** end parse */

}




/***/ }),

/***/ "./node_modules/tiny-svg/dist/index.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tiny-svg/dist/index.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "append": () => (/* binding */ append),
/* harmony export */   "appendTo": () => (/* binding */ appendTo),
/* harmony export */   "attr": () => (/* binding */ attr),
/* harmony export */   "classes": () => (/* binding */ classes),
/* harmony export */   "clear": () => (/* binding */ clear),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "innerSVG": () => (/* binding */ innerSVG),
/* harmony export */   "prepend": () => (/* binding */ prepend),
/* harmony export */   "prependTo": () => (/* binding */ prependTo),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "replace": () => (/* binding */ replace),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "on": () => (/* binding */ on),
/* harmony export */   "off": () => (/* binding */ off),
/* harmony export */   "createPoint": () => (/* binding */ createPoint),
/* harmony export */   "createMatrix": () => (/* binding */ createMatrix),
/* harmony export */   "createTransform": () => (/* binding */ createTransform),
/* harmony export */   "select": () => (/* binding */ select),
/* harmony export */   "selectAll": () => (/* binding */ selectAll)
/* harmony export */ });
function ensureImported(element, target) {

  if (element.ownerDocument !== target.ownerDocument) {
    try {
      // may fail on webkit
      return target.ownerDocument.importNode(element, true);
    } catch (e) {
      // ignore
    }
  }

  return element;
}

/**
 * appendTo utility
 */

/**
 * Append a node to a target element and return the appended node.
 *
 * @param  {SVGElement} element
 * @param  {SVGElement} target
 *
 * @return {SVGElement} the appended node
 */
function appendTo(element, target) {
  return target.appendChild(ensureImported(element, target));
}

/**
 * append utility
 */

/**
 * Append a node to an element
 *
 * @param  {SVGElement} element
 * @param  {SVGElement} node
 *
 * @return {SVGElement} the element
 */
function append(target, node) {
  appendTo(node, target);
  return target;
}

/**
 * attribute accessor utility
 */

var LENGTH_ATTR = 2;

var CSS_PROPERTIES = {
  'alignment-baseline': 1,
  'baseline-shift': 1,
  'clip': 1,
  'clip-path': 1,
  'clip-rule': 1,
  'color': 1,
  'color-interpolation': 1,
  'color-interpolation-filters': 1,
  'color-profile': 1,
  'color-rendering': 1,
  'cursor': 1,
  'direction': 1,
  'display': 1,
  'dominant-baseline': 1,
  'enable-background': 1,
  'fill': 1,
  'fill-opacity': 1,
  'fill-rule': 1,
  'filter': 1,
  'flood-color': 1,
  'flood-opacity': 1,
  'font': 1,
  'font-family': 1,
  'font-size': LENGTH_ATTR,
  'font-size-adjust': 1,
  'font-stretch': 1,
  'font-style': 1,
  'font-variant': 1,
  'font-weight': 1,
  'glyph-orientation-horizontal': 1,
  'glyph-orientation-vertical': 1,
  'image-rendering': 1,
  'kerning': 1,
  'letter-spacing': 1,
  'lighting-color': 1,
  'marker': 1,
  'marker-end': 1,
  'marker-mid': 1,
  'marker-start': 1,
  'mask': 1,
  'opacity': 1,
  'overflow': 1,
  'pointer-events': 1,
  'shape-rendering': 1,
  'stop-color': 1,
  'stop-opacity': 1,
  'stroke': 1,
  'stroke-dasharray': 1,
  'stroke-dashoffset': 1,
  'stroke-linecap': 1,
  'stroke-linejoin': 1,
  'stroke-miterlimit': 1,
  'stroke-opacity': 1,
  'stroke-width': LENGTH_ATTR,
  'text-anchor': 1,
  'text-decoration': 1,
  'text-rendering': 1,
  'unicode-bidi': 1,
  'visibility': 1,
  'word-spacing': 1,
  'writing-mode': 1
};


function getAttribute(node, name) {
  if (CSS_PROPERTIES[name]) {
    return node.style[name];
  } else {
    return node.getAttributeNS(null, name);
  }
}

function setAttribute(node, name, value) {
  var hyphenated = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();

  var type = CSS_PROPERTIES[hyphenated];

  if (type) {
    // append pixel unit, unless present
    if (type === LENGTH_ATTR && typeof value === 'number') {
      value = String(value) + 'px';
    }

    node.style[hyphenated] = value;
  } else {
    node.setAttributeNS(null, name, value);
  }
}

function setAttributes(node, attrs) {

  var names = Object.keys(attrs), i, name;

  for (i = 0, name; (name = names[i]); i++) {
    setAttribute(node, name, attrs[name]);
  }
}

/**
 * Gets or sets raw attributes on a node.
 *
 * @param  {SVGElement} node
 * @param  {Object} [attrs]
 * @param  {String} [name]
 * @param  {String} [value]
 *
 * @return {String}
 */
function attr(node, name, value) {
  if (typeof name === 'string') {
    if (value !== undefined) {
      setAttribute(node, name, value);
    } else {
      return getAttribute(node, name);
    }
  } else {
    setAttributes(node, name);
  }

  return node;
}

/**
 * Clear utility
 */
function index(arr, obj) {
  if (arr.indexOf) {
    return arr.indexOf(obj);
  }


  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) {
      return i;
    }
  }

  return -1;
}

var re = /\s+/;

var toString = Object.prototype.toString;

function defined(o) {
  return typeof o !== 'undefined';
}

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

function classes(el) {
  return new ClassList(el);
}

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name) {

  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) {
    arr.push(name);
  }

  if (defined(this.el.className.baseVal)) {
    this.el.className.baseVal = arr.join(' ');
  } else {
    this.el.className = arr.join(' ');
  }

  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name) {
  if ('[object RegExp]' === toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) {
    arr.splice(i, 1);
  }
  this.el.className.baseVal = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re) {
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force) {
  // classList
  if (this.list) {
    if (defined(force)) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if (defined(force)) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function() {
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) {
    arr.shift();
  }
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name) {
  return (
    this.list ?
      this.list.contains(name) :
      !! ~index(this.array(), name)
  );
};

function remove(element) {
  var parent = element.parentNode;

  if (parent) {
    parent.removeChild(element);
  }

  return element;
}

/**
 * Clear utility
 */

/**
 * Removes all children from the given element
 *
 * @param  {DOMElement} element
 * @return {DOMElement} the element (for chaining)
 */
function clear(element) {
  var child;

  while ((child = element.firstChild)) {
    remove(child);
  }

  return element;
}

function clone(element) {
  return element.cloneNode(true);
}

var ns = {
  svg: 'http://www.w3.org/2000/svg'
};

/**
 * DOM parsing utility
 */

var SVG_START = '<svg xmlns="' + ns.svg + '"';

function parse(svg) {

  var unwrap = false;

  // ensure we import a valid svg document
  if (svg.substring(0, 4) === '<svg') {
    if (svg.indexOf(ns.svg) === -1) {
      svg = SVG_START + svg.substring(4);
    }
  } else {
    // namespace svg
    svg = SVG_START + '>' + svg + '</svg>';
    unwrap = true;
  }

  var parsed = parseDocument(svg);

  if (!unwrap) {
    return parsed;
  }

  var fragment = document.createDocumentFragment();

  var parent = parsed.firstChild;

  while (parent.firstChild) {
    fragment.appendChild(parent.firstChild);
  }

  return fragment;
}

function parseDocument(svg) {

  var parser;

  // parse
  parser = new DOMParser();
  parser.async = false;

  return parser.parseFromString(svg, 'text/xml');
}

/**
 * Create utility for SVG elements
 */


/**
 * Create a specific type from name or SVG markup.
 *
 * @param {String} name the name or markup of the element
 * @param {Object} [attrs] attributes to set on the element
 *
 * @returns {SVGElement}
 */
function create(name, attrs) {
  var element;

  if (name.charAt(0) === '<') {
    element = parse(name).firstChild;
    element = document.importNode(element, true);
  } else {
    element = document.createElementNS(ns.svg, name);
  }

  if (attrs) {
    attr(element, attrs);
  }

  return element;
}

/**
 * Events handling utility
 */

function on(node, event, listener, useCapture) {
  node.addEventListener(event, listener, useCapture);
}

function off(node, event, listener, useCapture) {
  node.removeEventListener(event, listener, useCapture);
}

/**
 * Geometry helpers
 */

// fake node used to instantiate svg geometry elements
var node = create('svg');

function extend(object, props) {
  var i, k, keys = Object.keys(props);

  for (i = 0; (k = keys[i]); i++) {
    object[k] = props[k];
  }

  return object;
}


function createPoint(x, y) {
  var point = node.createSVGPoint();

  switch (arguments.length) {
  case 0:
    return point;
  case 2:
    x = {
      x: x,
      y: y
    };
    break;
  }

  return extend(point, x);
}

/**
 * Create matrix via args.
 *
 * @example
 *
 * createMatrix({ a: 1, b: 1 });
 * createMatrix();
 * createMatrix(1, 2, 0, 0, 30, 20);
 *
 * @return {SVGMatrix}
 */
function createMatrix(a, b, c, d, e, f) {
  var matrix = node.createSVGMatrix();

  switch (arguments.length) {
  case 0:
    return matrix;
  case 1:
    return extend(matrix, a);
  case 6:
    return extend(matrix, {
      a: a,
      b: b,
      c: c,
      d: d,
      e: e,
      f: f
    });
  }
}

function createTransform(matrix) {
  if (matrix) {
    return node.createSVGTransformFromMatrix(matrix);
  } else {
    return node.createSVGTransform();
  }
}

/**
 * Serialization util
 */

var TEXT_ENTITIES = /([&<>]{1})/g;
var ATTR_ENTITIES = /([\n\r"]{1})/g;

var ENTITY_REPLACEMENT = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '\''
};

function escape(str, pattern) {

  function replaceFn(match, entity) {
    return ENTITY_REPLACEMENT[entity] || entity;
  }

  return str.replace(pattern, replaceFn);
}

function serialize(node, output) {

  var i, len, attrMap, attrNode, childNodes;

  switch (node.nodeType) {
  // TEXT
  case 3:
    // replace special XML characters
    output.push(escape(node.textContent, TEXT_ENTITIES));
    break;

  // ELEMENT
  case 1:
    output.push('<', node.tagName);

    if (node.hasAttributes()) {
      attrMap = node.attributes;
      for (i = 0, len = attrMap.length; i < len; ++i) {
        attrNode = attrMap.item(i);
        output.push(' ', attrNode.name, '="', escape(attrNode.value, ATTR_ENTITIES), '"');
      }
    }

    if (node.hasChildNodes()) {
      output.push('>');
      childNodes = node.childNodes;
      for (i = 0, len = childNodes.length; i < len; ++i) {
        serialize(childNodes.item(i), output);
      }
      output.push('</', node.tagName, '>');
    } else {
      output.push('/>');
    }
    break;

  // COMMENT
  case 8:
    output.push('<!--', escape(node.nodeValue, TEXT_ENTITIES), '-->');
    break;

  // CDATA
  case 4:
    output.push('<![CDATA[', node.nodeValue, ']]>');
    break;

  default:
    throw new Error('unable to handle node ' + node.nodeType);
  }

  return output;
}

/**
 * innerHTML like functionality for SVG elements.
 * based on innerSVG (https://code.google.com/p/innersvg)
 */


function set(element, svg) {

  var parsed = parse(svg);

  // clear element contents
  clear(element);

  if (!svg) {
    return;
  }

  if (!isFragment(parsed)) {
    // extract <svg> from parsed document
    parsed = parsed.documentElement;
  }

  var nodes = slice(parsed.childNodes);

  // import + append each node
  for (var i = 0; i < nodes.length; i++) {
    appendTo(nodes[i], element);
  }

}

function get(element) {
  var child = element.firstChild,
      output = [];

  while (child) {
    serialize(child, output);
    child = child.nextSibling;
  }

  return output.join('');
}

function isFragment(node) {
  return node.nodeName === '#document-fragment';
}

function innerSVG(element, svg) {

  if (svg !== undefined) {

    try {
      set(element, svg);
    } catch (e) {
      throw new Error('error parsing SVG: ' + e.message);
    }

    return element;
  } else {
    return get(element);
  }
}


function slice(arr) {
  return Array.prototype.slice.call(arr);
}

/**
 * Selection utilities
 */

function select(node, selector) {
  return node.querySelector(selector);
}

function selectAll(node, selector) {
  var nodes = node.querySelectorAll(selector);

  return [].map.call(nodes, function(element) {
    return element;
  });
}

/**
 * prependTo utility
 */

/**
 * Prepend a node to a target element and return the prepended node.
 *
 * @param  {SVGElement} node
 * @param  {SVGElement} target
 *
 * @return {SVGElement} the prepended node
 */
function prependTo(node, target) {
  return target.insertBefore(ensureImported(node, target), target.firstChild || null);
}

/**
 * prepend utility
 */

/**
 * Prepend a node to a target element
 *
 * @param  {SVGElement} target
 * @param  {SVGElement} node
 *
 * @return {SVGElement} the target element
 */
function prepend(target, node) {
  prependTo(node, target);
  return target;
}

/**
 * Replace utility
 */

function replace(element, replacement) {
  element.parentNode.replaceChild(ensureImported(replacement, element), element);
  return replacement;
}

/**
 * transform accessor utility
 */

function wrapMatrix(transformList, transform) {
  if (transform instanceof SVGMatrix) {
    return transformList.createSVGTransformFromMatrix(transform);
  }

  return transform;
}


function setTransforms(transformList, transforms) {
  var i, t;

  transformList.clear();

  for (i = 0; (t = transforms[i]); i++) {
    transformList.appendItem(wrapMatrix(transformList, t));
  }
}

/**
 * Get or set the transforms on the given node.
 *
 * @param {SVGElement} node
 * @param  {SVGTransform|SVGMatrix|Array<SVGTransform|SVGMatrix>} [transforms]
 *
 * @return {SVGTransform} the consolidated transform
 */
function transform(node, transforms) {
  var transformList = node.transform.baseVal;

  if (transforms) {

    if (!Array.isArray(transforms)) {
      transforms = [ transforms ];
    }

    setTransforms(transformList, transforms);
  }

  return transformList.consolidate();
}




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL0Jhc2VNb2RlbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvQmFzZVZpZXdlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL01vZGVsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9OYXZpZ2F0ZWRWaWV3ZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9WaWV3ZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9jb3JlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZHJhdy9QYXRoTWFwLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZHJhdy9Qb3N0aXRSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2RyYXcvUG9zdGl0UmVuZGVyZXJVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZHJhdy9UZXh0UmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9kcmF3L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvY2FudmFzLWNyZWF0ZS9DYW52YXNDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9jYW52YXMtY3JlYXRlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvY29udGV4dC1wYWQvQ29udGV4dFBhZFByb3ZpZGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvY29udGV4dC1wYWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9jb3B5LXBhc3RlL01vZGRsZUNvcHkuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9jb3B5LXBhc3RlL1Bvc3RpdENvcHlQYXN0ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL2NvcHktcGFzdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9kaS1vcmRlcmluZy9Qb3N0aXREaU9yZGVyaW5nLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvZGktb3JkZXJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9kcmFnLWRyb3AtaW1hZ2VzL0RyYWdEcm9wSW1hZ2VzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvZHJhZy1kcm9wLWltYWdlcy9GaWxlVXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL2RyYWctZHJvcC1pbWFnZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9lZGl0b3ItYWN0aW9ucy9Qb3N0aXRFZGl0b3JBY3Rpb25zLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvZWRpdG9yLWFjdGlvbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9pbWFnZS1zZWxlY3Rpb24vSW1hZ2VTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9pbWFnZS1zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9rZXlib2FyZC9Qb3N0aXRLZXlib2FyZEJpbmRpbmdzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMva2V5Ym9hcmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL0xhYmVsRWRpdGluZ1ByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL0xhYmVsRWRpdGluZ1Byb3ZpZGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbGFiZWwtZWRpdGluZy9MYWJlbFV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL2NtZC9VcGRhdGVMYWJlbEhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvRWxlbWVudEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9Nb2RlbGluZy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL1Bvc3RpdEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9Qb3N0aXRVcGRhdGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvYmVoYXZpb3IvQWRhcHRpdmVMYWJlbFBvc2l0aW9uaW5nQmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9iZWhhdmlvci9BcHBlbmRCZWhhdmlvci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2JlaGF2aW9yL0NyZWF0ZUJvYXJkRWxlbWVudEJlaGF2aW9yLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvYmVoYXZpb3IvRW1wdHlUZXh0Qm94QmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9iZWhhdmlvci9GaXhIb3ZlckJlaGF2aW9yLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvYmVoYXZpb3IvSW1wb3J0RG9ja2luZ0ZpeC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2JlaGF2aW9yL0xhYmVsQmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9iZWhhdmlvci9SZXBsYWNlRWxlbWVudEJlaGF2aW91ci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2JlaGF2aW9yL1VuY2xhaW1JZEJlaGF2aW9yLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvYmVoYXZpb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9iZWhhdmlvci91dGlsL0dlb21ldHJpY1V0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9iZWhhdmlvci91dGlsL0xhYmVsTGF5b3V0VXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2JlaGF2aW9yL3V0aWwvTGluZUF0dGFjaG1lbnRVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvYmVoYXZpb3IvdXRpbC9MaW5lSW50ZXJzZWN0LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL0lkQ2xhaW1IYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL1NldENvbG9ySGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9VcGRhdGVDYW52YXNSb290SGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9VcGRhdGVQcm9wZXJ0aWVzSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL21vZGVsaW5nL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvbW9kZWxpbmcvdXRpbC9Nb2RlbGluZ1V0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9vcmRlcmluZy9Qb3N0aXRPcmRlcmluZ1Byb3ZpZGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvb3JkZXJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9wYWxldHRlL1BhbGV0dGVQcm92aWRlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL3BhbGV0dGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9wb3B1cC1tZW51L1JlcGxhY2VNZW51UHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9wb3B1cC1tZW51L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvcmVwbGFjZS1wcmV2aWV3L1Bvc3RpdFJlcGxhY2VQcmV2aWV3LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvcmVwbGFjZS1wcmV2aWV3L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvcmVwbGFjZS9Qb3N0aXRSZXBsYWNlLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvcmVwbGFjZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ZlYXR1cmVzL3J1bGVzL1Bvc3RpdFJ1bGVzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvZmVhdHVyZXMvcnVsZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9zbmFwcGluZy9Qb3N0aXRDcmVhdGVNb3ZlU25hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9mZWF0dXJlcy9zbmFwcGluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ltcG9ydC9JbXBvcnRlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ltcG9ydC9Qb3N0aXRJbXBvcnRlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL2ltcG9ydC9Qb3N0aXRUcmVlV2Fsa2VyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvaW1wb3J0L1V0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9pbXBvcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL21vZGRsZS9Nb2RkbGUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi9tb2RkbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi91dGlsL0NvbG9yVXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL3V0aWwvRmlsZVV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL2xpYi91dGlsL0xhYmVsVXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbGliL3V0aWwvTW9kZWxVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9saWIvdXRpbC9TY3JlZW5VdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvY3NzLmVzY2FwZS9jc3MuZXNjYXBlLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy1kaXJlY3QtZWRpdGluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMtZGlyZWN0LWVkaXRpbmcvbGliL0RpcmVjdEVkaXRpbmcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzLWRpcmVjdC1lZGl0aW5nL2xpYi9UZXh0Qm94LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvRGlhZ3JhbS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2NvbW1hbmQvQ29tbWFuZEludGVyY2VwdG9yLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvY29tbWFuZC9Db21tYW5kU3RhY2suanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9jb21tYW5kL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvY29yZS9DYW52YXMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9jb3JlL0VsZW1lbnRGYWN0b3J5LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvY29yZS9FbGVtZW50UmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9jb3JlL0V2ZW50QnVzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvY29yZS9HcmFwaGljc0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9jb3JlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZHJhdy9CYXNlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9kcmF3L0RlZmF1bHRSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2RyYXcvU3R5bGVzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZHJhdy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2FsaWduLWVsZW1lbnRzL0FsaWduRWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9hbGlnbi1lbGVtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2F0dGFjaC1zdXBwb3J0L0F0dGFjaFN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9hdHRhY2gtc3VwcG9ydC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2F1dG8tc2Nyb2xsL0F1dG9TY3JvbGwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9hdXRvLXNjcm9sbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2JlbmRwb2ludHMvQmVuZHBvaW50TW92ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2JlbmRwb2ludHMvQmVuZHBvaW50TW92ZVByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9iZW5kcG9pbnRzL0JlbmRwb2ludFNuYXBwaW5nLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvYmVuZHBvaW50cy9CZW5kcG9pbnRVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvYmVuZHBvaW50cy9CZW5kcG9pbnRzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvYmVuZHBvaW50cy9Db25uZWN0aW9uU2VnbWVudE1vdmUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9iZW5kcG9pbnRzL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY2hhbmdlLXN1cHBvcnQvQ2hhbmdlU3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NoYW5nZS1zdXBwb3J0L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY2xpcGJvYXJkL0NsaXBib2FyZC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NsaXBib2FyZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2Nvbm5lY3QvQ29ubmVjdC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2Nvbm5lY3QvQ29ubmVjdFByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9jb25uZWN0L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY29ubmVjdGlvbi1wcmV2aWV3L0Nvbm5lY3Rpb25QcmV2aWV3LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY29ubmVjdGlvbi1wcmV2aWV3L2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY29udGV4dC1wYWQvQ29udGV4dFBhZC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NvbnRleHQtcGFkL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY29weS1wYXN0ZS9Db3B5UGFzdGUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9jb3B5LXBhc3RlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY3JlYXRlL0NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NyZWF0ZS9DcmVhdGVQcmV2aWV3LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY3JlYXRlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvZHJhZ2dpbmcvRHJhZ2dpbmcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9kcmFnZ2luZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2VkaXRvci1hY3Rpb25zL0VkaXRvckFjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9lZGl0b3ItYWN0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2hhbmQtdG9vbC9IYW5kVG9vbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2hhbmQtdG9vbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2hvdmVyLWZpeC9Ib3ZlckZpeC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2hvdmVyLWZpeC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2ludGVyYWN0aW9uLWV2ZW50cy9JbnRlcmFjdGlvbkV2ZW50cy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2ludGVyYWN0aW9uLWV2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2tleWJvYXJkLW1vdmUtc2VsZWN0aW9uL0tleWJvYXJkTW92ZVNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2tleWJvYXJkLW1vdmUtc2VsZWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMva2V5Ym9hcmQvS2V5Ym9hcmQuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9rZXlib2FyZC9LZXlib2FyZEJpbmRpbmdzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMva2V5Ym9hcmQvS2V5Ym9hcmRVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMva2V5Ym9hcmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9sYWJlbC1zdXBwb3J0L0xhYmVsU3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2xhYmVsLXN1cHBvcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9sYXNzby10b29sL0xhc3NvVG9vbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2xhc3NvLXRvb2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9Nb2RlbGluZy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9BbGlnbkVsZW1lbnRzSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9BcHBlbmRTaGFwZUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvQ3JlYXRlQ29ubmVjdGlvbkhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvQ3JlYXRlRWxlbWVudHNIYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL0NyZWF0ZUxhYmVsSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9DcmVhdGVTaGFwZUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvRGVsZXRlQ29ubmVjdGlvbkhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvRGVsZXRlRWxlbWVudHNIYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL0RlbGV0ZVNoYXBlSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9EaXN0cmlidXRlRWxlbWVudHNIYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL0xheW91dENvbm5lY3Rpb25IYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL01vdmVDb25uZWN0aW9uSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9Nb3ZlRWxlbWVudHNIYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL01vdmVTaGFwZUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvUmVjb25uZWN0Q29ubmVjdGlvbkhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvUmVwbGFjZVNoYXBlSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9SZXNpemVTaGFwZUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb2RlbGluZy9jbWQvU3BhY2VUb29sSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9Ub2dnbGVTaGFwZUNvbGxhcHNlSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9VcGRhdGVBdHRhY2htZW50SGFuZGxlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9VcGRhdGVXYXlwb2ludHNIYW5kbGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL2hlbHBlci9BbmNob3JzSGVscGVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW9kZWxpbmcvY21kL2hlbHBlci9Nb3ZlQ2xvc3VyZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL2NtZC9oZWxwZXIvTW92ZUhlbHBlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vdXNlL01vdXNlLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW91c2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb3ZlL01vdmUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9tb3ZlL01vdmVQcmV2aWV3LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW92ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL29yZGVyaW5nL09yZGVyaW5nUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vdXRsaW5lL091dGxpbmUuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vdXRsaW5lL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvb3ZlcmxheXMvT3ZlcmxheXMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vdmVybGF5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3BhbGV0dGUvUGFsZXR0ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3BhbGV0dGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9wb3B1cC1tZW51L1BvcHVwTWVudS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3BvcHVwLW1lbnUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9wcmV2aWV3LXN1cHBvcnQvUHJldmlld1N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9wcmV2aWV3LXN1cHBvcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9yZXBsYWNlL1JlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9yZXBsYWNlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcmVzaXplL1Jlc2l6ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3Jlc2l6ZS9SZXNpemVIYW5kbGVzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcmVzaXplL1Jlc2l6ZVByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9yZXNpemUvUmVzaXplVXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3Jlc2l6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3J1bGVzL1J1bGVQcm92aWRlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3J1bGVzL1J1bGVzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcnVsZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zZWxlY3Rpb24vU2VsZWN0aW9uLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uL1NlbGVjdGlvbkJlaGF2aW9yLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uL1NlbGVjdGlvblZpc3VhbHMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zbmFwcGluZy9DcmVhdGVNb3ZlU25hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zbmFwcGluZy9SZXNpemVTbmFwcGluZy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NuYXBwaW5nL1NuYXBDb250ZXh0LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc25hcHBpbmcvU25hcFV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zbmFwcGluZy9TbmFwcGluZy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NuYXBwaW5nL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc3BhY2UtdG9vbC9TcGFjZVRvb2wuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zcGFjZS10b29sL1NwYWNlVG9vbFByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zcGFjZS10b29sL1NwYWNlVXRpbC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NwYWNlLXRvb2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy90b29sLW1hbmFnZXIvVG9vbE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy90b29sLW1hbmFnZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy90b29sdGlwcy9Ub29sdGlwcy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3Rvb2x0aXBzL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvdG91Y2gvVG91Y2hGaXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9mZWF0dXJlcy90b3VjaC9Ub3VjaEludGVyYWN0aW9uRXZlbnRzLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvdG91Y2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9pMThuL3RyYW5zbGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2kxOG4vdHJhbnNsYXRlL3RyYW5zbGF0ZS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2xheW91dC9CYXNlTGF5b3V0ZXIuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9sYXlvdXQvQ3JvcHBpbmdDb25uZWN0aW9uRG9ja2luZy5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL2xheW91dC9MYXlvdXRVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvbW9kZWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL2tleWJvYXJkLW1vdmUvS2V5Ym9hcmRNb3ZlLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi9rZXlib2FyZC1tb3ZlL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi9tb3ZlY2FudmFzL01vdmVDYW52YXMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL21vdmVjYW52YXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL3RvdWNoL2luZGV4LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi96b29tc2Nyb2xsL1pvb21TY3JvbGwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL3pvb21zY3JvbGwvWm9vbVV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL3pvb21zY3JvbGwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0F0dGFjaFV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0NsaWNrVHJhcC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvQ29sbGVjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0N1cnNvci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvRWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL0V2ZW50LmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvdXRpbC9HZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvR3JhcGhpY3NVdGlsLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvdXRpbC9JZEdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvTGluZUludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvTWF0aC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL2RpYWdyYW0tanMvbGliL3V0aWwvTW91c2UuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL1BsYXRmb3JtLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvZGlhZ3JhbS1qcy9saWIvdXRpbC9Qb3NpdGlvblV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL1JlbW92YWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL1JlbmRlclV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL1N2Z1RyYW5zZm9ybVV0aWwuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWFncmFtLWpzL2xpYi91dGlsL1RleHQuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9kaWRpL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvaGFtbWVyanMvaGFtbWVyLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvaWRzL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL21pbi1kYXNoL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvbWluLWRvbS9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL21vZGRsZS14bWwvZGlzdC9pbmRleC5lc20uanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9tb2RkbGUvZGlzdC9pbmRleC5lc20uanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9vYmplY3QtcmVmcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL29iamVjdC1yZWZzL2xpYi9jb2xsZWN0aW9uLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvLi9ub2RlX21vZHVsZXMvb2JqZWN0LXJlZnMvbGliL3JlZnMuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9wYXRoLWludGVyc2VjdGlvbi9pbnRlcnNlY3QuanMiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci8uL25vZGVfbW9kdWxlcy9zYXhlbi9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyLy4vbm9kZV9tb2R1bGVzL3Rpbnktc3ZnL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vUG9zdEl0TW9kZWxlci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL1Bvc3RJdE1vZGVsZXIvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9Qb3N0SXRNb2RlbGVyL3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVmdDOztBQUVWOztBQUVnQjs7O0FBR3RDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsV0FBVztBQUN0QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLG1CQUFtQjtBQUM5QjtBQUNlO0FBQ2YsRUFBRSxxREFBZTs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSwrQ0FBUSxjQUFjLGdEQUFVOzs7QUFHaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlLDZFQUF1Qzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdDQUFHOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFD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RUFBRSxLQUFLLElBQUksS0FBSyxHQUFHLEtBQUs7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHLElBQUksS0FBSyxFQUFFLEtBQUssS0FBSyxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRyxJQUFJLEtBQUssRUFBRSxLQUFLLEtBQUssS0FBSyxHQUFHLEtBQUssS0FBSyxLQUFLLEVBQUUsS0FBSztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLFFBQVEsS0FBSyxLQUFLLEtBQUs7QUFDekQsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEMsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEMsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEMsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEMsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEMsYUFBYSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHLElBQUksS0FBSyxHQUFHLEtBQUssTUFBTSxLQUFLLEVBQUUsS0FBSyxNQUFNLEtBQUssRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssR0FBRyxLQUFLLEVBQUUsS0FBSyxHQUFHLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUcsR0FBRyxLQUFLLE1BQU0sS0FBSyxFQUFFLEtBQUssTUFBTSxLQUFLLEVBQUUsS0FBSztBQUNqRSxhQUFhLEtBQUssRUFBRSxLQUFLLE9BQU8sS0FBSyxHQUFHLEtBQUssT0FBTyxLQUFLLEdBQUcsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLLEdBQUcsS0FBSyxJQUFJLEtBQUssTUFBTSxLQUFLLEdBQUcsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLLElBQUksS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRyxJQUFJLEtBQUssR0FBRyxLQUFLLEtBQUssS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLEVBQUUsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsR0FBRyxFQUFFLEdBQUc7QUFDdEIsY0FBYyxLQUFLLEVBQUUsS0FBSyxLQUFLLEtBQUssRUFBRSxLQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssR0FBRyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLLEVBQUUsS0FBSyxHQUFHLEtBQUs7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxNQUFNLEtBQUssRUFBRSxLQUFLLE1BQU0sS0FBSyxHQUFHLEtBQUssTUFBTSxLQUFLO0FBQzNFLFdBQVcsS0FBSyxPQUFPLEtBQUssR0FBRyxLQUFLLE9BQU8sS0FBSyxFQUFFLEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLEVBQUUsS0FBSztBQUN2RSxzQkFBc0IsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLElBQUksS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSztBQUN2RSxzQkFBc0IsS0FBSyxJQUFJLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSxHQUFHLEVBQUUsR0FBRyxJQUFJLEtBQUssR0FBRyxLQUFLLE1BQU0sS0FBSyxFQUFFLEtBQUssTUFBTSxLQUFLLEVBQUUsS0FBSztBQUN6RSxhQUFhLEtBQUssRUFBRSxLQUFLLE9BQU8sS0FBSyxHQUFHLEtBQUssT0FBTyxLQUFLLEdBQUcsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVksR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSxHQUFHLEVBQUUsR0FBRyxJQUFJLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLLE1BQU0sS0FBSztBQUM3RixVQUFVLEtBQUssTUFBTSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxHQUFHLEtBQUssSUFBSSxLQUFLLEVBQUUsS0FBSyxPQUFPLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSztBQUMxRyxVQUFVLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssRUFBRSxLQUFLLE9BQU8sS0FBSyxHQUFHLEtBQUssSUFBSSxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ25HLFdBQVcsS0FBSyxFQUFFLEtBQUssS0FBSyxLQUFLLEdBQUcsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixLQUFLLElBQUksS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLEdBQUcsS0FBSyxPQUFPLEtBQUssRUFBRSxLQUFLLE1BQU0sS0FBSyxFQUFFLEtBQUs7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLEdBQUcsR0FBRyxHQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckIsZUFBZSxLQUFLO0FBQ3BCLGFBQWEsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxHQUFHLEtBQUs7QUFDL0MsZ0JBQWdCLEtBQUs7QUFDckIsYUFBYSxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztBQUNsRCxhQUFhLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxLQUFLO0FBQy9DLGNBQWMsS0FBSyxFQUFFLEtBQUs7QUFDMUIsYUFBYSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSztBQUM5QyxjQUFjLEtBQUssRUFBRSxLQUFLO0FBQzFCLGFBQWEsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxHQUFHLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsR0FBRyxHQUFHLHFCQUFxQixLQUFLO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSxHQUFHLEVBQUUsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVksR0FBRyxFQUFFLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLEdBQUcsRUFBRSxHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHLE1BQU0sS0FBSyxJQUFJLEtBQUssU0FBUyxLQUFLLE1BQU0sS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLEdBQUcsS0FBSztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ3JCLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckIsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QiwyQ0FBMkM7QUFDekU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsSUFBSSxLQUFLO0FBQzdCLGtGQUFrRjs7QUFFbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pkZ0M7O0FBS2Q7O0FBT0E7O0FBRTBDOztBQUlmOztBQUtsQjs7QUFPRzs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRWU7QUFDZjtBQUNBOztBQUVBLEVBQUUsMEVBQWlCOztBQUVuQjtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVEsa0RBQVE7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsZ0RBQVM7QUFDMUIsSUFBSSw4Q0FBTztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDhDQUFPOztBQUVYLElBQUksZ0RBQVM7O0FBRWI7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLGtEQUFRO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsZUFBZSxnREFBUztBQUN4QixJQUFJLDhDQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksOENBQU87O0FBRVgsSUFBSSxnREFBUzs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsZUFBZSxnREFBUztBQUN4QixJQUFJLDhDQUFPLFFBQVEsT0FBTztBQUMxQixJQUFJLDhDQUFPOztBQUVYLElBQUksZ0RBQVM7O0FBRWI7QUFDQTs7O0FBR0E7O0FBRUEsY0FBYyxnREFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLElBQUksaURBQVU7O0FBRWQsSUFBSSxnREFBUzs7QUFFYjtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdFQUFXOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQywyRUFBUTtBQUMxQztBQUNBO0FBQ0EsYUFBYSxnREFBTTtBQUNuQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxpRUFBWTtBQUMxQixnQkFBZ0IsbUVBQWM7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsY0FBYyxpRUFBWTtBQUMxQixnQkFBZ0IsbUVBQWM7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVULE9BQU87QUFDUCxjQUFjLGdEQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULFFBQVEsZ0RBQVM7QUFDakI7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOzs7QUFHQSwrQ0FBUSxpQkFBaUIscUVBQVk7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsU0FBUyxtREFBRTtBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxnRUFBVztBQUNwQjs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsa0VBQWlCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrRUFBaUI7O0FBRTVCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5VWtCOztBQUlzQjs7QUFJYjs7O0FBRzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNPOztBQUVQO0FBQ0EsV0FBVywrQ0FBSzs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsU0FBUyw4Q0FBSTtBQUNiO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7OztBQUdBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsZ0ZBQWdCO0FBQ3pCOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGdGQUFnQjtBQUN6Qjs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxnRkFBZ0I7QUFDekI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGdGQUFnQjtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsa0VBQWlCOztBQUU1QjtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekprQzs7QUFFYzs7QUFFaEQ7QUFDQTs7O0FBR2U7O0FBRWYscUJBQXFCLGdEQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxxQ0FBcUM7O0FBRXhDOztBQUVBLHNCQUFzQixnREFBTSxHQUFHO0FBQy9CO0FBQ0EsR0FBRyxzQ0FBc0M7O0FBRXpDLHFCQUFxQiw2REFBUTtBQUM3QjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEY4QztBQUNKOztBQUVWOztBQUVoQyxpRUFBZTtBQUNmO0FBQ0EsNEJBQTRCLG9EQUFjO0FBQzFDLDBCQUEwQixrREFBWTtBQUN0QyxxQkFBcUIsNkNBQU87QUFDNUIsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUmU7O0FBSUM7O0FBSVk7O0FBRVk7O0FBSVA7QUFDbUI7O0FBRXREO0FBQ0E7QUFDQSxTQUFTLDJEQUFhO0FBQ3RCLDJCQUEyQixhQUFhO0FBQ3hDOztBQUVlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsa0VBQU87O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtFQUFLOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxnREFBTTs7QUFFckI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsa0VBQWlCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDBFQUEwRTtBQUMxRTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLElBQUksa0RBQWdCO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0cwQztBQUNrQjs7QUFFNUQsaUVBQWU7QUFDZjtBQUNBLElBQUksOERBQW1CO0FBQ3ZCO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQVk7QUFDdEMsQ0FBQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSmlCOztBQUlpQjs7QUFFTztBQUNtQjs7O0FBRzdEO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVMsNkVBQWtCO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMERBQTBELHdCQUF3Qjs7QUFFbEYsUUFBUSxpREFBTzs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGdEQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsSUFBSSxpREFBTyxDQUFDLDhDQUFJLENBQUMsb0RBQU07QUFDdkIsa0JBQWtCLG9EQUFNOztBQUV4QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNLGdEQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU0sbURBQUU7QUFDUjtBQUNBOztBQUVBLE1BQU0sbURBQUU7QUFDUixJQUFJLGdEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxrRUFBaUI7O0FBRTVCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDek00RDtBQUNPO0FBQ0g7QUFDSjtBQUNGO0FBQ2Q7O0FBRVU7O0FBRXRELGlFQUFlO0FBQ2Y7QUFDQSxJQUFJLDhEQUFtQjtBQUN2QixJQUFJLHdFQUFnQjtBQUNwQixJQUFJLHNFQUFlO0FBQ25CLElBQUksb0VBQWE7QUFDakIsSUFBSSxtRUFBWTtBQUNoQixJQUFJLGdEQUFlO0FBQ25CO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQWtCO0FBQ2xELENBQUMsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWaUI7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QjtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QixXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsYUFBYTtBQUN4QjtBQUNlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxnREFBTTtBQUNqQjtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBUTtBQUNuQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sOENBQUksOEJBQThCLHNEQUFZLEVBQUUscUJBQXFCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGlEQUFPO0FBQy9CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLGlEQUFPO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLEVBQUUsaURBQU87QUFDVDs7QUFFQSxRQUFRLDZDQUFHO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLFFBQVEsbURBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0RBQVE7QUFDaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxpREFBTztBQUNiLFdBQVcsZ0RBQU07O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxNQUFNLGtEQUFRO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUCxTQUFTLGdEQUFNOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNQOEI7O0FBUVo7O0FBRWxCO0FBQ0EsT0FBTyxpREFBTztBQUNkO0FBQ0E7O0FBRUEsRUFBRSxpREFBTztBQUNULFNBQVMscURBQVc7QUFDcEI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLE9BQU8saURBQU87QUFDZDtBQUNBOztBQUVBLEVBQUUsaURBQU87QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7OztBQUdlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Qsa0VBQWlCOztBQUV6RTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0EseUJBQXlCLGtFQUFpQjs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDhDQUFJLGFBQWEsZ0RBQU07QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGtFQUFpQjs7QUFFbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5SWlFOztBQUVqQjtBQUNWOztBQUV0QyxpRUFBZTtBQUNmO0FBQ0EsSUFBSSx1RUFBZTtBQUNuQjtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFlO0FBQzVDLHdCQUF3QixnREFBVTtBQUNsQyxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWm9EO0FBQ0c7O0FBS3ZDOztBQUVnRDs7O0FBR2xFOztBQUVlOztBQUVmOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsa0VBQWlCO0FBQ2xDO0FBQ0E7O0FBRUEsZUFBZSxnRkFBa0I7O0FBRWpDO0FBQ0EsZUFBZSxnREFBTTtBQUNyQjtBQUNBLEtBQUs7O0FBRUwsaUJBQWlCLDZDQUFHLFdBQVcsMkRBQUs7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ2tEOztBQUVsRCxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBZ0I7QUFDOUMsQ0FBQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKZ0I7O0FBSUM7O0FBSUs7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQywrQ0FBTTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLCtDQUFhO0FBQ2YsR0FBRztBQUNILEVBQUUsK0NBQWE7QUFDZixHQUFHO0FBQ0gsRUFBRSwrQ0FBYTtBQUNmLEdBQUc7QUFDSCxFQUFFLCtDQUFhO0FBQ2Y7QUFDQSxHQUFHO0FBQ0gsRUFBRSwrQ0FBYTtBQUNmO0FBQ0EsR0FBRztBQUNILEVBQUUsK0NBQWE7QUFDZjtBQUNBLEdBQUc7QUFDSCxFQUFFLCtDQUFhO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLGdDQUFnQyx3REFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBCQUEwQjtBQUN6RTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCO0FBQ0EsMkRBQTJELGdEQUFNLEdBQUc7QUFDcEU7QUFDQSxHQUFHO0FBQ0gsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlNTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25EOEM7O0FBRTlDLGlFQUFlO0FBQ2Y7QUFDQSw0QkFBNEIsb0RBQWM7QUFDMUMsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0w4Qjs7QUFFaUQ7O0FBSTNDOzs7QUFHdEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ2U7QUFDZixrQkFBa0IseUZBQWE7QUFDL0I7O0FBRUEsK0NBQVEsc0JBQXNCLHlGQUFhOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRSxnSUFBb0Q7O0FBRXREOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxvQkFBb0IscUVBQU87O0FBRTNCO0FBQ0E7QUFDQSxTQUFTLHVDQUF1QztBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUp5RTs7QUFFakI7O0FBRXhELGlFQUFlO0FBQ2Y7QUFDQSxJQUFJLDJFQUFtQjtBQUN2QjtBQUNBLDJCQUEyQix5REFBbUI7QUFDOUMsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTmU7O0FBSWU7O0FBSUU7O0FBRWxDO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLCtDQUFNOztBQUU1QztBQUNBOztBQUVBLHdCQUF3QixxRUFBZ0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLCtDQUFhO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsdUJBQXVCLHFFQUFnQjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdILGVBQWUscUNBQXFDO0FBQ3BEO0FBQ0EsSUFBSSwrQ0FBYTtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsRUFBRSwrQ0FBYTtBQUNmOztBQUVBOztBQUVBLGdDQUFnQyw2REFBVTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUUsK0NBQWE7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLHNEQUFzRCxtQkFBbUI7O0FBRXpFO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsRUFBRSwrQ0FBYTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyTkFBMk4sdUNBQXVDLG1JQUFtSSx1QkFBdUIsbUJBQW1CLDRCQUE0QjtBQUMzYyxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hVOEM7O0FBRTlDLGlFQUFlO0FBQ2Y7QUFDQSw0QkFBNEIsb0RBQWM7QUFDMUMsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTDhCOztBQUVpRDs7O0FBR2pGO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNlO0FBQ2Ysa0JBQWtCLHNGQUFnQjtBQUNsQzs7QUFFQSwrQ0FBUSx5QkFBeUIsc0ZBQWdCOztBQUVqRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLGNBQWM7QUFDekI7QUFDQTs7QUFFQTtBQUNBLEVBQUUsc0hBQWdEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1SThEOztBQUVBOztBQUU5RCxpRUFBZTtBQUNmO0FBQ0EsSUFBSSxxRUFBYztBQUNsQjtBQUNBO0FBQ0EsOEJBQThCLDREQUFzQjtBQUNwRCxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1JnQjs7QUFJWTs7QUFFOUI7QUFDQTs7O0FBR2U7QUFDZjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsS0FBSyxVQUFVLG1EQUFFO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTSxnREFBUzs7QUFFZjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdERrQjs7QUFJRzs7QUFFaUM7O0FBT3hCOzs7QUFHZjtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsUUFBUSxrRUFBSzs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBLGFBQWEsb0RBQVE7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFLGdEQUFNOztBQUVSOztBQUVBO0FBQ0EsTUFBTSxrRUFBSztBQUNYLElBQUksZ0RBQU07QUFDVjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLE1BQU0sZ0VBQWU7QUFDckIsSUFBSSxnREFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMOzs7QUFHQSxFQUFFLGdEQUFNO0FBQ1I7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjs7QUFFaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxNQUFNLGtFQUFLOztBQUVYLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxJQUFJLGdEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxnREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxJQUFJLGdEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxNQUFNLGdFQUFlO0FBQ3JCLFVBQVUsaUVBQWdCO0FBQzFCLFVBQVUsd0RBQU87O0FBRWpCLDJCQUEyQixvRUFBbUI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsSUFBSSxnREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBLE1BQU0sa0VBQUs7QUFDWCxJQUFJLGdEQUFNO0FBQ1Y7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsVUFBVTtBQUNWOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzlTc0Q7O0FBRXREO0FBQ0EsTUFBTSxrRUFBSztBQUNYO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCc0I7O0FBT1c7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSSxvREFBUTs7QUFFWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsd0RBQU87QUFDaEIsV0FBVyxnRUFBZTtBQUMxQixZQUFZLGlFQUFnQjtBQUM1Qjs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixvRUFBbUI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG9EQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsd0RBQU87QUFDaEI7QUFDQTs7QUFFQSxRQUFRLHdEQUFPOztBQUVmO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDs7QUFFQTtBQUNBOztBQUVBLGVBQWUsb0RBQVE7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSXlFO0FBQ2Y7QUFDRTs7QUFFRjtBQUNGOzs7QUFHeEQsaUVBQWU7QUFDZjtBQUNBLElBQUksMkVBQW1CO0FBQ3ZCLElBQUksbUVBQVk7QUFDaEIsSUFBSSw4REFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwREFBb0I7QUFDdEQsaUNBQWlDLHlEQUFtQjtBQUNwRCxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQmdCOztBQUVjOztBQUVVOztBQUUwQjs7QUFJdEM7OztBQUc5QjtBQUNBO0FBQ0E7QUFDZTtBQUNmLEVBQUUsNEVBQXVCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBUSxpQkFBaUIsdUVBQWtCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyx3RkFBbUM7O0FBRXpFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdEQUFNLEVBQUUsZ0JBQWdCLEVBQUUsK0RBQWtCO0FBQ3BGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLDhFQUE4RTtBQUM5RTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLE1BQU0sbURBQUU7QUFDUixZQUFZLGdEQUFNO0FBQ2xCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsSUFBSSxnREFBTTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLGdEQUFNO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0EsTUFBTSxtREFBRTtBQUNSLFlBQVk7QUFDWjs7QUFFQSxNQUFNLG1EQUFFO0FBQ1IsWUFBWTtBQUNaOztBQUVBLE1BQU0sbURBQUU7QUFDUixZQUFZO0FBQ1o7O0FBRUEsVUFBVTtBQUNWOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QjtBQUNBOztBQUVBLEVBQUUsaURBQU87QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVKZ0M7O0FBRXFDOztBQUVEO0FBQ0E7QUFDbEI7QUFDRTs7QUFFcUI7OztBQUd6RTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsYUFBYTtBQUN4QixXQUFXLFlBQVk7QUFDdkI7QUFDZTtBQUNmO0FBQ0E7O0FBRUEsRUFBRSxtRkFBaUI7O0FBRW5CO0FBQ0E7O0FBRUEsK0NBQVEsV0FBVyw4RUFBWTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGlCQUFpQix5R0FBdUM7O0FBRXhELHlDQUF5QyxpRUFBdUI7QUFDaEUsa0NBQWtDLGlFQUF1QjtBQUN6RCwrQkFBK0Isd0RBQWM7QUFDN0MsaUNBQWlDLHlEQUFlO0FBQ2hELG9DQUFvQywwRUFBa0I7O0FBRXREO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUZrQjs7QUFJVzs7QUFJQzs7O0FBR2Y7QUFDZjtBQUNBOztBQUVBOzs7QUFHQTtBQUNBLFNBQVMseURBQUs7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU0sbURBQUU7QUFDUjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9EQUFvRDs7QUFFcEQ7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQSw2Q0FBNkMsZ0RBQU07QUFDbkQ7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdFa0I7O0FBRWM7O0FBSVM7O0FBSVg7O0FBSUE7O0FBRTZDOztBQUUzRTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTs7QUFFQSxFQUFFLG1GQUF1Qjs7QUFFekI7QUFDQTs7QUFFQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpREFBTztBQUNYLFVBQVUsbURBQUU7QUFDWjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLG1EQUFFO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyx1QkFBdUIsRUFBRTtBQUN4RDtBQUNBLEdBQUc7O0FBRUg7O0FBRUEsK0NBQVEsZ0JBQWdCLDhFQUFrQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5Qix1REFBSztBQUM5QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQSxpQ0FBaUMsdURBQUs7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsZ0RBQU07QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7O0FBRUEsbUJBQW1CLG1EQUFFO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJLHVFQUFnQjtBQUNwQjtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxNQUFNLG1EQUFFO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVEsS0FBSyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx1RUFBZ0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksdUVBQWdCOztBQUVwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLG1EQUFFO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyVGdDOztBQU1VOztBQUlSOztBQUlEOztBQUUwQzs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ2U7O0FBRWYsRUFBRSxtRkFBdUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0EsU0FBUyxpRUFBZ0I7QUFDekI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQix3RUFBTTtBQUMzQjtBQUNBLG1CQUFtQix3RUFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHdFQUFNOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsK0RBQVM7O0FBRXpCO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQVEsbUNBQW1DLDhFQUFrQjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHdFQUFNO0FBQ3pCLHdCQUF3QixnRkFBYzs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBLG1CQUFtQix3RUFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBLGlCQUFpQix3RUFBTTs7QUFFdkIsbUJBQW1CLHdFQUFNOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGdGQUFjO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pSZ0M7O0FBRTJDOzs7QUFHNUQ7O0FBRWYsRUFBRSxtRkFBdUI7O0FBRXpCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsK0NBQVEsaUJBQWlCLDhFQUFrQjs7QUFFM0M7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0JnQzs7QUFJZDs7QUFLZTs7QUFFMEM7OztBQUc1RDs7QUFFZixFQUFFLG1GQUF1Qjs7QUFFekI7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUSxtREFBRTtBQUNWLDZCQUE2QixrRUFBaUI7QUFDOUMsK0JBQStCLGdEQUFNLGtCQUFrQixxQkFBcUI7QUFDNUU7O0FBRUEsUUFBUSxtREFBRTtBQUNWLDZCQUE2QixrRUFBaUI7QUFDOUMsZ0NBQWdDLGdEQUFNLGtCQUFrQix1QkFBdUI7QUFDL0U7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsK0NBQVEsNkJBQTZCLDhFQUFrQjs7QUFFdkQ7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Q2dDOztBQUtDOztBQUUwQzs7O0FBRzVEOztBQUVmLEVBQUUsbUZBQXVCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUSxtREFBRTtBQUNWO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLG1EQUFFLHVDQUF1QyxrRUFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLCtDQUFRLHVCQUF1Qiw4RUFBa0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7Ozs7O0FDakQ2Qzs7QUFFN0M7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdURBQXVELG1EQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDMEM7O0FBRU87OztBQUdqRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDZTs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsNERBQWE7QUFDekMsOEJBQThCLDREQUFhOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0VBQU07QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdFQUFNO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUVrQjs7QUFFYzs7QUFLQzs7QUFPQTs7QUFJTTs7QUFJUDs7QUFFMkM7O0FBSW5DOztBQUtFOztBQUlBOztBQUl4Qjs7QUFLWTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsYUFBYTtBQUN4QjtBQUNlO0FBQ2Y7QUFDQTs7QUFFQSxFQUFFLG1GQUF1Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsd0RBQU8sY0FBYyxnRUFBZTtBQUM1QztBQUNBOztBQUVBO0FBQ0EsU0FBUyxrRUFBUTtBQUNqQjtBQUNBOztBQUVBLHNCQUFzQixvRUFBbUI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQVE7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELHFCQUFxQjtBQUMxRTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsbURBQUU7QUFDWDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxJQUFJLGdEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQU0sR0FBRztBQUN6QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcseUVBQWtCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixrRUFBaUI7O0FBRTFDO0FBQ0EsU0FBUyxnRUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlFQUFnQjs7QUFFeEI7QUFDQSxxQkFBcUIsd0VBQU07QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLCtDQUFRLGdCQUFnQiw4RUFBa0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ087O0FBRVAsMEJBQTBCLGlGQUFpQjs7QUFFM0MsU0FBUyw0RUFBVSxDQUFDLHVFQUFLO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVztBQUNYO0FBQ087O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsdUVBQWlCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwRUFBb0I7QUFDcEM7QUFDQSxHQUFHOztBQUVILGVBQWUsZ0RBQU07O0FBRXJCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaFlnQzs7QUFFRzs7QUFFd0M7OztBQUczRTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhFQUFrQjs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlEQUFPO0FBQ1g7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0QsR0FBRztBQUNIOztBQUVBLCtDQUFRLDBCQUEwQiw4RUFBa0I7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsaURBQU87QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMEVBQTBFLGdCQUFnQjtBQUMxRixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekdnQzs7QUFFMkM7O0FBRXpCOzs7QUFHbEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ2U7QUFDZixrQkFBa0IsOEVBQWtCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHdEQUFPO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBLCtDQUFRLG9CQUFvQiw4RUFBa0I7O0FBRTlDLDJFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Q2tGO0FBQ3BDO0FBQ0k7QUFDQTtBQUNOO0FBQ29CO0FBQ1o7QUFDa0I7QUFDWjs7QUFFMUQsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHNFQUFnQztBQUM5RSw0QkFBNEIsb0RBQWM7QUFDMUMsOEJBQThCLHNEQUFnQjtBQUM5Qyw4QkFBOEIsc0RBQWdCO0FBQzlDLDJCQUEyQixtREFBYTtBQUN4QyxxQ0FBcUMsNkRBQXVCO0FBQzVELCtCQUErQix1REFBaUI7QUFDaEQsd0NBQXdDLGdFQUEwQjtBQUNsRSxrQ0FBa0MsMERBQW9CO0FBQ3RELENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0JGO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWCxXQUFXO0FBQ1gsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssK0JBQStCO0FBQ3BDLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWEsTUFBTSxHQUFHLE1BQU07QUFDNUIsWUFBWSxNQUFNO0FBQ2xCO0FBQ087O0FBRVA7O0FBRUE7QUFDQSxZQUFZOztBQUVaO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYSxNQUFNLEdBQUcsTUFBTTtBQUM1QixZQUFZLE1BQU07QUFDbEI7QUFDTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1gsWUFBWSxNQUFNO0FBQ2xCO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSHlCOztBQUlLOztBQUlZOzs7QUFHbkM7O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ087O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixrRUFBYTtBQUNoQztBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw0REFBWTtBQUNuQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw0RUFBVTtBQUNuQjtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTs7QUFFQSx5QkFBeUIscUVBQXFCO0FBQzlDLHlCQUF5QixxRUFBcUI7O0FBRTlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx3REFBUTtBQUNuQixXQUFXLHdEQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUscUVBQXFCO0FBQ3BDLHFCQUFxQixxRUFBcUI7O0FBRTFDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsdUJBQXVCOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3BPQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakI7QUFDQSxZQUFZO0FBQ1o7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7OztBQ25DZTtBQUNmO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDa0I7O0FBRTBCOzs7QUFHNUMsb0JBQW9CLDJEQUFZOzs7QUFHakI7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUUsaURBQU87O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDeUM7OztBQUcxQjtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLG9FQUFhO0FBQ2Y7O0FBRUEsRUFBRSx1RUFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLHVFQUFnQjtBQUNsQjs7QUFFQSxFQUFFLG9FQUFhO0FBQ2Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNFa0I7O0FBSWU7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGtFQUFpQjs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esc0JBQXNCLDhDQUFJOztBQUUxQixTQUFTLGdEQUFNOztBQUVmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1REFBdUQsOENBQUk7QUFDM0Q7O0FBRUE7QUFDQSxHQUFHLElBQUk7QUFDUDs7O0FBR0E7QUFDQSxTQUFTLGdEQUFNO0FBQ2Y7O0FBRUE7QUFDQSxHQUFHLElBQUk7QUFDUDs7O0FBR0E7QUFDQSxFQUFFLGlEQUFPOztBQUVUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0EsRUFBRSxpREFBTztBQUNUO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUEsdUJBQXVCLGdEQUFNLEdBQUc7O0FBRWhDO0FBQ0E7QUFDQSw2QkFBNkIsa0VBQWlCO0FBQzlDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdOd0M7QUFDTDtBQUNXO0FBQ0w7QUFDRjs7QUFFWTtBQUNXO0FBQ1M7QUFDRTtBQUNUO0FBQ1M7QUFDUjs7QUFFdEI7QUFDQztBQUNFO0FBQ1o7QUFDd0I7QUFDOEI7OztBQUd4RixpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDhDQUFjO0FBQ2xCLElBQUksMkNBQVc7QUFDZixJQUFJLGlEQUFnQjtBQUNwQixJQUFJLDhDQUFjO0FBQ2xCLElBQUksNkNBQWE7QUFDakIsSUFBSSwyREFBYTtBQUNqQixJQUFJLHFFQUFjO0FBQ2xCLElBQUksMEVBQWtCO0FBQ3RCLElBQUksMkVBQW1CO0FBQ3ZCLElBQUksc0VBQWU7QUFDbkIsSUFBSSw0RUFBbUI7QUFDdkIsSUFBSSx3RUFBZTtBQUNuQjtBQUNBLDJCQUEyQixvREFBWTtBQUN2QywyQkFBMkIsb0RBQWE7QUFDeEMsNEJBQTRCLHFEQUFjO0FBQzFDLHNCQUFzQiwrQ0FBUTtBQUM5QixzQkFBc0Isd0VBQVE7QUFDOUIsK0JBQStCLHFGQUF5QjtBQUN4RCxDQUFDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdDaUI7O0FBRTJCOzs7QUFHN0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsY0FBYztBQUN6QjtBQUNBLFlBQVk7QUFDWjtBQUNPO0FBQ1AsU0FBUyw4Q0FBSTtBQUNiLFdBQVcsbURBQUU7QUFDYixHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLHFCQUFxQjtBQUNoQztBQUNBLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQ2dDOztBQUVpRDs7QUFJMUM7O0FBS3JCOzs7QUFHbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNlOztBQUVmLEVBQUUsMkZBQXFCOztBQUV2QjtBQUNBLEtBQUssc0NBQXNDLFdBQVc7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxnQkFBZ0IsOENBQUk7QUFDcEIsYUFBYSxrRUFBSztBQUNsQixLQUFLOztBQUVMLG9DQUFvQztBQUNwQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLGtFQUFLO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELFFBQVEsS0FBSyxPQUFPO0FBQ3BFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxzQkFBc0IsbURBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQVEseUJBQXlCLHNGQUFnQixFOzs7Ozs7Ozs7Ozs7Ozs7OztBQzlISzs7QUFFUTs7QUFFOUQsaUVBQWU7QUFDZjtBQUNBLElBQUksa0VBQVM7QUFDYjtBQUNBO0FBQ0Esb0NBQW9DLDREQUFzQjtBQUMxRCxDQUFDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUmlCOztBQUV3Qjs7O0FBRzFDO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZDQUE2QyxnREFBTSxFQUFFLGFBQWE7QUFDbEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSyxJQUFJLGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7O0FBRUEsRUFBRSxnREFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMENBQTBDLFFBQVEsMkRBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVEseURBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9JNEQ7QUFDRjtBQUNPO0FBQ0E7QUFDRjtBQUNUOztBQUVOOztBQUVoRCxpRUFBZTtBQUNmO0FBQ0EsSUFBSSxvRUFBYTtBQUNqQixJQUFJLG1FQUFZO0FBQ2hCLElBQUksdUVBQWU7QUFDbkIsSUFBSSx1RUFBZTtBQUNuQixJQUFJLHNFQUFjO0FBQ2xCLElBQUksa0VBQVM7QUFDYjtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFlO0FBQzVDLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQmdCOzs7QUFHbEI7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLE9BQU87QUFDbkI7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUUsaURBQU87QUFDVDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksZUFBZTtBQUMzQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsSWlFO0FBQzFCOztBQUVpQjs7O0FBR3hELGlFQUFlO0FBQ2Y7QUFDQSxJQUFJLHVFQUFlO0FBQ25CLElBQUksNkNBQWE7QUFDakI7QUFDQTtBQUNBLGlDQUFpQyx5REFBbUI7QUFDcEQsQ0FBQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2IwRTs7QUFFM0M7O0FBRUc7O0FBS2pCOztBQUlEOztBQUlDOztBQUVsQjs7O0FBR2U7QUFDZjtBQUNBOztBQUVBLEVBQUUsbUZBQXVCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTs7QUFFQSxJQUFJLGlEQUFPOztBQUVYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLGdEQUFNLGNBQWMsNkJBQTZCOztBQUV2RDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLDhDQUFRLHdCQUF3QixpREFBUzs7QUFFekQ7QUFDQSxRQUFRLDhDQUFPLE9BQU8sa0JBQWtCO0FBQ3hDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSSxpREFBTzs7QUFFWCx3QkFBd0IsOENBQVEsd0JBQXdCLGlEQUFTOztBQUVqRTtBQUNBLFFBQVEsOENBQU8sZUFBZSxvQkFBb0I7QUFDbEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBUSx1QkFBdUIsOEVBQWtCLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0gwQjs7QUFFakI7O0FBRTFELGlFQUFlO0FBQ2Y7QUFDQSxJQUFJLDRFQUFvQjtBQUN4QjtBQUNBO0FBQ0Esa0NBQWtDLDBEQUFvQjtBQUN0RCxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0pnQjs7QUFFMEM7O0FBRTVEO0FBQ0EsT0FBTyxpREFBTztBQUNkO0FBQ0E7O0FBRUEsRUFBRSxpREFBTztBQUNULFNBQVMscURBQVc7QUFDcEI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0IsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHdFQUFnQjtBQUN2QywwQkFBMEIsd0VBQWdCO0FBQzFDOztBQUVBO0FBQ0EsSUFBSSxnREFBTSxvQkFBb0IsOENBQUk7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pINEM7QUFDZ0I7QUFDSTs7QUFFcEI7O0FBRTVDLGlFQUFlO0FBQ2Y7QUFDQSxJQUFJLGdEQUFlO0FBQ25CLElBQUksb0VBQWE7QUFDakIsSUFBSSxzRUFBZTtBQUNuQjtBQUNBLDJCQUEyQixtREFBYTtBQUN4QyxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWGdCOztBQUVjOztBQUlGOztBQUlBOztBQUV3QztBQUNoQjs7O0FBR3REO0FBQ0E7QUFDQTtBQUNlO0FBQ2YsRUFBRSxvRkFBaUI7QUFDbkI7O0FBRUEsK0NBQVEsY0FBYywrRUFBWTs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVywrQ0FBSztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxtREFBRTtBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsTUFBTSx3REFBTztBQUNiO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLG1EQUFFLG9DQUFvQyxtREFBRTtBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU0sd0RBQU87QUFDYjtBQUNBOztBQUVBLE1BQU0sbURBQUU7QUFDUjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU0sd0RBQU87QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxrRUFBSztBQUNYO0FBQ0E7O0FBRUEsTUFBTSxtREFBRTtBQUNSO0FBQ0E7O0FBRUEsTUFBTSxtREFBRTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RQd0Q7O0FBRWhCOztBQUV4QyxpRUFBZTtBQUNmO0FBQ0EsSUFBSSxrRUFBVztBQUNmO0FBQ0E7QUFDQSx5QkFBeUIsaURBQVc7QUFDcEMsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVjhCOztBQUVxRDs7QUFFckY7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNlO0FBQ2Ysa0JBQWtCLHdGQUFrQjtBQUNwQzs7QUFFQSwrQ0FBUSwyQkFBMkIsd0ZBQWtCOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGdIQUEwQztBQUNuRDs7QUFFQTtBQUNBLFNBQVMsMkhBQXFEO0FBQzlEOztBQUVBO0FBQ0EsU0FBUyxzSEFBZ0Q7QUFDekQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlCa0U7QUFDSjs7QUFFOUQsaUVBQWU7QUFDZixpQkFBaUIscUVBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhEQUF3QjtBQUN4RCxDQUFDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUaUQ7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsY0FBYztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxhQUFhLGNBQWM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLDJCQUEyQjtBQUN2QyxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QyxhQUFhLCtCQUErQjtBQUM1QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsdUJBQXVCLHFDQUFxQztBQUM1RDtBQUNBOztBQUVBLHFCQUFxQixzREFBZ0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLDJCQUEyQjs7QUFFdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxzQkFBc0IscUJBQXFCO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNILEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEZrQjs7QUFFcUI7O0FBS1o7O0FBSWtCOztBQUk3Qjs7O0FBR2hCO0FBQ0EsU0FBUyxnREFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHVDQUF1QyxRQUFRLGdCQUFnQixXQUFXLEVBQUUsU0FBUztBQUNyRixhQUFhLHNEQUFlO0FBQzVCLGdCQUFnQixzREFBZTtBQUMvQjtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsYUFBYTtBQUN4QjtBQUNlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbURBQUU7O0FBRVI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtREFBRTs7QUFFYjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxHQUFHLGNBQWMsU0FBUztBQUNyRSxVQUFVLHNEQUFlO0FBQ3pCLGdCQUFnQixzREFBZTtBQUMvQixLQUFLO0FBQ0w7O0FBRUE7QUFDQSxNQUFNLGdFQUFlLGNBQWMsMkVBQVE7QUFDM0M7QUFDQTs7O0FBR0EsNkNBQTZDLG1CQUFtQjs7QUFFaEU7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pELGdCQUFnQixzREFBZTtBQUMvQixLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsdUVBQXNCOztBQUVqQyxTQUFTLDJFQUFROztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkVBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQ0FBZ0MsU0FBUyxFQUFFLEtBQUs7QUFDaEQsZ0JBQWdCLHNEQUFlO0FBQy9CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLFNBQVMsbURBQUU7QUFDWCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdFBrQjs7QUFFYTs7QUFJZjs7QUFFaEIsaUJBQWlCLG9EQUFJO0FBQ3JCLEdBQUcseUNBQXlDO0FBQzVDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBSTtBQUNiO0FBQ0EsR0FBRztBQUNIOzs7QUFHZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVEsSUFBSSxVQUFVLHNEQUFlLFdBQVc7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsNkJBQTZCOztBQUV4RCxpREFBaUQsUUFBUSxJQUFJLFVBQVUsc0RBQWUsV0FBVztBQUNqRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9ELHFCQUFxQixzREFBZTtBQUNwQyxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtEQUFrRCxRQUFRO0FBQzFELG1CQUFtQixzREFBZTtBQUNsQyxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLGlEQUFPO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxjQUFjO0FBQzNCO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQixTQUFTLFVBQVUsc0RBQWU7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLHlEQUF5RCxNQUFNLEtBQUssWUFBWTtBQUNoRixtQkFBbUIsc0RBQWU7QUFDbEMseUJBQXlCLHNEQUFlO0FBQ3hDLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxpREFBTztBQUNYO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7OztBQ3ZQTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTnNEOztBQUVSOztBQUU5QyxpRUFBZTtBQUNmO0FBQ0EsSUFBSSxrRUFBUztBQUNiO0FBQ0EsNEJBQTRCLG9EQUFjO0FBQzFDLENBQUMsRTs7Ozs7Ozs7Ozs7QUNUWTs7QUFFYixjQUFjLG1CQUFPLENBQUMsbUNBQVc7O0FBRWpDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSjRDOztBQUVaOztBQUVZOztBQUU1QztBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ2U7QUFDZixFQUFFLCtDQUFXO0FBQ2I7O0FBRUEsdUNBQXVDLG9EQUFnQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxjQUFjO0FBQzVCLGNBQWMsY0FBYztBQUM1QixjQUFjLGFBQWE7QUFDM0IsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGNBQWMsYUFBYTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTyxrREFBUTtBQUNmO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsOENBQU0sQ0FBQyxnREFBTSxFQUFFLHlCQUF5QjtBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQkFBbUIsOENBQU07O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekZrQjs7QUFFWTs7QUFFMEI7QUFDRjtBQUNOOztBQUVoRDtBQUNBLFVBQVUsbURBQWlCO0FBQzNCLFlBQVkscURBQWE7QUFDekIsTUFBTSwrQ0FBYTtBQUNuQjs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QixZQUFZLGdEQUFNLEdBQUc7O0FBRXJCLGFBQWEsNENBQU07QUFDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQkEsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUks7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHTztBQUNQOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NrQjs7QUFFZTs7O0FBRzFCO0FBQ1A7QUFDQTtBQUNBOztBQUVPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ087QUFDUCxTQUFTLDhDQUFFO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsWUFBWSxRQUFRO0FBQ3BCO0FBQ087QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSxNQUFNO0FBQ2xCO0FBQ087O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTzs7QUFFUCxNQUFNLDhDQUFFO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGVBQWU7QUFDMUI7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyxnREFBTTtBQUNmO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2xIQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QyxZQUFZLE9BQU87QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDTztBQUNQOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0EsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7OztBQ3hCTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsS0FBSyxJQUEwQjtBQUMvQjtBQUNBO0FBQ0EsRUFBRSxNQUFNLEVBTU47QUFDRixDQUFDLFFBQVEscUJBQU0sa0JBQWtCLHFCQUFNOztBQUV2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pHZ0Y7O0FBRWpDOztBQUVoRCxpRUFBZTtBQUNmO0FBQ0EsSUFBSSwrRUFBdUI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQix1REFBYTtBQUN4QyxDQUFDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUGlCOztBQUVjOzs7QUFHaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDZTs7QUFFZjs7QUFFQTtBQUNBLHNCQUFzQiw2Q0FBTztBQUM3QjtBQUNBLGdCQUFnQiw4Q0FBSTtBQUNwQixtQkFBbUIsOENBQUk7QUFDdkIsR0FBRztBQUNIOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBLFdBQVcsT0FBTztBQUNsQixvREFBb0QsVUFBVSxxQkFBcUIsUUFBUTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsNERBQTRELHVCQUF1QjtBQUNuRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsOENBQUk7QUFDckI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4TGtCOztBQU9EOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNlO0FBQ2Y7O0FBRUEsZ0JBQWdCLCtDQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiw4Q0FBUTs7QUFFekI7QUFDQTs7QUFFQSxvQkFBb0IsOENBQUk7QUFDeEIscUJBQXFCLDhDQUFJO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLDhDQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxnREFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxxQkFBcUIsOENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxnREFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsRUFBRSwrQ0FBYTtBQUNmLEVBQUUsK0NBQWE7QUFDZixFQUFFLCtDQUFhOztBQUVmO0FBQ0EsSUFBSSwrQ0FBYTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFFBQVEsK0NBQVM7QUFDakI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QywrQ0FBTTtBQUM3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTSwrQ0FBYTtBQUNuQixNQUFNLCtDQUFhO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxpREFBZTtBQUNyQixNQUFNLGlEQUFlO0FBQ3JCOztBQUVBLElBQUksK0NBQWE7QUFDakI7O0FBRUEsRUFBRSxnREFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUUsaURBQWU7QUFDakIsRUFBRSxpREFBZTtBQUNqQixFQUFFLGlEQUFlO0FBQ2pCLEVBQUUsaURBQWU7O0FBRWpCO0FBQ0E7O0FBRUEsSUFBSSwrQ0FBUztBQUNiOztBQUVBLEVBQUUsK0NBQVM7QUFDWDs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JjZ0M7O0FBRUE7OztBQUdoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBLHFCQUFxQiwwQ0FBUTs7QUFFN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQywwQ0FBVTs7QUFFMUM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLGNBQWM7QUFDekI7QUFDZTs7QUFFZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RCxNQUFNO0FBQ047QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwTWtCOzs7QUFHbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQSxNQUFNLG9EQUFVLFVBQVUsa0RBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sb0RBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLGtEQUFRO0FBQ2Q7QUFDQTtBQUNBOztBQUVBLE9BQU8sb0RBQVU7QUFDakI7QUFDQTs7QUFFQSxPQUFPLGlEQUFPO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQSxFQUFFLGlEQUFPOztBQUVUO0FBQ0Esd0VBQXdFLFVBQVUsRUFBRTs7QUFFcEY7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQU87O0FBRVA7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQSxRQUFRLG9EQUFVLFlBQVksa0RBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzVJaUI7OztBQUdsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBLDZCQUE2QixrQ0FBa0M7QUFDL0QsSUFBSSxpQ0FBaUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRCxrQkFBa0IsWUFBWSxFQUFFLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ2U7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQiwrQ0FBK0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVMsc0JBQXNCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQW1CO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkNBQTZDLFdBQVcsa0RBQVEseUJBQXlCOztBQUV6Rjs7QUFFQSwyQkFBMkIsbUJBQW1COztBQUU5QztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsaURBQU87O0FBRXBCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JnQjBDOztBQUUxQyxpRUFBZTtBQUNmLDBCQUEwQixrREFBWTtBQUN0QyxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSWdCOztBQUtXOztBQUlIOztBQVFSOztBQUVzQzs7O0FBR3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsa0RBQVE7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUEsWUFBWSxnREFBTSxHQUFHLEdBQUcsZ0NBQWdDOztBQUV4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsZ0RBQU07QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZ0RBQVM7QUFDdkIsRUFBRSxpREFBVTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWMsV0FBVyxlQUFlO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGdEQUFTO0FBQ2pDLEVBQUUsOENBQU8sT0FBTyxnQ0FBZ0M7O0FBRWhELEVBQUUsZ0RBQVM7O0FBRVg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFRLENBQUMsOENBQUk7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLFdBQVc7QUFDN0Isa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1REFBTzs7QUFFdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksT0FBTyx3QkFBd0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdEQUFNO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUUsaURBQU87QUFDVDs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxpREFBVTtBQUNsQixPQUFPO0FBQ1AsUUFBUSxpREFBVTtBQUNsQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0RBQWdELG1FQUFtRTtBQUNuSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsaURBQVU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RDs7QUFFQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pELG1DQUFtQyx1QkFBdUI7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixtQkFBbUI7O0FBRWxEOztBQUVBLGlDQUFpQyw2QkFBNkI7QUFDOUQ7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLCtDQUFLO0FBQ25CO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBOztBQUVBO0FBQ0EsRUFBRSxzREFBYTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBSztBQUNiLFFBQVEsS0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDLG1DQUFtQzs7QUFFbkU7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQyw2QkFBNkI7O0FBRS9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxlQUFlO0FBQzFCLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsZUFBZTtBQUMxQixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsbUJBQW1COztBQUV0RDs7QUFFQTtBQUNBLEVBQUUseURBQWdCO0FBQ2xCOztBQUVBLG9DQUFvQyxtQkFBbUI7O0FBRXZEOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZ0JBQWdCLGdCQUFnQjtBQUNoQyxnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZ0JBQWdCLGdCQUFnQjtBQUNoQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZ0JBQWdCLHFCQUFxQjtBQUNyQyxnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZ0JBQWdCLHFCQUFxQjtBQUNyQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsMEJBQTBCO0FBQzNFOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtREFBWTtBQUM1Qiw0Q0FBNEMsc0RBQVk7QUFDeEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU0sbURBQVk7QUFDbEIsS0FBSztBQUNMOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGdEQUFNLEVBQUUsZUFBZSxhQUFhOztBQUVsRDs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxVQUFVO0FBQ1Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsV0FBVyxhQUFhLCtCQUErQixjQUFjO0FBQ3JFO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQixnREFBTTs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsaUNrQjs7QUFFZ0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTs7QUFFQSxVQUFVLGdEQUFNLEdBQUcsYUFBYTs7QUFFaEM7QUFDQTtBQUNBOztBQUVBLFNBQVMsOENBQU07QUFDZixFOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0NBOztBQUUyQzs7O0FBRzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUUsOENBQU87O0FBRVQ7QUFDQSxJQUFJLDhDQUFPO0FBQ1g7O0FBRUEsd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSSw4Q0FBTzs7QUFFWDtBQUNBLE1BQU0sOENBQU87QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQkFBbUIsOENBQU87QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVSxFQUFFO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN05rQjs7QUFFbEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQixNQUFNO0FBQ3ZELG9DQUFvQyxtQkFBbUI7QUFDdkQsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0JBQW9CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ2U7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQSxXQUFXLGlEQUFPOztBQUVsQixNQUFNLG9EQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU8sa0RBQVE7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLDhDQUFJOztBQUV6QjtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLG9EQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU8sa0RBQVE7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBLFdBQVcsaURBQU87O0FBRWxCOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1Qzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU8sV0FBVztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxnREFBTSxpQkFBaUI7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLGNBQWM7QUFDekI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyZ0JrQjs7QUFLWTs7QUFFdUI7O0FBRVQ7O0FBUTFCOztBQUlROztBQUUxQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQiwrREFBVztBQUM3QjtBQUNBLG9CQUFvQixnREFBUztBQUM3QixNQUFNLGlEQUFVOztBQUVoQixNQUFNLGdEQUFTO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZEQUFTOztBQUV4QixFQUFFLDhDQUFROztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnREFBUztBQUMxQixFQUFFLGlEQUFVOztBQUVaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJLGdEQUFTO0FBQ2I7O0FBRUEsWUFBWSxnREFBUztBQUNyQixFQUFFLGlEQUFVO0FBQ1osRUFBRSxpREFBVTs7QUFFWjtBQUNBLElBQUksaURBQVU7QUFDZDs7QUFFQSxFQUFFLGdEQUFTOztBQUVYO0FBQ0EsZUFBZSxnREFBUztBQUN4QixFQUFFLGlEQUFVOztBQUVaLEVBQUUsZ0RBQVM7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStELDhEQUFjO0FBQzdFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGdEQUFNOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLElBQUk7O0FBRVA7QUFDQTtBQUNBLEVBQUUsaURBQU87O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUksaURBQU87QUFDWDs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsZ0NBQWdDO0FBQ3hFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QyxnQ0FBZ0M7QUFDN0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksaUVBQVM7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsSUFBSSw4Q0FBTztBQUNYLEdBQUc7QUFDSCxJQUFJLDhDQUFPO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxnREFBUztBQUNYOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RQaUM7O0FBRUg7QUFDa0I7QUFDRjtBQUNaO0FBQ2M7O0FBRWhELGlFQUFlO0FBQ2YsaUJBQWlCLDBDQUFVO0FBQzNCO0FBQ0Esb0JBQW9CLDRDQUFNO0FBQzFCLDZCQUE2QixxREFBZTtBQUM1Qyw0QkFBNEIsb0RBQWM7QUFDMUMsc0JBQXNCLDhDQUFRO0FBQzlCLDZCQUE2QixxREFBZTtBQUM1QyxDQUFDLEU7Ozs7Ozs7Ozs7Ozs7OztBQ2hCRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ2U7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsV0FBVztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEZnQzs7QUFFVTs7QUFLZDs7QUFNVjs7QUFJUTs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDZTs7QUFFZjtBQUNBLEVBQUUsdURBQWlCOztBQUVuQix1REFBdUQsb0NBQW9DO0FBQzNGLG1DQUFtQyxtREFBbUQ7QUFDdEYsa0RBQWtELHdEQUF3RDtBQUMxRzs7QUFFQSwrQ0FBUSxrQkFBa0Isa0RBQVk7OztBQUd0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdEQUFTOztBQUV0QixFQUFFLDhDQUFPO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILE1BQU0sOERBQWM7QUFDcEIsSUFBSSw4Q0FBTztBQUNYLEdBQUc7QUFDSCxJQUFJLDhDQUFPO0FBQ1g7O0FBRUEsRUFBRSxnREFBUzs7QUFFWDtBQUNBOztBQUVBOztBQUVBLGFBQWEsNERBQVU7QUFDdkIsRUFBRSxnREFBUzs7QUFFWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsa0VBQWdCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSwwQkFBMEI7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMsa0VBQWdCO0FBQ3pCOzs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzR2tCOzs7QUFHbEI7QUFDQTtBQUNBO0FBQ2U7O0FBRWY7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLGNBQWM7QUFDNUIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGdEQUFNLFNBQVMscUJBQXFCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QixjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQSxTQUFTLGlEQUFPO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsZ0RBQU07QUFDdEIsYUFBYSxnREFBTSw4QkFBOEI7QUFDakQsS0FBSyxJQUFJOztBQUVULDZCQUE2QixnREFBTTtBQUNuQzs7QUFFQTtBQUNBLFNBQVMsaURBQU87QUFDaEI7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxnREFBTSxHQUFHLDZCQUE2QjtBQUMxRTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RWdEO0FBQ2xCOztBQUU5QixpRUFBZTtBQUNmO0FBQ0EsNkJBQTZCLHFEQUFlO0FBQzVDLG9CQUFvQiw0Q0FBTTtBQUMxQixDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSGdCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2U7QUFDZjtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxZQUFZLE9BQU8sRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUksaURBQU87QUFDWDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHVCQUF1QixnREFBTTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsZ0RBQU07QUFDM0I7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsZ0RBQU07QUFDL0I7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsZ0RBQU07O0FBRTdCOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0s0Qzs7QUFFNUMsaUVBQWU7QUFDZjtBQUNBLDJCQUEyQixtREFBYTtBQUN4QyxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNFZ0I7O0FBRTZCOztBQUVnQjs7QUFFL0I7O0FBRWtDOztBQUVsRTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCO0FBQ2U7O0FBRWYsRUFBRSxxRUFBdUI7O0FBRXpCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlEQUFPO0FBQ1g7O0FBRUEsTUFBTSxpREFBTztBQUNiO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlEQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxrQkFBa0IsZ0RBQU07QUFDeEI7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsSUFBSSxpREFBTztBQUNYO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQSxJQUFJLGlEQUFPOztBQUVYLE1BQU0saURBQU87O0FBRWI7QUFDQSxRQUFRLGlEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxRQUFRLGlEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksd0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxNQUFNLGlEQUFPO0FBQ2Isb0JBQW9CLHdFQUFzQjtBQUMxQztBQUNBLE9BQU87QUFDUDs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksaURBQU87QUFDWCxrQkFBa0Isd0VBQXNCOztBQUV4Qzs7QUFFQSxNQUFNLGlEQUFPO0FBQ2I7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQSxJQUFJLHdEQUFTO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSwrQ0FBUSxnQkFBZ0IsZ0VBQWtCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTLGlEQUFPLENBQUMsNkNBQUc7QUFDcEI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUEsU0FBUyxpREFBTztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBOztBQUVBLFlBQVksaURBQU87O0FBRW5CLFNBQVMsZ0RBQU07QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzVW1DOztBQUVTOztBQUU1QyxpRUFBZTtBQUNmO0FBQ0EsSUFBSSwyQ0FBVztBQUNmO0FBQ0E7QUFDQSwyQkFBMkIsbURBQWE7QUFDeEMsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWZ0M7O0FBSVI7OztBQUcxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7O0FBRWY7O0FBRUEsZUFBZSxnREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7O0FBRXBDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsZUFBZSxnREFBTSxHQUFHO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0RBQU87O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvSXlDOztBQUVIOzs7QUFHdEMsaUVBQWU7QUFDZjtBQUNBLElBQUksOENBQWM7QUFDbEI7QUFDQTtBQUNBLHdCQUF3QixnREFBVTtBQUNsQyxDQUFDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWGtFOztBQUVuRTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLDRFQUF3QjtBQUNuRSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1T2tCOztBQUU2Qjs7QUFFUzs7QUFFWjs7QUFFNUM7QUFDQTtBQUNBOztB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QUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0EsT0FBTyxrREFBTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVyxlQUFlO0FBQzFCO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTyxLQUFLO0FBQ3ZCLFdBQVcsT0FBTyxLQUFLO0FBQ3ZCLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0EsVUFBVTtBQUNW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QUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTyxJQUFJOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUErQyxjQUFjO1dBQzdELEU7Ozs7O1VDTkE7VUFDQTtVQUNBO1VBQ0EiLCJmaWxlIjoicG9zdGl0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUG9zdEl0TW9kZWxlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJQb3N0SXRNb2RlbGVyXCJdID0gZmFjdG9yeSgpO1xufSkoc2VsZiwgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IElkcyBmcm9tICdpZHMnO1xuXG5pbXBvcnQgQmFzZVZpZXdlciBmcm9tICcuL0Jhc2VWaWV3ZXInO1xuXG5cbi8qKlxuICogQSBiYXNlIG1vZGVsZXIgZm9yIHBvc3RpdC1qcyBib2FyZHMuXG4gKlxuICogSGF2ZSBhIGxvb2sgYXQge0BsaW5rIE1vZGVsZXJ9IGZvciBhIGJ1bmRsZSB0aGF0IGluY2x1ZGVzIGFjdHVhbCBmZWF0dXJlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byBwYXNzIHRvIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gW29wdGlvbnMuY29udGFpbmVyXSB0aGUgY29udGFpbmVyIHRvIHJlbmRlciB0aGUgdmlld2VyIGluLCBkZWZhdWx0cyB0byBib2R5LlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gdGhlIHdpZHRoIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSB0aGUgaGVpZ2h0IG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tb2RkbGVFeHRlbnNpb25zXSBleHRlbnNpb24gcGFja2FnZXMgdG8gcHJvdmlkZVxuICogQHBhcmFtIHtBcnJheTxkaWRpLk1vZHVsZT59IFtvcHRpb25zLm1vZHVsZXNdIGEgbGlzdCBvZiBtb2R1bGVzIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1vZHVsZXNcbiAqIEBwYXJhbSB7QXJyYXk8ZGlkaS5Nb2R1bGU+fSBbb3B0aW9ucy5hZGRpdGlvbmFsTW9kdWxlc10gYSBsaXN0IG9mIG1vZHVsZXMgdG8gdXNlIHdpdGggdGhlIGRlZmF1bHQgbW9kdWxlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCYXNlTW9kZWxlcihvcHRpb25zKSB7XG4gIEJhc2VWaWV3ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAvLyBob29rIElEIGNvbGxlY3Rpb24gaW50byB0aGUgbW9kZWxlclxuICB0aGlzLm9uKCdpbXBvcnQucGFyc2UuY29tcGxldGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghZXZlbnQuZXJyb3IpIHtcbiAgICAgIHRoaXMuX2NvbGxlY3RJZHMoZXZlbnQuZGVmaW5pdGlvbnMsIGV2ZW50LmNvbnRleHQpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5vbignZGlhZ3JhbS5kZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nZXQoJ21vZGRsZScpLmlkcy5jbGVhcigpO1xuICB9LCB0aGlzKTtcbn1cblxuaW5oZXJpdHMoQmFzZU1vZGVsZXIsIEJhc2VWaWV3ZXIpO1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbW9kZGxlIGluc3RhbmNlLCBhdHRhY2hpbmcgaWRzIHRvIGl0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbkJhc2VNb2RlbGVyLnByb3RvdHlwZS5fY3JlYXRlTW9kZGxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgbW9kZGxlID0gQmFzZVZpZXdlci5wcm90b3R5cGUuX2NyZWF0ZU1vZGRsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIC8vIGF0dGFjaCBpZHMgdG8gbW9kZGxlIHRvIGJlIGFibGUgdG8gdHJhY2tcbiAgLy8gYW5kIHZhbGlkYXRlZCBpZHMgaW4gdGhlIFhNTCBkb2N1bWVudFxuICAvLyB0cmVlXG4gIG1vZGRsZS5pZHMgPSBuZXcgSWRzKFsgMzIsIDM2LCAxIF0pO1xuXG4gIHJldHVybiBtb2RkbGU7XG59O1xuXG4vKipcbiAqIENvbGxlY3QgaWRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyc2luZyBvZiB0aGVcbiAqIGRlZmluaXRpb25zIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGRlZmluaXRpb25zXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHRcbiAqL1xuQmFzZU1vZGVsZXIucHJvdG90eXBlLl9jb2xsZWN0SWRzID0gZnVuY3Rpb24oZGVmaW5pdGlvbnMsIGNvbnRleHQpIHtcblxuICB2YXIgbW9kZGxlID0gZGVmaW5pdGlvbnMuJG1vZGVsLFxuICAgICAgaWRzID0gbW9kZGxlLmlkcyxcbiAgICAgIGlkO1xuXG4gIC8vIHJlbW92ZSByZWZlcmVuY2VzIGZyb20gcHJldmlvdXMgaW1wb3J0XG4gIGlkcy5jbGVhcigpO1xuXG4gIGZvciAoaWQgaW4gY29udGV4dC5lbGVtZW50c0J5SWQpIHtcbiAgICBpZHMuY2xhaW0oaWQsIGNvbnRleHQuZWxlbWVudHNCeUlkW2lkXSk7XG4gIH1cbn07XG4iLCIvKipcbiAqIFRoZSBjb2RlIGluIHRoZSA8cHJvamVjdC1sb2dvPjwvcHJvamVjdC1sb2dvPiBhcmVhXG4gKiBtdXN0IG5vdCBiZSBjaGFuZ2VkLlxuICpcbiAqIEBzZWUgaHR0cDovL2JwbW4uaW8vbGljZW5zZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmaW5kLFxuICBpc051bWJlcixcbiAgb21pdFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGRvbWlmeSxcbiAgcXVlcnkgYXMgZG9tUXVlcnksXG4gIHJlbW92ZSBhcyBkb21SZW1vdmVcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIGlubmVyU1ZHXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IERpYWdyYW0gZnJvbSAnZGlhZ3JhbS1qcyc7XG5pbXBvcnQgTW9kZGxlIGZyb20gJy4vbW9kZGxlJztcblxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IHtcbiAgaW1wb3J0UG9zdGl0RGlhZ3JhbVxufSBmcm9tICcuL2ltcG9ydC9JbXBvcnRlcic7XG5cblxuXG5cbi8qKlxuICogQSBiYXNlIHZpZXdlciBmb3IgUG9zdGl0IGJvYXJkcy5cbiAqXG4gKiBIYXZlIGEgbG9vayBhdCB7QGxpbmsgVmlld2VyfSwge0BsaW5rIE5hdmlnYXRlZFZpZXdlcn0gb3Ige0BsaW5rIE1vZGVsZXJ9IGZvclxuICogYnVuZGxlcyB0aGF0IGluY2x1ZGUgYWN0dWFsIGZlYXR1cmVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHZpZXdlclxuICogQHBhcmFtIHtET01FbGVtZW50fSBbb3B0aW9ucy5jb250YWluZXJdIHRoZSBjb250YWluZXIgdG8gcmVuZGVyIHRoZSB2aWV3ZXIgaW4sIGRlZmF1bHRzIHRvIGJvZHkuXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSB0aGUgd2lkdGggb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIHRoZSBoZWlnaHQgb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1vZGRsZUV4dGVuc2lvbnNdIGV4dGVuc2lvbiBwYWNrYWdlcyB0byBwcm92aWRlXG4gKiBAcGFyYW0ge0FycmF5PGRpZGkuTW9kdWxlPn0gW29wdGlvbnMubW9kdWxlc10gYSBsaXN0IG9mIG1vZHVsZXMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgbW9kdWxlc1xuICogQHBhcmFtIHtBcnJheTxkaWRpLk1vZHVsZT59IFtvcHRpb25zLmFkZGl0aW9uYWxNb2R1bGVzXSBhIGxpc3Qgb2YgbW9kdWxlcyB0byB1c2Ugd2l0aCB0aGUgZGVmYXVsdCBtb2R1bGVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJhc2VWaWV3ZXIob3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBhc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fbW9kZGxlID0gdGhpcy5fY3JlYXRlTW9kZGxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lcihvcHRpb25zKTtcblxuICB0aGlzLl9pbml0KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fbW9kZGxlLCBvcHRpb25zKTtcbn1cblxuaW5oZXJpdHMoQmFzZVZpZXdlciwgRGlhZ3JhbSk7XG5cbi8qKlxuKiBUaGUgaW1wb3J0WE1MIHJlc3VsdC5cbipcbiogQHR5cGVkZWYge09iamVjdH0gSW1wb3J0WE1MUmVzdWx0XG4qXG4qIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gd2FybmluZ3NcbiovXG5cbi8qKlxuKiBUaGUgaW1wb3J0WE1MIGVycm9yLlxuKlxuKiBAdHlwZWRlZiB7RXJyb3J9IEltcG9ydFhNTEVycm9yXG4qXG4qIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gd2FybmluZ3NcbiovXG5cblxuLyoqXG4gKiBQYXJzZSBhbmQgcmVuZGVyIGEgUG9zdGl0IGRpYWdyYW0uXG4gKlxuICogT25jZSBmaW5pc2hlZCB0aGUgdmlld2VyIHJlcG9ydHMgYmFjayB0aGUgcmVzdWx0IHRvIHRoZVxuICogcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCAoZXJyLCB3YXJuaW5ncykuXG4gKlxuICogIyMgTGlmZS1DeWNsZSBFdmVudHNcbiAqXG4gKiBEdXJpbmcgaW1wb3J0IHRoZSB2aWV3ZXIgd2lsbCBmaXJlIGxpZmUtY3ljbGUgZXZlbnRzOlxuICpcbiAqICAgKiBpbXBvcnQucGFyc2Uuc3RhcnQgKGFib3V0IHRvIHJlYWQgbW9kZWwgZnJvbSB4bWwpXG4gKiAgICogaW1wb3J0LnBhcnNlLmNvbXBsZXRlIChtb2RlbCByZWFkOyBtYXkgaGF2ZSB3b3JrZWQgb3Igbm90KVxuICogICAqIGltcG9ydC5yZW5kZXIuc3RhcnQgKGdyYXBoaWNhbCBpbXBvcnQgc3RhcnQpXG4gKiAgICogaW1wb3J0LnJlbmRlci5jb21wbGV0ZSAoZ3JhcGhpY2FsIGltcG9ydCBmaW5pc2hlZClcbiAqICAgKiBpbXBvcnQuZG9uZSAoZXZlcnl0aGluZyBkb25lKVxuICpcbiAqIFlvdSBjYW4gdXNlIHRoZXNlIGV2ZW50cyB0byBob29rIGludG8gdGhlIGxpZmUtY3ljbGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHhtbCB0aGUgUG9zdGl0IHhtbFxuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50PFBvc3RpdFJvb3RCb2FyZD58U3RyaW5nfSBbcm9vdEJvYXJkXSBQb3N0aXQgYm9hcmQgb3IgaWQgb2YgYm9hcmQgdG8gcmVuZGVyIChpZiBub3QgcHJvdmlkZWQsIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZW5kZXJlZClcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxJbXBvcnRYTUxSZXN1bHQsIEltcG9ydFhNTEVycm9yPn1cbiAqL1xuQmFzZVZpZXdlci5wcm90b3R5cGUuaW1wb3J0WE1MID0gZnVuY3Rpb24oeG1sLCByb290Qm9hcmQpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgLy8gaG9vayBpbiBwcmUtcGFyc2UgbGlzdGVuZXJzICtcbiAgICAvLyBhbGxvdyB4bWwgbWFuaXB1bGF0aW9uXG4gICAgeG1sID0gc2VsZi5fZW1pdCgnaW1wb3J0LnBhcnNlLnN0YXJ0JywgeyB4bWw6IHhtbCB9KSB8fCB4bWw7XG5cbiAgICBzZWxmLl9tb2RkbGUuZnJvbVhNTCh4bWwsICdwb3N0aXQ6RGVmaW5pdGlvbnMnKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuXG4gICAgICB2YXIgZGVmaW5pdGlvbnMgPSByZXN1bHQucm9vdEVsZW1lbnQ7XG4gICAgICB2YXIgcmVmZXJlbmNlcyA9IHJlc3VsdC5yZWZlcmVuY2VzO1xuICAgICAgdmFyIHBhcnNlV2FybmluZ3MgPSByZXN1bHQud2FybmluZ3M7XG4gICAgICB2YXIgZWxlbWVudHNCeUlkID0gcmVzdWx0LmVsZW1lbnRzQnlJZDtcblxuICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXMsXG4gICAgICAgIGVsZW1lbnRzQnlJZDogZWxlbWVudHNCeUlkLFxuICAgICAgICB3YXJuaW5nczogcGFyc2VXYXJuaW5nc1xuICAgICAgfTtcblxuICAgICAgLy8gaG9vayBpbiBwb3N0IHBhcnNlIGxpc3RlbmVycyArXG4gICAgICAvLyBhbGxvdyBkZWZpbml0aW9ucyBtYW5pcHVsYXRpb25cbiAgICAgIGRlZmluaXRpb25zID0gc2VsZi5fZW1pdCgnaW1wb3J0LnBhcnNlLmNvbXBsZXRlJywge1xuICAgICAgICBkZWZpbml0aW9uczogZGVmaW5pdGlvbnMsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH0pIHx8IGRlZmluaXRpb25zO1xuXG4gICAgICBzZWxmLmltcG9ydERlZmluaXRpb25zKGRlZmluaXRpb25zLCByb290Qm9hcmQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHZhciBhbGxXYXJuaW5ncyA9IFtdLmNvbmNhdChwYXJzZVdhcm5pbmdzLCByZXN1bHQud2FybmluZ3MgfHwgW10pO1xuXG4gICAgICAgIHNlbGYuX2VtaXQoJ2ltcG9ydC5kb25lJywgeyBlcnJvcjogbnVsbCwgd2FybmluZ3M6IGFsbFdhcm5pbmdzIH0pO1xuXG4gICAgICAgIHJldHVybiByZXNvbHZlKHsgd2FybmluZ3M6IGFsbFdhcm5pbmdzIH0pO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIHZhciBhbGxXYXJuaW5ncyA9IFtdLmNvbmNhdChwYXJzZVdhcm5pbmdzLCBlcnIud2FybmluZ3MgfHwgW10pO1xuXG4gICAgICAgIHNlbGYuX2VtaXQoJ2ltcG9ydC5kb25lJywgeyBlcnJvcjogZXJyLCB3YXJuaW5nczogYWxsV2FybmluZ3MgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlamVjdChhZGRXYXJuaW5nc1RvRXJyb3IoZXJyLCBhbGxXYXJuaW5ncykpO1xuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG5cbiAgICAgIHNlbGYuX2VtaXQoJ2ltcG9ydC5wYXJzZS5jb21wbGV0ZScsIHtcbiAgICAgICAgZXJyb3I6IGVyclxuICAgICAgfSk7XG5cbiAgICAgIGVyciA9IGNoZWNrVmFsaWRhdGlvbkVycm9yKGVycik7XG5cbiAgICAgIHNlbGYuX2VtaXQoJ2ltcG9ydC5kb25lJywgeyBlcnJvcjogZXJyLCB3YXJuaW5nczogZXJyLndhcm5pbmdzIH0pO1xuXG4gICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgfSk7XG5cbiAgfSk7XG59O1xuXG4vKipcbiogVGhlIGltcG9ydERlZmluaXRpb25zIHJlc3VsdC5cbipcbiogQHR5cGVkZWYge09iamVjdH0gSW1wb3J0RGVmaW5pdGlvbnNSZXN1bHRcbipcbiogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSB3YXJuaW5nc1xuKi9cblxuLyoqXG4qIFRoZSBpbXBvcnREZWZpbml0aW9ucyBlcnJvci5cbipcbiogQHR5cGVkZWYge0Vycm9yfSBJbXBvcnREZWZpbml0aW9uc0Vycm9yXG4qXG4qIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gd2FybmluZ3NcbiovXG5cbi8qKlxuICogSW1wb3J0IHBhcnNlZCBkZWZpbml0aW9ucyBhbmQgcmVuZGVyIGEgUG9zdGl0IGRpYWdyYW0uXG4gKlxuICogT25jZSBmaW5pc2hlZCB0aGUgdmlld2VyIHJlcG9ydHMgYmFjayB0aGUgcmVzdWx0IHRvIHRoZVxuICogcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCAoZXJyLCB3YXJuaW5ncykuXG4gKlxuICogIyMgTGlmZS1DeWNsZSBFdmVudHNcbiAqXG4gKiBEdXJpbmcgaW1wb3J0IHRoZSB2aWV3ZXIgd2lsbCBmaXJlIGxpZmUtY3ljbGUgZXZlbnRzOlxuICpcbiAqICAgKiBpbXBvcnQucmVuZGVyLnN0YXJ0IChncmFwaGljYWwgaW1wb3J0IHN0YXJ0KVxuICogICAqIGltcG9ydC5yZW5kZXIuY29tcGxldGUgKGdyYXBoaWNhbCBpbXBvcnQgZmluaXNoZWQpXG4gKlxuICogWW91IGNhbiB1c2UgdGhlc2UgZXZlbnRzIHRvIGhvb2sgaW50byB0aGUgbGlmZS1jeWNsZS5cbiAqXG4gKiBAcGFyYW0ge01vZGRsZUVsZW1lbnQ8RGVmaW5pdGlvbnM+fSBkZWZpbml0aW9ucyBwYXJzZWQgUG9zdGl0IGRlZmluaXRpb25zXG4gKiBAcGFyYW0ge01vZGRsZUVsZW1lbnQ8UG9zdGl0Um9vdEJvYXJkPnxTdHJpbmd9IFtyb290Qm9hcmRdIFBvc3RpdCBib2FyZCBvciBpZCBvZiBib2FyZCB0byByZW5kZXIgKGlmIG5vdCBwcm92aWRlZCwgdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJlbmRlcmVkKVxuICpcbiAqIHJldHVybnMge1Byb21pc2U8SW1wb3J0RGVmaW5pdGlvbnNSZXN1bHQsIEltcG9ydERlZmluaXRpb25zRXJyb3I+fVxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5pbXBvcnREZWZpbml0aW9ucyA9IGZ1bmN0aW9uKGRlZmluaXRpb25zLCByb290Qm9hcmQpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgc2VsZi5fc2V0RGVmaW5pdGlvbnMoZGVmaW5pdGlvbnMpO1xuXG4gICAgc2VsZi5vcGVuKHJvb3RCb2FyZCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcblxuICAgICAgdmFyIHdhcm5pbmdzID0gcmVzdWx0Lndhcm5pbmdzO1xuXG4gICAgICByZXR1cm4gcmVzb2x2ZSh7IHdhcm5pbmdzOiB3YXJuaW5ncyB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcblxuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogVGhlIG9wZW4gcmVzdWx0LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wZW5SZXN1bHRcbiAqXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IHdhcm5pbmdzXG4gKi9cblxuLyoqXG4qIFRoZSBvcGVuIGVycm9yLlxuKlxuKiBAdHlwZWRlZiB7RXJyb3J9IE9wZW5FcnJvclxuKlxuKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IHdhcm5pbmdzXG4qL1xuXG4vKipcbiAqIE9wZW4gYm9hcmQgb2YgcHJldmlvdXNseSBpbXBvcnRlZCBYTUwuXG4gKlxuICogT25jZSBmaW5pc2hlZCB0aGUgdmlld2VyIHJlcG9ydHMgYmFjayB0aGUgcmVzdWx0IHRvIHRoZVxuICogcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCAoZXJyLCB3YXJuaW5ncykuXG4gKlxuICogIyMgTGlmZS1DeWNsZSBFdmVudHNcbiAqXG4gKiBEdXJpbmcgc3dpdGNoIHRoZSB2aWV3ZXIgd2lsbCBmaXJlIGxpZmUtY3ljbGUgZXZlbnRzOlxuICpcbiAqICAgKiBpbXBvcnQucmVuZGVyLnN0YXJ0IChncmFwaGljYWwgaW1wb3J0IHN0YXJ0KVxuICogICAqIGltcG9ydC5yZW5kZXIuY29tcGxldGUgKGdyYXBoaWNhbCBpbXBvcnQgZmluaXNoZWQpXG4gKlxuICogWW91IGNhbiB1c2UgdGhlc2UgZXZlbnRzIHRvIGhvb2sgaW50byB0aGUgbGlmZS1jeWNsZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xNb2RkbGVFbGVtZW50PFBvc3RpdFJvb3RCb2FyZD59IFtyb290Qm9hcmRPcklkXSBpZCBvciB0aGUgZGlhZ3JhbSB0byBvcGVuXG4gKlxuICogcmV0dXJucyB7UHJvbWlzZTxPcGVuUmVzdWx0LCBPcGVuRXJyb3I+fVxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24ocm9vdEJvYXJkT3JJZCkge1xuXG4gIHZhciBkZWZpbml0aW9ucyA9IHRoaXMuX2RlZmluaXRpb25zO1xuICB2YXIgcm9vdEJvcmQgPSByb290Qm9hcmRPcklkO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKCFkZWZpbml0aW9ucykge1xuICAgICAgdmFyIGVycjEgPSBuZXcgRXJyb3IoJ25vIFhNTCBpbXBvcnRlZCcpO1xuXG4gICAgICByZXR1cm4gcmVqZWN0KGFkZFdhcm5pbmdzVG9FcnJvcihlcnIxLCBbXSkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygcm9vdEJvYXJkT3JJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvb3RCb3JkID0gZmluZFJvb3RCb2FyZChkZWZpbml0aW9ucywgcm9vdEJvYXJkT3JJZCk7XG5cbiAgICAgIGlmICghcm9vdEJvcmQpIHtcbiAgICAgICAgdmFyIGVycjIgPSBuZXcgRXJyb3IoJ1Bvc3RpdFJvb3RCb2FyZCA8JyArIHJvb3RCb2FyZE9ySWQgKyAnPiBub3QgZm91bmQnKTtcblxuICAgICAgICByZXR1cm4gcmVqZWN0KGFkZFdhcm5pbmdzVG9FcnJvcihlcnIyLCBbXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFyIGV4aXN0aW5nIHJlbmRlcmVkIGRpYWdyYW1cbiAgICAvLyBjYXRjaCBzeW5jaHJvbm91cyBleGNlcHRpb25zIGR1cmluZyAjY2xlYXIoKVxuICAgIHRyeSB7XG4gICAgICBzZWxmLmNsZWFyKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcblxuICAgICAgcmV0dXJuIHJlamVjdChhZGRXYXJuaW5nc1RvRXJyb3IoZXJyb3IsIFtdKSk7XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSBncmFwaGljYWwgaW1wb3J0XG4gICAgaW1wb3J0UG9zdGl0RGlhZ3JhbShzZWxmLCBkZWZpbml0aW9ucywgcm9vdEJvcmQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cbiAgICAgIHZhciB3YXJuaW5ncyA9IHJlc3VsdC53YXJuaW5ncztcblxuICAgICAgcmV0dXJuIHJlc29sdmUoeyB3YXJuaW5nczogd2FybmluZ3MgfSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG5cbiAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRoZSBzYXZlWE1MIHJlc3VsdC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTYXZlWE1MUmVzdWx0XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHhtbFxuICovXG5cbi8qKlxuICogRXhwb3J0IHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIFBvc3RpdCBkaWFncmFtIGFzXG4gKiBhIFBvc3RpdCBYTUwgZG9jdW1lbnQuXG4gKlxuICogIyMgTGlmZS1DeWNsZSBFdmVudHNcbiAqXG4gKiBEdXJpbmcgWE1MIHNhdmluZyB0aGUgdmlld2VyIHdpbGwgZmlyZSBsaWZlLWN5Y2xlIGV2ZW50czpcbiAqXG4gKiAgICogc2F2ZVhNTC5zdGFydCAoYmVmb3JlIHNlcmlhbGl6YXRpb24pXG4gKiAgICogc2F2ZVhNTC5zZXJpYWxpemVkIChhZnRlciB4bWwgZ2VuZXJhdGlvbilcbiAqICAgKiBzYXZlWE1MLmRvbmUgKGV2ZXJ5dGhpbmcgZG9uZSlcbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGVzZSBldmVudHMgdG8gaG9vayBpbnRvIHRoZSBsaWZlLWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gZXhwb3J0IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9ybWF0PWZhbHNlXSBvdXRwdXQgZm9ybWF0dGVkIFhNTFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5wcmVhbWJsZT10cnVlXSBvdXRwdXQgcHJlYW1ibGVcbiAqXG4gKiByZXR1cm5zIHtQcm9taXNlPFNhdmVYTUxSZXN1bHQsIEVycm9yPn1cbiAqL1xuQmFzZVZpZXdlci5wcm90b3R5cGUuc2F2ZVhNTCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGRlZmluaXRpb25zID0gdGhpcy5fZGVmaW5pdGlvbnM7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgaWYgKCFkZWZpbml0aW9ucykge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignbm8gZGVmaW5pdGlvbnMgbG9hZGVkJyk7XG5cbiAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyB0byBmaWRkbGUgYXJvdW5kIHdpdGggZGVmaW5pdGlvbnNcbiAgICBkZWZpbml0aW9ucyA9IHNlbGYuX2VtaXQoJ3NhdmVYTUwuc3RhcnQnLCB7XG4gICAgICBkZWZpbml0aW9uczogZGVmaW5pdGlvbnNcbiAgICB9KSB8fCBkZWZpbml0aW9ucztcblxuICAgIHNlbGYuX21vZGRsZS50b1hNTChkZWZpbml0aW9ucywgb3B0aW9ucykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcblxuICAgICAgdmFyIHhtbCA9IHJlc3VsdC54bWw7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHhtbCA9IHNlbGYuX2VtaXQoJ3NhdmVYTUwuc2VyaWFsaXplZCcsIHtcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB4bWw6IHhtbFxuICAgICAgICB9KSB8fCB4bWw7XG5cbiAgICAgICAgc2VsZi5fZW1pdCgnc2F2ZVhNTC5kb25lJywge1xuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIHhtbDogeG1sXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdlcnJvciBpbiBzYXZlWE1MIGxpZmUtY3ljbGUgbGlzdGVuZXInLCBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc29sdmUoeyB4bWw6IHhtbCB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcblxuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogVGhlIHNhdmVTVkcgcmVzdWx0LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNhdmVTVkdSZXN1bHRcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3ZnXG4gKi9cblxuLyoqXG4gKiBFeHBvcnQgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgUG9zdGl0IGRpYWdyYW0gYXNcbiAqIGFuIFNWRyBpbWFnZS5cbiAqXG4gKiAjIyBMaWZlLUN5Y2xlIEV2ZW50c1xuICpcbiAqIER1cmluZyBTVkcgc2F2aW5nIHRoZSB2aWV3ZXIgd2lsbCBmaXJlIGxpZmUtY3ljbGUgZXZlbnRzOlxuICpcbiAqICAgKiBzYXZlU1ZHLnN0YXJ0IChiZWZvcmUgc2VyaWFsaXphdGlvbilcbiAqICAgKiBzYXZlU1ZHLmRvbmUgKGV2ZXJ5dGhpbmcgZG9uZSlcbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGVzZSBldmVudHMgdG8gaG9vayBpbnRvIHRoZSBsaWZlLWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqXG4gKiByZXR1cm5zIHtQcm9taXNlPFNhdmVTVkdSZXN1bHQsIEVycm9yPn1cbiAqL1xuQmFzZVZpZXdlci5wcm90b3R5cGUuc2F2ZVNWRyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgc2VsZi5fZW1pdCgnc2F2ZVNWRy5zdGFydCcpO1xuXG4gICAgdmFyIHN2ZywgZXJyO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBjYW52YXMgPSBzZWxmLmdldCgnY2FudmFzJyk7XG5cbiAgICAgIHZhciBjb250ZW50Tm9kZSA9IGNhbnZhcy5nZXREZWZhdWx0TGF5ZXIoKSxcbiAgICAgICAgICBkZWZzTm9kZSA9IGRvbVF1ZXJ5KCdkZWZzJywgY2FudmFzLl9zdmcpO1xuXG4gICAgICB2YXIgY29udGVudHMgPSBpbm5lclNWRyhjb250ZW50Tm9kZSksXG4gICAgICAgICAgZGVmcyA9IGRlZnNOb2RlID8gJzxkZWZzPicgKyBpbm5lclNWRyhkZWZzTm9kZSkgKyAnPC9kZWZzPicgOiAnJztcblxuICAgICAgdmFyIGJib3ggPSBjb250ZW50Tm9kZS5nZXRCQm94KCk7XG5cbiAgICAgIHN2ZyA9XG4gICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJ1dGYtOFwiPz5cXG4nICtcbiAgICAgICAgJzwhLS0gY3JlYXRlZCB3aXRoIGRpYWdyYW0tanMgLyBodHRwOi8vYnBtbi5pbyAtLT5cXG4nICtcbiAgICAgICAgJzwhRE9DVFlQRSBzdmcgUFVCTElDIFwiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU5cIiBcImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZFwiPlxcbicgK1xuICAgICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgJyArXG4gICAgICAgICAgICAgJ3dpZHRoPVwiJyArIGJib3gud2lkdGggKyAnXCIgaGVpZ2h0PVwiJyArIGJib3guaGVpZ2h0ICsgJ1wiICcgK1xuICAgICAgICAgICAgICd2aWV3Qm94PVwiJyArIGJib3gueCArICcgJyArIGJib3gueSArICcgJyArIGJib3gud2lkdGggKyAnICcgKyBiYm94LmhlaWdodCArICdcIiB2ZXJzaW9uPVwiMS4xXCI+JyArXG4gICAgICAgICAgZGVmcyArIGNvbnRlbnRzICtcbiAgICAgICAgJzwvc3ZnPic7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG5cbiAgICBzZWxmLl9lbWl0KCdzYXZlU1ZHLmRvbmUnLCB7XG4gICAgICBlcnJvcjogZXJyLFxuICAgICAgc3ZnOiBzdmdcbiAgICB9KTtcblxuICAgIGlmICghZXJyKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSh7IHN2Zzogc3ZnIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCBhIG5hbWVkIGRpYWdyYW0gc2VydmljZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBlbGVtZW50UmVnaXN0cnkgPSB2aWV3ZXIuZ2V0KCdlbGVtZW50UmVnaXN0cnknKTtcbiAqIHZhciBzdGFydEV2ZW50U2hhcGUgPSBlbGVtZW50UmVnaXN0cnkuZ2V0KCdTdGFydEV2ZW50XzEnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGlhZ3JhbSBzZXJ2aWNlIGluc3RhbmNlXG4gKlxuICogQG1ldGhvZCBCYXNlVmlld2VyI2dldFxuICovXG5cbi8qKlxuICogSW52b2tlIGEgZnVuY3Rpb24gaW4gdGhlIGNvbnRleHQgb2YgdGhpcyB2aWV3ZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2aWV3ZXIuaW52b2tlKGZ1bmN0aW9uKGVsZW1lbnRSZWdpc3RyeSkge1xuICogICB2YXIgc3RhcnRFdmVudFNoYXBlID0gZWxlbWVudFJlZ2lzdHJ5LmdldCgnU3RhcnRFdmVudF8xJyk7XG4gKiB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0byBiZSBpbnZva2VkXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgZnVuY3Rpb25zIHJldHVybiB2YWx1ZVxuICpcbiAqIEBtZXRob2QgQmFzZVZpZXdlciNpbnZva2VcbiAqL1xuXG5cbkJhc2VWaWV3ZXIucHJvdG90eXBlLl9zZXREZWZpbml0aW9ucyA9IGZ1bmN0aW9uKGRlZmluaXRpb25zKSB7XG4gIHRoaXMuX2RlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5nZXRNb2R1bGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9tb2R1bGVzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGRyYXduIGVsZW1lbnRzIGZyb20gdGhlIHZpZXdlci5cbiAqXG4gKiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIHRoZSB2aWV3ZXIgY2FuIHN0aWxsXG4gKiBiZSByZXVzZWQgZm9yIG9wZW5pbmcgYW5vdGhlciBkaWFncmFtLlxuICpcbiAqIEBtZXRob2QgQmFzZVZpZXdlciNjbGVhclxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZ2V0RGVmaW5pdGlvbnMoKSkge1xuXG4gICAgLy8gbm8gZGlhZ3JhbSB0byBjbGVhclxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHJlbW92ZSBidXNpbmVzc09iamVjdCNkaSBiaW5kaW5nXG4gIC8vXG4gIC8vIHRoaXMgaXMgbmVjZXNzYXJ5LCBhcyB3ZSBlc3RhYmxpc2ggdGhlIGJpbmRpbmdzXG4gIC8vIGluIHRoZSBQb3N0aXRUcmVlV2Fsa2VyIChhbmQgYXNzdW1lIG5vbmUgYXJlIGdpdmVuXG4gIC8vIG9uIHJlaW1wb3J0KVxuICB0aGlzLmdldCgnZWxlbWVudFJlZ2lzdHJ5JykuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGJvID0gZWxlbWVudC5idXNpbmVzc09iamVjdDtcblxuICAgIGlmIChibyAmJiBiby5kaSkge1xuICAgICAgZGVsZXRlIGJvLmRpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIGRyYXduIGVsZW1lbnRzXG4gIERpYWdyYW0ucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIHZpZXdlciBpbnN0YW5jZSBhbmQgcmVtb3ZlIGFsbCBpdHNcbiAqIHJlbWFpbmRlcnMgZnJvbSB0aGUgZG9jdW1lbnQgdHJlZS5cbiAqL1xuQmFzZVZpZXdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIGRpYWdyYW0gZGVzdHJveVxuICBEaWFncmFtLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgLy8gZG9tIGRldGFjaFxuICBkb21SZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBSZW1vdmUgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIHZpYSB7QGxpbmsgI29mZihldmVudCwgY2FsbGJhY2spfS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFt0aGF0XVxuICovXG5CYXNlVmlld2VyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBwcmlvcml0eSwgY2FsbGJhY2ssIHRhcmdldCkge1xuICByZXR1cm4gdGhpcy5nZXQoJ2V2ZW50QnVzJykub24oZXZlbnQsIHByaW9yaXR5LCBjYWxsYmFjaywgdGFyZ2V0KTtcbn07XG5cbi8qKlxuICogRGUtcmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkJhc2VWaWV3ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuICB0aGlzLmdldCgnZXZlbnRCdXMnKS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbn07XG5cbkJhc2VWaWV3ZXIucHJvdG90eXBlLmF0dGFjaFRvID0gZnVuY3Rpb24ocGFyZW50Tm9kZSkge1xuXG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFyZW50Tm9kZSByZXF1aXJlZCcpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHdlIGRldGFjaCBmcm9tIHRoZVxuICAvLyBwcmV2aW91cywgb2xkIHBhcmVudFxuICB0aGlzLmRldGFjaCgpO1xuXG4gIC8vIHVud3JhcCBqUXVlcnkgaWYgcHJvdmlkZWRcbiAgaWYgKHBhcmVudE5vZGUuZ2V0ICYmIHBhcmVudE5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLmpxdWVyeSkge1xuICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLmdldCgwKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyZW50Tm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXJlbnROb2RlID0gZG9tUXVlcnkocGFyZW50Tm9kZSk7XG4gIH1cblxuICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgdGhpcy5fZW1pdCgnYXR0YWNoJywge30pO1xuXG4gIHRoaXMuZ2V0KCdjYW52YXMnKS5yZXNpemVkKCk7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5nZXREZWZpbml0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbnM7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbigpIHtcblxuICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuICAgICAgcGFyZW50Tm9kZSA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuXG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2VtaXQoJ2RldGFjaCcsIHt9KTtcblxuICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgbW9kZGxlLCBvcHRpb25zKSB7XG5cbiAgdmFyIGJhc2VNb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzIHx8IHRoaXMuZ2V0TW9kdWxlcygpLFxuICAgICAgYWRkaXRpb25hbE1vZHVsZXMgPSBvcHRpb25zLmFkZGl0aW9uYWxNb2R1bGVzIHx8IFtdLFxuICAgICAgc3RhdGljTW9kdWxlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHBvc3RpdGpzOiBbICd2YWx1ZScsIHRoaXMgXSxcbiAgICAgICAgICBtb2RkbGU6IFsgJ3ZhbHVlJywgbW9kZGxlIF1cbiAgICAgICAgfVxuICAgICAgXTtcblxuICB2YXIgZGlhZ3JhbU1vZHVsZXMgPSBbXS5jb25jYXQoc3RhdGljTW9kdWxlcywgYmFzZU1vZHVsZXMsIGFkZGl0aW9uYWxNb2R1bGVzKTtcblxuICB2YXIgZGlhZ3JhbU9wdGlvbnMgPSBhc3NpZ24ob21pdChvcHRpb25zLCBbICdhZGRpdGlvbmFsTW9kdWxlcycgXSksIHtcbiAgICBjYW52YXM6IGFzc2lnbih7fSwgb3B0aW9ucy5jYW52YXMsIHsgY29udGFpbmVyOiBjb250YWluZXIgfSksXG4gICAgbW9kdWxlczogZGlhZ3JhbU1vZHVsZXNcbiAgfSk7XG5cbiAgLy8gaW52b2tlIGRpYWdyYW0gY29uc3RydWN0b3JcbiAgRGlhZ3JhbS5jYWxsKHRoaXMsIGRpYWdyYW1PcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5lcikge1xuICAgIHRoaXMuYXR0YWNoVG8ob3B0aW9ucy5jb250YWluZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIEVtaXQgYW4gZXZlbnQgb24gdGhlIHVuZGVybHlpbmcge0BsaW5rIEV2ZW50QnVzfVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICogQHBhcmFtICB7T2JqZWN0fSBldmVudFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZXZlbnQgcHJvY2Vzc2luZyByZXN1bHQgKGlmIGFueSlcbiAqL1xuQmFzZVZpZXdlci5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuICByZXR1cm4gdGhpcy5nZXQoJ2V2ZW50QnVzJykuZmlyZSh0eXBlLCBldmVudCk7XG59O1xuXG5CYXNlVmlld2VyLnByb3RvdHlwZS5fY3JlYXRlQ29udGFpbmVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gIHZhciBjb250YWluZXIgPSBkb21pZnkoJzxkaXYgY2xhc3M9XCJwanMtY29udGFpbmVyXCI+PC9kaXY+Jyk7XG5cbiAgYXNzaWduKGNvbnRhaW5lci5zdHlsZSwge1xuICAgIHdpZHRoOiBlbnN1cmVVbml0KG9wdGlvbnMud2lkdGgpLFxuICAgIGhlaWdodDogZW5zdXJlVW5pdChvcHRpb25zLmhlaWdodCksXG4gICAgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn07XG5cbkJhc2VWaWV3ZXIucHJvdG90eXBlLl9jcmVhdGVNb2RkbGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBtb2RkbGVPcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLl9tb2RkbGVFeHRlbnNpb25zLCBvcHRpb25zLm1vZGRsZUV4dGVuc2lvbnMpO1xuXG4gIHJldHVybiBuZXcgTW9kZGxlKG1vZGRsZU9wdGlvbnMpO1xufTtcblxuQmFzZVZpZXdlci5wcm90b3R5cGUuX21vZHVsZXMgPSBbXTtcblxuQmFzZVZpZXdlci5wcm90b3R5cGUuX21vZGRsZUV4dGVuc2lvbnMgPSB7fTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBhZGRXYXJuaW5nc1RvRXJyb3IoZXJyLCB3YXJuaW5nc0FyeSkge1xuICBlcnIud2FybmluZ3MgPSB3YXJuaW5nc0FyeTtcbiAgcmV0dXJuIGVycjtcbn1cblxuZnVuY3Rpb24gY2hlY2tWYWxpZGF0aW9uRXJyb3IoZXJyKSB7XG5cbiAgLy8gY2hlY2sgaWYgd2UgY2FuIGhlbHAgdGhlIHVzZXIgYnkgaW5kaWNhdGluZyB3cm9uZyBQb3N0aXQgeG1sXG4gIC8vIChpbiBjYXNlIGhlIG9yIHRoZSBleHBvcnRpbmcgdG9vbCBkaWQgbm90IGdldCB0aGF0IHJpZ2h0KVxuXG4gIHZhciBwYXR0ZXJuID0gL3VucGFyc2FibGUgY29udGVudCA8KFtePl0rKT4gZGV0ZWN0ZWQoW1xcc1xcU10qKSQvO1xuICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoZXJyLm1lc3NhZ2UpO1xuXG4gIGlmIChtYXRjaCkge1xuICAgIGVyci5tZXNzYWdlID1cbiAgICAgICd1bnBhcnNhYmxlIGNvbnRlbnQgPCcgKyBtYXRjaFsxXSArICc+IGRldGVjdGVkOyAnICtcbiAgICAgICd0aGlzIG1heSBpbmRpY2F0ZSBhbiBpbnZhbGlkIFBvc3RpdCBib2FyZCBmaWxlJyArIG1hdGNoWzJdO1xuICB9XG5cbiAgcmV0dXJuIGVycjtcbn1cblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgd2lkdGg6ICcxMDAlJyxcbiAgaGVpZ2h0OiAnMTAwJScsXG4gIHBvc2l0aW9uOiAncmVsYXRpdmUnXG59O1xuXG5cbi8qKlxuICogRW5zdXJlIHRoZSBwYXNzZWQgYXJndW1lbnQgaXMgYSBwcm9wZXIgdW5pdCAoZGVmYXVsdGluZyB0byBweClcbiAqL1xuZnVuY3Rpb24gZW5zdXJlVW5pdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCArIChpc051bWJlcih2YWwpID8gJ3B4JyA6ICcnKTtcbn1cblxuXG4vKipcbiAqIEZpbmQgUm9vdEJvYXJkIGluIGRlZmluaXRpb25zIGJ5IElEXG4gKlxuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50PERlZmluaXRpb25zPn0gZGVmaW5pdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBib2FyZElkXG4gKlxuICogQHJldHVybiB7TW9kZGxlRWxlbWVudDxQb3N0aXRSb290Qm9hcmQ+fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGZpbmRSb290Qm9hcmQoZGVmaW5pdGlvbnMsIGJvYXJkSWQpIHtcbiAgaWYgKCFib2FyZElkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZmluZChkZWZpbml0aW9ucy5yb290Qm9hcmRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuaWQgPT09IGJvYXJkSWQ7XG4gIH0pIHx8IG51bGw7XG59XG5cblxuaW1wb3J0IHtcbiAgZXZlbnQgYXMgZG9tRXZlbnRcbn0gZnJvbSAnbWluLWRvbSc7XG4iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgQmFzZU1vZGVsZXIgZnJvbSAnLi9CYXNlTW9kZWxlcic7XG5cbmltcG9ydCBWaWV3ZXIgZnJvbSAnLi9WaWV3ZXInO1xuaW1wb3J0IE5hdmlnYXRlZFZpZXdlciBmcm9tICcuL05hdmlnYXRlZFZpZXdlcic7XG5cbmltcG9ydCBLZXlib2FyZE1vdmVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi9rZXlib2FyZC1tb3ZlJztcbmltcG9ydCBNb3ZlQ2FudmFzTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL25hdmlnYXRpb24vbW92ZWNhbnZhcyc7XG5pbXBvcnQgVG91Y2hNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi90b3VjaCc7XG5pbXBvcnQgWm9vbVNjcm9sbE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL3pvb21zY3JvbGwnO1xuXG5pbXBvcnQgQWxpZ25FbGVtZW50c01vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9hbGlnbi1lbGVtZW50cyc7XG5pbXBvcnQgQXV0b1Njcm9sbE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9hdXRvLXNjcm9sbCc7XG5pbXBvcnQgQmVuZHBvaW50c01vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9iZW5kcG9pbnRzJztcbmltcG9ydCBDYW52YXNDcmVhdGUgZnJvbSAnLi9mZWF0dXJlcy9jYW52YXMtY3JlYXRlJztcbmltcG9ydCBDb25uZWN0TW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2Nvbm5lY3QnO1xuaW1wb3J0IENvbm5lY3Rpb25QcmV2aWV3TW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2Nvbm5lY3Rpb24tcHJldmlldyc7XG5pbXBvcnQgQ29udGV4dFBhZE1vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL2NvbnRleHQtcGFkJztcbmltcG9ydCBDb3B5UGFzdGVNb2R1bGUgZnJvbSAnLi9mZWF0dXJlcy9jb3B5LXBhc3RlJztcbmltcG9ydCBDcmVhdGVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY3JlYXRlJztcbmltcG9ydCBFZGl0b3JBY3Rpb25zTW9kdWxlIGZyb20gJy4vZmVhdHVyZXMvZWRpdG9yLWFjdGlvbnMnO1xuaW1wb3J0IEltYWdlU2VsZWN0aW9uTW9kdWxlIGZyb20gJy4vZmVhdHVyZXMvaW1hZ2Utc2VsZWN0aW9uJztcbmltcG9ydCBLZXlib2FyZE1vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL2tleWJvYXJkJztcbmltcG9ydCBLZXlib2FyZE1vdmVTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMva2V5Ym9hcmQtbW92ZS1zZWxlY3Rpb24nO1xuaW1wb3J0IExhYmVsRWRpdGluZ01vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL2xhYmVsLWVkaXRpbmcnO1xuaW1wb3J0IE1vZGVsaW5nTW9kdWxlIGZyb20gJy4vZmVhdHVyZXMvbW9kZWxpbmcnO1xuaW1wb3J0IE1vdmVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvbW92ZSc7XG5pbXBvcnQgUGFsZXR0ZU1vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL3BhbGV0dGUnO1xuaW1wb3J0IFJlcGxhY2VQcmV2aWV3TW9kdWxlIGZyb20gJy4vZmVhdHVyZXMvcmVwbGFjZS1wcmV2aWV3JztcbmltcG9ydCBSZXNpemVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcmVzaXplJztcbmltcG9ydCBTbmFwcGluZ01vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL3NuYXBwaW5nJztcblxuaW1wb3J0IERyYWdEcm9wSW1hZ2VzTW9kdWxlIGZyb20gJy4vZmVhdHVyZXMvZHJhZy1kcm9wLWltYWdlcyc7XG4vL2ltcG9ydCBTZWxlY3Rpb25Pcmdhbml6ZXJNb2R1bGUgZnJvbSAnLi9mZWF0dXJlcy9zZWxlY3Rpb24tb3JnYW5pemVyJztcbi8vaW1wb3J0IFByb3BlcnRpZXNQYW5lbE1vZHVsZSBmcm9tICcuL2ZlYXR1cmVzL3Byb3BlcnRpZXMtcGFuZWwtdjInO1xuLy9pbXBvcnQgSW1hZ2VTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnLi9mZWF0dXJlcy9pbWFnZS1zZWxlY3Rpb24tdjInO1xuLy8gQ1RPRE9cblxuXG52YXIgaW5pdGlhbERpYWdyYW0gPVxuICBgPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XG4gIDxwb3N0aXQ6ZGVmaW5pdGlvbnMgeG1sbnM6eHNpPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2VcIiB4bWxuczpkYz1cImh0dHA6Ly93d3cub21nLm9yZy9zcGVjL0RELzIwMTAwNTI0L0RDXCIgeG1sbnM6ZGk9XCJodHRwOi8vd3d3Lm9tZy5vcmcvc3BlYy9ERC8yMDEwMDUyNC9ESVwiIGlkPVwic2FtcGxlLWRpYWdyYW1cIj5cbiAgICA8cG9zdGl0OlBvc3RpdEJvYXJkIGlkPVwiQm9hcmRfMVwiPlxuICAgIDwvcG9zdGl0OlBvc3RpdEJvYXJkPlxuICAgIDxwb3N0aXREaTpQb3N0aXRSb290Qm9hcmQgaWQ9XCJSb290Qm9hcmRfMVwiPlxuICAgICAgPHBvc3RpdERpOlBvc3RpdFBsYW5lIGlkPVwiUG9zaXRQbGFuZV8xXCIgYm9hcmRFbGVtZW50PVwiQm9hcmRfMVwiPlxuICAgICAgPC9wb3N0aXREaTpQb3N0aXRQbGFuZT5cbiAgICA8L3Bvc3RpdERpOlBvc3RpdFJvb3RCb2FyZD5cbiAgPC9wb3N0aXQ6ZGVmaW5pdGlvbnM+YDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW9kZWxlcihvcHRpb25zKSB7XG4gIEJhc2VNb2RlbGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5pbmhlcml0cyhNb2RlbGVyLCBCYXNlTW9kZWxlcik7XG5cblxuTW9kZWxlci5WaWV3ZXIgPSBWaWV3ZXI7XG5Nb2RlbGVyLk5hdmlnYXRlZFZpZXdlciA9IE5hdmlnYXRlZFZpZXdlcjtcblxuLyoqXG4qIFRoZSBjcmVhdGVEaWFncmFtIHJlc3VsdC5cbipcbiogQHR5cGVkZWYge09iamVjdH0gQ3JlYXRlRGlhZ3JhbVJlc3VsdFxuKlxuKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IHdhcm5pbmdzXG4qL1xuXG4vKipcbiogVGhlIGNyZWF0ZURpYWdyYW0gZXJyb3IuXG4qXG4qIEB0eXBlZGVmIHtFcnJvcn0gQ3JlYXRlRGlhZ3JhbUVycm9yXG4qXG4qIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gd2FybmluZ3NcbiovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGRpYWdyYW0gdG8gc3RhcnQgbW9kZWxpbmcuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8Q3JlYXRlRGlhZ3JhbVJlc3VsdCwgQ3JlYXRlRGlhZ3JhbUVycm9yPn1cbiAqXG4gKi9cbk1vZGVsZXIucHJvdG90eXBlLmNyZWF0ZURpYWdyYW0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaW1wb3J0WE1MKGluaXRpYWxEaWFncmFtKTtcbn07XG5cblxuTW9kZWxlci5wcm90b3R5cGUuX2ludGVyYWN0aW9uTW9kdWxlcyA9IFtcblxuICAvLyBub24tbW9kZWxpbmcgY29tcG9uZW50c1xuICBLZXlib2FyZE1vdmVNb2R1bGUsXG4gIE1vdmVDYW52YXNNb2R1bGUsXG4gIFRvdWNoTW9kdWxlLFxuICBab29tU2Nyb2xsTW9kdWxlXG5dO1xuXG5Nb2RlbGVyLnByb3RvdHlwZS5fbW9kZWxpbmdNb2R1bGVzID0gW1xuXG4gIC8vIG1vZGVsaW5nIGNvbXBvbmVudHNcbiAgQWxpZ25FbGVtZW50c01vZHVsZSxcbiAgQXV0b1Njcm9sbE1vZHVsZSxcbiAgQmVuZHBvaW50c01vZHVsZSxcbiAgQ2FudmFzQ3JlYXRlLFxuICBDb25uZWN0TW9kdWxlLFxuICBDb25uZWN0aW9uUHJldmlld01vZHVsZSxcbiAgQ29udGV4dFBhZE1vZHVsZSxcbiAgQ29weVBhc3RlTW9kdWxlLFxuICBDcmVhdGVNb2R1bGUsXG4gIEVkaXRvckFjdGlvbnNNb2R1bGUsXG4gIEltYWdlU2VsZWN0aW9uTW9kdWxlLFxuICBLZXlib2FyZE1vZHVsZSxcbiAgS2V5Ym9hcmRNb3ZlU2VsZWN0aW9uTW9kdWxlLFxuICBMYWJlbEVkaXRpbmdNb2R1bGUsXG4gIE1vZGVsaW5nTW9kdWxlLFxuICBNb3ZlTW9kdWxlLFxuICBQYWxldHRlTW9kdWxlLFxuICBSZXBsYWNlUHJldmlld01vZHVsZSxcbiAgUmVzaXplTW9kdWxlLFxuICBTbmFwcGluZ01vZHVsZSxcblxuICBEcmFnRHJvcEltYWdlc01vZHVsZSxcbiAgLy9TZWxlY3Rpb25Pcmdhbml6ZXJNb2R1bGUsXG4gIC8vUHJvcGVydGllc1BhbmVsTW9kdWxlLFxuICAvL0ltYWdlU2VsZWN0aW9uTW9kdWxlLFxuICAvLyBDVE9ET1xuICBcbl07XG5cblxuLy8gbW9kdWxlcyB0aGUgbW9kZWxlciBpcyBjb21wb3NlZCBvZlxuLy9cbi8vIC0gdmlld2VyIG1vZHVsZXNcbi8vIC0gaW50ZXJhY3Rpb24gbW9kdWxlc1xuLy8gLSBtb2RlbGluZyBtb2R1bGVzXG5cbk1vZGVsZXIucHJvdG90eXBlLl9tb2R1bGVzID0gW10uY29uY2F0KFxuICBWaWV3ZXIucHJvdG90eXBlLl9tb2R1bGVzLFxuICBNb2RlbGVyLnByb3RvdHlwZS5faW50ZXJhY3Rpb25Nb2R1bGVzLFxuICBNb2RlbGVyLnByb3RvdHlwZS5fbW9kZWxpbmdNb2R1bGVzXG4pO1xuIiwiaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IFZpZXdlciBmcm9tICcuL1ZpZXdlcic7XG5cbmltcG9ydCBLZXlib2FyZE1vdmVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvbmF2aWdhdGlvbi9rZXlib2FyZC1tb3ZlJztcbmltcG9ydCBNb3ZlQ2FudmFzTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL25hdmlnYXRpb24vbW92ZWNhbnZhcyc7XG5pbXBvcnQgWm9vbVNjcm9sbE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9uYXZpZ2F0aW9uL3pvb21zY3JvbGwnO1xuXG5cbi8qKlxuICogQSB2aWV3ZXIgdGhhdCBpbmNsdWRlcyBtb3VzZSBuYXZpZ2F0aW9uIGZhY2lsaXRpZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBOYXZpZ2F0ZWRWaWV3ZXIob3B0aW9ucykge1xuICBWaWV3ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuaW5oZXJpdHMoTmF2aWdhdGVkVmlld2VyLCBWaWV3ZXIpO1xuXG5cbk5hdmlnYXRlZFZpZXdlci5wcm90b3R5cGUuX25hdmlnYXRpb25Nb2R1bGVzID0gW1xuICBLZXlib2FyZE1vdmVNb2R1bGUsXG4gIE1vdmVDYW52YXNNb2R1bGUsXG4gIFpvb21TY3JvbGxNb2R1bGVcbl07XG5cbk5hdmlnYXRlZFZpZXdlci5wcm90b3R5cGUuX21vZHVsZXMgPSBbXS5jb25jYXQoXG4gIFZpZXdlci5wcm90b3R5cGUuX21vZHVsZXMsXG4gIE5hdmlnYXRlZFZpZXdlci5wcm90b3R5cGUuX25hdmlnYXRpb25Nb2R1bGVzXG4pOyIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBDb3JlTW9kdWxlIGZyb20gJy4vY29yZSc7XG5pbXBvcnQgVHJhbnNsYXRlTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2kxOG4vdHJhbnNsYXRlJztcbmltcG9ydCBTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uJztcbmltcG9ydCBPdmVybGF5c01vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9vdmVybGF5cyc7XG5cbmltcG9ydCBCYXNlVmlld2VyIGZyb20gJy4vQmFzZVZpZXdlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZpZXdlcihvcHRpb25zKSB7XG4gIEJhc2VWaWV3ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuaW5oZXJpdHMoVmlld2VyLCBCYXNlVmlld2VyKTtcblxuLy8gbW9kdWxlcyB0aGUgdmlld2VyIGlzIGNvbXBvc2VkIG9mXG5WaWV3ZXIucHJvdG90eXBlLl9tb2R1bGVzID0gW1xuICBDb3JlTW9kdWxlLFxuICBUcmFuc2xhdGVNb2R1bGUsXG4gIFNlbGVjdGlvbk1vZHVsZSxcbiAgT3ZlcmxheXNNb2R1bGVcbl07XG5cbi8vIGRlZmF1bHQgbW9kZGxlIGV4dGVuc2lvbnMgdGhlIHZpZXdlciBpcyBjb21wb3NlZCBvZlxuVmlld2VyLnByb3RvdHlwZS5fbW9kZGxlRXh0ZW5zaW9ucyA9IHt9OyIsImltcG9ydCBEcmF3TW9kdWxlIGZyb20gJy4uL2RyYXcnO1xuaW1wb3J0IEltcG9ydE1vZHVsZSBmcm9tICcuLi9pbXBvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgRHJhd01vZHVsZSxcbiAgICBJbXBvcnRNb2R1bGVcbiAgXVxufTsiLCIvKipcbiAqIE1hcCBjb250YWluaW5nIFNWRyBwYXRocyBuZWVkZWQgYnkgUG9zdGl0UmVuZGVyZXIuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGF0aE1hcCgpIHtcblxuICAvKipcbiAgICogQ29udGFpbnMgYSBtYXAgb2YgcGF0aCBlbGVtZW50c1xuICAgKlxuICAgKiA8aDE+UGF0aCBkZWZpbml0aW9uPC9oMT5cbiAgICogQSBwYXJhbWV0ZXJpemVkIHBhdGggaXMgZGVmaW5lZCBsaWtlIHRoaXM6XG4gICAqIDxwcmU+XG4gICAqICdHQVRFV0FZX1BBUkFMTEVMJzoge1xuICAgKiAgIGQ6ICdtIHtteH0se215fSB7ZS54MH0sMCAwLHtlLngxfSB7ZS54MX0sMCAwLHtlLnkwfSAte2UueDF9LDAgMCx7ZS55MX0gJyArXG4gICAgICAgICAgJy17ZS54MH0sMCAwLC17ZS55MX0gLXtlLngxfSwwIDAsLXtlLnkwfSB7ZS54MX0sMCB6JyxcbiAgICogICBoZWlnaHQ6IDE3LjUsXG4gICAqICAgd2lkdGg6ICAxNy41LFxuICAgKiAgIGhlaWdodEVsZW1lbnRzOiBbMi41LCA3LjVdLFxuICAgKiAgIHdpZHRoRWxlbWVudHM6IFsyLjUsIDcuNV1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICogPHA+SXQncyBpbXBvcnRhbnQgdG8gc3BlY2lmeSBhIGNvcnJlY3QgPGI+aGVpZ2h0IGFuZCB3aWR0aDwvYj4gZm9yIHRoZSBwYXRoIGFzIHRoZSBzY2FsaW5nXG4gICAqIGlzIGJhc2VkIG9uIHRoZSByYXRpbyBiZXR3ZWVuIHRoZSBzcGVjaWZpZWQgaGVpZ2h0IGFuZCB3aWR0aCBpbiB0aGlzIG9iamVjdCBhbmQgdGhlXG4gICAqIGhlaWdodCBhbmQgd2lkdGggdGhhdCBpcyBzZXQgYXMgc2NhbGUgdGFyZ2V0IChOb3RlIHgseSBjb29yZGluYXRlcyB3aWxsIGJlIHNjYWxlZCB3aXRoXG4gICAqIGluZGl2aWR1YWwgcmF0aW9zKS48L3A+XG4gICAqIDxwPlRoZSAnPGI+aGVpZ2h0RWxlbWVudHM8L2I+JyBhbmQgJzxiPndpZHRoRWxlbWVudHM8L2I+JyBhcnJheSBtdXN0IGNvbnRhaW4gdGhlIHZhbHVlcyB0aGF0IHdpbGwgYmUgc2NhbGVkLlxuICAgKiBUaGUgc2NhbGluZyBpcyBiYXNlZCBvbiB0aGUgY29tcHV0ZWQgcmF0aW9zLlxuICAgKiBDb29yZGluYXRlcyBvbiB0aGUgeSBheGlzIHNob3VsZCBiZSBpbiB0aGUgPGI+aGVpZ2h0RWxlbWVudDwvYj4ncyBhcnJheSwgdGhleSB3aWxsIGJlIHNjYWxlZCB1c2luZ1xuICAgKiB0aGUgY29tcHV0ZWQgcmF0aW8gY29lZmZpY2llbnQuXG4gICAqIEluIHRoZSBwYXJhbWV0ZXJpemVkIHBhdGggdGhlIHNjYWxlZCB2YWx1ZXMgY2FuIGJlIGFjY2Vzc2VkIHRocm91Z2ggdGhlICdlJyBvYmplY3QgaW4ge30gYnJhY2tldHMuXG4gICAqICAgPHVsPlxuICAgKiAgICA8bGk+VGhlIHZhbHVlcyBmb3IgdGhlIHkgYXhpcyBjYW4gYmUgYWNjZXNzZWQgaW4gdGhlIHBhdGggc3RyaW5nIHVzaW5nIHtlLnkwfSwge2UueTF9LCAuLi4uPC9saT5cbiAgICogICAgPGxpPlRoZSB2YWx1ZXMgZm9yIHRoZSB4IGF4aXMgY2FuIGJlIGFjY2Vzc2VkIGluIHRoZSBwYXRoIHN0cmluZyB1c2luZyB7ZS54MH0sIHtlLngxfSwgLi4uLjwvbGk+XG4gICAqICAgPC91bD5cbiAgICogICBUaGUgbnVtYmVycyB4MCwgeDEgcmVzcGVjdGl2ZWx5IHkwLCB5MSwgLi4uIG1hcCB0byB0aGUgY29ycmVzcG9uZGluZyBhcnJheSBpbmRleC5cbiAgICogPC9wPlxuICAgKi9cbiAgdGhpcy5wYXRoTWFwID0ge1xuICAgICdFVkVOVF9NRVNTQUdFJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IGwgMCx7ZS55MX0gbCB7ZS54MX0sMCBsIDAsLXtlLnkxfSB6IGwge2UueDB9LHtlLnkwfSBsIHtlLngwfSwte2UueTB9JyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogIDM2LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs2LCAxNF0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMTAuNSwgMjFdXG4gICAgfSxcbiAgICAnRVZFTlRfU0lHTkFMJzoge1xuICAgICAgZDogJ00ge214fSx7bXl9IGwge2UueDB9LHtlLnkwfSBsIC17ZS54MX0sMCBaJyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzE4XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFsxMCwgMjBdXG4gICAgfSxcbiAgICAnRVZFTlRfRVNDQUxBVElPTic6IHtcbiAgICAgIGQ6ICdNIHtteH0se215fSBsIHtlLngwfSx7ZS55MH0gbCAte2UueDB9LC17ZS55MX0gbCAte2UueDB9LHtlLnkxfSBaJyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzIwLCA3XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFs4XVxuICAgIH0sXG4gICAgJ0VWRU5UX0NPTkRJVElPTkFMJzoge1xuICAgICAgZDogJ00ge2UueDB9LHtlLnkwfSBsIHtlLngxfSwwIGwgMCx7ZS55Mn0gbCAte2UueDF9LDAgWiAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55M30gbCB7ZS54MH0sMCAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55NH0gbCB7ZS54MH0sMCAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55NX0gbCB7ZS54MH0sMCAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55Nn0gbCB7ZS54MH0sMCAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55N30gbCB7ZS54MH0sMCAnICtcbiAgICAgICAgICdNIHtlLngyfSx7ZS55OH0gbCB7ZS54MH0sMCAnLFxuICAgICAgaGVpZ2h0OiAzNixcbiAgICAgIHdpZHRoOiAgMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzguNSwgMTQuNSwgMTgsIDExLjUsIDE0LjUsIDE3LjUsIDIwLjUsIDIzLjUsIDI2LjVdLFxuICAgICAgd2lkdGhFbGVtZW50czogIFsxMC41LCAxNC41LCAxMi41XVxuICAgIH0sXG4gICAgJ0VWRU5UX0xJTksnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gMCx7ZS55MH0gLXtlLngxfSwwIDAse2UueTF9IHtlLngxfSwwIDAse2UueTB9IHtlLngwfSwte2UueTJ9IC17ZS54MH0sLXtlLnkyfSB6JyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzQuNDM3NSwgNi43NSwgNy44MTI1XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFs5Ljg0Mzc1LCAxMy41XVxuICAgIH0sXG4gICAgJ0VWRU5UX0VSUk9SJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IHtlLngwfSwte2UueTB9IHtlLngxfSwte2UueTF9IHtlLngyfSx7ZS55Mn0ge2UueDN9LC17ZS55M30gLXtlLng0fSx7ZS55NH0gLXtlLng1fSwte2UueTV9IHonLFxuICAgICAgaGVpZ2h0OiAzNixcbiAgICAgIHdpZHRoOiAzNixcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbMC4wMjMsIDguNzM3LCA4LjE1MSwgMTYuNTY0LCAxMC41OTEsIDguNzE0XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFswLjA4NSwgNi42NzIsIDYuOTcsIDQuMjczLCA1LjMzNywgNi42MzZdXG4gICAgfSxcbiAgICAnRVZFTlRfQ0FOQ0VMXzQ1Jzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IC17ZS54MX0sMCAwLHtlLngwfSB7ZS54MX0sMCAwLHtlLnkxfSB7ZS54MH0sMCAnICtcbiAgICAgICAgJzAsLXtlLnkxfSB7ZS54MX0sMCAwLC17ZS55MH0gLXtlLngxfSwwIDAsLXtlLnkxfSAte2UueDB9LDAgeicsXG4gICAgICBoZWlnaHQ6IDM2LFxuICAgICAgd2lkdGg6IDM2LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs0Ljc1LCA4LjVdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzQuNzUsIDguNV1cbiAgICB9LFxuICAgICdFVkVOVF9DT01QRU5TQVRJT04nOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0ge2UueDB9LC17ZS55MH0gMCx7ZS55MX0geiBtIHtlLngxfSwte2UueTJ9IHtlLngyfSwte2UueTN9IDAse2UueTF9IC17ZS54Mn0sLXtlLnkzfSB6JyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogMzYsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzYuNSwgMTMsIDAuNCwgNi4xXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFs5LCA5LjMsIDguN11cbiAgICB9LFxuICAgICdFVkVOVF9USU1FUl9XSCc6IHtcbiAgICAgIGQ6ICdNIHtteH0se215fSBsIHtlLngwfSwte2UueTB9IG0gLXtlLngwfSx7ZS55MH0gbCB7ZS54MX0se2UueTF9ICcsXG4gICAgICBoZWlnaHQ6IDM2LFxuICAgICAgd2lkdGg6ICAzNixcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbMTAsIDJdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzMsIDddXG4gICAgfSxcbiAgICAnRVZFTlRfVElNRVJfTElORSc6IHtcbiAgICAgIGQ6ICAnTSB7bXh9LHtteX0gJyArXG4gICAgICAgICAgJ20ge2UueDB9LHtlLnkwfSBsIC17ZS54MX0se2UueTF9ICcsXG4gICAgICBoZWlnaHQ6IDM2LFxuICAgICAgd2lkdGg6ICAzNixcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbMTAsIDNdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzAsIDBdXG4gICAgfSxcbiAgICAnRVZFTlRfTVVMVElQTEUnOiB7XG4gICAgICBkOidtIHtteH0se215fSB7ZS54MX0sLXtlLnkwfSB7ZS54MX0se2UueTB9IC17ZS54MH0se2UueTF9IC17ZS54Mn0sMCB6JyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogIDM2LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs2LjI4MDk5LCAxMi41NjE5OV0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMy4xNDA1LCA5LjQyMTQ5LCAxMi41NjE5OF1cbiAgICB9LFxuICAgICdFVkVOVF9QQVJBTExFTF9NVUxUSVBMRSc6IHtcbiAgICAgIGQ6J20ge214fSx7bXl9IHtlLngwfSwwIDAse2UueTF9IHtlLngxfSwwIDAse2UueTB9IC17ZS54MX0sMCAwLHtlLnkxfSAnICtcbiAgICAgICAgJy17ZS54MH0sMCAwLC17ZS55MX0gLXtlLngxfSwwIDAsLXtlLnkwfSB7ZS54MX0sMCB6JyxcbiAgICAgIGhlaWdodDogMzYsXG4gICAgICB3aWR0aDogIDM2LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFsyLjU2MjI4LCA3LjY4NjgzXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFsyLjU2MjI4LCA3LjY4NjgzXVxuICAgIH0sXG4gICAgJ0dBVEVXQVlfRVhDTFVTSVZFJzoge1xuICAgICAgZDonbSB7bXh9LHtteX0ge2UueDB9LHtlLnkwfSB7ZS54MX0se2UueTB9IHtlLngyfSwwIHtlLng0fSx7ZS55Mn0gJyArXG4gICAgICAgICAgICAgICAgICAgICd7ZS54NH0se2UueTF9IHtlLngyfSwwIHtlLngxfSx7ZS55M30ge2UueDB9LHtlLnkzfSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3tlLngzfSwwIHtlLng1fSx7ZS55MX0ge2UueDV9LHtlLnkyfSB7ZS54M30sMCB6JyxcbiAgICAgIGhlaWdodDogMTcuNSxcbiAgICAgIHdpZHRoOiAgMTcuNSxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbOC41LCA2LjUzMTIsIC02LjUzMTIsIC04LjVdLFxuICAgICAgd2lkdGhFbGVtZW50czogIFs2LjUsIC02LjUsIDMsIC0zLCA1LCAtNV1cbiAgICB9LFxuICAgICdHQVRFV0FZX1BBUkFMTEVMJzoge1xuICAgICAgZDonbSB7bXh9LHtteX0gMCx7ZS55MX0gLXtlLngxfSwwIDAse2UueTB9IHtlLngxfSwwIDAse2UueTF9IHtlLngwfSwwICcgK1xuICAgICAgICAnMCwte2UueTF9IHtlLngxfSwwIDAsLXtlLnkwfSAte2UueDF9LDAgMCwte2UueTF9IC17ZS54MH0sMCB6JyxcbiAgICAgIGhlaWdodDogMzAsXG4gICAgICB3aWR0aDogIDMwLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs1LCAxMi41XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFs1LCAxMi41XVxuICAgIH0sXG4gICAgJ0dBVEVXQVlfRVZFTlRfQkFTRUQnOiB7XG4gICAgICBkOidtIHtteH0se215fSB7ZS54MH0se2UueTB9IHtlLngwfSx7ZS55MX0ge2UueDF9LHtlLnkyfSB7ZS54Mn0sMCB6JyxcbiAgICAgIGhlaWdodDogMTEsXG4gICAgICB3aWR0aDogIDExLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFstNiwgNiwgMTIsIC0xMl0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbOSwgLTMsIC0xMl1cbiAgICB9LFxuICAgICdHQVRFV0FZX0NPTVBMRVgnOiB7XG4gICAgICBkOidtIHtteH0se215fSAwLHtlLnkwfSAte2UueDB9LC17ZS55MX0gLXtlLngxfSx7ZS55Mn0ge2UueDB9LHtlLnkxfSAte2UueDJ9LDAgMCx7ZS55M30gJyArXG4gICAgICAgICd7ZS54Mn0sMCAgLXtlLngwfSx7ZS55MX0gbCB7ZS54MX0se2UueTJ9IHtlLngwfSwte2UueTF9IDAse2UueTB9IHtlLngzfSwwIDAsLXtlLnkwfSB7ZS54MH0se2UueTF9ICcgK1xuICAgICAgICAne2UueDF9LC17ZS55Mn0gLXtlLngwfSwte2UueTF9IHtlLngyfSwwIDAsLXtlLnkzfSAte2UueDJ9LDAge2UueDB9LC17ZS55MX0gLXtlLngxfSwte2UueTJ9ICcgK1xuICAgICAgICAnLXtlLngwfSx7ZS55MX0gMCwte2UueTB9IC17ZS54M30sMCB6JyxcbiAgICAgIGhlaWdodDogMTcuMTI1LFxuICAgICAgd2lkdGg6ICAxNy4xMjUsXG4gICAgICBoZWlnaHRFbGVtZW50czogWzQuODc1LCAzLjQzNzUsIDIuMTI1LCAzXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFszLjQzNzUsIDIuMTI1LCA0Ljg3NSwgM11cbiAgICB9LFxuICAgICdEQVRBX09CSkVDVF9QQVRIJzoge1xuICAgICAgZDonbSAwLDAge2UueDF9LDAge2UueDB9LHtlLnkwfSAwLHtlLnkxfSAte2UueDJ9LDAgMCwte2UueTJ9IHtlLngxfSwwIDAse2UueTB9IHtlLngwfSwwJyxcbiAgICAgIGhlaWdodDogNjEsXG4gICAgICB3aWR0aDogIDUxLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFsxMCwgNTAsIDYwXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFsxMCwgNDAsIDUwLCA2MF1cbiAgICB9LFxuICAgICdEQVRBX09CSkVDVF9DT0xMRUNUSU9OX1BBVEgnOiB7XG4gICAgICBkOidtIHtteH0sIHtteX0gJyArXG4gICAgICAgICdtICAwIDE1ICBsIDAgLTE1ICcgK1xuICAgICAgICAnbSAgNCAxNSAgbCAwIC0xNSAnICtcbiAgICAgICAgJ20gIDQgMTUgIGwgMCAtMTUgJyxcbiAgICAgIGhlaWdodDogNjEsXG4gICAgICB3aWR0aDogIDUxLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFsxMl0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMSwgNiwgMTIsIDE1XVxuICAgIH0sXG4gICAgJ0RBVEFfQVJST1cnOiB7XG4gICAgICBkOidtIDUsOSA5LDAgMCwtMyA1LDUgLTUsNSAwLC0zIC05LDAgeicsXG4gICAgICBoZWlnaHQ6IDYxLFxuICAgICAgd2lkdGg6ICA1MSxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFtdXG4gICAgfSxcbiAgICAnREFUQV9TVE9SRSc6IHtcbiAgICAgIGQ6J20gIHtteH0se215fSAnICtcbiAgICAgICAgJ2wgIDAse2UueTJ9ICcgK1xuICAgICAgICAnYyAge2UueDB9LHtlLnkxfSB7ZS54MX0se2UueTF9ICB7ZS54Mn0sMCAnICtcbiAgICAgICAgJ2wgIDAsLXtlLnkyfSAnICtcbiAgICAgICAgJ2MgLXtlLngwfSwte2UueTF9IC17ZS54MX0sLXtlLnkxfSAte2UueDJ9LDAnICtcbiAgICAgICAgJ2MgIHtlLngwfSx7ZS55MX0ge2UueDF9LHtlLnkxfSAge2UueDJ9LDAgJyArXG4gICAgICAgICdtICAte2UueDJ9LHtlLnkwfScgK1xuICAgICAgICAnYyAge2UueDB9LHtlLnkxfSB7ZS54MX0se2UueTF9IHtlLngyfSwwJyArXG4gICAgICAgICdtICAte2UueDJ9LHtlLnkwfScgK1xuICAgICAgICAnYyAge2UueDB9LHtlLnkxfSB7ZS54MX0se2UueTF9ICB7ZS54Mn0sMCcsXG4gICAgICBoZWlnaHQ6IDYxLFxuICAgICAgd2lkdGg6ICA2MSxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbNywgMTAsIDQ1XSxcbiAgICAgIHdpZHRoRWxlbWVudHM6ICBbMiwgNTgsIDYwXVxuICAgIH0sXG4gICAgJ1RFWFRfQU5OT1RBVElPTic6IHtcbiAgICAgIGQ6ICdtIHtteH0sIHtteX0gbSAxMCwwIGwgLTEwLDAgbCAwLHtlLnkwfSBsIDEwLDAnLFxuICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgIHdpZHRoOiAxMCxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbMzBdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzEwXVxuICAgIH0sXG4gICAgJ01BUktFUl9TVUJfUFJPQ0VTUyc6IHtcbiAgICAgIGQ6ICdte214fSx7bXl9IG0gNywyIGwgMCwxMCBtIC01LC01IGwgMTAsMCcsXG4gICAgICBoZWlnaHQ6IDEwLFxuICAgICAgd2lkdGg6IDEwLFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFtdLFxuICAgICAgd2lkdGhFbGVtZW50czogW11cbiAgICB9LFxuICAgICdNQVJLRVJfUEFSQUxMRUwnOiB7XG4gICAgICBkOiAnbXtteH0se215fSBtIDMsMiBsIDAsMTAgbSAzLC0xMCBsIDAsMTAgbSAzLC0xMCBsIDAsMTAnLFxuICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgIHdpZHRoOiAxMCxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFtdXG4gICAgfSxcbiAgICAnTUFSS0VSX1NFUVVFTlRJQUwnOiB7XG4gICAgICBkOiAnbXtteH0se215fSBtIDAsMyBsIDEwLDAgbSAtMTAsMyBsIDEwLDAgbSAtMTAsMyBsIDEwLDAnLFxuICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgIHdpZHRoOiAxMCxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFtdXG4gICAgfSxcbiAgICAnTUFSS0VSX0NPTVBFTlNBVElPTic6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSA3LC01IDAsMTAgeiBtIDcuMSwtMC4zIDYuOSwtNC43IDAsMTAgLTYuOSwtNC43IHonLFxuICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgIHdpZHRoOiAyMSxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcbiAgICAgIHdpZHRoRWxlbWVudHM6IFtdXG4gICAgfSxcbiAgICAnTUFSS0VSX0xPT1AnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gYyAzLjUyNjk3OSwwIDYuMzg2MTYxLC0yLjgyOTg1OCA2LjM4NjE2MSwtNi4zMjA2NjEgMCwtMy40OTA4MDYgLTIuODU5MTgyLC02LjMyMDY2MSAnICtcbiAgICAgICAgJy02LjM4NjE2MSwtNi4zMjA2NjEgLTMuNTI2OTc4LDAgLTYuMzg2MTYsMi44Mjk4NTUgLTYuMzg2MTYsNi4zMjA2NjEgMCwxLjc0NTQwMiAnICtcbiAgICAgICAgJzAuNzE0Nzk3LDMuMzI1NTY3IDEuODcwNDYzLDQuNDY5MzgxIDAuNTc3ODM0LDAuNTcxOTA4IDEuMjY1ODg1LDEuMDM0NzI4IDIuMDI5OTE2LDEuMzU0NTcgJyArXG4gICAgICAgICdsIC0wLjcxODE2MywtMy45MDk3OTMgbSAwLjcxODE2MywzLjkwOTc5MyAtMy44ODUyMTEsMC44MDI5MDInLFxuICAgICAgaGVpZ2h0OiAxMy45LFxuICAgICAgd2lkdGg6IDEzLjcsXG4gICAgICBoZWlnaHRFbGVtZW50czogW10sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbXVxuICAgIH0sXG4gICAgJ01BUktFUl9BREhPQyc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBtIDAuODQ0NjEsMi42NDQxMSBjIDEuMDU1MzMsLTEuMjM3ODA5OTYgMi42NDMzNywtMi4wNzg4MiA0LjI5NjUzLC0xLjk3OTk3OTk2IDIuMDUxNjMsMC4wODA1ICcgK1xuICAgICAgICAnMy44NTU3OSwxLjE1ODAzIDUuNzYwODIsMS43OTEwNyAxLjA2Mzg1LDAuMzQxMzk5OTYgMi4yNDQ1NCwwLjE0MzggMy4xODc1OSwtMC40Mzc2NyAwLjYxNzQzLC0wLjMzNjQyICcgK1xuICAgICAgICAnMS4yNzc1LC0wLjY0MDc4IDEuNzU0MiwtMS4xNzUxMSAwLDAuNTYwMjMgMCwxLjEyMDQ2IDAsMS42ODA3IC0wLjk4NzA2LDAuOTYyMzc5OTYgLTIuMjk3OTIsMS42MjM5Mzk5NiAnICtcbiAgICAgICAgJy0zLjY5MTgsMS42NjE4MTk5NiAtMS4yNDQ1OSwwLjA5MjcgLTIuNDY2NzEsLTAuMjQ5MSAtMy41OTUwNSwtMC43NDgxMiAtMS4zNTc4OSwtMC41NTk2NSAnICtcbiAgICAgICAgJy0yLjc1MTMzLC0xLjMzNDM2OTk2IC00LjI3MDI3LC0xLjE4MTIxOTk2IC0xLjM3NzQxLDAuMTQ2MDEgLTIuNDE4NDIsMS4xMzY4NTk5NiAtMy40NDI4OCwxLjk2NzgyOTk2IHonLFxuICAgICAgaGVpZ2h0OiA0LFxuICAgICAgd2lkdGg6IDE1LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFtdLFxuICAgICAgd2lkdGhFbGVtZW50czogW11cbiAgICB9LFxuICAgICdUQVNLX1RZUEVfU0VORCc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBsIDAse2UueTF9IGwge2UueDF9LDAgbCAwLC17ZS55MX0geiBsIHtlLngwfSx7ZS55MH0gbCB7ZS54MH0sLXtlLnkwfScsXG4gICAgICBoZWlnaHQ6IDE0LFxuICAgICAgd2lkdGg6ICAyMSxcbiAgICAgIGhlaWdodEVsZW1lbnRzOiBbNiwgMTRdLFxuICAgICAgd2lkdGhFbGVtZW50czogWzEwLjUsIDIxXVxuICAgIH0sXG4gICAgJ1RBU0tfVFlQRV9TQ1JJUFQnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gYyA5Ljk2NjU1MywtNi4yNzI3NiAtOC4wMDA5MjYsLTcuOTE5MzIgMi45Njg5NjgsLTE0LjkzOCBsIC04LjgwMjcyOCwwICcgK1xuICAgICAgICAnYyAtMTAuOTY5ODk0LDcuMDE4NjggNi45OTc1ODUsOC42NjUyNCAtMi45Njg5NjcsMTQuOTM4IHogJyArXG4gICAgICAgICdtIC03LC0xMiBsIDUsMCAnICtcbiAgICAgICAgJ20gLTQuNSwzIGwgNC41LDAgJyArXG4gICAgICAgICdtIC0zLDMgbCA1LDAnICtcbiAgICAgICAgJ20gLTQsMyBsIDUsMCcsXG4gICAgICBoZWlnaHQ6IDE1LFxuICAgICAgd2lkdGg6ICAxMi42LFxuICAgICAgaGVpZ2h0RWxlbWVudHM6IFs2LCAxNF0sXG4gICAgICB3aWR0aEVsZW1lbnRzOiBbMTAuNSwgMjFdXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX1VTRVJfMSc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBjIDAuOTA5LC0wLjg0NSAxLjU5NCwtMi4wNDkgMS41OTQsLTMuMzg1IDAsLTIuNTU0IC0xLjgwNSwtNC42MjE5OTk5OSAnICtcbiAgICAgICAgJy00LjM1NywtNC42MjE5OTk5OSAtMi41NTE5OTk5OCwwIC00LjI4Nzk5OTk4LDIuMDY3OTk5OTkgLTQuMjg3OTk5OTgsNC42MjE5OTk5OSAwLDEuMzQ4ICcgK1xuICAgICAgICAnMC45NzQsMi41NjIgMS44OTU5OTk5OCwzLjQwNSAtMC41Mjg5OTk5OCwwLjE4NyAtNS42NjksMi4wOTcgLTUuNzk0LDQuNzU2MDAwNSB2IDYuNzE4ICcgK1xuICAgICAgICAnaCAxNyB2IC02LjcxOCBjIDAsLTIuMjk4MDAwNSAtNS41Mjc5OTk2LC00LjU5NTAwMDUgLTYuMDUwOTk5NiwtNC43NzYwMDA1IHonICtcbiAgICAgICAgJ20gLTgsNiBsIDAsNS41IG0gMTEsMCBsIDAsLTUnXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX1VTRVJfMic6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBtIDIuMTYyLDEuMDA5IGMgMCwyLjQ0NzAwMDUgLTIuMTU4LDQuNDMxMDAwNSAtNC44MjEsNC40MzEwMDA1ICcgK1xuICAgICAgICAnLTIuNjY0OTk5OTgsMCAtNC44MjIsLTEuOTgxIC00LjgyMiwtNC40MzEwMDA1ICdcbiAgICB9LFxuICAgICdUQVNLX1RZUEVfVVNFUl8zJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IG0gLTYuOSwtMy44MCBjIDAsMCAyLjI1MDk5OTk4LC0yLjM1OCA0LjI3Mzk5OTk4LC0xLjE3NyAyLjAyNCwxLjE4MSA0LjIyMSwxLjUzNyAnICtcbiAgICAgICAgJzQuMTI0LDAuOTY1IC0wLjA5OCwtMC41NyAtMC4xMTcsLTMuNzkwOTk5OTkgLTQuMTkxLC00LjEzNTk5OTk5IC0zLjU3NDk5OTk4LDAuMDAxICcgK1xuICAgICAgICAnLTQuMjA3OTk5OTgsMy4zNjY5OTk5OSAtNC4yMDY5OTk5OCw0LjM0Nzk5OTk5IHonXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX01BTlVBTCc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBjIDAuMjM0LC0wLjAxIDUuNjA0LDAuMDA4IDguMDI5LDAuMDA0IDAuODA4LDAgMS4yNzEsLTAuMTcyIDEuNDE3LC0wLjc1MiAwLjIyNywtMC44OTggJyArXG4gICAgICAgICctMC4zMzQsLTEuMzE0IC0xLjMzOCwtMS4zMTYgLTIuNDY3LC0wLjAxIC03Ljg4NiwtMC4wMDQgLTguMTA4LC0wLjAwNCAtMC4wMTQsLTAuMDc5IDAuMDE2LC0wLjUzMyAwLC0wLjYxICcgK1xuICAgICAgICAnMC4xOTUsLTAuMDQyIDguNTA3LDAuMDA2IDkuNjE2LDAuMDAyIDAuODc3LC0wLjAwNyAxLjM1LC0wLjQzOCAxLjM1MywtMS4yMDggMC4wMDMsLTAuNzY4IC0wLjQ3OSwtMS4wOSAnICtcbiAgICAgICAgJy0xLjM1LC0xLjA5MSAtMi45NjgsLTAuMDAyIC05LjYxOSwtMC4wMTMgLTkuNjE5LC0wLjAxMyB2IC0wLjU5MSBjIDAsMCA1LjA1MiwtMC4wMTYgNy4yMjUsLTAuMDE2ICcgK1xuICAgICAgICAnMC44ODgsLTAuMDAyIDEuMzU0LC0wLjQxNiAxLjM1MSwtMS4xOTMgLTAuMDA2LC0wLjc2MSAtMC40OTIsLTEuMTk2IC0xLjM2MSwtMS4xOTYgLTMuNDczLC0wLjAwNSAnICtcbiAgICAgICAgJy0xMC44NiwtMC4wMDMgLTExLjA4Mjk5OTUsLTAuMDAzIC0wLjAyMiwtMC4wNDcgLTAuMDQ1LC0wLjA5NCAtMC4wNjksLTAuMTM5IDAuMzkzOTk5NSwtMC4zMTkgJyArXG4gICAgICAgICcyLjA0MDk5OTUsLTEuNjI2IDIuNDE0OTk5NSwtMi4wMTcgMC40NjksLTAuNDg3MDAwNSAwLjUxOSwtMS4xNjUwMDA1IDAuMTYyLC0xLjYwNDAwMDUgLTAuNDE0LC0wLjUxMSAnICtcbiAgICAgICAgJy0wLjk3MywtMC41IC0xLjQ4LC0wLjIzNiAtMS40NjA5OTk1LDAuNzY0IC02LjU5OTk5OTUsMy42NDMwMDA1IC03LjczMjk5OTUsNC4yNzEwMDA1IC0wLjksMC40OTkgJyArXG4gICAgICAgICctMS41MTYsMS4yNTMgLTEuODgyLDIuMTkgLTAuMzcwMDAwMDIsMC45NSAtMC4xNywyLjAxIC0wLjE2NiwyLjk3OSAwLjAwNCwwLjcxOCAtMC4yNzMwMDAwMiwxLjM0NSAnICtcbiAgICAgICAgJy0wLjA1NSwyLjA2MyAwLjYyOSwyLjA4NyAyLjQyNSwzLjMxMiA0Ljg1OSwzLjMxOCA0LjYxNzk5OTUsMC4wMTQgOS4yMzc5OTk1LC0wLjEzOSAxMy44NTY5OTk1LC0wLjE1OCAnICtcbiAgICAgICAgJzAuNzU1LC0wLjAwNCAxLjE3MSwtMC4zMDEgMS4xODIsLTEuMDMzIDAuMDEyLC0wLjc1NCAtMC40MjMsLTAuOTY5IC0xLjE4MywtMC45NzMgLTEuNzc4LC0wLjAxICcgK1xuICAgICAgICAnLTUuODI0LC0wLjAwNCAtNi4wNCwtMC4wMDQgMTBlLTQsLTAuMDg0IDAuMDAzLC0wLjU4NiAxMGUtNCwtMC42NyB6J1xuICAgIH0sXG4gICAgJ1RBU0tfVFlQRV9JTlNUQU5USUFUSU5HX1NFTkQnOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gbCAwLDguNCBsIDEyLjYsMCBsIDAsLTguNCB6IGwgNi4zLDMuNiBsIDYuMywtMy42J1xuICAgIH0sXG4gICAgJ1RBU0tfVFlQRV9TRVJWSUNFJzoge1xuICAgICAgZDogJ20ge214fSx7bXl9IHYgLTEuNzEzMzUgYyAwLjM1MjMyNiwtMC4wNzA1IDAuNzAzOTMyLC0wLjE3ODM4IDEuMDQ3NjI4LC0wLjMyMTMzICcgK1xuICAgICAgICAnMC4zNDQ0MTYsLTAuMTQ0NjUgMC42NjU4MjIsLTAuMzIxMzMgMC45NjYzNzcsLTAuNTIxNDUgbCAxLjE5NDMxLDEuMTgwMDUgMS41Njc0ODcsLTEuNTc2ODggJyArXG4gICAgICAgICctMS4xOTUwMjgsLTEuMTgwMTQgYyAwLjQwMzM3NiwtMC42MTM5NCAwLjY4MzA3OSwtMS4yOTkwOCAwLjgyNTQ0NywtMi4wMTgyNCBsIDEuNjIyMTMzLC0wLjAxICcgK1xuICAgICAgICAndiAtMi4yMTk2IGwgLTEuNjM2NTE0LDAuMDEgYyAtMC4wNzMzMywtMC4zNTE1MyAtMC4xNzgzMTksLTAuNzAwMjQgLTAuMzIzNTY0LC0xLjA0MzcyICcgK1xuICAgICAgICAnLTAuMTQ1MjQ0LC0wLjM0NDA2IC0wLjMyMTQwNywtMC42NjQ0IC0wLjUyMjczNSwtMC45NjIxNyBsIDEuMTMxMDM1LC0xLjEzNjMxIC0xLjU4MzMwNSwtMS41NjI5MyAnICtcbiAgICAgICAgJy0xLjEyOTU5OCwxLjEzNTg5IGMgLTAuNjE0MDUyLC0wLjQwMTA4IC0xLjMwMjg4MywtMC42ODA5MyAtMi4wMjI2MzMsLTAuODIyNDcgbCAwLjAwOTMsLTEuNjE4NTIgJyArXG4gICAgICAgICdoIC0yLjI0MTE3MyBsIDAuMDA0MiwxLjYzMTI0IGMgLTAuMzUzNzYzLDAuMDczNiAtMC43MDUzNjksMC4xNzk3NyAtMS4wNDk3ODUsMC4zMjM3MSAtMC4zNDQ0MTUsMC4xNDQzNyAnICtcbiAgICAgICAgJy0wLjY2NTEwMiwwLjMyMDkyIC0wLjk2MzUwMDYsMC41MjA0NiBsIC0xLjE2OTg2MjgsLTEuMTU4MjMgLTEuNTY2NzY5MSwxLjU3OTIgMS4xNjg0MjY1LDEuMTU2NjkgJyArXG4gICAgICAgICdjIC0wLjQwMjY1NzMsMC42MTI4MyAtMC42ODMwOCwxLjI5Nzk3IC0wLjgyNDcyODcsMi4wMTcxMyBsIC0xLjY1ODgwNDEsMC4wMDMgdiAyLjIyMTc0ICcgK1xuICAgICAgICAnbCAxLjY3MjQ2NDgsLTAuMDA2IGMgMC4wNzMzMjcsMC4zNTA3NyAwLjE3OTc1OTgsMC43MDI0MyAwLjMyNDI4NTEsMS4wNDQ3MiAwLjE0NTI0MjgsMC4zNDQ0OCAnICtcbiAgICAgICAgJzAuMzIxNDA2NCwwLjY2NDQgMC41MjI3MzM5LDAuOTYwNjYgbCAtMS4xOTkzNDMxLDEuMTk3MjMgMS41ODQwMjU2LDEuNTYwMTEgMS4xOTY0NjY4LC0xLjE5MzQ4ICcgK1xuICAgICAgICAnYyAwLjYxNDA1MTcsMC40MDM0NiAxLjMwMjg4MjcsMC42ODIzMiAyLjAyMzM1MTcsMC44MjMzMSBsIDcuMTllLTQsMS42OTg5MiBoIDIuMjI2ODQ4IHogJyArXG4gICAgICAgICdtIDAuMjIxNDYyLC0zLjk5NTcgYyAtMS43ODg5NDgsMC43NTAyIC0zLjg1NzYsLTAuMDkyOCAtNC42MDk3MDU1LC0xLjg3NDM4IC0wLjc1MjEwNjUsLTEuNzgzMjEgJyArXG4gICAgICAgICcwLjA5MDU5OCwtMy44NDYyNyAxLjg4MDI2NDUsLTQuNTk2MDQgMS43ODgyMywtMC43NDkzNiAzLjg1Njg4MSwwLjA5MjkgNC42MDg5ODcsMS44NzQzNyAnICtcbiAgICAgICAgJzAuNzUyMTA2LDEuNzgxNjUgLTAuMDkwNiwzLjg0NjEyIC0xLjg3OTU0Niw0LjU5NjA1IHonXG4gICAgfSxcbiAgICAnVEFTS19UWVBFX1NFUlZJQ0VfRklMTCc6IHtcbiAgICAgIGQ6ICdtIHtteH0se215fSBjIC0xLjc4ODk0OCwwLjc1MDIgLTMuODU3NiwtMC4wOTI4IC00LjYwOTcwNTUsLTEuODc0MzggLTAuNzUyMTA2NSwtMS43ODMyMSAnICtcbiAgICAgICAgJzAuMDkwNTk4LC0zLjg0NjI3IDEuODgwMjY0NSwtNC41OTYwNCAxLjc4ODIzLC0wLjc0OTM2IDMuODU2ODgxLDAuMDkyOSA0LjYwODk4NywxLjg3NDM3ICcgK1xuICAgICAgICAnMC43NTIxMDYsMS43ODE2NSAtMC4wOTA2LDMuODQ2MTIgLTEuODc5NTQ2LDQuNTk2MDUgeidcbiAgICB9LFxuICAgICdUQVNLX1RZUEVfQlVTSU5FU1NfUlVMRV9IRUFERVInOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gMCw0IDIwLDAgMCwtNCB6J1xuICAgIH0sXG4gICAgJ1RBU0tfVFlQRV9CVVNJTkVTU19SVUxFX01BSU4nOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gMCwxMiAyMCwwIDAsLTEyIHonICtcbiAgICAgICAgJ20gMCw4IGwgMjAsMCAnICtcbiAgICAgICAgJ20gLTEzLC00IGwgMCw4J1xuICAgIH0sXG4gICAgJ01FU1NBR0VfRkxPV19NQVJLRVInOiB7XG4gICAgICBkOiAnbSB7bXh9LHtteX0gbSAtMTAuNSAsLTcgbCAwLDE0IGwgMjEsMCBsIDAsLTE0IHogbCAxMC41LDYgbCAxMC41LC02J1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmdldFJhd1BhdGggPSBmdW5jdGlvbiBnZXRSYXdQYXRoKHBhdGhJZCkge1xuICAgIHJldHVybiB0aGlzLnBhdGhNYXBbcGF0aElkXS5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTY2FsZXMgdGhlIHBhdGggdG8gdGhlIGdpdmVuIGhlaWdodCBhbmQgd2lkdGguXG4gICAqIDxoMT5Vc2UgY2FzZTwvaDE+XG4gICAqIDxwPlVzZSBjYXNlIGlzIHRvIHNjYWxlIHRoZSBjb250ZW50IG9mIGVsZW1lbnRzIChldmVudCwgZ2F0ZXdheXMpIGJhc2VkXG4gICAqIG9uIHRoZSBlbGVtZW50IGJvdW5kaW5nIGJveCdzIHNpemUuXG4gICAqIDwvcD5cbiAgICogPGgxPldoeSBub3QgdHJhbnNmb3JtPC9oMT5cbiAgICogPHA+U2NhbGluZyBhIHBhdGggd2l0aCB0cmFuc2Zvcm0oKSB3aWxsIGFsc28gc2NhbGUgdGhlIHN0cm9rZSBhbmQgSUUgZG9lcyBub3Qgc3VwcG9ydFxuICAgKiB0aGUgb3B0aW9uICdub24tc2NhbGluZy1zdHJva2UnIHRvIHByZXZlbnQgdGhpcy5cbiAgICogQWxzbyB0aGVyZSBhcmUgdXNlIGNhc2VzIHdoZXJlIG9ubHkgc29tZSBwYXJ0cyBvZiBhIHBhdGggc2hvdWxkIGJlXG4gICAqIHNjYWxlZC48L3A+XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoSWQgVGhlIElEIG9mIHRoZSBwYXRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gPHA+XG4gICAqICAgRXhhbXBsZSBwYXJhbSBvYmplY3Qgc2NhbGVzIHRoZSBwYXRoIHRvIDYwJSBzaXplIG9mIHRoZSBjb250YWluZXIgKGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0KS5cbiAgICogICA8cHJlPlxuICAgKiAgIHtcbiAgICogICAgIHhTY2FsZUZhY3RvcjogMC42LFxuICAgKiAgICAgeVNjYWxlRmFjdG9yOjAuNixcbiAgICogICAgIGNvbnRhaW5lcldpZHRoOiBkYXRhLndpZHRoLFxuICAgKiAgICAgY29udGFpbmVySGVpZ2h0OiBkYXRhLmhlaWdodCxcbiAgICogICAgIHBvc2l0aW9uOiB7XG4gICAqICAgICAgIG14OiAwLjQ2LFxuICAgKiAgICAgICBteTogMC4yLFxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogICA8L3ByZT5cbiAgICogICA8dWw+XG4gICAqICAgIDxsaT50YXJnZXRwYXRod2lkdGggPSB4U2NhbGVGYWN0b3IgKiBjb250YWluZXJXaWR0aDwvbGk+XG4gICAqICAgIDxsaT50YXJnZXRwYXRoaGVpZ2h0ID0geVNjYWxlRmFjdG9yICogY29udGFpbmVySGVpZ2h0PC9saT5cbiAgICogICAgPGxpPlBvc2l0aW9uIGlzIHVzZWQgdG8gc2V0IHRoZSBzdGFydGluZyBjb29yZGluYXRlIG9mIHRoZSBwYXRoLiBNIGlzIGNvbXB1dGVkOlxuICAgICogICAgPHVsPlxuICAgICogICAgICA8bGk+cG9zaXRpb24ueCAqIGNvbnRhaW5lcldpZHRoPC9saT5cbiAgICAqICAgICAgPGxpPnBvc2l0aW9uLnkgKiBjb250YWluZXJIZWlnaHQ8L2xpPlxuICAgICogICAgPC91bD5cbiAgICAqICAgIENlbnRlciBvZiB0aGUgY29udGFpbmVyIDxwcmU+IHBvc2l0aW9uOiB7XG4gICAqICAgICAgIG14OiAwLjUsXG4gICAqICAgICAgIG15OiAwLjUsXG4gICAqICAgICB9PC9wcmU+XG4gICAqICAgICBVcHBlciBsZWZ0IGNvcm5lciBvZiB0aGUgY29udGFpbmVyXG4gICAqICAgICA8cHJlPiBwb3NpdGlvbjoge1xuICAgKiAgICAgICBteDogMC4wLFxuICAgKiAgICAgICBteTogMC4wLFxuICAgKiAgICAgfTwvcHJlPlxuICAgKiAgICA8L2xpPlxuICAgKiAgIDwvdWw+XG4gICAqIDwvcD5cbiAgICpcbiAgICovXG4gIHRoaXMuZ2V0U2NhbGVkUGF0aCA9IGZ1bmN0aW9uIGdldFNjYWxlZFBhdGgocGF0aElkLCBwYXJhbSkge1xuICAgIHZhciByYXdQYXRoID0gdGhpcy5wYXRoTWFwW3BhdGhJZF07XG5cbiAgICAvLyBwb3NpdGlvbmluZ1xuICAgIC8vIGNvbXB1dGUgdGhlIHN0YXJ0IHBvaW50IG9mIHRoZSBwYXRoXG4gICAgdmFyIG14LCBteTtcblxuICAgIGlmIChwYXJhbS5hYnNwb3MpIHtcbiAgICAgIG14ID0gcGFyYW0uYWJzcG9zLng7XG4gICAgICBteSA9IHBhcmFtLmFic3Bvcy55O1xuICAgIH0gZWxzZSB7XG4gICAgICBteCA9IHBhcmFtLmNvbnRhaW5lcldpZHRoICogcGFyYW0ucG9zaXRpb24ubXg7XG4gICAgICBteSA9IHBhcmFtLmNvbnRhaW5lckhlaWdodCAqIHBhcmFtLnBvc2l0aW9uLm15O1xuICAgIH1cblxuICAgIHZhciBjb29yZGluYXRlcyA9IHt9OyAvLyBtYXAgZm9yIHRoZSBzY2FsZWQgY29vcmRpbmF0ZXNcbiAgICBpZiAocGFyYW0ucG9zaXRpb24pIHtcblxuICAgICAgLy8gcGF0aFxuICAgICAgdmFyIGhlaWdodFJhdGlvID0gKHBhcmFtLmNvbnRhaW5lckhlaWdodCAvIHJhd1BhdGguaGVpZ2h0KSAqIHBhcmFtLnlTY2FsZUZhY3RvcjtcbiAgICAgIHZhciB3aWR0aFJhdGlvID0gKHBhcmFtLmNvbnRhaW5lcldpZHRoIC8gcmF3UGF0aC53aWR0aCkgKiBwYXJhbS54U2NhbGVGYWN0b3I7XG5cblxuICAgICAgLy8gQXBwbHkgaGVpZ2h0IHJhdGlvXG4gICAgICBmb3IgKHZhciBoZWlnaHRJbmRleCA9IDA7IGhlaWdodEluZGV4IDwgcmF3UGF0aC5oZWlnaHRFbGVtZW50cy5sZW5ndGg7IGhlaWdodEluZGV4KyspIHtcbiAgICAgICAgY29vcmRpbmF0ZXNbJ3knICsgaGVpZ2h0SW5kZXhdID0gcmF3UGF0aC5oZWlnaHRFbGVtZW50c1toZWlnaHRJbmRleF0gKiBoZWlnaHRSYXRpbztcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgd2lkdGggcmF0aW9cbiAgICAgIGZvciAodmFyIHdpZHRoSW5kZXggPSAwOyB3aWR0aEluZGV4IDwgcmF3UGF0aC53aWR0aEVsZW1lbnRzLmxlbmd0aDsgd2lkdGhJbmRleCsrKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzWyd4JyArIHdpZHRoSW5kZXhdID0gcmF3UGF0aC53aWR0aEVsZW1lbnRzW3dpZHRoSW5kZXhdICogd2lkdGhSYXRpbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSB2YWx1ZSB0byByYXcgcGF0aFxuICAgIHZhciBwYXRoID0gZm9ybWF0KFxuICAgICAgcmF3UGF0aC5kLCB7XG4gICAgICAgIG14OiBteCxcbiAgICAgICAgbXk6IG15LFxuICAgICAgICBlOiBjb29yZGluYXRlc1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG59XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUtd2VicGxhdGZvcm0vU25hcC5zdmcvYmxvYi9tYXN0ZXIvc3JjL3N2Zy5qc1xudmFyIHRva2VuUmVnZXggPSAvXFx7KFtefV0rKVxcfS9nLFxuICAgIG9iak5vdGF0aW9uUmVnZXggPSAvKD86KD86XnxcXC4pKC4rPykoPz1cXFt8XFwufCR8XFwoKXxcXFsoJ3xcIikoLis/KVxcMlxcXSkoXFwoXFwpKT8vZzsgLy8gbWF0Y2hlcyAueHh4eHggb3IgW1wieHh4eHhcIl0gdG8gcnVuIG92ZXIgb2JqZWN0IHByb3BlcnRpZXNcblxuZnVuY3Rpb24gcmVwbGFjZXIoYWxsLCBrZXksIG9iaikge1xuICB2YXIgcmVzID0gb2JqO1xuICBrZXkucmVwbGFjZShvYmpOb3RhdGlvblJlZ2V4LCBmdW5jdGlvbihhbGwsIG5hbWUsIHF1b3RlLCBxdW90ZWROYW1lLCBpc0Z1bmMpIHtcbiAgICBuYW1lID0gbmFtZSB8fCBxdW90ZWROYW1lO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGlmIChuYW1lIGluIHJlcykge1xuICAgICAgICByZXMgPSByZXNbbmFtZV07XG4gICAgICB9XG4gICAgICB0eXBlb2YgcmVzID09ICdmdW5jdGlvbicgJiYgaXNGdW5jICYmIChyZXMgPSByZXMoKSk7XG4gICAgfVxuICB9KTtcbiAgcmVzID0gKHJlcyA9PSBudWxsIHx8IHJlcyA9PSBvYmogPyBhbGwgOiByZXMpICsgJyc7XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZm9ybWF0KHN0ciwgb2JqKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHRva2VuUmVnZXgsIGZ1bmN0aW9uKGFsbCwga2V5KSB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKGFsbCwga2V5LCBvYmopO1xuICB9KTtcbn1cbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCB7XG4gIGlzT2JqZWN0LFxuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXG4gIGNsYXNzZXMgYXMgc3ZnQ2xhc3Nlc1xufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCBCYXNlUmVuZGVyZXIgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZHJhdy9CYXNlUmVuZGVyZXInO1xuXG5pbXBvcnQge1xuICBnZXRMYWJlbFxufSBmcm9tICcuLi9mZWF0dXJlcy9sYWJlbC1lZGl0aW5nL0xhYmVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldEJ1c2luZXNzT2JqZWN0LFxuICBpc1xufSBmcm9tICcuLi91dGlsL01vZGVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldFNlbWFudGljLFxuICBnZXRSZWN0UGF0aCxcbiAgZ2V0RmlsbENvbG9yLFxuICBnZXRTdHJva2VDb2xvclxufSBmcm9tICcuL1Bvc3RpdFJlbmRlcmVyVXRpbCc7XG5cbnZhciBERUZBVUxUX0ZJTExfT1BBQ0lUWSA9IC45NTtcblxudmFyIFRBU0tfQk9SREVSX1JBRElVUyA9IDEwO1xuXG52YXIgREVGQVVMVF9URVhUX1NJWkUgPSAxNjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0UmVuZGVyZXIoXG4gICAgY29uZmlnLCBldmVudEJ1cywgc3R5bGVzLCBwYXRoTWFwLFxuICAgIGNhbnZhcywgdGV4dFJlbmRlcmVyLCBwcmlvcml0eSkge1xuXG4gIEJhc2VSZW5kZXJlci5jYWxsKHRoaXMsIGV2ZW50QnVzLCBwcmlvcml0eSk7XG5cbiAgdmFyIGRlZmF1bHRGaWxsQ29sb3IgPSBjb25maWcgJiYgY29uZmlnLmRlZmF1bHRGaWxsQ29sb3IsXG4gICAgICBkZWZhdWx0U3Ryb2tlQ29sb3IgPSBjb25maWcgJiYgY29uZmlnLmRlZmF1bHRTdHJva2VDb2xvcjtcblxuICB2YXIgY29tcHV0ZVN0eWxlID0gc3R5bGVzLmNvbXB1dGVTdHlsZTtcblxuICBmdW5jdGlvbiBkcmF3Q2lyY2xlKHBhcmVudEdmeCwgd2lkdGgsIGhlaWdodCwgb2Zmc2V0LCBhdHRycykge1xuXG4gICAgaWYgKGlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICAgIGF0dHJzID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGF0dHJzID0gY29tcHV0ZVN0eWxlKGF0dHJzLCB7XG4gICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgIGZpbGw6ICd3aGl0ZSdcbiAgICB9KTtcblxuICAgIGlmIChhdHRycy5maWxsID09PSAnbm9uZScpIHtcbiAgICAgIGRlbGV0ZSBhdHRycy5maWxsT3BhY2l0eTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSB3aWR0aCAvIDIsXG4gICAgICAgIGN5ID0gaGVpZ2h0IC8gMjtcblxuICAgIHZhciBjaXJjbGUgPSBzdmdDcmVhdGUoJ2NpcmNsZScpO1xuICAgIHN2Z0F0dHIoY2lyY2xlLCB7XG4gICAgICBjeDogY3gsXG4gICAgICBjeTogY3ksXG4gICAgICByOiBNYXRoLnJvdW5kKCh3aWR0aCArIGhlaWdodCkgLyA0IC0gb2Zmc2V0KVxuICAgIH0pO1xuICAgIHN2Z0F0dHIoY2lyY2xlLCBhdHRycyk7XG5cbiAgICBzdmdBcHBlbmQocGFyZW50R2Z4LCBjaXJjbGUpO1xuXG4gICAgcmV0dXJuIGNpcmNsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXdSZWN0KHBhcmVudEdmeCwgd2lkdGgsIGhlaWdodCwgciwgb2Zmc2V0LCBhdHRycykge1xuXG4gICAgaWYgKGlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICAgIGF0dHJzID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGF0dHJzID0gY29tcHV0ZVN0eWxlKGF0dHJzLCB7XG4gICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgIGZpbGw6ICd3aGl0ZSdcbiAgICB9KTtcblxuICAgIHZhciByZWN0ID0gc3ZnQ3JlYXRlKCdyZWN0Jyk7XG4gICAgc3ZnQXR0cihyZWN0LCB7XG4gICAgICB4OiBvZmZzZXQsXG4gICAgICB5OiBvZmZzZXQsXG4gICAgICB3aWR0aDogd2lkdGggLSBvZmZzZXQgKiAyLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgLSBvZmZzZXQgKiAyLFxuICAgICAgcng6IHIsXG4gICAgICByeTogclxuICAgIH0pO1xuICAgIHN2Z0F0dHIocmVjdCwgYXR0cnMpO1xuXG4gICAgc3ZnQXBwZW5kKHBhcmVudEdmeCwgcmVjdCk7XG5cbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXdQYXRoKHBhcmVudEdmeCwgZCwgYXR0cnMpIHtcblxuICAgIGF0dHJzID0gY29tcHV0ZVN0eWxlKGF0dHJzLCBbICduby1maWxsJyBdLCB7XG4gICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgIHN0cm9rZTogJ2JsYWNrJ1xuICAgIH0pO1xuXG4gICAgdmFyIHBhdGggPSBzdmdDcmVhdGUoJ3BhdGgnKTtcbiAgICBzdmdBdHRyKHBhdGgsIHsgZDogZCB9KTtcbiAgICBzdmdBdHRyKHBhdGgsIGF0dHJzKTtcblxuICAgIHN2Z0FwcGVuZChwYXJlbnRHZngsIHBhdGgpO1xuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHJlbmRlckxhYmVsKHBhcmVudEdmeCwgbGFiZWwsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBhc3NpZ24oe1xuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aDogMTAwXG4gICAgICB9XG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgdGV4dCA9IHRleHRSZW5kZXJlci5jcmVhdGVUZXh0KGxhYmVsIHx8ICcnLCBvcHRpb25zKTtcblxuICAgIHN2Z0NsYXNzZXModGV4dCkuYWRkKCdkanMtbGFiZWwnKTtcblxuICAgIHN2Z0FwcGVuZChwYXJlbnRHZngsIHRleHQpO1xuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJFbWJlZGRlZExhYmVsKHBhcmVudEdmeCwgZWxlbWVudCwgYWxpZ24sIGZvbnRTaXplKSB7XG4gICAgdmFyIHNlbWFudGljID0gZ2V0U2VtYW50aWMoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gcmVuZGVyTGFiZWwocGFyZW50R2Z4LCBzZW1hbnRpYy5uYW1lLCB7XG4gICAgICBib3g6IGVsZW1lbnQsXG4gICAgICBhbGlnbjogYWxpZ24sXG4gICAgICBwYWRkaW5nOiA1LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogZ2V0Q29sb3IoZWxlbWVudCkgPT09ICdibGFjaycgPyAnd2hpdGUnIDogJ2JsYWNrJyxcbiAgICAgICAgZm9udFNpemU6IGZvbnRTaXplIHx8IERFRkFVTFRfVEVYVF9TSVpFXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyRXh0ZXJuYWxMYWJlbChwYXJlbnRHZngsIGVsZW1lbnQpIHtcblxuICAgIHZhciBib3ggPSB7XG4gICAgICB3aWR0aDogOTAsXG4gICAgICBoZWlnaHQ6IDMwLFxuICAgICAgeDogZWxlbWVudC53aWR0aCAvIDIgKyBlbGVtZW50LngsXG4gICAgICB5OiBlbGVtZW50LmhlaWdodCAvIDIgKyBlbGVtZW50LnlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlbmRlckxhYmVsKHBhcmVudEdmeCwgZ2V0TGFiZWwoZWxlbWVudCksIHtcbiAgICAgIGJveDogYm94LFxuICAgICAgZml0Qm94OiB0cnVlLFxuICAgICAgc3R5bGU6IGFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIHRleHRSZW5kZXJlci5nZXRFeHRlcm5hbFN0eWxlKCksXG4gICAgICAgIHtcbiAgICAgICAgICBmaWxsOiAnYmxhY2snXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuaGFuZGxlcnMgPSB7XG4gICAgJ3Bvc3RpdDpTcXVhcmVQb3N0aXQnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcblxuICAgICAgdmFyIGF0dHJzID0ge1xuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfTtcblxuICAgICAgaWYgKCEoJ2ZpbGxPcGFjaXR5JyBpbiBhdHRycykpIHtcbiAgICAgICAgYXR0cnMuZmlsbE9wYWNpdHkgPSBERUZBVUxUX0ZJTExfT1BBQ0lUWTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY3QgPSBkcmF3UmVjdChwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCAwLCBhdHRycyk7XG5cbiAgICAgIHJlbmRlckVtYmVkZGVkTGFiZWwocGFyZW50R2Z4LCBlbGVtZW50LCAnY2VudGVyLW1pZGRsZScpO1xuXG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9LFxuXG4gICAgJ3Bvc3RpdDpHcm91cCc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuXG4gICAgICB2YXIgZ3JvdXAgPSBkcmF3UmVjdChwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCBUQVNLX0JPUkRFUl9SQURJVVMsIHtcbiAgICAgICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnOCwzLDEsMycsXG4gICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0sXG5cbiAgICAncG9zdGl0OkNpcmNsZVBvc3RpdCc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIGF0dHJzID0ge1xuICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yKVxuICAgICAgfTtcblxuICAgICAgaWYgKCEoJ2ZpbGxPcGFjaXR5JyBpbiBhdHRycykpIHtcbiAgICAgICAgYXR0cnMuZmlsbE9wYWNpdHkgPSBERUZBVUxUX0ZJTExfT1BBQ0lUWTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY3QgPSBkcmF3Q2lyY2xlKHBhcmVudEdmeCwgZWxlbWVudC53aWR0aCwgZWxlbWVudC5oZWlnaHQsIGF0dHJzKTtcblxuICAgICAgcmVuZGVyRW1iZWRkZWRMYWJlbChwYXJlbnRHZngsIGVsZW1lbnQsICdjZW50ZXItbWlkZGxlJyk7XG5cbiAgICAgIHJldHVybiByZWN0O1xuICAgIH0sXG4gICAgJ3Bvc3RpdDpUZXh0Qm94JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50KSB7XG4gICAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgc3Ryb2tlOiAnbm9uZSdcbiAgICAgIH07XG5cbiAgICAgIHZhciB0ZXh0U2l6ZSA9IGVsZW1lbnQudGV4dFNpemUgfHwgREVGQVVMVF9URVhUX1NJWkU7XG5cbiAgICAgIHZhciByZWN0ID0gZHJhd1JlY3QocGFyZW50R2Z4LCBlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCwgMCwgYXR0cnMpO1xuXG4gICAgICByZW5kZXJFbWJlZGRlZExhYmVsKHBhcmVudEdmeCwgZWxlbWVudCwgJ2NlbnRlci1taWRkbGUnLCB0ZXh0U2l6ZSk7XG5cbiAgICAgIHJldHVybiByZWN0O1xuICAgIH0sXG4gICAgJ3Bvc3RpdDpJbWFnZSc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCkge1xuICAgICAgdmFyIGltYWdlU291cmNlID0gZ2V0SW1hZ2VTb3VyY2UoZWxlbWVudCk7XG5cbiAgICAgIHZhciBnZng7XG4gICAgICBpZiAoIWltYWdlU291cmNlKSB7XG5cbiAgICAgICAgLy8gZGVmYXVsdCBwbGFjZWhvbGRlclxuICAgICAgICBnZnggPSBkcmF3UmVjdChwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCAwLCB7XG4gICAgICAgICAgZmlsbDogJyNjY2MnLFxuICAgICAgICAgIHN0cm9rZTogJyNjY2MnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlckxhYmVsKHBhcmVudEdmeCwgJ0ltYWdlIFBsYWNlaG9sZGVyJywge1xuICAgICAgICAgIGJveDogZWxlbWVudCxcbiAgICAgICAgICBhbGlnbjogJ2NlbnRlci1taWRkbGUnLFxuICAgICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGZpbGw6ICdibGFjaycsXG4gICAgICAgICAgICBmb250U2l6ZTogREVGQVVMVF9URVhUX1NJWkVcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2Z4ID0gc3ZnQ3JlYXRlKCdpbWFnZScsIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBocmVmOiBnZXRJbWFnZVNvdXJjZShlbGVtZW50KVxuICAgICAgICB9KTtcblxuICAgICAgICBzdmdBcHBlbmQocGFyZW50R2Z4LCBnZngpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2Z4O1xuICAgIH0sXG5cbiAgICAnbGFiZWwnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiByZW5kZXJFeHRlcm5hbExhYmVsKHBhcmVudEdmeCwgZWxlbWVudCk7XG4gICAgfVxuICB9O1xuXG5cbiAgLy8gZXh0ZW5zaW9uIEFQSSwgdXNlIGF0IHlvdXIgb3duIHJpc2tcbiAgdGhpcy5fZHJhd1BhdGggPSBkcmF3UGF0aDtcblxufVxuXG5cbmluaGVyaXRzKFBvc3RpdFJlbmRlcmVyLCBCYXNlUmVuZGVyZXIpO1xuXG5Qb3N0aXRSZW5kZXJlci4kaW5qZWN0ID0gW1xuICAnY29uZmlnLnBvc3RpdCcsXG4gICdldmVudEJ1cycsXG4gICdzdHlsZXMnLFxuICAncGF0aE1hcCcsXG4gICdjYW52YXMnLFxuICAndGV4dFJlbmRlcmVyJ1xuXTtcblxuXG5Qb3N0aXRSZW5kZXJlci5wcm90b3R5cGUuY2FuUmVuZGVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gaXMoZWxlbWVudCwgJ3Bvc3RpdDpCb2FyZEVsZW1lbnQnKTtcbn07XG5cblBvc3RpdFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3U2hhcGUgPSBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQpIHtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBoID0gdGhpcy5oYW5kbGVyc1t0eXBlXTtcblxuICAvKiBqc2hpbnQgLVcwNDAgKi9cbiAgcmV0dXJuIGgocGFyZW50R2Z4LCBlbGVtZW50KTtcbn07XG5cblBvc3RpdFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaGFwZVBhdGggPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgcmV0dXJuIGdldFJlY3RQYXRoKGVsZW1lbnQpO1xufTtcblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGdldENvbG9yKGVsZW1lbnQpIHtcbiAgdmFyIGJvID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XG5cbiAgcmV0dXJuIGJvLmNvbG9yIHx8IGVsZW1lbnQuY29sb3I7XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlU291cmNlKGVsZW1lbnQpIHtcbiAgdmFyIGJvID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XG5cbiAgcmV0dXJuIGJvLnNvdXJjZSB8fCBlbGVtZW50LnNvdXJjZTtcbn1cblxuIiwiaW1wb3J0IHtcbiAgZXZlcnksXG4gIHNvbWVcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBjb21wb25lbnRzVG9QYXRoXG59IGZyb20gJ2RpYWdyYW0tanMvbGliL3V0aWwvUmVuZGVyVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldEJ1c2luZXNzT2JqZWN0XG59IGZyb20gJy4uL3V0aWwvTW9kZWxVdGlsJztcblxuXG4vLyBlbGVtZW50IHV0aWxzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDaGVja3MgaWYgZXZlbnREZWZpbml0aW9uIG9mIHRoZSBnaXZlbiBlbGVtZW50IG1hdGNoZXMgd2l0aCBzZW1hbnRpYyB0eXBlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgZWxlbWVudCBpcyBvZiB0aGUgZ2l2ZW4gc2VtYW50aWMgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlZEV2ZW50KGV2ZW50LCBldmVudERlZmluaXRpb25UeXBlLCBmaWx0ZXIpIHtcblxuICBmdW5jdGlvbiBtYXRjaGVzKGRlZmluaXRpb24sIGZpbHRlcikge1xuICAgIHJldHVybiBldmVyeShmaWx0ZXIsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cbiAgICAgIC8vIHdlIHdhbnQgYSA9PSBjb252ZXJzaW9uIGhlcmUsIHRvIGJlIGFibGUgdG8gY2F0Y2hcbiAgICAgIC8vIHVuZGVmaW5lZCA9PSBmYWxzZSBhbmQgZnJpZW5kc1xuICAgICAgLyoganNoaW50IC1XMTE2ICovXG4gICAgICByZXR1cm4gZGVmaW5pdGlvbltrZXldID09IHZhbDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzb21lKGV2ZW50LmV2ZW50RGVmaW5pdGlvbnMsIGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvbi4kdHlwZSA9PT0gZXZlbnREZWZpbml0aW9uVHlwZSAmJiBtYXRjaGVzKGV2ZW50LCBmaWx0ZXIpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuYnVzaW5lc3NPYmplY3QuZGk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW1hbnRpYyhlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LmJ1c2luZXNzT2JqZWN0O1xufVxuXG5cbi8vIGNvbG9yIGFjY2VzcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdENvbG9yKSB7XG4gIHJldHVybiAoXG4gICAgZ2V0Q29sb3IoZWxlbWVudCkgfHxcbiAgICBnZXREaShlbGVtZW50KS5nZXQoJ2Jpb2M6ZmlsbCcpIHx8XG4gICAgZGVmYXVsdENvbG9yIHx8XG4gICAgJ3doaXRlJ1xuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdENvbG9yKSB7XG4gIHJldHVybiAoXG4gICAgZ2V0Q29sb3IoZWxlbWVudCkgfHxcbiAgICBnZXREaShlbGVtZW50KS5nZXQoJ2Jpb2M6c3Ryb2tlJykgfHxcbiAgICBkZWZhdWx0Q29sb3IgfHxcbiAgICAnYmxhY2snXG4gICk7XG59XG5cblxuLy8gY3JvcHBpbmcgcGF0aCBjdXN0b21pemF0aW9ucyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaXJjbGVQYXRoKHNoYXBlKSB7XG5cbiAgdmFyIGN4ID0gc2hhcGUueCArIHNoYXBlLndpZHRoIC8gMixcbiAgICAgIGN5ID0gc2hhcGUueSArIHNoYXBlLmhlaWdodCAvIDIsXG4gICAgICByYWRpdXMgPSBzaGFwZS53aWR0aCAvIDI7XG5cbiAgdmFyIGNpcmNsZVBhdGggPSBbXG4gICAgWydNJywgY3gsIGN5XSxcbiAgICBbJ20nLCAwLCAtcmFkaXVzXSxcbiAgICBbJ2EnLCByYWRpdXMsIHJhZGl1cywgMCwgMSwgMSwgMCwgMiAqIHJhZGl1c10sXG4gICAgWydhJywgcmFkaXVzLCByYWRpdXMsIDAsIDEsIDEsIDAsIC0yICogcmFkaXVzXSxcbiAgICBbJ3onXVxuICBdO1xuXG4gIHJldHVybiBjb21wb25lbnRzVG9QYXRoKGNpcmNsZVBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91bmRSZWN0UGF0aChzaGFwZSwgYm9yZGVyUmFkaXVzKSB7XG5cbiAgdmFyIHggPSBzaGFwZS54LFxuICAgICAgeSA9IHNoYXBlLnksXG4gICAgICB3aWR0aCA9IHNoYXBlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuXG4gIHZhciByb3VuZFJlY3RQYXRoID0gW1xuICAgIFsnTScsIHggKyBib3JkZXJSYWRpdXMsIHldLFxuICAgIFsnbCcsIHdpZHRoIC0gYm9yZGVyUmFkaXVzICogMiwgMF0sXG4gICAgWydhJywgYm9yZGVyUmFkaXVzLCBib3JkZXJSYWRpdXMsIDAsIDAsIDEsIGJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzXSxcbiAgICBbJ2wnLCAwLCBoZWlnaHQgLSBib3JkZXJSYWRpdXMgKiAyXSxcbiAgICBbJ2EnLCBib3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1cywgMCwgMCwgMSwgLWJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzXSxcbiAgICBbJ2wnLCBib3JkZXJSYWRpdXMgKiAyIC0gd2lkdGgsIDBdLFxuICAgIFsnYScsIGJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzLCAwLCAwLCAxLCAtYm9yZGVyUmFkaXVzLCAtYm9yZGVyUmFkaXVzXSxcbiAgICBbJ2wnLCAwLCBib3JkZXJSYWRpdXMgKiAyIC0gaGVpZ2h0XSxcbiAgICBbJ2EnLCBib3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1cywgMCwgMCwgMSwgYm9yZGVyUmFkaXVzLCAtYm9yZGVyUmFkaXVzXSxcbiAgICBbJ3onXVxuICBdO1xuXG4gIHJldHVybiBjb21wb25lbnRzVG9QYXRoKHJvdW5kUmVjdFBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlhbW9uZFBhdGgoc2hhcGUpIHtcblxuICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aCxcbiAgICAgIGhlaWdodCA9IHNoYXBlLmhlaWdodCxcbiAgICAgIHggPSBzaGFwZS54LFxuICAgICAgeSA9IHNoYXBlLnksXG4gICAgICBoYWxmV2lkdGggPSB3aWR0aCAvIDIsXG4gICAgICBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblxuICB2YXIgZGlhbW9uZFBhdGggPSBbXG4gICAgWydNJywgeCArIGhhbGZXaWR0aCwgeV0sXG4gICAgWydsJywgaGFsZldpZHRoLCBoYWxmSGVpZ2h0XSxcbiAgICBbJ2wnLCAtaGFsZldpZHRoLCBoYWxmSGVpZ2h0XSxcbiAgICBbJ2wnLCAtaGFsZldpZHRoLCAtaGFsZkhlaWdodF0sXG4gICAgWyd6J11cbiAgXTtcblxuICByZXR1cm4gY29tcG9uZW50c1RvUGF0aChkaWFtb25kUGF0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWN0UGF0aChzaGFwZSkge1xuICB2YXIgeCA9IHNoYXBlLngsXG4gICAgICB5ID0gc2hhcGUueSxcbiAgICAgIHdpZHRoID0gc2hhcGUud2lkdGgsXG4gICAgICBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG5cbiAgdmFyIHJlY3RQYXRoID0gW1xuICAgIFsnTScsIHgsIHldLFxuICAgIFsnbCcsIHdpZHRoLCAwXSxcbiAgICBbJ2wnLCAwLCBoZWlnaHRdLFxuICAgIFsnbCcsIC13aWR0aCwgMF0sXG4gICAgWyd6J11cbiAgXTtcblxuICByZXR1cm4gY29tcG9uZW50c1RvUGF0aChyZWN0UGF0aCk7XG59XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBnZXRDb2xvcihlbGVtZW50KSB7XG4gIHZhciBibyA9IGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpO1xuXG4gIHJldHVybiBiby5jb2xvciB8fCBlbGVtZW50LmNvbG9yO1xufSIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IFRleHRVdGlsIGZyb20gJ2RpYWdyYW0tanMvbGliL3V0aWwvVGV4dCc7XG5cbnZhciBERUZBVUxUX0ZPTlRfU0laRSA9IDE2O1xudmFyIExJTkVfSEVJR0hUX1JBVElPID0gMS4yO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRleHRSZW5kZXJlcihjb25maWcpIHtcblxuICB2YXIgZGVmYXVsdFN0eWxlID0gYXNzaWduKHtcbiAgICBmb250RmFtaWx5OiAnSUJNIFBsZXgsIHNhbnMtc2VyaWYnLFxuICAgIGZvbnRTaXplOiBERUZBVUxUX0ZPTlRfU0laRSxcbiAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICBsaW5lSGVpZ2h0OiBMSU5FX0hFSUdIVF9SQVRJT1xuICB9LCBjb25maWcgJiYgY29uZmlnLmRlZmF1bHRTdHlsZSB8fCB7fSk7XG5cbiAgdmFyIGZvbnRTaXplID0gcGFyc2VJbnQoZGVmYXVsdFN0eWxlLmZvbnRTaXplLCAxMCkgLSAxO1xuXG4gIHZhciBleHRlcm5hbFN0eWxlID0gYXNzaWduKHt9LCBkZWZhdWx0U3R5bGUsIHtcbiAgICBmb250U2l6ZTogZm9udFNpemVcbiAgfSwgY29uZmlnICYmIGNvbmZpZy5leHRlcm5hbFN0eWxlIHx8IHt9KTtcblxuICB2YXIgdGV4dFV0aWwgPSBuZXcgVGV4dFV0aWwoe1xuICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV3IGJvdW5kcyBvZiBhbiBleHRlcm5hbGx5IHJlbmRlcmVkLFxuICAgKiBsYXlvdXRlZCBsYWJlbC5cbiAgICpcbiAgICogQHBhcmFtICB7Qm91bmRzfSBib3VuZHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0XG4gICAqXG4gICAqIEByZXR1cm4ge0JvdW5kc31cbiAgICovXG4gIHRoaXMuZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kcyA9IGZ1bmN0aW9uKGJvdW5kcywgdGV4dCkge1xuXG4gICAgdmFyIGxheW91dGVkRGltZW5zaW9ucyA9IHRleHRVdGlsLmdldERpbWVuc2lvbnModGV4dCwge1xuICAgICAgYm94OiB7XG4gICAgICAgIHdpZHRoOiA5MCxcbiAgICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgICAgeDogYm91bmRzLndpZHRoIC8gMiArIGJvdW5kcy54LFxuICAgICAgICB5OiBib3VuZHMuaGVpZ2h0IC8gMiArIGJvdW5kcy55XG4gICAgICB9LFxuICAgICAgc3R5bGU6IGV4dGVybmFsU3R5bGVcbiAgICB9KTtcblxuICAgIC8vIHJlc2l6ZSBsYWJlbCBzaGFwZSB0byBmaXQgbGFiZWwgdGV4dFxuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLnJvdW5kKGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMiAtIGxheW91dGVkRGltZW5zaW9ucy53aWR0aCAvIDIpLFxuICAgICAgeTogTWF0aC5yb3VuZChib3VuZHMueSksXG4gICAgICB3aWR0aDogTWF0aC5jZWlsKGxheW91dGVkRGltZW5zaW9ucy53aWR0aCksXG4gICAgICBoZWlnaHQ6IE1hdGguY2VpbChsYXlvdXRlZERpbWVuc2lvbnMuaGVpZ2h0KVxuICAgIH07XG5cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbGF5b3V0ZWQgdGV4dCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqXG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHJlbmRlcmVkIHRleHRcbiAgICovXG4gIHRoaXMuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGV4dFV0aWwuY3JlYXRlVGV4dCh0ZXh0LCBvcHRpb25zIHx8IHt9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGRlZmF1bHQgdGV4dCBzdHlsZS5cbiAgICovXG4gIHRoaXMuZ2V0RGVmYXVsdFN0eWxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRTdHlsZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlcm5hbCB0ZXh0IHN0eWxlLlxuICAgKi9cbiAgdGhpcy5nZXRFeHRlcm5hbFN0eWxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGV4dGVybmFsU3R5bGU7XG4gIH07XG5cbn1cblxuVGV4dFJlbmRlcmVyLiRpbmplY3QgPSBbXG4gICdjb25maWcudGV4dFJlbmRlcmVyJ1xuXTsiLCJpbXBvcnQgUG9zdGl0UmVuZGVyZXIgZnJvbSAnLi9Qb3N0aXRSZW5kZXJlcic7XG5pbXBvcnQgVGV4dFJlbmRlcmVyIGZyb20gJy4vVGV4dFJlbmRlcmVyJztcblxuaW1wb3J0IFBhdGhNYXAgZnJvbSAnLi9QYXRoTWFwJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAncG9zdGl0UmVuZGVyZXInIF0sXG4gIHBvc3RpdFJlbmRlcmVyOiBbICd0eXBlJywgUG9zdGl0UmVuZGVyZXIgXSxcbiAgdGV4dFJlbmRlcmVyOiBbICd0eXBlJywgVGV4dFJlbmRlcmVyIF0sXG4gIHBhdGhNYXA6IFsgJ3R5cGUnLCBQYXRoTWFwIF1cbn07XG4iLCJpbXBvcnQge1xuICBkZWxlZ2F0ZSBhcyBkb21EZWxlZ2F0ZVxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZ2V0QnVzaW5lc3NPYmplY3Rcbn0gZnJvbSAnLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG5pbXBvcnQgQ09MT1JTIGZyb20gJy4uLy4uL3V0aWwvQ29sb3JVdGlsJztcblxuaW1wb3J0IHtcbiAgdG9Qb2ludFxufSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL0V2ZW50JztcbmltcG9ydCB7IGlzQW55IH0gZnJvbSAnLi4vbW9kZWxpbmcvdXRpbC9Nb2RlbGluZ1V0aWwnO1xuXG52YXIgREVGQVVMVF9TSEFQRSA9IHtcbiAgdHlwZTogJ3Bvc3RpdDpTcXVhcmVQb3N0aXQnLFxuICBjb2xvcjogQ09MT1JTLllFTExPVyxcbiAgJGluc3RhbmNlT2Y6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FudmFzQ3JlYXRlKFxuICAgIGV2ZW50QnVzLCBlbGVtZW50RmFjdG9yeSwgY2FudmFzLCBkaXJlY3RFZGl0aW5nLCBtb2RlbGluZykge1xuXG4gIHZhciBsYXN0Q3JlYXRlZFNoYXBlID0gREVGQVVMVF9TSEFQRTtcblxuICBmdW5jdGlvbiBfZ2V0TmV3U2hhcGVQb3NpdGlvbihldmVudCkge1xuICAgIHZhciBldmVudFBvaW50ID0gdG9Qb2ludChldmVudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnRQb2ludC54LFxuICAgICAgeTogZXZlbnRQb2ludC55XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hY3RpdmF0ZURpcmVjdEVkaXQoZWxlbWVudCkge1xuICAgIGlmIChpc0FueShlbGVtZW50LCBbICdwb3N0aXQ6UG9zdGl0JywgJ3Bvc3RpdDpHcm91cCcsICdwb3N0aXQ6VGV4dEJveCcgXSkpIHtcblxuICAgICAgZGlyZWN0RWRpdGluZy5hY3RpdmF0ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlU2hhcGVPbkNhbnZhcyhldmVudCkge1xuICAgIHZhciBwb3NpdGlvbiA9IF9nZXROZXdTaGFwZVBvc2l0aW9uKGV2ZW50KTtcblxuICAgIHZhciBuZXdTaGFwZSA9IGVsZW1lbnRGYWN0b3J5LmNyZWF0ZVBvc3RpdEVsZW1lbnQoXG4gICAgICAnc2hhcGUnLCBhc3NpZ24obGFzdENyZWF0ZWRTaGFwZSwgcG9zaXRpb24pKTtcblxuICAgIHZhciByb290ID0gY2FudmFzLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgICB2YXIgY3JlYXRlZFNoYXBlID0gbW9kZWxpbmcuY3JlYXRlU2hhcGUobmV3U2hhcGUsIHBvc2l0aW9uLCByb290KTtcblxuICAgIF9hY3RpdmF0ZURpcmVjdEVkaXQoY3JlYXRlZFNoYXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zYXZlTGFzdENyZWF0ZWRTaGFwZShzaGFwZSkge1xuICAgIGlmICghc2hhcGUpIHtcbiAgICAgIGxhc3RDcmVhdGVkU2hhcGUgPSBERUZBVUxUX1NIQVBFO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBibyA9IGdldEJ1c2luZXNzT2JqZWN0KHNoYXBlKTtcblxuICAgIGxhc3RDcmVhdGVkU2hhcGUgPSB7XG4gICAgICB0eXBlOiBzaGFwZS50eXBlLFxuICAgICAgY29sb3I6IHNoYXBlLmNvbG9yIHx8IGJvLmNvbG9yLFxuICAgICAgJGluc3RhbmNlT2Y6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgYm8uJGluc3RhbmNlT2YgPT09ICdmdW5jdGlvbicpICYmIGJvLiRpbnN0YW5jZU9mKHR5cGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVEcm9wU2hhZG93RmlsdGVyKHZpZXdwb3J0KSB7XG4gICAgdmlld3BvcnQuaW5uZXJIVE1MID0gJzxmaWx0ZXIgaWQ9XCJub3RlRHJvcFNoYWRvd1wiIHN0eWxlPVwiaGVpZ2h0OiAxMzAlO1wiPjxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwiM1wiPjwvZmVHYXVzc2lhbkJsdXI+PGZlT2Zmc2V0IGR4PVwiMVwiIGR5PVwiMlwiIHJlc3VsdD1cIm9mZnNldGJsdXJcIj48L2ZlT2Zmc2V0PjxmZU1lcmdlPjxmZU1lcmdlTm9kZT48L2ZlTWVyZ2VOb2RlPjxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIj48L2ZlTWVyZ2VOb2RlPjwvZmVNZXJnZT48L2ZpbHRlcj4nO1xuICB9XG5cblxuICBldmVudEJ1cy5vbignY2FudmFzLmluaXQnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHN2ZyA9IGNvbnRleHQuc3ZnO1xuXG4gICAgX2NyZWF0ZURyb3BTaGFkb3dGaWx0ZXIoY29udGV4dC52aWV3cG9ydCk7XG4gICAgZG9tRGVsZWdhdGUuYmluZChzdmcsICdzdmcnLCAnZGJsY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gc3ZnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX2NyZWF0ZVNoYXBlT25DYW52YXMoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgZXZlbnRCdXMub24oJ2NyZWF0ZS5lbmQnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlO1xuICAgICAgX3NhdmVMYXN0Q3JlYXRlZFNoYXBlKHNoYXBlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbkNhbnZhc0NyZWF0ZS5wcm90b3R5cGUuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2VsZW1lbnRGYWN0b3J5JyxcbiAgJ2NhbnZhcycsXG4gICdkaXJlY3RFZGl0aW5nJyxcbiAgJ21vZGVsaW5nJ1xuXTtcbiIsImltcG9ydCBDYW52YXNDcmVhdGUgZnJvbSAnLi9DYW52YXNDcmVhdGUnO1xuaW1wb3J0IERpcmVjdEVkaXRpbmdNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy1kaXJlY3QtZWRpdGluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBEaXJlY3RFZGl0aW5nTW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbICdjYW52YXNDcmVhdGUnIF0sXG4gIGNhbnZhc0NyZWF0ZTogWyAndHlwZScsIENhbnZhc0NyZWF0ZSBdXG59OyIsImltcG9ydCB7XG4gIGFzc2lnbixcbiAgaXNBcnJheSxcbiAga2V5cyxcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGhhc1ByaW1hcnlNb2RpZmllclxufSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL01vdXNlJztcblxuaW1wb3J0IENPTE9SUyBmcm9tICcuLi8uLi91dGlsL0NvbG9yVXRpbCc7XG5pbXBvcnQgeyBpcywgZ2V0QnVzaW5lc3NPYmplY3QgfSBmcm9tICcuLi8uLi91dGlsL01vZGVsVXRpbCc7XG5cblxuLyoqXG4gKiBBIHByb3ZpZGVyIGZvciBwb3N0aXQgZWxlbWVudHMgY29udGV4dCBwYWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29udGV4dFBhZFByb3ZpZGVyKFxuICAgIGNvbmZpZywgaW5qZWN0b3IsIGV2ZW50QnVzLFxuICAgIGNvbnRleHRQYWQsIG1vZGVsaW5nLCBydWxlcyxcbiAgICBpbWFnZVNlbGVjdGlvbiwgdHJhbnNsYXRlKSB7XG5cbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gIGNvbnRleHRQYWQucmVnaXN0ZXJQcm92aWRlcih0aGlzKTtcblxuICB0aGlzLl9jb250ZXh0UGFkID0gY29udGV4dFBhZDtcblxuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuXG4gIHRoaXMuX3J1bGVzID0gcnVsZXM7XG4gIHRoaXMuX2ltYWdlU2VsZWN0aW9uID0gaW1hZ2VTZWxlY3Rpb247XG4gIHRoaXMuX3RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcblxuICBpZiAoY29uZmlnLmF1dG9QbGFjZSAhPT0gZmFsc2UpIHtcbiAgICB0aGlzLl9hdXRvUGxhY2UgPSBpbmplY3Rvci5nZXQoJ2F1dG9QbGFjZScsIGZhbHNlKTtcbiAgfVxuXG4gIGV2ZW50QnVzLm9uKCdjcmVhdGUuZW5kJywgMjUwLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlO1xuXG4gICAgaWYgKCFoYXNQcmltYXJ5TW9kaWZpZXIoZXZlbnQpIHx8ICFjb250ZXh0UGFkLmlzT3BlbihzaGFwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZW50cmllcyA9IGNvbnRleHRQYWQuZ2V0RW50cmllcyhzaGFwZSk7XG5cbiAgICBpZiAoZW50cmllcy5yZXBsYWNlKSB7XG4gICAgICBlbnRyaWVzLnJlcGxhY2UuYWN0aW9uLmNsaWNrKGV2ZW50LCBzaGFwZSk7XG4gICAgfVxuICB9KTtcbn1cblxuQ29udGV4dFBhZFByb3ZpZGVyLiRpbmplY3QgPSBbXG4gICdjb25maWcuY29udGV4dFBhZCcsXG4gICdpbmplY3RvcicsXG4gICdldmVudEJ1cycsXG4gICdjb250ZXh0UGFkJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ3J1bGVzJyxcbiAgJ2ltYWdlU2VsZWN0aW9uJyxcbiAgJ3RyYW5zbGF0ZSdcbl07XG5cblxuQ29udGV4dFBhZFByb3ZpZGVyLnByb3RvdHlwZS5nZXRDb250ZXh0UGFkRW50cmllcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICBjb25zdCB7XG4gICAgX3J1bGVzOiBydWxlcyxcbiAgICBfbW9kZWxpbmc6IG1vZGVsaW5nLFxuICAgIF9pbWFnZVNlbGVjdGlvbjogaW1hZ2VTZWxlY3Rpb24sXG4gICAgX3RyYW5zbGF0ZTogdHJhbnNsYXRlXG4gIH0gPSB0aGlzO1xuXG4gIGxldCBhY3Rpb25zID0ge307XG5cbiAgZnVuY3Rpb24gX3JlbW92ZUVsZW1lbnQoZSkge1xuICAgIHZhciB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIHZhciBzX2tleSA9IHVybFBhcmFtcy5nZXQoJ3Nfa2V5Jyk7XG4gICAgaWYoIHNfa2V5ID09PSBudWxsICkge1xuICAgICAgc2hlcGhlcmRBbGVydChcIlNjcmlwdCBSZXF1aXJlZFwiLCBcIllvdSBtdXN0IG9wZW4gYSBzY3JpcHQgdG8gdXBkYXRlIGl0J3Mgbm90ZXMuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB0eXBlOiBcIkRFTEVURVwiLFxuICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignWC1DU1JGLVRva2VuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpLmF0dHIoJ2NvbnRlbnQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgIHVybDogXCIvc2NyaXB0cy9cIiArIHNfa2V5ICsgXCIvZGVzdHJveV9pbWFnZS9cIiArIGVsZW1lbnQuYnVzaW5lc3NPYmplY3QuJGF0dHJzW1wia2V5XCJdLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgZmFpbHVyZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIC8vIENvbnNjaW91c2x5IG5vdCBkb2luZyBhbnl0aGluZy4gRmFpbCBzaWxlbnRseSBhbmQgY2xlYW4gdXBcbiAgICAgICAgICAvLyBsYXRlci5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIG1vZGVsaW5nLnJlbW92ZUVsZW1lbnRzKFsgZWxlbWVudCBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZSkge1xuICAgIGlmKCBlbGVtZW50LnR5cGUgPT09IFwicG9zdGl0OkltYWdlXCIgKSB7XG4gICAgICBzaGVwaGVyZENvbmZpcm0oXCJDb25maXJtIERlbGV0ZT9cIiwgXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgZWxlbWVudD9cIiwgX3JlbW92ZUVsZW1lbnQsIFtlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsaW5nLnJlbW92ZUVsZW1lbnRzKFsgZWxlbWVudCBdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDb2xvcihjb2xvcikge1xuICAgIG1vZGVsaW5nLnNldENvbG9yKGVsZW1lbnQsIGNvbG9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlbGV0ZUVudHJ5KGFjdGlvbnMpIHtcblxuICAgIC8vIGRlbGV0ZSBlbGVtZW50IGVudHJ5LCBvbmx5IHNob3cgaWYgYWxsb3dlZCBieSBydWxlc1xuICAgIGxldCBkZWxldGVBbGxvd2VkID0gcnVsZXMuYWxsb3dlZCgnZWxlbWVudHMuZGVsZXRlJywgeyBlbGVtZW50czogWyBlbGVtZW50IF0gfSk7XG5cbiAgICBpZiAoaXNBcnJheShkZWxldGVBbGxvd2VkKSkge1xuXG4gICAgICAvLyB3YXMgdGhlIGVsZW1lbnQgcmV0dXJuZWQgYXMgYSBkZWxldGlvbiBjYW5kaWRhdGU/XG4gICAgICBkZWxldGVBbGxvd2VkID0gZGVsZXRlQWxsb3dlZFswXSA9PT0gZWxlbWVudDtcbiAgICB9XG5cbiAgICBpZiAoZGVsZXRlQWxsb3dlZCkge1xuICAgICAgYXNzaWduKGFjdGlvbnMsIHtcbiAgICAgICAgJ2RlbGV0ZSc6IHtcbiAgICAgICAgICBncm91cDogJ2VkaXQnLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ2JwbW4taWNvbi10cmFzaCcsXG4gICAgICAgICAgdGl0bGU6IHRyYW5zbGF0ZSgnUmVtb3ZlJyksXG4gICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICBjbGljazogcmVtb3ZlRWxlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29sb3JpbmdFbnRyaWVzKGFjdGlvbnMpIHtcbiAgICBmb3JFYWNoKGtleXMoQ09MT1JTKSwga2V5ID0+IHtcbiAgICAgIHZhciBjb2xvciA9IENPTE9SU1trZXldO1xuXG4gICAgICBmdW5jdGlvbiBnZXRDbGFzc05hbWVzKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xuXG4gICAgICAgIGlmIChjb2xvciA9PT0gZ2V0Q29sb3IoZWxlbWVudCkpIHtcblxuICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgncGpzLWNvbG9yLWVudHJ5LWRpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ3Bqcy1jb2xvci1lbnRyeS0nICsga2V5KTtcblxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lcztcbiAgICAgIH1cblxuICAgICAgYXNzaWduKGFjdGlvbnMsIHtcbiAgICAgICAgWydjb2xvci0nICsga2V5XToge1xuICAgICAgICAgIGdyb3VwOiAnY29sb3InLFxuICAgICAgICAgIGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lcygpLFxuICAgICAgICAgIHRpdGxlOiB0cmFuc2xhdGUoJ1NldCBDb2xvcicpLFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgY2xpY2s6IChldmVudCkgPT4gc2V0Q29sb3IoY29sb3IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChlbGVtZW50LnR5cGUgPT09ICdsYWJlbCcpIHtcbiAgICByZXR1cm4gYWN0aW9ucztcbiAgfVxuXG4gIGlmIChpcyhlbGVtZW50LCAncG9zdGl0OlBvc3RpdCcpKSB7XG4gICAgY3JlYXRlQ29sb3JpbmdFbnRyaWVzKGFjdGlvbnMpO1xuICB9XG5cbiAgaWYgKGlzKGVsZW1lbnQsICdwb3N0aXQ6SW1hZ2UnKSkge1xuICAgIGFzc2lnbihhY3Rpb25zLCB7XG4gICAgICAncmVwbGFjZS5pbWFnZSc6IHtcbiAgICAgICAgZ3JvdXA6ICdyZXBsYWNlJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnYnBtbi1pY29uLXNjcmV3LXdyZW5jaCcsXG4gICAgICAgIHRpdGxlOiB0cmFuc2xhdGUoJ0NoYW5nZSBpbWFnZSBzb3VyY2UnKSxcbiAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgY2xpY2s6IChldmVudCkgPT4gaW1hZ2VTZWxlY3Rpb24uc2VsZWN0KGVsZW1lbnQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZURlbGV0ZUVudHJ5KGFjdGlvbnMpO1xuXG4gIHJldHVybiBhY3Rpb25zO1xufTtcblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGdldENvbG9yKGVsZW1lbnQpIHtcbiAgdmFyIGJvID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XG5cbiAgcmV0dXJuIGJvLmNvbG9yIHx8IGVsZW1lbnQuY29sb3I7XG59XG4iLCJpbXBvcnQgRGlyZWN0RWRpdGluZ01vZHVsZSBmcm9tICdkaWFncmFtLWpzLWRpcmVjdC1lZGl0aW5nJztcbmltcG9ydCBDb250ZXh0UGFkTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NvbnRleHQtcGFkJztcbmltcG9ydCBTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uJztcbmltcG9ydCBDb25uZWN0TW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2Nvbm5lY3QnO1xuaW1wb3J0IENyZWF0ZU1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9jcmVhdGUnO1xuaW1wb3J0IFBvcHVwTWVudU1vZHVsZSBmcm9tICcuLi9wb3B1cC1tZW51JztcblxuaW1wb3J0IENvbnRleHRQYWRQcm92aWRlciBmcm9tICcuL0NvbnRleHRQYWRQcm92aWRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBEaXJlY3RFZGl0aW5nTW9kdWxlLFxuICAgIENvbnRleHRQYWRNb2R1bGUsXG4gICAgU2VsZWN0aW9uTW9kdWxlLFxuICAgIENvbm5lY3RNb2R1bGUsXG4gICAgQ3JlYXRlTW9kdWxlLFxuICAgIFBvcHVwTWVudU1vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAnY29udGV4dFBhZFByb3ZpZGVyJyBdLFxuICBjb250ZXh0UGFkUHJvdmlkZXI6IFsgJ3R5cGUnLCBDb250ZXh0UGFkUHJvdmlkZXIgXVxufTsiLCJpbXBvcnQge1xuICBmaW5kLFxuICBmb3JFYWNoLFxuICBpc0FycmF5LFxuICBpc0RlZmluZWQsXG4gIGlzT2JqZWN0LFxuICBtYXRjaFBhdHRlcm4sXG4gIHJlZHVjZSxcbiAgaGFzLFxuICBzb3J0Qnlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG52YXIgRElTQUxMT1dFRF9QUk9QRVJUSUVTID0gW1xuICAnYm9hcmRFbGVtZW50cydcbl07XG5cbi8qKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSA8bW9kZGxlQ29weS5jYW5Db3B5UHJvcGVydGllcz4gbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBjb250ZXh0LnByb3BlcnR5TmFtZXNcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gY29udGV4dC5zb3VyY2VFbGVtZW50XG4gKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGNvbnRleHQudGFyZ2V0RWxlbWVudFxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fGJvb2xlYW59IC0gUmV0dXJuIHByb3BlcnRpZXMgdG8gYmUgY29waWVkIG9yIGZhbHNlIHRvIGRpc2FsbG93XG4gKiBjb3B5aW5nLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSA8bW9kZGxlQ29weS5jYW5Db3B5UHJvcGVydHk+IGxpc3RlbmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gY29udGV4dC5wYXJlbnRcbiAqIEBwYXJhbSB7Kn0gY29udGV4dC5wcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQucHJvcGVydHlOYW1lXG4gKlxuICogQHJldHVybnMgeyp8Ym9vbGVhbn0gLSBSZXR1cm4gY29waWVkIHByb3BlcnR5IG9yIGZhbHNlIHRvIGRpc2FsbG93XG4gKiBjb3B5aW5nLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSA8bW9kZGxlQ29weS5jYW5TZXRDb3BpZWRQcm9wZXJ0eT4gbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBjb250ZXh0LnBhcmVudFxuICogQHBhcmFtIHsqfSBjb250ZXh0LnByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dC5wcm9wZXJ0eU5hbWVcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBSZXR1cm4gZmFsc2UgdG8gZGlzYWxsb3dcbiAqIHNldHRpbmcgY29waWVkIHByb3BlcnR5LlxuICovXG5cbi8qKlxuICogVXRpbGl0eSBmb3IgY29weWluZyBtb2RlbCBwcm9wZXJ0aWVzIGZyb20gc291cmNlIGVsZW1lbnQgdG8gdGFyZ2V0IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7UG9zdGl0RmFjdG9yeX0gcG9zdGl0RmFjdG9yeVxuICogQHBhcmFtIHtQb3N0aXRNb2RkbGV9IG1vZGRsZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNb2RkbGVDb3B5KGV2ZW50QnVzLCBwb3N0aXRGYWN0b3J5LCBtb2RkbGUpIHtcbiAgdGhpcy5fcG9zdGl0RmFjdG9yeSA9IHBvc3RpdEZhY3Rvcnk7XG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX21vZGRsZSA9IG1vZGRsZTtcblxuICAvLyBjb3B5IGV4dGVuc2lvbiBlbGVtZW50cyBsYXN0XG4gIGV2ZW50QnVzLm9uKCdtb2RkbGVDb3B5LmNhbkNvcHlQcm9wZXJ0aWVzJywgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWVzID0gY29udGV4dC5wcm9wZXJ0eU5hbWVzO1xuXG4gICAgaWYgKCFwcm9wZXJ0eU5hbWVzIHx8ICFwcm9wZXJ0eU5hbWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBzb3J0QnkocHJvcGVydHlOYW1lcywgZnVuY3Rpb24ocHJvcGVydHlOYW1lKSB7XG4gICAgICByZXR1cm4gcHJvcGVydHlOYW1lID09PSAnZXh0ZW5zaW9uRWxlbWVudHMnO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBkZWZhdWx0IGNoZWNrIHdoZXRoZXIgcHJvcGVydHkgY2FuIGJlIGNvcGllZFxuICBldmVudEJ1cy5vbignbW9kZGxlQ29weS5jYW5Db3B5UHJvcGVydHknLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHBhcmVudCA9IGNvbnRleHQucGFyZW50LFxuICAgICAgICBwYXJlbnREZXNjcmlwdG9yID0gaXNPYmplY3QocGFyZW50KSAmJiBwYXJlbnQuJGRlc2NyaXB0b3IsXG4gICAgICAgIHByb3BlcnR5TmFtZSA9IGNvbnRleHQucHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKHByb3BlcnR5TmFtZSAmJiBESVNBTExPV0VEX1BST1BFUlRJRVMuaW5kZXhPZihwcm9wZXJ0eU5hbWUpICE9PSAtMSkge1xuXG4gICAgICAvLyBkaXNhbGxvdyBjb3B5aW5nIHByb3BlcnR5XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5TmFtZSAmJlxuICAgICAgcGFyZW50RGVzY3JpcHRvciAmJlxuICAgICAgIWZpbmQocGFyZW50RGVzY3JpcHRvci5wcm9wZXJ0aWVzLCBtYXRjaFBhdHRlcm4oeyBuYW1lOiBwcm9wZXJ0eU5hbWUgfSkpKSB7XG5cbiAgICAgIC8vIGRpc2FsbG93IGNvcHlpbmcgcHJvcGVydHlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuXG5Nb2RkbGVDb3B5LiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdwb3N0aXRGYWN0b3J5JyxcbiAgJ21vZGRsZSdcbl07XG5cbi8qKlxuICogQ29weSBtb2RlbCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBlbGVtZW50IHRvIHRhcmdldCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gc291cmNlRWxlbWVudFxuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSB0YXJnZXRFbGVtZW50XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwcm9wZXJ0eU5hbWVzXVxuICpcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH1cbiAqL1xuTW9kZGxlQ29weS5wcm90b3R5cGUuY29weUVsZW1lbnQgPSBmdW5jdGlvbihzb3VyY2VFbGVtZW50LCB0YXJnZXRFbGVtZW50LCBwcm9wZXJ0eU5hbWVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAocHJvcGVydHlOYW1lcyAmJiAhaXNBcnJheShwcm9wZXJ0eU5hbWVzKSkge1xuICAgIHByb3BlcnR5TmFtZXMgPSBbIHByb3BlcnR5TmFtZXMgXTtcbiAgfVxuXG4gIHByb3BlcnR5TmFtZXMgPSBwcm9wZXJ0eU5hbWVzIHx8IGdldFByb3BlcnR5TmFtZXMoc291cmNlRWxlbWVudC4kZGVzY3JpcHRvcik7XG5cbiAgdmFyIGNhbkNvcHlQcm9wZXJ0aWVzID0gdGhpcy5fZXZlbnRCdXMuZmlyZSgnbW9kZGxlQ29weS5jYW5Db3B5UHJvcGVydGllcycsIHtcbiAgICBwcm9wZXJ0eU5hbWVzOiBwcm9wZXJ0eU5hbWVzLFxuICAgIHNvdXJjZUVsZW1lbnQ6IHNvdXJjZUVsZW1lbnQsXG4gICAgdGFyZ2V0RWxlbWVudDogdGFyZ2V0RWxlbWVudFxuICB9KTtcblxuICBpZiAoY2FuQ29weVByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRhcmdldEVsZW1lbnQ7XG4gIH1cblxuICBpZiAoaXNBcnJheShjYW5Db3B5UHJvcGVydGllcykpIHtcbiAgICBwcm9wZXJ0eU5hbWVzID0gY2FuQ29weVByb3BlcnRpZXM7XG4gIH1cblxuICAvLyBjb3B5IHByb3BlcnRpZXNcbiAgZm9yRWFjaChwcm9wZXJ0eU5hbWVzLCBmdW5jdGlvbihwcm9wZXJ0eU5hbWUpIHtcbiAgICB2YXIgc291cmNlUHJvcGVydHk7XG5cbiAgICBpZiAoaGFzKHNvdXJjZUVsZW1lbnQsIHByb3BlcnR5TmFtZSkpIHtcbiAgICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlRWxlbWVudC5nZXQocHJvcGVydHlOYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgY29waWVkUHJvcGVydHkgPSBzZWxmLmNvcHlQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0RWxlbWVudCwgcHJvcGVydHlOYW1lKTtcblxuICAgIHZhciBjYW5TZXRQcm9wZXJ0eSA9IHNlbGYuX2V2ZW50QnVzLmZpcmUoJ21vZGRsZUNvcHkuY2FuU2V0Q29waWVkUHJvcGVydHknLCB7XG4gICAgICBwYXJlbnQ6IHRhcmdldEVsZW1lbnQsXG4gICAgICBwcm9wZXJ0eTogY29waWVkUHJvcGVydHksXG4gICAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZVxuICAgIH0pO1xuXG4gICAgaWYgKGNhblNldFByb3BlcnR5ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0RlZmluZWQoY29waWVkUHJvcGVydHkpKSB7XG4gICAgICB0YXJnZXRFbGVtZW50LnNldChwcm9wZXJ0eU5hbWUsIGNvcGllZFByb3BlcnR5KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXRFbGVtZW50O1xufTtcblxuLyoqXG4gKiBDb3B5IG1vZGVsIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7Kn0gcHJvcGVydHlcbiAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbk1vZGRsZUNvcHkucHJvdG90eXBlLmNvcHlQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3BlcnR5LCBwYXJlbnQsIHByb3BlcnR5TmFtZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gYWxsb3cgb3RoZXJzIHRvIGNvcHkgcHJvcGVydHlcbiAgdmFyIGNvcGllZFByb3BlcnR5ID0gdGhpcy5fZXZlbnRCdXMuZmlyZSgnbW9kZGxlQ29weS5jYW5Db3B5UHJvcGVydHknLCB7XG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lXG4gIH0pO1xuXG4gIC8vIHJldHVybiBpZiBjb3B5aW5nIGlzIE5PVCBhbGxvd2VkXG4gIGlmIChjb3BpZWRQcm9wZXJ0eSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29waWVkUHJvcGVydHkpIHtcbiAgICBpZiAoaXNPYmplY3QoY29waWVkUHJvcGVydHkpICYmIGNvcGllZFByb3BlcnR5LiR0eXBlICYmICFjb3BpZWRQcm9wZXJ0eS4kcGFyZW50KSB7XG4gICAgICBjb3BpZWRQcm9wZXJ0eS4kcGFyZW50ID0gcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBjb3BpZWRQcm9wZXJ0eTtcbiAgfVxuXG4gIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSB0aGlzLl9tb2RkbGUuZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgcHJvcGVydHlOYW1lKTtcblxuICAvLyBkbyBOT1QgY29weSBJZHMgYW5kIHJlZmVyZW5jZXNcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5pc0lkIHx8IHByb3BlcnR5RGVzY3JpcHRvci5pc1JlZmVyZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNvcHkgYXJyYXlzXG4gIGlmIChpc0FycmF5KHByb3BlcnR5KSkge1xuICAgIHJldHVybiByZWR1Y2UocHJvcGVydHksIGZ1bmN0aW9uKGNoaWxkUHJvcGVydGllcywgY2hpbGRQcm9wZXJ0eSkge1xuXG4gICAgICAvLyByZWN1cnNpb25cbiAgICAgIGNvcGllZFByb3BlcnR5ID0gc2VsZi5jb3B5UHJvcGVydHkoY2hpbGRQcm9wZXJ0eSwgcGFyZW50LCBwcm9wZXJ0eU5hbWUpO1xuXG4gICAgICAvLyBjb3B5aW5nIG1pZ2h0IE5PVCBiZSBhbGxvd2VkXG4gICAgICBpZiAoY29waWVkUHJvcGVydHkpIHtcbiAgICAgICAgY29waWVkUHJvcGVydHkuJHBhcmVudCA9IHBhcmVudDtcblxuICAgICAgICByZXR1cm4gY2hpbGRQcm9wZXJ0aWVzLmNvbmNhdChjb3BpZWRQcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGlsZFByb3BlcnRpZXM7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgLy8gY29weSBtb2RlbCBlbGVtZW50c1xuICBpZiAoaXNPYmplY3QocHJvcGVydHkpICYmIHByb3BlcnR5LiR0eXBlKSB7XG4gICAgaWYgKHRoaXMuX21vZGRsZS5nZXRFbGVtZW50RGVzY3JpcHRvcihwcm9wZXJ0eSkuaXNHZW5lcmljKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29waWVkUHJvcGVydHkgPSBzZWxmLl9wb3N0aXRGYWN0b3J5LmNyZWF0ZShwcm9wZXJ0eS4kdHlwZSk7XG5cbiAgICBjb3BpZWRQcm9wZXJ0eS4kcGFyZW50ID0gcGFyZW50O1xuXG4gICAgLy8gcmVjdXJzaW9uXG4gICAgY29waWVkUHJvcGVydHkgPSBzZWxmLmNvcHlFbGVtZW50KHByb3BlcnR5LCBjb3BpZWRQcm9wZXJ0eSk7XG5cbiAgICByZXR1cm4gY29waWVkUHJvcGVydHk7XG4gIH1cblxuICAvLyBjb3B5IHByaW1pdGl2ZSBwcm9wZXJ0aWVzXG4gIHJldHVybiBwcm9wZXJ0eTtcbn07XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvcGVydHlOYW1lcyhkZXNjcmlwdG9yLCBrZWVwRGVmYXVsdFByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIHJlZHVjZShkZXNjcmlwdG9yLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnRpZXMsIHByb3BlcnR5KSB7XG5cbiAgICBpZiAoa2VlcERlZmF1bHRQcm9wZXJ0aWVzICYmIHByb3BlcnR5LmRlZmF1bHQpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wZXJ0aWVzLmNvbmNhdChwcm9wZXJ0eS5uYW1lKTtcbiAgfSwgW10pO1xufSIsImltcG9ydCB7XG4gIGdldEJ1c2luZXNzT2JqZWN0XG59IGZyb20gJy4uLy4uL3V0aWwvTW9kZWxVdGlsJztcblxuaW1wb3J0IHtcbiAgZm9yRWFjaCxcbiAgaXNBcnJheSxcbiAgaXNVbmRlZmluZWQsXG4gIG9taXQsXG4gIHJlZHVjZVxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmZ1bmN0aW9uIGNvcHlQcm9wZXJ0aWVzKHNvdXJjZSwgdGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIGlmICghaXNBcnJheShwcm9wZXJ0aWVzKSkge1xuICAgIHByb3BlcnRpZXMgPSBbIHByb3BlcnRpZXMgXTtcbiAgfVxuXG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHNvdXJjZVtwcm9wZXJ0eV0pKSB7XG4gICAgICB0YXJnZXRbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVQcm9wZXJ0aWVzKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgaWYgKCFpc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgcHJvcGVydGllcyA9IFsgcHJvcGVydGllcyBdO1xuICB9XG5cbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIGlmIChlbGVtZW50W3Byb3BlcnR5XSkge1xuICAgICAgZGVsZXRlIGVsZW1lbnRbcHJvcGVydHldO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBMT1dfUFJJT1JJVFkgPSA3NTA7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0Q29weVBhc3RlKHBvc3RpdEZhY3RvcnksIGV2ZW50QnVzLCBtb2RkbGVDb3B5KSB7XG5cbiAgZXZlbnRCdXMub24oJ2NvcHlQYXN0ZS5jb3B5RWxlbWVudCcsIExPV19QUklPUklUWSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gY29udGV4dC5kZXNjcmlwdG9yLFxuICAgICAgICBlbGVtZW50ID0gY29udGV4dC5lbGVtZW50O1xuXG4gICAgdmFyIGJ1c2luZXNzT2JqZWN0ID0gZGVzY3JpcHRvci5vbGRCdXNpbmVzc09iamVjdCA9IGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpO1xuXG4gICAgZGVzY3JpcHRvci50eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgY29weVByb3BlcnRpZXMoYnVzaW5lc3NPYmplY3QsIGRlc2NyaXB0b3IsICduYW1lJyk7XG5cbiAgICBkZXNjcmlwdG9yLmRpID0ge307XG5cbiAgICAvLyBmaWxsIGFuZCBzdHJva2Ugd2lsbCBiZSBzZXQgdG8gRElcbiAgICBjb3B5UHJvcGVydGllcyhidXNpbmVzc09iamVjdC5kaSwgZGVzY3JpcHRvci5kaSwgW1xuICAgICAgJ2ZpbGwnLFxuICAgICAgJ3N0cm9rZSdcbiAgICBdKTtcblxuICAgIGlmIChpc0xhYmVsKGRlc2NyaXB0b3IpKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9XG5cbiAgfSk7XG5cbiAgdmFyIHJlZmVyZW5jZXM7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZXMoZGVzY3JpcHRvciwgY2FjaGUpIHtcbiAgICB2YXIgYnVzaW5lc3NPYmplY3QgPSBnZXRCdXNpbmVzc09iamVjdChkZXNjcmlwdG9yKTtcblxuICAgIC8vIGRlZmF1bHQgc2VxdWVuY2UgZmxvd3NcbiAgICBpZiAoZGVzY3JpcHRvci5kZWZhdWx0KSB7XG5cbiAgICAgIC8vIHJlbGF0aW9uc2hpcCBjYW5ub3QgYmUgcmVzb2x2ZWQgaW1tZWRpYXRlbHlcbiAgICAgIHJlZmVyZW5jZXNbIGRlc2NyaXB0b3IuZGVmYXVsdCBdID0ge1xuICAgICAgICBlbGVtZW50OiBidXNpbmVzc09iamVjdCxcbiAgICAgICAgcHJvcGVydHk6ICdkZWZhdWx0J1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZWZlcmVuY2VzID0gb21pdChyZWZlcmVuY2VzLCByZWR1Y2UocmVmZXJlbmNlcywgZnVuY3Rpb24oYXJyYXksIHJlZmVyZW5jZSwga2V5KSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHJlZmVyZW5jZS5lbGVtZW50LFxuICAgICAgICAgIHByb3BlcnR5ID0gcmVmZXJlbmNlLnByb3BlcnR5O1xuXG4gICAgICBpZiAoa2V5ID09PSBkZXNjcmlwdG9yLmlkKSB7XG4gICAgICAgIGVsZW1lbnRbIHByb3BlcnR5IF0gPSBidXNpbmVzc09iamVjdDtcblxuICAgICAgICBhcnJheS5wdXNoKGRlc2NyaXB0b3IuaWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSwgW10pKTtcbiAgfVxuXG4gIGV2ZW50QnVzLm9uKCdjb3B5UGFzdGUucGFzdGVFbGVtZW50cycsIGZ1bmN0aW9uKCkge1xuICAgIHJlZmVyZW5jZXMgPSB7fTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2NvcHlQYXN0ZS5wYXN0ZUVsZW1lbnQnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIGNhY2hlID0gY29udGV4dC5jYWNoZSxcbiAgICAgICAgZGVzY3JpcHRvciA9IGNvbnRleHQuZGVzY3JpcHRvcixcbiAgICAgICAgb2xkQnVzaW5lc3NPYmplY3QgPSBkZXNjcmlwdG9yLm9sZEJ1c2luZXNzT2JqZWN0LFxuICAgICAgICBuZXdCdXNpbmVzc09iamVjdDtcblxuICAgIC8vIGRvIE5PVCBjb3B5IGJ1c2luZXNzIG9iamVjdCBpZiBleHRlcm5hbCBsYWJlbFxuICAgIGlmIChpc0xhYmVsKGRlc2NyaXB0b3IpKSB7XG4gICAgICBkZXNjcmlwdG9yLmJ1c2luZXNzT2JqZWN0ID0gZ2V0QnVzaW5lc3NPYmplY3QoY2FjaGVbIGRlc2NyaXB0b3IubGFiZWxUYXJnZXQgXSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXdCdXNpbmVzc09iamVjdCA9IHBvc3RpdEZhY3RvcnkuY3JlYXRlKG9sZEJ1c2luZXNzT2JqZWN0LiR0eXBlKTtcblxuICAgIGRlc2NyaXB0b3IuYnVzaW5lc3NPYmplY3QgPSBtb2RkbGVDb3B5LmNvcHlFbGVtZW50KFxuICAgICAgb2xkQnVzaW5lc3NPYmplY3QsXG4gICAgICBuZXdCdXNpbmVzc09iamVjdFxuICAgICk7XG5cbiAgICAvLyByZXNvbHZlIHJlZmVyZW5jZXMgZS5nLiBkZWZhdWx0IHNlcXVlbmNlIGZsb3dcbiAgICByZXNvbHZlUmVmZXJlbmNlcyhkZXNjcmlwdG9yLCBjYWNoZSk7XG5cbiAgICBjb3B5UHJvcGVydGllcyhkZXNjcmlwdG9yLCBuZXdCdXNpbmVzc09iamVjdCwgW1xuICAgICAgJ2NvbG9yJyxcbiAgICAgICduYW1lJ1xuICAgIF0pO1xuXG4gICAgcmVtb3ZlUHJvcGVydGllcyhkZXNjcmlwdG9yLCAnb2xkQnVzaW5lc3NPYmplY3QnKTtcbiAgfSk7XG5cbn1cblxuXG5Qb3N0aXRDb3B5UGFzdGUuJGluamVjdCA9IFtcbiAgJ3Bvc3RpdEZhY3RvcnknLFxuICAnZXZlbnRCdXMnLFxuICAnbW9kZGxlQ29weSdcbl07XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc0xhYmVsKGVsZW1lbnQpIHtcbiAgcmV0dXJuICEhZWxlbWVudC5sYWJlbFRhcmdldDtcbn1cbiIsImltcG9ydCBDb3B5UGFzdGVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY29weS1wYXN0ZSc7XG5cbmltcG9ydCBQb3N0aXRDb3B5UGFzdGUgZnJvbSAnLi9Qb3N0aXRDb3B5UGFzdGUnO1xuaW1wb3J0IE1vZGRsZUNvcHkgZnJvbSAnLi9Nb2RkbGVDb3B5JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIENvcHlQYXN0ZU1vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAncG9zdGl0Q29weVBhc3RlJywgJ21vZGRsZUNvcHknIF0sXG4gIHBvc3RpdENvcHlQYXN0ZTogWyAndHlwZScsIFBvc3RpdENvcHlQYXN0ZSBdLFxuICBtb2RkbGVDb3B5OiBbICd0eXBlJywgTW9kZGxlQ29weSBdXG59O1xuIiwiaW1wb3J0IHsgZ2V0RGkgfSBmcm9tICcuLi8uLi9kcmF3L1Bvc3RpdFJlbmRlcmVyVXRpbCc7XG5pbXBvcnQgeyBnZXRCdXNpbmVzc09iamVjdCB9IGZyb20gJy4uLy4uL3V0aWwvTW9kZWxVdGlsJztcblxuaW1wb3J0IHtcbiAgZmlsdGVyLFxuICBtYXBcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgeyBzZWxmQW5kQWxsQ2hpbGRyZW4gfSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL0VsZW1lbnRzJztcblxuXG52YXIgSElHSF9QUklPUklUWSA9IDIwMDA7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvc3RpdERpT3JkZXJpbmcoZXZlbnRCdXMsIGNhbnZhcykge1xuXG4gIGV2ZW50QnVzLm9uKCdzYXZlWE1MLnN0YXJ0JywgSElHSF9QUklPUklUWSwgb3JkZXJEaSk7XG5cbiAgZnVuY3Rpb24gb3JkZXJEaSgpIHtcbiAgICB2YXIgcm9vdCA9IGNhbnZhcy5nZXRSb290RWxlbWVudCgpLFxuICAgICAgICByb290RGkgPSBnZXRCdXNpbmVzc09iamVjdChyb290KS5kaSxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIGRpRWxlbWVudHM7XG5cbiAgICBlbGVtZW50cyA9IHNlbGZBbmRBbGxDaGlsZHJlbihbIHJvb3QgXSwgZmFsc2UpO1xuXG4gICAgLy8gb25seSBwb3N0aXREaTpTaGFwZSBjYW4gYmUgZGlyZWN0IGNoaWxkcmVuIG9mIHBvc3RpdERpOlBsYW5lXG4gICAgZWxlbWVudHMgPSBmaWx0ZXIoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50ICE9PSByb290ICYmICFlbGVtZW50LmxhYmVsVGFyZ2V0O1xuICAgIH0pO1xuXG4gICAgZGlFbGVtZW50cyA9IG1hcChlbGVtZW50cywgZ2V0RGkpO1xuXG4gICAgcm9vdERpLnNldCgncGxhbmVFbGVtZW50JywgZGlFbGVtZW50cyk7XG4gIH1cbn1cblxuUG9zdGl0RGlPcmRlcmluZy4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnLCAnY2FudmFzJyBdO1xuIiwiaW1wb3J0IFBvc3RpdERpT3JkZXJpbmcgZnJvbSAnLi9Qb3N0aXREaU9yZGVyaW5nJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogW1xuICAgICdwb3N0aXREaU9yZGVyaW5nJ1xuICBdLFxuICBwb3N0aXREaU9yZGVyaW5nOiBbICd0eXBlJywgUG9zdGl0RGlPcmRlcmluZyBdXG59OyIsImltcG9ydCB7XG4gIGRvbWlmeSxcbiAgZXZlbnQgYXMgZG9tRXZlbnRcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGZpbGVSZWFkZXJcbn0gZnJvbSAnLi9GaWxlVXRpbC5qcyc7XG5cbi8qIGNvbnN0YW50cyAqL1xuY29uc3QgUE9TVElUX0lNQUdFID0gJ3Bvc3RpdDpJbWFnZSc7XG5mdW5jdGlvbiByYW5kU3RyKGxlbmd0aD01KSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNoYXJhY3RlcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICB2YXIgY2hhcmFjdGVyc0xlbmd0aCA9IGNoYXJhY3RlcnMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnNMZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgRU5UUllfUFJPVE9UWVBFID0gKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIG9iaklkOiByYW5kU3RyKCksXG4gICAgb2JqVHlwZTogUE9TVElUX0lNQUdFLFxuICAgIG9ialRpdGxlOiAnJyxcbiAgICBvYmpEZXNjcmlwdGlvbjogJycsXG4gICAgb2JqU3RhcnJlZDogZmFsc2UsXG4gICAgb2JqSGlkZGVuOiBmYWxzZSxcbiAgICBvYmpVbmtleWVkOiBmYWxzZSxcbiAgICBvYmpVbmtleWVkT3JpZ2luYWw6IGZhbHNlLFxuICAgIG9ialNyY1Vua2V5ZWQ6ICcnLFxuICAgIG9iakNyZWF0aW9uRGF0ZTogJycsXG4gICAgc291cmNlOiAnJyxcbiAgICBvYmpQb3NpdGlvblg6IG51bGwsXG4gICAgb2JqUG9zaXRpb25ZOiBudWxsLFxuICB9O1xufTtcblxuLyogY29uc3RhbnRzICovXG5cblxudmFyIHRleHQ7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEcmFnRHJvcEltYWdlcyhldmVudEJ1cywgY2FudmFzLCBtb2RlbGluZywgZWxlbWVudEZhY3RvcnksIGNyZWF0ZSwgdHJhbnNsYXRlKSB7XG5cbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuICB0aGlzLl9lbGVtZW50RmFjdG9yeSA9IGVsZW1lbnRGYWN0b3J5O1xuICB0aGlzLl9jcmVhdGUgPSBjcmVhdGU7XG4gIHRoaXMuX3RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcblxuICBjb25zdCBjcmVhdGVJbWFnZUVsZW1lbnQgPSBfY3JlYXRlSW1hZ2VFbGVtZW50LmJpbmQodGhpcyk7XG5cbiAgdGV4dCA9IHsgJ1VSTCc6IHRoaXMuX3RyYW5zbGF0ZSgnVVJMJyksXG4gICAgJ0FuIGVycm9yIG9jY3VyZWQgZHVyaW5nIHRoZSBmaWxlIHVwbG9hZCc6IHRoaXMuX3RyYW5zbGF0ZSgnQW4gZXJyb3Igb2NjdXJlZCBkdXJpbmcgdGhlIGZpbGUgdXBsb2FkJyksXG4gICAgJ1VwbG9hZCBmaWxlcyBoZXJlJzogdGhpcy5fdHJhbnNsYXRlKCdVcGxvYWQgZmlsZXMgaGVyZScpLFxuICAgICdVcGxvYWQgZnJvbSBsb2NhbCBpcyBmb3IgZGVtbyBwdXJwb3NlcyBvbmx5LiBJdCBzbG93cyBkb3duIHRoZSBwYWdlIGFuZCBpbmNyZWFzZXMgdGhlIGZpbGUgc2l6ZS4nOiB0aGlzLl90cmFuc2xhdGUoJ1VwbG9hZCBmcm9tIGxvY2FsIGlzIGZvciBkZW1vIHB1cnBvc2VzIG9ubHkuIEl0IHNsb3dzIGRvd24gdGhlIHBhZ2UgYW5kIGluY3JlYXNlcyB0aGUgZmlsZSBzaXplLicpLFxuICAgICd1cGxvYWRlZCc6IHRoaXMuX3RyYW5zbGF0ZSgndXBsb2FkZWQnKSxcbiAgICAnZmlsZSc6IHRoaXMuX3RyYW5zbGF0ZSgnZmlsZScpLFxuICAgICdmaWxlcyc6IHRoaXMuX3RyYW5zbGF0ZSgnZmlsZXMnKSxcbiAgICAnc2VsZWN0ZWQnOiB0aGlzLl90cmFuc2xhdGUoJ3NlbGVjdGVkJyksXG4gICAgJ1VwbG9hZCBhZ2Fpbic6IHRoaXMuX3RyYW5zbGF0ZSgnVXBsb2FkIGFnYWluJyksXG4gICAgJ0RyYWcgaGVyZSc6IHRoaXMuX3RyYW5zbGF0ZSgnRHJhZyBoZXJlJyksXG4gIH07XG5cbiAgRHJhZ0Ryb3BJbWFnZXMuQ1NTID0gYFxuICAgIC5wanMtdmlzaWJsZSB7XG4gICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XG4gICAgICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1xuICAgIH1cbiAgICBcbiAgICAjcGpzLWRyb3Atem9uZSB7XG4gICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICM1NTU1NTU7XG4gICAgICB6LWluZGV4OiAxO1xuICAgICAgb3BhY2l0eTogMC45O1xuICAgIH1cblxuICAgICNwanMtZHJvcC16b25lLWJvcmRlciB7XG4gICAgICBib3JkZXItcmFkaXVzOiAxMHB4IDEwcHggMTBweCAxMHB4O1xuICAgICAgLW1vei1ib3JkZXItcmFkaXVzOiAxMHB4IDEwcHggMTBweCAxMHB4O1xuICAgICAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAxMHB4IDEwcHggMTBweCAxMHB4O1xuICAgICAgYm9yZGVyOiA1cHggZGFzaGVkICMwMDAwMDA7XG4gICAgICB6LWluZGV4OiAyO1xuICAgICAgZGlzcGxheTogdGFibGU7XG4gICAgICB3aWR0aDogOTguOSU7XG4gICAgICBoZWlnaHQ6IDEwMCU7IFxuICAgIH1cblxuICAgIC5wanMtZHJvcC16b25lLXRleHQge1xuICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgZm9udC1zaXplOiAyNXB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBtYXJnaW46IDAgYXV0bztcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XG4gIH1gO1xuXG4gIERyYWdEcm9wSW1hZ2VzLkhUTUxfTUFSS1VQID0gJzxkaXYgaWQ9XCJwanMtZHJvcC16b25lXCI+JytcbiAgICAgICAgJzxkaXYgaWQ9XCJwanMtZHJvcC16b25lLWJvcmRlclwiPicrXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJwanMtZHJvcC16b25lLXRleHRcIj4nK1xuICAgICAgICAgIHRleHRbJ0RyYWcgaGVyZSddK1xuICAgICAgICAnPC9kaXY+JytcbiAgICAgICc8L2Rpdj4nK1xuICAnPC9kaXY+JztcblxuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcbiAgc3R5bGUuaW5uZXJIVE1MID0gRHJhZ0Ryb3BJbWFnZXMuQ1NTO1xuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnSEVBRCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlKTtcblxuICBjb25zdCBjYW52YXNET00gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJyk7XG5cbiAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9taWZ5KERyYWdEcm9wSW1hZ2VzLkhUTUxfTUFSS1VQKTtcbiAgY2FudmFzRE9NLmluc2VydEJlZm9yZShjb250YWluZXIsIGNhbnZhcy5maXJzdENoaWxkKTtcblxuICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdHMoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZG9tRXZlbnQuYmluZChjYW52YXNET00sICdkcmFnJywgZnVuY3Rpb24oZXYpIHtcbiAgfSwgZmFsc2UpO1xuICBkb21FdmVudC5iaW5kKGNhbnZhc0RPTSwgJ2RyYWdzdGFydCcsIGZ1bmN0aW9uKGV2KSB7XG4gIH0sIGZhbHNlKTtcbiAgZG9tRXZlbnQuYmluZChjYW52YXNET00sICdkcmFnZW5kJywgZnVuY3Rpb24oZXYpIHtcbiAgfSwgZmFsc2UpO1xuICBkb21FdmVudC5iaW5kKGNhbnZhc0RPTSwgJ2RyYWdvdmVyJywgZnVuY3Rpb24oZXYpIHtcbiAgICBwcmV2ZW50RGVmYXVsdHMoZXYpO1xuICB9LCBmYWxzZSk7XG4gIGRvbUV2ZW50LmJpbmQoY2FudmFzRE9NLCAnZHJhZ2VudGVyJywgZnVuY3Rpb24oZXYpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGpzLWRyb3Atem9uZScpLmNsYXNzTGlzdC5hZGQoJ3Bqcy12aXNpYmxlJyk7XG4gIH0sIGZhbHNlKTtcbiAgZG9tRXZlbnQuYmluZChjYW52YXNET00sJ2RyYWdsZWF2ZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bqcy1kcm9wLXpvbmUnKS5jbGFzc0xpc3QucmVtb3ZlKCdwanMtdmlzaWJsZScpO1xuICB9LCBmYWxzZSk7XG4gIGRvbUV2ZW50LmJpbmQoY2FudmFzRE9NLCAnZHJvcCcsIGFzeW5jIGZ1bmN0aW9uKGV2KSB7XG4gICAgcHJldmVudERlZmF1bHRzKGV2KTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGpzLWRyb3Atem9uZScpLmNsYXNzTGlzdC5yZW1vdmUoJ3Bqcy12aXNpYmxlJyk7XG4gICAgdXBsb2FkRmlsZXMoZXYpO1xuICB9LCBmYWxzZSk7XG5cblxuICBhc3luYyBmdW5jdGlvbiB1cGxvYWRGaWxlcyhldikge1xuICAgIGxldCB1cGxvYWREaXNwbGF5VGV4dDtcbiAgICBsZXQgdXBsb2FkUmVzdWx0T2JqID0gYXdhaXQgZmlsZVJlYWRlcihldiwgbnVsbCk7XG4gICAgbGV0IHVwbG9hZFJlc3VsdCA9IHVwbG9hZFJlc3VsdE9iai5yZXN1bHRzO1xuICAgIGxldCBlcnJvcnMgPSB1cGxvYWRSZXN1bHRPYmouZXJyb3JzO1xuICAgIGlmICghZXJyb3JzKSB7XG4gICAgICBsZXQgdXBsb2FkZWRGaWxlc0NvdW50ID0gKHVwbG9hZFJlc3VsdC5sZW5ndGgpID8gdXBsb2FkUmVzdWx0Lmxlbmd0aCA6IG51bGw7XG4gICAgICB1cGxvYWREaXNwbGF5VGV4dCA9IHVwbG9hZGVkRmlsZXNDb3VudDtcbiAgICAgIGlmIChpc05hTih1cGxvYWRlZEZpbGVzQ291bnQpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBmaWxlUGx1cmFsVGV4dCA9KyAodXBsb2FkUmVzdWx0Lmxlbmd0aCA9PSAxKSA/IHRleHRbJ2ZpbGUnXSA6IHRleHRbJ2ZpbGVzJ107XG4gICAgICAgIHVwbG9hZERpc3BsYXlUZXh0ICs9ICcgJyArIGZpbGVQbHVyYWxUZXh0ICsgJyAnICsgdGV4dFsndXBsb2FkZWQnXTtcbiAgICAgIH1cbiAgICAgIGxldCBpID0gdXBsb2FkUmVzdWx0Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY3JlYXRlSW1hZ2VFbGVtZW50KGV2LCBjb252ZXJ0VG9FbnRyeSh7IHNvdXJjZTogdXBsb2FkUmVzdWx0W2ldIH0pKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKHVwbG9hZERpc3BsYXlUZXh0KTtcblxuICAgICAgLy8gdG9wTW9kYWwuZGlzcGxheVN1Y2Nlc3NNb2RhbCh1cGxvYWREaXNwbGF5VGV4dCk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gdG9wTW9kYWwuZGlzcGxheUVycm9yTW9kYWwodGV4dFsnQW4gZXJyb3Igb2NjdXJlZCBkdXJpbmcgdGhlIGZpbGUgdXBsb2FkJ10pO1xuICAgIH1cbiAgfVxuXG5cbn1cblxuY29uc3QgY29udmVydFRvRW50cnkgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB7IC4uLkVOVFJZX1BST1RPVFlQRSgpLCAuLi5vcHRpb25zIH07XG59O1xuXG5jb25zdCBfY3JlYXRlSW1hZ2VFbGVtZW50ID0gZnVuY3Rpb24oZXZlbnQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgW107XG4gIGNvbnN0IHNoYXBlID0gdGhpcy5fZWxlbWVudEZhY3RvcnkuY3JlYXRlU2hhcGUoe1xuICAgIHR5cGU6IFBPU1RJVF9JTUFHRSxcbiAgICAuLi5vcHRpb25zLFxuICB9KTtcbiAgY29uc3QgYXR0YWNoID0gZmFsc2U7XG4gIGNvbnN0IGhpbnRzID0geyBjcmVhdGVFbGVtZW50c0JlaGF2aW9yOiBmYWxzZSB9O1xuICBjb25zdCBwb3NpdGlvbiA9IHsgeDogZXZlbnQueCArIChNYXRoLnJhbmRvbSgpICogMTAwKSwgeTogZXZlbnQueSArIChNYXRoLnJhbmRvbSgpICogMTAwKSB9O1xuICBjb25zdCB0YXJnZXQgPSB0aGlzLl9jYW52YXMuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgdGhpcy5fbW9kZWxpbmcuY3JlYXRlRWxlbWVudHMoW3NoYXBlXSwgcG9zaXRpb24sIHRhcmdldCwgYXNzaWduKHt9LCBoaW50cywge1xuICAgIGF0dGFjaDogYXR0YWNoLFxuICB9KSk7XG4gIHJldHVybiB7IGlkOiBzaGFwZS5pZCwgeDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueSwgc2hhcGUsIHdpZHRoOiBzaGFwZS53aWR0aCwgaGVpZ2h0OiBzaGFwZS5oZWlnaHQgfTtcbn07XG5cbkRyYWdEcm9wSW1hZ2VzLnByb3RvdHlwZS4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ2VsZW1lbnRGYWN0b3J5JyxcbiAgJ2NyZWF0ZScsXG4gICd0cmFuc2xhdGUnXG5dO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGZpbGVUb0RhdGFVUkwoZmlsZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3QoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltYWdlUHJvY2Vzc29yKGV2LCBmaWxlKSB7XG4gIGNvbnN0IGJhc2U2NGZpbGUgPSBhd2FpdCBmaWxlVG9EYXRhVVJMKGZpbGUpO1xuICByZXR1cm4gYmFzZTY0ZmlsZTsgLy8gcGFzc2luZyBhbnkgZXJyb3JzIHRocm91Z2hcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbGVSZWFkZXIoZXYsIGZpbGVzKSB7XG4gIGxldCB1cGxvYWRSZXN1bHQgPSBbXTtcbiAgbGV0IGVycm9ycztcbiAgbGV0IGZpbGVJdGVtcyA9IGZpbGVzO1xuICBpZiAoZXYgJiYgKGV2LmRhdGFUcmFuc2Zlci5pdGVtcyB8fCBldi5kYXRhVHJhbnNmZXIuZmlsZXMpKSB7XG4gICAgZmlsZUl0ZW1zID0gZXYuZGF0YVRyYW5zZmVyLml0ZW1zIHx8IGV2LmRhdGFUcmFuc2Zlci5maWxlcztcbiAgfVxuICB0cnkge1xuICAgIGlmIChmaWxlSXRlbXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChldiAmJiBldi5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgICAgICBpZiAoZmlsZUl0ZW1zW2ldLmtpbmQgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgdmFyIGZpbGUgPSBmaWxlSXRlbXNbaV0uZ2V0QXNGaWxlKCk7XG4gICAgICAgICAgICB1cGxvYWRSZXN1bHQucHVzaChmaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBsb2FkUmVzdWx0LnB1c2goZmlsZUl0ZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9ycyA9IGU7XG4gICAgdXBsb2FkUmVzdWx0ID0gbnVsbDtcbiAgfVxuICBjb25zdCByZXN1bHRzID0gW107XG4gIHZhciBqID0gMDtcbiAgd2hpbGUgKGogPCB1cGxvYWRSZXN1bHQubGVuZ3RoKSB7XG4gICAgY29uc3QgZmlsZUltZyA9IGF3YWl0IGltYWdlUHJvY2Vzc29yKGV2LCB1cGxvYWRSZXN1bHRbal0pO1xuICAgIHJlc3VsdHMucHVzaChmaWxlSW1nKTtcbiAgICBqKz0xO1xuICB9XG4gIHJldHVybiB7IHJlc3VsdHMsIGVycm9ycyB9O1xufVxuXG4iLCJpbXBvcnQgRHJhZ0Ryb3BJbWFnZXMgZnJvbSAnLi9EcmFnRHJvcEltYWdlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ2RyYWdEcm9wSW1hZ2VzJyBdLFxuICBkcmFnRHJvcEltYWdlczogWyAndHlwZScsIERyYWdEcm9wSW1hZ2VzXVxufTtcbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBFZGl0b3JBY3Rpb25zIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2VkaXRvci1hY3Rpb25zL0VkaXRvckFjdGlvbnMnO1xuXG5pbXBvcnQge1xuICBnZXRCQm94XG59IGZyb20gJ2RpYWdyYW0tanMvbGliL3V0aWwvRWxlbWVudHMnO1xuXG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuZCBleGVjdXRlcyBQb3N0aXQgc3BlY2lmaWMgZWRpdG9yIGFjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtJbmplY3Rvcn0gaW5qZWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0RWRpdG9yQWN0aW9ucyhpbmplY3Rvcikge1xuICBpbmplY3Rvci5pbnZva2UoRWRpdG9yQWN0aW9ucywgdGhpcyk7XG59XG5cbmluaGVyaXRzKFBvc3RpdEVkaXRvckFjdGlvbnMsIEVkaXRvckFjdGlvbnMpO1xuXG5Qb3N0aXRFZGl0b3JBY3Rpb25zLiRpbmplY3QgPSBbXG4gICdpbmplY3Rvcidcbl07XG5cbi8qKlxuICogUmVnaXN0ZXIgZGVmYXVsdCBhY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7SW5qZWN0b3J9IGluamVjdG9yXG4gKi9cblBvc3RpdEVkaXRvckFjdGlvbnMucHJvdG90eXBlLl9yZWdpc3RlckRlZmF1bHRBY3Rpb25zID0gZnVuY3Rpb24oaW5qZWN0b3IpIHtcblxuICAvLyAoMCkgaW52b2tlIHN1cGVyIG1ldGhvZFxuXG4gIEVkaXRvckFjdGlvbnMucHJvdG90eXBlLl9yZWdpc3RlckRlZmF1bHRBY3Rpb25zLmNhbGwodGhpcywgaW5qZWN0b3IpO1xuXG4gIC8vICgxKSByZXRyaWV2ZSBvcHRpb25hbCBjb21wb25lbnRzIHRvIGludGVncmF0ZSB3aXRoXG5cbiAgdmFyIGNhbnZhcyA9IGluamVjdG9yLmdldCgnY2FudmFzJywgZmFsc2UpO1xuICB2YXIgZWxlbWVudFJlZ2lzdHJ5ID0gaW5qZWN0b3IuZ2V0KCdlbGVtZW50UmVnaXN0cnknLCBmYWxzZSk7XG4gIHZhciBzZWxlY3Rpb24gPSBpbmplY3Rvci5nZXQoJ3NlbGVjdGlvbicsIGZhbHNlKTtcbiAgdmFyIHNwYWNlVG9vbCA9IGluamVjdG9yLmdldCgnc3BhY2VUb29sJywgZmFsc2UpO1xuICB2YXIgbGFzc29Ub29sID0gaW5qZWN0b3IuZ2V0KCdsYXNzb1Rvb2wnLCBmYWxzZSk7XG4gIHZhciBoYW5kVG9vbCA9IGluamVjdG9yLmdldCgnaGFuZFRvb2wnLCBmYWxzZSk7XG4gIHZhciBkaXN0cmlidXRlRWxlbWVudHMgPSBpbmplY3Rvci5nZXQoJ2Rpc3RyaWJ1dGVFbGVtZW50cycsIGZhbHNlKTtcbiAgdmFyIGFsaWduRWxlbWVudHMgPSBpbmplY3Rvci5nZXQoJ2FsaWduRWxlbWVudHMnLCBmYWxzZSk7XG4gIHZhciBkaXJlY3RFZGl0aW5nID0gaW5qZWN0b3IuZ2V0KCdkaXJlY3RFZGl0aW5nJywgZmFsc2UpO1xuICB2YXIgc2VhcmNoUGFkID0gaW5qZWN0b3IuZ2V0KCdzZWFyY2hQYWQnLCBmYWxzZSk7XG4gIHZhciBtb2RlbGluZyA9IGluamVjdG9yLmdldCgnbW9kZWxpbmcnLCBmYWxzZSk7XG5cbiAgLy8gKDIpIGNoZWNrIGNvbXBvbmVudHMgYW5kIHJlZ2lzdGVyIGFjdGlvbnNcblxuICBpZiAoY2FudmFzICYmIGVsZW1lbnRSZWdpc3RyeSAmJiBzZWxlY3Rpb24pIHtcbiAgICB0aGlzLl9yZWdpc3RlckFjdGlvbignc2VsZWN0RWxlbWVudHMnLCBmdW5jdGlvbigpIHtcblxuICAgICAgLy8gc2VsZWN0IGFsbCBlbGVtZW50cyBleGNlcHQgZm9yIHRoZSBpbnZpc2libGVcbiAgICAgIC8vIHJvb3QgZWxlbWVudFxuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gY2FudmFzLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IGVsZW1lbnRSZWdpc3RyeS5maWx0ZXIoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudCAhPT0gcm9vdEVsZW1lbnQ7XG4gICAgICB9KTtcblxuICAgICAgc2VsZWN0aW9uLnNlbGVjdChlbGVtZW50cyk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzcGFjZVRvb2wpIHtcbiAgICB0aGlzLl9yZWdpc3RlckFjdGlvbignc3BhY2VUb29sJywgZnVuY3Rpb24oKSB7XG4gICAgICBzcGFjZVRvb2wudG9nZ2xlKCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAobGFzc29Ub29sKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJBY3Rpb24oJ2xhc3NvVG9vbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgbGFzc29Ub29sLnRvZ2dsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGhhbmRUb29sKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJBY3Rpb24oJ2hhbmRUb29sJywgZnVuY3Rpb24oKSB7XG4gICAgICBoYW5kVG9vbC50b2dnbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzZWxlY3Rpb24gJiYgZGlzdHJpYnV0ZUVsZW1lbnRzKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJBY3Rpb24oJ2Rpc3RyaWJ1dGVFbGVtZW50cycsIGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gc2VsZWN0aW9uLmdldCgpLFxuICAgICAgICAgIHR5cGUgPSBvcHRzLnR5cGU7XG5cbiAgICAgIGlmIChjdXJyZW50U2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICBkaXN0cmlidXRlRWxlbWVudHMudHJpZ2dlcihjdXJyZW50U2VsZWN0aW9uLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzZWxlY3Rpb24gJiYgYWxpZ25FbGVtZW50cykge1xuICAgIHRoaXMuX3JlZ2lzdGVyQWN0aW9uKCdhbGlnbkVsZW1lbnRzJywgZnVuY3Rpb24ob3B0cykge1xuICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBzZWxlY3Rpb24uZ2V0KCksXG4gICAgICAgICAgdHlwZSA9IG9wdHMudHlwZTtcblxuICAgICAgaWYgKGN1cnJlbnRTZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgIGFsaWduRWxlbWVudHMudHJpZ2dlcihjdXJyZW50U2VsZWN0aW9uLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzZWxlY3Rpb24gJiYgbW9kZWxpbmcpIHtcbiAgICB0aGlzLl9yZWdpc3RlckFjdGlvbignc2V0Q29sb3InLCBmdW5jdGlvbihvcHRzKSB7XG4gICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IHNlbGVjdGlvbi5nZXQoKTtcblxuICAgICAgaWYgKGN1cnJlbnRTZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgIG1vZGVsaW5nLnNldENvbG9yKGN1cnJlbnRTZWxlY3Rpb24sIG9wdHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHNlbGVjdGlvbiAmJiBkaXJlY3RFZGl0aW5nKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJBY3Rpb24oJ2RpcmVjdEVkaXRpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gc2VsZWN0aW9uLmdldCgpO1xuXG4gICAgICBpZiAoY3VycmVudFNlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgZGlyZWN0RWRpdGluZy5hY3RpdmF0ZShjdXJyZW50U2VsZWN0aW9uWzBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzZWFyY2hQYWQpIHtcbiAgICB0aGlzLl9yZWdpc3RlckFjdGlvbignZmluZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VhcmNoUGFkLnRvZ2dsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGNhbnZhcyAmJiBtb2RlbGluZykge1xuICAgIHRoaXMuX3JlZ2lzdGVyQWN0aW9uKCdtb3ZlVG9PcmlnaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IGNhbnZhcy5nZXRSb290RWxlbWVudCgpLFxuICAgICAgICAgIGJvdW5kaW5nQm94O1xuXG5cbiAgICAgIHZhciBlbGVtZW50cyA9IGVsZW1lbnRSZWdpc3RyeS5maWx0ZXIoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudCAhPT0gcm9vdEVsZW1lbnQ7XG4gICAgICB9KTtcblxuICAgICAgYm91bmRpbmdCb3ggPSBnZXRCQm94KGVsZW1lbnRzKTtcblxuICAgICAgbW9kZWxpbmcubW92ZUVsZW1lbnRzKFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgeyB4OiAtYm91bmRpbmdCb3gueCwgeTogLWJvdW5kaW5nQm94LnkgfSxcbiAgICAgICAgcm9vdEVsZW1lbnRcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxufTsiLCJpbXBvcnQgRWRpdG9yQWN0aW9uc01vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9lZGl0b3ItYWN0aW9ucyc7XG5cbmltcG9ydCBQb3N0aXRFZGl0b3JBY3Rpb25zIGZyb20gJy4vUG9zdGl0RWRpdG9yQWN0aW9ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBFZGl0b3JBY3Rpb25zTW9kdWxlXG4gIF0sXG4gIGVkaXRvckFjdGlvbnM6IFsgJ3R5cGUnLCBQb3N0aXRFZGl0b3JBY3Rpb25zIF1cbn07XG4iLCJpbXBvcnQge1xuICBkb21pZnksXG4gIGV2ZW50IGFzIGRvbUV2ZW50XG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQge1xuICBmaWxlUmVhZGVyXG59IGZyb20gJy4uLy4uL3V0aWwvRmlsZVV0aWwuanMnO1xuXG5pbXBvcnQge1xuICBnZXRNb3VzZVBvc2l0aW9uXG59IGZyb20gJy4uLy4uL3V0aWwvU2NyZWVuVXRpbC5qcyc7XG5cbnZhciBMT1dfUFJJT1JJVFkgPSA1MDA7XG52YXIgdGV4dDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSW1hZ2VTZWxlY3Rpb24oY2FudmFzLCBldmVudEJ1cywgbW9kZWxpbmcsIHRyYW5zbGF0ZSkge1xuXG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbiAgdGhpcy5fdHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBldmVudEJ1cy5vbignY3JlYXRlLmVuZCcsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBoaW50cyA9IGNvbnRleHQuaGludHM7XG5cbiAgICBpZiAoaGludHMuc2VsZWN0SW1hZ2UpIHtcbiAgICAgIHNlbGYuc2VsZWN0KGVsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGV4dCA9IHsgJ1VSTCc6IHRoaXMuX3RyYW5zbGF0ZSgnVVJMJyksXG4gICAgJ0FuIGVycm9yIG9jY3VyZWQgZHVyaW5nIHRoZSBmaWxlIHVwbG9hZCc6IHRoaXMuX3RyYW5zbGF0ZSgnQW4gZXJyb3Igb2NjdXJlZCBkdXJpbmcgdGhlIGZpbGUgdXBsb2FkJyksXG4gICAgJ1VwbG9hZCBmaWxlcyBoZXJlJzogdGhpcy5fdHJhbnNsYXRlKCdVcGxvYWQgZmlsZXMgaGVyZScpLFxuICAgICdVcGxvYWQnOiB0aGlzLl90cmFuc2xhdGUoJ1VwbG9hZCcpLFxuICAgICdmaWxlJzogdGhpcy5fdHJhbnNsYXRlKCdmaWxlJyksXG4gICAgJ2ZpbGVzJzogdGhpcy5fdHJhbnNsYXRlKCdmaWxlcycpLFxuICAgICdzZWxlY3RlZCc6IHRoaXMuX3RyYW5zbGF0ZSgnc2VsZWN0ZWQnKSxcbiAgICAnVXBsb2FkIGFnYWluJzogdGhpcy5fdHJhbnNsYXRlKCdVcGxvYWQgYWdhaW4nKSxcbiAgfTtcblxuICBJbWFnZVNlbGVjdGlvbi5JTUFHRV9TRUxFQ1RJT05fTUFSS1VQID0gJzxkaXYgaWQ9XCJwanMtaW1hZ2Utc2VsZWN0aW9uLW1vZGFsXCIgY2xhc3M9XCJwanMtaW8tZGlhbG9nLWxvY2FsXCI+JytcbiAgICAnPGRpdiBjbGFzcz1cInBqcy1pby1kaWFsb2ctc2VjdGlvbiBwanMtZmlyc3RcIj4nK1xuICAgICAgJzxkaXYgaWQ9XCJwanMtaW1hZ2Utc2VsZWN0aW9uLWlucHV0LXdyYXBwZXJcIj48aW5wdXQgaWQ9XCJwanMtaW1hZ2Utc2VsZWN0aW9uLWlucHV0XCIgY2xhc3M9XCJwanMtdWktZWxlbWVudC1ib3JkZXJlZFwiPjwvaW5wdXQ+PC9kaXY+JytcbiAgICAgICc8ZGl2IGNsYXNzPVwicGpzLWxhYmVsZWQtaW5wdXRcIj4nK1xuICAgICAgJzxsYWJlbCBmb3I9XCJwanMtaW1hZ2Utc2VsZWN0aW9uLWlucHV0XCIgY2xhc3M9XCJwanMtaW5wdXQtdGV4dC1zdGF0aWNcIj48IS0tU2VhcmNoIC8gLS0+Jyt0ZXh0WydVUkwnXSsnOjwvbGFiZWw+JytcbiAgICAgICc8L2Rpdj4nK1xuICAgICc8L2RpdlwiPicrXG4gICAgJzxkaXYgY2xhc3M9XCJwanMtaW8tZGlhbG9nLXNlY3Rpb25cIj4nK1xuICAgICc8ZGl2IGNsYXNzPVwicGpzLXNlY3Rpb24tc3BhY2VyXCI+PC9kaXY+JytcbiAgICAnPGxhYmVsIGZvcj1cInBqcy1pbWFnZS11cGxvYWRcIj48ZGl2IGNsYXNzPVwicGpzLWlvLWRpYWxvZy10ZXh0LWhpbnRcIj4nK1xuICAgICAgJzxhIHN0eWxlPVwiZGlzcGxheTpibG9ja1wiPjx1bCBpZD1cInBqcy1pbWFnZS1kaWFsb2ctdGV4dC1oaW50LWxpc3RcIiBjbGFzcz1cInBqcy1ob3Jpem9udGFsXCI+JytcbiAgICAgICAgJzxsaT48ZGl2IGNsYXNzPVwicGpzLWdlbmVyYWwtaWNvbiBwanMtaW1hZ2UtZGlhbG9nLXVwbG9hZC1pY29uXCI+PC9kaXY+PC9saT4nK1xuICAgICAgICAnPGxpIGlkPVwicGpzLWltYWdlLXNlbGVjdGlvbi1maWxlcy10ZXh0LWVycm9yXCI+Jyt0ZXh0WydBbiBlcnJvciBvY2N1cmVkIGR1cmluZyB0aGUgZmlsZSB1cGxvYWQnXSsnPC9saT4nK1xuICAgICAgICAnPGxpIGlkPVwicGpzLWltYWdlLXNlbGVjdGlvbi1maWxlcy10ZXh0LXVwbG9hZFwiPicrdGV4dFsnVXBsb2FkIGZpbGVzIGhlcmUnXSsnPC9saT4nK1xuICAgICAgJzwvdWw+PC9hPicrXG4gICAgJzwvZGl2PjwvbGFiZWw+JytcbiAgICAnPGlucHV0IHR5cGU9XCJmaWxlXCIgaWQ9XCJwanMtaW1hZ2UtdXBsb2FkXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBtdWx0aXBsZS8+JytcbiAgICAnPGRpdiBjbGFzcz1cInBqcy1pby1kaWFsb2ctc2VjdGlvblwiPicrXG4gICAgJzxkaXYgY2xhc3M9XCJwanMtYnV0dG9ucyBwanMtaW1hZ2Utc2VsZWN0aW9uLXN1Ym1pdC13cmFwcGVyXCI+PGJ1dHRvbiBpZD1cInBqcy1pbWFnZS1zZWxlY3Rpb24tc3VibWl0XCI+Jyt0ZXh0WydVcGxvYWQnXSsnPC9idXR0b24+PC9kaXY+JytcbiAgICAnPC9kaXY+JytcbiAgICAnPC9kaXY+JytcbiAgJzwvZGl2Pic7XG5cbn1cblxuSW1hZ2VTZWxlY3Rpb24ucHJvdG90eXBlLl9nZXRQYXJlbnRDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NhbnZhcy5nZXRDb250YWluZXIoKTtcbn07XG5cbkltYWdlU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvbWlmeShJbWFnZVNlbGVjdGlvbi5JTUFHRV9TRUxFQ1RJT05fTUFSS1VQKTtcblxuICBjb25zdCBjYW52YXMgPSB0aGlzLl9jYW52YXMuX2NvbnRhaW5lci5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIGNhbnZhcy5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjYW52YXMuZmlyc3RDaGlsZCk7XG5cbiAgY29uc3QgbW91c2VQb3NpdGlvbiA9IGdldE1vdXNlUG9zaXRpb24obnVsbCk7XG4gIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gKCBtb3VzZVBvc2l0aW9uLnBhZ2VYIC0gZ2V0T2Zmc2V0TGVmdChjb250YWluZXIpICkgKyAncHgnO1xuICBjb250YWluZXIuc3R5bGUudG9wID0gKCBtb3VzZVBvc2l0aW9uLnBhZ2VZIC0gZ2V0T2Zmc2V0VG9wKGNvbnRhaW5lcikgKSArICdweCc7XG5cbiAgY29uc3QgaW5wdXRGaWVsZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwanMtaW1hZ2Utc2VsZWN0aW9uLWlucHV0JyksXG4gICAgICAgIHN1Ym1pdEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwanMtaW1hZ2Utc2VsZWN0aW9uLXN1Ym1pdCcpLFxuICAgICAgICBpbWFnZVVwbG9hZFRleHRFcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwanMtaW1hZ2Utc2VsZWN0aW9uLWZpbGVzLXRleHQtZXJyb3InKSxcbiAgICAgICAgaW1hZ2VVcGxvYWRUZXh0VXBsb2FkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bqcy1pbWFnZS1zZWxlY3Rpb24tZmlsZXMtdGV4dC11cGxvYWQnKSxcbiAgICAgICAgaW1hZ2VVcGxvYWRUZXh0TGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwanMtaW1hZ2UtZGlhbG9nLXRleHQtaGludC1saXN0JyksXG4gICAgICAgIGltYWdlVXBsb2FkUmVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bqcy1pbWFnZS11cGxvYWQnKSxcbiAgICAgICAgbW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGpzLWltYWdlLXNlbGVjdGlvbi1tb2RhbCcpO1xuXG4gIHZhciB1cGxvYWRUZXh0TGlzdEhlaWdodCA9IGltYWdlVXBsb2FkVGV4dExpc3Quc3R5bGUuaGVpZ2h0O1xuXG4gIHZhciBzb3VyY2UsIGZpbGVzVG9VcGxvYWQ7XG5cbiAgLy8gZm9jdXMgdXJsIGlucHV0IGZpZWxkIG9uIG1vZGFsIG9wZW5cbiAgaW5wdXRGaWVsZC5mb2N1cygpO1xuXG4gIC8vIHJlbW92ZSBtb2RhbCBieSBjbGlja2luZyBhbnl3aGVyZSBlbHNlXG4gIGNvbnN0IGNhbnZhc0RlZmF1bHRDbGljayA9IGRvbUV2ZW50LmJpbmQoY2FudmFzLCAnY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgIGlmIChtb2RhbCkge1xuXG4gICAgICAvLyBJZiB3ZSBjbGlja2VkIG9uZSBvZiBvdXIgdXBkYXRlIGJ1dHRvbnMsIGRvbid0IGNsb3NlIHRoZSBkaWFsb2cuXG4gICAgICB2YXIgaXNCdG4gPSBmYWxzZTtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kanMtY29udGV4dC1wYWQgLmVudHJ5JykuZm9yRWFjaCggZnVuY3Rpb24oYnRuKSB7XG4gICAgICAgIGlmIChidG4gPT0gZXZlbnQudGFyZ2V0ICkge1xuICAgICAgICAgIGlzQnRuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vdXNlUG9zID0gZ2V0TW91c2VQb3NpdGlvbihldik7XG5cbiAgICAgIC8vIFRoZSBkaWFsb2cgaXMgZGlzcGxhY2VkIGJ5IGEgYm94IHRoZSBzaXplIG9mIGZvbnQtc2l6ZSBvbiBlYWNoIGVkZ2UuXG4gICAgICB2YXIgZm9udFNpemUgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG1vZGFsKVsnZm9udC1zaXplJ107XG4gICAgICBmb250U2l6ZSA9IHBhcnNlSW50KGZvbnRTaXplLnN1YnN0cmluZygwLCBmb250U2l6ZS5pbmRleE9mKCdweCcpKSk7XG4gICAgICBpZiAoIWlzQnRuICYmIChcbiAgICAgICAgICAobW91c2VQb3MucGFnZVggPiBtb2RhbC5vZmZzZXRMZWZ0K2dldE9mZnNldExlZnQoY2FudmFzKSttb2RhbC5jbGllbnRXaWR0aFxuICAgICAgICAgIHx8IG1vdXNlUG9zLnBhZ2VYIDwgbW9kYWwub2Zmc2V0TGVmdCtnZXRPZmZzZXRMZWZ0KGNhbnZhcykgLSBmb250U2l6ZSlcbiAgICAgICAgICB8fCAobW91c2VQb3MucGFnZVkgPiBtb2RhbC5vZmZzZXRUb3ArZ2V0T2Zmc2V0VG9wKGNhbnZhcykrbW9kYWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgfHwgbW91c2VQb3MucGFnZVkgPCBtb2RhbC5vZmZzZXRUb3ArZ2V0T2Zmc2V0VG9wKGNhbnZhcykgLSBmb250U2l6ZSkgKSkge1xuICAgICAgICByZW1vdmVJbWFnZVNlbGVjdGlvbk1vZGFsKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuXG4gIGZvciAodmFyIGk9MDsgaSA8IGltYWdlVXBsb2FkUmVhZGVyLmxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIC8vIG9wZW4gZmlsZSBkaWFsb2dcbiAgICBkb21FdmVudC5iaW5kKGltYWdlVXBsb2FkUmVhZGVyLmxhYmVsc1tpXSwgJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIFxuICAgICAgaW1hZ2VVcGxvYWRSZWFkZXIuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChldi50eXBlLCBldikpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gYWZ0ZXIgd2Ugb3BlbiBmaWxlIGRpYWxvZ1xuICBkb21FdmVudC5iaW5kKGltYWdlVXBsb2FkUmVhZGVyLCAnY2hhbmdlJywgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgaW5wdXRGaWVsZC5kaXNhYmxlZCA9ICd0cnVlJztcblxuICAgIGxldCB1cGxvYWREaXNwbGF5VGV4dDtcblxuICAgIGxldCB1cGxvYWRSZXN1bHRPYmogPSBhd2FpdCBmaWxlUmVhZGVyKG51bGwsIGltYWdlVXBsb2FkUmVhZGVyLmZpbGVzKSxcbiAgICAgICAgdXBsb2FkUmVzdWx0ID0gdXBsb2FkUmVzdWx0T2JqLnVwbG9hZFJlc3VsdCxcbiAgICAgICAgZXJyb3JzID0gdXBsb2FkUmVzdWx0T2JqLmVycm9ycztcblxuICAgIGlmICghZXJyb3JzKSB7XG4gICAgICBsZXQgdXBsb2FkZWRGaWxlc0NvdW50ID0gKHVwbG9hZFJlc3VsdC5sZW5ndGgpID8gdXBsb2FkUmVzdWx0Lmxlbmd0aCA6IDA7XG4gICAgICB1cGxvYWREaXNwbGF5VGV4dCA9IHVwbG9hZGVkRmlsZXNDb3VudDtcblxuICAgICAgaWYgKGlzTmFOKHVwbG9hZGVkRmlsZXNDb3VudCkgPT09IGZhbHNlKSB7XG5cbiAgICAgICAgY29uc3QgZmlsZVBsdXJhbFRleHQgPSsgKHVwbG9hZFJlc3VsdC5sZW5ndGggPT0gMSkgPyB0ZXh0WydmaWxlJ10gOiB0ZXh0WydmaWxlcyddO1xuICAgICAgICB1cGxvYWREaXNwbGF5VGV4dCArPSAnICcgKyBmaWxlUGx1cmFsVGV4dCArICcgJyArIHRleHRbJ3NlbGVjdGVkJ107XG5cbiAgICAgICAgLy8gdXBsb2FkZWQgZmlsZXMgYXJlIHNhdmVkIGluIGdsb2JhbCB2YXJcbiAgICAgICAgZmlsZXNUb1VwbG9hZCA9IHVwbG9hZFJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZGlzcGxheVVwbG9hZFN0YWdpbmcodXBsb2FkRGlzcGxheVRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwbGF5RXJyb3IoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHVwbG9hZCBidXR0b25cbiAgZG9tRXZlbnQuYmluZChzdWJtaXRCdXR0b24sICdjbGljaycsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgIHNvdXJjZSA9IGZpbGVzVG9VcGxvYWQ7XG5cbiAgICAvLyAoMSkgY2FsbCBmcm9tIGNhbnZhcywgcHJvdmlkaW5nIGEgdGFyZ2V0IGVsZW1lbnRcbiAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuXG4gICAgICAvLyAoMS4xKSBsb2NhbCBmaWxlIHNlbGVjdGlvbiB1cGxvYWRcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBmIGluIGZpbGVzVG9VcGxvYWQpIHtcbiAgICAgICAgICB1cGxvYWRJbWFnZShzZWxmLCBmaWxlc1RvVXBsb2FkW2ZdKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyAoMS4yKSB1cmwgdXBsb2FkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2UgPSBpbnB1dEZpZWxkLnZhbHVlO1xuICAgICAgICB1cGxvYWRJbWFnZShzZWxmLCBzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9ldmVudEJ1cy5maXJlKCdpbWFnZVNlbGVjdGlvbi5jb21wbGV0ZScsIHsgZWxlbWVudDogZWxlbWVudCB9KTtcblxuICAgIC8vICgyKSBleHRlcm5hbCBjYWxsIHcvbyBjYW52YXMgdGFyZ2V0XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gKDIuMSBkZWZhdWx0KSBsb2NhbCBmaWxlIHNlbGVjdGlvbiBkYXRhIGlzIHVzZWRcblxuICAgICAgLy8gKDIuMikgdXJsIHVwbG9hZFxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gaW5wdXRGaWVsZC52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soc291cmNlKTtcbiAgICB9XG5cbiAgICAvLyBlcnJvciBoYW5kbGluZyBub3QgbmVjZXNzYXJ5IGFzIGRlZmF1bHQgaW1nIHdpbGwgYmUgc2hvd24gaW4gZXJyb3Igc2l0dWF0aW9uXG4gICAgcmVtb3ZlSW1hZ2VTZWxlY3Rpb25Nb2RhbCgpO1xuICB9KTtcblxuICAvLyBlbnRlciBwcmVzc2VkXG4gIGRvbUV2ZW50LmJpbmQoaW5wdXRGaWVsZCwgJ2tleXVwJywgZnVuY3Rpb24oZXN2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3VibWl0QnV0dG9uLmNsaWNrKCk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBnZXRPZmZzZXRMZWZ0KGVsZW0pIHtcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKCAhaXNOYU4oIGVsZW0ub2Zmc2V0TGVmdCApIClcbiAgICAgIHtcbiAgICAgICAgICBvZmZzZXRMZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcbiAgICAgIH1cbiAgICB9IHdoaWxlKCBlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQgKTtcbiAgICByZXR1cm4gb2Zmc2V0TGVmdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9mZnNldFRvcChlbGVtKSB7XG4gICAgdmFyIG9mZnNldFRvcCA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKCAhaXNOYU4oIGVsZW0ub2Zmc2V0VG9wICkgKVxuICAgICAge1xuICAgICAgICAgIG9mZnNldFRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICB9IHdoaWxlKCBlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQgKTtcbiAgICByZXR1cm4gb2Zmc2V0VG9wO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzcGxheVVwbG9hZFN0YWdpbmcodGV4dCkge1xuICAgIGltYWdlVXBsb2FkVGV4dExpc3Quc3R5bGUuaGVpZ2h0ID0gdXBsb2FkVGV4dExpc3RIZWlnaHQ7XG4gICAgaW1hZ2VVcGxvYWRUZXh0RXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpbWFnZVVwbG9hZFRleHRVcGxvYWQuaW5uZXJIVE1MID0gdGV4dDtcblxuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdwanMtaW1hZ2UtZGlhbG9nLXVwbG9hZC1pY29uJykubGVuZ3RoID4gMCkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncGpzLWltYWdlLWRpYWxvZy11cGxvYWQtaWNvbicpWzBdLmNsYXNzTGlzdC5yZW1vdmUoJ3Bqcy1pbWFnZS1kaWFsb2ctdXBsb2FkLWljb24tZXJyb3InKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwbGF5RXJyb3IoKSB7XG4gICAgdXBsb2FkVGV4dExpc3RIZWlnaHQgPSBpbWFnZVVwbG9hZFRleHRMaXN0LnN0eWxlLmhlaWdodDtcblxuICAgIGltYWdlVXBsb2FkVGV4dExpc3Quc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgIGltYWdlVXBsb2FkVGV4dEVycm9yLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGltYWdlVXBsb2FkVGV4dFVwbG9hZC5pbm5lckhUTUwgPSB0ZXh0WydVcGxvYWQgYWdhaW4nXTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Bqcy1pbWFnZS1kaWFsb2ctdXBsb2FkLWljb24nKVswXS5jbGFzc0xpc3QuYWRkKCdwanMtaW1hZ2UtZGlhbG9nLXVwbG9hZC1pY29uLWVycm9yJyk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiB1cGxvYWRJbWFnZShzZWxmLCBzb3VyY2UpIHtcbiAgICB2YXIgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICB2YXIgc19rZXkgPSB1cmxQYXJhbXMuZ2V0KCdzX2tleScpO1xuICAgIGlmKCBzX2tleSA9PT0gbnVsbCApIHtcbiAgICAgIHNoZXBoZXJkQWxlcnQoXCJTY3JpcHQgUmVxdWlyZWRcIiwgXCJZb3UgbXVzdCBvcGVuIGEgc2NyaXB0IGJlZm9yZSB5b3UgY2FuIHRha2Ugbm90ZXMhXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBpbWFnZSwgYmxvYjtcbiAgICAgIGlmKCBzb3VyY2Uuc3Vic3RyaW5nKDAsNCkgIT09IFwiZGF0YVwiICkge1xuICAgICAgICBibG9iID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vY29ycy1hbnl3aGVyZS1kb3QtaW5kaWVza2VkZ2UtcHJvZHVjdGlvbi53bC5yLmFwcHNwb3QuY29tLycgKyBzb3VyY2UpLnRoZW4oIHIgPT4gci5ibG9iKCkgKTtcbiAgICAgICAgYmxvYi5uYW1lID0gXCJSZW1vdGUgRmlsZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvYiA9IGltYWdlVXBsb2FkUmVhZGVyLmZpbGVzWzBdO1xuICAgICAgfVxuXG4gICAgICAvLyBVZ2x5IGJlY2F1c2Ugd2UgZXhwZWN0IHRoaXMgVVJMIHRvIGV4aXN0IG9uIHRoZSBwYWdlLlxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyBBY3RpdmVTdG9yYWdlLkRpcmVjdFVwbG9hZChcbiAgICAgICAgYmxvYixcbiAgICAgICAgZGlyZWN0X3VwbG9hZF91cmxcbiAgICAgICk7XG5cbiAgICAgIHVwbG9hZC5jcmVhdGUoZnVuY3Rpb24oZXJyb3IsIGJsb2IpIHtcbiAgICAgICAgaWYoIGVycm9yICE9PSBudWxsICkge1xuICAgICAgICAgIGlmKCBlcnJvci5zZWFyY2goXCJTdGF0dXM6IDQwM1wiKSA+PSAwICkge1xuICAgICAgICAgICAgc2hlcGhlcmRBbGVydChcIlN1YnNjcmlwdGlvbiBOZWVkZWQhXCIsIFwiWW91IG11c3QgaGF2ZSBhbiBhY3RpdmUgc3Vic2NyaXB0aW9uIHRvIHNhdmUgaW1hZ2VzISBZb3UgY2FuIHNpZ24gdXAgPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cXFwibW9kYWxcXFwiIGhyZWY9XFxcIiNzdWJzY3JpcHRpb25Nb2RhbFxcXCIgb25jbGljaz1cXFwiU2hlcGhlcmQuYWN0aXZlVG91ci5jb21wbGV0ZSgpOyAkKCcjaWRlYXRvck5vdGVzTW9kYWwnKS5tb2RhbCgnaGlkZScpO1xcXCIgZGF0YS1kZXNjcmlwdGlvbj1cXFwiU2lnbiB1cCBmb3IgaW1hZ2UgdXBsb2FkaW5nIGFuZCBvdGhlciBncmVhdCBmZWF0dWVycyFcXFwiIGRhdGEtcmVzZXQ9XFxcIiQoJyNpZGVhdG9yTm90ZXNNb2RhbCcpLm1vZGFsKFxcJ3Nob3dcXCcpO1xcXCIgc3R5bGU9XFxcImNvbG9yOiBibHVlOyBtYXJnaW4tbGVmdDogLTZweDsgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxcIj5oZXJlITwvYnV0dG9uPlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hlcGhlcmRBbGVydChcIlVwbG9hZCBFcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIGJsb2Iua2V5ICkge1xuICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUNTUkYtVG9rZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpLmF0dHIoJ2NvbnRlbnQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXJsOiBcIi9zY3JpcHRzL1wiICsgc19rZXkgKyBcIi9pbWFnZV91cmwvXCIgKyBibG9iLmtleSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgc2VsZi5fbW9kZWxpbmcudXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBkYXRhLnVybCxcbiAgICAgICAgICAgICAgICBrZXk6IGRhdGEua2V5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhaWx1cmU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgYWxlcnQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hlcGhlcmRBbGVydChcIlVua25vd24gRXJyb3JcIiwgXCJXZSd2ZSBsb2dnZWQgdGhpcyBpc3N1ZS4gIElmIGl0IGNvbnRpbnVlcywgcGxlYXNlIHJlYWNoIG91dCB0byBzdXBwb3J0LlwiKTtcbiAgICAgICAgICBCdWdzbmFnLm5vdGlmeShcIlVua25vd24gdXBsb2FkIHJlc3BvbnNlOiBcIiArIGJsb2IudG9TdHJpbmcoKSApXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUltYWdlU2VsZWN0aW9uTW9kYWwoKSB7XG4gICAgaWYgKG1vZGFsICYmIG1vZGFsLnBhcmVudE5vZGUpIHtcbiAgICAgIG1vZGFsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobW9kYWwpO1xuICAgICAgaWYgKGNhbnZhc0RlZmF1bHRDbGljaykge1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYW52YXNEZWZhdWx0Q2xpY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5JbWFnZVNlbGVjdGlvbi5wcm90b3R5cGUuJGluamVjdCA9IFtcbiAgJ2NhbnZhcycsXG4gICdldmVudEJ1cycsXG4gICdtb2RlbG5nJyxcbiAgJ3RyYW5zbGF0ZSdcbl07XG4iLCJpbXBvcnQgSW1hZ2VTZWxlY3Rpb24gZnJvbSAnLi9JbWFnZVNlbGVjdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ2ltYWdlU2VsZWN0aW9uJyBdLFxuICBpbWFnZVNlbGVjdGlvbjogWyAndHlwZScsIEltYWdlU2VsZWN0aW9uIF1cbn07XG4iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgS2V5Ym9hcmRCaW5kaW5ncyBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9rZXlib2FyZC9LZXlib2FyZEJpbmRpbmdzJztcblxuXG4vKipcbiAqIFBvc3RpdCBzcGVjaWZpYyBrZXlib2FyZCBiaW5kaW5ncy5cbiAqXG4gKiBAcGFyYW0ge0luamVjdG9yfSBpbmplY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQb3N0aXRLZXlib2FyZEJpbmRpbmdzKGluamVjdG9yKSB7XG4gIGluamVjdG9yLmludm9rZShLZXlib2FyZEJpbmRpbmdzLCB0aGlzKTtcbn1cblxuaW5oZXJpdHMoUG9zdGl0S2V5Ym9hcmRCaW5kaW5ncywgS2V5Ym9hcmRCaW5kaW5ncyk7XG5cblBvc3RpdEtleWJvYXJkQmluZGluZ3MuJGluamVjdCA9IFtcbiAgJ2luamVjdG9yJ1xuXTtcblxuXG4vKipcbiAqIFJlZ2lzdGVyIGF2YWlsYWJsZSBrZXlib2FyZCBiaW5kaW5ncy5cbiAqXG4gKiBAcGFyYW0ge0tleWJvYXJkfSBrZXlib2FyZFxuICogQHBhcmFtIHtFZGl0b3JBY3Rpb25zfSBlZGl0b3JBY3Rpb25zXG4gKi9cblBvc3RpdEtleWJvYXJkQmluZGluZ3MucHJvdG90eXBlLnJlZ2lzdGVyQmluZGluZ3MgPSBmdW5jdGlvbihrZXlib2FyZCwgZWRpdG9yQWN0aW9ucykge1xuXG4gIC8vIGluaGVyaXQgZGVmYXVsdCBiaW5kaW5nc1xuICBLZXlib2FyZEJpbmRpbmdzLnByb3RvdHlwZS5yZWdpc3RlckJpbmRpbmdzLmNhbGwodGhpcywga2V5Ym9hcmQsIGVkaXRvckFjdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBBZGQga2V5Ym9hcmQgYmluZGluZyBpZiByZXNwZWN0aXZlIGVkaXRvciBhY3Rpb25cbiAgICogaXMgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRoYXQgaW1wbGVtZW50cyB0aGUga2V5IGJpbmRpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGFjdGlvbiwgZm4pIHtcblxuICAgIGlmIChlZGl0b3JBY3Rpb25zLmlzUmVnaXN0ZXJlZChhY3Rpb24pKSB7XG4gICAgICBrZXlib2FyZC5hZGRMaXN0ZW5lcihmbik7XG4gICAgfVxuICB9XG5cbiAgLy8gc2VsZWN0IGFsbCBlbGVtZW50c1xuICAvLyBDVFJMICsgQVxuICBhZGRMaXN0ZW5lcignc2VsZWN0RWxlbWVudHMnLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgaWYgKGtleWJvYXJkLmlzS2V5KFsnYScsICdBJ10sIGV2ZW50KSAmJiBrZXlib2FyZC5pc0NtZChldmVudCkpIHtcbiAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcignc2VsZWN0RWxlbWVudHMnKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBzZWFyY2ggbGFiZWxzXG4gIC8vIENUUkwgKyBGXG4gIGFkZExpc3RlbmVyKCdmaW5kJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudDtcblxuICAgIGlmIChrZXlib2FyZC5pc0tleShbJ2YnLCAnRiddLCBldmVudCkgJiYga2V5Ym9hcmQuaXNDbWQoZXZlbnQpKSB7XG4gICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ2ZpbmQnKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBhY3RpdmF0ZSBzcGFjZSB0b29sXG4gIC8vIFNcbiAgYWRkTGlzdGVuZXIoJ3NwYWNlVG9vbCcsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBldmVudCA9IGNvbnRleHQua2V5RXZlbnQ7XG5cbiAgICBpZiAoa2V5Ym9hcmQuaGFzTW9kaWZpZXIoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleWJvYXJkLmlzS2V5KFsncycsICdTJ10sIGV2ZW50KSkge1xuICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdzcGFjZVRvb2wnKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBhY3RpdmF0ZSBsYXNzbyB0b29sXG4gIC8vIExcbiAgYWRkTGlzdGVuZXIoJ2xhc3NvVG9vbCcsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBldmVudCA9IGNvbnRleHQua2V5RXZlbnQ7XG5cbiAgICBpZiAoa2V5Ym9hcmQuaGFzTW9kaWZpZXIoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleWJvYXJkLmlzS2V5KFsnbCcsICdMJ10sIGV2ZW50KSkge1xuICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdsYXNzb1Rvb2wnKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBhY3RpdmF0ZSBoYW5kIHRvb2xcbiAgLy8gSFxuICBhZGRMaXN0ZW5lcignaGFuZFRvb2wnLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgaWYgKGtleWJvYXJkLmhhc01vZGlmaWVyKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXlib2FyZC5pc0tleShbJ2gnLCAnSCddLCBldmVudCkpIHtcbiAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcignaGFuZFRvb2wnKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBhY3RpdmF0ZSBkaXJlY3QgZWRpdGluZ1xuICAvLyBFXG4gIGFkZExpc3RlbmVyKCdkaXJlY3RFZGl0aW5nJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudDtcblxuICAgIGlmIChrZXlib2FyZC5oYXNNb2RpZmllcihldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5Ym9hcmQuaXNLZXkoWydlJywgJ0UnXSwgZXZlbnQpKSB7XG4gICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ2RpcmVjdEVkaXRpbmcnKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxufTsiLCJpbXBvcnQgS2V5Ym9hcmRNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMva2V5Ym9hcmQnO1xuXG5pbXBvcnQgUG9zdGl0S2V5Ym9hcmRCaW5kaW5ncyBmcm9tICcuL1Bvc3RpdEtleWJvYXJkQmluZGluZ3MnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgS2V5Ym9hcmRNb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFsgJ2tleWJvYXJkQmluZGluZ3MnIF0sXG4gIGtleWJvYXJkQmluZGluZ3M6IFsgJ3R5cGUnLCBQb3N0aXRLZXlib2FyZEJpbmRpbmdzIF1cbn07XG4iLCJpbXBvcnQge1xuICByZW1vdmUgYXMgc3ZnUmVtb3ZlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IHtcbiAgaXNcbn0gZnJvbSAnLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG52YXIgTUFSS0VSX0hJRERFTiA9ICdkanMtZWxlbWVudC1oaWRkZW4nLFxuICAgIE1BUktFUl9MQUJFTF9ISURERU4gPSAnZGpzLWxhYmVsLWhpZGRlbic7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGFiZWxFZGl0aW5nUHJldmlldyhcbiAgICBldmVudEJ1cywgY2FudmFzLCBlbGVtZW50UmVnaXN0cnksXG4gICAgcGF0aE1hcCkge1xuXG5cbiAgdmFyIGVsZW1lbnQsIGdmeDtcblxuICBldmVudEJ1cy5vbignZGlyZWN0RWRpdGluZy5hY3RpdmF0ZScsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgYWN0aXZlUHJvdmlkZXIgPSBjb250ZXh0LmFjdGl2ZTtcblxuICAgIGVsZW1lbnQgPSBhY3RpdmVQcm92aWRlci5lbGVtZW50LmxhYmVsIHx8IGFjdGl2ZVByb3ZpZGVyLmVsZW1lbnQ7XG5cblxuICAgIGlmIChlbGVtZW50LmxhYmVsVGFyZ2V0KSB7XG4gICAgICBjYW52YXMuYWRkTWFya2VyKGVsZW1lbnQsIE1BUktFUl9ISURERU4pO1xuICAgIH0gZWxzZSBpZiAoaXMoZWxlbWVudCwgJ3Bvc3RpdDpQb3N0aXQnKSkge1xuICAgICAgY2FudmFzLmFkZE1hcmtlcihlbGVtZW50LCBNQVJLRVJfTEFCRUxfSElEREVOKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgZXZlbnRCdXMub24oWyAnZGlyZWN0RWRpdGluZy5jb21wbGV0ZScsICdkaXJlY3RFZGl0aW5nLmNhbmNlbCcgXSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBhY3RpdmVQcm92aWRlciA9IGNvbnRleHQuYWN0aXZlO1xuXG4gICAgaWYgKGFjdGl2ZVByb3ZpZGVyKSB7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGFjdGl2ZVByb3ZpZGVyLmVsZW1lbnQubGFiZWwgfHwgYWN0aXZlUHJvdmlkZXIuZWxlbWVudCwgTUFSS0VSX0hJRERFTik7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGVsZW1lbnQsIE1BUktFUl9MQUJFTF9ISURERU4pO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ2Z4KSB7XG4gICAgICBzdmdSZW1vdmUoZ2Z4KTtcblxuICAgICAgZ2Z4ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG59XG5cbkxhYmVsRWRpdGluZ1ByZXZpZXcuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcycsXG4gICdlbGVtZW50UmVnaXN0cnknLFxuICAncGF0aE1hcCdcbl07IiwiaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZ2V0TGFiZWxcbn0gZnJvbSAnLi9MYWJlbFV0aWwnO1xuXG5pbXBvcnQgeyBpc0FueSB9IGZyb20gJy4uL21vZGVsaW5nL3V0aWwvTW9kZWxpbmdVdGlsJztcblxuaW1wb3J0IHtcbiAgZ2V0RXh0ZXJuYWxMYWJlbE1pZCxcbiAgaXNMYWJlbEV4dGVybmFsLFxuICBoYXNFeHRlcm5hbExhYmVsLFxuICBpc0xhYmVsXG59IGZyb20gJy4uLy4uL3V0aWwvTGFiZWxVdGlsJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYWJlbEVkaXRpbmdQcm92aWRlcihcbiAgICBldmVudEJ1cywgcG9zdGl0RmFjdG9yeSwgY2FudmFzLCBkaXJlY3RFZGl0aW5nLFxuICAgIG1vZGVsaW5nLCByZXNpemVIYW5kbGVzLCB0ZXh0UmVuZGVyZXIpIHtcblxuICB0aGlzLl9wb3N0aXRGYWN0b3J5ID0gcG9zdGl0RmFjdG9yeTtcbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuICB0aGlzLl90ZXh0UmVuZGVyZXIgPSB0ZXh0UmVuZGVyZXI7XG5cbiAgZGlyZWN0RWRpdGluZy5yZWdpc3RlclByb3ZpZGVyKHRoaXMpO1xuXG4gIC8vIGxpc3RlbiB0byBkYmxjbGljayBvbiBub24tcm9vdCBlbGVtZW50c1xuICBldmVudEJ1cy5vbignZWxlbWVudC5kYmxjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgYWN0aXZhdGVEaXJlY3RFZGl0KGV2ZW50LmVsZW1lbnQsIHRydWUpO1xuICB9KTtcblxuICAvLyBjb21wbGV0ZSBvbiBmb2xsb3d1cCBjYW52YXMgb3BlcmF0aW9uXG4gIGV2ZW50QnVzLm9uKFtcbiAgICAnYXV0b1BsYWNlLnN0YXJ0JyxcbiAgICAnY2FudmFzLnZpZXdib3guY2hhbmdpbmcnLFxuICAgICdkcmFnLmluaXQnLFxuICAgICdlbGVtZW50Lm1vdXNlZG93bicsXG4gICAgJ3BvcHVwTWVudS5vcGVuJ1xuICBdLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgaWYgKGRpcmVjdEVkaXRpbmcuaXNBY3RpdmUoKSkge1xuICAgICAgZGlyZWN0RWRpdGluZy5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gY2FuY2VsIG9uIGNvbW1hbmQgc3RhY2sgY2hhbmdlc1xuICBldmVudEJ1cy5vbihbICdjb21tYW5kU3RhY2suY2hhbmdlZCcgXSwgZnVuY3Rpb24oZSkge1xuICAgIGlmIChkaXJlY3RFZGl0aW5nLmlzQWN0aXZlKCkpIHtcbiAgICAgIGRpcmVjdEVkaXRpbmcuY2FuY2VsKCk7XG4gICAgfVxuICB9KTtcblxuXG4gIGV2ZW50QnVzLm9uKCdkaXJlY3RFZGl0aW5nLmFjdGl2YXRlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXNpemVIYW5kbGVzLnJlbW92ZVJlc2l6ZXJzKCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjcmVhdGUuZW5kJywgNTAwLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBlbGVtZW50ID0gY29udGV4dC5zaGFwZSxcbiAgICAgICAgY2FuRXhlY3V0ZSA9IGV2ZW50LmNvbnRleHQuY2FuRXhlY3V0ZSxcbiAgICAgICAgaXNUb3VjaCA9IGV2ZW50LmlzVG91Y2g7XG5cbiAgICAvLyBUT0RPKG5pa2t1KTogd2UgbmVlZCB0byBmaW5kIGEgd2F5IHRvIHN1cHBvcnQgdGhlXG4gICAgLy8gZGlyZWN0IGVkaXRpbmcgb24gbW9iaWxlIGRldmljZXM7IHJpZ2h0IG5vdyB0aGlzIHdpbGxcbiAgICAvLyBicmVhayBmb3IgZGVzd29ya2Zsb3dlZGl0aW5nIG9uIG1vYmlsZSBkZXZpY2VzXG4gICAgLy8gYXMgaXQgYnJlYWtzIHRoZSB1c2VyIGludGVyYWN0aW9uIHdvcmtmbG93XG5cbiAgICAvLyBUT0RPKG5yZSk6IHdlIHNob3VsZCB0ZW1wb3JhcmlseSBmb2N1cyB0aGUgZWRpdGVkIGVsZW1lbnRcbiAgICAvLyBoZXJlIGFuZCByZWxlYXNlIHRoZSBmb2N1c2VkIHZpZXdwb3J0IGFmdGVyIHRoZSBkaXJlY3QgZWRpdFxuICAgIC8vIG9wZXJhdGlvbiBpcyBmaW5pc2hlZFxuICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjYW5FeGVjdXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuaGludHMgJiYgY29udGV4dC5oaW50cy5jcmVhdGVFbGVtZW50c0JlaGF2aW9yID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFjdGl2YXRlRGlyZWN0RWRpdChlbGVtZW50KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2F1dG9QbGFjZS5lbmQnLCA1MDAsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgYWN0aXZhdGVEaXJlY3RFZGl0KGV2ZW50LnNoYXBlKTtcbiAgfSk7XG5cblxuICBmdW5jdGlvbiBhY3RpdmF0ZURpcmVjdEVkaXQoZWxlbWVudCwgZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UgfHxcbiAgICAgICAgaXNBbnkoZWxlbWVudCwgWyAncG9zdGl0OlBvc3RpdCcsICdwb3N0aXQ6R3JvdXAnLCAncG9zdGl0OlRleHRCb3gnIF0pKSB7XG5cbiAgICAgIGRpcmVjdEVkaXRpbmcuYWN0aXZhdGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbn1cblxuTGFiZWxFZGl0aW5nUHJvdmlkZXIuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ3Bvc3RpdEZhY3RvcnknLFxuICAnY2FudmFzJyxcbiAgJ2RpcmVjdEVkaXRpbmcnLFxuICAnbW9kZWxpbmcnLFxuICAncmVzaXplSGFuZGxlcycsXG4gICd0ZXh0UmVuZGVyZXInXG5dO1xuXG5cbi8qKlxuICogQWN0aXZhdGUgZGlyZWN0IGVkaXRpbmcgZm9yIGFjdGl2aXRpZXMgYW5kIHRleHQgYW5ub3RhdGlvbnMuXG4gKlxuICogQHBhcmFtICB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgYm91bmRzIChwb3NpdGlvbiBhbmQgc2l6ZSksIHRleHQgYW5kIG9wdGlvbnNcbiAqL1xuTGFiZWxFZGl0aW5nUHJvdmlkZXIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gIC8vIHRleHRcbiAgdmFyIHRleHQgPSBnZXRMYWJlbChlbGVtZW50KTtcblxuICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgdGV4dDogdGV4dFxuICB9O1xuXG4gIC8vIGJvdW5kc1xuICB2YXIgYm91bmRzID0gdGhpcy5nZXRFZGl0aW5nQkJveChlbGVtZW50KTtcblxuICBhc3NpZ24oY29udGV4dCwgYm91bmRzKTtcblxuICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIC8vIHBvc3RpdHMgYW5kIHRleHQgYm94ZXNcbiAgaWYgKGlzQW55KGVsZW1lbnQsIFsncG9zdGl0OlBvc3RpdCcsICdwb3N0aXQ6VGV4dEJveCddKSkge1xuICAgIGFzc2lnbihvcHRpb25zLCB7XG4gICAgICBjZW50ZXJWZXJ0aWNhbGx5OiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvLyBleHRlcm5hbCBsYWJlbHNcbiAgaWYgKGlzTGFiZWxFeHRlcm5hbChlbGVtZW50KSkge1xuICAgIGFzc2lnbihvcHRpb25zLCB7XG4gICAgICBhdXRvUmVzaXplOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuXG4gIGFzc2lnbihjb250ZXh0LCB7XG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9KTtcblxuICByZXR1cm4gY29udGV4dDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGVkaXRpbmcgYm91bmRpbmcgYm94IGJhc2VkIG9uIHRoZSBlbGVtZW50J3Mgc2l6ZSBhbmQgcG9zaXRpb25cbiAqXG4gKiBAcGFyYW0gIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgcG9zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgYW5kIHNpemUgKGZpeGVkIG9yIG1pbmltdW0gYW5kL29yIG1heGltdW0pXG4gKi9cbkxhYmVsRWRpdGluZ1Byb3ZpZGVyLnByb3RvdHlwZS5nZXRFZGl0aW5nQkJveCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblxuICB2YXIgdGFyZ2V0ID0gZWxlbWVudC5sYWJlbCB8fCBlbGVtZW50O1xuXG4gIHZhciBiYm94ID0gY2FudmFzLmdldEFic29sdXRlQkJveCh0YXJnZXQpO1xuXG4gIHZhciBtaWQgPSB7XG4gICAgeDogYmJveC54ICsgYmJveC53aWR0aCAvIDIsXG4gICAgeTogYmJveC55ICsgYmJveC5oZWlnaHQgLyAyXG4gIH07XG5cbiAgLy8gZGVmYXVsdCBwb3NpdGlvblxuICB2YXIgYm91bmRzID0geyB4OiBiYm94LngsIHk6IGJib3gueSB9O1xuXG4gIHZhciB6b29tID0gY2FudmFzLnpvb20oKTtcblxuICB2YXIgZGVmYXVsdFN0eWxlID0gdGhpcy5fdGV4dFJlbmRlcmVyLmdldERlZmF1bHRTdHlsZSgpLFxuICAgICAgZXh0ZXJuYWxTdHlsZSA9IHRoaXMuX3RleHRSZW5kZXJlci5nZXRFeHRlcm5hbFN0eWxlKCk7XG5cbiAgLy8gdGFrZSB6b29tIGludG8gYWNjb3VudFxuICB2YXIgZXh0ZXJuYWxGb250U2l6ZSA9IGV4dGVybmFsU3R5bGUuZm9udFNpemUgKiB6b29tLFxuICAgICAgZXh0ZXJuYWxMaW5lSGVpZ2h0ID0gZXh0ZXJuYWxTdHlsZS5saW5lSGVpZ2h0LFxuICAgICAgZGVmYXVsdEZvbnRTaXplID0gZGVmYXVsdFN0eWxlLmZvbnRTaXplICogem9vbSxcbiAgICAgIGRlZmF1bHRMaW5lSGVpZ2h0ID0gZGVmYXVsdFN0eWxlLmxpbmVIZWlnaHQ7XG5cbiAgdmFyIHN0eWxlID0ge1xuICAgIGZvbnRGYW1pbHk6IHRoaXMuX3RleHRSZW5kZXJlci5nZXREZWZhdWx0U3R5bGUoKS5mb250RmFtaWx5LFxuICAgIGZvbnRXZWlnaHQ6IHRoaXMuX3RleHRSZW5kZXJlci5nZXREZWZhdWx0U3R5bGUoKS5mb250V2VpZ2h0XG4gIH07XG5cblxuICBpZiAoaXNBbnkoZWxlbWVudCwgWyAncG9zdGl0OlBvc3RpdCcsICdwb3N0aXQ6VGV4dEJveCcsICdwb3N0aXQ6R3JvdXAnXSkpIHtcblxuICAgIGFzc2lnbihib3VuZHMsIHtcbiAgICAgIHdpZHRoOiBiYm94LndpZHRoLFxuICAgICAgaGVpZ2h0OiBiYm94LmhlaWdodFxuICAgIH0pO1xuXG4gICAgYXNzaWduKHN0eWxlLCB7XG4gICAgICBmb250U2l6ZTogZGVmYXVsdEZvbnRTaXplICsgJ3B4JyxcbiAgICAgIGxpbmVIZWlnaHQ6IGRlZmF1bHRMaW5lSGVpZ2h0LFxuICAgICAgcGFkZGluZ1RvcDogKDcgKiB6b29tKSArICdweCcsXG4gICAgICBwYWRkaW5nQm90dG9tOiAoNyAqIHpvb20pICsgJ3B4JyxcbiAgICAgIHBhZGRpbmdMZWZ0OiAoNSAqIHpvb20pICsgJ3B4JyxcbiAgICAgIHBhZGRpbmdSaWdodDogKDUgKiB6b29tKSArICdweCdcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IDkwICogem9vbSxcbiAgICAgIHBhZGRpbmdUb3AgPSA3ICogem9vbSxcbiAgICAgIHBhZGRpbmdCb3R0b20gPSA0ICogem9vbTtcblxuICAvLyBleHRlcm5hbCBsYWJlbHMgZm9yIGV2ZW50cywgZGF0YSBlbGVtZW50cywgZ2F0ZXdheXMsIGdyb3VwcyBhbmQgY29ubmVjdGlvbnNcbiAgaWYgKHRhcmdldC5sYWJlbFRhcmdldCkge1xuICAgIGFzc2lnbihib3VuZHMsIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogYmJveC5oZWlnaHQgKyBwYWRkaW5nVG9wICsgcGFkZGluZ0JvdHRvbSxcbiAgICAgIHg6IG1pZC54IC0gd2lkdGggLyAyLFxuICAgICAgeTogYmJveC55IC0gcGFkZGluZ1RvcFxuICAgIH0pO1xuXG4gICAgYXNzaWduKHN0eWxlLCB7XG4gICAgICBmb250U2l6ZTogZXh0ZXJuYWxGb250U2l6ZSArICdweCcsXG4gICAgICBsaW5lSGVpZ2h0OiBleHRlcm5hbExpbmVIZWlnaHQsXG4gICAgICBwYWRkaW5nVG9wOiBwYWRkaW5nVG9wICsgJ3B4JyxcbiAgICAgIHBhZGRpbmdCb3R0b206IHBhZGRpbmdCb3R0b20gKyAncHgnXG4gICAgfSk7XG4gIH1cblxuICAvLyBleHRlcm5hbCBsYWJlbCBub3QgeWV0IGNyZWF0ZWRcbiAgaWYgKGlzTGFiZWxFeHRlcm5hbCh0YXJnZXQpXG4gICAgICAmJiAhaGFzRXh0ZXJuYWxMYWJlbCh0YXJnZXQpXG4gICAgICAmJiAhaXNMYWJlbCh0YXJnZXQpKSB7XG5cbiAgICB2YXIgZXh0ZXJuYWxMYWJlbE1pZCA9IGdldEV4dGVybmFsTGFiZWxNaWQoZWxlbWVudCk7XG5cbiAgICB2YXIgYWJzb2x1dGVCQm94ID0gY2FudmFzLmdldEFic29sdXRlQkJveCh7XG4gICAgICB4OiBleHRlcm5hbExhYmVsTWlkLngsXG4gICAgICB5OiBleHRlcm5hbExhYmVsTWlkLnksXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH0pO1xuXG4gICAgdmFyIGhlaWdodCA9IGV4dGVybmFsRm9udFNpemUgKyBwYWRkaW5nVG9wICsgcGFkZGluZ0JvdHRvbTtcblxuICAgIGFzc2lnbihib3VuZHMsIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgeDogYWJzb2x1dGVCQm94LnggLSB3aWR0aCAvIDIsXG4gICAgICB5OiBhYnNvbHV0ZUJCb3gueSAtIGhlaWdodCAvIDJcbiAgICB9KTtcblxuICAgIGFzc2lnbihzdHlsZSwge1xuICAgICAgZm9udFNpemU6IGV4dGVybmFsRm9udFNpemUgKyAncHgnLFxuICAgICAgbGluZUhlaWdodDogZXh0ZXJuYWxMaW5lSGVpZ2h0LFxuICAgICAgcGFkZGluZ1RvcDogcGFkZGluZ1RvcCArICdweCcsXG4gICAgICBwYWRkaW5nQm90dG9tOiBwYWRkaW5nQm90dG9tICsgJ3B4J1xuICAgIH0pO1xuICB9XG5cblxuICAvLyB0cmFuc3BhcmVudCBlZGl0IGJveFxuICBpZiAoaXNBbnkoZWxlbWVudCwgWyAncG9zdGl0OlBvc3RpdCcgXSkpIHtcbiAgICBhc3NpZ24oc3R5bGUsIHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHsgYm91bmRzOiBib3VuZHMsIHN0eWxlOiBzdHlsZSB9O1xufTtcblxuXG5MYWJlbEVkaXRpbmdQcm92aWRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxlbWVudCwgbmV3TGFiZWwpIHtcblxuICBpZiAoaXNFbXB0eVRleHQobmV3TGFiZWwpKSB7XG4gICAgbmV3TGFiZWwgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5fbW9kZWxpbmcudXBkYXRlTGFiZWwoZWxlbWVudCwgbmV3TGFiZWwpO1xufTtcblxuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc0VtcHR5VGV4dChsYWJlbCkge1xuICByZXR1cm4gIWxhYmVsIHx8ICFsYWJlbC50cmltKCk7XG59IiwiaW1wb3J0IHsgaXNBbnkgfSBmcm9tICcuLi9tb2RlbGluZy91dGlsL01vZGVsaW5nVXRpbCc7XG5cbmZ1bmN0aW9uIGdldExhYmVsQXR0cihzZW1hbnRpYykge1xuICBpZiAoaXNBbnkoc2VtYW50aWMsIFsgJ3Bvc3RpdDpQb3N0aXQnLCAncG9zdGl0OlRleHRCb3gnLCAncG9zdGl0Okdyb3VwJyBdKSkge1xuICAgIHJldHVybiAnbmFtZSc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExhYmVsKGVsZW1lbnQpIHtcbiAgdmFyIHNlbWFudGljID0gZWxlbWVudC5idXNpbmVzc09iamVjdCxcbiAgICAgIGF0dHIgPSBnZXRMYWJlbEF0dHIoc2VtYW50aWMpO1xuXG4gIGlmIChhdHRyKSB7XG4gICAgcmV0dXJuIHNlbWFudGljW2F0dHJdIHx8ICcnO1xuICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNldExhYmVsKGVsZW1lbnQsIHRleHQpIHtcbiAgdmFyIHNlbWFudGljID0gZWxlbWVudC5idXNpbmVzc09iamVjdCxcbiAgICAgIGF0dHIgPSBnZXRMYWJlbEF0dHIoc2VtYW50aWMpO1xuXG4gIGlmIChhdHRyKSB7XG4gICAgc2VtYW50aWNbYXR0cl0gPSB0ZXh0O1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59IiwiaW1wb3J0IHtcbiAgc2V0TGFiZWwsXG4gIGdldExhYmVsXG59IGZyb20gJy4uL0xhYmVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldEV4dGVybmFsTGFiZWxNaWQsXG4gIGlzTGFiZWxFeHRlcm5hbCxcbiAgaGFzRXh0ZXJuYWxMYWJlbCxcbiAgaXNMYWJlbFxufSBmcm9tICcuLi8uLi8uLi91dGlsL0xhYmVsVXRpbCc7XG5cbnZhciBOVUxMX0RJTUVOU0lPTlMgPSB7XG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDBcbn07XG5cblxuLyoqXG4gKiBBIGhhbmRsZXIgdGhhdCB1cGRhdGVzIHRoZSB0ZXh0IG9mIGEgcG9zdGl0IGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFVwZGF0ZUxhYmVsSGFuZGxlcihtb2RlbGluZywgdGV4dFJlbmRlcmVyKSB7XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGFiZWwgYW5kIHJldHVybiB0aGUgY2hhbmdlZCBlbGVtZW50cy5cbiAgICpcbiAgICogRWxlbWVudCBwYXJhbWV0ZXIgY2FuIGJlIGxhYmVsIGl0c2VsZiBvciBjb25uZWN0aW9uIChpLmUuIHNlcXVlbmNlIGZsb3cpLlxuICAgKlxuICAgKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqL1xuICBmdW5jdGlvbiBzZXRUZXh0KGVsZW1lbnQsIHRleHQpIHtcblxuICAgIC8vIGV4dGVybmFsIGxhYmVsIGlmIHByZXNlbnRcbiAgICB2YXIgbGFiZWwgPSBlbGVtZW50LmxhYmVsIHx8IGVsZW1lbnQ7XG5cbiAgICB2YXIgbGFiZWxUYXJnZXQgPSBlbGVtZW50LmxhYmVsVGFyZ2V0IHx8IGVsZW1lbnQ7XG5cbiAgICBzZXRMYWJlbChsYWJlbCwgdGV4dCwgbGFiZWxUYXJnZXQgIT09IGxhYmVsKTtcblxuICAgIHJldHVybiBbIGxhYmVsLCBsYWJlbFRhcmdldCBdO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlRXhlY3V0ZShjdHgpIHtcbiAgICB2YXIgZWxlbWVudCA9IGN0eC5lbGVtZW50LFxuICAgICAgICBidXNpbmVzc09iamVjdCA9IGVsZW1lbnQuYnVzaW5lc3NPYmplY3QsXG4gICAgICAgIG5ld0xhYmVsID0gY3R4Lm5ld0xhYmVsO1xuXG4gICAgaWYgKCFpc0xhYmVsKGVsZW1lbnQpXG4gICAgICAgICYmIGlzTGFiZWxFeHRlcm5hbChlbGVtZW50KVxuICAgICAgICAmJiAhaGFzRXh0ZXJuYWxMYWJlbChlbGVtZW50KVxuICAgICAgICAmJiAhaXNFbXB0eVRleHQobmV3TGFiZWwpKSB7XG5cbiAgICAgIC8vIGNyZWF0ZSBsYWJlbFxuICAgICAgdmFyIHBhZGRpbmdUb3AgPSA3O1xuXG4gICAgICB2YXIgbGFiZWxDZW50ZXIgPSBnZXRFeHRlcm5hbExhYmVsTWlkKGVsZW1lbnQpO1xuXG4gICAgICBsYWJlbENlbnRlciA9IHtcbiAgICAgICAgeDogbGFiZWxDZW50ZXIueCxcbiAgICAgICAgeTogbGFiZWxDZW50ZXIueSArIHBhZGRpbmdUb3BcbiAgICAgIH07XG5cbiAgICAgIG1vZGVsaW5nLmNyZWF0ZUxhYmVsKGVsZW1lbnQsIGxhYmVsQ2VudGVyLCB7XG4gICAgICAgIGlkOiBidXNpbmVzc09iamVjdC5pZCArICdfbGFiZWwnLFxuICAgICAgICBidXNpbmVzc09iamVjdDogYnVzaW5lc3NPYmplY3RcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4ZWN1dGUoY3R4KSB7XG4gICAgY3R4Lm9sZExhYmVsID0gZ2V0TGFiZWwoY3R4LmVsZW1lbnQpO1xuICAgIHJldHVybiBzZXRUZXh0KGN0eC5lbGVtZW50LCBjdHgubmV3TGFiZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJ0KGN0eCkge1xuICAgIHJldHVybiBzZXRUZXh0KGN0eC5lbGVtZW50LCBjdHgub2xkTGFiZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zdEV4ZWN1dGUoY3R4KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBjdHguZWxlbWVudCxcbiAgICAgICAgbGFiZWwgPSBlbGVtZW50LmxhYmVsIHx8IGVsZW1lbnQsXG4gICAgICAgIG5ld0xhYmVsID0gY3R4Lm5ld0xhYmVsLFxuICAgICAgICBuZXdCb3VuZHMgPSBjdHgubmV3Qm91bmRzLFxuICAgICAgICBoaW50cyA9IGN0eC5oaW50cyB8fCB7fTtcblxuICAgIC8vIGlnbm9yZSBpbnRlcm5hbCBsYWJlbHMgZm9yIGVsZW1lbnRzXG4gICAgaWYgKCFpc0xhYmVsKGxhYmVsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0xhYmVsKGxhYmVsKSAmJiBpc0VtcHR5VGV4dChuZXdMYWJlbCkpIHtcblxuICAgICAgaWYgKGhpbnRzLnJlbW92ZVNoYXBlICE9PSBmYWxzZSkge1xuICAgICAgICBtb2RlbGluZy5yZW1vdmVTaGFwZShsYWJlbCwgeyB1bnNldExhYmVsOiBmYWxzZSB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gZ2V0TGFiZWwobGFiZWwpO1xuXG4gICAgLy8gcmVzaXplIGVsZW1lbnQgYmFzZWQgb24gbGFiZWwgX29yXyBwcmUtZGVmaW5lZCBib3VuZHNcbiAgICBpZiAodHlwZW9mIG5ld0JvdW5kcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5ld0JvdW5kcyA9IHRleHRSZW5kZXJlci5nZXRFeHRlcm5hbExhYmVsQm91bmRzKGxhYmVsLCB0ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBzZXR0aW5nIG5ld0JvdW5kcyB0byBmYWxzZSBvciBfbnVsbF8gd2lsbFxuICAgIC8vIGRpc2FibGUgdGhlIHBvc3RFeGVjdXRlIHJlc2l6ZSBvcGVyYXRpb25cbiAgICBpZiAobmV3Qm91bmRzKSB7XG4gICAgICBtb2RlbGluZy5yZXNpemVTaGFwZShsYWJlbCwgbmV3Qm91bmRzLCBOVUxMX0RJTUVOU0lPTlMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFQSVxuXG4gIHRoaXMucHJlRXhlY3V0ZSA9IHByZUV4ZWN1dGU7XG4gIHRoaXMuZXhlY3V0ZSA9IGV4ZWN1dGU7XG4gIHRoaXMucmV2ZXJ0ID0gcmV2ZXJ0O1xuICB0aGlzLnBvc3RFeGVjdXRlID0gcG9zdEV4ZWN1dGU7XG59XG5cblVwZGF0ZUxhYmVsSGFuZGxlci4kaW5qZWN0ID0gW1xuICAnbW9kZWxpbmcnLFxuICAndGV4dFJlbmRlcmVyJ1xuXTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzRW1wdHlUZXh0KGxhYmVsKSB7XG4gIHJldHVybiAhbGFiZWwgfHwgIWxhYmVsLnRyaW0oKTtcbn0iLCJpbXBvcnQgQ2hhbmdlU3VwcG9ydE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9jaGFuZ2Utc3VwcG9ydCc7XG5pbXBvcnQgUmVzaXplTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3Jlc2l6ZSc7XG5pbXBvcnQgRGlyZWN0RWRpdGluZ01vZHVsZSBmcm9tICdkaWFncmFtLWpzLWRpcmVjdC1lZGl0aW5nJztcblxuaW1wb3J0IExhYmVsRWRpdGluZ1Byb3ZpZGVyIGZyb20gJy4vTGFiZWxFZGl0aW5nUHJvdmlkZXInO1xuaW1wb3J0IExhYmVsRWRpdGluZ1ByZXZpZXcgZnJvbSAnLi9MYWJlbEVkaXRpbmdQcmV2aWV3JztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgQ2hhbmdlU3VwcG9ydE1vZHVsZSxcbiAgICBSZXNpemVNb2R1bGUsXG4gICAgRGlyZWN0RWRpdGluZ01vZHVsZVxuICBdLFxuICBfX2luaXRfXzogW1xuICAgICdsYWJlbEVkaXRpbmdQcm92aWRlcicsXG4gICAgJ2xhYmVsRWRpdGluZ1ByZXZpZXcnXG4gIF0sXG4gIGxhYmVsRWRpdGluZ1Byb3ZpZGVyOiBbICd0eXBlJywgTGFiZWxFZGl0aW5nUHJvdmlkZXIgXSxcbiAgbGFiZWxFZGl0aW5nUHJldmlldzogWyAndHlwZScsIExhYmVsRWRpdGluZ1ByZXZpZXcgXVxufTtcbiIsImltcG9ydCB7XG4gIGFzc2lnbixcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCB7IGlzIH0gZnJvbSAnLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG5pbXBvcnQgQmFzZUVsZW1lbnRGYWN0b3J5IGZyb20gJ2RpYWdyYW0tanMvbGliL2NvcmUvRWxlbWVudEZhY3RvcnknO1xuXG5pbXBvcnQge1xuICBERUZBVUxUX0xBQkVMX1NJWkVcbn0gZnJvbSAnLi4vLi4vdXRpbC9MYWJlbFV0aWwnO1xuXG5cbi8qKlxuICogQSBwb3N0aXQtYXdhcmUgZmFjdG9yeSBmb3IgZGlhZ3JhbS1qcyBzaGFwZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRWxlbWVudEZhY3RvcnkocG9zdGl0RmFjdG9yeSwgbW9kZGxlLCB0cmFuc2xhdGUpIHtcbiAgQmFzZUVsZW1lbnRGYWN0b3J5LmNhbGwodGhpcyk7XG5cbiAgdGhpcy5fcG9zdGl0RmFjdG9yeSA9IHBvc3RpdEZhY3Rvcnk7XG4gIHRoaXMuX21vZGRsZSA9IG1vZGRsZTtcbiAgdGhpcy5fdHJhbnNsYXRlID0gdHJhbnNsYXRlO1xufVxuXG5pbmhlcml0cyhFbGVtZW50RmFjdG9yeSwgQmFzZUVsZW1lbnRGYWN0b3J5KTtcblxuRWxlbWVudEZhY3RvcnkuJGluamVjdCA9IFtcbiAgJ3Bvc3RpdEZhY3RvcnknLFxuICAnbW9kZGxlJyxcbiAgJ3RyYW5zbGF0ZSdcbl07XG5cbkVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5iYXNlQ3JlYXRlID0gQmFzZUVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGU7XG5cbkVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihlbGVtZW50VHlwZSwgYXR0cnMpIHtcblxuICAvLyBubyBzcGVjaWFsIG1hZ2ljIGZvciBsYWJlbHMsXG4gIC8vIHdlIGFzc3VtZSB0aGVpciBidXNpbmVzc09iamVjdHMgaGF2ZSBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAvLyBhbmQgd2lyZWQgdmlhIGF0dHJzXG4gIGlmIChlbGVtZW50VHlwZSA9PT0gJ2xhYmVsJykge1xuICAgIHJldHVybiB0aGlzLmJhc2VDcmVhdGUoZWxlbWVudFR5cGUsIGFzc2lnbih7IHR5cGU6ICdsYWJlbCcgfSwgREVGQVVMVF9MQUJFTF9TSVpFLCBhdHRycykpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3JlYXRlUG9zdGl0RWxlbWVudChlbGVtZW50VHlwZSwgYXR0cnMpO1xufTtcblxuRWxlbWVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVBvc3RpdEVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50VHlwZSwgYXR0cnMpIHtcbiAgdmFyIHNpemUsXG4gICAgICB0cmFuc2xhdGUgPSB0aGlzLl90cmFuc2xhdGU7XG5cbiAgYXR0cnMgPSBhdHRycyB8fCB7fTtcblxuICB2YXIgYnVzaW5lc3NPYmplY3QgPSBhdHRycy5idXNpbmVzc09iamVjdDtcblxuICBpZiAoIWJ1c2luZXNzT2JqZWN0KSB7XG4gICAgaWYgKCFhdHRycy50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnNsYXRlKCdubyBzaGFwZSB0eXBlIHNwZWNpZmllZCcpKTtcbiAgICB9XG5cbiAgICBidXNpbmVzc09iamVjdCA9IHRoaXMuX3Bvc3RpdEZhY3RvcnkuY3JlYXRlKGF0dHJzLnR5cGUpO1xuICB9XG5cbiAgaWYgKCFidXNpbmVzc09iamVjdC5kaSkge1xuICAgIGlmIChlbGVtZW50VHlwZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICBidXNpbmVzc09iamVjdC5kaSA9IHRoaXMuX3Bvc3RpdEZhY3RvcnkuY3JlYXRlRGlQbGFuZShidXNpbmVzc09iamVjdCwgW10sIHtcbiAgICAgICAgaWQ6IGJ1c2luZXNzT2JqZWN0LmlkICsgJ19kaSdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBidXNpbmVzc09iamVjdC5kaSA9IHRoaXMuX3Bvc3RpdEZhY3RvcnkuY3JlYXRlRGlTaGFwZShidXNpbmVzc09iamVjdCwge30sIHtcbiAgICAgICAgaWQ6IGJ1c2luZXNzT2JqZWN0LmlkICsgJ19kaSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpcyhidXNpbmVzc09iamVjdCwgJ3Bvc3RpdDpHcm91cCcpKSB7XG4gICAgYXR0cnMgPSBhc3NpZ24oe1xuICAgICAgaXNGcmFtZTogdHJ1ZVxuICAgIH0sIGF0dHJzKTtcbiAgfVxuXG4gIGlmIChhdHRycy5kaSkge1xuICAgIGFzc2lnbihidXNpbmVzc09iamVjdC5kaSwgYXR0cnMuZGkpO1xuXG4gICAgZGVsZXRlIGF0dHJzLmRpO1xuICB9XG5cbiAgYXBwbHlBdHRyaWJ1dGVzKGJ1c2luZXNzT2JqZWN0LCBhdHRycywgW1xuICAgICdwcm9jZXNzUmVmJyxcbiAgICAnaXNJbnRlcnJ1cHRpbmcnLFxuICAgICdhc3NvY2lhdGlvbkRpcmVjdGlvbicsXG4gICAgJ2lzRm9yQ29tcGVuc2F0aW9uJ1xuICBdKTtcblxuICBzaXplID0gdGhpcy5fZ2V0RGVmYXVsdFNpemUoYnVzaW5lc3NPYmplY3QpO1xuXG4gIGF0dHJzID0gYXNzaWduKHtcbiAgICBidXNpbmVzc09iamVjdDogYnVzaW5lc3NPYmplY3QsXG4gICAgaWQ6IGJ1c2luZXNzT2JqZWN0LmlkXG4gIH0sIHNpemUsIGF0dHJzKTtcblxuICByZXR1cm4gdGhpcy5iYXNlQ3JlYXRlKGVsZW1lbnRUeXBlLCBhdHRycyk7XG59O1xuXG5cbkVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5fZ2V0RGVmYXVsdFNpemUgPSBmdW5jdGlvbihzZW1hbnRpYykge1xuICBpZiAoaXMoc2VtYW50aWMsICdwb3N0aXQ6UG9zdGl0JykpIHtcbiAgICByZXR1cm4geyB3aWR0aDogMTUwLCBoZWlnaHQ6IDE1MCB9O1xuICB9XG5cbiAgaWYgKGlzKHNlbWFudGljLCAncG9zdGl0Okdyb3VwJykpIHtcbiAgICByZXR1cm4geyB3aWR0aDogMzAwLCBoZWlnaHQ6IDMwMCB9O1xuICB9XG5cbiAgaWYgKGlzKHNlbWFudGljLCAncG9zdGl0OkltYWdlJykpIHtcbiAgICByZXR1cm4geyB3aWR0aDogMzAwLCBoZWlnaHQ6IDMwMCB9O1xuICB9XG5cbiAgcmV0dXJuIHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiA4MCB9O1xufTtcblxuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEFwcGx5IGF0dHJpYnV0ZXMgZnJvbSBhIG1hcCB0byB0aGUgZ2l2ZW4gZWxlbWVudCxcbiAqIHJlbW92ZSBhdHRyaWJ1dGUgZnJvbSB0aGUgbWFwIG9uIGFwcGxpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7QmFzZX0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIChpbi9vdXQgbWFwIG9mIGF0dHJpYnV0ZXMpXG4gKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IGF0dHJpYnV0ZU5hbWVzIG5hbWUgb2YgYXR0cmlidXRlcyB0byBhcHBseVxuICovXG5mdW5jdGlvbiBhcHBseUF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cnMsIGF0dHJpYnV0ZU5hbWVzKSB7XG5cbiAgZm9yRWFjaChhdHRyaWJ1dGVOYW1lcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBpZiAoYXR0cnNbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFwcGx5QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJzLCBwcm9wZXJ0eSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseSBuYW1lZCBwcm9wZXJ0eSB0byBlbGVtZW50IGFuZCBkcmFpbiBpdCBmcm9tIHRoZSBhdHRyc1xuICogY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Jhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyAoaW4vb3V0IG1hcCBvZiBhdHRyaWJ1dGVzKVxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgdG8gYXBwbHlcbiAqL1xuZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cnMsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgZWxlbWVudFthdHRyaWJ1dGVOYW1lXSA9IGF0dHJzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gIGRlbGV0ZSBhdHRyc1thdHRyaWJ1dGVOYW1lXTtcbn0iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgQmFzZU1vZGVsaW5nIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vZGVsaW5nL01vZGVsaW5nJztcblxuaW1wb3J0IFVwZGF0ZVByb3BlcnRpZXNIYW5kbGVyIGZyb20gJy4vY21kL1VwZGF0ZVByb3BlcnRpZXNIYW5kbGVyJztcbmltcG9ydCBVcGRhdGVDYW52YXNSb290SGFuZGxlciBmcm9tICcuL2NtZC9VcGRhdGVDYW52YXNSb290SGFuZGxlcic7XG5pbXBvcnQgSWRDbGFpbUhhbmRsZXIgZnJvbSAnLi9jbWQvSWRDbGFpbUhhbmRsZXInO1xuaW1wb3J0IFNldENvbG9ySGFuZGxlciBmcm9tICcuL2NtZC9TZXRDb2xvckhhbmRsZXInO1xuXG5pbXBvcnQgVXBkYXRlTGFiZWxIYW5kbGVyIGZyb20gJy4uL2xhYmVsLWVkaXRpbmcvY21kL1VwZGF0ZUxhYmVsSGFuZGxlcic7XG5cblxuLyoqXG4gKiBQb3N0aXQgbW9kZWxpbmcgZmVhdHVyZXMgYWN0aXZhdG9yXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7RWxlbWVudEZhY3Rvcnl9IGVsZW1lbnRGYWN0b3J5XG4gKiBAcGFyYW0ge0NvbW1hbmRTdGFja30gY29tbWFuZFN0YWNrXG4gKiBAcGFyYW0ge1Bvc3RpdFJ1bGVzfSBwb3N0aXRSdWxlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNb2RlbGluZyhcbiAgICBldmVudEJ1cywgZWxlbWVudEZhY3RvcnksIGNvbW1hbmRTdGFjayxcbiAgICBwb3N0aXRSdWxlcykge1xuXG4gIEJhc2VNb2RlbGluZy5jYWxsKHRoaXMsIGV2ZW50QnVzLCBlbGVtZW50RmFjdG9yeSwgY29tbWFuZFN0YWNrKTtcblxuICB0aGlzLl9wb3N0aXRSdWxlcyA9IHBvc3RpdFJ1bGVzO1xufVxuXG5pbmhlcml0cyhNb2RlbGluZywgQmFzZU1vZGVsaW5nKTtcblxuTW9kZWxpbmcuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2VsZW1lbnRGYWN0b3J5JyxcbiAgJ2NvbW1hbmRTdGFjaycsXG4gICdwb3N0aXRSdWxlcydcbl07XG5cblxuTW9kZWxpbmcucHJvdG90eXBlLmdldEhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYW5kbGVycyA9IEJhc2VNb2RlbGluZy5wcm90b3R5cGUuZ2V0SGFuZGxlcnMuY2FsbCh0aGlzKTtcblxuICBoYW5kbGVyc1snZWxlbWVudC51cGRhdGVQcm9wZXJ0aWVzJ10gPSBVcGRhdGVQcm9wZXJ0aWVzSGFuZGxlcjtcbiAgaGFuZGxlcnNbJ2NhbnZhcy51cGRhdGVSb290J10gPSBVcGRhdGVDYW52YXNSb290SGFuZGxlcjtcbiAgaGFuZGxlcnNbJ2lkLnVwZGF0ZUNsYWltJ10gPSBJZENsYWltSGFuZGxlcjtcbiAgaGFuZGxlcnNbJ2VsZW1lbnQuc2V0Q29sb3InXSA9IFNldENvbG9ySGFuZGxlcjtcbiAgaGFuZGxlcnNbJ2VsZW1lbnQudXBkYXRlTGFiZWwnXSA9IFVwZGF0ZUxhYmVsSGFuZGxlcjtcblxuICByZXR1cm4gaGFuZGxlcnM7XG59O1xuXG5cbk1vZGVsaW5nLnByb3RvdHlwZS51cGRhdGVMYWJlbCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG5ld0xhYmVsLCBuZXdCb3VuZHMsIGhpbnRzKSB7XG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdlbGVtZW50LnVwZGF0ZUxhYmVsJywge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgbmV3TGFiZWw6IG5ld0xhYmVsLFxuICAgIG5ld0JvdW5kczogbmV3Qm91bmRzLFxuICAgIGhpbnRzOiBoaW50cyB8fCB7fVxuICB9KTtcbn07XG5cblxuTW9kZWxpbmcucHJvdG90eXBlLnVwZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdlbGVtZW50LnVwZGF0ZVByb3BlcnRpZXMnLCB7XG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gIH0pO1xufTtcblxuTW9kZWxpbmcucHJvdG90eXBlLmNsYWltSWQgPSBmdW5jdGlvbihpZCwgbW9kZGxlRWxlbWVudCkge1xuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnaWQudXBkYXRlQ2xhaW0nLCB7XG4gICAgaWQ6IGlkLFxuICAgIGVsZW1lbnQ6IG1vZGRsZUVsZW1lbnQsXG4gICAgY2xhaW1pbmc6IHRydWVcbiAgfSk7XG59O1xuXG5cbk1vZGVsaW5nLnByb3RvdHlwZS51bmNsYWltSWQgPSBmdW5jdGlvbihpZCwgbW9kZGxlRWxlbWVudCkge1xuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnaWQudXBkYXRlQ2xhaW0nLCB7XG4gICAgaWQ6IGlkLFxuICAgIGVsZW1lbnQ6IG1vZGRsZUVsZW1lbnRcbiAgfSk7XG59O1xuXG5Nb2RlbGluZy5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbihlbGVtZW50cywgY29sb3IpIHtcbiAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICBlbGVtZW50cyA9IFsgZWxlbWVudHMgXTtcbiAgfVxuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdlbGVtZW50LnNldENvbG9yJywge1xuICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICBjb2xvcjogY29sb3JcbiAgfSk7XG59O1xuIiwiaW1wb3J0IHtcbiAgYXNzaWduLFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGlzQW55XG59IGZyb20gJy4vdXRpbC9Nb2RlbGluZ1V0aWwnO1xuXG5pbXBvcnQge1xuICBpc1xufSBmcm9tICcuLi8uLi91dGlsL01vZGVsVXRpbCc7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zaXRGYWN0b3J5KG1vZGRsZSkge1xuICB0aGlzLl9tb2RlbCA9IG1vZGRsZTtcbn1cblxuUG9zaXRGYWN0b3J5LiRpbmplY3QgPSBbICdtb2RkbGUnIF07XG5cblxuUG9zaXRGYWN0b3J5LnByb3RvdHlwZS5fbmVlZHNJZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzQW55KGVsZW1lbnQsIFtcbiAgICAncG9zdGl0OkJvYXJkRWxlbWVudCdcbiAgXSk7XG59O1xuXG5Qb3NpdEZhY3RvcnkucHJvdG90eXBlLl9lbnN1cmVJZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAvLyBnZW5lcmF0ZSBzZW1hbnRpYyBpZHMgZm9yIGVsZW1lbnRzXG4gIC8vIHBvc3RpdDpQb3N0aXQgLT4gUG9zaXRpdF9JRFxuICB2YXIgcHJlZml4O1xuXG4gIGlmIChpcyhlbGVtZW50LCAncG9zdGl0OlBvc3RpdCcpKSB7XG4gICAgcHJlZml4ID0gJ1Bvc3RpdCc7XG4gIH0gZWxzZSB7XG4gICAgcHJlZml4ID0gKGVsZW1lbnQuJHR5cGUgfHwgJycpLnJlcGxhY2UoL15bXjpdKjovZywgJycpO1xuICB9XG5cbiAgcHJlZml4ICs9ICdfJztcblxuICBpZiAoIWVsZW1lbnQuaWQgJiYgdGhpcy5fbmVlZHNJZChlbGVtZW50KSkge1xuICAgIGVsZW1lbnQuaWQgPSB0aGlzLl9tb2RlbC5pZHMubmV4dFByZWZpeGVkKHByZWZpeCwgZWxlbWVudCk7XG4gIH1cbn07XG5cblxuUG9zaXRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbih0eXBlLCBhdHRycykge1xuICB2YXIgZWxlbWVudCA9IHRoaXMuX21vZGVsLmNyZWF0ZSh0eXBlLCBhdHRycyB8fCB7fSk7XG5cbiAgdGhpcy5fZW5zdXJlSWQoZWxlbWVudCk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5cblBvc2l0RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlRGlMYWJlbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jcmVhdGUoJ3Bvc3RpdERpOlBvc3RpdExhYmVsJywge1xuICAgIGJvdW5kczogdGhpcy5jcmVhdGVEaUJvdW5kcygpXG4gIH0pO1xufTtcblxuXG5Qb3NpdEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZURpU2hhcGUgPSBmdW5jdGlvbihzZW1hbnRpYywgYm91bmRzLCBhdHRycykge1xuXG4gIHJldHVybiB0aGlzLmNyZWF0ZSgncG9zdGl0RGk6UG9zdGl0U2hhcGUnLCBhc3NpZ24oe1xuICAgIGJvYXJkRWxlbWVudDogc2VtYW50aWMsXG4gICAgYm91bmRzOiB0aGlzLmNyZWF0ZURpQm91bmRzKGJvdW5kcylcbiAgfSwgYXR0cnMpKTtcbn07XG5cblxuUG9zaXRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVEaUJvdW5kcyA9IGZ1bmN0aW9uKGJvdW5kcykge1xuICByZXR1cm4gdGhpcy5jcmVhdGUoJ2RjOkJvdW5kcycsIGJvdW5kcyk7XG59O1xuXG5cblBvc2l0RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlRGlQbGFuZSA9IGZ1bmN0aW9uKHNlbWFudGljKSB7XG4gIHJldHVybiB0aGlzLmNyZWF0ZSgncG9zdGl0RGk6UG9zdGl0UGxhbmUnLCB7XG4gICAgYm9hcmRFbGVtZW50OiBzZW1hbnRpY1xuICB9KTtcbn07IiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmb3JFYWNoXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IHtcbiAgcmVtb3ZlIGFzIGNvbGxlY3Rpb25SZW1vdmVcbn0gZnJvbSAnZGlhZ3JhbS1qcy9saWIvdXRpbC9Db2xsZWN0aW9ucyc7XG5cbmltcG9ydCB7XG4gIExhYmVsXG59IGZyb20gJ2RpYWdyYW0tanMvbGliL21vZGVsJztcblxuaW1wb3J0IHtcbiAgaXNcbn0gZnJvbSAnLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG5pbXBvcnQgQ29tbWFuZEludGVyY2VwdG9yIGZyb20gJ2RpYWdyYW0tanMvbGliL2NvbW1hbmQvQ29tbWFuZEludGVyY2VwdG9yJztcblxuLyoqXG4gKiBBIGhhbmRsZXIgcmVzcG9uc2libGUgZm9yIHVwZGF0aW5nIHRoZSB1bmRlcmx5aW5nIFBvc3RpdCBYTUwgKyBESVxuICogb25jZSBjaGFuZ2VzIG9uIHRoZSBkaWFncmFtIGhhcHBlblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQb3N0aXRVcGRhdGVyKFxuICAgIGV2ZW50QnVzLCBwb3N0aXRGYWN0b3J5LCBjb25uZWN0aW9uRG9ja2luZyxcbiAgICB0cmFuc2xhdGUpIHtcblxuICBDb21tYW5kSW50ZXJjZXB0b3IuY2FsbCh0aGlzLCBldmVudEJ1cyk7XG5cbiAgdGhpcy5fcG9zdGl0RmFjdG9yeSA9IHBvc3RpdEZhY3Rvcnk7XG4gIHRoaXMuX3RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cblxuICAvLyBQb3N0aXQgKyBESSB1cGRhdGUgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbiAgLy8gdXBkYXRlIHBhcmVudFxuICBmdW5jdGlvbiB1cGRhdGVQYXJlbnQoZSkge1xuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0O1xuXG4gICAgc2VsZi51cGRhdGVQYXJlbnQoY29udGV4dC5zaGFwZSB8fCBjb250ZXh0LmNvbm5lY3Rpb24sIGNvbnRleHQub2xkUGFyZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVyc2VVcGRhdGVQYXJlbnQoZSkge1xuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0O1xuXG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0LnNoYXBlIHx8IGNvbnRleHQuY29ubmVjdGlvbixcblxuICAgICAgICAvLyBvbGRQYXJlbnQgaXMgdGhlIChvbGQpIG5ldyBwYXJlbnQsIGJlY2F1c2Ugd2UgYXJlIHVuZG9pbmdcbiAgICAgICAgb2xkUGFyZW50ID0gY29udGV4dC5wYXJlbnQgfHwgY29udGV4dC5uZXdQYXJlbnQ7XG5cbiAgICBzZWxmLnVwZGF0ZVBhcmVudChlbGVtZW50LCBvbGRQYXJlbnQpO1xuICB9XG5cbiAgdGhpcy5leGVjdXRlZChbXG4gICAgJ3NoYXBlLm1vdmUnLFxuICAgICdzaGFwZS5jcmVhdGUnLFxuICAgICdzaGFwZS5kZWxldGUnXG4gIF0sIGlmUG9zdGl0KHVwZGF0ZVBhcmVudCkpO1xuXG4gIHRoaXMucmV2ZXJ0ZWQoW1xuICAgICdzaGFwZS5tb3ZlJyxcbiAgICAnc2hhcGUuY3JlYXRlJyxcbiAgICAnc2hhcGUuZGVsZXRlJ1xuICBdLCBpZlBvc3RpdChyZXZlcnNlVXBkYXRlUGFyZW50KSk7XG5cbiAgLypcbiAgICogIyMgVXBkYXRpbmcgUGFyZW50XG4gICAqXG4gICAqIFdoZW4gbW9ycGhpbmcgYSByb290IGVsZW1lbnRcbiAgICogbWFrZSBzdXJlIHRoYXQgYm90aCB0aGUgKnNlbWFudGljKiBhbmQgKmRpKiBwYXJlbnQgb2YgZWFjaCBlbGVtZW50XG4gICAqIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVSb290KGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBvbGRSb290ID0gY29udGV4dC5vbGRSb290LFxuICAgICAgICBjaGlsZHJlbiA9IG9sZFJvb3QuY2hpbGRyZW47XG5cbiAgICBmb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgaWYgKGlzKGNoaWxkLCAncG9zdGl0OkJvYXJkRWxlbWVudCcpKSB7XG4gICAgICAgIHNlbGYudXBkYXRlUGFyZW50KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuZXhlY3V0ZWQoWyAnY2FudmFzLnVwZGF0ZVJvb3QnIF0sIHVwZGF0ZVJvb3QpO1xuICB0aGlzLnJldmVydGVkKFsgJ2NhbnZhcy51cGRhdGVSb290JyBdLCB1cGRhdGVSb290KTtcblxuXG4gIC8vIHVwZGF0ZSBib3VuZHNcbiAgZnVuY3Rpb24gdXBkYXRlQm91bmRzKGUpIHtcbiAgICB2YXIgc2hhcGUgPSBlLmNvbnRleHQuc2hhcGU7XG5cbiAgICBpZiAoIWlzKHNoYXBlLCAncG9zdGl0OkJvYXJkRWxlbWVudCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi51cGRhdGVCb3VuZHMoc2hhcGUpO1xuICB9XG5cbiAgdGhpcy5leGVjdXRlZChbICdzaGFwZS5tb3ZlJywgJ3NoYXBlLmNyZWF0ZScsICdzaGFwZS5yZXNpemUnIF0sIGlmUG9zdGl0KGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAvLyBleGNsdWRlIGxhYmVscyBiZWNhdXNlIHRoZXkncmUgaGFuZGxlZCBzZXBhcmF0ZWx5IGR1cmluZyBzaGFwZS5jaGFuZ2VkXG4gICAgaWYgKGV2ZW50LmNvbnRleHQuc2hhcGUudHlwZSA9PT0gJ2xhYmVsJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZUJvdW5kcyhldmVudCk7XG4gIH0pKTtcblxuICB0aGlzLnJldmVydGVkKFsgJ3NoYXBlLm1vdmUnLCAnc2hhcGUuY3JlYXRlJywgJ3NoYXBlLnJlc2l6ZScgXSwgaWZQb3N0aXQoZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIC8vIGV4Y2x1ZGUgbGFiZWxzIGJlY2F1c2UgdGhleSdyZSBoYW5kbGVkIHNlcGFyYXRlbHkgZHVyaW5nIHNoYXBlLmNoYW5nZWRcbiAgICBpZiAoZXZlbnQuY29udGV4dC5zaGFwZS50eXBlID09PSAnbGFiZWwnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdXBkYXRlQm91bmRzKGV2ZW50KTtcbiAgfSkpO1xuXG4gIC8vIEhhbmRsZSBsYWJlbHMgc2VwYXJhdGVseS4gVGhpcyBpcyBuZWNlc3NhcnksIGJlY2F1c2UgdGhlIGxhYmVsIGJvdW5kcyBoYXZlIHRvIGJlIHVwZGF0ZWRcbiAgLy8gZXZlcnkgdGltZSBpdHMgc2hhcGUgY2hhbmdlcywgbm90IG9ubHkgb24gbW92ZSwgY3JlYXRlIGFuZCByZXNpemUuXG4gIGV2ZW50QnVzLm9uKCdzaGFwZS5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZWxlbWVudC50eXBlID09PSAnbGFiZWwnKSB7XG4gICAgICB1cGRhdGVCb3VuZHMoeyBjb250ZXh0OiB7IHNoYXBlOiBldmVudC5lbGVtZW50IH0gfSk7XG4gICAgfVxuICB9KTtcblxufVxuXG5pbmhlcml0cyhQb3N0aXRVcGRhdGVyLCBDb21tYW5kSW50ZXJjZXB0b3IpO1xuXG5Qb3N0aXRVcGRhdGVyLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdwb3N0aXRGYWN0b3J5JyxcbiAgJ2Nvbm5lY3Rpb25Eb2NraW5nJyxcbiAgJ3RyYW5zbGF0ZSdcbl07XG5cblxuLy8gaW1wbGVtZW50YXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5Qb3N0aXRVcGRhdGVyLnByb3RvdHlwZS51cGRhdGVBdHRhY2htZW50ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICBidXNpbmVzc09iamVjdCA9IHNoYXBlLmJ1c2luZXNzT2JqZWN0LFxuICAgICAgaG9zdCA9IHNoYXBlLmhvc3Q7XG5cbiAgYnVzaW5lc3NPYmplY3QuYXR0YWNoZWRUb1JlZiA9IGhvc3QgJiYgaG9zdC5idXNpbmVzc09iamVjdDtcbn07XG5cblBvc3RpdFVwZGF0ZXIucHJvdG90eXBlLnVwZGF0ZVBhcmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9sZFBhcmVudCkge1xuXG4gIC8vIGRvIG5vdCB1cGRhdGUgbGFiZWwgcGFyZW50XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgTGFiZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFyZW50U2hhcGUgPSBlbGVtZW50LnBhcmVudDtcblxuICB2YXIgYnVzaW5lc3NPYmplY3QgPSBlbGVtZW50LmJ1c2luZXNzT2JqZWN0LFxuICAgICAgcGFyZW50QnVzaW5lc3NPYmplY3QgPSBwYXJlbnRTaGFwZSAmJiBwYXJlbnRTaGFwZS5idXNpbmVzc09iamVjdCxcbiAgICAgIHBhcmVudERpID0gcGFyZW50QnVzaW5lc3NPYmplY3QgJiYgcGFyZW50QnVzaW5lc3NPYmplY3QuZGk7XG5cbiAgdGhpcy51cGRhdGVTZW1hbnRpY1BhcmVudChidXNpbmVzc09iamVjdCwgcGFyZW50QnVzaW5lc3NPYmplY3QpO1xuXG4gIHRoaXMudXBkYXRlRGlQYXJlbnQoYnVzaW5lc3NPYmplY3QuZGksIHBhcmVudERpKTtcbn07XG5cblxuUG9zdGl0VXBkYXRlci5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24oc2hhcGUpIHtcblxuICB2YXIgZGkgPSBzaGFwZS5idXNpbmVzc09iamVjdC5kaTtcblxuICB2YXIgdGFyZ2V0ID0gKHNoYXBlIGluc3RhbmNlb2YgTGFiZWwpID8gdGhpcy5fZ2V0TGFiZWwoZGkpIDogZGk7XG5cbiAgdmFyIGJvdW5kcyA9IHRhcmdldC5ib3VuZHM7XG5cbiAgaWYgKCFib3VuZHMpIHtcbiAgICBib3VuZHMgPSB0aGlzLl9wb3N0aXRGYWN0b3J5LmNyZWF0ZURpQm91bmRzKCk7XG4gICAgdGFyZ2V0LnNldCgnYm91bmRzJywgYm91bmRzKTtcbiAgfVxuXG4gIGFzc2lnbihib3VuZHMsIHtcbiAgICB4OiBzaGFwZS54LFxuICAgIHk6IHNoYXBlLnksXG4gICAgd2lkdGg6IHNoYXBlLndpZHRoLFxuICAgIGhlaWdodDogc2hhcGUuaGVpZ2h0XG4gIH0pO1xufTtcblxuXG5Qb3N0aXRVcGRhdGVyLnByb3RvdHlwZS51cGRhdGVEaVBhcmVudCA9IGZ1bmN0aW9uKGRpLCBwYXJlbnREaSkge1xuXG4gIGlmIChwYXJlbnREaSAmJiAhaXMocGFyZW50RGksICdwb3N0aXREaTpQb3N0aXRQbGFuZScpKSB7XG4gICAgcGFyZW50RGkgPSBwYXJlbnREaS4kcGFyZW50O1xuICB9XG5cbiAgaWYgKGRpLiRwYXJlbnQgPT09IHBhcmVudERpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBsYW5lRWxlbWVudHMgPSAocGFyZW50RGkgfHwgZGkuJHBhcmVudCkuZ2V0KCdwbGFuZUVsZW1lbnQnKTtcblxuICBpZiAocGFyZW50RGkpIHtcbiAgICBwbGFuZUVsZW1lbnRzLnB1c2goZGkpO1xuICAgIGRpLiRwYXJlbnQgPSBwYXJlbnREaTtcbiAgfSBlbHNlIHtcbiAgICBjb2xsZWN0aW9uUmVtb3ZlKHBsYW5lRWxlbWVudHMsIGRpKTtcbiAgICBkaS4kcGFyZW50ID0gbnVsbDtcbiAgfVxufTtcblxuXG5Qb3N0aXRVcGRhdGVyLnByb3RvdHlwZS51cGRhdGVTZW1hbnRpY1BhcmVudCA9IGZ1bmN0aW9uKGJ1c2luZXNzT2JqZWN0LCBuZXdQYXJlbnQsIHZpc3VhbFBhcmVudCkge1xuXG4gIHZhciBjb250YWlubWVudCxcbiAgICAgIHRyYW5zbGF0ZSA9IHRoaXMuX3RyYW5zbGF0ZTtcblxuICBpZiAoYnVzaW5lc3NPYmplY3QuJHBhcmVudCA9PT0gbmV3UGFyZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cblxuICBpZiAoaXMoYnVzaW5lc3NPYmplY3QsICdwb3N0aXQ6Qm9hcmRFbGVtZW50JykpIHtcbiAgICBjb250YWlubWVudCA9ICdib2FyZEVsZW1lbnRzJztcbiAgfVxuXG4gIGlmICghY29udGFpbm1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnNsYXRlKFxuICAgICAgJ25vIHBhcmVudCBmb3Ige2VsZW1lbnR9IGluIHtwYXJlbnR9JyxcbiAgICAgIHtcbiAgICAgICAgZWxlbWVudDogYnVzaW5lc3NPYmplY3QuaWQsXG4gICAgICAgIHBhcmVudDogbmV3UGFyZW50LmlkXG4gICAgICB9XG4gICAgKSk7XG4gIH1cblxuICB2YXIgY2hpbGRyZW47XG5cbiAgaWYgKGJ1c2luZXNzT2JqZWN0LiRwYXJlbnQpIHtcblxuICAgIC8vIHJlbW92ZSBmcm9tIG9sZCBwYXJlbnRcbiAgICBjaGlsZHJlbiA9IGJ1c2luZXNzT2JqZWN0LiRwYXJlbnQuZ2V0KGNvbnRhaW5tZW50KTtcbiAgICBjb2xsZWN0aW9uUmVtb3ZlKGNoaWxkcmVuLCBidXNpbmVzc09iamVjdCk7XG4gIH1cblxuICBpZiAoIW5ld1BhcmVudCkge1xuICAgIGJ1c2luZXNzT2JqZWN0LiRwYXJlbnQgPSBudWxsO1xuICB9IGVsc2Uge1xuXG4gICAgLy8gYWRkIHRvIG5ldyBwYXJlbnRcbiAgICBjaGlsZHJlbiA9IG5ld1BhcmVudC5nZXQoY29udGFpbm1lbnQpO1xuICAgIGNoaWxkcmVuLnB1c2goYnVzaW5lc3NPYmplY3QpO1xuICAgIGJ1c2luZXNzT2JqZWN0LiRwYXJlbnQgPSBuZXdQYXJlbnQ7XG4gIH1cblxuICBpZiAodmlzdWFsUGFyZW50KSB7XG4gICAgdmFyIGRpQ2hpbGRyZW4gPSB2aXN1YWxQYXJlbnQuZ2V0KGNvbnRhaW5tZW50KTtcblxuICAgIGNvbGxlY3Rpb25SZW1vdmUoY2hpbGRyZW4sIGJ1c2luZXNzT2JqZWN0KTtcblxuICAgIGlmIChuZXdQYXJlbnQpIHtcblxuICAgICAgaWYgKCFkaUNoaWxkcmVuKSB7XG4gICAgICAgIGRpQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgbmV3UGFyZW50LnNldChjb250YWlubWVudCwgZGlDaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIGRpQ2hpbGRyZW4ucHVzaChidXNpbmVzc09iamVjdCk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5Qb3N0aXRVcGRhdGVyLnByb3RvdHlwZS5fZ2V0TGFiZWwgPSBmdW5jdGlvbihkaSkge1xuICBpZiAoIWRpLmxhYmVsKSB7XG4gICAgZGkubGFiZWwgPSB0aGlzLl9wb3N0aXRGYWN0b3J5LmNyZWF0ZURpTGFiZWwoKTtcbiAgfVxuXG4gIHJldHVybiBkaS5sYWJlbDtcbn07XG5cblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhlIGV2ZW50IGxpc3RlbmVyIGlzIG9ubHkgY2FsbGVkXG4gKiBpZiB0aGUgdG91Y2hlZCBlbGVtZW50IGlzIGEgcG9zdGl0IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZ3VhcmRlZCBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBpZlBvc3RpdChmbikge1xuXG4gIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBlbGVtZW50ID0gY29udGV4dC5zaGFwZSB8fCBjb250ZXh0LmNvbm5lY3Rpb247XG5cbiAgICBpZiAoaXMoZWxlbWVudCwgJ3Bvc3RpdDpCb2FyZEVsZW1lbnQnKSkge1xuICAgICAgZm4oZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCB7XG4gIGdldE9yaWVudGF0aW9uLFxuICBnZXRNaWQsXG4gIGFzVFJCTFxufSBmcm9tICdkaWFncmFtLWpzL2xpYi9sYXlvdXQvTGF5b3V0VXRpbCc7XG5cbmltcG9ydCB7XG4gIHN1YnN0cmFjdFxufSBmcm9tICdkaWFncmFtLWpzL2xpYi91dGlsL01hdGgnO1xuXG5pbXBvcnQge1xuICBoYXNFeHRlcm5hbExhYmVsXG59IGZyb20gJy4uLy4uLy4uL3V0aWwvTGFiZWxVdGlsJztcblxuaW1wb3J0IENvbW1hbmRJbnRlcmNlcHRvciBmcm9tICdkaWFncmFtLWpzL2xpYi9jb21tYW5kL0NvbW1hbmRJbnRlcmNlcHRvcic7XG5cbnZhciBBTElHTk1FTlRTID0gW1xuICAndG9wJyxcbiAgJ2JvdHRvbScsXG4gICdsZWZ0JyxcbiAgJ3JpZ2h0J1xuXTtcblxudmFyIEVMRU1FTlRfTEFCRUxfRElTVEFOQ0UgPSAxMDtcblxuLyoqXG4gKiBBIGNvbXBvbmVudCB0aGF0IG1ha2VzIHN1cmUgdGhhdCBleHRlcm5hbCBsYWJlbHMgYXJlIGFkZGVkXG4gKiB0b2dldGhlciB3aXRoIHJlc3BlY3RpdmUgZWxlbWVudHMgYW5kIHByb3Blcmx5IHVwZGF0ZWQgKERJIHdpc2UpXG4gKiBkdXJpbmcgbW92ZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtNb2RlbGluZ30gbW9kZWxpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWRhcHRpdmVMYWJlbFBvc2l0aW9uaW5nQmVoYXZpb3IoZXZlbnRCdXMsIG1vZGVsaW5nKSB7XG5cbiAgQ29tbWFuZEludGVyY2VwdG9yLmNhbGwodGhpcywgZXZlbnRCdXMpO1xuXG4gIHRoaXMucG9zdEV4ZWN1dGVkKFtcbiAgICAnY29ubmVjdGlvbi5jcmVhdGUnLFxuICAgICdjb25uZWN0aW9uLmxheW91dCcsXG4gICAgJ2Nvbm5lY3Rpb24udXBkYXRlV2F5cG9pbnRzJ1xuICBdLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgICAgc291cmNlID0gY29ubmVjdGlvbi5zb3VyY2UsXG4gICAgICAgIHRhcmdldCA9IGNvbm5lY3Rpb24udGFyZ2V0LFxuICAgICAgICBoaW50cyA9IGNvbnRleHQuaGludHMgfHwge307XG5cbiAgICBpZiAoaGludHMuY3JlYXRlRWxlbWVudHNCZWhhdmlvciAhPT0gZmFsc2UpIHtcbiAgICAgIGNoZWNrTGFiZWxBZGp1c3RtZW50KHNvdXJjZSk7XG4gICAgICBjaGVja0xhYmVsQWRqdXN0bWVudCh0YXJnZXQpO1xuICAgIH1cbiAgfSk7XG5cblxuICB0aGlzLnBvc3RFeGVjdXRlZChbXG4gICAgJ2xhYmVsLmNyZWF0ZSdcbiAgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gICAgaWYgKGhpbnRzLmNyZWF0ZUVsZW1lbnRzQmVoYXZpb3IgIT09IGZhbHNlKSB7XG4gICAgICBjaGVja0xhYmVsQWRqdXN0bWVudChzaGFwZS5sYWJlbFRhcmdldCk7XG4gICAgfVxuICB9KTtcblxuXG4gIHRoaXMucG9zdEV4ZWN1dGVkKFtcbiAgICAnZWxlbWVudHMuY3JlYXRlJ1xuICBdLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgZWxlbWVudHMgPSBjb250ZXh0LmVsZW1lbnRzLFxuICAgICAgICBoaW50cyA9IGNvbnRleHQuaGludHMgfHwge307XG5cbiAgICBpZiAoaGludHMuY3JlYXRlRWxlbWVudHNCZWhhdmlvciAhPT0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBjaGVja0xhYmVsQWRqdXN0bWVudChlbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gY2hlY2tMYWJlbEFkanVzdG1lbnQoZWxlbWVudCkge1xuXG4gICAgLy8gc2tpcCBub24tZXhpc3RpbmcgbGFiZWxzXG4gICAgaWYgKCFoYXNFeHRlcm5hbExhYmVsKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9wdGltYWxQb3NpdGlvbiA9IGdldE9wdGltYWxQb3NpdGlvbihlbGVtZW50KTtcblxuICAgIC8vIG5vIG9wdGltYWwgcG9zaXRpb24gZm91bmRcbiAgICBpZiAoIW9wdGltYWxQb3NpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFkanVzdExhYmVsUG9zaXRpb24oZWxlbWVudCwgb3B0aW1hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdExhYmVsUG9zaXRpb24oZWxlbWVudCwgb3JpZW50YXRpb24pIHtcblxuICAgIHZhciBlbGVtZW50TWlkID0gZ2V0TWlkKGVsZW1lbnQpLFxuICAgICAgICBsYWJlbCA9IGVsZW1lbnQubGFiZWwsXG4gICAgICAgIGxhYmVsTWlkID0gZ2V0TWlkKGxhYmVsKTtcblxuICAgIC8vIGlnbm9yZSBsYWJlbHMgdGhhdCBhcmUgYmVpbmcgY3JlYXRlZFxuICAgIGlmICghbGFiZWwucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRUcmJsID0gYXNUUkJMKGVsZW1lbnQpO1xuXG4gICAgdmFyIG5ld0xhYmVsTWlkO1xuXG4gICAgc3dpdGNoIChvcmllbnRhdGlvbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBuZXdMYWJlbE1pZCA9IHtcbiAgICAgICAgeDogZWxlbWVudE1pZC54LFxuICAgICAgICB5OiBlbGVtZW50VHJibC50b3AgLSBFTEVNRU5UX0xBQkVMX0RJU1RBTkNFIC0gbGFiZWwuaGVpZ2h0IC8gMlxuICAgICAgfTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdsZWZ0JzpcblxuICAgICAgbmV3TGFiZWxNaWQgPSB7XG4gICAgICAgIHg6IGVsZW1lbnRUcmJsLmxlZnQgLSBFTEVNRU5UX0xBQkVMX0RJU1RBTkNFIC0gbGFiZWwud2lkdGggLyAyLFxuICAgICAgICB5OiBlbGVtZW50TWlkLnlcbiAgICAgIH07XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcblxuICAgICAgbmV3TGFiZWxNaWQgPSB7XG4gICAgICAgIHg6IGVsZW1lbnRNaWQueCxcbiAgICAgICAgeTogZWxlbWVudFRyYmwuYm90dG9tICsgRUxFTUVOVF9MQUJFTF9ESVNUQU5DRSArIGxhYmVsLmhlaWdodCAvIDJcbiAgICAgIH07XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuXG4gICAgICBuZXdMYWJlbE1pZCA9IHtcbiAgICAgICAgeDogZWxlbWVudFRyYmwucmlnaHQgKyBFTEVNRU5UX0xBQkVMX0RJU1RBTkNFICsgbGFiZWwud2lkdGggLyAyLFxuICAgICAgICB5OiBlbGVtZW50TWlkLnlcbiAgICAgIH07XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBkZWx0YSA9IHN1YnN0cmFjdChuZXdMYWJlbE1pZCwgbGFiZWxNaWQpO1xuXG4gICAgbW9kZWxpbmcubW92ZVNoYXBlKGxhYmVsLCBkZWx0YSk7XG4gIH1cblxufVxuXG5pbmhlcml0cyhBZGFwdGl2ZUxhYmVsUG9zaXRpb25pbmdCZWhhdmlvciwgQ29tbWFuZEludGVyY2VwdG9yKTtcblxuQWRhcHRpdmVMYWJlbFBvc2l0aW9uaW5nQmVoYXZpb3IuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ21vZGVsaW5nJ1xuXTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBSZXR1cm4gYWxpZ25tZW50cyB3aGljaCBhcmUgdGFrZW4gYnkgYSBib3VuZGFyeSdzIGhvc3QgZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7U2hhcGV9IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxTdHJpbmc+fVxuICovXG5mdW5jdGlvbiBnZXRUYWtlbkhvc3RBbGlnbm1lbnRzKGVsZW1lbnQpIHtcblxuICB2YXIgaG9zdEVsZW1lbnQgPSBlbGVtZW50Lmhvc3QsXG4gICAgICBlbGVtZW50TWlkID0gZ2V0TWlkKGVsZW1lbnQpLFxuICAgICAgaG9zdE9yaWVudGF0aW9uID0gZ2V0T3JpZW50YXRpb24oZWxlbWVudE1pZCwgaG9zdEVsZW1lbnQpO1xuXG4gIHZhciBmcmVlQWxpZ25tZW50cztcblxuICAvLyBjaGVjayB3aGV0aGVyIHRoZXJlIGlzIGEgbXVsdGktb3JpZW50YXRpb24sIGUuZy4gJ3RvcC1sZWZ0J1xuICBpZiAoaG9zdE9yaWVudGF0aW9uLmluZGV4T2YoJy0nKSA+PSAwKSB7XG4gICAgZnJlZUFsaWdubWVudHMgPSBob3N0T3JpZW50YXRpb24uc3BsaXQoJy0nKTtcbiAgfSBlbHNlIHtcbiAgICBmcmVlQWxpZ25tZW50cyA9IFsgaG9zdE9yaWVudGF0aW9uIF07XG4gIH1cblxuICB2YXIgdGFrZW5BbGlnbm1lbnRzID0gQUxJR05NRU5UUy5maWx0ZXIoZnVuY3Rpb24oYWxpZ25tZW50KSB7XG5cbiAgICByZXR1cm4gZnJlZUFsaWdubWVudHMuaW5kZXhPZihhbGlnbm1lbnQpID09PSAtMTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRha2VuQWxpZ25tZW50cztcblxufVxuXG4vKipcbiAqIFJldHVybiBhbGlnbm1lbnRzIHdoaWNoIGFyZSB0YWtlbiBieSByZWxhdGVkIGNvbm5lY3Rpb25zXG4gKlxuICogQHBhcmFtIHtTaGFwZX0gZWxlbWVudFxuICpcbiAqIEByZXR1cm4ge0FycmF5PFN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldFRha2VuQ29ubmVjdGlvbkFsaWdubWVudHMoZWxlbWVudCkge1xuXG4gIHZhciBlbGVtZW50TWlkID0gZ2V0TWlkKGVsZW1lbnQpO1xuXG4gIHZhciB0YWtlbkFsaWdubWVudHMgPSBbXS5jb25jYXQoXG4gICAgZWxlbWVudC5pbmNvbWluZy5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMud2F5cG9pbnRzW2Mud2F5cG9pbnRzLmxlbmd0aCAtIDIgXTtcbiAgICB9KSxcbiAgICBlbGVtZW50Lm91dGdvaW5nLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gYy53YXlwb2ludHNbMV07XG4gICAgfSlcbiAgKS5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gZ2V0QXBwcm94aW1hdGVPcmllbnRhdGlvbihlbGVtZW50TWlkLCBwb2ludCk7XG4gIH0pO1xuXG4gIHJldHVybiB0YWtlbkFsaWdubWVudHM7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBvcHRpbWFsIGxhYmVsIHBvc2l0aW9uIGFyb3VuZCBhbiBlbGVtZW50XG4gKiBvciBfdW5kZWZpbmVkXywgaWYgbm9uZSB3YXMgZm91bmQuXG4gKlxuICogQHBhcmFtICB7U2hhcGV9IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHBvc2l0aW9uaW5nIGlkZW50aWZpZXJcbiAqL1xuZnVuY3Rpb24gZ2V0T3B0aW1hbFBvc2l0aW9uKGVsZW1lbnQpIHtcblxuICB2YXIgbGFiZWxNaWQgPSBnZXRNaWQoZWxlbWVudC5sYWJlbCk7XG5cbiAgdmFyIGVsZW1lbnRNaWQgPSBnZXRNaWQoZWxlbWVudCk7XG5cbiAgdmFyIGxhYmVsT3JpZW50YXRpb24gPSBnZXRBcHByb3hpbWF0ZU9yaWVudGF0aW9uKGVsZW1lbnRNaWQsIGxhYmVsTWlkKTtcblxuICBpZiAoIWlzQWxpZ25lZChsYWJlbE9yaWVudGF0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0YWtlbkFsaWdubWVudHMgPSBnZXRUYWtlbkNvbm5lY3Rpb25BbGlnbm1lbnRzKGVsZW1lbnQpO1xuXG4gIGlmIChlbGVtZW50Lmhvc3QpIHtcbiAgICB2YXIgdGFrZW5Ib3N0QWxpZ25tZW50cyA9IGdldFRha2VuSG9zdEFsaWdubWVudHMoZWxlbWVudCk7XG5cbiAgICB0YWtlbkFsaWdubWVudHMgPSB0YWtlbkFsaWdubWVudHMuY29uY2F0KHRha2VuSG9zdEFsaWdubWVudHMpO1xuICB9XG5cbiAgdmFyIGZyZWVBbGlnbm1lbnRzID0gQUxJR05NRU5UUy5maWx0ZXIoZnVuY3Rpb24oYWxpZ25tZW50KSB7XG5cbiAgICByZXR1cm4gdGFrZW5BbGlnbm1lbnRzLmluZGV4T2YoYWxpZ25tZW50KSA9PT0gLTE7XG4gIH0pO1xuXG4gIC8vIE5PVEhJTkcgVE8gRE87IGxhYmVsIGFscmVhZHkgYWxpZ25lZCBhLk8uSy5cbiAgaWYgKGZyZWVBbGlnbm1lbnRzLmluZGV4T2YobGFiZWxPcmllbnRhdGlvbikgIT09IC0xKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGZyZWVBbGlnbm1lbnRzWzBdO1xufVxuXG5mdW5jdGlvbiBnZXRBcHByb3hpbWF0ZU9yaWVudGF0aW9uKHAwLCBwMSkge1xuICByZXR1cm4gZ2V0T3JpZW50YXRpb24ocDEsIHAwLCA1KTtcbn1cblxuZnVuY3Rpb24gaXNBbGlnbmVkKG9yaWVudGF0aW9uKSB7XG4gIHJldHVybiBBTElHTk1FTlRTLmluZGV4T2Yob3JpZW50YXRpb24pICE9PSAtMTtcbn1cbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBDb21tYW5kSW50ZXJjZXB0b3IgZnJvbSAnZGlhZ3JhbS1qcy9saWIvY29tbWFuZC9Db21tYW5kSW50ZXJjZXB0b3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcGVuZEJlaGF2aW9yKGV2ZW50QnVzKSB7XG5cbiAgQ29tbWFuZEludGVyY2VwdG9yLmNhbGwodGhpcywgZXZlbnRCdXMpO1xuXG4gIC8vIGFzc2lnbiBjb3JyZWN0IHNoYXBlIHBvc2l0aW9uIHVubGVzcyBhbHJlYWR5IHNldFxuXG4gIHRoaXMucHJlRXhlY3V0ZSgnc2hhcGUuYXBwZW5kJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIHNvdXJjZSA9IGNvbnRleHQuc291cmNlLFxuICAgICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGU7XG5cbiAgICBpZiAoIWNvbnRleHQucG9zaXRpb24pIHtcblxuICAgICAgY29udGV4dC5wb3NpdGlvbiA9IHtcbiAgICAgICAgeDogc291cmNlLnggKyBzb3VyY2Uud2lkdGggKyA4MCArIHNoYXBlLndpZHRoIC8gMixcbiAgICAgICAgeTogc291cmNlLnkgKyBzb3VyY2UuaGVpZ2h0IC8gMlxuICAgICAgfTtcblxuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5cbmluaGVyaXRzKEFwcGVuZEJlaGF2aW9yLCBDb21tYW5kSW50ZXJjZXB0b3IpO1xuXG5BcHBlbmRCZWhhdmlvci4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnXG5dOyIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCB7XG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGdldEJ1c2luZXNzT2JqZWN0LFxuICBpc1xufSBmcm9tICcuLi8uLi8uLi91dGlsL01vZGVsVXRpbCc7XG5cbmltcG9ydCBDb21tYW5kSW50ZXJjZXB0b3IgZnJvbSAnZGlhZ3JhbS1qcy9saWIvY29tbWFuZC9Db21tYW5kSW50ZXJjZXB0b3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENyZWF0ZUJvYXJkRWxlbWVudEJlaGF2aW9yKGV2ZW50QnVzKSB7XG5cbiAgQ29tbWFuZEludGVyY2VwdG9yLmNhbGwodGhpcywgZXZlbnRCdXMpO1xuXG4gIC8vIGVuc3VyZSBwcm9wZXJ0aWVzIHdlcmUgc2V0IGluIGJ1c2luZXNzIG9iamVjdFxuXG4gIHRoaXMuZXhlY3V0ZSgnc2hhcGUuY3JlYXRlJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIHNoYXBlID0gY29udGV4dC5jb250ZXh0LnNoYXBlO1xuXG4gICAgaWYgKGlzKHNoYXBlLCAncG9zdGl0OlBvc3RpdCcpKSB7XG4gICAgICBjb25zdCBidXNpbmVzc09iamVjdCA9IGdldEJ1c2luZXNzT2JqZWN0KHNoYXBlKTtcbiAgICAgICFidXNpbmVzc09iamVjdC5jb2xvciAmJiBhc3NpZ24oYnVzaW5lc3NPYmplY3QsIHsgY29sb3I6IHNoYXBlLmNvbG9yIH0pO1xuICAgIH1cblxuICAgIGlmIChpcyhzaGFwZSwgJ3Bvc3RpdDpJbWFnZScpKSB7XG4gICAgICBjb25zdCBidXNpbmVzc09iamVjdCA9IGdldEJ1c2luZXNzT2JqZWN0KHNoYXBlKTtcbiAgICAgICFidXNpbmVzc09iamVjdC5zb3VyY2UgJiYgYXNzaWduKGJ1c2luZXNzT2JqZWN0LCB7IHNvdXJjZTogc2hhcGUuc291cmNlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmluaGVyaXRzKENyZWF0ZUJvYXJkRWxlbWVudEJlaGF2aW9yLCBDb21tYW5kSW50ZXJjZXB0b3IpO1xuXG5DcmVhdGVCb2FyZEVsZW1lbnRCZWhhdmlvci4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnXG5dOyIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCB7XG4gIGlzLFxuICBnZXRCdXNpbmVzc09iamVjdFxufSBmcm9tICcuLi8uLi8uLi91dGlsL01vZGVsVXRpbCc7XG5cbmltcG9ydCBDb21tYW5kSW50ZXJjZXB0b3IgZnJvbSAnZGlhZ3JhbS1qcy9saWIvY29tbWFuZC9Db21tYW5kSW50ZXJjZXB0b3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVtcHR5VGV4dEJveEJlaGF2aW9yKGV2ZW50QnVzLCBtb2RlbGluZywgZGlyZWN0RWRpdGluZykge1xuXG4gIENvbW1hbmRJbnRlcmNlcHRvci5jYWxsKHRoaXMsIGV2ZW50QnVzKTtcblxuICAvLyBkZWxldGUgdGV4dCBib3ggaWYgaXQgaGFzIG5vIHRleHRcbiAgdGhpcy5wb3N0RXhlY3V0ZSgnZWxlbWVudC51cGRhdGVMYWJlbCcsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBlbGVtZW50ID0gY29udGV4dC5lbGVtZW50LFxuICAgICAgICBuZXdMYWJlbCA9IGNvbnRleHQubmV3TGFiZWw7XG5cbiAgICBpZiAoaXMoZWxlbWVudCwgJ3Bvc3RpdDpUZXh0Qm94JykgJiYgaXNFbXB0eShuZXdMYWJlbCkpIHtcbiAgICAgIG1vZGVsaW5nLnJlbW92ZUVsZW1lbnRzKFsgZWxlbWVudCBdKTtcbiAgICB9XG4gIH0sIHRydWUpO1xuXG4gIGV2ZW50QnVzLm9uKCdkaXJlY3RFZGl0aW5nLmNhbmNlbCcsIDEwMDEsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGFjdGl2ZSA9IGV2ZW50LmFjdGl2ZSxcbiAgICAgICAgZWxlbWVudCA9IGFjdGl2ZS5lbGVtZW50O1xuXG4gICAgaWYgKGlzKGVsZW1lbnQsICdwb3N0aXQ6VGV4dEJveCcpICYmIGlzRW1wdHkoZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCkubmFtZSkpIHtcbiAgICAgIGRpcmVjdEVkaXRpbmcuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbW9kZWxpbmcucmVtb3ZlRWxlbWVudHMoWyBlbGVtZW50IF0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmluaGVyaXRzKEVtcHR5VGV4dEJveEJlaGF2aW9yLCBDb21tYW5kSW50ZXJjZXB0b3IpO1xuXG5FbXB0eVRleHRCb3hCZWhhdmlvci4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnbW9kZWxpbmcnLFxuICAnZGlyZWN0RWRpdGluZydcbl07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzRW1wdHkobGFiZWwpIHtcbiAgcmV0dXJuICFsYWJlbCB8fCBsYWJlbCA9PT0gJyc7XG59IiwiaW1wb3J0IHsgaXMgfSBmcm9tICcuLi8uLi8uLi91dGlsL01vZGVsVXRpbCc7XHJcblxyXG52YXIgSElHSF9QUklPUklUWSA9IDE1MDA7XHJcblxyXG5cclxuLyoqXHJcbiAqIENvcnJlY3QgaG92ZXIgdGFyZ2V0cyBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgdG8gaW1wcm92ZSBkaWFncmFtIGludGVyYWN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnRSZWdpc3RyeX0gZWxlbWVudFJlZ2lzdHJ5XHJcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXHJcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZpeEhvdmVyQmVoYXZpb3IoZWxlbWVudFJlZ2lzdHJ5LCBldmVudEJ1cywgY2FudmFzKSB7XHJcblxyXG4gIGV2ZW50QnVzLm9uKFtcclxuICAgICdjcmVhdGUuaG92ZXInLFxyXG4gICAgJ2NyZWF0ZS5tb3ZlJyxcclxuICAgICdjcmVhdGUuZW5kJyxcclxuICAgICdzaGFwZS5tb3ZlLmhvdmVyJyxcclxuICAgICdzaGFwZS5tb3ZlLm1vdmUnLFxyXG4gICAgJ3NoYXBlLm1vdmUuZW5kJ1xyXG4gIF0sIEhJR0hfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXHJcbiAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlIHx8IGV2ZW50LnNoYXBlLFxyXG4gICAgICAgIGhvdmVyID0gZXZlbnQuaG92ZXI7XHJcblxyXG4gICAgdmFyIHJvb3RFbGVtZW50ID0gY2FudmFzLmdldFJvb3RFbGVtZW50KCk7XHJcblxyXG4gICAgLy8gZW5zdXJlIGdyb3VwICYgbGFiZWwgZWxlbWVudHMgYXJlIGRyb3BwZWQgYWx3YXlzIG9udG8gdGhlIHJvb3RcclxuICAgIGlmIChob3ZlciAhPT0gcm9vdEVsZW1lbnQgJiYgKHNoYXBlLmxhYmVsVGFyZ2V0IHx8IGlzKHNoYXBlLCAncG9zdGl0Okdyb3VwJykpKSB7XHJcbiAgICAgIGV2ZW50LmhvdmVyID0gcm9vdEVsZW1lbnQ7XHJcbiAgICAgIGV2ZW50LmhvdmVyR2Z4ID0gZWxlbWVudFJlZ2lzdHJ5LmdldEdyYXBoaWNzKGV2ZW50LmhvdmVyKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbn1cclxuXHJcbkZpeEhvdmVyQmVoYXZpb3IuJGluamVjdCA9IFtcclxuICAnZWxlbWVudFJlZ2lzdHJ5JyxcclxuICAnZXZlbnRCdXMnLFxyXG4gICdjYW52YXMnXHJcbl07IiwiaW1wb3J0IHtcbiAgZ2V0TWlkXG59IGZyb20gJ2RpYWdyYW0tanMvbGliL2xheW91dC9MYXlvdXRVdGlsJztcblxuaW1wb3J0IGxpbmVJbnRlcnNlY3QgZnJvbSAnLi91dGlsL0xpbmVJbnRlcnNlY3QnO1xuXG5cbi8qKlxuICogRml4IGJyb2tlbiBkb2NraW5ncyBhZnRlciBESSBpbXBvcnRzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEltcG9ydERvY2tpbmdGaXgoZXZlbnRCdXMpIHtcblxuICBmdW5jdGlvbiBhZGp1c3REb2NraW5nKHN0YXJ0UG9pbnQsIG5leHRQb2ludCwgZWxlbWVudE1pZCkge1xuXG4gICAgdmFyIGVsZW1lbnRUb3AgPSB7XG4gICAgICB4OiBlbGVtZW50TWlkLngsXG4gICAgICB5OiBlbGVtZW50TWlkLnkgLSA1MFxuICAgIH07XG5cbiAgICB2YXIgZWxlbWVudExlZnQgPSB7XG4gICAgICB4OiBlbGVtZW50TWlkLnggLSA1MCxcbiAgICAgIHk6IGVsZW1lbnRNaWQueVxuICAgIH07XG5cbiAgICB2YXIgdmVydGljYWxJbnRlcnNlY3QgPSBsaW5lSW50ZXJzZWN0KHN0YXJ0UG9pbnQsIG5leHRQb2ludCwgZWxlbWVudE1pZCwgZWxlbWVudFRvcCksXG4gICAgICAgIGhvcml6b250YWxJbnRlcnNlY3QgPSBsaW5lSW50ZXJzZWN0KHN0YXJ0UG9pbnQsIG5leHRQb2ludCwgZWxlbWVudE1pZCwgZWxlbWVudExlZnQpO1xuXG4gICAgLy8gb3JpZ2luYWwgaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjZW50ZXIgY3Jvc3MgaW50ZXJzZWN0aW9uXG4gICAgdmFyIGNlbnRlckludGVyc2VjdDtcblxuICAgIGlmICh2ZXJ0aWNhbEludGVyc2VjdCAmJiBob3Jpem9udGFsSW50ZXJzZWN0KSB7XG4gICAgICBpZiAoZ2V0RGlzdGFuY2UodmVydGljYWxJbnRlcnNlY3QsIGVsZW1lbnRNaWQpID4gZ2V0RGlzdGFuY2UoaG9yaXpvbnRhbEludGVyc2VjdCwgZWxlbWVudE1pZCkpIHtcbiAgICAgICAgY2VudGVySW50ZXJzZWN0ID0gaG9yaXpvbnRhbEludGVyc2VjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbnRlckludGVyc2VjdCA9IHZlcnRpY2FsSW50ZXJzZWN0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjZW50ZXJJbnRlcnNlY3QgPSB2ZXJ0aWNhbEludGVyc2VjdCB8fCBob3Jpem9udGFsSW50ZXJzZWN0O1xuICAgIH1cblxuICAgIHN0YXJ0UG9pbnQub3JpZ2luYWwgPSBjZW50ZXJJbnRlcnNlY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBmaXhEb2NraW5ncyhjb25uZWN0aW9uKSB7XG4gICAgdmFyIHdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzO1xuXG4gICAgYWRqdXN0RG9ja2luZyhcbiAgICAgIHdheXBvaW50c1swXSxcbiAgICAgIHdheXBvaW50c1sxXSxcbiAgICAgIGdldE1pZChjb25uZWN0aW9uLnNvdXJjZSlcbiAgICApO1xuXG4gICAgYWRqdXN0RG9ja2luZyhcbiAgICAgIHdheXBvaW50c1t3YXlwb2ludHMubGVuZ3RoIC0gMV0sXG4gICAgICB3YXlwb2ludHNbd2F5cG9pbnRzLmxlbmd0aCAtIDJdLFxuICAgICAgZ2V0TWlkKGNvbm5lY3Rpb24udGFyZ2V0KVxuICAgICk7XG4gIH1cblxuICBldmVudEJ1cy5vbignYm9hcmRFbGVtZW50LmFkZGVkJywgZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIGVsZW1lbnQgPSBlLmVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudC53YXlwb2ludHMpIHtcbiAgICAgIGZpeERvY2tpbmdzKGVsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG59XG5cbkltcG9ydERvY2tpbmdGaXguJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJ1xuXTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDEueCAtIHAyLngsIDIpICsgTWF0aC5wb3cocDEueSAtIHAyLnksIDIpKTtcbn0iLCJpbXBvcnQge1xuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQge1xuICBpcyxcbiAgZ2V0QnVzaW5lc3NPYmplY3Rcbn0gZnJvbSAnLi4vLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG5pbXBvcnQge1xuICBpc0xhYmVsRXh0ZXJuYWwsXG4gIGdldEV4dGVybmFsTGFiZWxNaWQsXG4gIGhhc0V4dGVybmFsTGFiZWwsXG4gIGlzTGFiZWxcbn0gZnJvbSAnLi4vLi4vLi4vdXRpbC9MYWJlbFV0aWwnO1xuXG5pbXBvcnQge1xuICBnZXRMYWJlbFxufSBmcm9tICcuLi8uLi9sYWJlbC1lZGl0aW5nL0xhYmVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldExhYmVsQWRqdXN0bWVudFxufSBmcm9tICcuL3V0aWwvTGFiZWxMYXlvdXRVdGlsJztcblxuaW1wb3J0IENvbW1hbmRJbnRlcmNlcHRvciBmcm9tICdkaWFncmFtLWpzL2xpYi9jb21tYW5kL0NvbW1hbmRJbnRlcmNlcHRvcic7XG5cbmltcG9ydCB7XG4gIGdldE5ld0F0dGFjaFBvaW50XG59IGZyb20gJ2RpYWdyYW0tanMvbGliL3V0aWwvQXR0YWNoVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldE1pZCxcbiAgcm91bmRQb2ludFxufSBmcm9tICdkaWFncmFtLWpzL2xpYi9sYXlvdXQvTGF5b3V0VXRpbCc7XG5cbmltcG9ydCB7XG4gIGRlbHRhXG59IGZyb20gJ2RpYWdyYW0tanMvbGliL3V0aWwvUG9zaXRpb25VdGlsJztcblxuaW1wb3J0IHtcbiAgc29ydEJ5XG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZ2V0RGlzdGFuY2VQb2ludExpbmUsXG4gIHBlcnBlbmRpY3VsYXJGb290XG59IGZyb20gJy4vdXRpbC9HZW9tZXRyaWNVdGlsJztcblxudmFyIERFRkFVTFRfTEFCRUxfRElNRU5TSU9OUyA9IHtcbiAgd2lkdGg6IDkwLFxuICBoZWlnaHQ6IDIwXG59O1xuXG52YXIgTkFNRV9QUk9QRVJUWSA9ICduYW1lJztcblxuLyoqXG4gKiBBIGNvbXBvbmVudCB0aGF0IG1ha2VzIHN1cmUgdGhhdCBleHRlcm5hbCBsYWJlbHMgYXJlIGFkZGVkXG4gKiB0b2dldGhlciB3aXRoIHJlc3BlY3RpdmUgZWxlbWVudHMgYW5kIHByb3Blcmx5IHVwZGF0ZWQgKERJIHdpc2UpXG4gKiBkdXJpbmcgbW92ZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtNb2RlbGluZ30gbW9kZWxpbmdcbiAqIEBwYXJhbSB7UG9zdGl0RmFjdG9yeX0gcG9zdGl0RmFjdG9yeVxuICogQHBhcmFtIHtUZXh0UmVuZGVyZXJ9IHRleHRSZW5kZXJlclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYWJlbEJlaGF2aW9yKFxuICAgIGV2ZW50QnVzLCBtb2RlbGluZywgcG9zdGl0RmFjdG9yeSxcbiAgICB0ZXh0UmVuZGVyZXIpIHtcblxuICBDb21tYW5kSW50ZXJjZXB0b3IuY2FsbCh0aGlzLCBldmVudEJ1cyk7XG5cbiAgLy8gdXBkYXRlIGxhYmVsIGlmIG5hbWUgcHJvcGVydHkgd2FzIHVwZGF0ZWRcbiAgdGhpcy5wb3N0RXhlY3V0ZSgnZWxlbWVudC51cGRhdGVQcm9wZXJ0aWVzJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBlbGVtZW50ID0gY29udGV4dC5lbGVtZW50LFxuICAgICAgICBwcm9wZXJ0aWVzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xuXG4gICAgaWYgKE5BTUVfUFJPUEVSVFkgaW4gcHJvcGVydGllcykge1xuICAgICAgbW9kZWxpbmcudXBkYXRlTGFiZWwoZWxlbWVudCwgcHJvcGVydGllc1tOQU1FX1BST1BFUlRZXSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBjcmVhdGUgbGFiZWwgc2hhcGUgYWZ0ZXIgc2hhcGUvY29ubmVjdGlvbiB3YXMgY3JlYXRlZFxuICB0aGlzLnBvc3RFeGVjdXRlKFsgJ3NoYXBlLmNyZWF0ZScsICdjb25uZWN0aW9uLmNyZWF0ZScgXSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBoaW50cyA9IGNvbnRleHQuaGludHMgfHwge307XG5cbiAgICBpZiAoaGludHMuY3JlYXRlRWxlbWVudHNCZWhhdmlvciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHQuc2hhcGUgfHwgY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgICBidXNpbmVzc09iamVjdCA9IGVsZW1lbnQuYnVzaW5lc3NPYmplY3Q7XG5cbiAgICBpZiAoaXNMYWJlbChlbGVtZW50KSB8fCAhaXNMYWJlbEV4dGVybmFsKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb25seSBjcmVhdGUgbGFiZWwgaWYgYXR0cmlidXRlIGF2YWlsYWJsZVxuICAgIGlmICghZ2V0TGFiZWwoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGFiZWxDZW50ZXIgPSBnZXRFeHRlcm5hbExhYmVsTWlkKGVsZW1lbnQpO1xuXG4gICAgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCB4IGFuZCB5XG4gICAgdmFyIGxhYmVsRGltZW5zaW9ucyA9IHRleHRSZW5kZXJlci5nZXRFeHRlcm5hbExhYmVsQm91bmRzKFxuICAgICAgREVGQVVMVF9MQUJFTF9ESU1FTlNJT05TLFxuICAgICAgZ2V0TGFiZWwoZWxlbWVudClcbiAgICApO1xuXG4gICAgbW9kZWxpbmcuY3JlYXRlTGFiZWwoZWxlbWVudCwgbGFiZWxDZW50ZXIsIHtcbiAgICAgIGlkOiBidXNpbmVzc09iamVjdC5pZCArICdfbGFiZWwnLFxuICAgICAgYnVzaW5lc3NPYmplY3Q6IGJ1c2luZXNzT2JqZWN0LFxuICAgICAgd2lkdGg6IGxhYmVsRGltZW5zaW9ucy53aWR0aCxcbiAgICAgIGhlaWdodDogbGFiZWxEaW1lbnNpb25zLmhlaWdodFxuICAgIH0pO1xuICB9KTtcblxuICAvLyB1cGRhdGUgbGFiZWwgYWZ0ZXIgbGFiZWwgc2hhcGUgd2FzIGRlbGV0ZWRcbiAgdGhpcy5wb3N0RXhlY3V0ZSgnc2hhcGUuZGVsZXRlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGxhYmVsVGFyZ2V0ID0gY29udGV4dC5sYWJlbFRhcmdldCxcbiAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gICAgLy8gY2hlY2sgaWYgbGFiZWxcbiAgICBpZiAobGFiZWxUYXJnZXQgJiYgaGludHMudW5zZXRMYWJlbCAhPT0gZmFsc2UpIHtcbiAgICAgIG1vZGVsaW5nLnVwZGF0ZUxhYmVsKGxhYmVsVGFyZ2V0LCBudWxsLCBudWxsLCB7IHJlbW92ZVNoYXBlOiBmYWxzZSB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHVwZGF0ZSBkaSBpbmZvcm1hdGlvbiBvbiBsYWJlbCBjcmVhdGlvblxuICB0aGlzLnBvc3RFeGVjdXRlKFsgJ2xhYmVsLmNyZWF0ZScgXSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgZWxlbWVudCA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIGJ1c2luZXNzT2JqZWN0LFxuICAgICAgICBkaTtcblxuICAgIC8vIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiByZWFsIGxhYmVscyBvbmx5XG4gICAgaWYgKCFlbGVtZW50LmxhYmVsVGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGJvYXJkIGVsZW1lbnRzIG9ubHlcbiAgICBpZiAoIWlzKGVsZW1lbnQubGFiZWxUYXJnZXQgfHwgZWxlbWVudCwgJ3Bvc3RpdDpCb2FyZEVsZW1lbnQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJ1c2luZXNzT2JqZWN0ID0gZWxlbWVudC5idXNpbmVzc09iamVjdCxcbiAgICBkaSA9IGJ1c2luZXNzT2JqZWN0LmRpO1xuXG5cbiAgICBpZiAoIWRpLmxhYmVsKSB7XG4gICAgICBkaS5sYWJlbCA9IHBvc3RpdEZhY3RvcnkuY3JlYXRlKCdwb3N0aXREaTpQb3N0aXRMYWJlbCcsIHtcbiAgICAgICAgYm91bmRzOiBwb3N0aXRGYWN0b3J5LmNyZWF0ZSgnZGM6Qm91bmRzJylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzc2lnbihkaS5sYWJlbC5ib3VuZHMsIHtcbiAgICAgIHg6IGVsZW1lbnQueCxcbiAgICAgIHk6IGVsZW1lbnQueSxcbiAgICAgIHdpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodFxuICAgIH0pO1xuICB9KTtcblxuICBmdW5jdGlvbiBnZXRWaXNpYmxlTGFiZWxBZGp1c3RtZW50KGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICAgIGxhYmVsID0gY29ubmVjdGlvbi5sYWJlbCxcbiAgICAgICAgaGludHMgPSBhc3NpZ24oe30sIGNvbnRleHQuaGludHMpLFxuICAgICAgICBuZXdXYXlwb2ludHMgPSBjb250ZXh0Lm5ld1dheXBvaW50cyB8fCBjb25uZWN0aW9uLndheXBvaW50cyxcbiAgICAgICAgb2xkV2F5cG9pbnRzID0gY29udGV4dC5vbGRXYXlwb2ludHM7XG5cblxuICAgIGlmICh0eXBlb2YgaGludHMuc3RhcnRDaGFuZ2VkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaGludHMuc3RhcnRDaGFuZ2VkID0gISFoaW50cy5jb25uZWN0aW9uU3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoaW50cy5lbmRDaGFuZ2VkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaGludHMuZW5kQ2hhbmdlZCA9ICEhaGludHMuY29ubmVjdGlvbkVuZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0TGFiZWxBZGp1c3RtZW50KGxhYmVsLCBuZXdXYXlwb2ludHMsIG9sZFdheXBvaW50cywgaGludHMpO1xuICB9XG5cbiAgdGhpcy5wb3N0RXhlY3V0ZShbXG4gICAgJ2Nvbm5lY3Rpb24ubGF5b3V0JyxcbiAgICAnY29ubmVjdGlvbi51cGRhdGVXYXlwb2ludHMnXG4gIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBoaW50cyA9IGNvbnRleHQuaGludHMgfHwge307XG5cbiAgICBpZiAoaGludHMubGFiZWxCZWhhdmlvciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgICAgbGFiZWwgPSBjb25uZWN0aW9uLmxhYmVsLFxuICAgICAgICBsYWJlbEFkanVzdG1lbnQ7XG5cbiAgICAvLyBoYW5kbGUgbWlzc2luZyBsYWJlbCBhcyB3ZWxsIGFzIHRoZSBjYXNlXG4gICAgLy8gdGhhdCB0aGUgbGFiZWwgcGFyZW50IGRvZXMgbm90IGV4aXN0ICh5ZXQpLFxuICAgIC8vIGJlY2F1c2UgaXQgaXMgYmVpbmcgcGFzdGVkIC8gY3JlYXRlZCB2aWEgbXVsdGkgZWxlbWVudCBjcmVhdGVcbiAgICAvL1xuICAgIC8vIENmLiBodHRwczovL2dpdGh1Yi5jb20vYnBtbi1pby9icG1uLWpzL3B1bGwvMTIyN1xuICAgIGlmICghbGFiZWwgfHwgIWxhYmVsLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxhYmVsQWRqdXN0bWVudCA9IGdldFZpc2libGVMYWJlbEFkanVzdG1lbnQoZXZlbnQpO1xuXG4gICAgbW9kZWxpbmcubW92ZVNoYXBlKGxhYmVsLCBsYWJlbEFkanVzdG1lbnQpO1xuICB9KTtcblxuXG4gIC8vIGtlZXAgbGFiZWwgcG9zaXRpb24gb24gc2hhcGUgcmVwbGFjZVxuICB0aGlzLnBvc3RFeGVjdXRlKFsgJ3NoYXBlLnJlcGxhY2UnIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBuZXdTaGFwZSA9IGNvbnRleHQubmV3U2hhcGUsXG4gICAgICAgIG9sZFNoYXBlID0gY29udGV4dC5vbGRTaGFwZTtcblxuICAgIHZhciBidXNpbmVzc09iamVjdCA9IGdldEJ1c2luZXNzT2JqZWN0KG5ld1NoYXBlKTtcblxuICAgIGlmIChidXNpbmVzc09iamVjdFxuICAgICAgJiYgaXNMYWJlbEV4dGVybmFsKGJ1c2luZXNzT2JqZWN0KVxuICAgICAgJiYgb2xkU2hhcGUubGFiZWxcbiAgICAgICYmIG5ld1NoYXBlLmxhYmVsKSB7XG4gICAgICBuZXdTaGFwZS5sYWJlbC54ID0gb2xkU2hhcGUubGFiZWwueDtcbiAgICAgIG5ld1NoYXBlLmxhYmVsLnkgPSBvbGRTaGFwZS5sYWJlbC55O1xuICAgIH1cbiAgfSk7XG5cblxuICAvLyBtb3ZlIGV4dGVybmFsIGxhYmVsIGFmdGVyIHJlc2l6aW5nXG4gIHRoaXMucG9zdEV4ZWN1dGUoJ3NoYXBlLnJlc2l6ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgICAgbmV3Qm91bmRzID0gY29udGV4dC5uZXdCb3VuZHMsXG4gICAgICAgIG9sZEJvdW5kcyA9IGNvbnRleHQub2xkQm91bmRzO1xuXG4gICAgaWYgKGhhc0V4dGVybmFsTGFiZWwoc2hhcGUpKSB7XG5cbiAgICAgIHZhciBsYWJlbCA9IHNoYXBlLmxhYmVsLFxuICAgICAgICAgIGxhYmVsTWlkID0gZ2V0TWlkKGxhYmVsKSxcbiAgICAgICAgICBlZGdlcyA9IGFzRWRnZXMob2xkQm91bmRzKTtcblxuICAgICAgLy8gZ2V0IG5lYXJlc3QgYm9yZGVyIHBvaW50IHRvIGxhYmVsIGFzIHJlZmVyZW5jZSBwb2ludFxuICAgICAgdmFyIHJlZmVyZW5jZVBvaW50ID0gZ2V0UmVmZXJlbmNlUG9pbnQobGFiZWxNaWQsIGVkZ2VzKTtcblxuICAgICAgdmFyIGRlbHRhID0gZ2V0UmVmZXJlbmNlUG9pbnREZWx0YShyZWZlcmVuY2VQb2ludCwgb2xkQm91bmRzLCBuZXdCb3VuZHMpO1xuXG4gICAgICBtb2RlbGluZy5tb3ZlU2hhcGUobGFiZWwsIGRlbHRhKTtcblxuICAgIH1cblxuICB9KTtcblxufVxuXG5pbmhlcml0cyhMYWJlbEJlaGF2aW9yLCBDb21tYW5kSW50ZXJjZXB0b3IpO1xuXG5MYWJlbEJlaGF2aW9yLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdtb2RlbGluZycsXG4gICdwb3N0aXRGYWN0b3J5JyxcbiAgJ3RleHRSZW5kZXJlcidcbl07XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSByZWZlcmVuY2UgcG9pbnQgZGVsdGEgcmVsYXRpdmUgdG8gYSBuZXcgcG9zaXRpb25cbiAqIG9mIGEgY2VydGFpbiBlbGVtZW50J3MgYm91bmRzXG4gKlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAqIEBwYXJhbSB7Qm91bmRzfSBvbGRCb3VuZHNcbiAqIEBwYXJhbSB7Qm91bmRzfSBuZXdCb3VuZHNcbiAqXG4gKiBAcmV0dXJuIHtEZWx0YX0gZGVsdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlZmVyZW5jZVBvaW50RGVsdGEocmVmZXJlbmNlUG9pbnQsIG9sZEJvdW5kcywgbmV3Qm91bmRzKSB7XG5cbiAgdmFyIG5ld1JlZmVyZW5jZVBvaW50ID0gZ2V0TmV3QXR0YWNoUG9pbnQocmVmZXJlbmNlUG9pbnQsIG9sZEJvdW5kcywgbmV3Qm91bmRzKTtcblxuICByZXR1cm4gcm91bmRQb2ludChkZWx0YShuZXdSZWZlcmVuY2VQb2ludCwgcmVmZXJlbmNlUG9pbnQpKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIG5lYXJlc3QgcG9pbnQgKHJlZmVyZW5jZSBwb2ludCkgZm9yIGEgZ2l2ZW4gcG9pbnRcbiAqIG9udG8gZ2l2ZW4gc2V0IG9mIGxpbmVzXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludCwgUG9pbnQ+fSBsaW5lc1xuICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAqXG4gKiBAcGFyYW0ge1BvaW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlUG9pbnQocG9pbnQsIGxpbmVzKSB7XG5cbiAgaWYgKCFsaW5lcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmVhcmVzdExpbmUgPSBnZXROZWFyZXN0TGluZShwb2ludCwgbGluZXMpO1xuXG4gIHJldHVybiBwZXJwZW5kaWN1bGFyRm9vdChwb2ludCwgbmVhcmVzdExpbmUpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGJvdW5kcyB0byBhIGxpbmVzIGFycmF5IGNvbnRhaW5pbmcgYWxsIGVkZ2VzXG4gKlxuICogQHBhcmFtIHtCb3VuZHN8UG9pbnR9IGJvdW5kc1xuICpcbiAqIEByZXR1cm4gQXJyYXk8UG9pbnQ+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0VkZ2VzKGJvdW5kcykge1xuICByZXR1cm4gW1xuICAgIFsgLy8gdG9wXG4gICAgICB7XG4gICAgICAgIHg6IGJvdW5kcy54LFxuICAgICAgICB5OiBib3VuZHMueVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgeDogYm91bmRzLnggKyAoYm91bmRzLndpZHRoIHx8IDApLFxuICAgICAgICB5OiBib3VuZHMueVxuICAgICAgfVxuICAgIF0sXG4gICAgWyAvLyByaWdodFxuICAgICAge1xuICAgICAgICB4OiBib3VuZHMueCArIChib3VuZHMud2lkdGggfHwgMCksXG4gICAgICAgIHk6IGJvdW5kcy55XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB4OiBib3VuZHMueCArIChib3VuZHMud2lkdGggfHwgMCksXG4gICAgICAgIHk6IGJvdW5kcy55ICsgKGJvdW5kcy5oZWlnaHQgfHwgMClcbiAgICAgIH1cbiAgICBdLFxuICAgIFsgLy8gYm90dG9tXG4gICAgICB7XG4gICAgICAgIHg6IGJvdW5kcy54LFxuICAgICAgICB5OiBib3VuZHMueSArIChib3VuZHMuaGVpZ2h0IHx8IDApXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB4OiBib3VuZHMueCArIChib3VuZHMud2lkdGggfHwgMCksXG4gICAgICAgIHk6IGJvdW5kcy55ICsgKGJvdW5kcy5oZWlnaHQgfHwgMClcbiAgICAgIH1cbiAgICBdLFxuICAgIFsgLy8gbGVmdFxuICAgICAge1xuICAgICAgICB4OiBib3VuZHMueCxcbiAgICAgICAgeTogYm91bmRzLnlcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHg6IGJvdW5kcy54LFxuICAgICAgICB5OiBib3VuZHMueSArIChib3VuZHMuaGVpZ2h0IHx8IDApXG4gICAgICB9XG4gICAgXVxuICBdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5lYXJlc3QgbGluZSBmb3IgYSBnaXZlbiBwb2ludCBieSBkaXN0YW5jZVxuICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAqIEBwYXJhbSBBcnJheTxQb2ludD4gbGluZXNcbiAqXG4gKiBAcmV0dXJuIEFycmF5PFBvaW50PlxuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0TGluZShwb2ludCwgbGluZXMpIHtcblxuICB2YXIgZGlzdGFuY2VzID0gbGluZXMubWFwKGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbCxcbiAgICAgIGRpc3RhbmNlOiBnZXREaXN0YW5jZVBvaW50TGluZShwb2ludCwgbClcbiAgICB9O1xuICB9KTtcblxuICB2YXIgc29ydGVkID0gc29ydEJ5KGRpc3RhbmNlcywgJ2Rpc3RhbmNlJyk7XG5cbiAgcmV0dXJuIHNvcnRlZFswXS5saW5lO1xufVxuIiwiaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IENvbW1hbmRJbnRlcmNlcHRvciBmcm9tICdkaWFncmFtLWpzL2xpYi9jb21tYW5kL0NvbW1hbmRJbnRlcmNlcHRvcic7XG5cblxuLyoqXG4gKiBwb3N0aXQtc3BlY2lmaWMgcmVwbGFjZSBiZWhhdmlvci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmVwbGFjZUVsZW1lbnRCZWhhdmlvdXIoXG4gICAgcG9zdGl0UmVwbGFjZSxcbiAgICBwb3N0aXRSdWxlcyxcbiAgICBlbGVtZW50UmVnaXN0cnksXG4gICAgaW5qZWN0b3IsXG4gICAgbW9kZWxpbmcsXG4gICAgc2VsZWN0aW9uXG4pIHtcbiAgaW5qZWN0b3IuaW52b2tlKENvbW1hbmRJbnRlcmNlcHRvciwgdGhpcyk7XG5cbiAgdGhpcy5fcG9zdGl0UmVwbGFjZSA9IHBvc3RpdFJlcGxhY2U7XG4gIHRoaXMuX2VsZW1lbnRSZWdpc3RyeSA9IGVsZW1lbnRSZWdpc3RyeTtcbiAgdGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuXG4gIC8vIHJlcGxhY2UgZWxlbWVudHMgb24gbW92ZVxuICB0aGlzLnBvc3RFeGVjdXRlZChbICdlbGVtZW50cy5tb3ZlJyBdLCA1MDAsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICB0YXJnZXQgPSBjb250ZXh0Lm5ld1BhcmVudCxcbiAgICAgICAgbmV3SG9zdCA9IGNvbnRleHQubmV3SG9zdCxcbiAgICAgICAgZWxlbWVudHMgPSBbXTtcblxuICAgIGZvckVhY2goY29udGV4dC5jbG9zdXJlLnRvcExldmVsLCBmdW5jdGlvbih0b3BMZXZlbEVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLmNvbmNhdCh0b3BMZXZlbEVsZW1lbnRzKTtcbiAgICB9KTtcblxuICAgIC8vIHNldCB0YXJnZXQgdG8gaG9zdCBpZiBhdHRhY2hpbmdcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAxICYmIG5ld0hvc3QpIHtcbiAgICAgIHRhcmdldCA9IG5ld0hvc3Q7XG4gICAgfVxuXG4gICAgdmFyIGNhblJlcGxhY2UgPSBwb3N0aXRSdWxlcy5jYW5SZXBsYWNlKGVsZW1lbnRzLCB0YXJnZXQpO1xuXG4gICAgaWYgKGNhblJlcGxhY2UpIHtcbiAgICAgIHRoaXMucmVwbGFjZUVsZW1lbnRzKGVsZW1lbnRzLCBjYW5SZXBsYWNlLnJlcGxhY2VtZW50cywgbmV3SG9zdCk7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICAvLyB1cGRhdGUgYXR0YWNobWVudHMgb24gaG9zdCByZXBsYWNlXG4gIHRoaXMucG9zdEV4ZWN1dGUoWyAnc2hhcGUucmVwbGFjZScgXSwgMTUwMCwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBvbGRTaGFwZSA9IGNvbnRleHQub2xkU2hhcGUsXG4gICAgICAgIG5ld1NoYXBlID0gY29udGV4dC5uZXdTaGFwZSxcbiAgICAgICAgYXR0YWNoZXJzID0gb2xkU2hhcGUuYXR0YWNoZXJzLFxuICAgICAgICBjYW5SZXBsYWNlO1xuXG4gICAgaWYgKGF0dGFjaGVycyAmJiBhdHRhY2hlcnMubGVuZ3RoKSB7XG4gICAgICBjYW5SZXBsYWNlID0gcG9zdGl0UnVsZXMuY2FuUmVwbGFjZShhdHRhY2hlcnMsIG5ld1NoYXBlKTtcblxuICAgICAgdGhpcy5yZXBsYWNlRWxlbWVudHMoYXR0YWNoZXJzLCBjYW5SZXBsYWNlLnJlcGxhY2VtZW50cyk7XG4gICAgfVxuXG4gIH0sIHRoaXMpO1xuXG4gIC8vIGtlZXAgSUQgb24gc2hhcGUgcmVwbGFjZVxuICB0aGlzLnBvc3RFeGVjdXRlZChbICdzaGFwZS5yZXBsYWNlJyBdLCAxNTAwLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNvbnRleHQgPSBlLmNvbnRleHQsXG4gICAgICAgIG9sZFNoYXBlID0gY29udGV4dC5vbGRTaGFwZSxcbiAgICAgICAgbmV3U2hhcGUgPSBjb250ZXh0Lm5ld1NoYXBlO1xuXG4gICAgbW9kZWxpbmcudW5jbGFpbUlkKG9sZFNoYXBlLmJ1c2luZXNzT2JqZWN0LmlkLCBvbGRTaGFwZS5idXNpbmVzc09iamVjdCk7XG4gICAgbW9kZWxpbmcudXBkYXRlUHJvcGVydGllcyhuZXdTaGFwZSwgeyBpZDogb2xkU2hhcGUuaWQgfSk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhSZXBsYWNlRWxlbWVudEJlaGF2aW91ciwgQ29tbWFuZEludGVyY2VwdG9yKTtcblxuUmVwbGFjZUVsZW1lbnRCZWhhdmlvdXIucHJvdG90eXBlLnJlcGxhY2VFbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBuZXdFbGVtZW50cykge1xuICB2YXIgZWxlbWVudFJlZ2lzdHJ5ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LFxuICAgICAgcG9zdGl0UmVwbGFjZSA9IHRoaXMuX3Bvc3RpdFJlcGxhY2UsXG4gICAgICBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb247XG5cbiAgZm9yRWFjaChuZXdFbGVtZW50cywgZnVuY3Rpb24ocmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IHtcbiAgICAgIHR5cGU6IHJlcGxhY2VtZW50Lm5ld0VsZW1lbnRUeXBlXG4gICAgfTtcblxuICAgIHZhciBvbGRFbGVtZW50ID0gZWxlbWVudFJlZ2lzdHJ5LmdldChyZXBsYWNlbWVudC5vbGRFbGVtZW50SWQpO1xuXG4gICAgdmFyIGlkeCA9IGVsZW1lbnRzLmluZGV4T2Yob2xkRWxlbWVudCk7XG5cbiAgICBlbGVtZW50c1tpZHhdID0gcG9zdGl0UmVwbGFjZS5yZXBsYWNlRWxlbWVudChvbGRFbGVtZW50LCBuZXdFbGVtZW50LCB7IHNlbGVjdDogZmFsc2UgfSk7XG4gIH0pO1xuXG4gIGlmIChuZXdFbGVtZW50cykge1xuICAgIHNlbGVjdGlvbi5zZWxlY3QoZWxlbWVudHMpO1xuICB9XG59O1xuXG5SZXBsYWNlRWxlbWVudEJlaGF2aW91ci4kaW5qZWN0ID0gW1xuICAncG9zdGl0UmVwbGFjZScsXG4gICdwb3N0aXRSdWxlcycsXG4gICdlbGVtZW50UmVnaXN0cnknLFxuICAnaW5qZWN0b3InLFxuICAnbW9kZWxpbmcnLFxuICAnc2VsZWN0aW9uJ1xuXTtcbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBDb21tYW5kSW50ZXJjZXB0b3IgZnJvbSAnZGlhZ3JhbS1qcy9saWIvY29tbWFuZC9Db21tYW5kSW50ZXJjZXB0b3InO1xuXG5pbXBvcnQgeyBpc0xhYmVsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9MYWJlbFV0aWwnO1xuXG5cbi8qKlxuICogVW5jbGFpbXMgbW9kZWwgSURzIG9uIGVsZW1lbnQgZGVsZXRpb24uXG4gKlxuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtJbmplY3Rvcn0gaW5qZWN0b3JcbiAqIEBwYXJhbSB7TW9kZGxlfSBtb2RkbGVcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFVuY2xhaW1JZEJlaGF2aW9yKGNhbnZhcywgaW5qZWN0b3IsIG1vZGRsZSwgbW9kZWxpbmcpIHtcbiAgaW5qZWN0b3IuaW52b2tlKENvbW1hbmRJbnRlcmNlcHRvciwgdGhpcyk7XG5cbiAgdGhpcy5wcmVFeGVjdXRlKCdzaGFwZS5kZWxldGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBzaGFwZUJvID0gc2hhcGUuYnVzaW5lc3NPYmplY3Q7XG5cbiAgICBpZiAoaXNMYWJlbChzaGFwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtb2RlbGluZy51bmNsYWltSWQoc2hhcGVCby5pZCwgc2hhcGVCbyk7XG4gIH0pO1xuXG4gIHRoaXMucHJlRXhlY3V0ZSgnY2FudmFzLnVwZGF0ZVJvb3QnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgcm9vdEVsZW1lbnQgPSBjYW52YXMuZ2V0Um9vdEVsZW1lbnQoKSxcbiAgICAgICAgcm9vdEVsZW1lbnRCbyA9IHJvb3RFbGVtZW50LmJ1c2luZXNzT2JqZWN0O1xuXG4gICAgbW9kZGxlLmlkcy51bmNsYWltKHJvb3RFbGVtZW50Qm8uaWQpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoVW5jbGFpbUlkQmVoYXZpb3IsIENvbW1hbmRJbnRlcmNlcHRvcik7XG5cblVuY2xhaW1JZEJlaGF2aW9yLiRpbmplY3QgPSBbICdjYW52YXMnLCAnaW5qZWN0b3InLCAnbW9kZGxlJywgJ21vZGVsaW5nJyBdOyIsImltcG9ydCBBZGFwdGl2ZUxhYmVsUG9zaXRpb25pbmdCZWhhdmlvciBmcm9tICcuL0FkYXB0aXZlTGFiZWxQb3NpdGlvbmluZ0JlaGF2aW9yJztcbmltcG9ydCBBcHBlbmRCZWhhdmlvciBmcm9tICcuL0FwcGVuZEJlaGF2aW9yJztcbmltcG9ydCBGaXhIb3ZlckJlaGF2aW9yIGZyb20gJy4vRml4SG92ZXJCZWhhdmlvcic7XG5pbXBvcnQgSW1wb3J0RG9ja2luZ0ZpeCBmcm9tICcuL0ltcG9ydERvY2tpbmdGaXgnO1xuaW1wb3J0IExhYmVsQmVoYXZpb3IgZnJvbSAnLi9MYWJlbEJlaGF2aW9yJztcbmltcG9ydCBSZXBsYWNlRWxlbWVudEJlaGF2aW91ciBmcm9tICcuL1JlcGxhY2VFbGVtZW50QmVoYXZpb3VyJztcbmltcG9ydCBVbmNsYWltSWRCZWhhdmlvciBmcm9tICcuL1VuY2xhaW1JZEJlaGF2aW9yJztcbmltcG9ydCBDcmVhdGVCb2FyZEVsZW1lbnRCZWhhdmlvciBmcm9tICcuL0NyZWF0ZUJvYXJkRWxlbWVudEJlaGF2aW9yJztcbmltcG9ydCBFbXB0eVRleHRCb3hCZWhhdmlvciBmcm9tICcuL0VtcHR5VGV4dEJveEJlaGF2aW9yJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogW1xuICAgICdhZGFwdGl2ZUxhYmVsUG9zaXRpb25pbmdCZWhhdmlvcicsXG4gICAgJ2FwcGVuZEJlaGF2aW9yJyxcbiAgICAnZml4SG92ZXJCZWhhdmlvcicsXG4gICAgJ2ltcG9ydERvY2tpbmdGaXgnLFxuICAgICdsYWJlbEJlaGF2aW9yJyxcbiAgICAncmVwbGFjZUVsZW1lbnRCZWhhdmlvdXInLFxuICAgICd1bmNsYWltSWRCZWhhdmlvcicsXG4gICAgJ2NyZWF0ZUJvYXJkRWxlbWVudEJlaGF2aW9yJyxcbiAgICAnZW1wdHlUZXh0Qm94QmVoYXZpb3InXG4gIF0sXG4gIGFkYXB0aXZlTGFiZWxQb3NpdGlvbmluZ0JlaGF2aW9yOiBbICd0eXBlJywgQWRhcHRpdmVMYWJlbFBvc2l0aW9uaW5nQmVoYXZpb3IgXSxcbiAgYXBwZW5kQmVoYXZpb3I6IFsgJ3R5cGUnLCBBcHBlbmRCZWhhdmlvciBdLFxuICBmaXhIb3ZlckJlaGF2aW9yOiBbICd0eXBlJywgRml4SG92ZXJCZWhhdmlvciBdLFxuICBpbXBvcnREb2NraW5nRml4OiBbICd0eXBlJywgSW1wb3J0RG9ja2luZ0ZpeCBdLFxuICBsYWJlbEJlaGF2aW9yOiBbICd0eXBlJywgTGFiZWxCZWhhdmlvciBdLFxuICByZXBsYWNlRWxlbWVudEJlaGF2aW91cjogWyAndHlwZScsIFJlcGxhY2VFbGVtZW50QmVoYXZpb3VyIF0sXG4gIHVuY2xhaW1JZEJlaGF2aW9yOiBbICd0eXBlJywgVW5jbGFpbUlkQmVoYXZpb3IgXSxcbiAgY3JlYXRlQm9hcmRFbGVtZW50QmVoYXZpb3I6IFsgJ3R5cGUnLCBDcmVhdGVCb2FyZEVsZW1lbnRCZWhhdmlvciBdLFxuICBlbXB0eVRleHRCb3hCZWhhdmlvcjogWyAndHlwZScsIEVtcHR5VGV4dEJveEJlaGF2aW9yIF1cbn07XG4iLCIvKipcbiAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7VmVjdG9yfVxuICogQHJldHVybiB7RmxvYXR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWN0b3JMZW5ndGgodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHYueCwgMikgKyBNYXRoLnBvdyh2LnksIDIpKTtcbn1cblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFuZ2xlIGJldHdlZW4gYSBsaW5lIGEgdGhlIHlBeGlzXG4gKlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm4ge0Zsb2F0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW5nbGUobGluZSkge1xuXG4gIC8vIHJldHVybiB2YWx1ZSBpcyBiZXR3ZWVuIDAsIDE4MCBhbmQgLTE4MCwgLTBcbiAgLy8gQGphbnN0dWVtbWVsOiBtYXliZSByZXBsYWNlIHJldHVybiBhL2Igd2l0aCBiL2FcbiAgcmV0dXJuIE1hdGguYXRhbigobGluZVsxXS55IC0gbGluZVswXS55KSAvIChsaW5lWzFdLnggLSBsaW5lWzBdLngpKTtcbn1cblxuXG4vKipcbiAqIFJvdGF0ZXMgYSB2ZWN0b3IgYnkgYSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7VmVjdG9yfVxuICogQHBhcmFtIHtGbG9hdH0gQW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybiB7VmVjdG9yfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlVmVjdG9yKHZlY3RvciwgYW5nbGUpIHtcbiAgcmV0dXJuICghYW5nbGUpID8gdmVjdG9yIDoge1xuICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIHZlY3Rvci54IC0gTWF0aC5zaW4oYW5nbGUpICogdmVjdG9yLnksXG4gICAgeTogTWF0aC5zaW4oYW5nbGUpICogdmVjdG9yLnggKyBNYXRoLmNvcyhhbmdsZSkgKiB2ZWN0b3IueVxuICB9O1xufVxuXG5cbi8qKlxuICogU29sdmVzIGEgMkQgZXF1YXRpb24gc3lzdGVtXG4gKiBhICsgcipiID0gYywgd2hlcmUgYSxiLGMgYXJlIDJEIHZlY3RvcnNcbiAqXG4gKiBAcGFyYW0ge1ZlY3Rvcn1cbiAqIEBwYXJhbSB7VmVjdG9yfVxuICogQHBhcmFtIHtWZWN0b3J9XG4gKiBAcmV0dXJuIHtGbG9hdH1cbiAqL1xuZnVuY3Rpb24gc29sdmVMYW1iYVN5c3RlbShhLCBiLCBjKSB7XG5cbiAgLy8gdGhlIDJkIHN5c3RlbVxuICB2YXIgc3lzdGVtID0gW1xuICAgIHsgbjogYVswXSAtIGNbMF0sIGxhbWJkYTogYlswXSB9LFxuICAgIHsgbjogYVsxXSAtIGNbMV0sIGxhbWJkYTogYlsxXSB9XG4gIF07XG5cbiAgLy8gc29sdmVcbiAgdmFyIG4gPSBzeXN0ZW1bMF0ubiAqIGJbMF0gKyBzeXN0ZW1bMV0ubiAqIGJbMV0sXG4gICAgICBsID0gc3lzdGVtWzBdLmxhbWJkYSAqIGJbMF0gKyBzeXN0ZW1bMV0ubGFtYmRhICogYlsxXTtcblxuICByZXR1cm4gLW4vbDtcbn1cblxuXG4vKipcbiAqIFBvc2l0aW9uIG9mIHBlcnBlbmRpY3VsYXIgZm9vdFxuICpcbiAqIEBwYXJhbSB7UG9pbnR9XG4gKiBAcGFyYW0gWyB7UG9pbnR9LCB7UG9pbnR9IF0gbGluZSBkZWZpbmVkIHRocm91Z2ggdHdvIHBvaW50c1xuICogQHJldHVybiB7UG9pbnR9IHRoZSBwZXJwZW5kaWN1bGFyIGZvb3QgcG9zaXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBlcnBlbmRpY3VsYXJGb290KHBvaW50LCBsaW5lKSB7XG5cbiAgdmFyIGEgPSBsaW5lWzBdLCBiID0gbGluZVsxXTtcblxuICAvLyByZWxhdGl2ZSBwb3NpdGlvbiBvZiBiIGZyb20gYVxuICB2YXIgYmQgPSB7IHg6IGIueCAtIGEueCwgeTogYi55IC0gYS55IH07XG5cbiAgLy8gc29sdmUgZXF1YXRpb24gc3lzdGVtIHRvIHRoZSBwYXJhbWV0cml6ZWQgdmVjdG9ycyBwYXJhbSByZWFsIHZhbHVlXG4gIHZhciByID0gc29sdmVMYW1iYVN5c3RlbShbIGEueCwgYS55IF0sIFsgYmQueCwgYmQueSBdLCBbIHBvaW50LngsIHBvaW50LnkgXSk7XG5cbiAgcmV0dXJuIHsgeDogYS54ICsgcipiZC54LCB5OiBhLnkgKyByKmJkLnkgfTtcbn1cblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCBhbmQgYSBsaW5lXG4gKlxuICogQHBhcmFtIHtQb2ludH1cbiAqIEBwYXJhbSBbIHtQb2ludH0sIHtQb2ludH0gXSBsaW5lIGRlZmluZWQgdGhyb3VnaCB0d28gcG9pbnRzXG4gKiBAcmV0dXJuIHtGbG9hdH0gZGlzdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlUG9pbnRMaW5lKHBvaW50LCBsaW5lKSB7XG5cbiAgdmFyIHBmUG9pbnQgPSBwZXJwZW5kaWN1bGFyRm9vdChwb2ludCwgbGluZSk7XG5cbiAgLy8gZGlzdGFuY2UgdmVjdG9yXG4gIHZhciBjb25uZWN0aW9uVmVjdG9yID0ge1xuICAgIHg6IHBmUG9pbnQueCAtIHBvaW50LngsXG4gICAgeTogcGZQb2ludC55IC0gcG9pbnQueVxuICB9O1xuXG4gIHJldHVybiB2ZWN0b3JMZW5ndGgoY29ubmVjdGlvblZlY3Rvcik7XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge1BvaW50fVxuICogQHBhcmFtIHtQb2ludH1cbiAqIEByZXR1cm4ge0Zsb2F0fSBkaXN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdGFuY2VQb2ludFBvaW50KHBvaW50MSwgcG9pbnQyKSB7XG5cbiAgcmV0dXJuIHZlY3Rvckxlbmd0aCh7XG4gICAgeDogcG9pbnQxLnggLSBwb2ludDIueCxcbiAgICB5OiBwb2ludDEueSAtIHBvaW50Mi55XG4gIH0pO1xufSIsImltcG9ydCB7XG4gIGdldERpc3RhbmNlUG9pbnRQb2ludCxcbiAgcm90YXRlVmVjdG9yLFxuICBnZXRBbmdsZVxufSBmcm9tICcuL0dlb21ldHJpY1V0aWwnO1xuXG5pbXBvcnQge1xuICBnZXRBdHRhY2htZW50XG59IGZyb20gJy4vTGluZUF0dGFjaG1lbnRVdGlsJztcblxuaW1wb3J0IHtcbiAgcm91bmRQb2ludFxufSBmcm9tICdkaWFncmFtLWpzL2xpYi9sYXlvdXQvTGF5b3V0VXRpbCc7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmROZXdMYWJlbExpbmVTdGFydEluZGV4KG9sZFdheXBvaW50cywgbmV3V2F5cG9pbnRzLCBhdHRhY2htZW50LCBoaW50cykge1xuXG4gIHZhciBpbmRleCA9IGF0dGFjaG1lbnQuc2VnbWVudEluZGV4O1xuXG4gIHZhciBvZmZzZXQgPSBuZXdXYXlwb2ludHMubGVuZ3RoIC0gb2xkV2F5cG9pbnRzLmxlbmd0aDtcblxuICAvLyBzZWdtZW50TW92ZSBoYXBwZW5lZFxuICBpZiAoaGludHMuc2VnbWVudE1vdmUpIHtcblxuICAgIHZhciBvbGRTZWdtZW50U3RhcnRJbmRleCA9IGhpbnRzLnNlZ21lbnRNb3ZlLnNlZ21lbnRTdGFydEluZGV4LFxuICAgICAgICBuZXdTZWdtZW50U3RhcnRJbmRleCA9IGhpbnRzLnNlZ21lbnRNb3ZlLm5ld1NlZ21lbnRTdGFydEluZGV4O1xuXG4gICAgLy8gaWYgbGFiZWwgd2FzIG9uIG1vdmVkIHNlZ21lbnQgcmV0dXJuIG5ldyBzZWdtZW50IGluZGV4XG4gICAgaWYgKGluZGV4ID09PSBvbGRTZWdtZW50U3RhcnRJbmRleCkge1xuICAgICAgcmV0dXJuIG5ld1NlZ21lbnRTdGFydEluZGV4O1xuICAgIH1cblxuICAgIC8vIGxhYmVsIGlzIGFmdGVyIG5ldyBzZWdtZW50IGluZGV4XG4gICAgaWYgKGluZGV4ID49IG5ld1NlZ21lbnRTdGFydEluZGV4KSB7XG4gICAgICByZXR1cm4gKGluZGV4K29mZnNldCA8IG5ld1NlZ21lbnRTdGFydEluZGV4KSA/IG5ld1NlZ21lbnRTdGFydEluZGV4IDogaW5kZXgrb2Zmc2V0O1xuICAgIH1cblxuICAgIC8vIGlmIGxhYmVsIGlzIGJlZm9yZSBuZXcgc2VnbWVudCBpbmRleFxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8vIGJlbmRwb2ludE1vdmUgaGFwcGVuZWRcbiAgaWYgKGhpbnRzLmJlbmRwb2ludE1vdmUpIHtcblxuICAgIHZhciBpbnNlcnQgPSBoaW50cy5iZW5kcG9pbnRNb3ZlLmluc2VydCxcbiAgICAgICAgYmVuZHBvaW50SW5kZXggPSBoaW50cy5iZW5kcG9pbnRNb3ZlLmJlbmRwb2ludEluZGV4LFxuICAgICAgICBuZXdJbmRleDtcblxuICAgIC8vIHdheXBvaW50cyBsZW5ndGggZGlkbnQgY2hhbmdlXG4gICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cblxuICAgIC8vIGxhYmVsIGJlaGluZCBuZXcvcmVtb3ZlZCBiZW5kcG9pbnRcbiAgICBpZiAoaW5kZXggPj0gYmVuZHBvaW50SW5kZXgpIHtcbiAgICAgIG5ld0luZGV4ID0gaW5zZXJ0ID8gaW5kZXggKyAxIDogaW5kZXggLSAxO1xuICAgIH1cblxuICAgIC8vIGxhYmVsIGJlZm9yZSBuZXcvcmVtb3ZlZCBiZW5kcG9pbnRcbiAgICBpZiAoaW5kZXggPCBiZW5kcG9pbnRJbmRleCkge1xuXG4gICAgICBuZXdJbmRleCA9IGluZGV4O1xuXG4gICAgICAvLyBkZWNpZGUgbGFiZWwgc2hvdWxkIHRha2UgcmlnaHQgb3IgbGVmdCBzZWdtZW50XG4gICAgICBpZiAoaW5zZXJ0ICYmIGF0dGFjaG1lbnQudHlwZSAhPT0gJ2JlbmRwb2ludCcgJiYgYmVuZHBvaW50SW5kZXgtMSA9PT0gaW5kZXgpIHtcblxuICAgICAgICB2YXIgcmVsID0gcmVsYXRpdmVQb3NpdGlvbk1pZFdheXBvaW50KG5ld1dheXBvaW50cywgYmVuZHBvaW50SW5kZXgpO1xuXG4gICAgICAgIGlmIChyZWwgPCBhdHRhY2htZW50LnJlbGF0aXZlTG9jYXRpb24pIHtcbiAgICAgICAgICBuZXdJbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0luZGV4O1xuICB9XG5cbiAgLy8gc3RhcnQvZW5kIGNoYW5nZWRcbiAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIGlmIChoaW50cy5jb25uZWN0aW9uU3RhcnQpIHtcbiAgICByZXR1cm4gKGluZGV4ID09PSAwKSA/IDAgOiBudWxsO1xuICB9XG5cbiAgaWYgKGhpbnRzLmNvbm5lY3Rpb25FbmQpIHtcbiAgICByZXR1cm4gKGluZGV4ID09PSBvbGRXYXlwb2ludHMubGVuZ3RoIC0gMikgPyBuZXdXYXlwb2ludHMubGVuZ3RoIC0gMiA6IG51bGw7XG4gIH1cblxuICAvLyBpZiBub3RoaW5nIGZpdHMsIHJldHVybiBudWxsXG4gIHJldHVybiBudWxsO1xufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSByZXF1aXJlZCBhZGp1c3RtZW50IChtb3ZlIGRlbHRhKSBmb3IgdGhlIGdpdmVuIGxhYmVsXG4gKiBhZnRlciB0aGUgY29ubmVjdGlvbiB3YXlwb2ludHMgZ290IHVwZGF0ZWQuXG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuTGFiZWx9IGxhYmVsXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gbmV3V2F5cG9pbnRzXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gb2xkV2F5cG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gaGludHNcbiAqXG4gKiBAcmV0dXJuIHtQb2ludH0gZGVsdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhYmVsQWRqdXN0bWVudChsYWJlbCwgbmV3V2F5cG9pbnRzLCBvbGRXYXlwb2ludHMsIGhpbnRzKSB7XG5cbiAgdmFyIHggPSAwLFxuICAgICAgeSA9IDA7XG5cbiAgdmFyIGxhYmVsUG9zaXRpb24gPSBnZXRMYWJlbE1pZChsYWJlbCk7XG5cbiAgLy8gZ2V0IGNsb3Nlc3QgYXR0YWNobWVudFxuICB2YXIgYXR0YWNobWVudCA9IGdldEF0dGFjaG1lbnQobGFiZWxQb3NpdGlvbiwgb2xkV2F5cG9pbnRzKSxcbiAgICAgIG9sZExhYmVsTGluZUluZGV4ID0gYXR0YWNobWVudC5zZWdtZW50SW5kZXgsXG4gICAgICBuZXdMYWJlbExpbmVJbmRleCA9IGZpbmROZXdMYWJlbExpbmVTdGFydEluZGV4KG9sZFdheXBvaW50cywgbmV3V2F5cG9pbnRzLCBhdHRhY2htZW50LCBoaW50cyk7XG5cbiAgaWYgKG5ld0xhYmVsTGluZUluZGV4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICB9XG5cbiAgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAvLyBUT0RPKEBqYW5zdHVlbW1lbCk6IHRocm93IGFuIGVycm9yIGhlcmUgd2hlbiBjb25uZWN0aW9uU2VnbWVudE1vdmUgaXMgcmVmYWN0b3JlZFxuICBpZiAobmV3TGFiZWxMaW5lSW5kZXggPCAwIHx8XG4gICAgICBuZXdMYWJlbExpbmVJbmRleCA+IG5ld1dheXBvaW50cy5sZW5ndGggLSAyKSB7XG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICB9XG5cbiAgdmFyIG9sZExhYmVsTGluZSA9IGdldExpbmUob2xkV2F5cG9pbnRzLCBvbGRMYWJlbExpbmVJbmRleCksXG4gICAgICBuZXdMYWJlbExpbmUgPSBnZXRMaW5lKG5ld1dheXBvaW50cywgbmV3TGFiZWxMaW5lSW5kZXgpLFxuICAgICAgb2xkRm9vdCA9IGF0dGFjaG1lbnQucG9zaXRpb247XG5cbiAgdmFyIHJlbGF0aXZlRm9vdFBvc2l0aW9uID0gZ2V0UmVsYXRpdmVGb290UG9zaXRpb24ob2xkTGFiZWxMaW5lLCBvbGRGb290KSxcbiAgICAgIGFuZ2xlRGVsdGEgPSBnZXRBbmdsZURlbHRhKG9sZExhYmVsTGluZSwgbmV3TGFiZWxMaW5lKTtcblxuICAvLyBzcGVjaWFsIHJ1bGUgaWYgbGFiZWwgb24gYmVuZHBvaW50XG4gIGlmIChhdHRhY2htZW50LnR5cGUgPT09ICdiZW5kcG9pbnQnKSB7XG5cbiAgICB2YXIgb2Zmc2V0ID0gbmV3V2F5cG9pbnRzLmxlbmd0aCAtIG9sZFdheXBvaW50cy5sZW5ndGgsXG4gICAgICAgIG9sZEJlbmRwb2ludEluZGV4ID0gYXR0YWNobWVudC5iZW5kcG9pbnRJbmRleCxcbiAgICAgICAgb2xkQmVuZHBvaW50ID0gb2xkV2F5cG9pbnRzW29sZEJlbmRwb2ludEluZGV4XTtcblxuICAgIC8vIGJlbmRwb2ludCBwb3NpdGlvbiBoYXNuJ3QgY2hhbmdlZCwgcmV0dXJuIHNhbWUgcG9zaXRpb25cbiAgICBpZiAobmV3V2F5cG9pbnRzLmluZGV4T2Yob2xkQmVuZHBvaW50KSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgICB9XG5cbiAgICAvLyBuZXcgYmVuZHBvaW50IGFuZCBvbGQgYmVuZHBvaW50IGhhdmUgc2FtZSBpbmRleCwgdGhlbiBqdXN0IHJldHVybiB0aGUgb2Zmc2V0XG4gICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgdmFyIG5ld0JlbmRwb2ludCA9IG5ld1dheXBvaW50c1tvbGRCZW5kcG9pbnRJbmRleF07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IG5ld0JlbmRwb2ludC54IC0gYXR0YWNobWVudC5wb3NpdGlvbi54LFxuICAgICAgICB5OiBuZXdCZW5kcG9pbnQueSAtIGF0dGFjaG1lbnQucG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBpZiBiZW5kcG9pbnRzIGdldCByZW1vdmVkXG4gICAgaWYgKG9mZnNldCA8IDAgJiYgb2xkQmVuZHBvaW50SW5kZXggIT09IDAgJiYgb2xkQmVuZHBvaW50SW5kZXggPCBvbGRXYXlwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgcmVsYXRpdmVGb290UG9zaXRpb24gPSByZWxhdGl2ZVBvc2l0aW9uTWlkV2F5cG9pbnQob2xkV2F5cG9pbnRzLCBvbGRCZW5kcG9pbnRJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0Zvb3QgPSB7XG4gICAgeDogKG5ld0xhYmVsTGluZVsxXS54IC0gbmV3TGFiZWxMaW5lWzBdLngpICogcmVsYXRpdmVGb290UG9zaXRpb24gKyBuZXdMYWJlbExpbmVbMF0ueCxcbiAgICB5OiAobmV3TGFiZWxMaW5lWzFdLnkgLSBuZXdMYWJlbExpbmVbMF0ueSkgKiByZWxhdGl2ZUZvb3RQb3NpdGlvbiArIG5ld0xhYmVsTGluZVswXS55XG4gIH07XG5cbiAgLy8gdGhlIHJvdGF0ZWQgdmVjdG9yIHRvIGxhYmVsXG4gIHZhciBuZXdMYWJlbFZlY3RvciA9IHJvdGF0ZVZlY3Rvcih7XG4gICAgeDogbGFiZWxQb3NpdGlvbi54IC0gb2xkRm9vdC54LFxuICAgIHk6IGxhYmVsUG9zaXRpb24ueSAtIG9sZEZvb3QueVxuICB9LCBhbmdsZURlbHRhKTtcblxuICAvLyB0aGUgbmV3IHJlbGF0aXZlIHBvc2l0aW9uXG4gIHggPSBuZXdGb290LnggKyBuZXdMYWJlbFZlY3Rvci54IC0gbGFiZWxQb3NpdGlvbi54O1xuICB5ID0gbmV3Rm9vdC55ICsgbmV3TGFiZWxWZWN0b3IueSAtIGxhYmVsUG9zaXRpb24ueTtcblxuICByZXR1cm4gcm91bmRQb2ludCh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pO1xufVxuXG5cbi8vIEhFTFBFUlMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiByZWxhdGl2ZVBvc2l0aW9uTWlkV2F5cG9pbnQod2F5cG9pbnRzLCBpZHgpIHtcblxuICB2YXIgZGlzdGFuY2VTZWdtZW50MSA9IGdldERpc3RhbmNlUG9pbnRQb2ludCh3YXlwb2ludHNbaWR4LTFdLCB3YXlwb2ludHNbaWR4XSksXG4gICAgICBkaXN0YW5jZVNlZ21lbnQyID0gZ2V0RGlzdGFuY2VQb2ludFBvaW50KHdheXBvaW50c1tpZHhdLCB3YXlwb2ludHNbaWR4KzFdKTtcblxuICB2YXIgcmVsYXRpdmVQb3NpdGlvbiA9IGRpc3RhbmNlU2VnbWVudDEgLyAoZGlzdGFuY2VTZWdtZW50MSArIGRpc3RhbmNlU2VnbWVudDIpO1xuXG4gIHJldHVybiByZWxhdGl2ZVBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRMYWJlbE1pZChsYWJlbCkge1xuICByZXR1cm4ge1xuICAgIHg6IGxhYmVsLnggKyBsYWJlbC53aWR0aCAvIDIsXG4gICAgeTogbGFiZWwueSArIGxhYmVsLmhlaWdodCAvIDJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QW5nbGVEZWx0YShsMSwgbDIpIHtcbiAgdmFyIGExID0gZ2V0QW5nbGUobDEpLFxuICAgICAgYTIgPSBnZXRBbmdsZShsMik7XG4gIHJldHVybiBhMiAtIGExO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lKHdheXBvaW50cywgaWR4KSB7XG4gIHJldHVybiBbIHdheXBvaW50c1tpZHhdLCB3YXlwb2ludHNbaWR4KzFdIF07XG59XG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlRm9vdFBvc2l0aW9uKGxpbmUsIGZvb3QpIHtcblxuICB2YXIgbGVuZ3RoID0gZ2V0RGlzdGFuY2VQb2ludFBvaW50KGxpbmVbMF0sIGxpbmVbMV0pLFxuICAgICAgbGVuZ3RoVG9Gb290ID0gZ2V0RGlzdGFuY2VQb2ludFBvaW50KGxpbmVbMF0sIGZvb3QpO1xuXG4gIHJldHVybiBsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoVG9Gb290IC8gbGVuZ3RoO1xufVxuIiwidmFyIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgbWluID0gTWF0aC5taW4sXG4gICAgbWF4ID0gTWF0aC5tYXgsXG4gICAgYWJzID0gTWF0aC5hYnM7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzcXVhcmUgKHBvd2VyIHRvIHR3bykgb2YgYSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHNxKG4pIHtcbiAgcmV0dXJuIE1hdGgucG93KG4sIDIpO1xufVxuXG4vKipcbiAqIEdldCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gcDFcbiAqIEBwYXJhbSB7UG9pbnR9IHAyXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIpIHtcbiAgcmV0dXJuIHNxcnQoc3EocDEueCAtIHAyLngpICsgc3EocDEueSAtIHAyLnkpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGF0dGFjaG1lbnQgb2YgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBzcGVjaWZpZWQgbGluZS5cbiAqXG4gKiBUaGUgYXR0YWNobWVudCBpcyBlaXRoZXIgYSBiZW5kcG9pbnQgKGF0dGFjaGVkIHRvIHRoZSBnaXZlbiBwb2ludClcbiAqIG9yIHNlZ21lbnQgKGF0dGFjaGVkIHRvIGEgbG9jYXRpb24gb24gYSBsaW5lIHNlZ21lbnQpIGF0dGFjaG1lbnQ6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBvaW50QXR0YWNobWVudCA9IHtcbiAqICAgdHlwZTogJ2JlbmRwb2ludCcsXG4gKiAgIGJlbmRwb2ludEluZGV4OiAzLFxuICogICBwb3NpdGlvbjogeyB4OiAxMCwgeTogMTAgfSAvLyB0aGUgYXR0YWNoIHBvaW50IG9uIHRoZSBsaW5lXG4gKiB9O1xuICpcbiAqIHZhciBzZWdtZW50QXR0YWNobWVudCA9IHtcbiAqICAgdHlwZTogJ3NlZ21lbnQnLFxuICogICBzZWdtZW50SW5kZXg6IDIsXG4gKiAgIHJlbGF0aXZlTG9jYXRpb246IDAuMzEsIC8vIGF0dGFjaCBwb2ludCBsb2NhdGlvbiBiZXR3ZWVuIDAgKGF0IHN0YXJ0KSBhbmQgMSAoYXQgZW5kKVxuICogICBwb3NpdGlvbjogeyB4OiAxMCwgeTogMTAgfSAvLyB0aGUgYXR0YWNoIHBvaW50IG9uIHRoZSBsaW5lXG4gKiB9O1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBsaW5lXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBhdHRhY2htZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRhY2htZW50KHBvaW50LCBsaW5lKSB7XG5cbiAgdmFyIGlkeCA9IDAsXG4gICAgICBzZWdtZW50U3RhcnQsXG4gICAgICBzZWdtZW50RW5kLFxuICAgICAgc2VnbWVudFN0YXJ0RGlzdGFuY2UsXG4gICAgICBzZWdtZW50RW5kRGlzdGFuY2UsXG4gICAgICBhdHRhY2htZW50UG9zaXRpb24sXG4gICAgICBtaW5EaXN0YW5jZSxcbiAgICAgIGludGVyc2VjdGlvbnMsXG4gICAgICBhdHRhY2htZW50LFxuICAgICAgYXR0YWNobWVudERpc3RhbmNlLFxuICAgICAgY2xvc2VzdEF0dGFjaG1lbnREaXN0YW5jZSxcbiAgICAgIGNsb3Nlc3RBdHRhY2htZW50O1xuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbGluZS5sZW5ndGggLSAxOyBpZHgrKykge1xuXG4gICAgc2VnbWVudFN0YXJ0ID0gbGluZVtpZHhdO1xuICAgIHNlZ21lbnRFbmQgPSBsaW5lW2lkeCArIDFdO1xuXG4gICAgaWYgKHBvaW50c0VxdWFsKHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCkpIHtcbiAgICAgIGludGVyc2VjdGlvbnMgPSBbIHNlZ21lbnRTdGFydCBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWdtZW50U3RhcnREaXN0YW5jZSA9IGdldERpc3RhbmNlKHBvaW50LCBzZWdtZW50U3RhcnQpO1xuICAgICAgc2VnbWVudEVuZERpc3RhbmNlID0gZ2V0RGlzdGFuY2UocG9pbnQsIHNlZ21lbnRFbmQpO1xuXG4gICAgICBtaW5EaXN0YW5jZSA9IG1pbihzZWdtZW50U3RhcnREaXN0YW5jZSwgc2VnbWVudEVuZERpc3RhbmNlKTtcblxuICAgICAgaW50ZXJzZWN0aW9ucyA9IGdldENpcmNsZVNlZ21lbnRJbnRlcnNlY3Rpb25zKHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCwgcG9pbnQsIG1pbkRpc3RhbmNlKTtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGJldHdlZW4gWzEsIDJdIGNpcmNsZSAtPiBsaW5lIGludGVyc2VjdGlvbnMnKTtcbiAgICB9XG5cbiAgICAvLyBvbmUgaW50ZXJzZWN0aW9uIC0+IGJlbmRwb2ludCBhdHRhY2htZW50XG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBhdHRhY2htZW50ID0ge1xuICAgICAgICB0eXBlOiAnYmVuZHBvaW50JyxcbiAgICAgICAgcG9zaXRpb246IGludGVyc2VjdGlvbnNbMF0sXG4gICAgICAgIHNlZ21lbnRJbmRleDogaWR4LFxuICAgICAgICBiZW5kcG9pbnRJbmRleDogcG9pbnRzRXF1YWwoc2VnbWVudFN0YXJ0LCBpbnRlcnNlY3Rpb25zWzBdKSA/IGlkeCA6IGlkeCArIDFcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gdHdvIGludGVyc2VjdGlvbnMgLT4gc2VnbWVudCBhdHRhY2htZW50XG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID09PSAyKSB7XG5cbiAgICAgIGF0dGFjaG1lbnRQb3NpdGlvbiA9IG1pZChpbnRlcnNlY3Rpb25zWzBdLCBpbnRlcnNlY3Rpb25zWzFdKTtcblxuICAgICAgYXR0YWNobWVudCA9IHtcbiAgICAgICAgdHlwZTogJ3NlZ21lbnQnLFxuICAgICAgICBwb3NpdGlvbjogYXR0YWNobWVudFBvc2l0aW9uLFxuICAgICAgICBzZWdtZW50SW5kZXg6IGlkeCxcbiAgICAgICAgcmVsYXRpdmVMb2NhdGlvbjogZ2V0RGlzdGFuY2Uoc2VnbWVudFN0YXJ0LCBhdHRhY2htZW50UG9zaXRpb24pIC8gZ2V0RGlzdGFuY2Uoc2VnbWVudFN0YXJ0LCBzZWdtZW50RW5kKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBhdHRhY2htZW50RGlzdGFuY2UgPSBnZXREaXN0YW5jZShhdHRhY2htZW50LnBvc2l0aW9uLCBwb2ludCk7XG5cbiAgICBpZiAoIWNsb3Nlc3RBdHRhY2htZW50IHx8IGNsb3Nlc3RBdHRhY2htZW50RGlzdGFuY2UgPiBhdHRhY2htZW50RGlzdGFuY2UpIHtcbiAgICAgIGNsb3Nlc3RBdHRhY2htZW50ID0gYXR0YWNobWVudDtcbiAgICAgIGNsb3Nlc3RBdHRhY2htZW50RGlzdGFuY2UgPSBhdHRhY2htZW50RGlzdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3RBdHRhY2htZW50O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgY2lyY2xlIGFuZCBhIGxpbmUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge1BvaW50fSBzMSBzZWdtZW50IHN0YXJ0XG4gKiBAcGFyYW0ge1BvaW50fSBzMiBzZWdtZW50IGVuZFxuICogQHBhcmFtIHtQb2ludH0gY2MgY2lyY2xlIGNlbnRlclxuICogQHBhcmFtIHtOdW1iZXJ9IGNyIGNpcmNsZSByYWRpdXNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxQb2ludD59IGludGVyc2VjdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0Q2lyY2xlU2VnbWVudEludGVyc2VjdGlvbnMoczEsIHMyLCBjYywgY3IpIHtcblxuICB2YXIgYmFYID0gczIueCAtIHMxLng7XG4gIHZhciBiYVkgPSBzMi55IC0gczEueTtcbiAgdmFyIGNhWCA9IGNjLnggLSBzMS54O1xuICB2YXIgY2FZID0gY2MueSAtIHMxLnk7XG5cbiAgdmFyIGEgPSBiYVggKiBiYVggKyBiYVkgKiBiYVk7XG4gIHZhciBiQnkyID0gYmFYICogY2FYICsgYmFZICogY2FZO1xuICB2YXIgYyA9IGNhWCAqIGNhWCArIGNhWSAqIGNhWSAtIGNyICogY3I7XG5cbiAgdmFyIHBCeTIgPSBiQnkyIC8gYTtcbiAgdmFyIHEgPSBjIC8gYTtcblxuICB2YXIgZGlzYyA9IHBCeTIgKiBwQnkyIC0gcTtcblxuICAvLyBjaGVjayBhZ2FpbnN0IG5lZ2F0aXZlIHZhbHVlIHRvIHdvcmsgYXJvdW5kXG4gIC8vIG5lZ2F0aXZlLCB2ZXJ5IGNsb3NlIHRvIHplcm8gcmVzdWx0cyAoLTRlLTE1KVxuICAvLyBiZWluZyBwcm9kdWNlZCBpbiBzb21lIGVudmlyb25tZW50c1xuICBpZiAoZGlzYyA8IDAgJiYgZGlzYyA+IC0wLjAwMDAwMSkge1xuICAgIGRpc2MgPSAwO1xuICB9XG5cbiAgaWYgKGRpc2MgPCAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gaWYgZGlzYyA9PSAwIC4uLiBkZWFsdCB3aXRoIGxhdGVyXG4gIHZhciB0bXBTcXJ0ID0gc3FydChkaXNjKTtcbiAgdmFyIGFiU2NhbGluZ0ZhY3RvcjEgPSAtcEJ5MiArIHRtcFNxcnQ7XG4gIHZhciBhYlNjYWxpbmdGYWN0b3IyID0gLXBCeTIgLSB0bXBTcXJ0O1xuXG4gIHZhciBpMSA9IHtcbiAgICB4OiBzMS54IC0gYmFYICogYWJTY2FsaW5nRmFjdG9yMSxcbiAgICB5OiBzMS55IC0gYmFZICogYWJTY2FsaW5nRmFjdG9yMVxuICB9O1xuXG4gIGlmIChkaXNjID09PSAwKSB7IC8vIGFiU2NhbGluZ0ZhY3RvcjEgPT0gYWJTY2FsaW5nRmFjdG9yMlxuICAgIHJldHVybiBbIGkxIF07XG4gIH1cblxuICB2YXIgaTIgPSB7XG4gICAgeDogczEueCAtIGJhWCAqIGFiU2NhbGluZ0ZhY3RvcjIsXG4gICAgeTogczEueSAtIGJhWSAqIGFiU2NhbGluZ0ZhY3RvcjJcbiAgfTtcblxuICAvLyByZXR1cm4gb25seSBwb2ludHMgb24gbGluZSBzZWdtZW50XG4gIHJldHVybiBbIGkxLCBpMiBdLmZpbHRlcihmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIGlzUG9pbnRJblNlZ21lbnQocCwgczEsIHMyKTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gaXNQb2ludEluU2VnbWVudChwLCBzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQpIHtcbiAgcmV0dXJuIChcbiAgICBmZW5jZWQocC54LCBzZWdtZW50U3RhcnQueCwgc2VnbWVudEVuZC54KSAmJlxuICAgIGZlbmNlZChwLnksIHNlZ21lbnRTdGFydC55LCBzZWdtZW50RW5kLnkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGZlbmNlZChuLCByYW5nZVN0YXJ0LCByYW5nZUVuZCkge1xuXG4gIC8vIHVzZSBtYXRjaGluZyB0aHJlc2hvbGQgdG8gd29yayBhcm91bmRcbiAgLy8gcHJlY2lzaW9uIGVycm9ycyBpbiBpbnRlcnNlY3Rpb24gY29tcHV0YXRpb25cblxuICByZXR1cm4gKFxuICAgIG4gPj0gbWluKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSAtIEVRVUFMX1RIUkVTSE9MRCAmJlxuICAgIG4gPD0gbWF4KHJhbmdlU3RhcnQsIHJhbmdlRW5kKSArIEVRVUFMX1RIUkVTSE9MRFxuICApO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBtaWQgb2YgdHdvIHBvaW50cy5cbiAqXG4gKiBAcGFyYW0ge1BvaW50fSBwMVxuICogQHBhcmFtIHtQb2ludH0gcDJcbiAqXG4gKiBAcmV0dXJuIHtQb2ludH1cbiAqL1xuZnVuY3Rpb24gbWlkKHAxLCBwMikge1xuXG4gIHJldHVybiB7XG4gICAgeDogKHAxLnggKyBwMi54KSAvIDIsXG4gICAgeTogKHAxLnkgKyBwMi55KSAvIDJcbiAgfTtcbn1cblxudmFyIEVRVUFMX1RIUkVTSE9MRCA9IDAuMTtcblxuZnVuY3Rpb24gcG9pbnRzRXF1YWwocDEsIHAyKSB7XG5cbiAgcmV0dXJuIChcbiAgICBhYnMocDEueCAtIHAyLngpIDw9IEVRVUFMX1RIUkVTSE9MRCAmJlxuICAgIGFicyhwMS55IC0gcDIueSkgPD0gRVFVQUxfVEhSRVNIT0xEXG4gICk7XG59XG4iLCIvKipcbiAqIFJldHVybnMgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHR3byBsaW5lIHNlZ21lbnRzIGEgYW5kIGIuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gbDFzXG4gKiBAcGFyYW0ge1BvaW50fSBsMWVcbiAqIEBwYXJhbSB7UG9pbnR9IGwyc1xuICogQHBhcmFtIHtQb2ludH0gbDJlXG4gKlxuICogQHJldHVybiB7UG9pbnR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpbmVJbnRlcnNlY3QobDFzLCBsMWUsIGwycywgbDJlKSB7XG5cbiAgLy8gaWYgdGhlIGxpbmVzIGludGVyc2VjdCwgdGhlIHJlc3VsdCBjb250YWlucyB0aGUgeCBhbmQgeSBvZiB0aGVcbiAgLy8gaW50ZXJzZWN0aW9uICh0cmVhdGluZyB0aGUgbGluZXMgYXMgaW5maW5pdGUpIGFuZCBib29sZWFucyBmb3JcbiAgLy8gd2hldGhlciBsaW5lIHNlZ21lbnQgMSBvciBsaW5lIHNlZ21lbnQgMiBjb250YWluIHRoZSBwb2ludFxuICB2YXIgZGVub21pbmF0b3IsIGEsIGIsIGMsIG51bWVyYXRvcjtcblxuICBkZW5vbWluYXRvciA9ICgobDJlLnkgLSBsMnMueSkgKiAobDFlLnggLSBsMXMueCkpIC0gKChsMmUueCAtIGwycy54KSAqIChsMWUueSAtIGwxcy55KSk7XG5cbiAgaWYgKGRlbm9taW5hdG9yID09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGEgPSBsMXMueSAtIGwycy55O1xuICBiID0gbDFzLnggLSBsMnMueDtcbiAgbnVtZXJhdG9yID0gKChsMmUueCAtIGwycy54KSAqIGEpIC0gKChsMmUueSAtIGwycy55KSAqIGIpO1xuXG4gIGMgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcblxuICAvLyBpZiB3ZSBjYXN0IHRoZXNlIGxpbmVzIGluZmluaXRlbHkgaW5cbiAgLy8gYm90aCBkaXJlY3Rpb25zLCB0aGV5IGludGVyc2VjdCBoZXJlXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZChsMXMueCArIChjICogKGwxZS54IC0gbDFzLngpKSksXG4gICAgeTogTWF0aC5yb3VuZChsMXMueSArIChjICogKGwxZS55IC0gbDFzLnkpKSlcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJZENsYWltSGFuZGxlcihtb2RkbGUpIHtcbiAgdGhpcy5fbW9kZGxlID0gbW9kZGxlO1xufVxuXG5JZENsYWltSGFuZGxlci4kaW5qZWN0ID0gWyAnbW9kZGxlJyBdO1xuXG5cbklkQ2xhaW1IYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgaWRzID0gdGhpcy5fbW9kZGxlLmlkcyxcbiAgICAgIGlkID0gY29udGV4dC5pZCxcbiAgICAgIGVsZW1lbnQgPSBjb250ZXh0LmVsZW1lbnQsXG4gICAgICBjbGFpbWluZyA9IGNvbnRleHQuY2xhaW1pbmc7XG5cbiAgaWYgKGNsYWltaW5nKSB7XG4gICAgaWRzLmNsYWltKGlkLCBlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZHMudW5jbGFpbShpZCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29tbWFuZCByZXZlcnQgaW1wbGVtZW50YXRpb24uXG4gKi9cbklkQ2xhaW1IYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBpZHMgPSB0aGlzLl9tb2RkbGUuaWRzLFxuICAgICAgaWQgPSBjb250ZXh0LmlkLFxuICAgICAgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudCxcbiAgICAgIGNsYWltaW5nID0gY29udGV4dC5jbGFpbWluZztcblxuICBpZiAoY2xhaW1pbmcpIHtcbiAgICBpZHMudW5jbGFpbShpZCk7XG4gIH0gZWxzZSB7XG4gICAgaWRzLmNsYWltKGlkLCBlbGVtZW50KTtcbiAgfVxufTtcblxuIiwiaW1wb3J0IHtcclxuICBmb3JFYWNoXHJcbn0gZnJvbSAnbWluLWRhc2gnO1xyXG5cclxuaW1wb3J0IENPTE9SIGZyb20gJy4uLy4uLy4uL3V0aWwvQ29sb3JVdGlsJztcclxuXHJcblxyXG52YXIgREVGQVVMVF9DT0xPUiA9IENPTE9SLllFTExPVztcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZXRDb2xvckhhbmRsZXIoY29tbWFuZFN0YWNrKSB7XHJcbiAgdGhpcy5fY29tbWFuZFN0YWNrID0gY29tbWFuZFN0YWNrO1xyXG59XHJcblxyXG5TZXRDb2xvckhhbmRsZXIuJGluamVjdCA9IFtcclxuICAnY29tbWFuZFN0YWNrJ1xyXG5dO1xyXG5cclxuXHJcblNldENvbG9ySGFuZGxlci5wcm90b3R5cGUucG9zdEV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgdmFyIGVsZW1lbnRzID0gY29udGV4dC5lbGVtZW50cyxcclxuICAgICAgY29sb3IgPSBjb250ZXh0LmNvbG9yIHx8IERFRkFVTFRfQ09MT1I7XHJcblxyXG4gIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xyXG5cclxuICAgIHNlbGYuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdlbGVtZW50LnVwZGF0ZVByb3BlcnRpZXMnLCB7XHJcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBjb2xvcjogY29sb3JcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG59O1xyXG4iLCJpbXBvcnQge1xuICBhZGQgYXMgY29sbGVjdGlvbkFkZCxcbiAgcmVtb3ZlIGFzIGNvbGxlY3Rpb25SZW1vdmVcbn0gZnJvbSAnZGlhZ3JhbS1qcy9saWIvdXRpbC9Db2xsZWN0aW9ucyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVXBkYXRlQ2FudmFzUm9vdEhhbmRsZXIoY2FudmFzLCBtb2RlbGluZykge1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG59XG5cblVwZGF0ZUNhbnZhc1Jvb3RIYW5kbGVyLiRpbmplY3QgPSBbXG4gICdjYW52YXMnLFxuICAnbW9kZWxpbmcnXG5dO1xuXG5cblVwZGF0ZUNhbnZhc1Jvb3RIYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cbiAgdmFyIG5ld1Jvb3QgPSBjb250ZXh0Lm5ld1Jvb3QsXG4gICAgICBuZXdSb290QnVzaW5lc3NPYmplY3QgPSBuZXdSb290LmJ1c2luZXNzT2JqZWN0LFxuICAgICAgb2xkUm9vdCA9IGNhbnZhcy5nZXRSb290RWxlbWVudCgpLFxuICAgICAgb2xkUm9vdEJ1c2luZXNzT2JqZWN0ID0gb2xkUm9vdC5idXNpbmVzc09iamVjdCxcbiAgICAgIHBvc3RpdERlZmluaXRpb25zID0gb2xkUm9vdEJ1c2luZXNzT2JqZWN0LiRwYXJlbnQsXG4gICAgICBkaVBsYW5lID0gb2xkUm9vdEJ1c2luZXNzT2JqZWN0LmRpO1xuXG4gIC8vICgxKSByZXBsYWNlIHByb2Nlc3Mgb2xkIDw+IG5ldyByb290XG4gIGNhbnZhcy5zZXRSb290RWxlbWVudChuZXdSb290LCB0cnVlKTtcblxuICAvLyAoMikgdXBkYXRlIHJvb3QgZWxlbWVudHNcbiAgY29sbGVjdGlvbkFkZChwb3N0aXREZWZpbml0aW9ucy5yb290RWxlbWVudHMsIG5ld1Jvb3RCdXNpbmVzc09iamVjdCk7XG4gIG5ld1Jvb3RCdXNpbmVzc09iamVjdC4kcGFyZW50ID0gcG9zdGl0RGVmaW5pdGlvbnM7XG5cbiAgY29sbGVjdGlvblJlbW92ZShwb3N0aXREZWZpbml0aW9ucy5yb290RWxlbWVudHMsIG9sZFJvb3RCdXNpbmVzc09iamVjdCk7XG4gIG9sZFJvb3RCdXNpbmVzc09iamVjdC4kcGFyZW50ID0gbnVsbDtcblxuICAvLyAoMykgd2lyZSBkaVxuICBvbGRSb290QnVzaW5lc3NPYmplY3QuZGkgPSBudWxsO1xuXG4gIGRpUGxhbmUuYm9hcmRFbGVtZW50ID0gbmV3Um9vdEJ1c2luZXNzT2JqZWN0O1xuICBuZXdSb290QnVzaW5lc3NPYmplY3QuZGkgPSBkaVBsYW5lO1xuXG4gIGNvbnRleHQub2xkUm9vdCA9IG9sZFJvb3Q7XG5cbiAgLy8gVE9ETyhuaWtrdSk6IHJldHVybiBjaGFuZ2VkIGVsZW1lbnRzP1xuICAvLyByZXR1cm4gWyBuZXdSb290LCBvbGRSb290IF07XG59O1xuXG5cblVwZGF0ZUNhbnZhc1Jvb3RIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblxuICB2YXIgbmV3Um9vdCA9IGNvbnRleHQubmV3Um9vdCxcbiAgICAgIG5ld1Jvb3RCdXNpbmVzc09iamVjdCA9IG5ld1Jvb3QuYnVzaW5lc3NPYmplY3QsXG4gICAgICBvbGRSb290ID0gY29udGV4dC5vbGRSb290LFxuICAgICAgb2xkUm9vdEJ1c2luZXNzT2JqZWN0ID0gb2xkUm9vdC5idXNpbmVzc09iamVjdCxcbiAgICAgIHBvc3RpdERlZmluaXRpb25zID0gbmV3Um9vdEJ1c2luZXNzT2JqZWN0LiRwYXJlbnQsXG4gICAgICBkaVBsYW5lID0gbmV3Um9vdEJ1c2luZXNzT2JqZWN0LmRpO1xuXG4gIC8vICgxKSByZXBsYWNlIHByb2Nlc3Mgb2xkIDw+IG5ldyByb290XG4gIGNhbnZhcy5zZXRSb290RWxlbWVudChvbGRSb290LCB0cnVlKTtcblxuICAvLyAoMikgdXBkYXRlIHJvb3QgZWxlbWVudHNcbiAgY29sbGVjdGlvblJlbW92ZShwb3N0aXREZWZpbml0aW9ucy5yb290RWxlbWVudHMsIG5ld1Jvb3RCdXNpbmVzc09iamVjdCk7XG4gIG5ld1Jvb3RCdXNpbmVzc09iamVjdC4kcGFyZW50ID0gbnVsbDtcblxuICBjb2xsZWN0aW9uQWRkKHBvc3RpdERlZmluaXRpb25zLnJvb3RFbGVtZW50cywgb2xkUm9vdEJ1c2luZXNzT2JqZWN0KTtcbiAgb2xkUm9vdEJ1c2luZXNzT2JqZWN0LiRwYXJlbnQgPSBwb3N0aXREZWZpbml0aW9ucztcblxuICAvLyAoMykgd2lyZSBkaVxuICBuZXdSb290QnVzaW5lc3NPYmplY3QuZGkgPSBudWxsO1xuXG4gIGRpUGxhbmUuYm9hcmRFbGVtZW50ID0gb2xkUm9vdEJ1c2luZXNzT2JqZWN0O1xuICBvbGRSb290QnVzaW5lc3NPYmplY3QuZGkgPSBkaVBsYW5lO1xuXG4gIC8vIFRPRE8obmlra3UpOiByZXR1cm4gY2hhbmdlZCBlbGVtZW50cz9cbiAgLy8gcmV0dXJuIFsgbmV3Um9vdCwgb2xkUm9vdCBdO1xufTsiLCJpbXBvcnQge1xuICByZWR1Y2UsXG4gIGtleXMsXG4gIGZvckVhY2gsXG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGdldEJ1c2luZXNzT2JqZWN0XG59IGZyb20gJy4uLy4uLy4uL3V0aWwvTW9kZWxVdGlsJztcblxudmFyIElEID0gJ2lkJyxcbiAgICBESSA9ICdkaSc7XG5cbnZhciBOVUxMX0RJTUVOU0lPTlMgPSB7XG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDBcbn07XG5cbi8qKlxuICogQSBoYW5kbGVyIHRoYXQgaW1wbGVtZW50cyBhIHBvc3RpdCBlbGVtZW50cyBwcm9wZXJ0eSB1cGRhdGUuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgdXNlZCB0byBzZXQgc2ltcGxlIHByb3BlcnRpZXMgb24gZWxlbWVudHMgd2l0aFxuICogYW4gdW5kZXJseWluZyBYTUwgYnVzaW5lc3Mgb2JqZWN0LlxuICpcbiAqIFVzZSByZXNwZWN0aXZlIGRpYWdyYW0tanMgcHJvdmlkZWQgaGFuZGxlcnMgaWYgeW91IHdvdWxkXG4gKiBsaWtlIHRvIHBlcmZvcm0gYXV0b21hdGVkIG1vZGVsaW5nLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBVcGRhdGVQcm9wZXJ0aWVzSGFuZGxlcihcbiAgICBlbGVtZW50UmVnaXN0cnksIG1vZGRsZSwgdHJhbnNsYXRlLFxuICAgIG1vZGVsaW5nLCB0ZXh0UmVuZGVyZXIpIHtcblxuICB0aGlzLl9lbGVtZW50UmVnaXN0cnkgPSBlbGVtZW50UmVnaXN0cnk7XG4gIHRoaXMuX21vZGRsZSA9IG1vZGRsZTtcbiAgdGhpcy5fdHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuICB0aGlzLl90ZXh0UmVuZGVyZXIgPSB0ZXh0UmVuZGVyZXI7XG59XG5cblVwZGF0ZVByb3BlcnRpZXNIYW5kbGVyLiRpbmplY3QgPSBbXG4gICdlbGVtZW50UmVnaXN0cnknLFxuICAnbW9kZGxlJyxcbiAgJ3RyYW5zbGF0ZScsXG4gICdtb2RlbGluZycsXG4gICd0ZXh0UmVuZGVyZXInXG5dO1xuXG5cbi8vIGFwaSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogVXBkYXRlcyBhIGJvYXJkIGVsZW1lbnQgd2l0aCBhIGxpc3Qgb2YgbmV3IHByb3BlcnRpZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gY29udGV4dC5lbGVtZW50IHRoZSBlbGVtZW50IHRvIHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQucHJvcGVydGllcyBhIGxpc3Qgb2YgcHJvcGVydGllcyB0byBzZXQgb24gdGhlIGVsZW1lbnQnc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXNpbmVzc09iamVjdCAodGhlIFhNTCBtb2RlbCBlbGVtZW50KVxuICpcbiAqIEByZXR1cm4ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gdGhlIHVwZGF0ZWQgZWxlbWVudFxuICovXG5VcGRhdGVQcm9wZXJ0aWVzSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudCxcbiAgICAgIGNoYW5nZWQgPSBbIGVsZW1lbnQgXSxcbiAgICAgIHRyYW5zbGF0ZSA9IHRoaXMuX3RyYW5zbGF0ZTtcblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnNsYXRlKCdlbGVtZW50IHJlcXVpcmVkJykpO1xuICB9XG5cbiAgdmFyIGVsZW1lbnRSZWdpc3RyeSA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeSxcbiAgICAgIGlkcyA9IHRoaXMuX21vZGRsZS5pZHM7XG5cbiAgdmFyIGJ1c2luZXNzT2JqZWN0ID0gZWxlbWVudC5idXNpbmVzc09iamVjdCxcbiAgICAgIHByb3BlcnRpZXMgPSB1bndyYXBCdXNpbmVzc09iamVjdHMoY29udGV4dC5wcm9wZXJ0aWVzKSxcbiAgICAgIG9sZFByb3BlcnRpZXMgPSBjb250ZXh0Lm9sZFByb3BlcnRpZXMgfHwgZ2V0UHJvcGVydGllcyhidXNpbmVzc09iamVjdCwgcHJvcGVydGllcyk7XG5cbiAgaWYgKGlzSWRDaGFuZ2UocHJvcGVydGllcywgYnVzaW5lc3NPYmplY3QpKSB7XG4gICAgaWRzLnVuY2xhaW0oYnVzaW5lc3NPYmplY3RbSURdKTtcblxuICAgIGVsZW1lbnRSZWdpc3RyeS51cGRhdGVJZChlbGVtZW50LCBwcm9wZXJ0aWVzW0lEXSk7XG5cbiAgICBpZHMuY2xhaW0ocHJvcGVydGllc1tJRF0sIGJ1c2luZXNzT2JqZWN0KTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBwcm9wZXJ0aWVzXG4gIHNldFByb3BlcnRpZXMoYnVzaW5lc3NPYmplY3QsIHByb3BlcnRpZXMpO1xuXG4gIC8vIHN0b3JlIG9sZCB2YWx1ZXNcbiAgY29udGV4dC5vbGRQcm9wZXJ0aWVzID0gb2xkUHJvcGVydGllcztcbiAgY29udGV4dC5jaGFuZ2VkID0gY2hhbmdlZDtcblxuICAvLyBpbmRpY2F0ZSBjaGFuZ2VkIG9uIG9iamVjdHMgYWZmZWN0ZWQgYnkgdGhlIHVwZGF0ZVxuICByZXR1cm4gY2hhbmdlZDtcbn07XG5cblxuVXBkYXRlUHJvcGVydGllc0hhbmRsZXIucHJvdG90eXBlLnBvc3RFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudCxcbiAgICAgIGxhYmVsID0gZWxlbWVudC5sYWJlbDtcblxuICB2YXIgdGV4dCA9IGxhYmVsICYmIGdldEJ1c2luZXNzT2JqZWN0KGxhYmVsKS5uYW1lO1xuXG4gIGlmICghdGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGdldCBsYXlvdXRlZCB0ZXh0IGJvdW5kcyBhbmQgcmVzaXplIGV4dGVybmFsXG4gIC8vIGV4dGVybmFsIGxhYmVsIGFjY29yZGluZ2x5XG4gIHZhciBuZXdMYWJlbEJvdW5kcyA9IHRoaXMuX3RleHRSZW5kZXJlci5nZXRFeHRlcm5hbExhYmVsQm91bmRzKGxhYmVsLCB0ZXh0KTtcblxuICB0aGlzLl9tb2RlbGluZy5yZXNpemVTaGFwZShsYWJlbCwgbmV3TGFiZWxCb3VuZHMsIE5VTExfRElNRU5TSU9OUyk7XG59O1xuXG4vKipcbiAqIFJldmVydHMgdGhlIHVwZGF0ZSBvbiBhIGJvYXJkIGVsZW1lbnRzIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybiB7ZGpzLm1vZGVsLkJhc2V9IHRoZSB1cGRhdGVkIGVsZW1lbnRcbiAqL1xuVXBkYXRlUHJvcGVydGllc0hhbmRsZXIucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudCxcbiAgICAgIHByb3BlcnRpZXMgPSBjb250ZXh0LnByb3BlcnRpZXMsXG4gICAgICBvbGRQcm9wZXJ0aWVzID0gY29udGV4dC5vbGRQcm9wZXJ0aWVzLFxuICAgICAgYnVzaW5lc3NPYmplY3QgPSBlbGVtZW50LmJ1c2luZXNzT2JqZWN0LFxuICAgICAgZWxlbWVudFJlZ2lzdHJ5ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LFxuICAgICAgaWRzID0gdGhpcy5fbW9kZGxlLmlkcztcblxuICAvLyB1cGRhdGUgcHJvcGVydGllc1xuICBzZXRQcm9wZXJ0aWVzKGJ1c2luZXNzT2JqZWN0LCBvbGRQcm9wZXJ0aWVzKTtcblxuICBpZiAoaXNJZENoYW5nZShwcm9wZXJ0aWVzLCBidXNpbmVzc09iamVjdCkpIHtcbiAgICBpZHMudW5jbGFpbShwcm9wZXJ0aWVzW0lEXSk7XG5cbiAgICBlbGVtZW50UmVnaXN0cnkudXBkYXRlSWQoZWxlbWVudCwgb2xkUHJvcGVydGllc1tJRF0pO1xuXG4gICAgaWRzLmNsYWltKG9sZFByb3BlcnRpZXNbSURdLCBidXNpbmVzc09iamVjdCk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dC5jaGFuZ2VkO1xufTtcblxuXG5mdW5jdGlvbiBpc0lkQ2hhbmdlKHByb3BlcnRpZXMsIGJ1c2luZXNzT2JqZWN0KSB7XG4gIHJldHVybiBJRCBpbiBwcm9wZXJ0aWVzICYmIHByb3BlcnRpZXNbSURdICE9PSBidXNpbmVzc09iamVjdFtJRF07XG59XG5cblxuZnVuY3Rpb24gZ2V0UHJvcGVydGllcyhidXNpbmVzc09iamVjdCwgcHJvcGVydGllcykge1xuICB2YXIgcHJvcGVydHlOYW1lcyA9IGtleXMocHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIHJlZHVjZShwcm9wZXJ0eU5hbWVzLCBmdW5jdGlvbihyZXN1bHQsIGtleSkge1xuXG4gICAgLy8gaGFuZGxlIERJIHNlcGFyYXRlbHlcbiAgICBpZiAoa2V5ICE9PSBESSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBidXNpbmVzc09iamVjdC5nZXQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSBnZXREaVByb3BlcnRpZXMoYnVzaW5lc3NPYmplY3QuZGksIGtleXMocHJvcGVydGllcy5kaSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbn1cblxuXG5mdW5jdGlvbiBnZXREaVByb3BlcnRpZXMoZGksIHByb3BlcnR5TmFtZXMpIHtcbiAgcmV0dXJuIHJlZHVjZShwcm9wZXJ0eU5hbWVzLCBmdW5jdGlvbihyZXN1bHQsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gZGkuZ2V0KGtleSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG59XG5cblxuZnVuY3Rpb24gc2V0UHJvcGVydGllcyhidXNpbmVzc09iamVjdCwgcHJvcGVydGllcykge1xuICBmb3JFYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblxuICAgIGlmIChrZXkgIT09IERJKSB7XG4gICAgICBidXNpbmVzc09iamVjdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gb25seSB1cGRhdGUsIGlmIGJ1c2luZXNzT2JqZWN0LmRpIGV4aXN0c1xuICAgICAgaWYgKGJ1c2luZXNzT2JqZWN0LmRpKSB7XG4gICAgICAgIHNldERpUHJvcGVydGllcyhidXNpbmVzc09iamVjdC5kaSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gc2V0RGlQcm9wZXJ0aWVzKGRpLCBwcm9wZXJ0aWVzKSB7XG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIGRpLnNldChrZXksIHZhbHVlKTtcbiAgfSk7XG59XG5cblxudmFyIHJlZmVyZW5jZVByb3BlcnR5TmFtZXMgPSBbICdkZWZhdWx0JyBdO1xuXG4vKipcbiAqIE1ha2Ugc3VyZSB3ZSB1bndyYXAgdGhlIGFjdHVhbCBidXNpbmVzcyBvYmplY3RcbiAqIGJlaGluZCBkaWFncmFtIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSBiZWVuXG4gKiBwYXNzZWQgYXMgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gcHJvcGVydGllc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdW53cmFwcGVkUHJvcHNcbiAqL1xuZnVuY3Rpb24gdW53cmFwQnVzaW5lc3NPYmplY3RzKHByb3BlcnRpZXMpIHtcblxuICB2YXIgdW53cmFwcGVkUHJvcHMgPSBhc3NpZ24oe30sIHByb3BlcnRpZXMpO1xuXG4gIHJlZmVyZW5jZVByb3BlcnR5TmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gcHJvcGVydGllcykge1xuICAgICAgdW53cmFwcGVkUHJvcHNbbmFtZV0gPSBnZXRCdXNpbmVzc09iamVjdCh1bndyYXBwZWRQcm9wc1tuYW1lXSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdW53cmFwcGVkUHJvcHM7XG59IiwiaW1wb3J0IEJlaGF2aW9yTW9kdWxlIGZyb20gJy4vYmVoYXZpb3InO1xuaW1wb3J0IFJ1bGVzTW9kdWxlIGZyb20gJy4uL3J1bGVzJztcbmltcG9ydCBEaU9yZGVyaW5nTW9kdWxlIGZyb20gJy4uL2RpLW9yZGVyaW5nJztcbmltcG9ydCBPcmRlcmluZ01vZHVsZSBmcm9tICcuLi9vcmRlcmluZyc7XG5pbXBvcnQgUmVwbGFjZU1vZHVsZSBmcm9tICcuLi9yZXBsYWNlJztcblxuaW1wb3J0IENvbW1hbmRNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvY29tbWFuZCc7XG5pbXBvcnQgVG9vbHRpcHNNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvdG9vbHRpcHMnO1xuaW1wb3J0IExhYmVsU3VwcG9ydE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9sYWJlbC1zdXBwb3J0JztcbmltcG9ydCBBdHRhY2hTdXBwb3J0TW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2F0dGFjaC1zdXBwb3J0JztcbmltcG9ydCBTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uJztcbmltcG9ydCBDaGFuZ2VTdXBwb3J0TW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2NoYW5nZS1zdXBwb3J0JztcbmltcG9ydCBTcGFjZVRvb2xNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc3BhY2UtdG9vbCc7XG5cbmltcG9ydCBQb3NpdEZhY3RvcnkgZnJvbSAnLi9Qb3N0aXRGYWN0b3J5JztcbmltcG9ydCBQb3N0aXRVcGRhdGVyIGZyb20gJy4vUG9zdGl0VXBkYXRlcic7XG5pbXBvcnQgRWxlbWVudEZhY3RvcnkgZnJvbSAnLi9FbGVtZW50RmFjdG9yeSc7XG5pbXBvcnQgTW9kZWxpbmcgZnJvbSAnLi9Nb2RlbGluZyc7XG5pbXBvcnQgTGF5b3V0ZXIgZnJvbSAnZGlhZ3JhbS1qcy9saWIvbGF5b3V0L0Jhc2VMYXlvdXRlcic7XG5pbXBvcnQgQ3JvcHBpbmdDb25uZWN0aW9uRG9ja2luZyBmcm9tICdkaWFncmFtLWpzL2xpYi9sYXlvdXQvQ3JvcHBpbmdDb25uZWN0aW9uRG9ja2luZyc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogW1xuICAgICdtb2RlbGluZycsXG4gICAgJ3Bvc3RpdFVwZGF0ZXInXG4gIF0sXG4gIF9fZGVwZW5kc19fOiBbXG4gICAgQmVoYXZpb3JNb2R1bGUsXG4gICAgUnVsZXNNb2R1bGUsXG4gICAgRGlPcmRlcmluZ01vZHVsZSxcbiAgICBPcmRlcmluZ01vZHVsZSxcbiAgICBSZXBsYWNlTW9kdWxlLFxuICAgIENvbW1hbmRNb2R1bGUsXG4gICAgVG9vbHRpcHNNb2R1bGUsXG4gICAgTGFiZWxTdXBwb3J0TW9kdWxlLFxuICAgIEF0dGFjaFN1cHBvcnRNb2R1bGUsXG4gICAgU2VsZWN0aW9uTW9kdWxlLFxuICAgIENoYW5nZVN1cHBvcnRNb2R1bGUsXG4gICAgU3BhY2VUb29sTW9kdWxlXG4gIF0sXG4gIHBvc3RpdEZhY3Rvcnk6IFsgJ3R5cGUnLCBQb3NpdEZhY3RvcnkgXSxcbiAgcG9zdGl0VXBkYXRlcjogWyAndHlwZScsIFBvc3RpdFVwZGF0ZXIgXSxcbiAgZWxlbWVudEZhY3Rvcnk6IFsgJ3R5cGUnLCBFbGVtZW50RmFjdG9yeSBdLFxuICBtb2RlbGluZzogWyAndHlwZScsIE1vZGVsaW5nIF0sXG4gIGxheW91dGVyOiBbICd0eXBlJywgTGF5b3V0ZXIgXSxcbiAgY29ubmVjdGlvbkRvY2tpbmc6IFsgJ3R5cGUnLCBDcm9wcGluZ0Nvbm5lY3Rpb25Eb2NraW5nIF1cbn07IiwiaW1wb3J0IHtcbiAgc29tZVxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7IGlzIH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9Nb2RlbFV0aWwnO1xuXG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgZWxlbWVudCBoYXMgYW55IG9mIHRoZSBnaXZlbiB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHR5cGVzXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQW55KGVsZW1lbnQsIHR5cGVzKSB7XG4gIHJldHVybiBzb21lKHR5cGVzLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGlzKGVsZW1lbnQsIHQpO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IG9mIHRoZSBlbGVtZW50IHdpdGggYW55IG9mIHRoZSBnaXZlbiB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheTxTdHJpbmc+fSBhbnlUeXBlXG4gKlxuICogQHJldHVybiB7ZGpzLm1vZGVsLkJhc2V9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJlbnQoZWxlbWVudCwgYW55VHlwZSkge1xuXG4gIGlmICh0eXBlb2YgYW55VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBhbnlUeXBlID0gWyBhbnlUeXBlIF07XG4gIH1cblxuICB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCkpIHtcbiAgICBpZiAoaXNBbnkoZWxlbWVudCwgYW55VHlwZSkpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBPcmRlcmluZ1Byb3ZpZGVyIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL29yZGVyaW5nL09yZGVyaW5nUHJvdmlkZXInO1xuXG5pbXBvcnQge1xuICBpc0FueVxufSBmcm9tICcuLi9tb2RlbGluZy91dGlsL01vZGVsaW5nVXRpbCc7XG5cbmltcG9ydCB7XG4gIGZpbmRJbmRleCxcbiAgZmluZFxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxuLyoqXG4gKiBhIHNpbXBsZSBvcmRlcmluZyBwcm92aWRlciB0aGF0IG1ha2VzIHN1cmU6XG4gKlxuICogKDApIGxhYmVscyBhbmQgZ3JvdXBzIGFyZSByZW5kZXJlZCBhbHdheXMgb24gdG9wXG4gKiAoMSkgZWxlbWVudHMgYXJlIG9yZGVyZWQgYnkgYSB7bGV2ZWx9IHByb3BlcnR5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvc3RpdE9yZGVyaW5nUHJvdmlkZXIoZXZlbnRCdXMsIGNhbnZhcywgdHJhbnNsYXRlKSB7XG5cbiAgT3JkZXJpbmdQcm92aWRlci5jYWxsKHRoaXMsIGV2ZW50QnVzKTtcblxuICB2YXIgb3JkZXJzID0gW1xuICAgIHsgdHlwZTogJ3Bvc3RpdDpCb2FyZEVsZW1lbnQnLCBvcmRlcjogeyBsZXZlbDogNSB9IH1cbiAgXTtcblxuICBmdW5jdGlvbiBjb21wdXRlT3JkZXIoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LmxhYmVsVGFyZ2V0KSB7XG4gICAgICByZXR1cm4geyBsZXZlbDogMTAgfTtcbiAgICB9XG5cbiAgICB2YXIgZW50cnkgPSBmaW5kKG9yZGVycywgZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIGlzQW55KGVsZW1lbnQsIFsgby50eXBlIF0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5Lm9yZGVyIHx8IHsgbGV2ZWw6IDEgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9yZGVyKGVsZW1lbnQpIHtcblxuICAgIHZhciBvcmRlciA9IGVsZW1lbnQub3JkZXI7XG5cbiAgICBpZiAoIW9yZGVyKSB7XG4gICAgICBlbGVtZW50Lm9yZGVyID0gb3JkZXIgPSBjb21wdXRlT3JkZXIoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yZGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEFjdHVhbFBhcmVudChlbGVtZW50LCBuZXdQYXJlbnQsIGNvbnRhaW5lcnMpIHtcblxuICAgIHZhciBhY3R1YWxQYXJlbnQgPSBuZXdQYXJlbnQ7XG5cbiAgICB3aGlsZSAoYWN0dWFsUGFyZW50KSB7XG5cbiAgICAgIGlmIChpc0FueShhY3R1YWxQYXJlbnQsIGNvbnRhaW5lcnMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhY3R1YWxQYXJlbnQgPSBhY3R1YWxQYXJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIGlmICghYWN0dWFsUGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnNsYXRlKCdubyBwYXJlbnQgZm9yIHtlbGVtZW50fSBpbiB7cGFyZW50fScsIHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudC5pZCxcbiAgICAgICAgcGFyZW50OiBuZXdQYXJlbnQuaWRcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0dWFsUGFyZW50O1xuICB9XG5cbiAgdGhpcy5nZXRPcmRlcmluZyA9IGZ1bmN0aW9uKGVsZW1lbnQsIG5ld1BhcmVudCkge1xuXG4gICAgLy8gcmVuZGVyIGxhYmVscyBhbHdheXMgb24gdG9wXG4gICAgaWYgKGVsZW1lbnQubGFiZWxUYXJnZXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogY2FudmFzLmdldFJvb3RFbGVtZW50KCksXG4gICAgICAgIGluZGV4OiAtMVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudE9yZGVyID0gZ2V0T3JkZXIoZWxlbWVudCk7XG5cblxuICAgIGlmIChlbGVtZW50T3JkZXIuY29udGFpbmVycykge1xuICAgICAgbmV3UGFyZW50ID0gZmluZEFjdHVhbFBhcmVudChlbGVtZW50LCBuZXdQYXJlbnQsIGVsZW1lbnRPcmRlci5jb250YWluZXJzKTtcbiAgICB9XG5cblxuICAgIHZhciBjdXJyZW50SW5kZXggPSBuZXdQYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihlbGVtZW50KTtcblxuICAgIHZhciBpbnNlcnRJbmRleCA9IGZpbmRJbmRleChuZXdQYXJlbnQuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG5cbiAgICAgIC8vIGRvIG5vdCBjb21wYXJlIHdpdGggbGFiZWxzLCB0aGV5IGFyZSBjcmVhdGVkXG4gICAgICAvLyBpbiB0aGUgd3Jvbmcgb3JkZXIgKHJpZ2h0IGFmdGVyIGVsZW1lbnRzKSBkdXJpbmcgaW1wb3J0IGFuZFxuICAgICAgLy8gbWVzcyB1cCB0aGUgcG9zaXRpb25pbmcuXG4gICAgICBpZiAoIWVsZW1lbnQubGFiZWxUYXJnZXQgJiYgY2hpbGQubGFiZWxUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudE9yZGVyLmxldmVsIDwgZ2V0T3JkZXIoY2hpbGQpLmxldmVsO1xuICAgIH0pO1xuXG5cbiAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGluIHRoZSBjaGlsZCBsaXN0IGF0XG4gICAgLy8gYSBzbWFsbGVyIGluZGV4LCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgaW5zZXJ0IGluZGV4LlxuICAgIC8vIHRoaXMgdGFrZXMgaW50byBhY2NvdW50IHRoYXQgdGhlIGVsZW1lbnQgaXMgYmVpbmcgcmVtb3ZlZFxuICAgIC8vIGJlZm9yZSBiZWluZyByZS1pbnNlcnRlZFxuICAgIGlmIChpbnNlcnRJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChjdXJyZW50SW5kZXggIT09IC0xICYmIGN1cnJlbnRJbmRleCA8IGluc2VydEluZGV4KSB7XG4gICAgICAgIGluc2VydEluZGV4IC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiBpbnNlcnRJbmRleCxcbiAgICAgIHBhcmVudDogbmV3UGFyZW50XG4gICAgfTtcbiAgfTtcbn1cblxuUG9zdGl0T3JkZXJpbmdQcm92aWRlci4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnLCAnY2FudmFzJywgJ3RyYW5zbGF0ZScgXTtcblxuaW5oZXJpdHMoUG9zdGl0T3JkZXJpbmdQcm92aWRlciwgT3JkZXJpbmdQcm92aWRlcik7IiwiaW1wb3J0IHRyYW5zbGF0ZSBmcm9tICdkaWFncmFtLWpzL2xpYi9pMThuL3RyYW5zbGF0ZSc7XG5cbmltcG9ydCBQb3N0aXRPcmRlcmluZ1Byb3ZpZGVyIGZyb20gJy4vUG9zdGl0T3JkZXJpbmdQcm92aWRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICB0cmFuc2xhdGVcbiAgXSxcbiAgX19pbml0X186IFsgJ3Bvc3RpdE9yZGVyaW5nUHJvdmlkZXInIF0sXG4gIHBvc3RpdE9yZGVyaW5nUHJvdmlkZXI6IFsgJ3R5cGUnLCBQb3N0aXRPcmRlcmluZ1Byb3ZpZGVyIF1cbn07IiwiaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IENPTE9SUyBmcm9tICcuLi8uLi91dGlsL0NvbG9yVXRpbCc7XG5cblxuLyoqXG4gKiBBIHBhbGV0dGUgcHJvdmlkZXIgZm9yIHBvc3RpdCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGFsZXR0ZVByb3ZpZGVyKFxuICAgIHBhbGV0dGUsIGNyZWF0ZSwgZWxlbWVudEZhY3RvcnksXG4gICAgc3BhY2VUb29sLCBsYXNzb1Rvb2wsIGhhbmRUb29sLCB0cmFuc2xhdGUpIHtcblxuICB0aGlzLl9wYWxldHRlID0gcGFsZXR0ZTtcbiAgdGhpcy5fY3JlYXRlID0gY3JlYXRlO1xuICB0aGlzLl9lbGVtZW50RmFjdG9yeSA9IGVsZW1lbnRGYWN0b3J5O1xuICB0aGlzLl9zcGFjZVRvb2wgPSBzcGFjZVRvb2w7XG4gIHRoaXMuX2xhc3NvVG9vbCA9IGxhc3NvVG9vbDtcbiAgdGhpcy5faGFuZFRvb2wgPSBoYW5kVG9vbDtcbiAgdGhpcy5fdHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuXG4gIHBhbGV0dGUucmVnaXN0ZXJQcm92aWRlcih0aGlzKTtcbn1cblxuUGFsZXR0ZVByb3ZpZGVyLiRpbmplY3QgPSBbXG4gICdwYWxldHRlJyxcbiAgJ2NyZWF0ZScsXG4gICdlbGVtZW50RmFjdG9yeScsXG4gICdzcGFjZVRvb2wnLFxuICAnbGFzc29Ub29sJyxcbiAgJ2hhbmRUb29sJyxcbiAgJ3RyYW5zbGF0ZSdcbl07XG5cblxuUGFsZXR0ZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRQYWxldHRlRW50cmllcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICB2YXIgYWN0aW9ucyA9IHt9LFxuICAgICAgY3JlYXRlID0gdGhpcy5fY3JlYXRlLFxuICAgICAgZWxlbWVudEZhY3RvcnkgPSB0aGlzLl9lbGVtZW50RmFjdG9yeSxcbiAgICAgIHNwYWNlVG9vbCA9IHRoaXMuX3NwYWNlVG9vbCxcbiAgICAgIGxhc3NvVG9vbCA9IHRoaXMuX2xhc3NvVG9vbCxcbiAgICAgIGhhbmRUb29sID0gdGhpcy5faGFuZFRvb2wsXG4gICAgICB0cmFuc2xhdGUgPSB0aGlzLl90cmFuc2xhdGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIGdyb3VwLCBjbGFzc05hbWUsIHRpdGxlLCBvcHRpb25zKSB7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMaXN0ZW5lcihldmVudCkge1xuICAgICAgdmFyIHNoYXBlID0gZWxlbWVudEZhY3RvcnkuY3JlYXRlU2hhcGUoYXNzaWduKHsgdHlwZTogdHlwZSB9LCBvcHRpb25zKSk7XG4gICAgICBjcmVhdGUuc3RhcnQoZXZlbnQsIHNoYXBlKTtcbiAgICB9XG5cbiAgICB2YXIgc2hvcnRUeXBlID0gdHlwZS5yZXBsYWNlKC9ecG9zdGl0Oi8sICcnKTtcblxuICAgIHJldHVybiB7XG4gICAgICBncm91cDogZ3JvdXAsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHRpdGxlOiB0aXRsZSB8fCB0cmFuc2xhdGUoJ0NyZWF0ZSB7dHlwZX0nLCB7IHR5cGU6IHNob3J0VHlwZSB9KSxcbiAgICAgIGFjdGlvbjoge1xuICAgICAgICBkcmFnc3RhcnQ6IGNyZWF0ZUxpc3RlbmVyLFxuICAgICAgICBjbGljazogY3JlYXRlTGlzdGVuZXJcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW1hZ2UoZXZlbnQpIHtcbiAgICB2YXIgc2hhcGUgPSBlbGVtZW50RmFjdG9yeS5jcmVhdGVTaGFwZSh7XG4gICAgICB0eXBlOiAncG9zdGl0OkltYWdlJ1xuICAgIH0pO1xuXG4gICAgY3JlYXRlLnN0YXJ0KGV2ZW50LCBzaGFwZSwge1xuICAgICAgaGludHM6IHsgc2VsZWN0SW1hZ2U6IHRydWUgfVxuICAgIH0pO1xuICB9XG5cbiAgYXNzaWduKGFjdGlvbnMsIHtcbiAgICAnaGFuZC10b29sJzoge1xuICAgICAgZ3JvdXA6ICd0b29scycsXG4gICAgICBjbGFzc05hbWU6ICdicG1uLWljb24taGFuZC10b29sJyxcbiAgICAgIHRpdGxlOiB0cmFuc2xhdGUoJ0FjdGl2YXRlIHRoZSBoYW5kIHRvb2wnKSxcbiAgICAgIGFjdGlvbjoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICBoYW5kVG9vbC5hY3RpdmF0ZUhhbmQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnbGFzc28tdG9vbCc6IHtcbiAgICAgIGdyb3VwOiAndG9vbHMnLFxuICAgICAgY2xhc3NOYW1lOiAnYnBtbi1pY29uLWxhc3NvLXRvb2wnLFxuICAgICAgdGl0bGU6IHRyYW5zbGF0ZSgnQWN0aXZhdGUgdGhlIGxhc3NvIHRvb2wnKSxcbiAgICAgIGFjdGlvbjoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICBsYXNzb1Rvb2wuYWN0aXZhdGVTZWxlY3Rpb24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnc3BhY2UtdG9vbCc6IHtcbiAgICAgIGdyb3VwOiAndG9vbHMnLFxuICAgICAgY2xhc3NOYW1lOiAnYnBtbi1pY29uLXNwYWNlLXRvb2wnLFxuICAgICAgdGl0bGU6IHRyYW5zbGF0ZSgnQWN0aXZhdGUgdGhlIGNyZWF0ZS9yZW1vdmUgc3BhY2UgdG9vbCcpLFxuICAgICAgYWN0aW9uOiB7XG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHNwYWNlVG9vbC5hY3RpdmF0ZVNlbGVjdGlvbihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICd0b29sLXNlcGFyYXRvcic6IHtcbiAgICAgIGdyb3VwOiAndG9vbHMnLFxuICAgICAgc2VwYXJhdG9yOiB0cnVlXG4gICAgfSxcbiAgICAnY3JlYXRlLnNxdWFyZS1wb3N0aXQnOiBjcmVhdGVBY3Rpb24oXG4gICAgICAncG9zdGl0OlNxdWFyZVBvc3RpdCcsICdwb3N0aXRzJywgJ3Bqcy1wb3N0aXQtc3F1YXJlJyxcbiAgICAgIHRyYW5zbGF0ZSgnQ3JlYXRlIFNxdWFyZSBQb3N0aXQnKSwgeyBjb2xvcjogQ09MT1JTLllFTExPVyB9XG4gICAgKSxcbiAgICAnY3JlYXRlLmNpcmNsZS1wb3N0aXQnOiBjcmVhdGVBY3Rpb24oXG4gICAgICAncG9zdGl0OkNpcmNsZVBvc3RpdCcsICdwb3N0aXRzJywgJ3Bqcy1wb3N0aXQtY2lyY2xlJyxcbiAgICAgIHRyYW5zbGF0ZSgnQ3JlYXRlIENpcmNsZSBQb3N0aXQnKSwgeyBjb2xvcjogQ09MT1JTLlBJTksgfVxuICAgICksXG4gICAgJ3Bvc3RpdC1zZXBhcmF0b3InOiB7XG4gICAgICBncm91cDogJ3Bvc3RpdHMnLFxuICAgICAgc2VwYXJhdG9yOiB0cnVlXG4gICAgfSxcbiAgICAnY3JlYXRlLmltYWdlJzoge1xuICAgICAgZ3JvdXA6ICdhcnRpZmFjdCcsXG4gICAgICBjbGFzc05hbWU6ICdwanMtaW1hZ2UnLFxuICAgICAgdGl0bGU6IHRyYW5zbGF0ZSgnQ3JlYXRlIEltYWdlJyksXG4gICAgICBhY3Rpb246IHtcbiAgICAgICAgY2xpY2s6IGNyZWF0ZUltYWdlLFxuICAgICAgICBkcmFnc3RhcnQ6IGNyZWF0ZUltYWdlXG4gICAgICB9XG4gICAgfSxcbiAgICAnY3JlYXRlLnRleHQtYm94JzogY3JlYXRlQWN0aW9uKFxuICAgICAgJ3Bvc3RpdDpUZXh0Qm94JywgJ2FydGlmYWN0JywgJ3Bqcy10ZXh0LWJveCcsXG4gICAgICB0cmFuc2xhdGUoJ0NyZWF0ZSBUZXh0JylcbiAgICApLFxuICAgICdjcmVhdGUuZ3JvdXAnOiBjcmVhdGVBY3Rpb24oXG4gICAgICAncG9zdGl0Okdyb3VwJywgJ2FydGlmYWN0JywgJ3Bqcy1ncm91cCcsXG4gICAgICB0cmFuc2xhdGUoJ0NyZWF0ZSBHcm91cCcpXG4gICAgKVxuICB9KTtcblxuICByZXR1cm4gYWN0aW9ucztcbn07XG4iLCJpbXBvcnQgUGFsZXR0ZU1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9wYWxldHRlJztcbmltcG9ydCBDcmVhdGVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvY3JlYXRlJztcbmltcG9ydCBTcGFjZVRvb2xNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc3BhY2UtdG9vbCc7XG5pbXBvcnQgTGFzc29Ub29sTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2xhc3NvLXRvb2wnO1xuaW1wb3J0IEhhbmRUb29sTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL2hhbmQtdG9vbCc7XG5pbXBvcnQgdHJhbnNsYXRlIGZyb20gJ2RpYWdyYW0tanMvbGliL2kxOG4vdHJhbnNsYXRlJztcblxuaW1wb3J0IFBhbGV0dGVQcm92aWRlciBmcm9tICcuL1BhbGV0dGVQcm92aWRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBQYWxldHRlTW9kdWxlLFxuICAgIENyZWF0ZU1vZHVsZSxcbiAgICBTcGFjZVRvb2xNb2R1bGUsXG4gICAgTGFzc29Ub29sTW9kdWxlLFxuICAgIEhhbmRUb29sTW9kdWxlLFxuICAgIHRyYW5zbGF0ZVxuICBdLFxuICBfX2luaXRfXzogWyAncGFsZXR0ZVByb3ZpZGVyJyBdLFxuICBwYWxldHRlUHJvdmlkZXI6IFsgJ3R5cGUnLCBQYWxldHRlUHJvdmlkZXIgXVxufTtcbiIsImltcG9ydCB7XG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbi8qKlxuICogVGhpcyBtb2R1bGUgaXMgYW4gZWxlbWVudCBhZ25vc3RpYyByZXBsYWNlIG1lbnUgcHJvdmlkZXIgZm9yIHRoZSBwb3B1cCBtZW51LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZXBsYWNlTWVudVByb3ZpZGVyKFxuICAgIHBvcHVwTWVudSwgbW9kZWxpbmcsIG1vZGRsZSxcbiAgICBwb3N0aXRSZXBsYWNlLCBydWxlcywgdHJhbnNsYXRlKSB7XG5cbiAgdGhpcy5fcG9wdXBNZW51ID0gcG9wdXBNZW51O1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuICB0aGlzLl9tb2RkbGUgPSBtb2RkbGU7XG4gIHRoaXMuX3Bvc3RpdFJlcGxhY2UgPSBwb3N0aXRSZXBsYWNlO1xuICB0aGlzLl9ydWxlcyA9IHJ1bGVzO1xuICB0aGlzLl90cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5cbiAgdGhpcy5yZWdpc3RlcigpO1xufVxuXG5SZXBsYWNlTWVudVByb3ZpZGVyLiRpbmplY3QgPSBbXG4gICdwb3B1cE1lbnUnLFxuICAnbW9kZWxpbmcnLFxuICAnbW9kZGxlJyxcbiAgJ3Bvc3RpdFJlcGxhY2UnLFxuICAncnVsZXMnLFxuICAndHJhbnNsYXRlJ1xuXTtcblxuXG4vKipcbiAqIFJlZ2lzdGVyIHJlcGxhY2UgbWVudSBwcm92aWRlciBpbiB0aGUgcG9wdXAgbWVudVxuICovXG5SZXBsYWNlTWVudVByb3ZpZGVyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9wb3B1cE1lbnUucmVnaXN0ZXJQcm92aWRlcigncG9zdGl0LXJlcGxhY2UnLCB0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBHZXQgYWxsIGVudHJpZXMgZnJvbSByZXBsYWNlT3B0aW9ucyBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgYW5kIGFwcGx5IGZpbHRlcnNcbiAqIG9uIHRoZW0uIEdldCBmb3IgZXhhbXBsZSBvbmx5IGVsZW1lbnRzLCB3aGljaCBhcmUgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgb25lLlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fSBhIGxpc3Qgb2YgbWVudSBlbnRyeSBpdGVtc1xuICovXG5SZXBsYWNlTWVudVByb3ZpZGVyLnByb3RvdHlwZS5nZXRFbnRyaWVzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gIHZhciBydWxlcyA9IHRoaXMuX3J1bGVzO1xuXG4gIHZhciBlbnRyaWVzID0gW107XG5cbiAgaWYgKCFydWxlcy5hbGxvd2VkKCdzaGFwZS5yZXBsYWNlJywgeyBlbGVtZW50OiBlbGVtZW50IH0pKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIGVudHJpZXM7XG59O1xuXG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBoZWFkZXIgaXRlbXMgZm9yIHRoZSBnaXZlbiBlbGVtZW50LiBUaGlzIGluY2x1ZGVzIGJ1dHRvbnNcbiAqIGZvciBtdWx0aSBpbnN0YW5jZSBtYXJrZXJzIGFuZCBmb3IgdGhlIGFkIGhvYyBtYXJrZXIuXG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICpcbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IGEgbGlzdCBvZiBtZW51IGVudHJ5IGl0ZW1zXG4gKi9cblJlcGxhY2VNZW51UHJvdmlkZXIucHJvdG90eXBlLmdldEhlYWRlckVudHJpZXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgdmFyIGhlYWRlckVudHJpZXMgPSBbXTtcblxuICByZXR1cm4gaGVhZGVyRW50cmllcztcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG1lbnUgZW50cnkgb2JqZWN0cyBmb3IgYSBnaXZlbiBlbGVtZW50IGFuZCBmaWx0ZXJzIHRoZSByZXBsYWNlT3B0aW9uc1xuICogYWNjb3JkaW5nIHRvIGEgZmlsdGVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSAge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0gIHtPYmplY3R9IHJlcGxhY2VPcHRpb25zXG4gKlxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gYSBsaXN0IG9mIG1lbnUgaXRlbXNcbiAqL1xuUmVwbGFjZU1lbnVQcm92aWRlci5wcm90b3R5cGUuX2NyZWF0ZUVudHJpZXMgPSBmdW5jdGlvbihlbGVtZW50LCByZXBsYWNlT3B0aW9ucykge1xuICB2YXIgbWVudUVudHJpZXMgPSBbXTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZm9yRWFjaChyZXBsYWNlT3B0aW9ucywgZnVuY3Rpb24oZGVmaW5pdGlvbikge1xuICAgIHZhciBlbnRyeSA9IHNlbGYuX2NyZWF0ZU1lbnVFbnRyeShkZWZpbml0aW9uLCBlbGVtZW50KTtcblxuICAgIG1lbnVFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9KTtcblxuICByZXR1cm4gbWVudUVudHJpZXM7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHNpbmdsZSBtZW51IGVudHJ5IGl0ZW0uXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBkZWZpbml0aW9uIGEgc2luZ2xlIHJlcGxhY2Ugb3B0aW9ucyBkZWZpbml0aW9uIG9iamVjdFxuICogQHBhcmFtICB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbYWN0aW9uXSBhbiBhY3Rpb24gY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggZ2V0cyBjYWxsZWQgd2hlblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBtZW51IGVudHJ5IGlzIGJlaW5nIHRyaWdnZXJlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IG1lbnUgZW50cnkgaXRlbVxuICovXG5SZXBsYWNlTWVudVByb3ZpZGVyLnByb3RvdHlwZS5fY3JlYXRlTWVudUVudHJ5ID0gZnVuY3Rpb24oZGVmaW5pdGlvbiwgZWxlbWVudCwgYWN0aW9uKSB7XG4gIHZhciB0cmFuc2xhdGUgPSB0aGlzLl90cmFuc2xhdGU7XG4gIHZhciByZXBsYWNlRWxlbWVudCA9IHRoaXMuX3Bvc3RpdFJlcGxhY2UucmVwbGFjZUVsZW1lbnQ7XG5cbiAgdmFyIHJlcGxhY2VBY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcmVwbGFjZUVsZW1lbnQoZWxlbWVudCwgZGVmaW5pdGlvbi50YXJnZXQpO1xuICB9O1xuXG4gIGFjdGlvbiA9IGFjdGlvbiB8fCByZXBsYWNlQWN0aW9uO1xuXG4gIHZhciBtZW51RW50cnkgPSB7XG4gICAgbGFiZWw6IHRyYW5zbGF0ZShkZWZpbml0aW9uLmxhYmVsKSxcbiAgICBjbGFzc05hbWU6IGRlZmluaXRpb24uY2xhc3NOYW1lLFxuICAgIGlkOiBkZWZpbml0aW9uLmFjdGlvbk5hbWUsXG4gICAgYWN0aW9uOiBhY3Rpb25cbiAgfTtcblxuICByZXR1cm4gbWVudUVudHJ5O1xufTtcbiIsImltcG9ydCBQb3B1cE1lbnVNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvcG9wdXAtbWVudSc7XG5pbXBvcnQgUmVwbGFjZU1vZHVsZSBmcm9tICcuLi9yZXBsYWNlJztcblxuaW1wb3J0IFJlcGxhY2VNZW51UHJvdmlkZXIgZnJvbSAnLi9SZXBsYWNlTWVudVByb3ZpZGVyJztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgUG9wdXBNZW51TW9kdWxlLFxuICAgIFJlcGxhY2VNb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFsgJ3JlcGxhY2VNZW51UHJvdmlkZXInIF0sXG4gIHJlcGxhY2VNZW51UHJvdmlkZXI6IFsgJ3R5cGUnLCBSZXBsYWNlTWVudVByb3ZpZGVyIF1cbn07IiwiaW1wb3J0IENvbW1hbmRJbnRlcmNlcHRvciBmcm9tICdkaWFncmFtLWpzL2xpYi9jb21tYW5kL0NvbW1hbmRJbnRlcmNlcHRvcic7XG5cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBjc3NFc2NhcGUgZnJvbSAnY3NzLmVzY2FwZSc7XG5cbmltcG9ydCB7XG4gIGFzc2lnbixcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIHF1ZXJ5IGFzIGRvbVF1ZXJ5XG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQge1xuICBhdHRyIGFzIHN2Z0F0dHJcbn0gZnJvbSAndGlueS1zdmcnO1xuXG52YXIgTE9XX1BSSU9SSVRZID0gMjUwO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvc3RpdFJlcGxhY2VQcmV2aWV3KFxuICAgIGV2ZW50QnVzLCBlbGVtZW50UmVnaXN0cnksIGVsZW1lbnRGYWN0b3J5LFxuICAgIGNhbnZhcywgcHJldmlld1N1cHBvcnQpIHtcblxuICBDb21tYW5kSW50ZXJjZXB0b3IuY2FsbCh0aGlzLCBldmVudEJ1cyk7XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIHZpc3VhbHMgb2YgYWxsIGVsZW1lbnRzIGluIHRoZSBjb250ZXh0IHdoaWNoIGNhbiBiZSByZXBsYWNlZFxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VWaXN1YWwoY29udGV4dCkge1xuXG4gICAgdmFyIHJlcGxhY2VtZW50cyA9IGNvbnRleHQuY2FuRXhlY3V0ZS5yZXBsYWNlbWVudHM7XG5cbiAgICBmb3JFYWNoKHJlcGxhY2VtZW50cywgZnVuY3Rpb24ocmVwbGFjZW1lbnQpIHtcblxuICAgICAgdmFyIGlkID0gcmVwbGFjZW1lbnQub2xkRWxlbWVudElkO1xuXG4gICAgICB2YXIgbmV3RWxlbWVudCA9IHtcbiAgICAgICAgdHlwZTogcmVwbGFjZW1lbnQubmV3RWxlbWVudFR5cGVcbiAgICAgIH07XG5cbiAgICAgIC8vIGlmIHRoZSB2aXN1YWwgb2YgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSByZXBsYWNlZFxuICAgICAgaWYgKGNvbnRleHQudmlzdWFsUmVwbGFjZW1lbnRzW2lkXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudFJlZ2lzdHJ5LmdldChpZCk7XG5cbiAgICAgIGFzc2lnbihuZXdFbGVtZW50LCB7IHg6IGVsZW1lbnQueCwgeTogZWxlbWVudC55IH0pO1xuXG4gICAgICAvLyBjcmVhdGUgYSB0ZW1wb3Jhcnkgc2hhcGVcbiAgICAgIHZhciB0ZW1wU2hhcGUgPSBlbGVtZW50RmFjdG9yeS5jcmVhdGVTaGFwZShuZXdFbGVtZW50KTtcblxuICAgICAgY2FudmFzLmFkZFNoYXBlKHRlbXBTaGFwZSwgZWxlbWVudC5wYXJlbnQpO1xuXG4gICAgICAvLyBzZWxlY3QgdGhlIG9yaWdpbmFsIFNWRyBlbGVtZW50IHJlbGF0ZWQgdG8gdGhlIGVsZW1lbnQgYW5kIGhpZGUgaXRcbiAgICAgIHZhciBnZnggPSBkb21RdWVyeSgnW2RhdGEtZWxlbWVudC1pZD1cIicgKyBjc3NFc2NhcGUoZWxlbWVudC5pZCkgKyAnXCJdJywgY29udGV4dC5kcmFnR3JvdXApO1xuXG4gICAgICBpZiAoZ2Z4KSB7XG4gICAgICAgIHN2Z0F0dHIoZ2Z4LCB7IGRpc3BsYXk6ICdub25lJyB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gY2xvbmUgdGhlIGdmeCBvZiB0aGUgdGVtcG9yYXJ5IHNoYXBlIGFuZCBhZGQgaXQgdG8gdGhlIGRyYWcgZ3JvdXBcbiAgICAgIHZhciBkcmFnZ2VyID0gcHJldmlld1N1cHBvcnQuYWRkRHJhZ2dlcih0ZW1wU2hhcGUsIGNvbnRleHQuZHJhZ0dyb3VwKTtcblxuICAgICAgY29udGV4dC52aXN1YWxSZXBsYWNlbWVudHNbaWRdID0gZHJhZ2dlcjtcblxuICAgICAgY2FudmFzLnJlbW92ZVNoYXBlKHRlbXBTaGFwZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSB0aGUgb3JpZ2luYWwgdmlzdWFscyBvZiB0aGUgcHJldmlvdXNseSByZXBsYWNlZCBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIHJlc3RvcmVWaXN1YWwoY29udGV4dCkge1xuXG4gICAgdmFyIHZpc3VhbFJlcGxhY2VtZW50cyA9IGNvbnRleHQudmlzdWFsUmVwbGFjZW1lbnRzO1xuXG4gICAgZm9yRWFjaCh2aXN1YWxSZXBsYWNlbWVudHMsIGZ1bmN0aW9uKGRyYWdnZXIsIGlkKSB7XG5cbiAgICAgIHZhciBvcmlnaW5hbEdmeCA9IGRvbVF1ZXJ5KCdbZGF0YS1lbGVtZW50LWlkPVwiJyArIGNzc0VzY2FwZShpZCkgKyAnXCJdJywgY29udGV4dC5kcmFnR3JvdXApO1xuXG4gICAgICBpZiAob3JpZ2luYWxHZngpIHtcbiAgICAgICAgc3ZnQXR0cihvcmlnaW5hbEdmeCwgeyBkaXNwbGF5OiAnaW5saW5lJyB9KTtcbiAgICAgIH1cblxuICAgICAgZHJhZ2dlci5yZW1vdmUoKTtcblxuICAgICAgaWYgKHZpc3VhbFJlcGxhY2VtZW50c1tpZF0pIHtcbiAgICAgICAgZGVsZXRlIHZpc3VhbFJlcGxhY2VtZW50c1tpZF07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBldmVudEJ1cy5vbignc2hhcGUubW92ZS5tb3ZlJywgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBjYW5FeGVjdXRlID0gY29udGV4dC5jYW5FeGVjdXRlO1xuXG4gICAgaWYgKCFjb250ZXh0LnZpc3VhbFJlcGxhY2VtZW50cykge1xuICAgICAgY29udGV4dC52aXN1YWxSZXBsYWNlbWVudHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoY2FuRXhlY3V0ZSAmJiBjYW5FeGVjdXRlLnJlcGxhY2VtZW50cykge1xuICAgICAgcmVwbGFjZVZpc3VhbChjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdG9yZVZpc3VhbChjb250ZXh0KTtcbiAgICB9XG4gIH0pO1xufVxuXG5Qb3N0aXRSZXBsYWNlUHJldmlldy4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnZWxlbWVudFJlZ2lzdHJ5JyxcbiAgJ2VsZW1lbnRGYWN0b3J5JyxcbiAgJ2NhbnZhcycsXG4gICdwcmV2aWV3U3VwcG9ydCdcbl07XG5cbmluaGVyaXRzKFBvc3RpdFJlcGxhY2VQcmV2aWV3LCBDb21tYW5kSW50ZXJjZXB0b3IpOyIsImltcG9ydCBQcmV2aWV3U3VwcG9ydE1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9wcmV2aWV3LXN1cHBvcnQnO1xuXG5pbXBvcnQgUG9zdGl0UmVwbGFjZVByZXZpZXcgZnJvbSAnLi9Qb3N0aXRSZXBsYWNlUHJldmlldyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBQcmV2aWV3U3VwcG9ydE1vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAncG9zdGl0UmVwbGFjZVByZXZpZXcnIF0sXG4gIHBvc3RpdFJlcGxhY2VQcmV2aWV3OiBbICd0eXBlJywgUG9zdGl0UmVwbGFjZVByZXZpZXcgXVxufTtcbiIsImltcG9ydCB7XG4gIHBpY2ssXG4gIGFzc2lnbixcbiAgZm9yRWFjaCxcbiAgaXNBcnJheSxcbiAgaXNVbmRlZmluZWRcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgeyBnZXRQcm9wZXJ0eU5hbWVzIH0gZnJvbSAnLi4vY29weS1wYXN0ZS9Nb2RkbGVDb3B5JztcblxuZnVuY3Rpb24gY29weVByb3BlcnRpZXMoc291cmNlLCB0YXJnZXQsIHByb3BlcnRpZXMpIHtcbiAgaWYgKCFpc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgcHJvcGVydGllcyA9IFsgcHJvcGVydGllcyBdO1xuICB9XG5cbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIGlmICghaXNVbmRlZmluZWQoc291cmNlW3Byb3BlcnR5XSkpIHtcbiAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBDVVNUT01fUFJPUEVSVElFUyA9IFtcbiAgJ2NhbmNlbEFjdGl2aXR5JyxcbiAgJ2luc3RhbnRpYXRlJyxcbiAgJ2V2ZW50R2F0ZXdheVR5cGUnLFxuICAndHJpZ2dlcmVkQnlFdmVudCcsXG4gICdpc0ludGVycnVwdGluZydcbl07XG5cblxuXG4vKipcbiAqIFRoaXMgbW9kdWxlIHRha2VzIGNhcmUgb2YgcmVwbGFjaW5nIHBvc3RpdCBlbGVtZW50c1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQb3N0aXRSZXBsYWNlKFxuICAgIHBvc3RpdEZhY3RvcnksXG4gICAgZWxlbWVudEZhY3RvcnksXG4gICAgbW9kZGxlQ29weSxcbiAgICBtb2RlbGluZyxcbiAgICByZXBsYWNlLFxuICAgIHNlbGVjdGlvblxuKSB7XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIGEgbmV3IGJ1c2luZXNzIG9iamVjdCBmb3IgdGhlIHJlcGxhY2VtZW50IGVsZW1lbnRcbiAgICogYW5kIHRyaWdnZXJzIHRoZSByZXBsYWNlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAgICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbaGludHNdXG4gICAqXG4gICAqIEByZXR1cm4ge2Rqcy5tb2RlbC5CYXNlfSB0aGUgbmV3bHkgY3JlYXRlZCBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlRWxlbWVudChlbGVtZW50LCB0YXJnZXQsIGhpbnRzKSB7XG5cbiAgICBoaW50cyA9IGhpbnRzIHx8IHt9O1xuXG4gICAgdmFyIHR5cGUgPSB0YXJnZXQudHlwZSxcbiAgICAgICAgb2xkQnVzaW5lc3NPYmplY3QgPSBlbGVtZW50LmJ1c2luZXNzT2JqZWN0O1xuXG4gICAgdmFyIG5ld0J1c2luZXNzT2JqZWN0ID0gcG9zdGl0RmFjdG9yeS5jcmVhdGUodHlwZSk7XG5cbiAgICB2YXIgbmV3RWxlbWVudCA9IHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBidXNpbmVzc09iamVjdDogbmV3QnVzaW5lc3NPYmplY3RcbiAgICB9O1xuXG4gICAgdmFyIGVsZW1lbnRQcm9wcyA9IGdldFByb3BlcnR5TmFtZXMob2xkQnVzaW5lc3NPYmplY3QuJGRlc2NyaXB0b3IpLFxuICAgICAgICBuZXdFbGVtZW50UHJvcHMgPSBnZXRQcm9wZXJ0eU5hbWVzKG5ld0J1c2luZXNzT2JqZWN0LiRkZXNjcmlwdG9yLCB0cnVlKSxcbiAgICAgICAgY29weVByb3BzID0gaW50ZXJzZWN0aW9uKGVsZW1lbnRQcm9wcywgbmV3RWxlbWVudFByb3BzKTtcblxuICAgIC8vIGluaXRpYWxpemUgc3BlY2lhbCBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGFyZ2V0IGRlZmluaXRpb25cbiAgICBhc3NpZ24obmV3QnVzaW5lc3NPYmplY3QsIHBpY2sodGFyZ2V0LCBDVVNUT01fUFJPUEVSVElFUykpO1xuXG4gICAgdmFyIHByb3BlcnRpZXMgPSBjb3B5UHJvcHM7XG5cbiAgICBuZXdCdXNpbmVzc09iamVjdCA9IG1vZGRsZUNvcHkuY29weUVsZW1lbnQoXG4gICAgICBvbGRCdXNpbmVzc09iamVjdCxcbiAgICAgIG5ld0J1c2luZXNzT2JqZWN0LFxuICAgICAgcHJvcGVydGllc1xuICAgICk7XG5cbiAgICBuZXdCdXNpbmVzc09iamVjdC5uYW1lID0gb2xkQnVzaW5lc3NPYmplY3QubmFtZTtcblxuICAgIG5ld0VsZW1lbnQuZGkgPSB7fTtcblxuICAgIC8vIGZpbGwgYW5kIHN0cm9rZSB3aWxsIGJlIHNldCB0byBESVxuICAgIGNvcHlQcm9wZXJ0aWVzKG9sZEJ1c2luZXNzT2JqZWN0LmRpLCBuZXdFbGVtZW50LmRpLCBbXG4gICAgICAnZmlsbCcsXG4gICAgICAnc3Ryb2tlJ1xuICAgIF0pO1xuXG4gICAgbmV3RWxlbWVudCA9IHJlcGxhY2UucmVwbGFjZUVsZW1lbnQoZWxlbWVudCwgbmV3RWxlbWVudCwgaGludHMpO1xuXG4gICAgaWYgKGhpbnRzLnNlbGVjdCAhPT0gZmFsc2UpIHtcbiAgICAgIHNlbGVjdGlvbi5zZWxlY3QobmV3RWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cblxuICB0aGlzLnJlcGxhY2VFbGVtZW50ID0gcmVwbGFjZUVsZW1lbnQ7XG59XG5cblBvc3RpdFJlcGxhY2UuJGluamVjdCA9IFtcbiAgJ3Bvc3RpdEZhY3RvcnknLFxuICAnZWxlbWVudEZhY3RvcnknLFxuICAnbW9kZGxlQ29weScsXG4gICdtb2RlbGluZycsXG4gICdyZXBsYWNlJyxcbiAgJ3NlbGVjdGlvbidcbl07XG5cbi8qKlxuICogQ29tcHV0ZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0d28gYXJyYXlzLlxuICovXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oYTEsIGEyKSB7XG4gIHJldHVybiBhMS5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gYTIuaW5kZXhPZihlbCkgIT09IC0xO1xuICB9KTtcbn1cbiIsImltcG9ydCBDb3B5UGFzdGVNb2R1bGUgZnJvbSAnLi4vY29weS1wYXN0ZSc7XG5pbXBvcnQgUmVwbGFjZU1vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9yZXBsYWNlJztcbmltcG9ydCBTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvc2VsZWN0aW9uJztcblxuaW1wb3J0IFBvc3RpdFJlcGxhY2UgZnJvbSAnLi9Qb3N0aXRSZXBsYWNlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIENvcHlQYXN0ZU1vZHVsZSxcbiAgICBSZXBsYWNlTW9kdWxlLFxuICAgIFNlbGVjdGlvbk1vZHVsZVxuICBdLFxuICBwb3N0aXRSZXBsYWNlOiBbICd0eXBlJywgUG9zdGl0UmVwbGFjZSBdXG59O1xuIiwiaW1wb3J0IHtcbiAgZXZlcnlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQge1xuICBpc1xufSBmcm9tICcuLi8uLi91dGlsL01vZGVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGlzTGFiZWxcbn0gZnJvbSAnLi4vLi4vdXRpbC9MYWJlbFV0aWwnO1xuXG5pbXBvcnQgUnVsZVByb3ZpZGVyIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3J1bGVzL1J1bGVQcm92aWRlcic7XG5pbXBvcnQgeyBpc0FueSB9IGZyb20gJy4uL21vZGVsaW5nL3V0aWwvTW9kZWxpbmdVdGlsJztcblxuXG4vKipcbiAqIFBvc3RpdCBzcGVjaWZpYyBtb2RlbGluZyBydWxlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvc3RpdFJ1bGVzKGV2ZW50QnVzKSB7XG4gIFJ1bGVQcm92aWRlci5jYWxsKHRoaXMsIGV2ZW50QnVzKTtcbn1cblxuaW5oZXJpdHMoUG9zdGl0UnVsZXMsIFJ1bGVQcm92aWRlcik7XG5cblBvc3RpdFJ1bGVzLiRpbmplY3QgPSBbICdldmVudEJ1cycgXTtcblxuUG9zdGl0UnVsZXMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICB0aGlzLmFkZFJ1bGUoJ3NoYXBlLnJlc2l6ZScsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIG5ld0JvdW5kcyA9IGNvbnRleHQubmV3Qm91bmRzO1xuXG4gICAgcmV0dXJuIGNhblJlc2l6ZShzaGFwZSwgbmV3Qm91bmRzKTtcbiAgfSk7XG5cbiAgdGhpcy5hZGRSdWxlKCdlbGVtZW50cy5jcmVhdGUnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIGVsZW1lbnRzID0gY29udGV4dC5lbGVtZW50cyxcbiAgICAgICAgcG9zaXRpb24gPSBjb250ZXh0LnBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQgPSBjb250ZXh0LnRhcmdldDtcblxuICAgIHJldHVybiBldmVyeShlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQuaG9zdCkge1xuICAgICAgICByZXR1cm4gY2FuQXR0YWNoKGVsZW1lbnQsIGVsZW1lbnQuaG9zdCwgbnVsbCwgcG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FuQ3JlYXRlKGVsZW1lbnQsIHRhcmdldCwgbnVsbCwgcG9zaXRpb24pO1xuICAgIH0pO1xuICB9KTtcblxuICB0aGlzLmFkZFJ1bGUoJ2VsZW1lbnRzLm1vdmUnLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgdGFyZ2V0ID0gY29udGV4dC50YXJnZXQsXG4gICAgICAgIHNoYXBlcyA9IGNvbnRleHQuc2hhcGVzLFxuICAgICAgICBwb3NpdGlvbiA9IGNvbnRleHQucG9zaXRpb247XG5cbiAgICByZXR1cm4gY2FuQXR0YWNoKHNoYXBlcywgdGFyZ2V0LCBudWxsLCBwb3NpdGlvbikgfHxcbiAgICAgICAgICAgY2FuTW92ZShzaGFwZXMsIHRhcmdldCwgcG9zaXRpb24pO1xuICB9KTtcblxuICB0aGlzLmFkZFJ1bGUoJ3NoYXBlLmNyZWF0ZScsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2FuQ3JlYXRlKFxuICAgICAgY29udGV4dC5zaGFwZSxcbiAgICAgIGNvbnRleHQudGFyZ2V0LFxuICAgICAgY29udGV4dC5zb3VyY2UsXG4gICAgICBjb250ZXh0LnBvc2l0aW9uXG4gICAgKTtcbiAgfSk7XG5cbiAgdGhpcy5hZGRSdWxlKCdzaGFwZS5hdHRhY2gnLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICByZXR1cm4gY2FuQXR0YWNoKFxuICAgICAgY29udGV4dC5zaGFwZSxcbiAgICAgIGNvbnRleHQudGFyZ2V0LFxuICAgICAgbnVsbCxcbiAgICAgIGNvbnRleHQucG9zaXRpb25cbiAgICApO1xuICB9KTtcblxuICB0aGlzLmFkZFJ1bGUoJ2VsZW1lbnQuY29weScsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudCxcbiAgICAgICAgZWxlbWVudHMgPSBjb250ZXh0LmVsZW1lbnRzO1xuXG4gICAgcmV0dXJuIGNhbkNvcHkoZWxlbWVudHMsIGVsZW1lbnQpO1xuICB9KTtcbn07XG5cblBvc3RpdFJ1bGVzLnByb3RvdHlwZS5jYW5Nb3ZlID0gY2FuTW92ZTtcblxuUG9zdGl0UnVsZXMucHJvdG90eXBlLmNhbkF0dGFjaCA9IGNhbkF0dGFjaDtcblxuUG9zdGl0UnVsZXMucHJvdG90eXBlLmNhbkRyb3AgPSBjYW5Ecm9wO1xuXG5Qb3N0aXRSdWxlcy5wcm90b3R5cGUuY2FuQ3JlYXRlID0gY2FuQ3JlYXRlO1xuXG5Qb3N0aXRSdWxlcy5wcm90b3R5cGUuY2FuUmVwbGFjZSA9IGNhblJlcGxhY2U7XG5cblBvc3RpdFJ1bGVzLnByb3RvdHlwZS5jYW5SZXNpemUgPSBjYW5SZXNpemU7XG5cblBvc3RpdFJ1bGVzLnByb3RvdHlwZS5jYW5Db3B5ID0gY2FuQ29weTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgcnVsZSBjaGVja2luZ1xuICovXG5cbmZ1bmN0aW9uIGlzU2FtZShhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRzKGVsZW1lbnQpIHtcblxuICB2YXIgcGFyZW50cyA9IFtdO1xuXG4gIHdoaWxlIChlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHBhcmVudHMucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyZW50cztcbn1cblxuZnVuY3Rpb24gaXNQYXJlbnQocG9zc2libGVQYXJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIGFsbFBhcmVudHMgPSBnZXRQYXJlbnRzKGVsZW1lbnQpO1xuICByZXR1cm4gYWxsUGFyZW50cy5pbmRleE9mKHBvc3NpYmxlUGFyZW50KSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGlzR3JvdXAoZWxlbWVudCkge1xuICByZXR1cm4gaXMoZWxlbWVudCwgJ3Bvc3RpdDpHcm91cCcpICYmICFlbGVtZW50LmxhYmVsVGFyZ2V0O1xufVxuXG4vKipcbiAqIENhbiBhbiBlbGVtZW50IGJlIGRyb3BwZWQgaW50byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBjYW5Ecm9wKGVsZW1lbnQsIHRhcmdldCkge1xuXG4gIC8vIGNhbiBtb3ZlIGxhYmVsc1xuICBpZiAoaXNMYWJlbChlbGVtZW50KSB8fCBpc0dyb3VwKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBkcm9wIGJvYXJkIGVsZW1lbnRzIG9udG8gYm9hcmRzXG4gIGlmIChpcyhlbGVtZW50LCAncG9zdGl0OkJvYXJkRWxlbWVudCcpICYmIGlzKHRhcmdldCwgJ3Bvc3RpdDpQb3N0aXRCb2FyZCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNhblJlcGxhY2UoZWxlbWVudHMsIHRhcmdldCkge1xuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuZnVuY3Rpb24gY2FuQXR0YWNoKGVsZW1lbnRzLCB0YXJnZXQpIHtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgZWxlbWVudHMgPSBbIGVsZW1lbnRzIF07XG4gIH1cblxuICAvLyBvbmx5IChyZS0pYXR0YWNoIG9uZSBlbGVtZW50IGF0IGEgdGltZVxuICBpZiAoZWxlbWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1swXTtcblxuICAvLyBkbyBub3QgYXR0YWNoIGxhYmVsc1xuICBpZiAoaXNMYWJlbChlbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpcyh0YXJnZXQsICdwb3N0aXQ6Qm9hcmRFbGVtZW50JykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gJ2F0dGFjaCc7XG59XG5cblxuZnVuY3Rpb24gY2FuTW92ZShlbGVtZW50cywgdGFyZ2V0KSB7XG5cbiAgLy8gYWxsb3cgZGVmYXVsdCBtb3ZlIGNoZWNrIHRvIHN0YXJ0IG1vdmUgb3BlcmF0aW9uXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudHMuZXZlcnkoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiBjYW5Ecm9wKGVsZW1lbnQsIHRhcmdldCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjYW5DcmVhdGUoc2hhcGUsIHRhcmdldCwgc291cmNlLCBwb3NpdGlvbikge1xuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzTGFiZWwoc2hhcGUpIHx8IGlzR3JvdXAoc2hhcGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNTYW1lKHNvdXJjZSwgdGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGVuc3VyZSB3ZSBkbyBub3QgZHJvcCB0aGUgZWxlbWVudFxuICAvLyBpbnRvIHNvdXJjZVxuICBpZiAoc291cmNlICYmIGlzUGFyZW50KHNvdXJjZSwgdGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjYW5Ecm9wKHNoYXBlLCB0YXJnZXQsIHBvc2l0aW9uKTtcbn1cblxuZnVuY3Rpb24gY2FuUmVzaXplKHNoYXBlLCBuZXdCb3VuZHMpIHtcblxuICBpZiAoaXNBbnkoc2hhcGUsIFsgJ3Bvc3RpdDpQb3N0aXQnLCAncG9zdGl0OlRleHRCb3gnIF0pKSB7XG4gICAgcmV0dXJuICFuZXdCb3VuZHMgfHwgKG5ld0JvdW5kcy53aWR0aCA+PSA1MCAmJiBuZXdCb3VuZHMuaGVpZ2h0ID49IDUwKTtcbiAgfVxuXG4gIGlmIChpcyhzaGFwZSwgJ3Bvc3RpdDpHcm91cCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXMoc2hhcGUsICdwb3N0aXQ6SW1hZ2UnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjYW5Db3B5KGVsZW1lbnRzLCBlbGVtZW50KSB7XG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IFJ1bGVzTW9kdWxlIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3J1bGVzJztcblxuaW1wb3J0IFBvc3RpdFJ1bGVzIGZyb20gJy4vUG9zdGl0UnVsZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgUnVsZXNNb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFsgJ3Bvc3RpdFJ1bGVzJyBdLFxuICBwb3N0aXRSdWxlczogWyAndHlwZScsIFBvc3RpdFJ1bGVzIF1cbn07XG4iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgQ3JlYXRlTW92ZVNuYXBwaW5nIGZyb20gJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL3NuYXBwaW5nL0NyZWF0ZU1vdmVTbmFwcGluZyc7XG5cbi8qKlxuICogU25hcCBkdXJpbmcgY3JlYXRlIGFuZCBtb3ZlLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0luamVjdG9yfSBpbmplY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQb3N0aXRDcmVhdGVNb3ZlU25hcHBpbmcoaW5qZWN0b3IpIHtcbiAgaW5qZWN0b3IuaW52b2tlKENyZWF0ZU1vdmVTbmFwcGluZywgdGhpcyk7XG59XG5cbmluaGVyaXRzKFBvc3RpdENyZWF0ZU1vdmVTbmFwcGluZywgQ3JlYXRlTW92ZVNuYXBwaW5nKTtcblxuUG9zdGl0Q3JlYXRlTW92ZVNuYXBwaW5nLiRpbmplY3QgPSBbXG4gICdpbmplY3Rvcidcbl07XG5cblBvc3RpdENyZWF0ZU1vdmVTbmFwcGluZy5wcm90b3R5cGUuaW5pdFNuYXAgPSBmdW5jdGlvbihldmVudCkge1xuICByZXR1cm4gQ3JlYXRlTW92ZVNuYXBwaW5nLnByb3RvdHlwZS5pbml0U25hcC5jYWxsKHRoaXMsIGV2ZW50KTtcbn07XG5cblBvc3RpdENyZWF0ZU1vdmVTbmFwcGluZy5wcm90b3R5cGUuYWRkU25hcFRhcmdldFBvaW50cyA9IGZ1bmN0aW9uKHNuYXBQb2ludHMsIHNoYXBlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIENyZWF0ZU1vdmVTbmFwcGluZy5wcm90b3R5cGUuYWRkU25hcFRhcmdldFBvaW50cy5jYWxsKHRoaXMsIHNuYXBQb2ludHMsIHNoYXBlLCB0YXJnZXQpO1xufTtcblxuUG9zdGl0Q3JlYXRlTW92ZVNuYXBwaW5nLnByb3RvdHlwZS5nZXRTbmFwVGFyZ2V0cyA9IGZ1bmN0aW9uKHNoYXBlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIENyZWF0ZU1vdmVTbmFwcGluZy5wcm90b3R5cGUuZ2V0U25hcFRhcmdldHMuY2FsbCh0aGlzLCBzaGFwZSwgdGFyZ2V0KTtcbn07XG4iLCJpbXBvcnQgUG9zdGl0Q3JlYXRlTW92ZVNuYXBwaW5nIGZyb20gJy4vUG9zdGl0Q3JlYXRlTW92ZVNuYXBwaW5nJztcbmltcG9ydCBTbmFwcGluZ01vZHVsZSBmcm9tICdkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9zbmFwcGluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFsgU25hcHBpbmdNb2R1bGUgXSxcbiAgX19pbml0X186IFtcbiAgICAnY3JlYXRlTW92ZVNuYXBwaW5nJ1xuICBdLFxuICBjcmVhdGVNb3ZlU25hcHBpbmc6IFsgJ3R5cGUnLCBQb3N0aXRDcmVhdGVNb3ZlU25hcHBpbmcgXVxufTsiLCJpbXBvcnQgUG9zdGl0VHJlZVdhbGtlciBmcm9tICcuL1Bvc3RpdFRyZWVXYWxrZXInO1xuXG4vKipcbiAqIFRoZSBpbXBvcnRQb3N0aXREaWFncmFtIHJlc3VsdC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBpbXBvcnRQb3N0aXREaWFncmFtUmVzdWx0XG4gKlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSB3YXJuaW5nc1xuICovXG5cbi8qKlxuKiBUaGUgaW1wb3J0UG9zdGl0RGlhZ3JhbSBlcnJvci5cbipcbiogQHR5cGVkZWYge0Vycm9yfSBpbXBvcnRQb3N0aXREaWFncmFtRXJyb3JcbipcbiogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSB3YXJuaW5nc1xuKi9cblxuLyoqXG4gKiBJbXBvcnQgdGhlIGRlZmluaXRpb25zIGludG8gYSBkaWFncmFtLlxuICpcbiAqIEVycm9ycyBhbmQgd2FybmluZ3MgYXJlIHJlcG9ydGVkIHRocm91Z2ggdGhlIHNwZWNpZmllZCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0gIHtkanMuRGlhZ3JhbX0gZGlhZ3JhbVxuICogQHBhcmFtICB7TW9kZGxlRWxlbWVudDxEZWZpbml0aW9ucz59IGRlZmluaXRpb25zXG4gKiBAcGFyYW0gIHtNb2RkbGVFbGVtZW50PFBvdGl0Um9vdEJvYXJkPn0gW3Jvb3RCb2FyZF0gdGhlIGRpYWdyYW0gdG8gYmUgcmVuZGVyZWRcbiAqIChpZiBub3QgcHJvdmlkZWQsIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZW5kZXJlZClcbiAqXG4gKiBSZXR1cm5zIHtQcm9taXNlPGltcG9ydFBvc3RpdERpYWdyYW1SZXN1bHQsIGltcG9ydFBvc3RpdERpYWdyYW1FcnJvcj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbXBvcnRQb3N0aXREaWFncmFtKGRpYWdyYW0sIGRlZmluaXRpb25zLCByb290Qm9hcmQpIHtcblxuICB2YXIgaW1wb3J0ZXIsXG4gICAgICBldmVudEJ1cyxcbiAgICAgIHRyYW5zbGF0ZTtcblxuICB2YXIgZXJyb3IsXG4gICAgICB3YXJuaW5ncyA9IFtdO1xuXG4gIC8qKlxuICAgKiBXYWxrIHRoZSBkaWFncmFtIHNlbWFudGljYWxseSwgaW1wb3J0aW5nICg9ZHJhd2luZylcbiAgICogYWxsIGVsZW1lbnRzIHlvdSBlbmNvdW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudDxEZWZpbml0aW9ucz59IGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudDxQb3N0aXRSb290Qm9hcmQ+fSByb290Qm9hcmRcbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlcihkZWZpbml0aW9ucywgcm9vdEJvYXJkKSB7XG5cbiAgICB2YXIgdmlzaXRvciA9IHtcblxuICAgICAgcm9vdDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaW1wb3J0ZXIuYWRkKGVsZW1lbnQpO1xuICAgICAgfSxcblxuICAgICAgZWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgcGFyZW50U2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIGltcG9ydGVyLmFkZChlbGVtZW50LCBwYXJlbnRTaGFwZSk7XG4gICAgICB9LFxuXG4gICAgICBlcnJvcjogZnVuY3Rpb24obWVzc2FnZSwgY29udGV4dCkge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKHsgbWVzc2FnZTogbWVzc2FnZSwgY29udGV4dDogY29udGV4dCB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHdhbGtlciA9IG5ldyBQb3N0aXRUcmVlV2Fsa2VyKHZpc2l0b3IsIHRyYW5zbGF0ZSk7XG5cbiAgICAvLyB0cmF2ZXJzZSB4bWwgZG9jdW1lbnQgbW9kZWwsXG4gICAgLy8gc3RhcnRpbmcgYXQgZGVmaW5pdGlvbnNcbiAgICB3YWxrZXIuaGFuZGxlRGVmaW5pdGlvbnMoZGVmaW5pdGlvbnMsIHJvb3RCb2FyZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGltcG9ydGVyID0gZGlhZ3JhbS5nZXQoJ3Bvc3RpdEltcG9ydGVyJyk7XG4gICAgICBldmVudEJ1cyA9IGRpYWdyYW0uZ2V0KCdldmVudEJ1cycpO1xuICAgICAgdHJhbnNsYXRlID0gZGlhZ3JhbS5nZXQoJ3RyYW5zbGF0ZScpO1xuXG4gICAgICBldmVudEJ1cy5maXJlKCdpbXBvcnQucmVuZGVyLnN0YXJ0JywgeyBkZWZpbml0aW9uczogZGVmaW5pdGlvbnMgfSk7XG5cbiAgICAgIHJlbmRlcihkZWZpbml0aW9ucywgcm9vdEJvYXJkKTtcblxuICAgICAgZXZlbnRCdXMuZmlyZSgnaW1wb3J0LnJlbmRlci5jb21wbGV0ZScsIHtcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICB3YXJuaW5nczogd2FybmluZ3NcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzb2x2ZSh7IHdhcm5pbmdzOiB3YXJuaW5ncyB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgIH1cbiAgfSk7XG59IiwiaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHsgaXMgfSBmcm9tICcuLi91dGlsL01vZGVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGlzTGFiZWxFeHRlcm5hbCxcbiAgZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kc1xufSBmcm9tICcuLi91dGlsL0xhYmVsVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldExhYmVsXG59IGZyb20gJy4uL2ZlYXR1cmVzL2xhYmVsLWVkaXRpbmcvTGFiZWxVdGlsJztcblxuaW1wb3J0IHtcbiAgZWxlbWVudFRvU3RyaW5nXG59IGZyb20gJy4vVXRpbCc7XG5cblxuZnVuY3Rpb24gZWxlbWVudERhdGEoc2VtYW50aWMsIGF0dHJzKSB7XG4gIHJldHVybiBhc3NpZ24oe1xuICAgIGlkOiBzZW1hbnRpYy5pZCxcbiAgICB0eXBlOiBzZW1hbnRpYy4kdHlwZSxcbiAgICBidXNpbmVzc09iamVjdDogc2VtYW50aWNcbiAgfSwgYXR0cnMpO1xufVxuXG5mdW5jdGlvbiBub3RZZXREcmF3bih0cmFuc2xhdGUsIHNlbWFudGljLCByZWZTZW1hbnRpYywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcih0cmFuc2xhdGUoJ2VsZW1lbnQge2VsZW1lbnR9IHJlZmVyZW5jZWQgYnkge3JlZmVyZW5jZWR9I3twcm9wZXJ0eX0gbm90IHlldCBkcmF3bicsIHtcbiAgICBlbGVtZW50OiBlbGVtZW50VG9TdHJpbmcocmVmU2VtYW50aWMpLFxuICAgIHJlZmVyZW5jZWQ6IGVsZW1lbnRUb1N0cmluZyhzZW1hbnRpYyksXG4gICAgcHJvcGVydHk6IHByb3BlcnR5XG4gIH0pKTtcbn1cblxuXG4vKipcbiAqIEFuIGltcG9ydGVyIHRoYXQgYWRkcyBwb3N0aXQgZWxlbWVudHMgdG8gdGhlIGNhbnZhc1xuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKiBAcGFyYW0ge0VsZW1lbnRGYWN0b3J5fSBlbGVtZW50RmFjdG9yeVxuICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnl9IGVsZW1lbnRSZWdpc3RyeVxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge1RleHRSZW5kZXJlcn0gdGV4dFJlbmRlcmVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvc3RpdEltcG9ydGVyKFxuICAgIGV2ZW50QnVzLCBjYW52YXMsIGVsZW1lbnRGYWN0b3J5LFxuICAgIGVsZW1lbnRSZWdpc3RyeSwgdHJhbnNsYXRlLCB0ZXh0UmVuZGVyZXIpIHtcblxuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gIHRoaXMuX2VsZW1lbnRGYWN0b3J5ID0gZWxlbWVudEZhY3Rvcnk7XG4gIHRoaXMuX2VsZW1lbnRSZWdpc3RyeSA9IGVsZW1lbnRSZWdpc3RyeTtcbiAgdGhpcy5fdHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuICB0aGlzLl90ZXh0UmVuZGVyZXIgPSB0ZXh0UmVuZGVyZXI7XG59XG5cblBvc3RpdEltcG9ydGVyLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnZWxlbWVudEZhY3RvcnknLFxuICAnZWxlbWVudFJlZ2lzdHJ5JyxcbiAgJ3RyYW5zbGF0ZScsXG4gICd0ZXh0UmVuZGVyZXInXG5dO1xuXG5cbi8qKlxuICogQWRkIHBvc3RpdCBlbGVtZW50IChzZW1hbnRpYykgdG8gdGhlIGNhbnZhcyBvbnRvIHRoZVxuICogc3BlY2lmaWVkIHBhcmVudCBzaGFwZS5cbiAqL1xuUG9zdGl0SW1wb3J0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHNlbWFudGljLCBwYXJlbnRFbGVtZW50KSB7XG5cbiAgdmFyIGRpID0gc2VtYW50aWMuZGksXG4gICAgICBlbGVtZW50LFxuICAgICAgdHJhbnNsYXRlID0gdGhpcy5fdHJhbnNsYXRlLFxuICAgICAgaGlkZGVuO1xuXG4gIHZhciBwYXJlbnRJbmRleDtcblxuICAvLyBST09UIEVMRU1FTlRcbiAgLy8gaGFuZGxlIHRoZSBzcGVjaWFsIGNhc2UgdGhhdCB3ZSBkZWFsIHdpdGggYVxuICAvLyBpbnZpc2libGUgcm9vdCBlbGVtZW50XG4gIGlmIChpcyhkaSwgJ3Bvc3RpdERpOlBvc3RpdFBsYW5lJykpIHtcblxuICAgIC8vIGFkZCBhIHZpcnR1YWwgZWxlbWVudCAobm90IGJlaW5nIGRyYXduKVxuICAgIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50RmFjdG9yeS5jcmVhdGVSb290KGVsZW1lbnREYXRhKHNlbWFudGljKSk7XG5cbiAgICB0aGlzLl9jYW52YXMuc2V0Um9vdEVsZW1lbnQoZWxlbWVudCk7XG4gIH1cblxuICAvLyBTSEFQRVxuICBlbHNlIGlmIChpcyhkaSwgJ3Bvc3RpdERpOlBvc3RpdFNoYXBlJykpIHtcblxuICAgIHZhciBpc0ZyYW1lID0gaXNGcmFtZUVsZW1lbnQoc2VtYW50aWMpO1xuXG4gICAgaGlkZGVuID0gcGFyZW50RWxlbWVudCAmJiAocGFyZW50RWxlbWVudC5oaWRkZW4gfHwgcGFyZW50RWxlbWVudC5jb2xsYXBzZWQpO1xuXG4gICAgdmFyIGJvdW5kcyA9IHNlbWFudGljLmRpLmJvdW5kcztcblxuICAgIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50RmFjdG9yeS5jcmVhdGVTaGFwZShlbGVtZW50RGF0YShzZW1hbnRpYywge1xuICAgICAgaGlkZGVuOiBoaWRkZW4sXG4gICAgICB4OiBNYXRoLnJvdW5kKGJvdW5kcy54KSxcbiAgICAgIHk6IE1hdGgucm91bmQoYm91bmRzLnkpLFxuICAgICAgd2lkdGg6IE1hdGgucm91bmQoYm91bmRzLndpZHRoKSxcbiAgICAgIGhlaWdodDogTWF0aC5yb3VuZChib3VuZHMuaGVpZ2h0KSxcbiAgICAgIGlzRnJhbWU6IGlzRnJhbWVcbiAgICB9KSk7XG5cbiAgICB0aGlzLl9jYW52YXMuYWRkU2hhcGUoZWxlbWVudCwgcGFyZW50RWxlbWVudCwgcGFyZW50SW5kZXgpO1xuICB9XG5cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zbGF0ZSgndW5rbm93biBkaSB7ZGl9IGZvciBlbGVtZW50IHtzZW1hbnRpY30nLCB7XG4gICAgICBkaTogZWxlbWVudFRvU3RyaW5nKGRpKSxcbiAgICAgIHNlbWFudGljOiBlbGVtZW50VG9TdHJpbmcoc2VtYW50aWMpXG4gICAgfSkpO1xuICB9XG5cbiAgLy8gKG9wdGlvbmFsKSBMQUJFTFxuICBpZiAoaXNMYWJlbEV4dGVybmFsKHNlbWFudGljKSAmJiBnZXRMYWJlbChlbGVtZW50KSkge1xuICAgIHRoaXMuYWRkTGFiZWwoc2VtYW50aWMsIGVsZW1lbnQpO1xuICB9XG5cblxuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdib2FyZEVsZW1lbnQuYWRkZWQnLCB7IGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogQXR0YWNoIHRoZSBib3VuZGFyeSBlbGVtZW50IHRvIHRoZSBnaXZlbiBob3N0XG4gKlxuICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBib3VuZGFyeVNlbWFudGljXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBib3VuZGFyeUVsZW1lbnRcbiAqL1xuUG9zdGl0SW1wb3J0ZXIucHJvdG90eXBlLl9hdHRhY2hCb3VuZGFyeSA9IGZ1bmN0aW9uKGJvdW5kYXJ5U2VtYW50aWMsIGJvdW5kYXJ5RWxlbWVudCkge1xuICB2YXIgdHJhbnNsYXRlID0gdGhpcy5fdHJhbnNsYXRlO1xuICB2YXIgaG9zdFNlbWFudGljID0gYm91bmRhcnlTZW1hbnRpYy5hdHRhY2hlZFRvUmVmO1xuXG4gIGlmICghaG9zdFNlbWFudGljKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zbGF0ZSgnbWlzc2luZyB7c2VtYW50aWN9I2F0dGFjaGVkVG9SZWYnLCB7XG4gICAgICBzZW1hbnRpYzogZWxlbWVudFRvU3RyaW5nKGJvdW5kYXJ5U2VtYW50aWMpXG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIGhvc3QgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0KGhvc3RTZW1hbnRpYy5pZCksXG4gICAgICBhdHRhY2hlcnMgPSBob3N0ICYmIGhvc3QuYXR0YWNoZXJzO1xuXG4gIGlmICghaG9zdCkge1xuICAgIHRocm93IG5vdFlldERyYXduKHRyYW5zbGF0ZSwgYm91bmRhcnlTZW1hbnRpYywgaG9zdFNlbWFudGljLCAnYXR0YWNoZWRUb1JlZicpO1xuICB9XG5cbiAgLy8gd2lyZSBlbGVtZW50Lmhvc3QgPD4gaG9zdC5hdHRhY2hlcnNcbiAgYm91bmRhcnlFbGVtZW50Lmhvc3QgPSBob3N0O1xuXG4gIGlmICghYXR0YWNoZXJzKSB7XG4gICAgaG9zdC5hdHRhY2hlcnMgPSBhdHRhY2hlcnMgPSBbXTtcbiAgfVxuXG4gIGlmIChhdHRhY2hlcnMuaW5kZXhPZihib3VuZGFyeUVsZW1lbnQpID09PSAtMSkge1xuICAgIGF0dGFjaGVycy5wdXNoKGJvdW5kYXJ5RWxlbWVudCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBhZGQgbGFiZWwgZm9yIGFuIGVsZW1lbnRcbiAqL1xuUG9zdGl0SW1wb3J0ZXIucHJvdG90eXBlLmFkZExhYmVsID0gZnVuY3Rpb24oc2VtYW50aWMsIGVsZW1lbnQpIHtcbiAgdmFyIGJvdW5kcyxcbiAgICAgIHRleHQsXG4gICAgICBsYWJlbDtcblxuICBib3VuZHMgPSBnZXRFeHRlcm5hbExhYmVsQm91bmRzKHNlbWFudGljLCBlbGVtZW50KTtcblxuICB0ZXh0ID0gZ2V0TGFiZWwoZWxlbWVudCk7XG5cbiAgaWYgKHRleHQpIHtcblxuICAgIC8vIGdldCBjb3JyZWN0ZWQgYm91bmRzIGZyb20gYWN0dWFsIGxheW91dGVkIHRleHRcbiAgICBib3VuZHMgPSB0aGlzLl90ZXh0UmVuZGVyZXIuZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kcyhib3VuZHMsIHRleHQpO1xuICB9XG5cbiAgbGFiZWwgPSB0aGlzLl9lbGVtZW50RmFjdG9yeS5jcmVhdGVMYWJlbChlbGVtZW50RGF0YShzZW1hbnRpYywge1xuICAgIGlkOiBzZW1hbnRpYy5pZCArICdfbGFiZWwnLFxuICAgIGxhYmVsVGFyZ2V0OiBlbGVtZW50LFxuICAgIHR5cGU6ICdsYWJlbCcsXG4gICAgaGlkZGVuOiBlbGVtZW50LmhpZGRlbiB8fCAhZ2V0TGFiZWwoZWxlbWVudCksXG4gICAgeDogTWF0aC5yb3VuZChib3VuZHMueCksXG4gICAgeTogTWF0aC5yb3VuZChib3VuZHMueSksXG4gICAgd2lkdGg6IE1hdGgucm91bmQoYm91bmRzLndpZHRoKSxcbiAgICBoZWlnaHQ6IE1hdGgucm91bmQoYm91bmRzLmhlaWdodClcbiAgfSkpO1xuXG4gIHJldHVybiB0aGlzLl9jYW52YXMuYWRkU2hhcGUobGFiZWwsIGVsZW1lbnQucGFyZW50KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBkcmF3biBjb25uZWN0aW9uIGVuZCBiYXNlZCBvbiB0aGUgZ2l2ZW4gc2lkZS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGVuZCBpcyBub3QgeWV0IGRyYXduXG4gKi9cblBvc3RpdEltcG9ydGVyLnByb3RvdHlwZS5fZ2V0RW5kID0gZnVuY3Rpb24oc2VtYW50aWMsIHNpZGUpIHtcblxuICB2YXIgZWxlbWVudCxcbiAgICAgIHJlZlNlbWFudGljLFxuICAgICAgdHJhbnNsYXRlID0gdGhpcy5fdHJhbnNsYXRlO1xuXG4gIHJlZlNlbWFudGljID0gc2VtYW50aWNbc2lkZSArICdSZWYnXTtcblxuXG4gIGVsZW1lbnQgPSByZWZTZW1hbnRpYyAmJiB0aGlzLl9nZXRFbGVtZW50KHJlZlNlbWFudGljKTtcblxuICBpZiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgaWYgKHJlZlNlbWFudGljKSB7XG4gICAgdGhyb3cgbm90WWV0RHJhd24odHJhbnNsYXRlLCBzZW1hbnRpYywgcmVmU2VtYW50aWMsIHNpZGUgKyAnUmVmJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zbGF0ZSgne3NlbWFudGljfSN7c2lkZX0gUmVmIG5vdCBzcGVjaWZpZWQnLCB7XG4gICAgICBzZW1hbnRpYzogZWxlbWVudFRvU3RyaW5nKHNlbWFudGljKSxcbiAgICAgIHNpZGU6IHNpZGVcbiAgICB9KSk7XG4gIH1cbn07XG5cblBvc3RpdEltcG9ydGVyLnByb3RvdHlwZS5fZ2V0U291cmNlID0gZnVuY3Rpb24oc2VtYW50aWMpIHtcbiAgcmV0dXJuIHRoaXMuX2dldEVuZChzZW1hbnRpYywgJ3NvdXJjZScpO1xufTtcblxuUG9zdGl0SW1wb3J0ZXIucHJvdG90eXBlLl9nZXRUYXJnZXQgPSBmdW5jdGlvbihzZW1hbnRpYykge1xuICByZXR1cm4gdGhpcy5fZ2V0RW5kKHNlbWFudGljLCAndGFyZ2V0Jyk7XG59O1xuXG5cblBvc3RpdEltcG9ydGVyLnByb3RvdHlwZS5fZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKHNlbWFudGljKSB7XG4gIHJldHVybiB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0KHNlbWFudGljLmlkKTtcbn07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzRnJhbWVFbGVtZW50KHNlbWFudGljKSB7XG4gIHJldHVybiBpcyhzZW1hbnRpYywgJ3Bvc3RpdDpHcm91cCcpO1xufSIsImltcG9ydCB7XG4gIGZpbmQsXG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgUmVmcyBmcm9tICdvYmplY3QtcmVmcyc7XG5cbmltcG9ydCB7XG4gIGVsZW1lbnRUb1N0cmluZ1xufSBmcm9tICcuL1V0aWwnO1xuXG52YXIgZGlSZWZzID0gbmV3IFJlZnMoXG4gIHsgbmFtZTogJ2JvYXJkRWxlbWVudCcsIGVudW1lcmFibGU6IHRydWUgfSxcbiAgeyBuYW1lOiAnZGknLCBjb25maWd1cmFibGU6IHRydWUgfVxuKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gZWxlbWVudCBoYXMgdGhlIGdpdmVuIG1ldGEtbW9kZWwgdHlwZVxuICpcbiAqIEBwYXJhbSAge01vZGRsZUVsZW1lbnR9ICBlbGVtZW50XG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgdHlwZVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzKGVsZW1lbnQsIHR5cGUpIHtcbiAgcmV0dXJuIGVsZW1lbnQuJGluc3RhbmNlT2YodHlwZSk7XG59XG5cblxuLyoqXG4gKiBGaW5kIGEgc3VpdGFibGUgZGlzcGxheSBjYW5kaWRhdGUgZm9yIGRlZmluaXRpb25zIHdoZXJlIHRoZSBESSBkb2VzIG5vdFxuICogY29ycmVjdGx5IHNwZWNpZnkgb25lLlxuICovXG5mdW5jdGlvbiBmaW5kRGlzcGxheUNhbmRpZGF0ZShkZWZpbml0aW9ucykge1xuICByZXR1cm4gZmluZChkZWZpbml0aW9ucy5yb290RWxlbWVudHMsIGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gaXMoZSwgJ3Bvc3RpdDpQb3N0aXRCb2FyZCcpO1xuICB9KTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQb3N0aXRUcmVlV2Fsa2VyKGhhbmRsZXIsIHRyYW5zbGF0ZSkge1xuXG4gIC8vIGxpc3Qgb2YgY29udGFpbmVycyBhbHJlYWR5IHdhbGtlZFxuICB2YXIgaGFuZGxlZEVsZW1lbnRzID0ge307XG5cbiAgLy8gbGlzdCBvZiBlbGVtZW50cyB0byBoYW5kbGUgZGVmZXJyZWQgdG8gZW5zdXJlXG4gIC8vIHByZXJlcXVpc2l0ZXMgYXJlIGRyYXduXG4gIHZhciBkZWZlcnJlZCA9IFtdO1xuXG4gIC8vIEhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIHZpc2l0Um9vdChlbGVtZW50LCBkaWFncmFtKSB7XG4gICAgcmV0dXJuIGhhbmRsZXIucm9vdChlbGVtZW50LCBkaWFncmFtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2l0KGVsZW1lbnQsIGN0eCkge1xuXG4gICAgdmFyIGdmeCA9IGVsZW1lbnQuZ2Z4O1xuXG4gICAgLy8gYXZvaWQgbXVsdGlwbGUgcmVuZGVyaW5nIG9mIGVsZW1lbnRzXG4gICAgaWYgKGdmeCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICB0cmFuc2xhdGUoJ2FscmVhZHkgcmVuZGVyZWQge2VsZW1lbnR9JywgeyBlbGVtZW50OiBlbGVtZW50VG9TdHJpbmcoZWxlbWVudCkgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY2FsbCBoYW5kbGVyXG4gICAgcmV0dXJuIGhhbmRsZXIuZWxlbWVudChlbGVtZW50LCBjdHgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlzaXRJZkRpKGVsZW1lbnQsIGN0eCkge1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBnZnggPSBlbGVtZW50LmRpICYmIHZpc2l0KGVsZW1lbnQsIGN0eCk7XG5cbiAgICAgIGhhbmRsZWQoZWxlbWVudCk7XG5cbiAgICAgIHJldHVybiBnZng7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nRXJyb3IoZS5tZXNzYWdlLCB7IGVsZW1lbnQ6IGVsZW1lbnQsIGVycm9yOiBlIH0pO1xuXG4gICAgICBjb25zb2xlLmVycm9yKHRyYW5zbGF0ZSgnZmFpbGVkIHRvIGltcG9ydCB7ZWxlbWVudH0nLCB7IGVsZW1lbnQ6IGVsZW1lbnRUb1N0cmluZyhlbGVtZW50KSB9KSk7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ0Vycm9yKG1lc3NhZ2UsIGNvbnRleHQpIHtcbiAgICBoYW5kbGVyLmVycm9yKG1lc3NhZ2UsIGNvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlZChlbGVtZW50KSB7XG4gICAgaGFuZGxlZEVsZW1lbnRzW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcbiAgfVxuXG4gIC8vIERJIGhhbmRsaW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiByZWdpc3RlckRpKGRpKSB7XG4gICAgdmFyIGJvYXJkRWxlbWVudCA9IGRpLmJvYXJkRWxlbWVudDtcblxuICAgIGlmIChib2FyZEVsZW1lbnQpIHtcbiAgICAgIGlmIChib2FyZEVsZW1lbnQuZGkpIHtcbiAgICAgICAgbG9nRXJyb3IoXG4gICAgICAgICAgdHJhbnNsYXRlKCdtdWx0aXBsZSBESSBlbGVtZW50cyBkZWZpbmVkIGZvciB7ZWxlbWVudH0nLCB7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50VG9TdHJpbmcoYm9hcmRFbGVtZW50KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgZWxlbWVudDogYm9hcmRFbGVtZW50IH1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpUmVmcy5iaW5kKGJvYXJkRWxlbWVudCwgJ2RpJyk7XG4gICAgICAgIGJvYXJkRWxlbWVudC5kaSA9IGRpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dFcnJvcihcbiAgICAgICAgdHJhbnNsYXRlKCdubyBib2FyZEVsZW1lbnQgcmVmZXJlbmNlZCBpbiB7ZWxlbWVudH0nLCB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudFRvU3RyaW5nKGRpKVxuICAgICAgICB9KSxcbiAgICAgICAgeyBlbGVtZW50OiBkaSB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUJvYXJkKGRpYWdyYW0pIHtcbiAgICBoYW5kbGVQbGFuZShkaWFncmFtLnBsYW5lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBsYW5lKHBsYW5lKSB7XG4gICAgcmVnaXN0ZXJEaShwbGFuZSk7XG5cbiAgICBmb3JFYWNoKHBsYW5lLnBsYW5lRWxlbWVudCwgaGFuZGxlUGxhbmVFbGVtZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBsYW5lRWxlbWVudChwbGFuZUVsZW1lbnQpIHtcbiAgICByZWdpc3RlckRpKHBsYW5lRWxlbWVudCk7XG4gIH1cblxuXG4gIC8vIFNlbWFudGljIGhhbmRsaW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogSGFuZGxlIGRlZmluaXRpb25zIGFuZCByZXR1cm4gdGhlIHJlbmRlcmVkIGJvYXJkIChpZiBhbnkpXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gZGVmaW5pdGlvbnMgdG8gd2FsayBhbmQgaW1wb3J0XG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gW3Jvb3RCb2FyZF0gc3BlY2lmaWMgYm9hcmQgdG8gaW1wb3J0IGFuZCBkaXNwbGF5XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBkaWFncmFtIHRvIGRpc3BsYXkgY291bGQgYmUgZm91bmRcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZURlZmluaXRpb25zKGRlZmluaXRpb25zLCByb290Qm9hcmQpIHtcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSB3YWxrIHRoZSBjb3JyZWN0IGJvYXJkRWxlbWVudFxuXG4gICAgdmFyIHJvb3RCb2FyZHMgPSBkZWZpbml0aW9ucy5yb290Qm9hcmRzO1xuXG4gICAgaWYgKHJvb3RCb2FyZCAmJiByb290Qm9hcmRzLmluZGV4T2Yocm9vdEJvYXJkKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0cmFuc2xhdGUoJ3Jvb3RCb2FyZCBub3QgcGFydCBvZiBwb3N0aXQ6RGVmaW5pdGlvbnMnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFyb290Qm9hcmQgJiYgcm9vdEJvYXJkcyAmJiByb290Qm9hcmRzLmxlbmd0aCkge1xuICAgICAgcm9vdEJvYXJkID0gcm9vdEJvYXJkc1swXTtcbiAgICB9XG5cbiAgICAvLyBubyByb290IGJvYXJkIC0+IG5vdGhpbmcgdG8gaW1wb3J0XG4gICAgaWYgKCFyb290Qm9hcmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0cmFuc2xhdGUoJ25vIHJvb3RCb2FyZCB0byBkaXNwbGF5JykpO1xuICAgIH1cblxuICAgIC8vIGxvYWQgREkgZnJvbSBzZWxlY3RlZCByb290IGJvYXJkIG9ubHlcbiAgICBoYW5kbGVCb2FyZChyb290Qm9hcmQpO1xuXG4gICAgdmFyIHBsYW5lID0gcm9vdEJvYXJkLnBsYW5lO1xuXG4gICAgaWYgKCFwbGFuZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zbGF0ZShcbiAgICAgICAgJ25vIHBsYW5lIGZvciB7ZWxlbWVudH0nLFxuICAgICAgICB7IGVsZW1lbnQ6IGVsZW1lbnRUb1N0cmluZyhyb290Qm9hcmQpIH1cbiAgICAgICkpO1xuICAgIH1cblxuICAgIHZhciByb290RWxlbWVudCA9IHBsYW5lLmJvYXJkRWxlbWVudDtcblxuICAgIC8vIGVuc3VyZSB3ZSBkZWZhdWx0IHRvIGEgc3VpdGFibGUgZGlzcGxheSBjYW5kaWRhdGUgKGJvYXJkKSxcbiAgICAvLyBldmVuIGlmIG5vbiBpcyBzcGVjaWZpZWQgaW4gRElcbiAgICBpZiAoIXJvb3RFbGVtZW50KSB7XG4gICAgICByb290RWxlbWVudCA9IGZpbmREaXNwbGF5Q2FuZGlkYXRlKGRlZmluaXRpb25zKTtcblxuICAgICAgaWYgKCFyb290RWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnNsYXRlKCdubyBib2FyZCB0byBkaXNwbGF5JykpO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBsb2dFcnJvcihcbiAgICAgICAgICB0cmFuc2xhdGUoJ2NvcnJlY3RpbmcgbWlzc2luZyBib2FyZEVsZW1lbnQgb24ge3BsYW5lfSB0byB7cm9vdEVsZW1lbnR9Jywge1xuICAgICAgICAgICAgcGxhbmU6IGVsZW1lbnRUb1N0cmluZyhwbGFuZSksXG4gICAgICAgICAgICByb290RWxlbWVudDogZWxlbWVudFRvU3RyaW5nKHJvb3RFbGVtZW50KVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY29ycmVjdCBESSBvbiB0aGUgZmx5XG4gICAgICAgIHBsYW5lLmJvYXJkRWxlbWVudCA9IHJvb3RFbGVtZW50O1xuICAgICAgICByZWdpc3RlckRpKHBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIHZhciBjdHggPSB2aXNpdFJvb3Qocm9vdEVsZW1lbnQsIHBsYW5lKTtcblxuICAgIGlmIChpcyhyb290RWxlbWVudCwgJ3Bvc3RpdDpQb3N0aXRCb2FyZCcpKSB7XG4gICAgICBoYW5kbGVQb3N0aXRCb2FyZChyb290RWxlbWVudCwgY3R4KTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgYWxsIGRlZmVycmVkIGVsZW1lbnRzXG4gICAgaGFuZGxlRGVmZXJyZWQoZGVmZXJyZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQm9hcmRFbGVtZW50cyhib2FyZEVsZW1lbnRzLCBjb250ZXh0KSB7XG4gICAgZm9yRWFjaChib2FyZEVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB2aXNpdElmRGkoZWxlbWVudCwgY29udGV4dCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3N0aXRCb2FyZChib2FyZCwgY29udGV4dCkge1xuICAgIGhhbmRsZUJvYXJkRWxlbWVudHMoYm9hcmQuYm9hcmRFbGVtZW50cywgY29udGV4dCk7XG5cbiAgICAvLyBsb2cgYm9hcmQgaGFuZGxlZFxuICAgIGhhbmRsZWQoYm9hcmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRGVmZXJyZWQoKSB7XG5cbiAgICB2YXIgZm47XG5cbiAgICAvLyBkcmFpbiBkZWZlcnJlZCB1bnRpbCBlbXB0eVxuICAgIHdoaWxlIChkZWZlcnJlZC5sZW5ndGgpIHtcbiAgICAgIGZuID0gZGVmZXJyZWQuc2hpZnQoKTtcblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH1cblxuXG5cblxuICAvLyBBUEkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHJldHVybiB7XG4gICAgaGFuZGxlRGVmZXJyZWQ6IGhhbmRsZURlZmVycmVkLFxuICAgIGhhbmRsZURlZmluaXRpb25zOiBoYW5kbGVEZWZpbml0aW9ucyxcbiAgICByZWdpc3RlckRpOiByZWdpc3RlckRpXG4gIH07XG59IiwiZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRUb1N0cmluZyhlKSB7XG4gIGlmICghZSkge1xuICAgIHJldHVybiAnPG51bGw+JztcbiAgfVxuXG4gIHJldHVybiAnPCcgKyBlLiR0eXBlICsgKGUuaWQgPyAnIGlkPVwiJyArIGUuaWQgOiAnJykgKyAnXCIgLz4nO1xufSIsImltcG9ydCB0cmFuc2xhdGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvaTE4bi90cmFuc2xhdGUnO1xuXG5pbXBvcnQgUG9zdGl0SW1wb3J0ZXIgZnJvbSAnLi9Qb3N0aXRJbXBvcnRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICB0cmFuc2xhdGVcbiAgXSxcbiAgcG9zdGl0SW1wb3J0ZXI6IFsgJ3R5cGUnLCBQb3N0aXRJbXBvcnRlciBdXG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsZXIgPSByZXF1aXJlKCcuL01vZGVsZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbGVyO1xuIiwiaW1wb3J0IHsgaXNTdHJpbmcsIGFzc2lnbiB9IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHsgTW9kZGxlIH0gZnJvbSAnbW9kZGxlJztcblxuaW1wb3J0IHsgUmVhZGVyLCBXcml0ZXIgfSBmcm9tICdtb2RkbGUteG1sJztcblxuLyoqXG4gKiBBIHN1YiBjbGFzcyBvZiB7QGxpbmsgTW9kZGxlfSB3aXRoIHN1cHBvcnQgZm9yIGltcG9ydCBhbmQgZXhwb3J0IG9mIFBvc3RpdC1qcyB4bWwgZmlsZXMuXG4gKlxuICogQGNsYXNzIFBvc3RpdE1vZGRsZVxuICpcbiAqIEBleHRlbmRzIE1vZGRsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBwYWNrYWdlcyB0byB1c2UgZm9yIGluc3RhbnRpYXRpbmcgdGhlIG1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIG92ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9zdGl0TW9kZGxlKHBhY2thZ2VzLCBvcHRpb25zKSB7XG4gIE1vZGRsZS5jYWxsKHRoaXMsIHBhY2thZ2VzLCBvcHRpb25zKTtcbn1cblxuUG9zdGl0TW9kZGxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kZGxlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogVGhlIGZyb21YTUwgcmVzdWx0LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhcnNlUmVzdWx0XG4gKlxuICogQHByb3BlcnR5IHtNb2RkbGVFbGVtZW50fSByb290RWxlbWVudFxuICogQHByb3BlcnR5IHtBcnJheTxPYmplY3Q+fSByZWZlcmVuY2VzXG4gKiBAcHJvcGVydHkge0FycmF5PEVycm9yPn0gd2FybmluZ3NcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBlbGVtZW50c0J5SWQgLSBhIG1hcHBpbmcgY29udGFpbmluZyBlYWNoIElEIC0+IE1vZGRsZUVsZW1lbnRcbiAqL1xuXG4vKipcbiAqIFRoZSBmcm9tWE1MIGVycm9yLlxuICpcbiAqIEB0eXBlZGVmIHtFcnJvcn0gUGFyc2VFcnJvclxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8RXJyb3I+fSB3YXJuaW5nc1xuICovXG5cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgUG9zdGl0IG1vZGVsIHRyZWUgZnJvbSBhIGdpdmVuIHhtbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICAgeG1sU3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gICBbdHlwZU5hbWU9J3Bvc3RpdDpEZWZpbml0aW9ucyddIG5hbWUgb2YgdGhlIHJvb3QgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9ICAgW29wdGlvbnNdICBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHVuZGVybHlpbmcgcmVhZGVyXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8UGFyc2VSZXN1bHQsIFBhcnNlRXJyb3I+fVxuICovXG5Qb3N0aXRNb2RkbGUucHJvdG90eXBlLmZyb21YTUwgPSBmdW5jdGlvbih4bWxTdHIsIHR5cGVOYW1lLCBvcHRpb25zKSB7XG4gIGlmICghaXNTdHJpbmcodHlwZU5hbWUpKSB7XG4gICAgb3B0aW9ucyA9IHR5cGVOYW1lO1xuICAgIHR5cGVOYW1lID0gJ3Bvc3RpdDpEZWZpbml0aW9ucyc7XG4gIH1cblxuICB2YXIgcmVhZGVyID0gbmV3IFJlYWRlcihhc3NpZ24oeyBtb2RlbDogdGhpcywgbGF4OiB0cnVlIH0sIG9wdGlvbnMpKTtcbiAgdmFyIHJvb3RIYW5kbGVyID0gcmVhZGVyLmhhbmRsZXIodHlwZU5hbWUpO1xuXG4gIHJldHVybiByZWFkZXIuZnJvbVhNTCh4bWxTdHIsIHJvb3RIYW5kbGVyKTtcbn07XG5cbi8qKlxuICogVGhlIHRvWE1MIHJlc3VsdC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXJpYWxpemF0aW9uUmVzdWx0XG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHhtbFxuICovXG5cbi8qKlxuICogU2VyaWFsaXplcyBhIFBvc3RpdCBvYmplY3QgdHJlZSB0byBYTUwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICAgZWxlbWVudCAgICB0aGUgcm9vdCBlbGVtZW50LCB0eXBpY2FsbHkgYW4gaW5zdGFuY2Ugb2YgYHBvc3RpdDpEZWZpbml0aW9uc2BcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIFtvcHRpb25zXSAgdG8gcGFzcyB0byB0aGUgdW5kZXJseWluZyB3cml0ZXJcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTZXJpYWxpemF0aW9uUmVzdWx0LCBFcnJvcj59XG4gKi9cblBvc3RpdE1vZGRsZS5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyKG9wdGlvbnMpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHJlc3VsdCA9IHdyaXRlci50b1hNTChlbGVtZW50KTtcblxuICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICB4bWw6IHJlc3VsdFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgfVxuICB9KTtcbn07XG4iLCJcbmltcG9ydCB7XG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCBNb2RkbGUgZnJvbSAnLi9Nb2RkbGUnO1xuXG5pbXBvcnQgUG9zdGl0RGVzY3JpcHRvcnMgZnJvbSAnLi9yZXNvdXJjZXMvcG9zdGl0Lmpzb24nO1xuaW1wb3J0IERpRGVzY3JpcHRvcnMgZnJvbSAnLi9yZXNvdXJjZXMvcG9zdGl0RGkuanNvbic7XG5pbXBvcnQgRGNEZXNjcmlwdG9ycyBmcm9tICcuL3Jlc291cmNlcy9kYy5qc29uJztcblxudmFyIHBhY2thZ2VzID0ge1xuICBwb3N0aXQ6IFBvc3RpdERlc2NyaXB0b3JzLFxuICBwb3N0aXREaTogRGlEZXNjcmlwdG9ycyxcbiAgZGM6IERjRGVzY3JpcHRvcnMsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhZGRpdGlvbmFsUGFja2FnZXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBrcyA9IGFzc2lnbih7fSwgcGFja2FnZXMsIGFkZGl0aW9uYWxQYWNrYWdlcyk7XG5cbiAgcmV0dXJuIG5ldyBNb2RkbGUocGtzLCBvcHRpb25zKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgWUVMTE9XOiAnI0ZGRkY4OCcsXG4gIEdSRUVOOiAnIzdFQzg0NScsXG4gIFBJTks6ICcjRjQ2RjYwJyxcbiAgSUNFX0JMVUU6ICcjQjhENkY3JyxcbiAgQkxVRTogJyMyM0JGRTcnLFxuICBPUkFOR0U6ICcjRkY5RDQ4JyxcbiAgQkxBQ0s6ICdibGFjaydcbn07XG4iLCJleHBvcnQgZnVuY3Rpb24gZmlsZVRvRGF0YVVSTChmaWxlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbWFnZVByb2Nlc3NvcihldiwgZmlsZSkge1xuICBjb25zdCBiYXNlNjRmaWxlID0gYXdhaXQgZmlsZVRvRGF0YVVSTChmaWxlKTtcblxuICAvLyBjcmVhdGVJbWFnZShldiwgYmFzZTY0ZmlsZSk7XG4gIHJldHVybiBiYXNlNjRmaWxlOyAvLyBwYXNzaW5nIGFueSBlcnJvcnMgdGhyb3VnaFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmlsZVJlYWRlcihldiwgZmlsZXMpIHtcbiAgbGV0IHVwbG9hZFJlc3VsdCA9IFtdO1xuICBsZXQgZXJyb3JzO1xuICBsZXQgZmlsZUl0ZW1zID0gZmlsZXM7XG4gIGlmIChldiAmJiAoZXYuZGF0YVRyYW5zZmVyLml0ZW1zIHx8IGV2LmRhdGFUcmFuc2Zlci5maWxlcykpIHtcbiAgICBmaWxlSXRlbXMgPSBldi5kYXRhVHJhbnNmZXIuaXRlbXMgfHwgZXYuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKGZpbGVJdGVtcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGV2ICYmIGV2LmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgICAgIGlmIChmaWxlSXRlbXNbaV0ua2luZCA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICB2YXIgZmlsZSA9IGZpbGVJdGVtc1tpXS5nZXRBc0ZpbGUoKTtcbiAgICAgICAgICAgIHVwbG9hZFJlc3VsdC5wdXNoKGF3YWl0IGltYWdlUHJvY2Vzc29yKGV2LCBmaWxlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwbG9hZFJlc3VsdC5wdXNoKGF3YWl0IGltYWdlUHJvY2Vzc29yKGV2LCBmaWxlSXRlbXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9ycyA9IGU7XG4gICAgdXBsb2FkUmVzdWx0ID0gbnVsbDtcbiAgfVxuICByZXR1cm4geyB1cGxvYWRSZXN1bHQsIGVycm9ycyB9O1xufVxuXG4iLCJpbXBvcnQge1xuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgeyBpcyB9IGZyb20gJy4vTW9kZWxVdGlsJztcblxuXG5leHBvcnQgdmFyIERFRkFVTFRfTEFCRUxfU0laRSA9IHtcbiAgd2lkdGg6IDkwLFxuICBoZWlnaHQ6IDIwXG59O1xuXG5leHBvcnQgdmFyIEZMT1dfTEFCRUxfSU5ERU5UID0gMTU7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNlbWFudGljIGhhcyBhbiBleHRlcm5hbCBsYWJlbFxuICpcbiAqIEBwYXJhbSB7Qm9hcmRFbGVtZW50fSBzZW1hbnRpY1xuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBoYXMgbGFiZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTGFiZWxFeHRlcm5hbChzZW1hbnRpYykge1xuICByZXR1cm4gaXMoc2VtYW50aWMsICdwb3N0aXQ6R3JvdXAnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaGFzIGFuIGV4dGVybmFsIGxhYmVsXG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuc2hhcGV9IGVsZW1lbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgaGFzIGxhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNFeHRlcm5hbExhYmVsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzTGFiZWwoZWxlbWVudC5sYWJlbCk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIG1pZGRsZSBvZiBhIG51bWJlciBvZiB3YXlwb2ludHNcbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxQb2ludD59IHdheXBvaW50c1xuICogQHJldHVybiB7UG9pbnR9IHRoZSBtaWQgcG9pbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdheXBvaW50c01pZCh3YXlwb2ludHMpIHtcblxuICB2YXIgbWlkID0gd2F5cG9pbnRzLmxlbmd0aCAvIDIgLSAxO1xuXG4gIHZhciBmaXJzdCA9IHdheXBvaW50c1tNYXRoLmZsb29yKG1pZCldO1xuICB2YXIgc2Vjb25kID0gd2F5cG9pbnRzW01hdGguY2VpbChtaWQgKyAwLjAxKV07XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBmaXJzdC54ICsgKHNlY29uZC54IC0gZmlyc3QueCkgLyAyLFxuICAgIHk6IGZpcnN0LnkgKyAoc2Vjb25kLnkgLSBmaXJzdC55KSAvIDJcbiAgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXh0ZXJuYWxMYWJlbE1pZChlbGVtZW50KSB7XG5cbiAgaWYgKGlzKGVsZW1lbnQsICdwb3N0aXQ6R3JvdXAnKSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBlbGVtZW50LnggKyBlbGVtZW50LndpZHRoIC8gMixcbiAgICAgIHk6IGVsZW1lbnQueSArIERFRkFVTFRfTEFCRUxfU0laRS5oZWlnaHQgLyAyXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZWxlbWVudC54ICsgZWxlbWVudC53aWR0aCAvIDIsXG4gICAgICB5OiBlbGVtZW50LnkgKyBlbGVtZW50LmhlaWdodCArIERFRkFVTFRfTEFCRUxfU0laRS5oZWlnaHQgLyAyXG4gICAgfTtcbiAgfVxufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRzIG9mIGFuIGVsZW1lbnRzIGxhYmVsLCBwYXJzZWQgZnJvbSB0aGUgZWxlbWVudHMgREkgb3JcbiAqIGdlbmVyYXRlZCBmcm9tIGl0cyBib3VuZHMuXG4gKlxuICogQHBhcmFtIHtCb2FyZEVsZW1lbnR9IHNlbWFudGljXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlcm5hbExhYmVsQm91bmRzKHNlbWFudGljLCBlbGVtZW50KSB7XG5cbiAgdmFyIG1pZCxcbiAgICAgIHNpemUsXG4gICAgICBib3VuZHMsXG4gICAgICBkaSA9IHNlbWFudGljLmRpLFxuICAgICAgbGFiZWwgPSBkaS5sYWJlbDtcblxuICBpZiAobGFiZWwgJiYgbGFiZWwuYm91bmRzKSB7XG4gICAgYm91bmRzID0gbGFiZWwuYm91bmRzO1xuXG4gICAgc2l6ZSA9IHtcbiAgICAgIHdpZHRoOiBNYXRoLm1heChERUZBVUxUX0xBQkVMX1NJWkUud2lkdGgsIGJvdW5kcy53aWR0aCksXG4gICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHRcbiAgICB9O1xuXG4gICAgbWlkID0ge1xuICAgICAgeDogYm91bmRzLnggKyBib3VuZHMud2lkdGggLyAyLFxuICAgICAgeTogYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IC8gMlxuICAgIH07XG4gIH0gZWxzZSB7XG5cbiAgICBtaWQgPSBnZXRFeHRlcm5hbExhYmVsTWlkKGVsZW1lbnQpO1xuXG4gICAgc2l6ZSA9IERFRkFVTFRfTEFCRUxfU0laRTtcbiAgfVxuXG4gIHJldHVybiBhc3NpZ24oe1xuICAgIHg6IG1pZC54IC0gc2l6ZS53aWR0aCAvIDIsXG4gICAgeTogbWlkLnkgLSBzaXplLmhlaWdodCAvIDJcbiAgfSwgc2l6ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xhYmVsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgJiYgISFlbGVtZW50LmxhYmVsVGFyZ2V0O1xufVxuIiwiLyoqXG4gKiBJcyBhbiBlbGVtZW50IG9mIHRoZSBnaXZlbiBwb3N0aXQgdHlwZT9cbiAqXG4gKiBAcGFyYW0gIHtkanMubW9kZWwuQmFzZXxNb2RkbGVFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXMoZWxlbWVudCwgdHlwZSkge1xuICB2YXIgYm8gPSBnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KTtcblxuICByZXR1cm4gYm8gJiYgKHR5cGVvZiBiby4kaW5zdGFuY2VPZiA9PT0gJ2Z1bmN0aW9uJykgJiYgYm8uJGluc3RhbmNlT2YodHlwZSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJ1c2luZXNzIG9iamVjdCBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge2Rqcy5tb2RlbC5CYXNlfE1vZGRsZUVsZW1lbnR9IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtNb2RkbGVFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCkge1xuICByZXR1cm4gKGVsZW1lbnQgJiYgZWxlbWVudC5idXNpbmVzc09iamVjdCkgfHwgZWxlbWVudDtcbn0iLCJleHBvcnQgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldmVudCkge1xuICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcblxuICB2YXIgcGFnZVggPSBldmVudC5wYWdlWDtcbiAgdmFyIHBhZ2VZID0gZXZlbnQucGFnZVk7XG5cbiAgLy8gSUUgOFxuICBpZiAocGFnZVggPT09IHVuZGVmaW5lZCkge1xuICAgIHBhZ2VYID0gZXZlbnQuY2xpZW50WCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIHBhZ2VZID0gZXZlbnQuY2xpZW50WSArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuXG4gIHJldHVybiB7IHBhZ2VYLCBwYWdlWSB9O1xufVxuXG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL2Nzc2VzY2FwZSB2MS41LjEgYnkgQG1hdGhpYXMgfCBNSVQgbGljZW5zZSAqL1xuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvcmV0dXJuRXhwb3J0cy5qc1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcpIHtcblx0XHQvLyBGb3IgTm9kZS5qcy5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBGb3IgQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbXSwgZmFjdG9yeS5iaW5kKHJvb3QsIHJvb3QpKTtcblx0fSBlbHNlIHtcblx0XHQvLyBGb3IgYnJvd3NlciBnbG9iYWxzIChub3QgZXhwb3NpbmcgdGhlIGZ1bmN0aW9uIHNlcGFyYXRlbHkpLlxuXHRcdGZhY3Rvcnkocm9vdCk7XG5cdH1cbn0odHlwZW9mIGdsb2JhbCAhPSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHRoaXMsIGZ1bmN0aW9uKHJvb3QpIHtcblxuXHRpZiAocm9vdC5DU1MgJiYgcm9vdC5DU1MuZXNjYXBlKSB7XG5cdFx0cmV0dXJuIHJvb3QuQ1NTLmVzY2FwZTtcblx0fVxuXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jc2VyaWFsaXplLWFuLWlkZW50aWZpZXJcblx0dmFyIGNzc0VzY2FwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYENTUy5lc2NhcGVgIHJlcXVpcmVzIGFuIGFyZ3VtZW50LicpO1xuXHRcdH1cblx0XHR2YXIgc3RyaW5nID0gU3RyaW5nKHZhbHVlKTtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVVuaXQ7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdHZhciBmaXJzdENvZGVVbml0ID0gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVVbml0ID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuXHRcdFx0Ly8gTm90ZTogdGhlcmXigJlzIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlIGFzdHJhbCBzeW1ib2xzLCBzdXJyb2dhdGVcblx0XHRcdC8vIHBhaXJzLCBvciBsb25lIHN1cnJvZ2F0ZXMuXG5cblx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgTlVMTCAoVSswMDAwKSwgdGhlbiB0aGUgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHQvLyAoVStGRkZEKS5cblx0XHRcdGlmIChjb2RlVW5pdCA9PSAweDAwMDApIHtcblx0XHRcdFx0cmVzdWx0ICs9ICdcXHVGRkZEJztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBpbiB0aGUgcmFuZ2UgW1xcMS1cXDFGXSAoVSswMDAxIHRvIFUrMDAxRikgb3IgaXNcblx0XHRcdFx0Ly8gVSswMDdGLCBb4oCmXVxuXHRcdFx0XHQoY29kZVVuaXQgPj0gMHgwMDAxICYmIGNvZGVVbml0IDw9IDB4MDAxRikgfHwgY29kZVVuaXQgPT0gMHgwMDdGIHx8XG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXMgaW4gdGhlIHJhbmdlIFswLTldXG5cdFx0XHRcdC8vIChVKzAwMzAgdG8gVSswMDM5KSwgW+KApl1cblx0XHRcdFx0KGluZGV4ID09IDAgJiYgY29kZVVuaXQgPj0gMHgwMDMwICYmIGNvZGVVbml0IDw9IDB4MDAzOSkgfHxcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyB0aGUgc2Vjb25kIGNoYXJhY3RlciBhbmQgaXMgaW4gdGhlIHJhbmdlIFswLTldXG5cdFx0XHRcdC8vIChVKzAwMzAgdG8gVSswMDM5KSBhbmQgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBhIGAtYCAoVSswMDJEKSwgW+KApl1cblx0XHRcdFx0KFxuXHRcdFx0XHRcdGluZGV4ID09IDEgJiZcblx0XHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5ICYmXG5cdFx0XHRcdFx0Zmlyc3RDb2RlVW5pdCA9PSAweDAwMkRcblx0XHRcdFx0KVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jZXNjYXBlLWEtY2hhcmFjdGVyLWFzLWNvZGUtcG9pbnRcblx0XHRcdFx0cmVzdWx0ICs9ICdcXFxcJyArIGNvZGVVbml0LnRvU3RyaW5nKDE2KSArICcgJztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpcyBhIGAtYCAoVSswMDJEKSwgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIG5vIHNlY29uZCBjaGFyYWN0ZXIsIFvigKZdXG5cdFx0XHRcdGluZGV4ID09IDAgJiZcblx0XHRcdFx0bGVuZ3RoID09IDEgJiZcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDJEXG5cdFx0XHQpIHtcblx0XHRcdFx0cmVzdWx0ICs9ICdcXFxcJyArIHN0cmluZy5jaGFyQXQoaW5kZXgpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBub3QgaGFuZGxlZCBieSBvbmUgb2YgdGhlIGFib3ZlIHJ1bGVzIGFuZCBpc1xuXHRcdFx0Ly8gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFUrMDA4MCwgaXMgYC1gIChVKzAwMkQpIG9yIGBfYCAoVSswMDVGKSwgb3Jcblx0XHRcdC8vIGlzIGluIG9uZSBvZiB0aGUgcmFuZ2VzIFswLTldIChVKzAwMzAgdG8gVSswMDM5KSwgW0EtWl0gKFUrMDA0MSB0b1xuXHRcdFx0Ly8gVSswMDVBKSwgb3IgW2Etel0gKFUrMDA2MSB0byBVKzAwN0EpLCBb4oCmXVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwODAgfHxcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDJEIHx8XG5cdFx0XHRcdGNvZGVVbml0ID09IDB4MDA1RiB8fFxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5IHx8XG5cdFx0XHRcdGNvZGVVbml0ID49IDB4MDA0MSAmJiBjb2RlVW5pdCA8PSAweDAwNUEgfHxcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDYxICYmIGNvZGVVbml0IDw9IDB4MDA3QVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIHRoZSBjaGFyYWN0ZXIgaXRzZWxmXG5cdFx0XHRcdHJlc3VsdCArPSBzdHJpbmcuY2hhckF0KGluZGV4KTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSwgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuXHRcdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNlc2NhcGUtYS1jaGFyYWN0ZXJcblx0XHRcdHJlc3VsdCArPSAnXFxcXCcgKyBzdHJpbmcuY2hhckF0KGluZGV4KTtcblxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGlmICghcm9vdC5DU1MpIHtcblx0XHRyb290LkNTUyA9IHt9O1xuXHR9XG5cblx0cm9vdC5DU1MuZXNjYXBlID0gY3NzRXNjYXBlO1xuXHRyZXR1cm4gY3NzRXNjYXBlO1xuXG59KSk7XG4iLCJpbXBvcnQgSW50ZXJhY3Rpb25FdmVudHNNb2R1bGUgZnJvbSAnZGlhZ3JhbS1qcy9saWIvZmVhdHVyZXMvaW50ZXJhY3Rpb24tZXZlbnRzJztcblxuaW1wb3J0IERpcmVjdEVkaXRpbmcgZnJvbSAnLi9saWIvRGlyZWN0RWRpdGluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBJbnRlcmFjdGlvbkV2ZW50c01vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAnZGlyZWN0RWRpdGluZycgXSxcbiAgZGlyZWN0RWRpdGluZzogWyAndHlwZScsIERpcmVjdEVkaXRpbmcgXVxufTsiLCJpbXBvcnQge1xuICBiaW5kLFxuICBmaW5kXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IFRleHRCb3ggZnJvbSAnLi9UZXh0Qm94JztcblxuXG4vKipcbiAqIEEgZGlyZWN0IGVkaXRpbmcgY29tcG9uZW50IHRoYXQgYWxsb3dzIHVzZXJzXG4gKiB0byBlZGl0IGFuIGVsZW1lbnRzIHRleHQgZGlyZWN0bHkgaW4gdGhlIGRpYWdyYW1cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1cyB0aGUgZXZlbnQgYnVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERpcmVjdEVkaXRpbmcoZXZlbnRCdXMsIGNhbnZhcykge1xuXG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG5cbiAgdGhpcy5fcHJvdmlkZXJzID0gW107XG4gIHRoaXMuX3RleHRib3ggPSBuZXcgVGV4dEJveCh7XG4gICAgY29udGFpbmVyOiBjYW52YXMuZ2V0Q29udGFpbmVyKCksXG4gICAga2V5SGFuZGxlcjogYmluZCh0aGlzLl9oYW5kbGVLZXksIHRoaXMpLFxuICAgIHJlc2l6ZUhhbmRsZXI6IGJpbmQodGhpcy5faGFuZGxlUmVzaXplLCB0aGlzKVxuICB9KTtcbn1cblxuRGlyZWN0RWRpdGluZy4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnLCAnY2FudmFzJyBdO1xuXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBkaXJlY3QgZWRpdGluZyBwcm92aWRlclxuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdmlkZXIgdGhlIHByb3ZpZGVyLCBtdXN0IGV4cG9zZSBhbiAjYWN0aXZhdGUoZWxlbWVudCkgbWV0aG9kIHRoYXQgcmV0dXJuc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGFjdGl2YXRpb24gY29udGV4dCAoeyBib3VuZHM6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0IH0sIHRleHQgfSkgaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3QgZWRpdGluZyBpcyBhdmFpbGFibGUgZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIEFkZGl0aW9uYWxseSB0aGUgcHJvdmlkZXIgbXVzdCBleHBvc2UgYSAjdXBkYXRlKGVsZW1lbnQsIHZhbHVlKSBtZXRob2RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB0byByZWNlaXZlIGRpcmVjdCBlZGl0aW5nIHVwZGF0ZXMuXG4gKi9cbkRpcmVjdEVkaXRpbmcucHJvdG90eXBlLnJlZ2lzdGVyUHJvdmlkZXIgPSBmdW5jdGlvbihwcm92aWRlcikge1xuICB0aGlzLl9wcm92aWRlcnMucHVzaChwcm92aWRlcik7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGRpcmVjdCBlZGl0aW5nIGlzIGN1cnJlbnRseSBhY3RpdmVcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5EaXJlY3RFZGl0aW5nLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLl9hY3RpdmU7XG59O1xuXG5cbi8qKlxuICogQ2FuY2VsIGRpcmVjdCBlZGl0aW5nLCBpZiBpdCBpcyBjdXJyZW50bHkgYWN0aXZlXG4gKi9cbkRpcmVjdEVkaXRpbmcucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2ZpcmUoJ2NhbmNlbCcpO1xuICB0aGlzLmNsb3NlKCk7XG59O1xuXG5cbkRpcmVjdEVkaXRpbmcucHJvdG90eXBlLl9maXJlID0gZnVuY3Rpb24oZXZlbnQsIGNvbnRleHQpIHtcbiAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnZGlyZWN0RWRpdGluZy4nICsgZXZlbnQsIGNvbnRleHQgfHwgeyBhY3RpdmU6IHRoaXMuX2FjdGl2ZSB9KTtcbn07XG5cbkRpcmVjdEVkaXRpbmcucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3RleHRib3guZGVzdHJveSgpO1xuXG4gIHRoaXMuX2ZpcmUoJ2RlYWN0aXZhdGUnKTtcblxuICB0aGlzLl9hY3RpdmUgPSBudWxsO1xuXG4gIHRoaXMucmVzaXphYmxlID0gdW5kZWZpbmVkO1xufTtcblxuXG5EaXJlY3RFZGl0aW5nLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG5cbiAgaWYgKCFhY3RpdmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29udGFpbmVyQm91bmRzLFxuICAgICAgcHJldmlvdXNCb3VuZHMgPSBhY3RpdmUuY29udGV4dC5ib3VuZHMsXG4gICAgICBuZXdCb3VuZHMgPSB0aGlzLiR0ZXh0Ym94LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgbmV3VGV4dCA9IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgIHByZXZpb3VzVGV4dCA9IGFjdGl2ZS5jb250ZXh0LnRleHQ7XG5cbiAgaWYgKFxuICAgIG5ld1RleHQgIT09IHByZXZpb3VzVGV4dCB8fFxuICAgIG5ld0JvdW5kcy5oZWlnaHQgIT09IHByZXZpb3VzQm91bmRzLmhlaWdodCB8fFxuICAgIG5ld0JvdW5kcy53aWR0aCAhPT0gcHJldmlvdXNCb3VuZHMud2lkdGhcbiAgKSB7XG4gICAgY29udGFpbmVyQm91bmRzID0gdGhpcy5fdGV4dGJveC5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBhY3RpdmUucHJvdmlkZXIudXBkYXRlKGFjdGl2ZS5lbGVtZW50LCBuZXdUZXh0LCBhY3RpdmUuY29udGV4dC50ZXh0LCB7XG4gICAgICB4OiBuZXdCb3VuZHMubGVmdCAtIGNvbnRhaW5lckJvdW5kcy5sZWZ0LFxuICAgICAgeTogbmV3Qm91bmRzLnRvcCAtIGNvbnRhaW5lckJvdW5kcy50b3AsXG4gICAgICB3aWR0aDogbmV3Qm91bmRzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBuZXdCb3VuZHMuaGVpZ2h0XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLl9maXJlKCdjb21wbGV0ZScpO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cblxuRGlyZWN0RWRpdGluZy5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RleHRib3guZ2V0VmFsdWUoKTtcbn07XG5cblxuRGlyZWN0RWRpdGluZy5wcm90b3R5cGUuX2hhbmRsZUtleSA9IGZ1bmN0aW9uKGUpIHtcblxuICAvLyBzdG9wIGJ1YmJsZVxuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gIHZhciBrZXkgPSBlLmtleUNvZGUgfHwgZS5jaGFyQ29kZTtcblxuICAvLyBFU0NcbiAgaWYgKGtleSA9PT0gMjcpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIHRoaXMuY2FuY2VsKCk7XG4gIH1cblxuICAvLyBFbnRlclxuICBpZiAoa2V5ID09PSAxMyAmJiAhZS5zaGlmdEtleSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gdGhpcy5jb21wbGV0ZSgpO1xuICB9XG59O1xuXG5cbkRpcmVjdEVkaXRpbmcucHJvdG90eXBlLl9oYW5kbGVSZXNpemUgPSBmdW5jdGlvbihldmVudCkge1xuICB0aGlzLl9maXJlKCdyZXNpemUnLCBldmVudCk7XG59O1xuXG5cbi8qKlxuICogQWN0aXZhdGUgZGlyZWN0IGVkaXRpbmcgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gRWxlbWVudERlc2NyaXB0b3IgdGhlIGRlc2NyaXB0b3IgZm9yIGEgc2hhcGUgb3IgY29ubmVjdGlvblxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgYWN0aXZhdGlvbiB3YXMgcG9zc2libGVcbiAqL1xuRGlyZWN0RWRpdGluZy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICB0aGlzLmNhbmNlbCgpO1xuICB9XG5cbiAgLy8gdGhlIGRpcmVjdCBlZGl0aW5nIGNvbnRleHRcbiAgdmFyIGNvbnRleHQ7XG5cbiAgdmFyIHByb3ZpZGVyID0gZmluZCh0aGlzLl9wcm92aWRlcnMsIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gKGNvbnRleHQgPSBwLmFjdGl2YXRlKGVsZW1lbnQpKSA/IHAgOiBudWxsO1xuICB9KTtcblxuICAvLyBjaGVjayBpZiBhY3RpdmF0aW9uIHRvb2sgcGxhY2VcbiAgaWYgKGNvbnRleHQpIHtcbiAgICB0aGlzLiR0ZXh0Ym94ID0gdGhpcy5fdGV4dGJveC5jcmVhdGUoXG4gICAgICBjb250ZXh0LmJvdW5kcyxcbiAgICAgIGNvbnRleHQuc3R5bGUsXG4gICAgICBjb250ZXh0LnRleHQsXG4gICAgICBjb250ZXh0Lm9wdGlvbnNcbiAgICApO1xuXG4gICAgdGhpcy5fYWN0aXZlID0ge1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBwcm92aWRlcjogcHJvdmlkZXJcbiAgICB9O1xuXG4gICAgaWYgKGNvbnRleHQub3B0aW9ucyAmJiBjb250ZXh0Lm9wdGlvbnMucmVzaXphYmxlKSB7XG4gICAgICB0aGlzLnJlc2l6YWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fZmlyZSgnYWN0aXZhdGUnKTtcbiAgfVxuXG4gIHJldHVybiAhIWNvbnRleHQ7XG59O1xuIiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBiaW5kLFxuICBwaWNrXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZG9taWZ5LFxuICBxdWVyeSBhcyBkb21RdWVyeSxcbiAgZXZlbnQgYXMgZG9tRXZlbnQsXG4gIHJlbW92ZSBhcyBkb21SZW1vdmVcbn0gZnJvbSAnbWluLWRvbSc7XG5cbnZhciBtaW4gPSBNYXRoLm1pbixcbiAgICBtYXggPSBNYXRoLm1heDtcblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREU7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkobm9kZUxpc3QpIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwobm9kZUxpc3QpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGEgY29udGFpbmVyIGZvciBhIGNvbnRlbnQgZWRpdGFibGUgZGl2LlxuICpcbiAqIFN0cnVjdHVyZTpcbiAqXG4gKiBjb250YWluZXJcbiAqICAgcGFyZW50XG4gKiAgICAgY29udGVudFxuICogICAgIHJlc2l6ZS1oYW5kbGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtET01FbGVtZW50fSBvcHRpb25zLmNvbnRhaW5lciBUaGUgRE9NIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSBjb250ZW50Q29udGFpbmVyIHRvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmtleUhhbmRsZXIgSGFuZGxlciBmb3Iga2V5IGV2ZW50c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5yZXNpemVIYW5kbGVyIEhhbmRsZXIgZm9yIHJlc2l6ZSBldmVudHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGV4dEJveChvcHRpb25zKSB7XG4gIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG5cbiAgdGhpcy5wYXJlbnQgPSBkb21pZnkoXG4gICAgJzxkaXYgY2xhc3M9XCJkanMtZGlyZWN0LWVkaXRpbmctcGFyZW50XCI+JyArXG4gICAgICAnPGRpdiBjbGFzcz1cImRqcy1kaXJlY3QtZWRpdGluZy1jb250ZW50XCIgY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiPjwvZGl2PicgK1xuICAgICc8L2Rpdj4nXG4gICk7XG5cbiAgdGhpcy5jb250ZW50ID0gZG9tUXVlcnkoJ1tjb250ZW50ZWRpdGFibGVdJywgdGhpcy5wYXJlbnQpO1xuXG4gIHRoaXMua2V5SGFuZGxlciA9IG9wdGlvbnMua2V5SGFuZGxlciB8fCBmdW5jdGlvbigpIHt9O1xuICB0aGlzLnJlc2l6ZUhhbmRsZXIgPSBvcHRpb25zLnJlc2l6ZUhhbmRsZXIgfHwgZnVuY3Rpb24oKSB7fTtcblxuICB0aGlzLmF1dG9SZXNpemUgPSBiaW5kKHRoaXMuYXV0b1Jlc2l6ZSwgdGhpcyk7XG4gIHRoaXMuaGFuZGxlUGFzdGUgPSBiaW5kKHRoaXMuaGFuZGxlUGFzdGUsIHRoaXMpO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgdGV4dCBib3ggd2l0aCB0aGUgZ2l2ZW4gcG9zaXRpb24sIHNpemUsIHN0eWxlIGFuZCB0ZXh0IGNvbnRlbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYm91bmRzXG4gKiBAcGFyYW0ge051bWJlcn0gYm91bmRzLnggYWJzb2x1dGUgeCBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdW5kcy55IGFic29sdXRlIHkgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLndpZHRoXSBmaXhlZCB3aWR0aCB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMuaGVpZ2h0XSBmaXhlZCBoZWlnaHQgdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLm1heFdpZHRoXSBtYXhpbXVtIHdpZHRoIHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy5tYXhIZWlnaHRdIG1heGltdW0gaGVpZ2h0IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy5taW5XaWR0aF0gbWluaW11bSB3aWR0aCB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMubWluSGVpZ2h0XSBtaW5pbXVtIGhlaWdodCB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZV1cbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB0ZXh0IGNvbnRlbnRcbiAqXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSBUaGUgY3JlYXRlZCBjb250ZW50IERPTSBlbGVtZW50XG4gKi9cblRleHRCb3gucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGJvdW5kcywgc3R5bGUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICBjb250ZW50ID0gdGhpcy5jb250ZW50LFxuICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG5cbiAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgc3R5bGUgPSB0aGlzLnN0eWxlID0gc3R5bGUgfHwge307XG5cbiAgdmFyIHBhcmVudFN0eWxlID0gcGljayhzdHlsZSwgW1xuICAgICd3aWR0aCcsXG4gICAgJ2hlaWdodCcsXG4gICAgJ21heFdpZHRoJyxcbiAgICAnbWF4SGVpZ2h0JyxcbiAgICAnbWluV2lkdGgnLFxuICAgICdtaW5IZWlnaHQnLFxuICAgICdsZWZ0JyxcbiAgICAndG9wJyxcbiAgICAnYmFja2dyb3VuZENvbG9yJyxcbiAgICAncG9zaXRpb24nLFxuICAgICdvdmVyZmxvdycsXG4gICAgJ2JvcmRlcicsXG4gICAgJ3dvcmRXcmFwJyxcbiAgICAndGV4dEFsaWduJyxcbiAgICAnb3V0bGluZScsXG4gICAgJ3RyYW5zZm9ybSdcbiAgXSk7XG5cbiAgYXNzaWduKHBhcmVudC5zdHlsZSwge1xuICAgIHdpZHRoOiBib3VuZHMud2lkdGggKyAncHgnLFxuICAgIGhlaWdodDogYm91bmRzLmhlaWdodCArICdweCcsXG4gICAgbWF4V2lkdGg6IGJvdW5kcy5tYXhXaWR0aCArICdweCcsXG4gICAgbWF4SGVpZ2h0OiBib3VuZHMubWF4SGVpZ2h0ICsgJ3B4JyxcbiAgICBtaW5XaWR0aDogYm91bmRzLm1pbldpZHRoICsgJ3B4JyxcbiAgICBtaW5IZWlnaHQ6IGJvdW5kcy5taW5IZWlnaHQgKyAncHgnLFxuICAgIGxlZnQ6IGJvdW5kcy54ICsgJ3B4JyxcbiAgICB0b3A6IGJvdW5kcy55ICsgJ3B4JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmZmZmJyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBvdmVyZmxvdzogJ3Zpc2libGUnLFxuICAgIGJvcmRlcjogJzFweCBzb2xpZCAjY2NjJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB3b3JkV3JhcDogJ25vcm1hbCcsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICBvdXRsaW5lOiAnbm9uZSdcbiAgfSwgcGFyZW50U3R5bGUpO1xuXG4gIHZhciBjb250ZW50U3R5bGUgPSBwaWNrKHN0eWxlLCBbXG4gICAgJ2ZvbnRGYW1pbHknLFxuICAgICdmb250U2l6ZScsXG4gICAgJ2ZvbnRXZWlnaHQnLFxuICAgICdsaW5lSGVpZ2h0JyxcbiAgICAncGFkZGluZycsXG4gICAgJ3BhZGRpbmdUb3AnLFxuICAgICdwYWRkaW5nUmlnaHQnLFxuICAgICdwYWRkaW5nQm90dG9tJyxcbiAgICAncGFkZGluZ0xlZnQnXG4gIF0pO1xuXG4gIGFzc2lnbihjb250ZW50LnN0eWxlLCB7XG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgd29yZFdyYXA6ICdicmVhay13b3JkJ1xuICB9LCBjb250ZW50U3R5bGUpO1xuXG4gIGlmIChvcHRpb25zLmNlbnRlclZlcnRpY2FsbHkpIHtcbiAgICBhc3NpZ24oY29udGVudC5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3A6ICc1MCUnLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsIC01MCUpJ1xuICAgIH0sIGNvbnRlbnRTdHlsZSk7XG4gIH1cblxuICBjb250ZW50LmlubmVyVGV4dCA9IHZhbHVlO1xuXG4gIGRvbUV2ZW50LmJpbmQoY29udGVudCwgJ2tleWRvd24nLCB0aGlzLmtleUhhbmRsZXIpO1xuICBkb21FdmVudC5iaW5kKGNvbnRlbnQsICdtb3VzZWRvd24nLCBzdG9wUHJvcGFnYXRpb24pO1xuICBkb21FdmVudC5iaW5kKGNvbnRlbnQsICdwYXN0ZScsIHNlbGYuaGFuZGxlUGFzdGUpO1xuXG4gIGlmIChvcHRpb25zLmF1dG9SZXNpemUpIHtcbiAgICBkb21FdmVudC5iaW5kKGNvbnRlbnQsICdpbnB1dCcsIHRoaXMuYXV0b1Jlc2l6ZSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZXNpemFibGUpIHtcbiAgICB0aGlzLnJlc2l6YWJsZShzdHlsZSk7XG4gIH1cblxuICBjb250YWluZXIuYXBwZW5kQ2hpbGQocGFyZW50KTtcblxuICAvLyBzZXQgc2VsZWN0aW9uIHRvIGVuZCBvZiB0ZXh0XG4gIHRoaXMuc2V0U2VsZWN0aW9uKGNvbnRlbnQubGFzdENoaWxkLCBjb250ZW50Lmxhc3RDaGlsZCAmJiBjb250ZW50Lmxhc3RDaGlsZC5sZW5ndGgpO1xuXG4gIHJldHVybiBwYXJlbnQ7XG59O1xuXG4vKipcbiAqIEludGVyY2VwdCBwYXN0ZSBldmVudHMgdG8gcmVtb3ZlIGZvcm1hdHRpbmcgZnJvbSBwYXN0ZWQgdGV4dC5cbiAqL1xuVGV4dEJveC5wcm90b3R5cGUuaGFuZGxlUGFzdGUgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICB2YXIgdGV4dDtcblxuICBpZiAoZS5jbGlwYm9hcmREYXRhKSB7XG5cbiAgICAvLyBDaHJvbWUsIEZpcmVmb3gsIFNhZmFyaVxuICAgIHRleHQgPSBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuICB9IGVsc2Uge1xuXG4gICAgLy8gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICB0ZXh0ID0gd2luZG93LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgnVGV4dCcpO1xuICB9XG5cbiAgdGhpcy5pbnNlcnRUZXh0KHRleHQpO1xuXG4gIGlmIChvcHRpb25zLmF1dG9SZXNpemUpIHtcbiAgICB2YXIgaGFzUmVzaXplZCA9IHRoaXMuYXV0b1Jlc2l6ZShzdHlsZSk7XG5cbiAgICBpZiAoaGFzUmVzaXplZCkge1xuICAgICAgdGhpcy5yZXNpemVIYW5kbGVyKGhhc1Jlc2l6ZWQpO1xuICAgIH1cbiAgfVxufTtcblxuVGV4dEJveC5wcm90b3R5cGUuaW5zZXJ0VGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcblxuICAvLyBpbnNlcnRUZXh0IGNvbW1hbmQgbm90IHN1cHBvcnRlZCBieSBJbnRlcm5ldCBFeHBsb3JlclxuICB2YXIgc3VjY2VzcyA9IGRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRUZXh0JywgZmFsc2UsIHRleHQpO1xuXG4gIGlmIChzdWNjZXNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5faW5zZXJ0VGV4dElFKHRleHQpO1xufTtcblxuVGV4dEJveC5wcm90b3R5cGUuX2luc2VydFRleHRJRSA9IGZ1bmN0aW9uKHRleHQpIHtcblxuICAvLyBJbnRlcm5ldCBFeHBsb3JlclxuICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvbigpLFxuICAgICAgc3RhcnRDb250YWluZXIgPSByYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICAgIGVuZENvbnRhaW5lciA9IHJhbmdlLmVuZENvbnRhaW5lcixcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQsXG4gICAgICBlbmRPZmZzZXQgPSByYW5nZS5lbmRPZmZzZXQsXG4gICAgICBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIHZhciBjaGlsZE5vZGVzQXJyYXkgPSB0b0FycmF5KGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLmNoaWxkTm9kZXMpO1xuXG4gIHZhciBjb250YWluZXIsXG4gICAgICBvZmZzZXQ7XG5cbiAgaWYgKGlzVGV4dE5vZGUoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgdmFyIGNvbnRhaW5lclRleHRDb250ZW50ID0gc3RhcnRDb250YWluZXIudGV4dENvbnRlbnQ7XG5cbiAgICBzdGFydENvbnRhaW5lci50ZXh0Q29udGVudCA9XG4gICAgICBjb250YWluZXJUZXh0Q29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpXG4gICAgICArIHRleHRcbiAgICAgICsgY29udGFpbmVyVGV4dENvbnRlbnQuc3Vic3RyaW5nKGVuZE9mZnNldCk7XG5cbiAgICBjb250YWluZXIgPSBzdGFydENvbnRhaW5lcjtcbiAgICBvZmZzZXQgPSBzdGFydE9mZnNldCArIHRleHQubGVuZ3RoO1xuXG4gIH0gZWxzZSBpZiAoc3RhcnRDb250YWluZXIgPT09IHRoaXMuY29udGVudCAmJiBlbmRDb250YWluZXIgPT09IHRoaXMuY29udGVudCkge1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuXG4gICAgdGhpcy5jb250ZW50Lmluc2VydEJlZm9yZSh0ZXh0Tm9kZSwgY2hpbGROb2Rlc0FycmF5W3N0YXJ0T2Zmc2V0XSk7XG5cbiAgICBjb250YWluZXIgPSB0ZXh0Tm9kZTtcbiAgICBvZmZzZXQgPSB0ZXh0Tm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0YXJ0Q29udGFpbmVyQ2hpbGRJbmRleCA9IGNoaWxkTm9kZXNBcnJheS5pbmRleE9mKHN0YXJ0Q29udGFpbmVyKSxcbiAgICAgICAgZW5kQ29udGFpbmVyQ2hpbGRJbmRleCA9IGNoaWxkTm9kZXNBcnJheS5pbmRleE9mKGVuZENvbnRhaW5lcik7XG5cbiAgICBjaGlsZE5vZGVzQXJyYXkuZm9yRWFjaChmdW5jdGlvbihjaGlsZE5vZGUsIGluZGV4KSB7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gc3RhcnRDb250YWluZXJDaGlsZEluZGV4KSB7XG4gICAgICAgIGNoaWxkTm9kZS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgc3RhcnRDb250YWluZXIudGV4dENvbnRlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KSArXG4gICAgICAgICAgdGV4dCArXG4gICAgICAgICAgZW5kQ29udGFpbmVyLnRleHRDb250ZW50LnN1YnN0cmluZyhlbmRPZmZzZXQpO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA+IHN0YXJ0Q29udGFpbmVyQ2hpbGRJbmRleCAmJiBpbmRleCA8PSBlbmRDb250YWluZXJDaGlsZEluZGV4KSB7XG4gICAgICAgIGRvbVJlbW92ZShjaGlsZE5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGFpbmVyID0gc3RhcnRDb250YWluZXI7XG4gICAgb2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyB0ZXh0Lmxlbmd0aDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIgJiYgb2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcblxuICAgIC8vIGlzIG5lY2Vzc2FyeSBpbiBJbnRlcm5ldCBFeHBsb3JlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnNldFNlbGVjdGlvbihjb250YWluZXIsIG9mZnNldCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQXV0b21hdGljYWxseSByZXNpemUgZWxlbWVudCB2ZXJ0aWNhbGx5IHRvIGZpdCBpdHMgY29udGVudC5cbiAqL1xuVGV4dEJveC5wcm90b3R5cGUuYXV0b1Jlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuXG4gIHZhciBmb250U2l6ZSA9IHBhcnNlSW50KHRoaXMuc3R5bGUuZm9udFNpemUpIHx8IDEyO1xuXG4gIGlmIChjb250ZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudC5vZmZzZXRIZWlnaHQgfHxcbiAgICAgIGNvbnRlbnQuc2Nyb2xsSGVpZ2h0IDwgcGFyZW50Lm9mZnNldEhlaWdodCAtIGZvbnRTaXplKSB7XG4gICAgdmFyIGJvdW5kcyA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHZhciBoZWlnaHQgPSBjb250ZW50LnNjcm9sbEhlaWdodDtcbiAgICBwYXJlbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgIHRoaXMucmVzaXplSGFuZGxlcih7XG4gICAgICB3aWR0aDogYm91bmRzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxuICAgICAgZHg6IDAsXG4gICAgICBkeTogaGVpZ2h0IC0gYm91bmRzLmhlaWdodFxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYW4gZWxlbWVudCByZXNpemFibGUgYnkgYWRkaW5nIGEgcmVzaXplIGhhbmRsZS5cbiAqL1xuVGV4dEJveC5wcm90b3R5cGUucmVzaXphYmxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICByZXNpemVIYW5kbGUgPSB0aGlzLnJlc2l6ZUhhbmRsZTtcblxuICB2YXIgbWluV2lkdGggPSBwYXJzZUludCh0aGlzLnN0eWxlLm1pbldpZHRoKSB8fCAwLFxuICAgICAgbWluSGVpZ2h0ID0gcGFyc2VJbnQodGhpcy5zdHlsZS5taW5IZWlnaHQpIHx8IDAsXG4gICAgICBtYXhXaWR0aCA9IHBhcnNlSW50KHRoaXMuc3R5bGUubWF4V2lkdGgpIHx8IEluZmluaXR5LFxuICAgICAgbWF4SGVpZ2h0ID0gcGFyc2VJbnQodGhpcy5zdHlsZS5tYXhIZWlnaHQpIHx8IEluZmluaXR5O1xuXG4gIGlmICghcmVzaXplSGFuZGxlKSB7XG4gICAgcmVzaXplSGFuZGxlID0gdGhpcy5yZXNpemVIYW5kbGUgPSBkb21pZnkoXG4gICAgICAnPGRpdiBjbGFzcz1cImRqcy1kaXJlY3QtZWRpdGluZy1yZXNpemUtaGFuZGxlXCI+PC9kaXY+J1xuICAgICk7XG5cbiAgICB2YXIgc3RhcnRYLCBzdGFydFksIHN0YXJ0V2lkdGgsIHN0YXJ0SGVpZ2h0O1xuXG4gICAgdmFyIG9uTW91c2VEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICBzdG9wUHJvcGFnYXRpb24oZSk7XG5cbiAgICAgIHN0YXJ0WCA9IGUuY2xpZW50WDtcbiAgICAgIHN0YXJ0WSA9IGUuY2xpZW50WTtcblxuICAgICAgdmFyIGJvdW5kcyA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgc3RhcnRXaWR0aCA9IGJvdW5kcy53aWR0aDtcbiAgICAgIHN0YXJ0SGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcblxuICAgICAgZG9tRXZlbnQuYmluZChkb2N1bWVudCwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICAgIGRvbUV2ZW50LmJpbmQoZG9jdW1lbnQsICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICB9O1xuXG4gICAgdmFyIG9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICBzdG9wUHJvcGFnYXRpb24oZSk7XG5cbiAgICAgIHZhciBuZXdXaWR0aCA9IG1pbihtYXgoc3RhcnRXaWR0aCArIGUuY2xpZW50WCAtIHN0YXJ0WCwgbWluV2lkdGgpLCBtYXhXaWR0aCk7XG4gICAgICB2YXIgbmV3SGVpZ2h0ID0gbWluKG1heChzdGFydEhlaWdodCArIGUuY2xpZW50WSAtIHN0YXJ0WSwgbWluSGVpZ2h0KSwgbWF4SGVpZ2h0KTtcblxuICAgICAgcGFyZW50LnN0eWxlLndpZHRoID0gbmV3V2lkdGggKyAncHgnO1xuICAgICAgcGFyZW50LnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodCArICdweCc7XG5cbiAgICAgIHNlbGYucmVzaXplSGFuZGxlcih7XG4gICAgICAgIHdpZHRoOiBzdGFydFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHN0YXJ0SGVpZ2h0LFxuICAgICAgICBkeDogZS5jbGllbnRYIC0gc3RhcnRYLFxuICAgICAgICBkeTogZS5jbGllbnRZIC0gc3RhcnRZXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIG9uTW91c2VVcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgc3RvcFByb3BhZ2F0aW9uKGUpO1xuXG4gICAgICBkb21FdmVudC51bmJpbmQoZG9jdW1lbnQsJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICBkb21FdmVudC51bmJpbmQoZG9jdW1lbnQsICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIGRvbUV2ZW50LmJpbmQocmVzaXplSGFuZGxlLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICB9XG5cbiAgYXNzaWduKHJlc2l6ZUhhbmRsZS5zdHlsZSwge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGJvdHRvbTogJzBweCcsXG4gICAgcmlnaHQ6ICcwcHgnLFxuICAgIGN1cnNvcjogJ253c2UtcmVzaXplJyxcbiAgICB3aWR0aDogJzAnLFxuICAgIGhlaWdodDogJzAnLFxuICAgIGJvcmRlclRvcDogKHBhcnNlSW50KHRoaXMuc3R5bGUuZm9udFNpemUpIC8gNCB8fCAzKSArICdweCBzb2xpZCB0cmFuc3BhcmVudCcsXG4gICAgYm9yZGVyUmlnaHQ6IChwYXJzZUludCh0aGlzLnN0eWxlLmZvbnRTaXplKSAvIDQgfHwgMykgKyAncHggc29saWQgI2NjYycsXG4gICAgYm9yZGVyQm90dG9tOiAocGFyc2VJbnQodGhpcy5zdHlsZS5mb250U2l6ZSkgLyA0IHx8IDMpICsgJ3B4IHNvbGlkICNjY2MnLFxuICAgIGJvcmRlckxlZnQ6IChwYXJzZUludCh0aGlzLnN0eWxlLmZvbnRTaXplKSAvIDQgfHwgMykgKyAncHggc29saWQgdHJhbnNwYXJlbnQnXG4gIH0pO1xuXG4gIHBhcmVudC5hcHBlbmRDaGlsZChyZXNpemVIYW5kbGUpO1xufTtcblxuXG4vKipcbiAqIENsZWFyIGNvbnRlbnQgYW5kIHN0eWxlIG9mIHRoZSB0ZXh0Ym94LCB1bmJpbmQgbGlzdGVuZXJzIGFuZFxuICogcmVzZXQgQ1NTIHN0eWxlLlxuICovXG5UZXh0Qm94LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQsXG4gICAgICByZXNpemVIYW5kbGUgPSB0aGlzLnJlc2l6ZUhhbmRsZTtcblxuICAvLyBjbGVhciBjb250ZW50XG4gIGNvbnRlbnQuaW5uZXJUZXh0ID0gJyc7XG5cbiAgLy8gY2xlYXIgc3R5bGVzXG4gIHBhcmVudC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gIGNvbnRlbnQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXG4gIGRvbUV2ZW50LnVuYmluZChjb250ZW50LCAna2V5ZG93bicsIHRoaXMua2V5SGFuZGxlcik7XG4gIGRvbUV2ZW50LnVuYmluZChjb250ZW50LCAnbW91c2Vkb3duJywgc3RvcFByb3BhZ2F0aW9uKTtcbiAgZG9tRXZlbnQudW5iaW5kKGNvbnRlbnQsICdpbnB1dCcsIHRoaXMuYXV0b1Jlc2l6ZSk7XG4gIGRvbUV2ZW50LnVuYmluZChjb250ZW50LCAncGFzdGUnLCB0aGlzLmhhbmRsZVBhc3RlKTtcblxuICBpZiAocmVzaXplSGFuZGxlKSB7XG4gICAgcmVzaXplSGFuZGxlLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgIGRvbVJlbW92ZShyZXNpemVIYW5kbGUpO1xuICB9XG5cbiAgZG9tUmVtb3ZlKHBhcmVudCk7XG59O1xuXG5cblRleHRCb3gucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRlbnQuaW5uZXJUZXh0LnRyaW0oKTtcbn07XG5cblxuVGV4dEJveC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuXG4gIHJldHVybiByYW5nZTtcbn07XG5cblxuVGV4dEJveC5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oY29udGFpbmVyLCBvZmZzZXQpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuICBpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRoaXMuY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgIHJhbmdlLnNldEVuZChjb250YWluZXIsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbn07XG4iLCJpbXBvcnQgeyBJbmplY3RvciB9IGZyb20gJ2RpZGknO1xuXG5pbXBvcnQgQ29yZU1vZHVsZSBmcm9tICcuL2NvcmUnO1xuXG5cbi8qKlxuICogQm9vdHN0cmFwIGFuIGluamVjdG9yIGZyb20gYSBsaXN0IG9mIG1vZHVsZXMsIGluc3RhbnRpYXRpbmcgYSBudW1iZXIgb2YgZGVmYXVsdCBjb21wb25lbnRzXG4gKlxuICogQGlnbm9yZVxuICogQHBhcmFtIHtBcnJheTxkaWRpLk1vZHVsZT59IGJvb3RzdHJhcE1vZHVsZXNcbiAqXG4gKiBAcmV0dXJuIHtkaWRpLkluamVjdG9yfSBhIGluamVjdG9yIHRvIHVzZSB0byBhY2Nlc3MgdGhlIGNvbXBvbmVudHNcbiAqL1xuZnVuY3Rpb24gYm9vdHN0cmFwKGJvb3RzdHJhcE1vZHVsZXMpIHtcblxuICB2YXIgbW9kdWxlcyA9IFtdLFxuICAgICAgY29tcG9uZW50cyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGhhc01vZHVsZShtKSB7XG4gICAgcmV0dXJuIG1vZHVsZXMuaW5kZXhPZihtKSA+PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTW9kdWxlKG0pIHtcbiAgICBtb2R1bGVzLnB1c2gobSk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpdChtKSB7XG4gICAgaWYgKGhhc01vZHVsZShtKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIChtLl9fZGVwZW5kc19fIHx8IFtdKS5mb3JFYWNoKHZpc2l0KTtcblxuICAgIGlmIChoYXNNb2R1bGUobSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhZGRNb2R1bGUobSk7XG5cbiAgICAobS5fX2luaXRfXyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goYyk7XG4gICAgfSk7XG4gIH1cblxuICBib290c3RyYXBNb2R1bGVzLmZvckVhY2godmlzaXQpO1xuXG4gIHZhciBpbmplY3RvciA9IG5ldyBJbmplY3Rvcihtb2R1bGVzKTtcblxuICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24oYykge1xuXG4gICAgdHJ5IHtcblxuICAgICAgLy8gZWFnZXJseSByZXNvbHZlIGNvbXBvbmVudCAoZm4gb3Igc3RyaW5nKVxuICAgICAgaW5qZWN0b3JbdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gJ2dldCcgOiAnaW52b2tlJ10oYyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluc3RhbnRpYXRlIGNvbXBvbmVudCcpO1xuICAgICAgY29uc29sZS5lcnJvcihlLnN0YWNrKTtcblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpbmplY3Rvcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGluamVjdG9yIGZyb20gcGFzc2VkIG9wdGlvbnMuXG4gKlxuICogQGlnbm9yZVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtkaWRpLkluamVjdG9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmplY3RvcihvcHRpb25zKSB7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGNvbmZpZ01vZHVsZSA9IHtcbiAgICAnY29uZmlnJzogWyd2YWx1ZScsIG9wdGlvbnNdXG4gIH07XG5cbiAgdmFyIG1vZHVsZXMgPSBbIGNvbmZpZ01vZHVsZSwgQ29yZU1vZHVsZSBdLmNvbmNhdChvcHRpb25zLm1vZHVsZXMgfHwgW10pO1xuXG4gIHJldHVybiBib290c3RyYXAobW9kdWxlcyk7XG59XG5cblxuLyoqXG4gKiBUaGUgbWFpbiBkaWFncmFtLWpzIGVudHJ5IHBvaW50IHRoYXQgYm9vdHN0cmFwcyB0aGUgZGlhZ3JhbSB3aXRoIHRoZSBnaXZlblxuICogY29uZmlndXJhdGlvbi5cbiAqXG4gKiBUbyByZWdpc3RlciBleHRlbnNpb25zIHdpdGggdGhlIGRpYWdyYW0sIHBhc3MgdGhlbSBhcyBBcnJheTxkaWRpLk1vZHVsZT4gdG8gdGhlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBjbGFzcyBkanMuRGlhZ3JhbVxuICogQG1lbWJlck9mIGRqc1xuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiA8Y2FwdGlvbj5DcmVhdGluZyBhIHBsdWctaW4gdGhhdCBsb2dzIHdoZW5ldmVyIGEgc2hhcGUgaXMgYWRkZWQgdG8gdGhlIGNhbnZhcy48L2NhcHRpb24+XG4gKlxuICogLy8gcGx1Zy1pbiBpbXBsZW1lbmVudGF0aW9uXG4gKiBmdW5jdGlvbiBNeUxvZ2dpbmdQbHVnaW4oZXZlbnRCdXMpIHtcbiAqICAgZXZlbnRCdXMub24oJ3NoYXBlLmFkZGVkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgICBjb25zb2xlLmxvZygnc2hhcGUgJywgZXZlbnQuc2hhcGUsICcgd2FzIGFkZGVkIHRvIHRoZSBkaWFncmFtJyk7XG4gKiAgIH0pO1xuICogfVxuICpcbiAqIC8vIGV4cG9ydCBhcyBtb2R1bGVcbiAqIGV4cG9ydCBkZWZhdWx0IHtcbiAqICAgX19pbml0X186IFsgJ215TG9nZ2luZ1BsdWdpbicgXSxcbiAqICAgICBteUxvZ2dpbmdQbHVnaW46IFsgJ3R5cGUnLCBNeUxvZ2dpbmdQbHVnaW4gXVxuICogfTtcbiAqXG4gKlxuICogLy8gaW5zdGFudGlhdGUgdGhlIGRpYWdyYW0gd2l0aCB0aGUgbmV3IHBsdWctaW5cbiAqXG4gKiBpbXBvcnQgTXlMb2dnaW5nTW9kdWxlIGZyb20gJ3BhdGgtdG8tbXktbG9nZ2luZy1wbHVnaW4nO1xuICpcbiAqIHZhciBkaWFncmFtID0gbmV3IERpYWdyYW0oe1xuICogICBtb2R1bGVzOiBbXG4gKiAgICAgTXlMb2dnaW5nTW9kdWxlXG4gKiAgIF1cbiAqIH0pO1xuICpcbiAqIGRpYWdyYW0uaW52b2tlKFsgJ2NhbnZhcycsIGZ1bmN0aW9uKGNhbnZhcykge1xuICogICAvLyBhZGQgc2hhcGUgdG8gZHJhd2luZyBjYW52YXNcbiAqICAgY2FudmFzLmFkZFNoYXBlKHsgeDogMTAsIHk6IDEwIH0pO1xuICogfSk7XG4gKlxuICogLy8gJ3NoYXBlIC4uLiB3YXMgYWRkZWQgdG8gdGhlIGRpYWdyYW0nIGxvZ2dlZCB0byBjb25zb2xlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXk8ZGlkaS5Nb2R1bGU+fSBbb3B0aW9ucy5tb2R1bGVzXSBleHRlcm5hbCBtb2R1bGVzIHRvIGluc3RhbnRpYXRlIHdpdGggdGhlIGRpYWdyYW1cbiAqIEBwYXJhbSB7ZGlkaS5JbmplY3Rvcn0gW2luamVjdG9yXSBhbiAob3B0aW9uYWwpIGluamVjdG9yIHRvIGJvb3RzdHJhcCB0aGUgZGlhZ3JhbSB3aXRoXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERpYWdyYW0ob3B0aW9ucywgaW5qZWN0b3IpIHtcblxuICAvLyBjcmVhdGUgaW5qZWN0b3IgdW5sZXNzIGV4cGxpY2l0bHkgc3BlY2lmaWVkXG4gIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvciA9IGluamVjdG9yIHx8IGNyZWF0ZUluamVjdG9yKG9wdGlvbnMpO1xuXG4gIC8vIEFQSVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIGRpYWdyYW0gc2VydmljZVxuICAgKlxuICAgKiBAbWV0aG9kIERpYWdyYW0jZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBkaWFncmFtIHNlcnZpY2UgdG8gYmUgcmV0cmlldmVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0cmljdD10cnVlXSBpZiBmYWxzZSwgcmVzb2x2ZSBtaXNzaW5nIHNlcnZpY2VzIHRvIG51bGxcbiAgICovXG4gIHRoaXMuZ2V0ID0gaW5qZWN0b3IuZ2V0O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIGZ1bmN0aW9uIGludG8gd2hpY2ggZGlhZ3JhbSBzZXJ2aWNlcyBhcmUgaW5qZWN0ZWRcbiAgICpcbiAgICogQG1ldGhvZCBEaWFncmFtI2ludm9rZVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdFtdfSBmbiB0aGUgZnVuY3Rpb24gdG8gcmVzb2x2ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYWxzIGEgbnVtYmVyIG9mIGxvY2FscyB0byB1c2UgdG8gcmVzb2x2ZSBjZXJ0YWluIGRlcGVuZGVuY2llc1xuICAgKi9cbiAgdGhpcy5pbnZva2UgPSBpbmplY3Rvci5pbnZva2U7XG5cbiAgLy8gaW5pdFxuXG4gIC8vIGluZGljYXRlIHZpYSBldmVudFxuXG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhbGwgcGx1Zy1pbnMgYXJlIGxvYWRlZC5cbiAgICpcbiAgICogVXNlIHRoaXMgZXZlbnQgdG8gZmlyZSBvdGhlciBldmVudHMgdG8gaW50ZXJlc3RlZCBwbHVnLWluc1xuICAgKlxuICAgKiBAbWVtYmVyT2YgRGlhZ3JhbVxuICAgKlxuICAgKiBAZXZlbnQgZGlhZ3JhbS5pbml0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGV2ZW50QnVzLm9uKCdkaWFncmFtLmluaXQnLCBmdW5jdGlvbigpIHtcbiAgICogICBldmVudEJ1cy5maXJlKCdteS1jdXN0b20tZXZlbnQnLCB7IGZvbzogJ0JBUicgfSk7XG4gICAqIH0pO1xuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5nZXQoJ2V2ZW50QnVzJykuZmlyZSgnZGlhZ3JhbS5pbml0Jyk7XG59XG5cblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgZGlhZ3JhbVxuICpcbiAqIEBtZXRob2QgIERpYWdyYW0jZGVzdHJveVxuICovXG5EaWFncmFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ2V0KCdldmVudEJ1cycpLmZpcmUoJ2RpYWdyYW0uZGVzdHJveScpO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgZGlhZ3JhbSwgcmVtb3ZpbmcgYWxsIGNvbnRlbnRzLlxuICovXG5EaWFncmFtLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdldCgnZXZlbnRCdXMnKS5maXJlKCdkaWFncmFtLmNsZWFyJyk7XG59O1xuIiwiaW1wb3J0IHtcbiAgZm9yRWFjaCxcbiAgaXNGdW5jdGlvbixcbiAgaXNBcnJheSxcbiAgaXNOdW1iZXIsXG4gIGlzT2JqZWN0XG59IGZyb20gJ21pbi1kYXNoJztcblxuXG52YXIgREVGQVVMVF9QUklPUklUWSA9IDEwMDA7XG5cbi8qKlxuICogQSB1dGlsaXR5IHRoYXQgY2FuIGJlIHVzZWQgdG8gcGx1Zy1pbiBpbnRvIHRoZSBjb21tYW5kIGV4ZWN1dGlvbiBmb3JcbiAqIGV4dGVuc2lvbiBhbmQvb3IgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbiAqXG4gKiBpbXBvcnQgQ29tbWFuZEludGVyY2VwdG9yIGZyb20gJ2RpYWdyYW0tanMvbGliL2NvbW1hbmQvQ29tbWFuZEludGVyY2VwdG9yJztcbiAqXG4gKiBmdW5jdGlvbiBDb21tYW5kTG9nZ2VyKGV2ZW50QnVzKSB7XG4gKiAgIENvbW1hbmRJbnRlcmNlcHRvci5jYWxsKHRoaXMsIGV2ZW50QnVzKTtcbiAqXG4gKiAgIHRoaXMucHJlRXhlY3V0ZShmdW5jdGlvbihldmVudCkge1xuICogICAgIGNvbnNvbGUubG9nKCdjb21tYW5kIHByZS1leGVjdXRlJywgZXZlbnQpO1xuICogICB9KTtcbiAqIH1cbiAqXG4gKiBpbmhlcml0cyhDb21tYW5kTG9nZ2VyLCBDb21tYW5kSW50ZXJjZXB0b3IpO1xuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29tbWFuZEludGVyY2VwdG9yKGV2ZW50QnVzKSB7XG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG59XG5cbkNvbW1hbmRJbnRlcmNlcHRvci4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnIF07XG5cbmZ1bmN0aW9uIHVud3JhcEV2ZW50KGZuLCB0aGF0KSB7XG4gIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBmbi5jYWxsKHRoYXQgfHwgbnVsbCwgZXZlbnQuY29udGV4dCwgZXZlbnQuY29tbWFuZCwgZXZlbnQpO1xuICB9O1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGFuIGludGVyY2VwdG9yIGZvciBhIGNvbW1hbmQgZXhlY3V0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gW2V2ZW50c10gbGlzdCBvZiBjb21tYW5kcyB0byByZWdpc3RlciBvblxuICogQHBhcmFtIHtzdHJpbmd9IFtob29rXSBjb21tYW5kIGhvb2ssIGkuZS4gcHJlRXhlY3V0ZSwgZXhlY3V0ZWQgdG8gbGlzdGVuIG9uXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5XSB0aGUgcHJpb3JpdHkgb24gd2hpY2ggdG8gaG9vayBpbnRvIHRoZSBleGVjdXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJGbiBpbnRlcmNlcHRvciB0byBiZSBpbnZva2VkIHdpdGggKGV2ZW50KVxuICogQHBhcmFtIHtib29sZWFufSB1bndyYXAgaWYgdHJ1ZSwgdW53cmFwIHRoZSBldmVudCBhbmQgcGFzcyAoY29udGV4dCwgY29tbWFuZCwgZXZlbnQpIHRvIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyIGluc3RlYWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGhhdF0gUGFzcyBjb250ZXh0IChgdGhpc2ApIHRvIHRoZSBoYW5kbGVyIGZ1bmN0aW9uXG4gKi9cbkNvbW1hbmRJbnRlcmNlcHRvci5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudHMsIGhvb2ssIHByaW9yaXR5LCBoYW5kbGVyRm4sIHVud3JhcCwgdGhhdCkge1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhvb2spIHx8IGlzTnVtYmVyKGhvb2spKSB7XG4gICAgdGhhdCA9IHVud3JhcDtcbiAgICB1bndyYXAgPSBoYW5kbGVyRm47XG4gICAgaGFuZGxlckZuID0gcHJpb3JpdHk7XG4gICAgcHJpb3JpdHkgPSBob29rO1xuICAgIGhvb2sgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24ocHJpb3JpdHkpKSB7XG4gICAgdGhhdCA9IHVud3JhcDtcbiAgICB1bndyYXAgPSBoYW5kbGVyRm47XG4gICAgaGFuZGxlckZuID0gcHJpb3JpdHk7XG4gICAgcHJpb3JpdHkgPSBERUZBVUxUX1BSSU9SSVRZO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KHVud3JhcCkpIHtcbiAgICB0aGF0ID0gdW53cmFwO1xuICAgIHVud3JhcCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGhhbmRsZXJGbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhbmRsZXJGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghaXNBcnJheShldmVudHMpKSB7XG4gICAgZXZlbnRzID0gWyBldmVudHMgXTtcbiAgfVxuXG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgLy8gY29uY2F0IGNvbW1hbmRTdGFjayguZXZlbnQpPyguaG9vayk/XG4gICAgdmFyIGZ1bGxFdmVudCA9IFsgJ2NvbW1hbmRTdGFjaycsIGV2ZW50LCBob29rIF0uZmlsdGVyKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGU7IH0pLmpvaW4oJy4nKTtcblxuICAgIGV2ZW50QnVzLm9uKGZ1bGxFdmVudCwgcHJpb3JpdHksIHVud3JhcCA/IHVud3JhcEV2ZW50KGhhbmRsZXJGbiwgdGhhdCkgOiBoYW5kbGVyRm4sIHRoYXQpO1xuICB9KTtcbn07XG5cblxudmFyIGhvb2tzID0gW1xuICAnY2FuRXhlY3V0ZScsXG4gICdwcmVFeGVjdXRlJyxcbiAgJ3ByZUV4ZWN1dGVkJyxcbiAgJ2V4ZWN1dGUnLFxuICAnZXhlY3V0ZWQnLFxuICAncG9zdEV4ZWN1dGUnLFxuICAncG9zdEV4ZWN1dGVkJyxcbiAgJ3JldmVydCcsXG4gICdyZXZlcnRlZCdcbl07XG5cbi8qXG4gKiBJbnN0YWxsIGhvb2sgc2hvcnRjdXRzXG4gKlxuICogVGhpcyB3aWxsIGdlbmVyYXRlIHRoZSBDb21tYW5kSW50ZXJjZXB0b3IjKHByZUV4ZWN1dGV8Li4ufHJldmVydGVkKSBtZXRob2RzXG4gKiB3aGljaCB3aWxsIGluIHRlcm0gZm9yd2FyZCB0byBDb21tYW5kSW50ZXJjZXB0b3Ijb24uXG4gKi9cbmZvckVhY2goaG9va3MsIGZ1bmN0aW9uKGhvb2spIHtcblxuICAvKipcbiAgICoge2NhbkV4ZWN1dGV8cHJlRXhlY3V0ZXxwcmVFeGVjdXRlZHxleGVjdXRlfGV4ZWN1dGVkfHBvc3RFeGVjdXRlfHBvc3RFeGVjdXRlZHxyZXZlcnR8cmV2ZXJ0ZWR9XG4gICAqXG4gICAqIEEgbmFtZWQgaG9vayBmb3IgcGx1Z2dpbmcgaW50byB0aGUgY29tbWFuZCBleGVjdXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gW2V2ZW50c10gbGlzdCBvZiBjb21tYW5kcyB0byByZWdpc3RlciBvblxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5XSB0aGUgcHJpb3JpdHkgb24gd2hpY2ggdG8gaG9vayBpbnRvIHRoZSBleGVjdXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlckZuIGludGVyY2VwdG9yIHRvIGJlIGludm9rZWQgd2l0aCAoZXZlbnQpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vud3JhcD1mYWxzZV0gaWYgdHJ1ZSwgdW53cmFwIHRoZSBldmVudCBhbmQgcGFzcyAoY29udGV4dCwgY29tbWFuZCwgZXZlbnQpIHRvIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIgaW5zdGVhZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3RoYXRdIFBhc3MgY29udGV4dCAoYHRoaXNgKSB0byB0aGUgaGFuZGxlciBmdW5jdGlvblxuICAgKi9cbiAgQ29tbWFuZEludGVyY2VwdG9yLnByb3RvdHlwZVtob29rXSA9IGZ1bmN0aW9uKGV2ZW50cywgcHJpb3JpdHksIGhhbmRsZXJGbiwgdW53cmFwLCB0aGF0KSB7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmVudHMpIHx8IGlzTnVtYmVyKGV2ZW50cykpIHtcbiAgICAgIHRoYXQgPSB1bndyYXA7XG4gICAgICB1bndyYXAgPSBoYW5kbGVyRm47XG4gICAgICBoYW5kbGVyRm4gPSBwcmlvcml0eTtcbiAgICAgIHByaW9yaXR5ID0gZXZlbnRzO1xuICAgICAgZXZlbnRzID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm9uKGV2ZW50cywgaG9vaywgcHJpb3JpdHksIGhhbmRsZXJGbiwgdW53cmFwLCB0aGF0KTtcbiAgfTtcbn0pO1xuIiwiaW1wb3J0IHtcbiAgdW5pcXVlQnksXG4gIGlzQXJyYXlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbi8qKlxuICogQSBzZXJ2aWNlIHRoYXQgb2ZmZXJzIHVuLSBhbmQgcmVkb2FibGUgZXhlY3V0aW9uIG9mIGNvbW1hbmRzLlxuICpcbiAqIFRoZSBjb21tYW5kIHN0YWNrIGlzIHJlc3BvbnNpYmxlIGZvciBleGVjdXRpbmcgbW9kZWxpbmcgYWN0aW9uc1xuICogaW4gYSB1bi0gYW5kIHJlZG9hYmxlIG1hbm5lci4gVG8gZG8gdGhpcyBpdCBkZWxlZ2F0ZXMgdGhlIGFjdHVhbFxuICogY29tbWFuZCBleGVjdXRpb24gdG8ge0BsaW5rIENvbW1hbmRIYW5kbGVyfXMuXG4gKlxuICogQ29tbWFuZCBoYW5kbGVycyBwcm92aWRlIHtAbGluayBDb21tYW5kSGFuZGxlciNleGVjdXRlKGN0eCl9IGFuZFxuICoge0BsaW5rIENvbW1hbmRIYW5kbGVyI3JldmVydChjdHgpfSBtZXRob2RzIHRvIHVuLSBhbmQgcmVkbyBhIGNvbW1hbmRcbiAqIGlkZW50aWZpZWQgYnkgYSBjb21tYW5kIGNvbnRleHQuXG4gKlxuICpcbiAqICMjIExpZmUtQ3ljbGUgZXZlbnRzXG4gKlxuICogSW4gdGhlIHByb2Nlc3MgdGhlIGNvbW1hbmQgc3RhY2sgZmlyZXMgYSBudW1iZXIgb2YgbGlmZS1jeWNsZSBldmVudHNcbiAqIHRoYXQgb3RoZXIgY29tcG9uZW50cyB0byBwYXJ0aWNpcGF0ZSBpbiB0aGUgY29tbWFuZCBleGVjdXRpb24uXG4gKlxuICogICAgKiBwcmVFeGVjdXRlXG4gKiAgICAqIHByZUV4ZWN1dGVkXG4gKiAgICAqIGV4ZWN1dGVcbiAqICAgICogZXhlY3V0ZWRcbiAqICAgICogcG9zdEV4ZWN1dGVcbiAqICAgICogcG9zdEV4ZWN1dGVkXG4gKiAgICAqIHJldmVydFxuICogICAgKiByZXZlcnRlZFxuICpcbiAqIEEgc3BlY2lhbCBldmVudCBpcyB1c2VkIGZvciB2YWxpZGF0aW5nLCB3aGV0aGVyIGEgY29tbWFuZCBjYW4gYmVcbiAqIHBlcmZvcm1lZCBwcmlvciB0byBpdHMgZXhlY3V0aW9uLlxuICpcbiAqICAgICogY2FuRXhlY3V0ZVxuICpcbiAqIEVhY2ggb2YgdGhlIGV2ZW50cyBpcyBmaXJlZCBhcyBgY29tbWFuZFN0YWNrLntldmVudE5hbWV9YCBhbmRcbiAqIGBjb21tYW5kU3RhY2sue2NvbW1hbmROYW1lfS57ZXZlbnROYW1lfWAsIHJlc3BlY3RpdmVseS4gVGhpcyBnaXZlc1xuICogY29tcG9uZW50cyBmaW5lIGdyYWluZWQgY29udHJvbCBvbiB3aGVyZSB0byBob29rIGludG8uXG4gKlxuICogVGhlIGV2ZW50IG9iamVjdCBmaXJlZCB0cmFuc3BvcnRzIGBjb21tYW5kYCwgdGhlIG5hbWUgb2YgdGhlXG4gKiBjb21tYW5kIGFuZCBgY29udGV4dGAsIHRoZSBjb21tYW5kIGNvbnRleHQuXG4gKlxuICpcbiAqICMjIENyZWF0aW5nIENvbW1hbmQgSGFuZGxlcnNcbiAqXG4gKiBDb21tYW5kIGhhbmRsZXJzIHNob3VsZCBwcm92aWRlIHRoZSB7QGxpbmsgQ29tbWFuZEhhbmRsZXIjZXhlY3V0ZShjdHgpfVxuICogYW5kIHtAbGluayBDb21tYW5kSGFuZGxlciNyZXZlcnQoY3R4KX0gbWV0aG9kcyB0byBpbXBsZW1lbnRcbiAqIHJlZG9pbmcgYW5kIHVuZG9pbmcgb2YgYSBjb21tYW5kLlxuICpcbiAqIEEgY29tbWFuZCBoYW5kbGVyIF9tdXN0XyBlbnN1cmUgdW5kbyBpcyBwZXJmb3JtZWQgcHJvcGVybHkgaW4gb3JkZXJcbiAqIG5vdCB0byBicmVhayB0aGUgdW5kbyBjaGFpbi4gSXQgbXVzdCBhbHNvIHJldHVybiB0aGUgc2hhcGVzIHRoYXRcbiAqIGdvdCBjaGFuZ2VkIGR1cmluZyB0aGUgYGV4ZWN1dGVgIGFuZCBgcmV2ZXJ0YCBvcGVyYXRpb25zLlxuICpcbiAqIENvbW1hbmQgaGFuZGxlcnMgbWF5IGV4ZWN1dGUgb3RoZXIgbW9kZWxpbmcgb3BlcmF0aW9ucyAoYW5kIHRodXNcbiAqIGNvbW1hbmRzKSBpbiB0aGVpciBgcHJlRXhlY3V0ZWAgYW5kIGBwb3N0RXhlY3V0ZWAgcGhhc2VzLiBUaGUgY29tbWFuZFxuICogc3RhY2sgd2lsbCBwcm9wZXJseSBncm91cCBhbGwgY29tbWFuZHMgdG9nZXRoZXIgaW50byBhIGxvZ2ljYWwgdW5pdFxuICogdGhhdCBtYXkgYmUgcmUtIGFuZCB1bmRvbmUgYXRvbWljYWxseS5cbiAqXG4gKiBDb21tYW5kIGhhbmRsZXJzIG11c3Qgbm90IGV4ZWN1dGUgb3RoZXIgY29tbWFuZHMgZnJvbSB3aXRoaW4gdGhlaXJcbiAqIGNvcmUgaW1wbGVtZW50YXRpb24gKGBleGVjdXRlYCwgYHJldmVydGApLlxuICpcbiAqXG4gKiAjIyBDaGFuZ2UgVHJhY2tpbmdcbiAqXG4gKiBEdXJpbmcgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgQ29tbWFuZFN0YWNrIGl0IHdpbGwga2VlcCB0cmFjayBvZiBhbGxcbiAqIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHRvdWNoZWQgZHVyaW5nIHRoZSBjb21tYW5kJ3MgZXhlY3V0aW9uLlxuICpcbiAqIEF0IHRoZSBlbmQgb2YgdGhlIENvbW1hbmRTdGFjayBleGVjdXRpb24gaXQgd2lsbCBub3RpZnkgaW50ZXJlc3RlZFxuICogY29tcG9uZW50cyB2aWEgYW4gJ2VsZW1lbnRzLmNoYW5nZWQnIGV2ZW50IHdpdGggYWxsIHRoZSBkaXJ0eVxuICogZWxlbWVudHMuXG4gKlxuICogVGhlIGV2ZW50IGNhbiBiZSBwaWNrZWQgdXAgYnkgY29tcG9uZW50cyB0aGF0IGFyZSBpbnRlcmVzdGVkIGluIHRoZSBmYWN0XG4gKiB0aGF0IGVsZW1lbnRzIGhhdmUgYmVlbiBjaGFuZ2VkLiBPbmUgdXNlIGNhc2UgZm9yIHRoaXMgaXMgdXBkYXRpbmdcbiAqIHRoZWlyIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBhZnRlciBtb3ZpbmcgLyByZXNpemluZyBvciBkZWxldGlvbi5cbiAqXG4gKiBAc2VlIENvbW1hbmRIYW5kbGVyXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7SW5qZWN0b3J9IGluamVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbW1hbmRTdGFjayhldmVudEJ1cywgaW5qZWN0b3IpIHtcblxuICAvKipcbiAgICogQSBtYXAgb2YgYWxsIHJlZ2lzdGVyZWQgY29tbWFuZCBoYW5kbGVycy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuX2hhbmRsZXJNYXAgPSB7fTtcblxuICAvKipcbiAgICogQSBzdGFjayBjb250YWluaW5nIGFsbCByZS91bmRvYWJsZSBhY3Rpb25zIG9uIHRoZSBkaWFncmFtXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuICAgKi9cbiAgdGhpcy5fc3RhY2sgPSBbXTtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgaW5kZXggb24gdGhlIHN0YWNrXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLl9zdGFja0lkeCA9IC0xO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IGFjdGl2ZSBjb21tYW5kU3RhY2sgZXhlY3V0aW9uXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IGFjdGlvbnNcbiAgICogQHByb3BlcnR5IHtPYmplY3RbXX0gZGlydHlcbiAgICogQHByb3BlcnR5IHsgJ3VuZG8nIHwgJ3JlZG8nIHwgJ2NsZWFyJyB8ICdleGVjdXRlJyB8IG51bGwgfSB0cmlnZ2VyIHRoZSBjYXVzZSBvZiB0aGUgY3VycmVudCBleGNlY3V0aW9uXG4gICAqL1xuICB0aGlzLl9jdXJyZW50RXhlY3V0aW9uID0ge1xuICAgIGFjdGlvbnM6IFtdLFxuICAgIGRpcnR5OiBbXSxcbiAgICB0cmlnZ2VyOiBudWxsXG4gIH07XG5cblxuICB0aGlzLl9pbmplY3RvciA9IGluamVjdG9yO1xuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuXG4gIHRoaXMuX3VpZCA9IDE7XG5cbiAgZXZlbnRCdXMub24oW1xuICAgICdkaWFncmFtLmRlc3Ryb3knLFxuICAgICdkaWFncmFtLmNsZWFyJ1xuICBdLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyKGZhbHNlKTtcbiAgfSwgdGhpcyk7XG59XG5cbkNvbW1hbmRTdGFjay4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnLCAnaW5qZWN0b3InIF07XG5cblxuLyoqXG4gKiBFeGVjdXRlIGEgY29tbWFuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kIHRoZSBjb21tYW5kIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IHRoZSBlbnZpcm9ubWVudCB0byBleGVjdXRlIHRoZSBjb21tYW5kIGluXG4gKi9cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbW1hbmQsIGNvbnRleHQpIHtcbiAgaWYgKCFjb21tYW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21tYW5kIHJlcXVpcmVkJyk7XG4gIH1cblxuICB0aGlzLl9jdXJyZW50RXhlY3V0aW9uLnRyaWdnZXIgPSAnZXhlY3V0ZSc7XG5cbiAgdmFyIGFjdGlvbiA9IHsgY29tbWFuZDogY29tbWFuZCwgY29udGV4dDogY29udGV4dCB9O1xuXG4gIHRoaXMuX3B1c2hBY3Rpb24oYWN0aW9uKTtcbiAgdGhpcy5faW50ZXJuYWxFeGVjdXRlKGFjdGlvbik7XG4gIHRoaXMuX3BvcEFjdGlvbihhY3Rpb24pO1xufTtcblxuXG4vKipcbiAqIEFzayB3aGV0aGVyIGEgZ2l2ZW4gY29tbWFuZCBjYW4gYmUgZXhlY3V0ZWQuXG4gKlxuICogSW1wbGVtZW50b3JzIG1heSBob29rIGludG8gdGhlIG1lY2hhbmlzbSBvbiB0d28gd2F5czpcbiAqXG4gKiAgICogaW4gZXZlbnQgbGlzdGVuZXJzOlxuICpcbiAqICAgICBVc2VycyBtYXkgcHJldmVudCB0aGUgZXhlY3V0aW9uIHZpYSBhbiBldmVudCBsaXN0ZW5lci5cbiAqICAgICBJdCBtdXN0IHByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBgY29tbWFuZFN0YWNrLig8Y29tbWFuZD4uKWNhbkV4ZWN1dGVgIGV2ZW50cy5cbiAqXG4gKiAgICogaW4gY29tbWFuZCBoYW5kbGVyczpcbiAqXG4gKiAgICAgSWYgdGhlIG1ldGhvZCB7QGxpbmsgQ29tbWFuZEhhbmRsZXIjY2FuRXhlY3V0ZX0gaXMgaW1wbGVtZW50ZWQgaW4gYSBoYW5kbGVyXG4gKiAgICAgaXQgd2lsbCBiZSBjYWxsZWQgdG8gZmlndXJlIG91dCB3aGV0aGVyIHRoZSBleGVjdXRpb24gaXMgYWxsb3dlZC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbW1hbmQgdGhlIGNvbW1hbmQgdG8gZXhlY3V0ZVxuICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0IHRoZSBlbnZpcm9ubWVudCB0byBleGVjdXRlIHRoZSBjb21tYW5kIGluXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY29tbWFuZCBjYW4gYmUgZXhlY3V0ZWRcbiAqL1xuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS5jYW5FeGVjdXRlID0gZnVuY3Rpb24oY29tbWFuZCwgY29udGV4dCkge1xuXG4gIHZhciBhY3Rpb24gPSB7IGNvbW1hbmQ6IGNvbW1hbmQsIGNvbnRleHQ6IGNvbnRleHQgfTtcblxuICB2YXIgaGFuZGxlciA9IHRoaXMuX2dldEhhbmRsZXIoY29tbWFuZCk7XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2ZpcmUoY29tbWFuZCwgJ2NhbkV4ZWN1dGUnLCBhY3Rpb24pO1xuXG4gIC8vIGhhbmRsZXIjY2FuRXhlY3V0ZSB3aWxsIG9ubHkgYmUgY2FsbGVkIGlmIG5vIGxpc3RlbmVyXG4gIC8vIGRlY2lkZWQgb24gYSByZXN1bHQgYWxyZWFkeVxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlci5jYW5FeGVjdXRlKSB7XG4gICAgICByZXN1bHQgPSBoYW5kbGVyLmNhbkV4ZWN1dGUoY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBDbGVhciB0aGUgY29tbWFuZCBzdGFjaywgZXJhc2luZyBhbGwgdW5kbyAvIHJlZG8gaGlzdG9yeVxuICovXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oZW1pdCkge1xuICB0aGlzLl9zdGFjay5sZW5ndGggPSAwO1xuICB0aGlzLl9zdGFja0lkeCA9IC0xO1xuXG4gIGlmIChlbWl0ICE9PSBmYWxzZSkge1xuICAgIHRoaXMuX2ZpcmUoJ2NoYW5nZWQnLCB7IHRyaWdnZXI6ICdjbGVhcicgfSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBVbmRvIGxhc3QgY29tbWFuZChzKVxuICovXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFjdGlvbiA9IHRoaXMuX2dldFVuZG9BY3Rpb24oKSxcbiAgICAgIG5leHQ7XG5cbiAgaWYgKGFjdGlvbikge1xuICAgIHRoaXMuX2N1cnJlbnRFeGVjdXRpb24udHJpZ2dlciA9ICd1bmRvJztcblxuICAgIHRoaXMuX3B1c2hBY3Rpb24oYWN0aW9uKTtcblxuICAgIHdoaWxlIChhY3Rpb24pIHtcbiAgICAgIHRoaXMuX2ludGVybmFsVW5kbyhhY3Rpb24pO1xuICAgICAgbmV4dCA9IHRoaXMuX2dldFVuZG9BY3Rpb24oKTtcblxuICAgICAgaWYgKCFuZXh0IHx8IG5leHQuaWQgIT09IGFjdGlvbi5pZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYWN0aW9uID0gbmV4dDtcbiAgICB9XG5cbiAgICB0aGlzLl9wb3BBY3Rpb24oKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJlZG8gbGFzdCBjb21tYW5kKHMpXG4gKi9cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYWN0aW9uID0gdGhpcy5fZ2V0UmVkb0FjdGlvbigpLFxuICAgICAgbmV4dDtcblxuICBpZiAoYWN0aW9uKSB7XG4gICAgdGhpcy5fY3VycmVudEV4ZWN1dGlvbi50cmlnZ2VyID0gJ3JlZG8nO1xuXG4gICAgdGhpcy5fcHVzaEFjdGlvbihhY3Rpb24pO1xuXG4gICAgd2hpbGUgKGFjdGlvbikge1xuICAgICAgdGhpcy5faW50ZXJuYWxFeGVjdXRlKGFjdGlvbiwgdHJ1ZSk7XG4gICAgICBuZXh0ID0gdGhpcy5fZ2V0UmVkb0FjdGlvbigpO1xuXG4gICAgICBpZiAoIW5leHQgfHwgbmV4dC5pZCAhPT0gYWN0aW9uLmlkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhY3Rpb24gPSBuZXh0O1xuICAgIH1cblxuICAgIHRoaXMuX3BvcEFjdGlvbigpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBoYW5kbGVyIGluc3RhbmNlIHdpdGggdGhlIGNvbW1hbmQgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZFxuICogQHBhcmFtIHtDb21tYW5kSGFuZGxlcn0gaGFuZGxlclxuICovXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24oY29tbWFuZCwgaGFuZGxlcikge1xuICB0aGlzLl9zZXRIYW5kbGVyKGNvbW1hbmQsIGhhbmRsZXIpO1xufTtcblxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgaGFuZGxlciB0eXBlIHdpdGggdGhlIGNvbW1hbmQgc3RhY2tcbiAqIGJ5IGluc3RhbnRpYXRpbmcgaXQgYW5kIGluamVjdGluZyBpdHMgZGVwZW5kZW5jaWVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhIGNvbnN0cnVjdG9yIGZvciBhIHtAbGluayBDb21tYW5kSGFuZGxlcn1cbiAqL1xuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS5yZWdpc3RlckhhbmRsZXIgPSBmdW5jdGlvbihjb21tYW5kLCBoYW5kbGVyQ2xzKSB7XG5cbiAgaWYgKCFjb21tYW5kIHx8ICFoYW5kbGVyQ2xzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21tYW5kIGFuZCBoYW5kbGVyQ2xzIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSB0aGlzLl9pbmplY3Rvci5pbnN0YW50aWF0ZShoYW5kbGVyQ2xzKTtcbiAgdGhpcy5yZWdpc3Rlcihjb21tYW5kLCBoYW5kbGVyKTtcbn07XG5cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuY2FuVW5kbyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLl9nZXRVbmRvQWN0aW9uKCk7XG59O1xuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLmNhblJlZG8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhdGhpcy5fZ2V0UmVkb0FjdGlvbigpO1xufTtcblxuLy8gc3RhY2sgYWNjZXNzICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuX2dldFJlZG9BY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrSWR4ICsgMV07XG59O1xuXG5cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuX2dldFVuZG9BY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrSWR4XTtcbn07XG5cblxuLy8gaW50ZXJuYWwgZnVuY3Rpb25hbGl0eSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuX2ludGVybmFsVW5kbyA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGNvbW1hbmQgPSBhY3Rpb24uY29tbWFuZCxcbiAgICAgIGNvbnRleHQgPSBhY3Rpb24uY29udGV4dDtcblxuICB2YXIgaGFuZGxlciA9IHRoaXMuX2dldEhhbmRsZXIoY29tbWFuZCk7XG5cbiAgLy8gZ3VhcmQgYWdhaW5zdCBpbGxlZ2FsIG5lc3RlZCBjb21tYW5kIHN0YWNrIGludm9jYXRpb25zXG4gIHRoaXMuX2F0b21pY0RvKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2ZpcmUoY29tbWFuZCwgJ3JldmVydCcsIGFjdGlvbik7XG5cbiAgICBpZiAoaGFuZGxlci5yZXZlcnQpIHtcbiAgICAgIHNlbGYuX21hcmtEaXJ0eShoYW5kbGVyLnJldmVydChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgc2VsZi5fcmV2ZXJ0ZWRBY3Rpb24oYWN0aW9uKTtcblxuICAgIHNlbGYuX2ZpcmUoY29tbWFuZCwgJ3JldmVydGVkJywgYWN0aW9uKTtcbiAgfSk7XG59O1xuXG5cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuX2ZpcmUgPSBmdW5jdGlvbihjb21tYW5kLCBxdWFsaWZpZXIsIGV2ZW50KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIGV2ZW50ID0gcXVhbGlmaWVyO1xuICAgIHF1YWxpZmllciA9IG51bGw7XG4gIH1cblxuICB2YXIgbmFtZXMgPSBxdWFsaWZpZXIgPyBbIGNvbW1hbmQgKyAnLicgKyBxdWFsaWZpZXIsIHF1YWxpZmllciBdIDogWyBjb21tYW5kIF0sXG4gICAgICBpLCBuYW1lLCByZXN1bHQ7XG5cbiAgZXZlbnQgPSB0aGlzLl9ldmVudEJ1cy5jcmVhdGVFdmVudChldmVudCk7XG5cbiAgZm9yIChpID0gMDsgKG5hbWUgPSBuYW1lc1tpXSk7IGkrKykge1xuICAgIHJlc3VsdCA9IHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NvbW1hbmRTdGFjay4nICsgbmFtZSwgZXZlbnQpO1xuXG4gICAgaWYgKGV2ZW50LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuX2NyZWF0ZUlkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl91aWQrKztcbn07XG5cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuX2F0b21pY0RvID0gZnVuY3Rpb24oZm4pIHtcblxuICB2YXIgZXhlY3V0aW9uID0gdGhpcy5fY3VycmVudEV4ZWN1dGlvbjtcblxuICBleGVjdXRpb24uYXRvbWljID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhlY3V0aW9uLmF0b21pYyA9IGZhbHNlO1xuICB9XG59O1xuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9pbnRlcm5hbEV4ZWN1dGUgPSBmdW5jdGlvbihhY3Rpb24sIHJlZG8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBjb21tYW5kID0gYWN0aW9uLmNvbW1hbmQsXG4gICAgICBjb250ZXh0ID0gYWN0aW9uLmNvbnRleHQ7XG5cbiAgdmFyIGhhbmRsZXIgPSB0aGlzLl9nZXRIYW5kbGVyKGNvbW1hbmQpO1xuXG4gIGlmICghaGFuZGxlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gY29tbWFuZCBoYW5kbGVyIHJlZ2lzdGVyZWQgZm9yIDwnICsgY29tbWFuZCArICc+Jyk7XG4gIH1cblxuICB0aGlzLl9wdXNoQWN0aW9uKGFjdGlvbik7XG5cbiAgaWYgKCFyZWRvKSB7XG4gICAgdGhpcy5fZmlyZShjb21tYW5kLCAncHJlRXhlY3V0ZScsIGFjdGlvbik7XG5cbiAgICBpZiAoaGFuZGxlci5wcmVFeGVjdXRlKSB7XG4gICAgICBoYW5kbGVyLnByZUV4ZWN1dGUoY29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZmlyZShjb21tYW5kLCAncHJlRXhlY3V0ZWQnLCBhY3Rpb24pO1xuICB9XG5cbiAgLy8gZ3VhcmQgYWdhaW5zdCBpbGxlZ2FsIG5lc3RlZCBjb21tYW5kIHN0YWNrIGludm9jYXRpb25zXG4gIHRoaXMuX2F0b21pY0RvKGZ1bmN0aW9uKCkge1xuXG4gICAgc2VsZi5fZmlyZShjb21tYW5kLCAnZXhlY3V0ZScsIGFjdGlvbik7XG5cbiAgICBpZiAoaGFuZGxlci5leGVjdXRlKSB7XG5cbiAgICAgIC8vIGFjdHVhbCBleGVjdXRlICsgbWFyayByZXR1cm4gcmVzdWx0cyBhcyBkaXJ0eVxuICAgICAgc2VsZi5fbWFya0RpcnR5KGhhbmRsZXIuZXhlY3V0ZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgLy8gbG9nIHRvIHN0YWNrXG4gICAgc2VsZi5fZXhlY3V0ZWRBY3Rpb24oYWN0aW9uLCByZWRvKTtcblxuICAgIHNlbGYuX2ZpcmUoY29tbWFuZCwgJ2V4ZWN1dGVkJywgYWN0aW9uKTtcbiAgfSk7XG5cbiAgaWYgKCFyZWRvKSB7XG4gICAgdGhpcy5fZmlyZShjb21tYW5kLCAncG9zdEV4ZWN1dGUnLCBhY3Rpb24pO1xuXG4gICAgaWYgKGhhbmRsZXIucG9zdEV4ZWN1dGUpIHtcbiAgICAgIGhhbmRsZXIucG9zdEV4ZWN1dGUoY29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZmlyZShjb21tYW5kLCAncG9zdEV4ZWN1dGVkJywgYWN0aW9uKTtcbiAgfVxuXG4gIHRoaXMuX3BvcEFjdGlvbihhY3Rpb24pO1xufTtcblxuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9wdXNoQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uKSB7XG5cbiAgdmFyIGV4ZWN1dGlvbiA9IHRoaXMuX2N1cnJlbnRFeGVjdXRpb24sXG4gICAgICBhY3Rpb25zID0gZXhlY3V0aW9uLmFjdGlvbnM7XG5cbiAgdmFyIGJhc2VBY3Rpb24gPSBhY3Rpb25zWzBdO1xuXG4gIGlmIChleGVjdXRpb24uYXRvbWljKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIGludm9jYXRpb24gaW4gPGV4ZWN1dGU+IG9yIDxyZXZlcnQ+IHBoYXNlIChhY3Rpb246ICcgKyBhY3Rpb24uY29tbWFuZCArICcpJyk7XG4gIH1cblxuICBpZiAoIWFjdGlvbi5pZCkge1xuICAgIGFjdGlvbi5pZCA9IChiYXNlQWN0aW9uICYmIGJhc2VBY3Rpb24uaWQpIHx8IHRoaXMuX2NyZWF0ZUlkKCk7XG4gIH1cblxuICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbn07XG5cblxuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS5fcG9wQWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBleGVjdXRpb24gPSB0aGlzLl9jdXJyZW50RXhlY3V0aW9uLFxuICAgICAgdHJpZ2dlciA9IGV4ZWN1dGlvbi50cmlnZ2VyLFxuICAgICAgYWN0aW9ucyA9IGV4ZWN1dGlvbi5hY3Rpb25zLFxuICAgICAgZGlydHkgPSBleGVjdXRpb24uZGlydHk7XG5cbiAgYWN0aW9ucy5wb3AoKTtcblxuICBpZiAoIWFjdGlvbnMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnZWxlbWVudHMuY2hhbmdlZCcsIHsgZWxlbWVudHM6IHVuaXF1ZUJ5KCdpZCcsIGRpcnR5LnJldmVyc2UoKSkgfSk7XG5cbiAgICBkaXJ0eS5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5fZmlyZSgnY2hhbmdlZCcsIHsgdHJpZ2dlcjogdHJpZ2dlciB9KTtcblxuICAgIGV4ZWN1dGlvbi50cmlnZ2VyID0gbnVsbDtcbiAgfVxufTtcblxuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9tYXJrRGlydHkgPSBmdW5jdGlvbihlbGVtZW50cykge1xuICB2YXIgZXhlY3V0aW9uID0gdGhpcy5fY3VycmVudEV4ZWN1dGlvbjtcblxuICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudHMgPSBpc0FycmF5KGVsZW1lbnRzKSA/IGVsZW1lbnRzIDogWyBlbGVtZW50cyBdO1xuXG4gIGV4ZWN1dGlvbi5kaXJ0eSA9IGV4ZWN1dGlvbi5kaXJ0eS5jb25jYXQoZWxlbWVudHMpO1xufTtcblxuXG5Db21tYW5kU3RhY2sucHJvdG90eXBlLl9leGVjdXRlZEFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcmVkbykge1xuICB2YXIgc3RhY2tJZHggPSArK3RoaXMuX3N0YWNrSWR4O1xuXG4gIGlmICghcmVkbykge1xuICAgIHRoaXMuX3N0YWNrLnNwbGljZShzdGFja0lkeCwgdGhpcy5fc3RhY2subGVuZ3RoLCBhY3Rpb24pO1xuICB9XG59O1xuXG5cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuX3JldmVydGVkQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gIHRoaXMuX3N0YWNrSWR4LS07XG59O1xuXG5cbkNvbW1hbmRTdGFjay5wcm90b3R5cGUuX2dldEhhbmRsZXIgPSBmdW5jdGlvbihjb21tYW5kKSB7XG4gIHJldHVybiB0aGlzLl9oYW5kbGVyTWFwW2NvbW1hbmRdO1xufTtcblxuQ29tbWFuZFN0YWNrLnByb3RvdHlwZS5fc2V0SGFuZGxlciA9IGZ1bmN0aW9uKGNvbW1hbmQsIGhhbmRsZXIpIHtcbiAgaWYgKCFjb21tYW5kIHx8ICFoYW5kbGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21tYW5kIGFuZCBoYW5kbGVyIHJlcXVpcmVkJyk7XG4gIH1cblxuICBpZiAodGhpcy5faGFuZGxlck1hcFtjb21tYW5kXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignb3ZlcnJpZGluZyBoYW5kbGVyIGZvciBjb21tYW5kIDwnICsgY29tbWFuZCArICc+Jyk7XG4gIH1cblxuICB0aGlzLl9oYW5kbGVyTWFwW2NvbW1hbmRdID0gaGFuZGxlcjtcbn07XG4iLCJpbXBvcnQgQ29tbWFuZFN0YWNrIGZyb20gJy4vQ29tbWFuZFN0YWNrJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21tYW5kU3RhY2s6IFsgJ3R5cGUnLCBDb21tYW5kU3RhY2sgXVxufTtcbiIsImltcG9ydCB7XG4gIGlzTnVtYmVyLFxuICBhc3NpZ24sXG4gIGZvckVhY2gsXG4gIGV2ZXJ5LFxuICBkZWJvdW5jZSxcbiAgYmluZCxcbiAgcmVkdWNlXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgYWRkIGFzIGNvbGxlY3Rpb25BZGQsXG4gIHJlbW92ZSBhcyBjb2xsZWN0aW9uUmVtb3ZlXG59IGZyb20gJy4uL3V0aWwvQ29sbGVjdGlvbnMnO1xuXG5pbXBvcnQge1xuICBnZXRUeXBlXG59IGZyb20gJy4uL3V0aWwvRWxlbWVudHMnO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNsYXNzZXMgYXMgc3ZnQ2xhc3NlcyxcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZSxcbiAgdHJhbnNmb3JtIGFzIHN2Z1RyYW5zZm9ybVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7IGNyZWF0ZU1hdHJpeCBhcyBjcmVhdGVNYXRyaXggfSBmcm9tICd0aW55LXN2Zyc7XG5cblxuZnVuY3Rpb24gcm91bmQobnVtYmVyLCByZXNvbHV0aW9uKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbn1cblxuZnVuY3Rpb24gZW5zdXJlUHgobnVtYmVyKSB7XG4gIHJldHVybiBpc051bWJlcihudW1iZXIpID8gbnVtYmVyICsgJ3B4JyA6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgSFRNTCBjb250YWluZXIgZWxlbWVudCBmb3IgYSBTVkcgZWxlbWVudCB3aXRoXG4gKiB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvblxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IHRoZSBjb250YWluZXIgZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIob3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBhc3NpZ24oe30sIHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfSwgb3B0aW9ucyk7XG5cbiAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgLy8gY3JlYXRlIGEgPGRpdj4gYXJvdW5kIHRoZSBzdmcgZWxlbWVudCB3aXRoIHRoZSByZXNwZWN0aXZlIHNpemVcbiAgLy8gdGhpcyB3YXkgd2UgY2FuIGFsd2F5cyBnZXQgdGhlIGNvcnJlY3QgY29udGFpbmVyIHNpemVcbiAgLy8gKHRoaXMgaXMgaW1wb3NzaWJsZSBmb3IgPHN2Zz4gZWxlbWVudHMgYXQgdGhlIG1vbWVudClcbiAgdmFyIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwYXJlbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsICdkanMtY29udGFpbmVyJyk7XG5cbiAgYXNzaWduKHBhcmVudC5zdHlsZSwge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICB3aWR0aDogZW5zdXJlUHgob3B0aW9ucy53aWR0aCksXG4gICAgaGVpZ2h0OiBlbnN1cmVQeChvcHRpb25zLmhlaWdodClcbiAgfSk7XG5cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBhcmVudCk7XG5cbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlR3JvdXAocGFyZW50LCBjbHMsIGNoaWxkSW5kZXgpIHtcbiAgdmFyIGdyb3VwID0gc3ZnQ3JlYXRlKCdnJyk7XG4gIHN2Z0NsYXNzZXMoZ3JvdXApLmFkZChjbHMpO1xuXG4gIHZhciBpbmRleCA9IGNoaWxkSW5kZXggIT09IHVuZGVmaW5lZCA/IGNoaWxkSW5kZXggOiBwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGggLSAxO1xuXG4gIC8vIG11c3QgZW5zdXJlIHNlY29uZCBhcmd1bWVudCBpcyBub2RlIG9yIF9udWxsX1xuICAvLyBjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvaW5zZXJ0QmVmb3JlXG4gIHBhcmVudC5pbnNlcnRCZWZvcmUoZ3JvdXAsIHBhcmVudC5jaGlsZE5vZGVzW2luZGV4XSB8fCBudWxsKTtcblxuICByZXR1cm4gZ3JvdXA7XG59XG5cbnZhciBCQVNFX0xBWUVSID0gJ2Jhc2UnO1xuXG5cbnZhciBSRVFVSVJFRF9NT0RFTF9BVFRSUyA9IHtcbiAgc2hhcGU6IFsgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnIF0sXG4gIGNvbm5lY3Rpb246IFsgJ3dheXBvaW50cycgXVxufTtcblxuLyoqXG4gKiBUaGUgbWFpbiBkcmF3aW5nIGNhbnZhcy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBlbWl0cyBDYW52YXMjY2FudmFzLmluaXRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtHcmFwaGljc0ZhY3Rvcnl9IGdyYXBoaWNzRmFjdG9yeVxuICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnl9IGVsZW1lbnRSZWdpc3RyeVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDYW52YXMoY29uZmlnLCBldmVudEJ1cywgZ3JhcGhpY3NGYWN0b3J5LCBlbGVtZW50UmVnaXN0cnkpIHtcblxuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICB0aGlzLl9lbGVtZW50UmVnaXN0cnkgPSBlbGVtZW50UmVnaXN0cnk7XG4gIHRoaXMuX2dyYXBoaWNzRmFjdG9yeSA9IGdyYXBoaWNzRmFjdG9yeTtcblxuICB0aGlzLl9pbml0KGNvbmZpZyB8fCB7fSk7XG59XG5cbkNhbnZhcy4kaW5qZWN0ID0gW1xuICAnY29uZmlnLmNhbnZhcycsXG4gICdldmVudEJ1cycsXG4gICdncmFwaGljc0ZhY3RvcnknLFxuICAnZWxlbWVudFJlZ2lzdHJ5J1xuXTtcblxuXG5DYW52YXMucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oY29uZmlnKSB7XG5cbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgLy8gQ3JlYXRlcyBhIDxzdmc+IGVsZW1lbnQgdGhhdCBpcyB3cmFwcGVkIGludG8gYSA8ZGl2Pi5cbiAgLy8gVGhpcyB3YXkgd2UgYXJlIGFsd2F5cyBhYmxlIHRvIGNvcnJlY3RseSBmaWd1cmUgb3V0IHRoZSBzaXplIG9mIHRoZSBzdmcgZWxlbWVudFxuICAvLyBieSBxdWVyeWluZyB0aGUgcGFyZW50IG5vZGUuXG4gIC8vXG4gIC8vIChJdCBpcyBub3QgcG9zc2libGUgdG8gZ2V0IHRoZSBzaXplIG9mIGEgc3ZnIGVsZW1lbnQgY3Jvc3MgYnJvd3NlciBAIDIwMTQtMDQtMDEpXG4gIC8vXG4gIC8vIDxkaXYgY2xhc3M9XCJkanMtY29udGFpbmVyXCIgc3R5bGU9XCJ3aWR0aDoge2Rlc2lyZWQtd2lkdGh9LCBoZWlnaHQ6IHtkZXNpcmVkLWhlaWdodH1cIj5cbiAgLy8gICA8c3ZnIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIj5cbiAgLy8gICAgLi4uXG4gIC8vICAgPC9zdmc+XG4gIC8vIDwvZGl2PlxuXG4gIC8vIGh0bWwgY29udGFpbmVyXG4gIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGVDb250YWluZXIoY29uZmlnKTtcblxuICB2YXIgc3ZnID0gdGhpcy5fc3ZnID0gc3ZnQ3JlYXRlKCdzdmcnKTtcbiAgc3ZnQXR0cihzdmcsIHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfSk7XG5cbiAgc3ZnQXBwZW5kKGNvbnRhaW5lciwgc3ZnKTtcblxuICB2YXIgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydCA9IGNyZWF0ZUdyb3VwKHN2ZywgJ3ZpZXdwb3J0Jyk7XG5cbiAgdGhpcy5fbGF5ZXJzID0ge307XG5cbiAgLy8gZGVib3VuY2UgY2FudmFzLnZpZXdib3guY2hhbmdlZCBldmVudHNcbiAgLy8gZm9yIHNtb290aGVyIGRpYWdyYW0gaW50ZXJhY3Rpb25cbiAgaWYgKGNvbmZpZy5kZWZlclVwZGF0ZSAhPT0gZmFsc2UpIHtcbiAgICB0aGlzLl92aWV3Ym94Q2hhbmdlZCA9IGRlYm91bmNlKGJpbmQodGhpcy5fdmlld2JveENoYW5nZWQsIHRoaXMpLCAzMDApO1xuICB9XG5cbiAgZXZlbnRCdXMub24oJ2RpYWdyYW0uaW5pdCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IHRoZSBjYW52YXMgaXMgcmVhZHkgdG8gYmUgZHJhd24gb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgQ2FudmFzXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2FudmFzLmluaXRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBzdmcgdGhlIGNyZWF0ZWQgc3ZnIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IHZpZXdwb3J0IHRoZSBkaXJlY3QgcGFyZW50IG9mIGRpYWdyYW0gZWxlbWVudHMgYW5kIHNoYXBlc1xuICAgICAqL1xuICAgIGV2ZW50QnVzLmZpcmUoJ2NhbnZhcy5pbml0Jywge1xuICAgICAgc3ZnOiBzdmcsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgICB9KTtcblxuICB9LCB0aGlzKTtcblxuICAvLyByZXNldCB2aWV3Ym94IG9uIHNoYXBlIGNoYW5nZXMgdG9cbiAgLy8gcmVjb21wdXRlIHRoZSB2aWV3Ym94XG4gIGV2ZW50QnVzLm9uKFtcbiAgICAnc2hhcGUuYWRkZWQnLFxuICAgICdjb25uZWN0aW9uLmFkZGVkJyxcbiAgICAnc2hhcGUucmVtb3ZlZCcsXG4gICAgJ2Nvbm5lY3Rpb24ucmVtb3ZlZCcsXG4gICAgJ2VsZW1lbnRzLmNoYW5nZWQnXG4gIF0sIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWNoZWRWaWV3Ym94O1xuICB9LCB0aGlzKTtcblxuICBldmVudEJ1cy5vbignZGlhZ3JhbS5kZXN0cm95JywgNTAwLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcbiAgZXZlbnRCdXMub24oJ2RpYWdyYW0uY2xlYXInLCA1MDAsIHRoaXMuX2NsZWFyLCB0aGlzKTtcbn07XG5cbkNhbnZhcy5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlbWl0KSB7XG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NhbnZhcy5kZXN0cm95Jywge1xuICAgIHN2ZzogdGhpcy5fc3ZnLFxuICAgIHZpZXdwb3J0OiB0aGlzLl92aWV3cG9ydFxuICB9KTtcblxuICB2YXIgcGFyZW50ID0gdGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGU7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuX3N2ZztcbiAgZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcbiAgZGVsZXRlIHRoaXMuX2xheWVycztcbiAgZGVsZXRlIHRoaXMuX3Jvb3RFbGVtZW50O1xuICBkZWxldGUgdGhpcy5fdmlld3BvcnQ7XG59O1xuXG5DYW52YXMucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgYWxsRWxlbWVudHMgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0QWxsKCk7XG5cbiAgLy8gcmVtb3ZlIGFsbCBlbGVtZW50c1xuICBhbGxFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB2YXIgdHlwZSA9IGdldFR5cGUoZWxlbWVudCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICBzZWxmLnNldFJvb3RFbGVtZW50KG51bGwsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9yZW1vdmVFbGVtZW50KGVsZW1lbnQsIHR5cGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZm9yY2UgcmVjb21wdXRhdGlvbiBvZiB2aWV3IGJveFxuICBkZWxldGUgdGhpcy5fY2FjaGVkVmlld2JveDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBsYXllciBvbiB3aGljaFxuICogYWxsIGVsZW1lbnRzIGFyZSBkcmF3bi5cbiAqXG4gKiBAcmV0dXJucyB7U1ZHRWxlbWVudH1cbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5nZXREZWZhdWx0TGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIoQkFTRV9MQVlFUiwgMCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBsYXllciB0aGF0IGlzIHVzZWQgdG8gZHJhdyBlbGVtZW50c1xuICogb3IgYW5ub3RhdGlvbnMgb24gaXQuXG4gKlxuICogTm9uLWV4aXN0aW5nIGxheWVycyByZXRyaWV2ZWQgdGhyb3VnaCB0aGlzIG1ldGhvZFxuICogd2lsbCBiZSBjcmVhdGVkLiBEdXJpbmcgY3JlYXRpb24sIHRoZSBvcHRpb25hbCBpbmRleFxuICogbWF5IGJlIHVzZWQgdG8gY3JlYXRlIGxheWVycyBiZWxvdyBvciBhYm92ZSBleGlzdGluZyBsYXllcnMuXG4gKiBBIGxheWVyIHdpdGggYSBjZXJ0YWluIGluZGV4IGlzIGFsd2F5cyBjcmVhdGVkIGFib3ZlIGFsbFxuICogZXhpc3RpbmcgbGF5ZXJzIHdpdGggdGhlIHNhbWUgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICpcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fVxuICovXG5DYW52YXMucHJvdG90eXBlLmdldExheWVyID0gZnVuY3Rpb24obmFtZSwgaW5kZXgpIHtcblxuICBpZiAoIW5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmeSBhIG5hbWUnKTtcbiAgfVxuXG4gIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tuYW1lXTtcblxuICBpZiAoIWxheWVyKSB7XG4gICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbbmFtZV0gPSB0aGlzLl9jcmVhdGVMYXllcihuYW1lLCBpbmRleCk7XG4gIH1cblxuICAvLyB0aHJvdyBhbiBlcnJvciBpZiBsYXllciBjcmVhdGlvbiAvIHJldHJpdmFsIGlzXG4gIC8vIHJlcXVlc3RlZCBvbiBkaWZmZXJlbnQgaW5kZXhcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgbGF5ZXIuaW5kZXggIT09IGluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXllciA8JyArIG5hbWUgKyAnPiBhbHJlYWR5IGNyZWF0ZWQgYXQgaW5kZXggPCcgKyBpbmRleCArICc+Jyk7XG4gIH1cblxuICByZXR1cm4gbGF5ZXIuZ3JvdXA7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBnaXZlbiBsYXllciBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gbGF5ZXIgZGVzY3JpcHRvciB3aXRoIHsgaW5kZXgsIGdyb3VwOiBTVkdHcm91cCB9XG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuX2NyZWF0ZUxheWVyID0gZnVuY3Rpb24obmFtZSwgaW5kZXgpIHtcblxuICBpZiAoIWluZGV4KSB7XG4gICAgaW5kZXggPSAwO1xuICB9XG5cbiAgdmFyIGNoaWxkSW5kZXggPSByZWR1Y2UodGhpcy5fbGF5ZXJzLCBmdW5jdGlvbihjaGlsZEluZGV4LCBsYXllcikge1xuICAgIGlmIChpbmRleCA+PSBsYXllci5pbmRleCkge1xuICAgICAgY2hpbGRJbmRleCsrO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZEluZGV4O1xuICB9LCAwKTtcblxuICByZXR1cm4ge1xuICAgIGdyb3VwOiBjcmVhdGVHcm91cCh0aGlzLl92aWV3cG9ydCwgJ2xheWVyLScgKyBuYW1lLCBjaGlsZEluZGV4KSxcbiAgICBpbmRleDogaW5kZXhcbiAgfTtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBodG1sIGVsZW1lbnQgdGhhdCBlbmNsb3NlcyB0aGVcbiAqIGRyYXdpbmcgY2FudmFzLlxuICpcbiAqIEByZXR1cm4ge0RPTU5vZGV9XG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jb250YWluZXI7XG59O1xuXG5cbi8vIG1hcmtlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5DYW52YXMucHJvdG90eXBlLl91cGRhdGVNYXJrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBtYXJrZXIsIGFkZCkge1xuICB2YXIgY29udGFpbmVyO1xuXG4gIGlmICghZWxlbWVudC5pZCkge1xuICAgIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0KGVsZW1lbnQpO1xuICB9XG5cbiAgLy8gd2UgbmVlZCB0byBhY2Nlc3MgYWxsXG4gIGNvbnRhaW5lciA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5fZWxlbWVudHNbZWxlbWVudC5pZF07XG5cbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3JFYWNoKFsgY29udGFpbmVyLmdmeCwgY29udGFpbmVyLnNlY29uZGFyeUdmeCBdLCBmdW5jdGlvbihnZngpIHtcbiAgICBpZiAoZ2Z4KSB7XG5cbiAgICAgIC8vIGludm9rZSBlaXRoZXIgYWRkQ2xhc3Mgb3IgcmVtb3ZlQ2xhc3MgYmFzZWQgb24gbW9kZVxuICAgICAgaWYgKGFkZCkge1xuICAgICAgICBzdmdDbGFzc2VzKGdmeCkuYWRkKG1hcmtlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdmdDbGFzc2VzKGdmeCkucmVtb3ZlKG1hcmtlcik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IGEgbWFya2VyIGhhcyBiZWVuIHVwZGF0ZWQgZm9yIGFuIGVsZW1lbnRcbiAgICpcbiAgICogQGV2ZW50IGVsZW1lbnQubWFya2VyLnVwZGF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge2Rqcy5tb2RlbC5FbGVtZW50fSBlbGVtZW50IHRoZSBzaGFwZVxuICAgKiBAcHJvcGVydHkge09iamVjdH0gZ2Z4IHRoZSBncmFwaGljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNoYXBlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYXJrZXJcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBhZGQgdHJ1ZSBpZiB0aGUgbWFya2VyIHdhcyBhZGRlZCwgZmFsc2UgaWYgaXQgZ290IHJlbW92ZWRcbiAgICovXG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2VsZW1lbnQubWFya2VyLnVwZGF0ZScsIHsgZWxlbWVudDogZWxlbWVudCwgZ2Z4OiBjb250YWluZXIuZ2Z4LCBtYXJrZXI6IG1hcmtlciwgYWRkOiAhIWFkZCB9KTtcbn07XG5cblxuLyoqXG4gKiBBZGRzIGEgbWFya2VyIHRvIGFuIGVsZW1lbnQgKGJhc2ljYWxseSBhIGNzcyBjbGFzcykuXG4gKlxuICogRmlyZXMgdGhlIGVsZW1lbnQubWFya2VyLnVwZGF0ZSBldmVudCwgbWFraW5nIGl0IHBvc3NpYmxlIHRvXG4gKiBpbnRlZ3JhdGUgZXh0ZW5zaW9uIGludG8gdGhlIG1hcmtlciBsaWZlLWN5Y2xlLCB0b28uXG4gKlxuICogQGV4YW1wbGVcbiAqIGNhbnZhcy5hZGRNYXJrZXIoJ2ZvbycsICdzb21lLW1hcmtlcicpO1xuICpcbiAqIHZhciBmb29HZnggPSBjYW52YXMuZ2V0R3JhcGhpY3MoJ2ZvbycpO1xuICpcbiAqIGZvb0dmeDsgLy8gPGcgY2xhc3M9XCIuLi4gc29tZS1tYXJrZXJcIj4gLi4uIDwvZz5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmtlclxuICovXG5DYW52YXMucHJvdG90eXBlLmFkZE1hcmtlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG1hcmtlcikge1xuICB0aGlzLl91cGRhdGVNYXJrZXIoZWxlbWVudCwgbWFya2VyLCB0cnVlKTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYSBtYXJrZXIgZnJvbSBhbiBlbGVtZW50LlxuICpcbiAqIEZpcmVzIHRoZSBlbGVtZW50Lm1hcmtlci51cGRhdGUgZXZlbnQsIG1ha2luZyBpdCBwb3NzaWJsZSB0b1xuICogaW50ZWdyYXRlIGV4dGVuc2lvbiBpbnRvIHRoZSBtYXJrZXIgbGlmZS1jeWNsZSwgdG9vLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ3xkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHBhcmFtICB7c3RyaW5nfSBtYXJrZXJcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5yZW1vdmVNYXJrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBtYXJrZXIpIHtcbiAgdGhpcy5fdXBkYXRlTWFya2VyKGVsZW1lbnQsIG1hcmtlciwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBDaGVjayB0aGUgZXhpc3RlbmNlIG9mIGEgbWFya2VyIG9uIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfGRqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1hcmtlclxuICovXG5DYW52YXMucHJvdG90eXBlLmhhc01hcmtlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG1hcmtlcikge1xuICBpZiAoIWVsZW1lbnQuaWQpIHtcbiAgICBlbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBnZnggPSB0aGlzLmdldEdyYXBoaWNzKGVsZW1lbnQpO1xuXG4gIHJldHVybiBzdmdDbGFzc2VzKGdmeCkuaGFzKG1hcmtlcik7XG59O1xuXG4vKipcbiAqIFRvZ2dsZXMgYSBtYXJrZXIgb24gYW4gZWxlbWVudC5cbiAqXG4gKiBGaXJlcyB0aGUgZWxlbWVudC5tYXJrZXIudXBkYXRlIGV2ZW50LCBtYWtpbmcgaXQgcG9zc2libGUgdG9cbiAqIGludGVncmF0ZSBleHRlbnNpb24gaW50byB0aGUgbWFya2VyIGxpZmUtY3ljbGUsIHRvby5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd8ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gbWFya2VyXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUudG9nZ2xlTWFya2VyID0gZnVuY3Rpb24oZWxlbWVudCwgbWFya2VyKSB7XG4gIGlmICh0aGlzLmhhc01hcmtlcihlbGVtZW50LCBtYXJrZXIpKSB7XG4gICAgdGhpcy5yZW1vdmVNYXJrZXIoZWxlbWVudCwgbWFya2VyKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFkZE1hcmtlcihlbGVtZW50LCBtYXJrZXIpO1xuICB9XG59O1xuXG5DYW52YXMucHJvdG90eXBlLmdldFJvb3RFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICB0aGlzLnNldFJvb3RFbGVtZW50KHsgaWQ6ICdfX2ltcGxpY2l0cm9vdCcsIGNoaWxkcmVuOiBbXSB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbn07XG5cblxuXG4vLyByb290IGVsZW1lbnQgaGFuZGxpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFNldHMgYSBnaXZlbiBlbGVtZW50IGFzIHRoZSBuZXcgcm9vdCBlbGVtZW50IGZvciB0aGUgY2FudmFzXG4gKiBhbmQgcmV0dXJucyB0aGUgbmV3IHJvb3QgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxkanMubW9kZWwuUm9vdH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBbb3ZlcnJpZGVdIHdoZXRoZXIgdG8gb3ZlcnJpZGUgdGhlIGN1cnJlbnQgcm9vdCBlbGVtZW50LCBpZiBhbnlcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R8ZGpzLm1vZGVsLlJvb3R9IG5ldyByb290IGVsZW1lbnRcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5zZXRSb290RWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG92ZXJyaWRlKSB7XG5cbiAgaWYgKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9lbnN1cmVWYWxpZCgncm9vdCcsIGVsZW1lbnQpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSb290ID0gdGhpcy5fcm9vdEVsZW1lbnQsXG4gICAgICBlbGVtZW50UmVnaXN0cnkgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnksXG4gICAgICBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIGlmIChjdXJyZW50Um9vdCkge1xuICAgIGlmICghb3ZlcnJpZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncm9vdEVsZW1lbnQgYWxyZWFkeSBzZXQsIG5lZWQgdG8gc3BlY2lmeSBvdmVycmlkZScpO1xuICAgIH1cblxuICAgIC8vIHNpbXVsYXRlIGVsZW1lbnQgcmVtb3ZlIGV2ZW50IHNlcXVlbmNlXG4gICAgZXZlbnRCdXMuZmlyZSgncm9vdC5yZW1vdmUnLCB7IGVsZW1lbnQ6IGN1cnJlbnRSb290IH0pO1xuICAgIGV2ZW50QnVzLmZpcmUoJ3Jvb3QucmVtb3ZlZCcsIHsgZWxlbWVudDogY3VycmVudFJvb3QgfSk7XG5cbiAgICBlbGVtZW50UmVnaXN0cnkucmVtb3ZlKGN1cnJlbnRSb290KTtcbiAgfVxuXG4gIGlmIChlbGVtZW50KSB7XG4gICAgdmFyIGdmeCA9IHRoaXMuZ2V0RGVmYXVsdExheWVyKCk7XG5cbiAgICAvLyByZXNlbWJsZSBlbGVtZW50IGFkZCBldmVudCBzZXF1ZW5jZVxuICAgIGV2ZW50QnVzLmZpcmUoJ3Jvb3QuYWRkJywgeyBlbGVtZW50OiBlbGVtZW50IH0pO1xuXG4gICAgZWxlbWVudFJlZ2lzdHJ5LmFkZChlbGVtZW50LCBnZngsIHRoaXMuX3N2Zyk7XG5cbiAgICBldmVudEJ1cy5maXJlKCdyb290LmFkZGVkJywgeyBlbGVtZW50OiBlbGVtZW50LCBnZng6IGdmeCB9KTtcbiAgfVxuXG4gIHRoaXMuX3Jvb3RFbGVtZW50ID0gZWxlbWVudDtcblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cblxuXG4vLyBhZGQgZnVuY3Rpb25hbGl0eSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbkNhbnZhcy5wcm90b3R5cGUuX2Vuc3VyZVZhbGlkID0gZnVuY3Rpb24odHlwZSwgZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQuaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgbXVzdCBoYXZlIGFuIGlkJyk7XG4gIH1cblxuICBpZiAodGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChlbGVtZW50LmlkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCB3aXRoIGlkICcgKyBlbGVtZW50LmlkICsgJyBhbHJlYWR5IGV4aXN0cycpO1xuICB9XG5cbiAgdmFyIHJlcXVpcmVkQXR0cnMgPSBSRVFVSVJFRF9NT0RFTF9BVFRSU1t0eXBlXTtcblxuICB2YXIgdmFsaWQgPSBldmVyeShyZXF1aXJlZEF0dHJzLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50W2F0dHJdICE9PSAndW5kZWZpbmVkJztcbiAgfSk7XG5cbiAgaWYgKCF2YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdtdXN0IHN1cHBseSB7ICcgKyByZXF1aXJlZEF0dHJzLmpvaW4oJywgJykgKyAnIH0gd2l0aCAnICsgdHlwZSk7XG4gIH1cbn07XG5cbkNhbnZhcy5wcm90b3R5cGUuX3NldFBhcmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHBhcmVudCwgcGFyZW50SW5kZXgpIHtcbiAgY29sbGVjdGlvbkFkZChwYXJlbnQuY2hpbGRyZW4sIGVsZW1lbnQsIHBhcmVudEluZGV4KTtcbiAgZWxlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgY2FudmFzLlxuICpcbiAqIFRoaXMgd2lyZXMgdGhlIHBhcmVudCA8LT4gY2hpbGQgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlIGVsZW1lbnQgYW5kXG4gKiBhIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHBhcmVudCBvciBhbiBpbXBsaWNpdCByb290IGVsZW1lbnQuXG4gKlxuICogRHVyaW5nIGFkZCBpdCBlbWl0cyB0aGUgZXZlbnRzXG4gKlxuICogICogPHt0eXBlfS5hZGQ+IChlbGVtZW50LCBwYXJlbnQpXG4gKiAgKiA8e3R5cGV9LmFkZGVkPiAoZWxlbWVudCwgZ2Z4KVxuICpcbiAqIEV4dGVuc2lvbnMgbWF5IGhvb2sgaW50byB0aGVzZSBldmVudHMgdG8gcGVyZm9ybSB0aGVpciBtYWdpYy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtPYmplY3R8ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fGRqcy5tb2RlbC5CYXNlfSBbcGFyZW50XVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJlbnRJbmRleF1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R8ZGpzLm1vZGVsLkJhc2V9IHRoZSBhZGRlZCBlbGVtZW50XG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuX2FkZEVsZW1lbnQgPSBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBwYXJlbnQsIHBhcmVudEluZGV4KSB7XG5cbiAgcGFyZW50ID0gcGFyZW50IHx8IHRoaXMuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICB2YXIgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cyxcbiAgICAgIGdyYXBoaWNzRmFjdG9yeSA9IHRoaXMuX2dyYXBoaWNzRmFjdG9yeTtcblxuICB0aGlzLl9lbnN1cmVWYWxpZCh0eXBlLCBlbGVtZW50KTtcblxuICBldmVudEJ1cy5maXJlKHR5cGUgKyAnLmFkZCcsIHsgZWxlbWVudDogZWxlbWVudCwgcGFyZW50OiBwYXJlbnQgfSk7XG5cbiAgdGhpcy5fc2V0UGFyZW50KGVsZW1lbnQsIHBhcmVudCwgcGFyZW50SW5kZXgpO1xuXG4gIC8vIGNyZWF0ZSBncmFwaGljc1xuICB2YXIgZ2Z4ID0gZ3JhcGhpY3NGYWN0b3J5LmNyZWF0ZSh0eXBlLCBlbGVtZW50LCBwYXJlbnRJbmRleCk7XG5cbiAgdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmFkZChlbGVtZW50LCBnZngpO1xuXG4gIC8vIHVwZGF0ZSBpdHMgdmlzdWFsXG4gIGdyYXBoaWNzRmFjdG9yeS51cGRhdGUodHlwZSwgZWxlbWVudCwgZ2Z4KTtcblxuICBldmVudEJ1cy5maXJlKHR5cGUgKyAnLmFkZGVkJywgeyBlbGVtZW50OiBlbGVtZW50LCBnZng6IGdmeCB9KTtcblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQWRkcyBhIHNoYXBlIHRvIHRoZSBjYW52YXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxkanMubW9kZWwuU2hhcGV9IHNoYXBlIHRvIGFkZCB0byB0aGUgZGlhZ3JhbVxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gW3BhcmVudF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyZW50SW5kZXhdXG4gKlxuICogQHJldHVybiB7ZGpzLm1vZGVsLlNoYXBlfSB0aGUgYWRkZWQgc2hhcGVcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLCBwYXJlbnQsIHBhcmVudEluZGV4KSB7XG4gIHJldHVybiB0aGlzLl9hZGRFbGVtZW50KCdzaGFwZScsIHNoYXBlLCBwYXJlbnQsIHBhcmVudEluZGV4KTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGNvbm5lY3Rpb24gdG8gdGhlIGNhbnZhc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fGRqcy5tb2RlbC5Db25uZWN0aW9ufSBjb25uZWN0aW9uIHRvIGFkZCB0byB0aGUgZGlhZ3JhbVxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gW3BhcmVudF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyZW50SW5kZXhdXG4gKlxuICogQHJldHVybiB7ZGpzLm1vZGVsLkNvbm5lY3Rpb259IHRoZSBhZGRlZCBjb25uZWN0aW9uXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuYWRkQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIHBhcmVudCwgcGFyZW50SW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuX2FkZEVsZW1lbnQoJ2Nvbm5lY3Rpb24nLCBjb25uZWN0aW9uLCBwYXJlbnQsIHBhcmVudEluZGV4KTtcbn07XG5cblxuLyoqXG4gKiBJbnRlcm5hbCByZW1vdmUgZWxlbWVudFxuICovXG5DYW52YXMucHJvdG90eXBlLl9yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSkge1xuXG4gIHZhciBlbGVtZW50UmVnaXN0cnkgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnksXG4gICAgICBncmFwaGljc0ZhY3RvcnkgPSB0aGlzLl9ncmFwaGljc0ZhY3RvcnksXG4gICAgICBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIGVsZW1lbnQgPSBlbGVtZW50UmVnaXN0cnkuZ2V0KGVsZW1lbnQuaWQgfHwgZWxlbWVudCk7XG5cbiAgaWYgKCFlbGVtZW50KSB7XG5cbiAgICAvLyBlbGVtZW50IHdhcyByZW1vdmVkIGFscmVhZHlcbiAgICByZXR1cm47XG4gIH1cblxuICBldmVudEJ1cy5maXJlKHR5cGUgKyAnLnJlbW92ZScsIHsgZWxlbWVudDogZWxlbWVudCB9KTtcblxuICBncmFwaGljc0ZhY3RvcnkucmVtb3ZlKGVsZW1lbnQpO1xuXG4gIC8vIHVuc2V0IHBhcmVudCA8LT4gY2hpbGQgcmVsYXRpb25zaGlwXG4gIGNvbGxlY3Rpb25SZW1vdmUoZWxlbWVudC5wYXJlbnQgJiYgZWxlbWVudC5wYXJlbnQuY2hpbGRyZW4sIGVsZW1lbnQpO1xuICBlbGVtZW50LnBhcmVudCA9IG51bGw7XG5cbiAgZXZlbnRCdXMuZmlyZSh0eXBlICsgJy5yZW1vdmVkJywgeyBlbGVtZW50OiBlbGVtZW50IH0pO1xuXG4gIGVsZW1lbnRSZWdpc3RyeS5yZW1vdmUoZWxlbWVudCk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhIHNoYXBlIGZyb20gdGhlIGNhbnZhc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGRqcy5tb2RlbC5TaGFwZX0gc2hhcGUgb3Igc2hhcGUgaWQgdG8gYmUgcmVtb3ZlZFxuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5TaGFwZX0gdGhlIHJlbW92ZWQgc2hhcGVcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5yZW1vdmVTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlKSB7XG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhIHNoYXBlIGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgY2FudmFzLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgQ2FudmFzXG4gICAqXG4gICAqIEBldmVudCBzaGFwZS5yZW1vdmVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtkanMubW9kZWwuU2hhcGV9IGVsZW1lbnQgdGhlIHNoYXBlIGRlc2NyaXB0b3JcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGdmeCB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzaGFwZVxuICAgKi9cblxuICAvKipcbiAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IGEgc2hhcGUgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBDYW52YXNcbiAgICpcbiAgICogQGV2ZW50IHNoYXBlLnJlbW92ZWRcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtkanMubW9kZWwuU2hhcGV9IGVsZW1lbnQgdGhlIHNoYXBlIGRlc2NyaXB0b3JcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGdmeCB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzaGFwZVxuICAgKi9cbiAgcmV0dXJuIHRoaXMuX3JlbW92ZUVsZW1lbnQoc2hhcGUsICdzaGFwZScpO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYSBjb25uZWN0aW9uIGZyb20gdGhlIGNhbnZhc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGRqcy5tb2RlbC5Db25uZWN0aW9ufSBjb25uZWN0aW9uIG9yIGNvbm5lY3Rpb24gaWQgdG8gYmUgcmVtb3ZlZFxuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5Db25uZWN0aW9ufSB0aGUgcmVtb3ZlZCBjb25uZWN0aW9uXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUucmVtb3ZlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcblxuICAvKipcbiAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IGEgY29ubmVjdGlvbiBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gdGhlIGNhbnZhcy5cbiAgICpcbiAgICogQG1lbWJlck9mIENhbnZhc1xuICAgKlxuICAgKiBAZXZlbnQgY29ubmVjdGlvbi5yZW1vdmVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtkanMubW9kZWwuQ29ubmVjdGlvbn0gZWxlbWVudCB0aGUgY29ubmVjdGlvbiBkZXNjcmlwdG9yXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBnZnggdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29ubmVjdGlvblxuICAgKi9cblxuICAvKipcbiAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IGEgY29ubmVjdGlvbiBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGNhbnZhcy5cbiAgICpcbiAgICogQG1lbWJlck9mIENhbnZhc1xuICAgKlxuICAgKiBAZXZlbnQgY29ubmVjdGlvbi5yZW1vdmVkXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLkNvbm5lY3Rpb259IGVsZW1lbnQgdGhlIGNvbm5lY3Rpb24gZGVzY3JpcHRvclxuICAgKiBAcHJvcGVydHkge09iamVjdH0gZ2Z4IHRoZSBncmFwaGljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbm5lY3Rpb25cbiAgICovXG4gIHJldHVybiB0aGlzLl9yZW1vdmVFbGVtZW50KGNvbm5lY3Rpb24sICdjb25uZWN0aW9uJyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBncmFwaGljYWwgb2JqZWN0IHVuZGVybGF5aW5nIGEgY2VydGFpbiBkaWFncmFtIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xkanMubW9kZWwuQmFzZX0gZWxlbWVudCBkZXNjcmlwdG9yIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWNvbmRhcnk9ZmFsc2VdIHdoZXRoZXIgdG8gcmV0dXJuIHRoZSBzZWNvbmRhcnkgY29ubmVjdGVkIGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICovXG5DYW52YXMucHJvdG90eXBlLmdldEdyYXBoaWNzID0gZnVuY3Rpb24oZWxlbWVudCwgc2Vjb25kYXJ5KSB7XG4gIHJldHVybiB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCwgc2Vjb25kYXJ5KTtcbn07XG5cblxuLyoqXG4gKiBQZXJmb3JtIGEgdmlld2JveCB1cGRhdGUgdmlhIGEgZ2l2ZW4gY2hhbmdlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYW5nZUZuXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuX2NoYW5nZVZpZXdib3ggPSBmdW5jdGlvbihjaGFuZ2VGbikge1xuXG4gIC8vIG5vdGlmeSBvdGhlcnMgb2YgdGhlIHVwY29taW5nIHZpZXdib3ggY2hhbmdlXG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NhbnZhcy52aWV3Ym94LmNoYW5naW5nJyk7XG5cbiAgLy8gcGVyZm9ybSBhY3R1YWwgY2hhbmdlXG4gIGNoYW5nZUZuLmFwcGx5KHRoaXMpO1xuXG4gIC8vIHJlc2V0IHRoZSBjYWNoZWQgdmlld2JveCBzbyB0aGF0XG4gIC8vIGEgbmV3IGdldCBvcGVyYXRpb24gb24gdmlld2JveCBvciB6b29tXG4gIC8vIHRyaWdnZXJzIGEgdmlld2JveCByZS1jb21wdXRhdGlvblxuICB0aGlzLl9jYWNoZWRWaWV3Ym94ID0gbnVsbDtcblxuICAvLyBub3RpZnkgb3RoZXJzIG9mIHRoZSBjaGFuZ2U7IHRoaXMgc3RlcFxuICAvLyBtYXkgb3IgbWF5IG5vdCBiZSBkZWJvdW5jZWRcbiAgdGhpcy5fdmlld2JveENoYW5nZWQoKTtcbn07XG5cbkNhbnZhcy5wcm90b3R5cGUuX3ZpZXdib3hDaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NhbnZhcy52aWV3Ym94LmNoYW5nZWQnLCB7IHZpZXdib3g6IHRoaXMudmlld2JveCgpIH0pO1xufTtcblxuXG4vKipcbiAqIEdldHMgb3Igc2V0cyB0aGUgdmlldyBib3ggb2YgdGhlIGNhbnZhcywgaS5lLiB0aGVcbiAqIGFyZWEgdGhhdCBpcyBjdXJyZW50bHkgZGlzcGxheWVkLlxuICpcbiAqIFRoZSBnZXR0ZXIgbWF5IHJldHVybiBhIGNhY2hlZCB2aWV3Ym94IChpZiBpdCBpcyBjdXJyZW50bHlcbiAqIGNoYW5naW5nKS4gVG8gZm9yY2UgYSByZWNvbXB1dGF0aW9uLCBwYXNzIGBmYWxzZWAgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogY2FudmFzLnZpZXdib3goeyB4OiAxMDAsIHk6IDEwMCwgd2lkdGg6IDUwMCwgaGVpZ2h0OiA1MDAgfSlcbiAqXG4gKiAvLyBzZXRzIHRoZSB2aXNpYmxlIGFyZWEgb2YgdGhlIGRpYWdyYW0gdG8gKDEwMHwxMDApIC0+ICg2MDB8MTAwKVxuICogLy8gYW5kIGFuZCBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIHRoZSBkaWFncmFtIHdpZHRoXG4gKlxuICogdmFyIHZpZXdib3ggPSBjYW52YXMudmlld2JveCgpOyAvLyBwYXNzIGBmYWxzZWAgdG8gZm9yY2UgcmVjb21wdXRpbmcgdGhlIGJveC5cbiAqXG4gKiBjb25zb2xlLmxvZyh2aWV3Ym94KTtcbiAqIC8vIHtcbiAqIC8vICAgaW5uZXI6IERpbWVuc2lvbnMsXG4gKiAvLyAgIG91dGVyOiBEaW1lbnNpb25zLFxuICogLy8gICBzY2FsZSxcbiAqIC8vICAgeCwgeSxcbiAqIC8vICAgd2lkdGgsIGhlaWdodFxuICogLy8gfVxuICpcbiAqIC8vIGlmIHRoZSBjdXJyZW50IGRpYWdyYW0gaXMgem9vbWVkIGFuZCBzY3JvbGxlZCwgeW91IG1heSByZXNldCBpdCB0byB0aGVcbiAqIC8vIGRlZmF1bHQgem9vbSB2aWEgdGhpcyBtZXRob2QsIHRvbzpcbiAqXG4gKiB2YXIgem9vbWVkQW5kU2Nyb2xsZWRWaWV3Ym94ID0gY2FudmFzLnZpZXdib3goKTtcbiAqXG4gKiBjYW52YXMudmlld2JveCh7XG4gKiAgIHg6IDAsXG4gKiAgIHk6IDAsXG4gKiAgIHdpZHRoOiB6b29tZWRBbmRTY3JvbGxlZFZpZXdib3gub3V0ZXIud2lkdGgsXG4gKiAgIGhlaWdodDogem9vbWVkQW5kU2Nyb2xsZWRWaWV3Ym94Lm91dGVyLmhlaWdodFxuICogfSk7XG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBbYm94XSB0aGUgbmV3IHZpZXcgYm94IHRvIHNldFxuICogQHBhcmFtICB7bnVtYmVyfSBib3gueCB0aGUgdG9wIGxlZnQgWCBjb29yZGluYXRlIG9mIHRoZSBjYW52YXMgdmlzaWJsZSBpbiB2aWV3IGJveFxuICogQHBhcmFtICB7bnVtYmVyfSBib3gueSB0aGUgdG9wIGxlZnQgWSBjb29yZGluYXRlIG9mIHRoZSBjYW52YXMgdmlzaWJsZSBpbiB2aWV3IGJveFxuICogQHBhcmFtICB7bnVtYmVyfSBib3gud2lkdGggdGhlIHZpc2libGUgd2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gYm94LmhlaWdodFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGN1cnJlbnQgdmlldyBib3hcbiAqL1xuQ2FudmFzLnByb3RvdHlwZS52aWV3Ym94ID0gZnVuY3Rpb24oYm94KSB7XG5cbiAgaWYgKGJveCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2NhY2hlZFZpZXdib3gpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkVmlld2JveDtcbiAgfVxuXG4gIHZhciB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0LFxuICAgICAgaW5uZXJCb3gsXG4gICAgICBvdXRlckJveCA9IHRoaXMuZ2V0U2l6ZSgpLFxuICAgICAgbWF0cml4LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgc2NhbGUsXG4gICAgICB4LCB5O1xuXG4gIGlmICghYm94KSB7XG5cbiAgICAvLyBjb21wdXRlIHRoZSBpbm5lciBib3ggYmFzZWQgb24gdGhlXG4gICAgLy8gZGlhZ3JhbXMgZGVmYXVsdCBsYXllci4gVGhpcyBhbGxvd3MgdXMgdG8gZXhjbHVkZVxuICAgIC8vIGV4dGVybmFsIGNvbXBvbmVudHMsIHN1Y2ggYXMgb3ZlcmxheXNcbiAgICBpbm5lckJveCA9IHRoaXMuZ2V0RGVmYXVsdExheWVyKCkuZ2V0QkJveCgpO1xuXG4gICAgdHJhbnNmb3JtID0gc3ZnVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICBtYXRyaXggPSB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0ubWF0cml4IDogY3JlYXRlTWF0cml4KCk7XG4gICAgc2NhbGUgPSByb3VuZChtYXRyaXguYSwgMTAwMCk7XG5cbiAgICB4ID0gcm91bmQoLW1hdHJpeC5lIHx8IDAsIDEwMDApO1xuICAgIHkgPSByb3VuZCgtbWF0cml4LmYgfHwgMCwgMTAwMCk7XG5cbiAgICBib3ggPSB0aGlzLl9jYWNoZWRWaWV3Ym94ID0ge1xuICAgICAgeDogeCA/IHggLyBzY2FsZSA6IDAsXG4gICAgICB5OiB5ID8geSAvIHNjYWxlIDogMCxcbiAgICAgIHdpZHRoOiBvdXRlckJveC53aWR0aCAvIHNjYWxlLFxuICAgICAgaGVpZ2h0OiBvdXRlckJveC5oZWlnaHQgLyBzY2FsZSxcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIGlubmVyOiB7XG4gICAgICAgIHdpZHRoOiBpbm5lckJveC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBpbm5lckJveC5oZWlnaHQsXG4gICAgICAgIHg6IGlubmVyQm94LngsXG4gICAgICAgIHk6IGlubmVyQm94LnlcbiAgICAgIH0sXG4gICAgICBvdXRlcjogb3V0ZXJCb3hcbiAgICB9O1xuXG4gICAgcmV0dXJuIGJveDtcbiAgfSBlbHNlIHtcblxuICAgIHRoaXMuX2NoYW5nZVZpZXdib3goZnVuY3Rpb24oKSB7XG4gICAgICBzY2FsZSA9IE1hdGgubWluKG91dGVyQm94LndpZHRoIC8gYm94LndpZHRoLCBvdXRlckJveC5oZWlnaHQgLyBib3guaGVpZ2h0KTtcblxuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX3N2Zy5jcmVhdGVTVkdNYXRyaXgoKVxuICAgICAgICAuc2NhbGUoc2NhbGUpXG4gICAgICAgIC50cmFuc2xhdGUoLWJveC54LCAtYm94LnkpO1xuXG4gICAgICBzdmdUcmFuc2Zvcm0odmlld3BvcnQsIG1hdHJpeCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYm94O1xufTtcblxuXG4vKipcbiAqIEdldHMgb3Igc2V0cyB0aGUgc2Nyb2xsIG9mIHRoZSBjYW52YXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtkZWx0YV0gdGhlIG5ldyBzY3JvbGwgdG8gYXBwbHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWx0YS5keF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsdGEuZHldXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuc2Nyb2xsID0gZnVuY3Rpb24oZGVsdGEpIHtcblxuICB2YXIgbm9kZSA9IHRoaXMuX3ZpZXdwb3J0O1xuICB2YXIgbWF0cml4ID0gbm9kZS5nZXRDVE0oKTtcblxuICBpZiAoZGVsdGEpIHtcbiAgICB0aGlzLl9jaGFuZ2VWaWV3Ym94KGZ1bmN0aW9uKCkge1xuICAgICAgZGVsdGEgPSBhc3NpZ24oeyBkeDogMCwgZHk6IDAgfSwgZGVsdGEgfHwge30pO1xuXG4gICAgICBtYXRyaXggPSB0aGlzLl9zdmcuY3JlYXRlU1ZHTWF0cml4KCkudHJhbnNsYXRlKGRlbHRhLmR4LCBkZWx0YS5keSkubXVsdGlwbHkobWF0cml4KTtcblxuICAgICAgc2V0Q1RNKG5vZGUsIG1hdHJpeCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4geyB4OiBtYXRyaXguZSwgeTogbWF0cml4LmYgfTtcbn07XG5cblxuLyoqXG4gKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgem9vbSBvZiB0aGUgY2FudmFzLCBvcHRpb25hbGx5IHpvb21pbmdcbiAqIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG4gKlxuICogVGhlIGdldHRlciBtYXkgcmV0dXJuIGEgY2FjaGVkIHpvb20gbGV2ZWwuIENhbGwgaXQgd2l0aCBgZmFsc2VgIGFzXG4gKiB0aGUgZmlyc3QgYXJndW1lbnQgdG8gZm9yY2UgcmVjb21wdXRhdGlvbiBvZiB0aGUgY3VycmVudCBsZXZlbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtuZXdTY2FsZV0gdGhlIG5ldyB6b29tIGxldmVsLCBlaXRoZXIgYSBudW1iZXIsIGkuZS4gMC45LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGBmaXQtdmlld3BvcnRgIHRvIGFkanVzdCB0aGUgc2l6ZSB0byBmaXQgdGhlIGN1cnJlbnQgdmlld3BvcnRcbiAqIEBwYXJhbSB7c3RyaW5nfFBvaW50fSBbY2VudGVyXSB0aGUgcmVmZXJlbmNlIHBvaW50IHsgeDogLi4sIHk6IC4ufSB0byB6b29tIHRvLCAnYXV0bycgdG8gem9vbSBpbnRvIG1pZCBvciBudWxsXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgY3VycmVudCBzY2FsZVxuICovXG5DYW52YXMucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbihuZXdTY2FsZSwgY2VudGVyKSB7XG5cbiAgaWYgKCFuZXdTY2FsZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXdib3gobmV3U2NhbGUpLnNjYWxlO1xuICB9XG5cbiAgaWYgKG5ld1NjYWxlID09PSAnZml0LXZpZXdwb3J0Jykge1xuICAgIHJldHVybiB0aGlzLl9maXRWaWV3cG9ydChjZW50ZXIpO1xuICB9XG5cbiAgdmFyIG91dGVyLFxuICAgICAgbWF0cml4O1xuXG4gIHRoaXMuX2NoYW5nZVZpZXdib3goZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAodHlwZW9mIGNlbnRlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgIG91dGVyID0gdGhpcy52aWV3Ym94KCkub3V0ZXI7XG5cbiAgICAgIGNlbnRlciA9IHtcbiAgICAgICAgeDogb3V0ZXIud2lkdGggLyAyLFxuICAgICAgICB5OiBvdXRlci5oZWlnaHQgLyAyXG4gICAgICB9O1xuICAgIH1cblxuICAgIG1hdHJpeCA9IHRoaXMuX3NldFpvb20obmV3U2NhbGUsIGNlbnRlcik7XG4gIH0pO1xuXG4gIHJldHVybiByb3VuZChtYXRyaXguYSwgMTAwMCk7XG59O1xuXG5mdW5jdGlvbiBzZXRDVE0obm9kZSwgbSkge1xuICB2YXIgbXN0ciA9ICdtYXRyaXgoJyArIG0uYSArICcsJyArIG0uYiArICcsJyArIG0uYyArICcsJyArIG0uZCArICcsJyArIG0uZSArICcsJyArIG0uZiArICcpJztcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIG1zdHIpO1xufVxuXG5DYW52YXMucHJvdG90eXBlLl9maXRWaWV3cG9ydCA9IGZ1bmN0aW9uKGNlbnRlcikge1xuXG4gIHZhciB2Ym94ID0gdGhpcy52aWV3Ym94KCksXG4gICAgICBvdXRlciA9IHZib3gub3V0ZXIsXG4gICAgICBpbm5lciA9IHZib3guaW5uZXIsXG4gICAgICBuZXdTY2FsZSxcbiAgICAgIG5ld1ZpZXdib3g7XG5cbiAgLy8gZGlzcGxheSB0aGUgY29tcGxldGUgZGlhZ3JhbSB3aXRob3V0IHpvb21pbmcgaW4uXG4gIC8vIGluc3RlYWQgb2YgcmVseWluZyBvbiBpbnRlcm5hbCB6b29tLCB3ZSBwZXJmb3JtIGFcbiAgLy8gaGFyZCByZXNldCBvbiB0aGUgY2FudmFzIHZpZXdib3ggdG8gcmVhbGl6ZSB0aGlzXG4gIC8vXG4gIC8vIGlmIGRpYWdyYW0gZG9lcyBub3QgbmVlZCB0byBiZSB6b29tZWQgaW4sIHdlIGZvY3VzIGl0IGFyb3VuZFxuICAvLyB0aGUgZGlhZ3JhbSBvcmlnaW4gaW5zdGVhZFxuXG4gIGlmIChpbm5lci54ID49IDAgJiZcbiAgICAgIGlubmVyLnkgPj0gMCAmJlxuICAgICAgaW5uZXIueCArIGlubmVyLndpZHRoIDw9IG91dGVyLndpZHRoICYmXG4gICAgICBpbm5lci55ICsgaW5uZXIuaGVpZ2h0IDw9IG91dGVyLmhlaWdodCAmJlxuICAgICAgIWNlbnRlcikge1xuXG4gICAgbmV3Vmlld2JveCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IE1hdGgubWF4KGlubmVyLndpZHRoICsgaW5uZXIueCwgb3V0ZXIud2lkdGgpLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heChpbm5lci5oZWlnaHQgKyBpbm5lci55LCBvdXRlci5oZWlnaHQpXG4gICAgfTtcbiAgfSBlbHNlIHtcblxuICAgIG5ld1NjYWxlID0gTWF0aC5taW4oMSwgb3V0ZXIud2lkdGggLyBpbm5lci53aWR0aCwgb3V0ZXIuaGVpZ2h0IC8gaW5uZXIuaGVpZ2h0KTtcbiAgICBuZXdWaWV3Ym94ID0ge1xuICAgICAgeDogaW5uZXIueCArIChjZW50ZXIgPyBpbm5lci53aWR0aCAvIDIgLSBvdXRlci53aWR0aCAvIG5ld1NjYWxlIC8gMiA6IDApLFxuICAgICAgeTogaW5uZXIueSArIChjZW50ZXIgPyBpbm5lci5oZWlnaHQgLyAyIC0gb3V0ZXIuaGVpZ2h0IC8gbmV3U2NhbGUgLyAyIDogMCksXG4gICAgICB3aWR0aDogb3V0ZXIud2lkdGggLyBuZXdTY2FsZSxcbiAgICAgIGhlaWdodDogb3V0ZXIuaGVpZ2h0IC8gbmV3U2NhbGVcbiAgICB9O1xuICB9XG5cbiAgdGhpcy52aWV3Ym94KG5ld1ZpZXdib3gpO1xuXG4gIHJldHVybiB0aGlzLnZpZXdib3goZmFsc2UpLnNjYWxlO1xufTtcblxuXG5DYW52YXMucHJvdG90eXBlLl9zZXRab29tID0gZnVuY3Rpb24oc2NhbGUsIGNlbnRlcikge1xuXG4gIHZhciBzdmcgPSB0aGlzLl9zdmcsXG4gICAgICB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0O1xuXG4gIHZhciBtYXRyaXggPSBzdmcuY3JlYXRlU1ZHTWF0cml4KCk7XG4gIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuXG4gIHZhciBjZW50ZXJQb2ludCxcbiAgICAgIG9yaWdpbmFsUG9pbnQsXG4gICAgICBjdXJyZW50TWF0cml4LFxuICAgICAgc2NhbGVNYXRyaXgsXG4gICAgICBuZXdNYXRyaXg7XG5cbiAgY3VycmVudE1hdHJpeCA9IHZpZXdwb3J0LmdldENUTSgpO1xuXG4gIHZhciBjdXJyZW50U2NhbGUgPSBjdXJyZW50TWF0cml4LmE7XG5cbiAgaWYgKGNlbnRlcikge1xuICAgIGNlbnRlclBvaW50ID0gYXNzaWduKHBvaW50LCBjZW50ZXIpO1xuXG4gICAgLy8gcmV2ZXJ0IGFwcGxpZWQgdmlld3BvcnQgdHJhbnNmb3JtYXRpb25zXG4gICAgb3JpZ2luYWxQb2ludCA9IGNlbnRlclBvaW50Lm1hdHJpeFRyYW5zZm9ybShjdXJyZW50TWF0cml4LmludmVyc2UoKSk7XG5cbiAgICAvLyBjcmVhdGUgc2NhbGUgbWF0cml4XG4gICAgc2NhbGVNYXRyaXggPSBtYXRyaXhcbiAgICAgIC50cmFuc2xhdGUob3JpZ2luYWxQb2ludC54LCBvcmlnaW5hbFBvaW50LnkpXG4gICAgICAuc2NhbGUoMSAvIGN1cnJlbnRTY2FsZSAqIHNjYWxlKVxuICAgICAgLnRyYW5zbGF0ZSgtb3JpZ2luYWxQb2ludC54LCAtb3JpZ2luYWxQb2ludC55KTtcblxuICAgIG5ld01hdHJpeCA9IGN1cnJlbnRNYXRyaXgubXVsdGlwbHkoc2NhbGVNYXRyaXgpO1xuICB9IGVsc2Uge1xuICAgIG5ld01hdHJpeCA9IG1hdHJpeC5zY2FsZShzY2FsZSk7XG4gIH1cblxuICBzZXRDVE0odGhpcy5fdmlld3BvcnQsIG5ld01hdHJpeCk7XG5cbiAgcmV0dXJuIG5ld01hdHJpeDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBjYW52YXNcbiAqXG4gKiBAcmV0dXJuIHtEaW1lbnNpb25zfVxuICovXG5DYW52YXMucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxuICAgIGhlaWdodDogdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodFxuICB9O1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgYWJzb2x1dGUgYm91bmRpbmcgYm94IGZvciB0aGUgZ2l2ZW4gZWxlbWVudFxuICpcbiAqIFRoZSBhYnNvbHV0ZSBib3VuZGluZyBib3ggbWF5IGJlIHVzZWQgdG8gZGlzcGxheSBvdmVybGF5cyBpbiB0aGVcbiAqIGNhbGxlcnMgKGJyb3dzZXIpIGNvb3JkaW5hdGUgc3lzdGVtIHJhdGhlciB0aGFuIHRoZSB6b29tZWQgaW4vb3V0XG4gKiBjYW52YXMgY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtICB7RWxlbWVudERlc2NyaXB0b3J9IGVsZW1lbnRcbiAqIEByZXR1cm4ge0JvdW5kc30gdGhlIGFic29sdXRlIGJvdW5kaW5nIGJveFxuICovXG5DYW52YXMucHJvdG90eXBlLmdldEFic29sdXRlQkJveCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIHZib3ggPSB0aGlzLnZpZXdib3goKTtcbiAgdmFyIGJib3g7XG5cbiAgLy8gY29ubmVjdGlvblxuICAvLyB1c2Ugc3ZnIGJib3hcbiAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgdmFyIGdmeCA9IHRoaXMuZ2V0R3JhcGhpY3MoZWxlbWVudCk7XG5cbiAgICBiYm94ID0gZ2Z4LmdldEJCb3goKTtcbiAgfVxuXG4gIC8vIHNoYXBlc1xuICAvLyB1c2UgZGF0YVxuICBlbHNlIHtcbiAgICBiYm94ID0gZWxlbWVudDtcbiAgfVxuXG4gIHZhciB4ID0gYmJveC54ICogdmJveC5zY2FsZSAtIHZib3gueCAqIHZib3guc2NhbGU7XG4gIHZhciB5ID0gYmJveC55ICogdmJveC5zY2FsZSAtIHZib3gueSAqIHZib3guc2NhbGU7XG5cbiAgdmFyIHdpZHRoID0gYmJveC53aWR0aCAqIHZib3guc2NhbGU7XG4gIHZhciBoZWlnaHQgPSBiYm94LmhlaWdodCAqIHZib3guc2NhbGU7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59O1xuXG4vKipcbiAqIEZpcmVzIGFuIGV2ZW50IGluIG9yZGVyIG90aGVyIG1vZHVsZXMgY2FuIHJlYWN0IHRvIHRoZVxuICogY2FudmFzIHJlc2l6aW5nXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUucmVzaXplZCA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIGZvcmNlIHJlY29tcHV0YXRpb24gb2YgdmlldyBib3hcbiAgZGVsZXRlIHRoaXMuX2NhY2hlZFZpZXdib3g7XG5cbiAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnY2FudmFzLnJlc2l6ZWQnKTtcbn07XG4iLCJpbXBvcnQge1xuICBjcmVhdGVcbn0gZnJvbSAnLi4vbW9kZWwnO1xuXG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdtaW4tZGFzaCc7XG5cbi8qKlxuICogQSBmYWN0b3J5IGZvciBkaWFncmFtLWpzIHNoYXBlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbGVtZW50RmFjdG9yeSgpIHtcbiAgdGhpcy5fdWlkID0gMTI7XG59XG5cblxuRWxlbWVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVJvb3QgPSBmdW5jdGlvbihhdHRycykge1xuICByZXR1cm4gdGhpcy5jcmVhdGUoJ3Jvb3QnLCBhdHRycyk7XG59O1xuXG5FbGVtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTGFiZWwgPSBmdW5jdGlvbihhdHRycykge1xuICByZXR1cm4gdGhpcy5jcmVhdGUoJ2xhYmVsJywgYXR0cnMpO1xufTtcblxuRWxlbWVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVNoYXBlID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlKCdzaGFwZScsIGF0dHJzKTtcbn07XG5cbkVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlKCdjb25uZWN0aW9uJywgYXR0cnMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtb2RlbCBlbGVtZW50IHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kXG4gKiBhIG51bWJlciBvZiBwcmUtc2V0IGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0gIHtPYmplY3R9IGF0dHJzXG4gKiBAcmV0dXJuIHtkanMubW9kZWwuQmFzZX0gdGhlIG5ld2x5IGNyZWF0ZWQgbW9kZWwgaW5zdGFuY2VcbiAqL1xuRWxlbWVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHR5cGUsIGF0dHJzKSB7XG5cbiAgYXR0cnMgPSBhc3NpZ24oe30sIGF0dHJzIHx8IHt9KTtcblxuICBpZiAoIWF0dHJzLmlkKSB7XG4gICAgYXR0cnMuaWQgPSB0eXBlICsgJ18nICsgKHRoaXMuX3VpZCsrKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGUodHlwZSwgYXR0cnMpO1xufTsiLCJ2YXIgRUxFTUVOVF9JRCA9ICdkYXRhLWVsZW1lbnQtaWQnO1xuXG5pbXBvcnQgeyBhdHRyIGFzIHN2Z0F0dHIgfSBmcm9tICd0aW55LXN2Zyc7XG5cblxuLyoqXG4gKiBAY2xhc3NcbiAqXG4gKiBBIHJlZ2lzdHJ5IHRoYXQga2VlcHMgdHJhY2sgb2YgYWxsIHNoYXBlcyBpbiB0aGUgZGlhZ3JhbS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRWxlbWVudFJlZ2lzdHJ5KGV2ZW50QnVzKSB7XG4gIHRoaXMuX2VsZW1lbnRzID0ge307XG5cbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbn1cblxuRWxlbWVudFJlZ2lzdHJ5LiRpbmplY3QgPSBbICdldmVudEJ1cycgXTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHBhaXIgb2YgKGVsZW1lbnQsIGdmeCwgKHNlY29uZGFyeUdmeCkpLlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ2Z4XG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IFtzZWNvbmRhcnlHZnhdIG9wdGlvbmFsIG90aGVyIGVsZW1lbnQgdG8gcmVnaXN0ZXIsIHRvb1xuICovXG5FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGdmeCwgc2Vjb25kYXJ5R2Z4KSB7XG5cbiAgdmFyIGlkID0gZWxlbWVudC5pZDtcblxuICB0aGlzLl92YWxpZGF0ZUlkKGlkKTtcblxuICAvLyBhc3NvY2lhdGUgZG9tIG5vZGUgd2l0aCBlbGVtZW50XG4gIHN2Z0F0dHIoZ2Z4LCBFTEVNRU5UX0lELCBpZCk7XG5cbiAgaWYgKHNlY29uZGFyeUdmeCkge1xuICAgIHN2Z0F0dHIoc2Vjb25kYXJ5R2Z4LCBFTEVNRU5UX0lELCBpZCk7XG4gIH1cblxuICB0aGlzLl9lbGVtZW50c1tpZF0gPSB7IGVsZW1lbnQ6IGVsZW1lbnQsIGdmeDogZ2Z4LCBzZWNvbmRhcnlHZng6IHNlY29uZGFyeUdmeCB9O1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgcmVnaXN0cnkuXG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICovXG5FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHMsXG4gICAgICBpZCA9IGVsZW1lbnQuaWQgfHwgZWxlbWVudCxcbiAgICAgIGNvbnRhaW5lciA9IGlkICYmIGVsZW1lbnRzW2lkXTtcblxuICBpZiAoY29udGFpbmVyKSB7XG5cbiAgICAvLyB1bnNldCBlbGVtZW50IGlkIG9uIGdmeFxuICAgIHN2Z0F0dHIoY29udGFpbmVyLmdmeCwgRUxFTUVOVF9JRCwgJycpO1xuXG4gICAgaWYgKGNvbnRhaW5lci5zZWNvbmRhcnlHZngpIHtcbiAgICAgIHN2Z0F0dHIoY29udGFpbmVyLnNlY29uZGFyeUdmeCwgRUxFTUVOVF9JRCwgJycpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBlbGVtZW50c1tpZF07XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBpZCBvZiBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5ld0lkXG4gKi9cbkVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUudXBkYXRlSWQgPSBmdW5jdGlvbihlbGVtZW50LCBuZXdJZCkge1xuXG4gIHRoaXMuX3ZhbGlkYXRlSWQobmV3SWQpO1xuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbGVtZW50ID0gdGhpcy5nZXQoZWxlbWVudCk7XG4gIH1cblxuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdlbGVtZW50LnVwZGF0ZUlkJywge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgbmV3SWQ6IG5ld0lkXG4gIH0pO1xuXG4gIHZhciBnZnggPSB0aGlzLmdldEdyYXBoaWNzKGVsZW1lbnQpLFxuICAgICAgc2Vjb25kYXJ5R2Z4ID0gdGhpcy5nZXRHcmFwaGljcyhlbGVtZW50LCB0cnVlKTtcblxuICB0aGlzLnJlbW92ZShlbGVtZW50KTtcblxuICBlbGVtZW50LmlkID0gbmV3SWQ7XG5cbiAgdGhpcy5hZGQoZWxlbWVudCwgZ2Z4LCBzZWNvbmRhcnlHZngpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1vZGVsIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gaWQgb3IgZ3JhcGhpY3MuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBlbGVtZW50UmVnaXN0cnkuZ2V0KCdTb21lRWxlbWVudElkXzEnKTtcbiAqIGVsZW1lbnRSZWdpc3RyeS5nZXQoZ2Z4KTtcbiAqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8U1ZHRWxlbWVudH0gZmlsdGVyIGZvciBzZWxlY3RpbmcgdGhlIGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtkanMubW9kZWwuQmFzZX1cbiAqL1xuRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgdmFyIGlkO1xuXG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgIGlkID0gZmlsdGVyO1xuICB9IGVsc2Uge1xuICAgIGlkID0gZmlsdGVyICYmIHN2Z0F0dHIoZmlsdGVyLCBFTEVNRU5UX0lEKTtcbiAgfVxuXG4gIHZhciBjb250YWluZXIgPSB0aGlzLl9lbGVtZW50c1tpZF07XG4gIHJldHVybiBjb250YWluZXIgJiYgY29udGFpbmVyLmVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbGwgZWxlbWVudHMgdGhhdCBtYXRjaCBhIGdpdmVuIGZpbHRlciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICpcbiAqIEByZXR1cm4ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn1cbiAqL1xuRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmbikge1xuXG4gIHZhciBmaWx0ZXJlZCA9IFtdO1xuXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBnZngpIHtcbiAgICBpZiAoZm4oZWxlbWVudCwgZ2Z4KSkge1xuICAgICAgZmlsdGVyZWQucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmaWx0ZXJlZDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKlxuICogQHJldHVybiB7ZGpzLm1vZGVsLkJhc2V9XG4gKi9cbkVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBtYXAgPSB0aGlzLl9lbGVtZW50cyxcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZCA9IGtleXNbaV0sXG4gICAgICAgIGNvbnRhaW5lciA9IG1hcFtpZF0sXG4gICAgICAgIGVsZW1lbnQgPSBjb250YWluZXIuZWxlbWVudCxcbiAgICAgICAgZ2Z4ID0gY29udGFpbmVyLmdmeDtcblxuICAgIGlmIChmbihlbGVtZW50LCBnZngpKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIGFsbCByZW5kZXJlZCBtb2RlbCBlbGVtZW50cy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59XG4gKi9cbkVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihlKSB7IHJldHVybiBlOyB9KTtcbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCBkaWFncmFtIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbkVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG5cbiAgdmFyIG1hcCA9IHRoaXMuX2VsZW1lbnRzO1xuXG4gIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbihpZCkge1xuICAgIHZhciBjb250YWluZXIgPSBtYXBbaWRdLFxuICAgICAgICBlbGVtZW50ID0gY29udGFpbmVyLmVsZW1lbnQsXG4gICAgICAgIGdmeCA9IGNvbnRhaW5lci5nZng7XG5cbiAgICByZXR1cm4gZm4oZWxlbWVudCwgZ2Z4KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGFuIGVsZW1lbnQgb3IgaXRzIGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBlbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoJ1NvbWVFbGVtZW50SWRfMScpO1xuICogZWxlbWVudFJlZ2lzdHJ5LmdldEdyYXBoaWNzKHJvb3RFbGVtZW50KTsgLy8gPGcgLi4uPlxuICpcbiAqIGVsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhyb290RWxlbWVudCwgdHJ1ZSk7IC8vIDxzdmcgLi4uPlxuICpcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xkanMubW9kZWwuQmFzZX0gZmlsdGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWNvbmRhcnk9ZmFsc2VdIHdoZXRoZXIgdG8gcmV0dXJuIHRoZSBzZWNvbmRhcnkgY29ubmVjdGVkIGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICovXG5FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmdldEdyYXBoaWNzID0gZnVuY3Rpb24oZmlsdGVyLCBzZWNvbmRhcnkpIHtcbiAgdmFyIGlkID0gZmlsdGVyLmlkIHx8IGZpbHRlcjtcblxuICB2YXIgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudHNbaWRdO1xuICByZXR1cm4gY29udGFpbmVyICYmIChzZWNvbmRhcnkgPyBjb250YWluZXIuc2Vjb25kYXJ5R2Z4IDogY29udGFpbmVyLmdmeCk7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBzdWl0YWJpbGl0eSBvZiB0aGUgZ2l2ZW4gaWQgYW5kIHNpZ25hbHMgYSBwcm9ibGVtXG4gKiB3aXRoIGFuIGV4Y2VwdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgaWQgaXMgZW1wdHkgb3IgYWxyZWFkeSBhc3NpZ25lZFxuICovXG5FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLl92YWxpZGF0ZUlkID0gZnVuY3Rpb24oaWQpIHtcbiAgaWYgKCFpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBtdXN0IGhhdmUgYW4gaWQnKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9lbGVtZW50c1tpZF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgd2l0aCBpZCAnICsgaWQgKyAnIGFscmVhZHkgYWRkZWQnKTtcbiAgfVxufTtcbiIsImltcG9ydCB7XG4gIGlzRnVuY3Rpb24sXG4gIGlzQXJyYXksXG4gIGlzTnVtYmVyLFxuICBiaW5kLFxuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG52YXIgRk5fUkVGID0gJ19fZm4nO1xuXG52YXIgREVGQVVMVF9QUklPUklUWSA9IDEwMDA7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBBIGdlbmVyYWwgcHVycG9zZSBldmVudCBidXMuXG4gKlxuICogVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byBjb21tdW5pY2F0ZSBhY3Jvc3MgYSBkaWFncmFtIGluc3RhbmNlLlxuICogT3RoZXIgcGFydHMgb2YgYSBkaWFncmFtIGNhbiB1c2UgaXQgdG8gbGlzdGVuIHRvIGFuZCBicm9hZGNhc3QgZXZlbnRzLlxuICpcbiAqXG4gKiAjIyBSZWdpc3RlcmluZyBmb3IgRXZlbnRzXG4gKlxuICogVGhlIGV2ZW50IGJ1cyBwcm92aWRlcyB0aGUge0BsaW5rIEV2ZW50QnVzI29ufSBhbmQge0BsaW5rIEV2ZW50QnVzI29uY2V9XG4gKiBtZXRob2RzIHRvIHJlZ2lzdGVyIGZvciBldmVudHMuIHtAbGluayBFdmVudEJ1cyNvZmZ9IGNhbiBiZSB1c2VkIHRvXG4gKiByZW1vdmUgZXZlbnQgcmVnaXN0cmF0aW9ucy4gTGlzdGVuZXJzIHJlY2VpdmUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEV2ZW50fVxuICogYXMgdGhlIGZpcnN0IGFyZ3VtZW50LiBJdCBhbGxvd3MgdGhlbSB0byBob29rIGludG8gdGhlIGV2ZW50IGV4ZWN1dGlvbi5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKlxuICogLy8gbGlzdGVuIGZvciBldmVudFxuICogZXZlbnRCdXMub24oJ2ZvbycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKlxuICogICAvLyBhY2Nlc3MgZXZlbnQgdHlwZVxuICogICBldmVudC50eXBlOyAvLyAnZm9vJ1xuICpcbiAqICAgLy8gc3RvcCBwcm9wYWdhdGlvbiB0byBvdGhlciBsaXN0ZW5lcnNcbiAqICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gKlxuICogICAvLyBwcmV2ZW50IGV2ZW50IGRlZmF1bHRcbiAqICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAqIH0pO1xuICpcbiAqIC8vIGxpc3RlbiBmb3IgZXZlbnQgd2l0aCBjdXN0b20gcGF5bG9hZFxuICogZXZlbnRCdXMub24oJ2JhcicsIGZ1bmN0aW9uKGV2ZW50LCBwYXlsb2FkKSB7XG4gKiAgIGNvbnNvbGUubG9nKHBheWxvYWQpO1xuICogfSk7XG4gKlxuICogLy8gbGlzdGVuIGZvciBldmVudCByZXR1cm5pbmcgdmFsdWVcbiAqIGV2ZW50QnVzLm9uKCdmb29iYXInLCBmdW5jdGlvbihldmVudCkge1xuICpcbiAqICAgLy8gc3RvcCBldmVudCBwcm9wYWdhdGlvbiArIHByZXZlbnQgZGVmYXVsdFxuICogICByZXR1cm4gZmFsc2U7XG4gKlxuICogICAvLyBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uICsgcmV0dXJuIGN1c3RvbSByZXN1bHRcbiAqICAgcmV0dXJuIHtcbiAqICAgICBjb21wbGV4OiAnbGlzdGVuaW5nIHJlc3VsdCdcbiAqICAgfTtcbiAqIH0pO1xuICpcbiAqXG4gKiAvLyBsaXN0ZW4gd2l0aCBjdXN0b20gcHJpb3JpdHkgKGRlZmF1bHQ9MTAwMCwgaGlnaGVyIGlzIGJldHRlcilcbiAqIGV2ZW50QnVzLm9uKCdwcmlvcml0eWZvbycsIDE1MDAsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgIGNvbnNvbGUubG9nKCdpbnZva2VkIGZpcnN0IScpO1xuICogfSk7XG4gKlxuICpcbiAqIC8vIGxpc3RlbiBmb3IgZXZlbnQgYW5kIHBhc3MgdGhlIGNvbnRleHQgKGB0aGlzYClcbiAqIGV2ZW50QnVzLm9uKCdmb29iYXInLCBmdW5jdGlvbihldmVudCkge1xuICogICB0aGlzLmZvbygpO1xuICogfSwgdGhpcyk7XG4gKiBgYGBcbiAqXG4gKlxuICogIyMgRW1pdHRpbmcgRXZlbnRzXG4gKlxuICogRXZlbnRzIGNhbiBiZSBlbWl0dGVkIHZpYSB0aGUgZXZlbnQgYnVzIHVzaW5nIHtAbGluayBFdmVudEJ1cyNmaXJlfS5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKlxuICogLy8gZmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIGRlZmF1bHQgYWN0aW9uXG4gKiAvLyB3YXMgcHJldmVudGVkIGJ5IGxpc3RlbmVyc1xuICogaWYgKGV2ZW50QnVzLmZpcmUoJ2ZvbycpID09PSBmYWxzZSkge1xuICogICBjb25zb2xlLmxvZygnZGVmYXVsdCBoYXMgYmVlbiBwcmV2ZW50ZWQhJyk7XG4gKiB9O1xuICpcbiAqXG4gKiAvLyBjdXN0b20gYXJncyArIHJldHVybiB2YWx1ZSBsaXN0ZW5lclxuICogZXZlbnRCdXMub24oJ3N1bScsIGZ1bmN0aW9uKGV2ZW50LCBhLCBiKSB7XG4gKiAgIHJldHVybiBhICsgYjtcbiAqIH0pO1xuICpcbiAqIC8vIHlvdSBjYW4gcGFzcyBjdXN0b20gYXJndW1lbnRzICsgcmV0cmlldmUgcmVzdWx0IHZhbHVlcy5cbiAqIHZhciBzdW0gPSBldmVudEJ1cy5maXJlKCdzdW0nLCAxLCAyKTtcbiAqIGNvbnNvbGUubG9nKHN1bSk7IC8vIDNcbiAqIGBgYFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFdmVudEJ1cygpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cbiAgLy8gY2xlYW51cCBvbiBkZXN0cm95IG9uIGxvd2VzdCBwcmlvcml0eSB0byBhbGxvd1xuICAvLyBtZXNzYWdlIHBhc3NpbmcgdW50aWwgdGhlIGJpdHRlciBlbmRcbiAgdGhpcy5vbignZGlhZ3JhbS5kZXN0cm95JywgMSwgdGhpcy5fZGVzdHJveSwgdGhpcyk7XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lciBmb3IgZXZlbnRzIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gKlxuICogVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCB3aXRoIGBldmVudCwgLi4uYWRkaXRpb25hbEFyZ3VtZW50c2BcbiAqIHRoYXQgaGF2ZSBiZWVuIHBhc3NlZCB0byB7QGxpbmsgRXZlbnRCdXMjZmlyZX0uXG4gKlxuICogUmV0dXJuaW5nIGZhbHNlIGZyb20gYSBsaXN0ZW5lciB3aWxsIHByZXZlbnQgdGhlIGV2ZW50cyBkZWZhdWx0IGFjdGlvblxuICogKGlmIGFueSBpcyBzcGVjaWZpZWQpLiBUbyBzdG9wIGFuIGV2ZW50IGZyb20gYmVpbmcgcHJvY2Vzc2VkIGZ1cnRoZXIgaW5cbiAqIG90aGVyIGxpc3RlbmVycyBleGVjdXRlIHtAbGluayBFdmVudCNzdG9wUHJvcGFnYXRpb259LlxuICpcbiAqIFJldHVybmluZyBhbnl0aGluZyBidXQgYHVuZGVmaW5lZGAgZnJvbSBhIGxpc3RlbmVyIHdpbGwgc3RvcCB0aGUgbGlzdGVuZXIgcHJvcGFnYXRpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gZXZlbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTEwMDBdIHRoZSBwcmlvcml0eSBpbiB3aGljaCB0aGlzIGxpc3RlbmVyIGlzIGNhbGxlZCwgbGFyZ2VyIGlzIGhpZ2hlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGhhdF0gUGFzcyBjb250ZXh0IChgdGhpc2ApIHRvIHRoZSBjYWxsYmFja1xuICovXG5FdmVudEJ1cy5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudHMsIHByaW9yaXR5LCBjYWxsYmFjaywgdGhhdCkge1xuXG4gIGV2ZW50cyA9IGlzQXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IFsgZXZlbnRzIF07XG5cbiAgaWYgKGlzRnVuY3Rpb24ocHJpb3JpdHkpKSB7XG4gICAgdGhhdCA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gcHJpb3JpdHk7XG4gICAgcHJpb3JpdHkgPSBERUZBVUxUX1BSSU9SSVRZO1xuICB9XG5cbiAgaWYgKCFpc051bWJlcihwcmlvcml0eSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaW9yaXR5IG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuXG4gIHZhciBhY3R1YWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIGlmICh0aGF0KSB7XG4gICAgYWN0dWFsQ2FsbGJhY2sgPSBiaW5kKGNhbGxiYWNrLCB0aGF0KTtcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSByZW1lbWJlciBhbmQgYXJlIGFibGUgdG8gcmVtb3ZlXG4gICAgLy8gYm91bmQgY2FsbGJhY2tzIHZpYSB7QGxpbmsgI29mZn0gdXNpbmcgdGhlIG9yaWdpbmFsXG4gICAgLy8gY2FsbGJhY2tcbiAgICBhY3R1YWxDYWxsYmFja1tGTl9SRUZdID0gY2FsbGJhY2tbRk5fUkVGXSB8fCBjYWxsYmFjaztcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgc2VsZi5fYWRkTGlzdGVuZXIoZSwge1xuICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgY2FsbGJhY2s6IGFjdHVhbENhbGxiYWNrLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGlzIGV4ZWN1dGVkIG9ubHkgb25jZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgdGhlIGV2ZW50IG5hbWUgdG8gcmVnaXN0ZXIgZm9yXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTEwMDBdIHRoZSBwcmlvcml0eSBpbiB3aGljaCB0aGlzIGxpc3RlbmVyIGlzIGNhbGxlZCwgbGFyZ2VyIGlzIGhpZ2hlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGhhdF0gUGFzcyBjb250ZXh0IChgdGhpc2ApIHRvIHRoZSBjYWxsYmFja1xuICovXG5FdmVudEJ1cy5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBwcmlvcml0eSwgY2FsbGJhY2ssIHRoYXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmIChpc0Z1bmN0aW9uKHByaW9yaXR5KSkge1xuICAgIHRoYXQgPSBjYWxsYmFjaztcbiAgICBjYWxsYmFjayA9IHByaW9yaXR5O1xuICAgIHByaW9yaXR5ID0gREVGQVVMVF9QUklPUklUWTtcbiAgfVxuXG4gIGlmICghaXNOdW1iZXIocHJpb3JpdHkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcmlvcml0eSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwcGVkQ2FsbGJhY2soKSB7XG4gICAgd3JhcHBlZENhbGxiYWNrLl9faXNUb21iID0gdHJ1ZTtcblxuICAgIHZhciByZXN1bHQgPSBjYWxsYmFjay5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuXG4gICAgc2VsZi5vZmYoZXZlbnQsIHdyYXBwZWRDYWxsYmFjayk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHJlbWVtYmVyIGFuZCBhcmUgYWJsZSB0byByZW1vdmVcbiAgLy8gYm91bmQgY2FsbGJhY2tzIHZpYSB7QGxpbmsgI29mZn0gdXNpbmcgdGhlIG9yaWdpbmFsXG4gIC8vIGNhbGxiYWNrXG4gIHdyYXBwZWRDYWxsYmFja1tGTl9SRUZdID0gY2FsbGJhY2s7XG5cbiAgdGhpcy5vbihldmVudCwgcHJpb3JpdHksIHdyYXBwZWRDYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgYnkgZXZlbnQgYW5kIGNhbGxiYWNrLlxuICpcbiAqIElmIG5vIGNhbGxiYWNrIGlzIGdpdmVuLCBhbGwgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50IG5hbWUgYXJlIGJlaW5nIHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gZXZlbnRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gKi9cbkV2ZW50QnVzLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihldmVudHMsIGNhbGxiYWNrKSB7XG5cbiAgZXZlbnRzID0gaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogWyBldmVudHMgXTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBzZWxmLl9yZW1vdmVMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spO1xuICB9KTtcblxufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhbiBFdmVudEJ1cyBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZXZlbnQsIHJlY29nbml6ZWQgYnkgdGhlIGV2ZW50QnVzXG4gKi9cbkV2ZW50QnVzLnByb3RvdHlwZS5jcmVhdGVFdmVudCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIGV2ZW50ID0gbmV3IEludGVybmFsRXZlbnQoKTtcblxuICBldmVudC5pbml0KGRhdGEpO1xuXG4gIHJldHVybiBldmVudDtcbn07XG5cblxuLyoqXG4gKiBGaXJlcyBhIG5hbWVkIGV2ZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZmlyZSBldmVudCBieSBuYW1lXG4gKiBldmVudHMuZmlyZSgnZm9vJyk7XG4gKlxuICogLy8gZmlyZSBldmVudCBvYmplY3Qgd2l0aCBuZXN0ZWQgdHlwZVxuICogdmFyIGV2ZW50ID0geyB0eXBlOiAnZm9vJyB9O1xuICogZXZlbnRzLmZpcmUoZXZlbnQpO1xuICpcbiAqIC8vIGZpcmUgZXZlbnQgd2l0aCBleHBsaWNpdCB0eXBlXG4gKiB2YXIgZXZlbnQgPSB7IHg6IDEwLCB5OiAyMCB9O1xuICogZXZlbnRzLmZpcmUoJ2VsZW1lbnQubW92ZWQnLCBldmVudCk7XG4gKlxuICogLy8gcGFzcyBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byB0aGUgZXZlbnRcbiAqIGV2ZW50cy5vbignZm9vJywgZnVuY3Rpb24oZXZlbnQsIGJhcikge1xuICogICBhbGVydChiYXIpO1xuICogfSk7XG4gKlxuICogZXZlbnRzLmZpcmUoeyB0eXBlOiAnZm9vJyB9LCAnSSBhbSBiYXIhJyk7XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSB0aGUgb3B0aW9uYWwgZXZlbnQgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtldmVudF0gdGhlIGV2ZW50IG9iamVjdFxuICogQHBhcmFtIHsuLi5PYmplY3R9IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIGV2ZW50cyByZXR1cm4gdmFsdWUsIGlmIHNwZWNpZmllZCBvciBmYWxzZSBpZiB0aGVcbiAqICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgYWN0aW9uIHdhcyBwcmV2ZW50ZWQgYnkgbGlzdGVuZXJzXG4gKi9cbkV2ZW50QnVzLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICB2YXIgZXZlbnQsXG4gICAgICBmaXJzdExpc3RlbmVyLFxuICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICBhcmdzO1xuXG4gIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIGRhdGEgPSB0eXBlO1xuICAgIHR5cGUgPSBkYXRhLnR5cGU7XG4gIH1cblxuICBpZiAoIXR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGV2ZW50IHR5cGUgc3BlY2lmaWVkJyk7XG4gIH1cblxuICBmaXJzdExpc3RlbmVyID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuXG4gIGlmICghZmlyc3RMaXN0ZW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHdlIG1ha2Ugc3VyZSB3ZSBmaXJlIGluc3RhbmNlcyBvZiBvdXIgaG9tZSBtYWRlXG4gIC8vIGV2ZW50cyBoZXJlLiBXZSB3cmFwIHRoZW0gb25seSBvbmNlLCB0aG91Z2hcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBJbnRlcm5hbEV2ZW50KSB7XG5cbiAgICAvLyB3ZSBhcmUgZmluZSwgd2UgYWxyZWFkIGhhdmUgYW4gZXZlbnRcbiAgICBldmVudCA9IGRhdGE7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50KGRhdGEpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHdlIHBhc3MgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXJcbiAgYXJnc1swXSA9IGV2ZW50O1xuXG4gIC8vIG9yaWdpbmFsIGV2ZW50IHR5cGUgKGluIGNhc2Ugd2UgZGVsZWdhdGUpXG4gIHZhciBvcmlnaW5hbFR5cGUgPSBldmVudC50eXBlO1xuXG4gIC8vIHVwZGF0ZSBldmVudCB0eXBlIGJlZm9yZSBkZWxlZ2F0aW9uXG4gIGlmICh0eXBlICE9PSBvcmlnaW5hbFR5cGUpIHtcbiAgICBldmVudC50eXBlID0gdHlwZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuVmFsdWUgPSB0aGlzLl9pbnZva2VMaXN0ZW5lcnMoZXZlbnQsIGFyZ3MsIGZpcnN0TGlzdGVuZXIpO1xuICB9IGZpbmFsbHkge1xuXG4gICAgLy8gcmVzZXQgZXZlbnQgdHlwZSBhZnRlciBkZWxlZ2F0aW9uXG4gICAgaWYgKHR5cGUgIT09IG9yaWdpbmFsVHlwZSkge1xuICAgICAgZXZlbnQudHlwZSA9IG9yaWdpbmFsVHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgdGhlIHJldHVybiB2YWx1ZSB0byBmYWxzZSBpZiB0aGUgZXZlbnQgZGVmYXVsdFxuICAvLyBnb3QgcHJldmVudGVkIGFuZCBubyBvdGhlciByZXR1cm4gdmFsdWUgZXhpc3RzXG4gIGlmIChyZXR1cm5WYWx1ZSA9PT0gdW5kZWZpbmVkICYmIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcblxuXG5FdmVudEJ1cy5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICByZXR1cm4gdGhpcy5maXJlKCdlcnJvcicsIHsgZXJyb3I6IGVycm9yIH0pID09PSBmYWxzZTtcbn07XG5cblxuRXZlbnRCdXMucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xufTtcblxuRXZlbnRCdXMucHJvdG90eXBlLl9pbnZva2VMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCwgYXJncywgbGlzdGVuZXIpIHtcblxuICB2YXIgcmV0dXJuVmFsdWU7XG5cbiAgd2hpbGUgKGxpc3RlbmVyKSB7XG5cbiAgICAvLyBoYW5kbGUgc3RvcHBlZCBwcm9wYWdhdGlvblxuICAgIGlmIChldmVudC5jYW5jZWxCdWJibGUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVyblZhbHVlID0gdGhpcy5faW52b2tlTGlzdGVuZXIoZXZlbnQsIGFyZ3MsIGxpc3RlbmVyKTtcblxuICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG5cbkV2ZW50QnVzLnByb3RvdHlwZS5faW52b2tlTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgYXJncywgbGlzdGVuZXIpIHtcblxuICB2YXIgcmV0dXJuVmFsdWU7XG5cbiAgaWYgKGxpc3RlbmVyLmNhbGxiYWNrLl9faXNUb21iKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbiAgdHJ5IHtcblxuICAgIC8vIHJldHVybmluZyBmYWxzZSBwcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb25cbiAgICByZXR1cm5WYWx1ZSA9IGludm9rZUZ1bmN0aW9uKGxpc3RlbmVyLmNhbGxiYWNrLCBhcmdzKTtcblxuICAgIC8vIHN0b3AgcHJvcGFnYXRpb24gb24gcmV0dXJuIHZhbHVlXG4gICAgaWYgKHJldHVyblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gcmV0dXJuVmFsdWU7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IGRlZmF1bHQgb24gcmV0dXJuIGZhbHNlXG4gICAgaWYgKHJldHVyblZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIXRoaXMuaGFuZGxlRXJyb3IoZSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3VuaGFuZGxlZCBlcnJvciBpbiBldmVudCBsaXN0ZW5lcicpO1xuICAgICAgY29uc29sZS5lcnJvcihlLnN0YWNrKTtcblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuXG4vKlxuICogQWRkIG5ldyBsaXN0ZW5lciB3aXRoIGEgY2VydGFpbiBwcmlvcml0eSB0byB0aGUgbGlzdFxuICogb2YgbGlzdGVuZXJzIChmb3IgdGhlIGdpdmVuIGV2ZW50KS5cbiAqXG4gKiBUaGUgc2VtYW50aWNzIG9mIGxpc3RlbmVyIHJlZ2lzdHJhdGlvbiAvIGxpc3RlbmVyIGV4ZWN1dGlvbiBhcmVcbiAqIGZpcnN0IHJlZ2lzdGVyLCBmaXJzdCBzZXJ2ZTogTmV3IGxpc3RlbmVycyB3aWxsIGFsd2F5cyBiZSBpbnNlcnRlZFxuICogYWZ0ZXIgZXhpc3RpbmcgbGlzdGVuZXJzIHdpdGggdGhlIHNhbWUgcHJpb3JpdHkuXG4gKlxuICogRXhhbXBsZTogSW5zZXJ0aW5nIHR3byBsaXN0ZW5lcnMgd2l0aCBwcmlvcml0eSAxMDAwIGFuZCAxMzAwXG4gKlxuICogICAgKiBiZWZvcmU6IFsgMTUwMCwgMTUwMCwgMTAwMCwgMTAwMCBdXG4gKiAgICAqIGFmdGVyOiBbIDE1MDAsIDE1MDAsIChuZXc9MTMwMCksIDEwMDAsIDEwMDAsIChuZXc9MTAwMCkgXVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGxpc3RlbmVyIHsgcHJpb3JpdHksIGNhbGxiYWNrIH1cbiAqL1xuRXZlbnRCdXMucHJvdG90eXBlLl9hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBuZXdMaXN0ZW5lcikge1xuXG4gIHZhciBsaXN0ZW5lciA9IHRoaXMuX2dldExpc3RlbmVycyhldmVudCksXG4gICAgICBwcmV2aW91c0xpc3RlbmVyO1xuXG4gIC8vIG5vIHByaW9yIGxpc3RlbmVyc1xuICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKGV2ZW50LCBuZXdMaXN0ZW5lcik7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBlbnN1cmUgd2Ugb3JkZXIgbGlzdGVuZXJzIGJ5IHByaW9yaXR5IGZyb21cbiAgLy8gMCAoaGlnaCkgdG8gbiA+IDAgKGxvdylcbiAgd2hpbGUgKGxpc3RlbmVyKSB7XG5cbiAgICBpZiAobGlzdGVuZXIucHJpb3JpdHkgPCBuZXdMaXN0ZW5lci5wcmlvcml0eSkge1xuXG4gICAgICBuZXdMaXN0ZW5lci5uZXh0ID0gbGlzdGVuZXI7XG5cbiAgICAgIGlmIChwcmV2aW91c0xpc3RlbmVyKSB7XG4gICAgICAgIHByZXZpb3VzTGlzdGVuZXIubmV4dCA9IG5ld0xpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKGV2ZW50LCBuZXdMaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcmV2aW91c0xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICB9XG5cbiAgLy8gYWRkIG5ldyBsaXN0ZW5lciB0byBiYWNrXG4gIHByZXZpb3VzTGlzdGVuZXIubmV4dCA9IG5ld0xpc3RlbmVyO1xufTtcblxuXG5FdmVudEJ1cy5wcm90b3R5cGUuX2dldExpc3RlbmVycyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX2xpc3RlbmVyc1tuYW1lXTtcbn07XG5cbkV2ZW50QnVzLnByb3RvdHlwZS5fc2V0TGlzdGVuZXJzID0gZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgdGhpcy5fbGlzdGVuZXJzW25hbWVdID0gbGlzdGVuZXI7XG59O1xuXG5FdmVudEJ1cy5wcm90b3R5cGUuX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG5cbiAgdmFyIGxpc3RlbmVyID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50KSxcbiAgICAgIG5leHRMaXN0ZW5lcixcbiAgICAgIHByZXZpb3VzTGlzdGVuZXIsXG4gICAgICBsaXN0ZW5lckNhbGxiYWNrO1xuXG4gIGlmICghY2FsbGJhY2spIHtcblxuICAgIC8vIGNsZWFyIGxpc3RlbmVyc1xuICAgIHRoaXMuX3NldExpc3RlbmVycyhldmVudCwgbnVsbCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB3aGlsZSAobGlzdGVuZXIpIHtcblxuICAgIG5leHRMaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG5cbiAgICBsaXN0ZW5lckNhbGxiYWNrID0gbGlzdGVuZXIuY2FsbGJhY2s7XG5cbiAgICBpZiAobGlzdGVuZXJDYWxsYmFjayA9PT0gY2FsbGJhY2sgfHwgbGlzdGVuZXJDYWxsYmFja1tGTl9SRUZdID09PSBjYWxsYmFjaykge1xuICAgICAgaWYgKHByZXZpb3VzTGlzdGVuZXIpIHtcbiAgICAgICAgcHJldmlvdXNMaXN0ZW5lci5uZXh0ID0gbmV4dExpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBuZXcgZmlyc3QgbGlzdGVuZXJcbiAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKGV2ZW50LCBuZXh0TGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZpb3VzTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICBsaXN0ZW5lciA9IG5leHRMaXN0ZW5lcjtcbiAgfVxufTtcblxuLyoqXG4gKiBBIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB2aWEgdGhlIGV2ZW50IGJ1cy5cbiAqL1xuZnVuY3Rpb24gSW50ZXJuYWxFdmVudCgpIHsgfVxuXG5JbnRlcm5hbEV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xufTtcblxuSW50ZXJuYWxFdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbn07XG5cbkludGVybmFsRXZlbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGFzc2lnbih0aGlzLCBkYXRhIHx8IHt9KTtcbn07XG5cblxuLyoqXG4gKiBJbnZva2UgZnVuY3Rpb24uIEJlIGZhc3QuLi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBhcmdzXG4gKlxuICogQHJldHVybiB7QW55fVxuICovXG5mdW5jdGlvbiBpbnZva2VGdW5jdGlvbihmbiwgYXJncykge1xuICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG59XG4iLCJpbXBvcnQge1xuICBmb3JFYWNoLFxuICByZWR1Y2Vcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRDaGlsZHJlbixcbiAgZ2V0VmlzdWFsXG59IGZyb20gJy4uL3V0aWwvR3JhcGhpY3NVdGlsJztcblxuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vdXRpbC9TdmdUcmFuc2Zvcm1VdGlsJztcblxuaW1wb3J0IHsgY2xlYXIgYXMgZG9tQ2xlYXIgfSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjbGFzc2VzIGFzIHN2Z0NsYXNzZXMsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXG4gIHJlbW92ZSBhcyBzdmdSZW1vdmVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQge1xuICBpc0ZyYW1lRWxlbWVudFxufSBmcm9tICcuLi91dGlsL0VsZW1lbnRzJztcblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBjcmVhdGVzIGdyYXBoaWNhbCBlbGVtZW50c1xuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0VsZW1lbnRSZWdpc3RyeX0gZWxlbWVudFJlZ2lzdHJ5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdyYXBoaWNzRmFjdG9yeShldmVudEJ1cywgZWxlbWVudFJlZ2lzdHJ5KSB7XG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX2VsZW1lbnRSZWdpc3RyeSA9IGVsZW1lbnRSZWdpc3RyeTtcbn1cblxuR3JhcGhpY3NGYWN0b3J5LiRpbmplY3QgPSBbICdldmVudEJ1cycgLCAnZWxlbWVudFJlZ2lzdHJ5JyBdO1xuXG5cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuX2dldENoaWxkcmVuQ29udGFpbmVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gIHZhciBnZnggPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCk7XG5cbiAgdmFyIGNoaWxkcmVuR2Z4O1xuXG4gIC8vIHJvb3QgZWxlbWVudFxuICBpZiAoIWVsZW1lbnQucGFyZW50KSB7XG4gICAgY2hpbGRyZW5HZnggPSBnZng7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW5HZnggPSBnZXRDaGlsZHJlbihnZngpO1xuICAgIGlmICghY2hpbGRyZW5HZngpIHtcbiAgICAgIGNoaWxkcmVuR2Z4ID0gc3ZnQ3JlYXRlKCdnJyk7XG4gICAgICBzdmdDbGFzc2VzKGNoaWxkcmVuR2Z4KS5hZGQoJ2Rqcy1jaGlsZHJlbicpO1xuXG4gICAgICBzdmdBcHBlbmQoZ2Z4LnBhcmVudE5vZGUsIGNoaWxkcmVuR2Z4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW5HZng7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlbGVtZW50IGFuZCByZXR1cm5zIHRoZVxuICogY2xlYXJlZCB2aXN1YWwgKHRoZSA8ZyBjbGFzcz1cImRqcy12aXN1YWxcIiAvPiBlbGVtZW50KS5cbiAqL1xuR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbihnZngpIHtcbiAgdmFyIHZpc3VhbCA9IGdldFZpc3VhbChnZngpO1xuXG4gIGRvbUNsZWFyKHZpc3VhbCk7XG5cbiAgcmV0dXJuIHZpc3VhbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGdmeCBjb250YWluZXIgZm9yIHNoYXBlcyBhbmQgY29ubmVjdGlvbnNcbiAqXG4gKiBUaGUgbGF5b3V0IGlzIGFzIGZvbGxvd3M6XG4gKlxuICogPGcgY2xhc3M9XCJkanMtZ3JvdXBcIj5cbiAqXG4gKiAgIDwhLS0gdGhlIGdmeCAtLT5cbiAqICAgPGcgY2xhc3M9XCJkanMtZWxlbWVudCBkanMtKHNoYXBlfGNvbm5lY3Rpb258ZnJhbWUpXCI+XG4gKiAgICAgPGcgY2xhc3M9XCJkanMtdmlzdWFsXCI+XG4gKiAgICAgICA8IS0tIHRoZSByZW5kZXJlciBkcmF3cyBpbiBoZXJlIC0tPlxuICogICAgIDwvZz5cbiAqXG4gKiAgICAgPCEtLSBleHRlbnNpb25zIChvdmVybGF5cywgY2xpY2sgYm94LCAuLi4pIGdvZXMgaGVyZVxuICogICA8L2c+XG4gKlxuICogICA8IS0tIHRoZSBnZnggY2hpbGQgbm9kZXMgLS0+XG4gKiAgIDxnIGNsYXNzPVwiZGpzLWNoaWxkcmVuXCI+PC9nPlxuICogPC9nPlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBlbGVtZW50LCBpLmUuIHNoYXBlIHwgY29ubmVjdGlvblxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBbY2hpbGRyZW5HZnhdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmVudEluZGV4XSBwb3NpdGlvbiB0byBjcmVhdGUgY29udGFpbmVyIGluIHBhcmVudFxuICogQHBhcmFtIHtib29sZWFufSBbaXNGcmFtZV0gaXMgZnJhbWUgZWxlbWVudFxuICpcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9XG4gKi9cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuX2NyZWF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uKFxuICAgIHR5cGUsIGNoaWxkcmVuR2Z4LCBwYXJlbnRJbmRleCwgaXNGcmFtZVxuKSB7XG4gIHZhciBvdXRlckdmeCA9IHN2Z0NyZWF0ZSgnZycpO1xuICBzdmdDbGFzc2VzKG91dGVyR2Z4KS5hZGQoJ2Rqcy1ncm91cCcpO1xuXG4gIC8vIGluc2VydCBub2RlIGF0IHBvc2l0aW9uXG4gIGlmICh0eXBlb2YgcGFyZW50SW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcHJlcGVuZFRvKG91dGVyR2Z4LCBjaGlsZHJlbkdmeCwgY2hpbGRyZW5HZnguY2hpbGROb2Rlc1twYXJlbnRJbmRleF0pO1xuICB9IGVsc2Uge1xuICAgIHN2Z0FwcGVuZChjaGlsZHJlbkdmeCwgb3V0ZXJHZngpO1xuICB9XG5cbiAgdmFyIGdmeCA9IHN2Z0NyZWF0ZSgnZycpO1xuICBzdmdDbGFzc2VzKGdmeCkuYWRkKCdkanMtZWxlbWVudCcpO1xuICBzdmdDbGFzc2VzKGdmeCkuYWRkKCdkanMtJyArIHR5cGUpO1xuXG4gIGlmIChpc0ZyYW1lKSB7XG4gICAgc3ZnQ2xhc3NlcyhnZngpLmFkZCgnZGpzLWZyYW1lJyk7XG4gIH1cblxuICBzdmdBcHBlbmQob3V0ZXJHZngsIGdmeCk7XG5cbiAgLy8gY3JlYXRlIHZpc3VhbFxuICB2YXIgdmlzdWFsID0gc3ZnQ3JlYXRlKCdnJyk7XG4gIHN2Z0NsYXNzZXModmlzdWFsKS5hZGQoJ2Rqcy12aXN1YWwnKTtcblxuICBzdmdBcHBlbmQoZ2Z4LCB2aXN1YWwpO1xuXG4gIHJldHVybiBnZng7XG59O1xuXG5HcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHBhcmVudEluZGV4KSB7XG4gIHZhciBjaGlsZHJlbkdmeCA9IHRoaXMuX2dldENoaWxkcmVuQ29udGFpbmVyKGVsZW1lbnQucGFyZW50KTtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUNvbnRhaW5lcih0eXBlLCBjaGlsZHJlbkdmeCwgcGFyZW50SW5kZXgsIGlzRnJhbWVFbGVtZW50KGVsZW1lbnQpKTtcbn07XG5cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUudXBkYXRlQ29udGFpbm1lbnRzID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBlbGVtZW50UmVnaXN0cnkgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnksXG4gICAgICBwYXJlbnRzO1xuXG4gIHBhcmVudHMgPSByZWR1Y2UoZWxlbWVudHMsIGZ1bmN0aW9uKG1hcCwgZSkge1xuXG4gICAgaWYgKGUucGFyZW50KSB7XG4gICAgICBtYXBbZS5wYXJlbnQuaWRdID0gZS5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfSwge30pO1xuXG4gIC8vIHVwZGF0ZSBhbGwgcGFyZW50cyBvZiBjaGFuZ2VkIGFuZCByZW9yZ2FuaXplZCB0aGVpciBjaGlsZHJlblxuICAvLyBpbiB0aGUgY29ycmVjdCBvcmRlciAoYXMgaW5kaWNhdGVkIGluIG91ciBtb2RlbClcbiAgZm9yRWFjaChwYXJlbnRzLCBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcblxuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW5HZnggPSBzZWxmLl9nZXRDaGlsZHJlbkNvbnRhaW5lcihwYXJlbnQpO1xuXG4gICAgZm9yRWFjaChjaGlsZHJlbi5zbGljZSgpLnJldmVyc2UoKSwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZEdmeCA9IGVsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhjaGlsZCk7XG5cbiAgICAgIHByZXBlbmRUbyhjaGlsZEdmeC5wYXJlbnROb2RlLCBjaGlsZHJlbkdmeCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS5kcmF3U2hhcGUgPSBmdW5jdGlvbih2aXN1YWwsIGVsZW1lbnQpIHtcbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgcmV0dXJuIGV2ZW50QnVzLmZpcmUoJ3JlbmRlci5zaGFwZScsIHsgZ2Z4OiB2aXN1YWwsIGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG59O1xuXG5HcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLmdldFNoYXBlUGF0aCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgcmV0dXJuIGV2ZW50QnVzLmZpcmUoJ3JlbmRlci5nZXRTaGFwZVBhdGgnLCBlbGVtZW50KTtcbn07XG5cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuZHJhd0Nvbm5lY3Rpb24gPSBmdW5jdGlvbih2aXN1YWwsIGVsZW1lbnQpIHtcbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgcmV0dXJuIGV2ZW50QnVzLmZpcmUoJ3JlbmRlci5jb25uZWN0aW9uJywgeyBnZng6IHZpc3VhbCwgZWxlbWVudDogZWxlbWVudCB9KTtcbn07XG5cbkdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvblBhdGggPSBmdW5jdGlvbih3YXlwb2ludHMpIHtcbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgcmV0dXJuIGV2ZW50QnVzLmZpcmUoJ3JlbmRlci5nZXRDb25uZWN0aW9uUGF0aCcsIHdheXBvaW50cyk7XG59O1xuXG5HcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIGdmeCkge1xuXG4gIC8vIGRvIE5PVCB1cGRhdGUgcm9vdCBlbGVtZW50XG4gIGlmICghZWxlbWVudC5wYXJlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmlzdWFsID0gdGhpcy5fY2xlYXIoZ2Z4KTtcblxuICAvLyByZWRyYXdcbiAgaWYgKHR5cGUgPT09ICdzaGFwZScpIHtcbiAgICB0aGlzLmRyYXdTaGFwZSh2aXN1YWwsIGVsZW1lbnQpO1xuXG4gICAgLy8gdXBkYXRlIHBvc2l0aW9uaW5nXG4gICAgdHJhbnNsYXRlKGdmeCwgZWxlbWVudC54LCBlbGVtZW50LnkpO1xuICB9IGVsc2VcbiAgaWYgKHR5cGUgPT09ICdjb25uZWN0aW9uJykge1xuICAgIHRoaXMuZHJhd0Nvbm5lY3Rpb24odmlzdWFsLCBlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdHlwZTogJyArIHR5cGUpO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQuaGlkZGVuKSB7XG4gICAgc3ZnQXR0cihnZngsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgfSBlbHNlIHtcbiAgICBzdmdBdHRyKGdmeCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgfVxufTtcblxuR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBnZnggPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCk7XG5cbiAgLy8gcmVtb3ZlXG4gIHN2Z1JlbW92ZShnZngucGFyZW50Tm9kZSk7XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBwcmVwZW5kVG8obmV3Tm9kZSwgcGFyZW50Tm9kZSwgc2libGluZ05vZGUpIHtcbiAgdmFyIG5vZGUgPSBzaWJsaW5nTm9kZSB8fCBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG5cbiAgLy8gZG8gbm90IHByZXBlbmQgbm9kZSB0byBpdHNlbGYgdG8gcHJldmVudCBJRSBmcm9tIGNyYXNoaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9icG1uLWlvL2JwbW4tanMvaXNzdWVzLzc0NlxuICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIG5vZGUpO1xufVxuIiwiaW1wb3J0IERyYXdNb2R1bGUgZnJvbSAnLi4vZHJhdyc7XG5cbmltcG9ydCBDYW52YXMgZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IEVsZW1lbnRSZWdpc3RyeSBmcm9tICcuL0VsZW1lbnRSZWdpc3RyeSc7XG5pbXBvcnQgRWxlbWVudEZhY3RvcnkgZnJvbSAnLi9FbGVtZW50RmFjdG9yeSc7XG5pbXBvcnQgRXZlbnRCdXMgZnJvbSAnLi9FdmVudEJ1cyc7XG5pbXBvcnQgR3JhcGhpY3NGYWN0b3J5IGZyb20gJy4vR3JhcGhpY3NGYWN0b3J5JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogWyBEcmF3TW9kdWxlIF0sXG4gIF9faW5pdF9fOiBbICdjYW52YXMnIF0sXG4gIGNhbnZhczogWyAndHlwZScsIENhbnZhcyBdLFxuICBlbGVtZW50UmVnaXN0cnk6IFsgJ3R5cGUnLCBFbGVtZW50UmVnaXN0cnkgXSxcbiAgZWxlbWVudEZhY3Rvcnk6IFsgJ3R5cGUnLCBFbGVtZW50RmFjdG9yeSBdLFxuICBldmVudEJ1czogWyAndHlwZScsIEV2ZW50QnVzIF0sXG4gIGdyYXBoaWNzRmFjdG9yeTogWyAndHlwZScsIEdyYXBoaWNzRmFjdG9yeSBdXG59OyIsInZhciBERUZBVUxUX1JFTkRFUl9QUklPUklUWSA9IDEwMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2Ygc2hhcGUgYW5kIGNvbm5lY3Rpb24gcmVuZGVyZXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge251bWJlcn0gW3JlbmRlclByaW9yaXR5PTEwMDBdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJhc2VSZW5kZXJlcihldmVudEJ1cywgcmVuZGVyUHJpb3JpdHkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHJlbmRlclByaW9yaXR5ID0gcmVuZGVyUHJpb3JpdHkgfHwgREVGQVVMVF9SRU5ERVJfUFJJT1JJVFk7XG5cbiAgZXZlbnRCdXMub24oWyAncmVuZGVyLnNoYXBlJywgJ3JlbmRlci5jb25uZWN0aW9uJyBdLCByZW5kZXJQcmlvcml0eSwgZnVuY3Rpb24oZXZ0LCBjb250ZXh0KSB7XG4gICAgdmFyIHR5cGUgPSBldnQudHlwZSxcbiAgICAgICAgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudCxcbiAgICAgICAgdmlzdWFscyA9IGNvbnRleHQuZ2Z4O1xuXG4gICAgaWYgKHNlbGYuY2FuUmVuZGVyKGVsZW1lbnQpKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ3JlbmRlci5zaGFwZScpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZHJhd1NoYXBlKHZpc3VhbHMsIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZHJhd0Nvbm5lY3Rpb24odmlzdWFscywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbihbICdyZW5kZXIuZ2V0U2hhcGVQYXRoJywgJ3JlbmRlci5nZXRDb25uZWN0aW9uUGF0aCddLCByZW5kZXJQcmlvcml0eSwgZnVuY3Rpb24oZXZ0LCBlbGVtZW50KSB7XG4gICAgaWYgKHNlbGYuY2FuUmVuZGVyKGVsZW1lbnQpKSB7XG4gICAgICBpZiAoZXZ0LnR5cGUgPT09ICdyZW5kZXIuZ2V0U2hhcGVQYXRoJykge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRTaGFwZVBhdGgoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXRDb25uZWN0aW9uUGF0aChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNob3VsZCBjaGVjayB3aGV0aGVyICp0aGlzKiByZW5kZXJlciBjYW4gcmVuZGVyXG4gKiB0aGUgZWxlbWVudC9jb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmNhblJlbmRlciA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogUHJvdmlkZXMgdGhlIHNoYXBlJ3Mgc25hcCBzdmcgZWxlbWVudCB0byBiZSBkcmF3biBvbiB0aGUgYGNhbnZhc2AuXG4gKlxuICogQHBhcmFtIHtkanMuR3JhcGhpY3N9IHZpc3VhbHNcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gKlxuICogQHJldHVybnMge1NuYXAuc3ZnfSBbcmV0dXJucyBhIFNuYXAuc3ZnIHBhcGVyIGVsZW1lbnQgXVxuICovXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdTaGFwZSA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogUHJvdmlkZXMgdGhlIHNoYXBlJ3Mgc25hcCBzdmcgZWxlbWVudCB0byBiZSBkcmF3biBvbiB0aGUgYGNhbnZhc2AuXG4gKlxuICogQHBhcmFtIHtkanMuR3JhcGhpY3N9IHZpc3VhbHNcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICpcbiAqIEByZXR1cm5zIHtTbmFwLnN2Z30gW3JldHVybnMgYSBTbmFwLnN2ZyBwYXBlciBlbGVtZW50IF1cbiAqL1xuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogR2V0cyB0aGUgU1ZHIHBhdGggb2YgYSBzaGFwZSB0aGF0IHJlcHJlc2VudHMgaXQncyB2aXN1YWwgYm91bmRzLlxuICpcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBzdmcgcGF0aFxuICovXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmdldFNoYXBlUGF0aCA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogR2V0cyB0aGUgU1ZHIHBhdGggb2YgYSBjb25uZWN0aW9uIHRoYXQgcmVwcmVzZW50cyBpdCdzIHZpc3VhbCBib3VuZHMuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBzdmcgcGF0aFxuICovXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmdldENvbm5lY3Rpb25QYXRoID0gZnVuY3Rpb24oKSB7fTtcbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBCYXNlUmVuZGVyZXIgZnJvbSAnLi9CYXNlUmVuZGVyZXInO1xuXG5pbXBvcnQge1xuICBjb21wb25lbnRzVG9QYXRoLFxuICBjcmVhdGVMaW5lXG59IGZyb20gJy4uL3V0aWwvUmVuZGVyVXRpbCc7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7XG4gIGlzRnJhbWVFbGVtZW50XG59IGZyb20gJy4uL3V0aWwvRWxlbWVudHMnO1xuXG4vLyBhcHBseSBkZWZhdWx0IHJlbmRlcmVyIHdpdGggbG93ZXN0IHBvc3NpYmxlIHByaW9yaXR5XG4vLyBzbyB0aGF0IGl0IG9ubHkga2lja3MgaW4gaWYgbm9vbmUgZWxzZSBjb3VsZCByZW5kZXJcbnZhciBERUZBVUxUX1JFTkRFUl9QUklPUklUWSA9IDE7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgcmVuZGVyZXIgdXNlZCBmb3Igc2hhcGVzIGFuZCBjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtTdHlsZXN9IHN0eWxlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0UmVuZGVyZXIoZXZlbnRCdXMsIHN0eWxlcykge1xuXG4gIC8vXG4gIEJhc2VSZW5kZXJlci5jYWxsKHRoaXMsIGV2ZW50QnVzLCBERUZBVUxUX1JFTkRFUl9QUklPUklUWSk7XG5cbiAgdGhpcy5DT05ORUNUSU9OX1NUWUxFID0gc3R5bGVzLnN0eWxlKFsgJ25vLWZpbGwnIF0sIHsgc3Ryb2tlV2lkdGg6IDUsIHN0cm9rZTogJ2Z1Y2hzaWEnIH0pO1xuICB0aGlzLlNIQVBFX1NUWUxFID0gc3R5bGVzLnN0eWxlKHsgZmlsbDogJ3doaXRlJywgc3Ryb2tlOiAnZnVjaHNpYScsIHN0cm9rZVdpZHRoOiAyIH0pO1xuICB0aGlzLkZSQU1FX1NUWUxFID0gc3R5bGVzLnN0eWxlKFsgJ25vLWZpbGwnIF0sIHsgc3Ryb2tlOiAnZnVjaHNpYScsIHN0cm9rZURhc2hhcnJheTogNCwgc3Ryb2tlV2lkdGg6IDIgfSk7XG59XG5cbmluaGVyaXRzKERlZmF1bHRSZW5kZXJlciwgQmFzZVJlbmRlcmVyKTtcblxuXG5EZWZhdWx0UmVuZGVyZXIucHJvdG90eXBlLmNhblJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkRlZmF1bHRSZW5kZXJlci5wcm90b3R5cGUuZHJhd1NoYXBlID0gZnVuY3Rpb24gZHJhd1NoYXBlKHZpc3VhbHMsIGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcblxuICBzdmdBdHRyKHJlY3QsIHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IGVsZW1lbnQud2lkdGggfHwgMCxcbiAgICBoZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0IHx8IDBcbiAgfSk7XG5cbiAgaWYgKGlzRnJhbWVFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgc3ZnQXR0cihyZWN0LCB0aGlzLkZSQU1FX1NUWUxFKTtcbiAgfSBlbHNlIHtcbiAgICBzdmdBdHRyKHJlY3QsIHRoaXMuU0hBUEVfU1RZTEUpO1xuICB9XG5cbiAgc3ZnQXBwZW5kKHZpc3VhbHMsIHJlY3QpO1xuXG4gIHJldHVybiByZWN0O1xufTtcblxuRGVmYXVsdFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIGRyYXdDb25uZWN0aW9uKHZpc3VhbHMsIGNvbm5lY3Rpb24pIHtcblxuICB2YXIgbGluZSA9IGNyZWF0ZUxpbmUoY29ubmVjdGlvbi53YXlwb2ludHMsIHRoaXMuQ09OTkVDVElPTl9TVFlMRSk7XG4gIHN2Z0FwcGVuZCh2aXN1YWxzLCBsaW5lKTtcblxuICByZXR1cm4gbGluZTtcbn07XG5cbkRlZmF1bHRSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2hhcGVQYXRoID0gZnVuY3Rpb24gZ2V0U2hhcGVQYXRoKHNoYXBlKSB7XG5cbiAgdmFyIHggPSBzaGFwZS54LFxuICAgICAgeSA9IHNoYXBlLnksXG4gICAgICB3aWR0aCA9IHNoYXBlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuXG4gIHZhciBzaGFwZVBhdGggPSBbXG4gICAgWydNJywgeCwgeV0sXG4gICAgWydsJywgd2lkdGgsIDBdLFxuICAgIFsnbCcsIDAsIGhlaWdodF0sXG4gICAgWydsJywgLXdpZHRoLCAwXSxcbiAgICBbJ3onXVxuICBdO1xuXG4gIHJldHVybiBjb21wb25lbnRzVG9QYXRoKHNoYXBlUGF0aCk7XG59O1xuXG5EZWZhdWx0UmVuZGVyZXIucHJvdG90eXBlLmdldENvbm5lY3Rpb25QYXRoID0gZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblBhdGgoY29ubmVjdGlvbikge1xuICB2YXIgd2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHM7XG5cbiAgdmFyIGlkeCwgcG9pbnQsIGNvbm5lY3Rpb25QYXRoID0gW107XG5cbiAgZm9yIChpZHggPSAwOyAocG9pbnQgPSB3YXlwb2ludHNbaWR4XSk7IGlkeCsrKSB7XG5cbiAgICAvLyB0YWtlIGludmlzaWJsZSBkb2NraW5nIGludG8gYWNjb3VudFxuICAgIC8vIHdoZW4gY3JlYXRpbmcgdGhlIHBhdGhcbiAgICBwb2ludCA9IHBvaW50Lm9yaWdpbmFsIHx8IHBvaW50O1xuXG4gICAgY29ubmVjdGlvblBhdGgucHVzaChbIGlkeCA9PT0gMCA/ICdNJyA6ICdMJywgcG9pbnQueCwgcG9pbnQueSBdKTtcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzVG9QYXRoKGNvbm5lY3Rpb25QYXRoKTtcbn07XG5cblxuRGVmYXVsdFJlbmRlcmVyLiRpbmplY3QgPSBbICdldmVudEJ1cycsICdzdHlsZXMnIF07XG4iLCJpbXBvcnQge1xuICBpc0FycmF5LFxuICBhc3NpZ24sXG4gIHJlZHVjZVxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxuLyoqXG4gKiBBIGNvbXBvbmVudCB0aGF0IG1hbmFnZXMgc2hhcGUgc3R5bGVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN0eWxlcygpIHtcblxuICB2YXIgZGVmYXVsdFRyYWl0cyA9IHtcblxuICAgICduby1maWxsJzoge1xuICAgICAgZmlsbDogJ25vbmUnXG4gICAgfSxcbiAgICAnbm8tYm9yZGVyJzoge1xuICAgICAgc3Ryb2tlT3BhY2l0eTogMC4wXG4gICAgfSxcbiAgICAnbm8tZXZlbnRzJzoge1xuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgfVxuICB9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvKipcbiAgICogQnVpbGRzIGEgc3R5bGUgZGVmaW5pdGlvbiBmcm9tIGEgY2xhc3NOYW1lLCBhIGxpc3Qgb2YgdHJhaXRzIGFuZCBhbiBvYmplY3Qgb2YgYWRkaXRpb25hbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcGFyYW0gIHtBcnJheTxzdHJpbmc+fSB0cmFpdHNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBhZGRpdGlvbmFsQXR0cnNcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgc3R5bGUgZGVmaW50aW9uXG4gICAqL1xuICB0aGlzLmNscyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSwgdHJhaXRzLCBhZGRpdGlvbmFsQXR0cnMpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLnN0eWxlKHRyYWl0cywgYWRkaXRpb25hbEF0dHJzKTtcblxuICAgIHJldHVybiBhc3NpZ24oYXR0cnMsIHsgJ2NsYXNzJzogY2xhc3NOYW1lIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBzdHlsZSBkZWZpbml0aW9uIGZyb20gYSBsaXN0IG9mIHRyYWl0cyBhbmQgYW4gb2JqZWN0IG9mIGFkZGl0aW9uYWwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPn0gdHJhaXRzXG4gICAqIEBwYXJhbSAge09iamVjdH0gYWRkaXRpb25hbEF0dHJzXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHN0eWxlIGRlZmludGlvblxuICAgKi9cbiAgdGhpcy5zdHlsZSA9IGZ1bmN0aW9uKHRyYWl0cywgYWRkaXRpb25hbEF0dHJzKSB7XG5cbiAgICBpZiAoIWlzQXJyYXkodHJhaXRzKSAmJiAhYWRkaXRpb25hbEF0dHJzKSB7XG4gICAgICBhZGRpdGlvbmFsQXR0cnMgPSB0cmFpdHM7XG4gICAgICB0cmFpdHMgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgYXR0cnMgPSByZWR1Y2UodHJhaXRzLCBmdW5jdGlvbihhdHRycywgdCkge1xuICAgICAgcmV0dXJuIGFzc2lnbihhdHRycywgZGVmYXVsdFRyYWl0c1t0XSB8fCB7fSk7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIGFkZGl0aW9uYWxBdHRycyA/IGFzc2lnbihhdHRycywgYWRkaXRpb25hbEF0dHJzKSA6IGF0dHJzO1xuICB9O1xuXG4gIHRoaXMuY29tcHV0ZVN0eWxlID0gZnVuY3Rpb24oY3VzdG9tLCB0cmFpdHMsIGRlZmF1bHRTdHlsZXMpIHtcbiAgICBpZiAoIWlzQXJyYXkodHJhaXRzKSkge1xuICAgICAgZGVmYXVsdFN0eWxlcyA9IHRyYWl0cztcbiAgICAgIHRyYWl0cyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLnN0eWxlKHRyYWl0cyB8fCBbXSwgYXNzaWduKHt9LCBkZWZhdWx0U3R5bGVzLCBjdXN0b20gfHwge30pKTtcbiAgfTtcbn1cbiIsImltcG9ydCBEZWZhdWx0UmVuZGVyZXIgZnJvbSAnLi9EZWZhdWx0UmVuZGVyZXInO1xuaW1wb3J0IFN0eWxlcyBmcm9tICcuL1N0eWxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ2RlZmF1bHRSZW5kZXJlcicgXSxcbiAgZGVmYXVsdFJlbmRlcmVyOiBbICd0eXBlJywgRGVmYXVsdFJlbmRlcmVyIF0sXG4gIHN0eWxlczogWyAndHlwZScsIFN0eWxlcyBdXG59O1xuIiwiaW1wb3J0IHtcbiAgZmlsdGVyLFxuICBmb3JFYWNoLFxuICBzb3J0Qnlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5mdW5jdGlvbiBsYXN0KGFycikge1xuICByZXR1cm4gYXJyICYmIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHNvcnRUb3BPck1pZGRsZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lnk7XG59XG5cbmZ1bmN0aW9uIHNvcnRMZWZ0T3JDZW50ZXIoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC54O1xufVxuXG4vKipcbiAqIFNvcnRpbmcgZnVuY3Rpb25zIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgYWxpZ25tZW50XG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xudmFyIEFMSUdOTUVOVF9TT1JUSU5HID0ge1xuICBsZWZ0OiBzb3J0TGVmdE9yQ2VudGVyLFxuICBjZW50ZXI6IHNvcnRMZWZ0T3JDZW50ZXIsXG4gIHJpZ2h0OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQueCArIGVsZW1lbnQud2lkdGg7XG4gIH0sXG4gIHRvcDogc29ydFRvcE9yTWlkZGxlLFxuICBtaWRkbGU6IHNvcnRUb3BPck1pZGRsZSxcbiAgYm90dG9tOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQueSArIGVsZW1lbnQuaGVpZ2h0O1xuICB9XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFsaWduRWxlbWVudHMobW9kZWxpbmcpIHtcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbn1cblxuQWxpZ25FbGVtZW50cy4kaW5qZWN0ID0gWyAnbW9kZWxpbmcnIF07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHJlbGV2YW50IFwiYXhpc1wiIGFuZCBcImRpbWVuc2lvblwiIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnQgdHlwZSBvZiBhbGlnbm1lbnRcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgbGVmdHxyaWdodHxjZW50ZXJ8dG9wfGJvdHRvbXxtaWRkbGVcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHsgYXhpcywgZGltZW5zaW9uIH1cbiAqL1xuQWxpZ25FbGVtZW50cy5wcm90b3R5cGUuX2dldE9yaWVudGF0aW9uRGV0YWlscyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHZlcnRpY2FsID0gWyAndG9wJywgJ2JvdHRvbScsICdtaWRkbGUnIF0sXG4gICAgICBheGlzID0gJ3gnLFxuICAgICAgZGltZW5zaW9uID0gJ3dpZHRoJztcblxuICBpZiAodmVydGljYWwuaW5kZXhPZih0eXBlKSAhPT0gLTEpIHtcbiAgICBheGlzID0gJ3knO1xuICAgIGRpbWVuc2lvbiA9ICdoZWlnaHQnO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBheGlzOiBheGlzLFxuICAgIGRpbWVuc2lvbjogZGltZW5zaW9uXG4gIH07XG59O1xuXG5BbGlnbkVsZW1lbnRzLnByb3RvdHlwZS5faXNUeXBlID0gZnVuY3Rpb24odHlwZSwgdHlwZXMpIHtcbiAgcmV0dXJuIHR5cGVzLmluZGV4T2YodHlwZSkgIT09IC0xO1xufTtcblxuLyoqXG4gKiBHZXQgYSBwb2ludCBvbiB0aGUgcmVsZXZhbnQgYXhpcyB3aGVyZSBlbGVtZW50cyBzaG91bGQgYWxpZ24gdG9cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgbGVmdHxyaWdodHxjZW50ZXJ8dG9wfGJvdHRvbXxtaWRkbGVcbiAqIEBwYXJhbSAge0FycmF5fSBzb3J0ZWRFbGVtZW50c1xuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuQWxpZ25FbGVtZW50cy5wcm90b3R5cGUuX2FsaWdubWVudFBvc2l0aW9uID0gZnVuY3Rpb24odHlwZSwgc29ydGVkRWxlbWVudHMpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5fZ2V0T3JpZW50YXRpb25EZXRhaWxzKHR5cGUpLFxuICAgICAgYXhpcyA9IG9yaWVudGF0aW9uLmF4aXMsXG4gICAgICBkaW1lbnNpb24gPSBvcmllbnRhdGlvbi5kaW1lbnNpb24sXG4gICAgICBhbGlnbm1lbnQgPSB7fSxcbiAgICAgIGNlbnRlcnMgPSB7fSxcbiAgICAgIGhhc1NoYXJlZENlbnRlcnMgPSBmYWxzZSxcbiAgICAgIGNlbnRlcmVkRWxlbWVudHMsXG4gICAgICBmaXJzdEVsZW1lbnQsXG4gICAgICBsYXN0RWxlbWVudDtcblxuICBmdW5jdGlvbiBnZXRNaWRkbGVPclRvcChmaXJzdCwgbGFzdCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKChmaXJzdFtheGlzXSArIGxhc3RbYXhpc10gKyBsYXN0W2RpbWVuc2lvbl0pIC8gMik7XG4gIH1cblxuICBpZiAodGhpcy5faXNUeXBlKHR5cGUsIFsgJ2xlZnQnLCAndG9wJyBdKSkge1xuICAgIGFsaWdubWVudFt0eXBlXSA9IHNvcnRlZEVsZW1lbnRzWzBdW2F4aXNdO1xuXG4gIH0gZWxzZSBpZiAodGhpcy5faXNUeXBlKHR5cGUsIFsgJ3JpZ2h0JywgJ2JvdHRvbScgXSkpIHtcbiAgICBsYXN0RWxlbWVudCA9IGxhc3Qoc29ydGVkRWxlbWVudHMpO1xuXG4gICAgYWxpZ25tZW50W3R5cGVdID0gbGFzdEVsZW1lbnRbYXhpc10gKyBsYXN0RWxlbWVudFtkaW1lbnNpb25dO1xuXG4gIH0gZWxzZSBpZiAodGhpcy5faXNUeXBlKHR5cGUsIFsgJ2NlbnRlcicsICdtaWRkbGUnIF0pKSB7XG5cbiAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIGNlbnRlciBzaGFyZWQgYnkgbW9yZSB0aGFuIG9uZSBzaGFwZVxuICAgIC8vIGlmIG5vdCwganVzdCB0YWtlIHRoZSBtaWRkbGUgb2YgdGhlIHJhbmdlXG4gICAgZm9yRWFjaChzb3J0ZWRFbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdmFyIGNlbnRlciA9IGVsZW1lbnRbYXhpc10gKyBNYXRoLnJvdW5kKGVsZW1lbnRbZGltZW5zaW9uXSAvIDIpO1xuXG4gICAgICBpZiAoY2VudGVyc1tjZW50ZXJdKSB7XG4gICAgICAgIGNlbnRlcnNbY2VudGVyXS5lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VudGVyc1tjZW50ZXJdID0ge1xuICAgICAgICAgIGVsZW1lbnRzOiBbIGVsZW1lbnQgXSxcbiAgICAgICAgICBjZW50ZXI6IGNlbnRlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY2VudGVyZWRFbGVtZW50cyA9IHNvcnRCeShjZW50ZXJzLCBmdW5jdGlvbihjZW50ZXIpIHtcbiAgICAgIGlmIChjZW50ZXIuZWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBoYXNTaGFyZWRDZW50ZXJzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNlbnRlci5lbGVtZW50cy5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICBpZiAoaGFzU2hhcmVkQ2VudGVycykge1xuICAgICAgYWxpZ25tZW50W3R5cGVdID0gbGFzdChjZW50ZXJlZEVsZW1lbnRzKS5jZW50ZXI7XG5cbiAgICAgIHJldHVybiBhbGlnbm1lbnQ7XG4gICAgfVxuXG4gICAgZmlyc3RFbGVtZW50ID0gc29ydGVkRWxlbWVudHNbMF07XG5cbiAgICBzb3J0ZWRFbGVtZW50cyA9IHNvcnRCeShzb3J0ZWRFbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRbYXhpc10gKyBlbGVtZW50W2RpbWVuc2lvbl07XG4gICAgfSk7XG5cbiAgICBsYXN0RWxlbWVudCA9IGxhc3Qoc29ydGVkRWxlbWVudHMpO1xuXG4gICAgYWxpZ25tZW50W3R5cGVdID0gZ2V0TWlkZGxlT3JUb3AoZmlyc3RFbGVtZW50LCBsYXN0RWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gYWxpZ25tZW50O1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgYWxpZ25tZW50IG9mIGEgc2VsZWN0aW9uIG9mIGVsZW1lbnRzXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGVsZW1lbnRzIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZSBsZWZ0fHJpZ2h0fGNlbnRlcnx0b3B8Ym90dG9tfG1pZGRsZVxuICovXG5BbGlnbkVsZW1lbnRzLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oZWxlbWVudHMsIHR5cGUpIHtcbiAgdmFyIG1vZGVsaW5nID0gdGhpcy5fbW9kZWxpbmc7XG5cbiAgdmFyIGZpbHRlcmVkRWxlbWVudHMgPSBmaWx0ZXIoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50LndheXBvaW50cyB8fCBlbGVtZW50Lmhvc3QgfHwgZWxlbWVudC5sYWJlbFRhcmdldCk7XG4gIH0pO1xuXG4gIGlmIChmaWx0ZXJlZEVsZW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc29ydEZuID0gQUxJR05NRU5UX1NPUlRJTkdbdHlwZV07XG5cbiAgdmFyIHNvcnRlZEVsZW1lbnRzID0gc29ydEJ5KGZpbHRlcmVkRWxlbWVudHMsIHNvcnRGbik7XG5cbiAgdmFyIGFsaWdubWVudCA9IHRoaXMuX2FsaWdubWVudFBvc2l0aW9uKHR5cGUsIHNvcnRlZEVsZW1lbnRzKTtcblxuICBtb2RlbGluZy5hbGlnbkVsZW1lbnRzKHNvcnRlZEVsZW1lbnRzLCBhbGlnbm1lbnQpO1xufTtcbiIsImltcG9ydCBBbGlnbkVsZW1lbnRzIGZyb20gJy4vQWxpZ25FbGVtZW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ2FsaWduRWxlbWVudHMnIF0sXG4gIGFsaWduRWxlbWVudHM6IFsgJ3R5cGUnLCBBbGlnbkVsZW1lbnRzIF1cbn07XG4iLCJpbXBvcnQge1xuICBmbGF0dGVuLFxuICBmaWx0ZXIsXG4gIGZvckVhY2gsXG4gIGdyb3VwQnksXG4gIG1hcCxcbiAgdW5pb25CeVxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7IHNhdmVDbGVhciB9IGZyb20gJy4uLy4uL3V0aWwvUmVtb3ZhbCc7XG5cbmltcG9ydCB7IGdldE5ld0F0dGFjaFNoYXBlRGVsdGEgfSBmcm9tICcuLi8uLi91dGlsL0F0dGFjaFV0aWwnO1xuXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgQ29tbWFuZEludGVyY2VwdG9yIGZyb20gJy4uLy4uL2NvbW1hbmQvQ29tbWFuZEludGVyY2VwdG9yJztcblxudmFyIExPV19QUklPUklUWSA9IDI1MSxcbiAgICBISUdIX1BSSU9SSVRZID0gMTQwMTtcblxudmFyIE1BUktFUl9BVFRBQ0ggPSAnYXR0YWNoLW9rJztcblxuXG4vKipcbiAqIEFkZHMgdGhlIG5vdGlvbiBvZiBhdHRhY2hlZCBlbGVtZW50cyB0byB0aGUgbW9kZWxlci5cbiAqXG4gKiBPcHRpb25hbGx5IGRlcGVuZHMgb24gYGRpYWdyYW0tanMvbGliL2ZlYXR1cmVzL21vdmVgIHRvIHJlbmRlclxuICogdGhlIGF0dGFjaGVkIGVsZW1lbnRzIGR1cmluZyBtb3ZlIHByZXZpZXcuXG4gKlxuICogT3B0aW9uYWxseSBkZXBlbmRzIG9uIGBkaWFncmFtLWpzL2xpYi9mZWF0dXJlcy9sYWJlbC1zdXBwb3J0YFxuICogdG8gcmVuZGVyIGF0dGFjaGVkIGxhYmVscyBkdXJpbmcgbW92ZSBwcmV2aWV3LlxuICpcbiAqIEBwYXJhbSB7ZGlkaS5JbmplY3Rvcn0gaW5qZWN0b3JcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKiBAcGFyYW0ge1J1bGVzfSBydWxlc1xuICogQHBhcmFtIHtNb2RlbGluZ30gbW9kZWxpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXR0YWNoU3VwcG9ydChpbmplY3RvciwgZXZlbnRCdXMsIGNhbnZhcywgcnVsZXMsIG1vZGVsaW5nKSB7XG5cbiAgQ29tbWFuZEludGVyY2VwdG9yLmNhbGwodGhpcywgZXZlbnRCdXMpO1xuXG4gIHZhciBtb3ZlUHJldmlldyA9IGluamVjdG9yLmdldCgnbW92ZVByZXZpZXcnLCBmYWxzZSk7XG5cblxuICAvLyByZW1vdmUgYWxsIHRoZSBhdHRhY2hlZCBlbGVtZW50cyBmcm9tIHRoZSBzaGFwZXMgdG8gYmUgdmFsaWRhdGVkXG4gIC8vIGFkZCBhbGwgdGhlIGF0dGFjaGVkIHNoYXBlcyB0byB0aGUgb3ZlcmFsbCBsaXN0IG9mIG1vdmVkIHNoYXBlc1xuICBldmVudEJ1cy5vbignc2hhcGUubW92ZS5zdGFydCcsIEhJR0hfUFJJT1JJVFksIGZ1bmN0aW9uKGUpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBzaGFwZXMgPSBjb250ZXh0LnNoYXBlcyxcbiAgICAgICAgdmFsaWRhdGVkU2hhcGVzID0gY29udGV4dC52YWxpZGF0ZWRTaGFwZXM7XG5cbiAgICBjb250ZXh0LnNoYXBlcyA9IGFkZEF0dGFjaGVkKHNoYXBlcyk7XG5cbiAgICBjb250ZXh0LnZhbGlkYXRlZFNoYXBlcyA9IHJlbW92ZUF0dGFjaGVkKHZhbGlkYXRlZFNoYXBlcyk7XG4gIH0pO1xuXG4gIC8vIGFkZCBhdHRhY2hlcnMgdG8gdGhlIHZpc3VhbCdzIGdyb3VwXG4gIG1vdmVQcmV2aWV3ICYmIGV2ZW50QnVzLm9uKCdzaGFwZS5tb3ZlLnN0YXJ0JywgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihlKSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGUuY29udGV4dCxcbiAgICAgICAgc2hhcGVzID0gY29udGV4dC5zaGFwZXMsXG4gICAgICAgIGF0dGFjaGVycyA9IGdldEF0dGFjaGVycyhzaGFwZXMpO1xuXG4gICAgZm9yRWFjaChhdHRhY2hlcnMsIGZ1bmN0aW9uKGF0dGFjaGVyKSB7XG4gICAgICBtb3ZlUHJldmlldy5tYWtlRHJhZ2dhYmxlKGNvbnRleHQsIGF0dGFjaGVyLCB0cnVlKTtcblxuICAgICAgZm9yRWFjaChhdHRhY2hlci5sYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgIG1vdmVQcmV2aWV3Lm1ha2VEcmFnZ2FibGUoY29udGV4dCwgbGFiZWwsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGFkZCBhdHRhY2gtb2sgbWFya2VyIHRvIGN1cnJlbnQgaG9zdFxuICBtb3ZlUHJldmlldyAmJiBldmVudEJ1cy5vbignc2hhcGUubW92ZS5zdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBzaGFwZXMgPSBjb250ZXh0LnNoYXBlcztcblxuICAgIGlmIChzaGFwZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlID0gc2hhcGVzWzBdO1xuXG4gICAgdmFyIGhvc3QgPSBzaGFwZS5ob3N0O1xuXG4gICAgaWYgKGhvc3QpIHtcbiAgICAgIGNhbnZhcy5hZGRNYXJrZXIoaG9zdCwgTUFSS0VSX0FUVEFDSCk7XG5cbiAgICAgIGV2ZW50QnVzLm9uY2UoW1xuICAgICAgICAnc2hhcGUubW92ZS5vdXQnLFxuICAgICAgICAnc2hhcGUubW92ZS5jbGVhbnVwJ1xuICAgICAgXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoaG9zdCwgTUFSS0VSX0FUVEFDSCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGFkZCBhbGwgYXR0YWNoZXJzIHRvIG1vdmUgY2xvc3VyZVxuICB0aGlzLnByZUV4ZWN1dGVkKCdlbGVtZW50cy5tb3ZlJywgSElHSF9QUklPUklUWSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBjbG9zdXJlID0gY29udGV4dC5jbG9zdXJlLFxuICAgICAgICBzaGFwZXMgPSBjb250ZXh0LnNoYXBlcyxcbiAgICAgICAgYXR0YWNoZXJzID0gZ2V0QXR0YWNoZXJzKHNoYXBlcyk7XG5cbiAgICBmb3JFYWNoKGF0dGFjaGVycywgZnVuY3Rpb24oYXR0YWNoZXIpIHtcbiAgICAgIGNsb3N1cmUuYWRkKGF0dGFjaGVyLCBjbG9zdXJlLnRvcExldmVsW2F0dGFjaGVyLmhvc3QuaWRdKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gcGVyZm9ybSB0aGUgYXR0YWNoaW5nIGFmdGVyIHNoYXBlcyBhcmUgZG9uZSBtb3ZpbmdcbiAgdGhpcy5wb3N0RXhlY3V0ZWQoJ2VsZW1lbnRzLm1vdmUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGUuY29udGV4dCxcbiAgICAgICAgc2hhcGVzID0gY29udGV4dC5zaGFwZXMsXG4gICAgICAgIG5ld0hvc3QgPSBjb250ZXh0Lm5ld0hvc3QsXG4gICAgICAgIGF0dGFjaGVycztcblxuICAgIC8vIG9ubHkgc2luZ2xlIGVsZW1lbnRzIGNhbiBiZSBhdHRhY2hlZFxuICAgIC8vIG11bHRpcGx5IGVsZW1lbnRzIGNhbiBiZSBkZXRhY2hlZFxuICAgIGlmIChuZXdIb3N0ICYmIHNoYXBlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV3SG9zdCkge1xuICAgICAgYXR0YWNoZXJzID0gc2hhcGVzO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGZpbmQgYXR0YWNoZXJzIG1vdmVkIHdpdGhvdXQgaG9zdFxuICAgICAgYXR0YWNoZXJzID0gZmlsdGVyKHNoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgdmFyIGhvc3QgPSBzaGFwZS5ob3N0O1xuXG4gICAgICAgIHJldHVybiBpc0F0dGFjaGVyKHNoYXBlKSAmJiAhaW5jbHVkZXMoc2hhcGVzLCBob3N0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvckVhY2goYXR0YWNoZXJzLCBmdW5jdGlvbihhdHRhY2hlcikge1xuICAgICAgbW9kZWxpbmcudXBkYXRlQXR0YWNobWVudChhdHRhY2hlciwgbmV3SG9zdCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGVuc3VyZSBpbnZhbGlkIGF0dGFjaG1lbnQgY29ubmVjdGlvbnMgYXJlIHJlbW92ZWRcbiAgdGhpcy5wb3N0RXhlY3V0ZWQoJ2VsZW1lbnRzLm1vdmUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICB2YXIgc2hhcGVzID0gZS5jb250ZXh0LnNoYXBlcztcblxuICAgIGZvckVhY2goc2hhcGVzLCBmdW5jdGlvbihzaGFwZSkge1xuXG4gICAgICBmb3JFYWNoKHNoYXBlLmF0dGFjaGVycywgZnVuY3Rpb24oYXR0YWNoZXIpIHtcblxuICAgICAgICAvLyByZW1vdmUgaW52YWxpZCBvdXRnb2luZyBjb25uZWN0aW9uc1xuICAgICAgICBmb3JFYWNoKGF0dGFjaGVyLm91dGdvaW5nLnNsaWNlKCksIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICB2YXIgYWxsb3dlZCA9IHJ1bGVzLmFsbG93ZWQoJ2Nvbm5lY3Rpb24ucmVjb25uZWN0Jywge1xuICAgICAgICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgICAgICAgIHNvdXJjZTogY29ubmVjdGlvbi5zb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQ6IGNvbm5lY3Rpb24udGFyZ2V0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgICAgIG1vZGVsaW5nLnJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZW1vdmUgaW52YWxpZCBpbmNvbWluZyBjb25uZWN0aW9uc1xuICAgICAgICBmb3JFYWNoKGF0dGFjaGVyLmluY29taW5nLnNsaWNlKCksIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICB2YXIgYWxsb3dlZCA9IHJ1bGVzLmFsbG93ZWQoJ2Nvbm5lY3Rpb24ucmVjb25uZWN0Jywge1xuICAgICAgICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgICAgICAgIHNvdXJjZTogY29ubmVjdGlvbi5zb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQ6IGNvbm5lY3Rpb24udGFyZ2V0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgICAgIG1vZGVsaW5nLnJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICB0aGlzLnBvc3RFeGVjdXRlKCdzaGFwZS5jcmVhdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNvbnRleHQgPSBlLmNvbnRleHQsXG4gICAgICAgIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgICAgaG9zdCA9IGNvbnRleHQuaG9zdDtcblxuICAgIGlmIChob3N0KSB7XG4gICAgICBtb2RlbGluZy51cGRhdGVBdHRhY2htZW50KHNoYXBlLCBob3N0KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHVwZGF0ZSBhdHRhY2htZW50cyBpZiB0aGUgaG9zdCBpcyByZXBsYWNlZFxuICB0aGlzLnBvc3RFeGVjdXRlKCdzaGFwZS5yZXBsYWNlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBlLmNvbnRleHQsXG4gICAgICAgIG9sZFNoYXBlID0gY29udGV4dC5vbGRTaGFwZSxcbiAgICAgICAgbmV3U2hhcGUgPSBjb250ZXh0Lm5ld1NoYXBlO1xuXG4gICAgLy8gbW92ZSB0aGUgYXR0YWNoZXJzIHRvIHRoZSBuZXcgaG9zdFxuICAgIHNhdmVDbGVhcihvbGRTaGFwZS5hdHRhY2hlcnMsIGZ1bmN0aW9uKGF0dGFjaGVyKSB7XG4gICAgICB2YXIgYWxsb3dlZCA9IHJ1bGVzLmFsbG93ZWQoJ2VsZW1lbnRzLm1vdmUnLCB7XG4gICAgICAgIHRhcmdldDogbmV3U2hhcGUsXG4gICAgICAgIHNoYXBlczogW2F0dGFjaGVyXVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChhbGxvd2VkID09PSAnYXR0YWNoJykge1xuICAgICAgICBtb2RlbGluZy51cGRhdGVBdHRhY2htZW50KGF0dGFjaGVyLCBuZXdTaGFwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbGluZy5yZW1vdmVTaGFwZShhdHRhY2hlcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBtb3ZlIGF0dGFjaGVycyBpZiBuZXcgaG9zdCBoYXMgZGlmZmVyZW50IHNpemVcbiAgICBpZiAobmV3U2hhcGUuYXR0YWNoZXJzLmxlbmd0aCkge1xuXG4gICAgICBmb3JFYWNoKG5ld1NoYXBlLmF0dGFjaGVycywgZnVuY3Rpb24oYXR0YWNoZXIpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gZ2V0TmV3QXR0YWNoU2hhcGVEZWx0YShhdHRhY2hlciwgb2xkU2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgICAgbW9kZWxpbmcubW92ZVNoYXBlKGF0dGFjaGVyLCBkZWx0YSwgYXR0YWNoZXIucGFyZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBtb3ZlIHNoYXBlIG9uIGhvc3QgcmVzaXplXG4gIHRoaXMucG9zdEV4ZWN1dGUoJ3NoYXBlLnJlc2l6ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIG9sZEJvdW5kcyA9IGNvbnRleHQub2xkQm91bmRzLFxuICAgICAgICBuZXdCb3VuZHMgPSBjb250ZXh0Lm5ld0JvdW5kcyxcbiAgICAgICAgYXR0YWNoZXJzID0gc2hhcGUuYXR0YWNoZXJzLFxuICAgICAgICBoaW50cyA9IGNvbnRleHQuaGludHMgfHwge307XG5cbiAgICBpZiAoaGludHMuYXR0YWNoU3VwcG9ydCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3JFYWNoKGF0dGFjaGVycywgZnVuY3Rpb24oYXR0YWNoZXIpIHtcbiAgICAgIHZhciBkZWx0YSA9IGdldE5ld0F0dGFjaFNoYXBlRGVsdGEoYXR0YWNoZXIsIG9sZEJvdW5kcywgbmV3Qm91bmRzKTtcblxuICAgICAgbW9kZWxpbmcubW92ZVNoYXBlKGF0dGFjaGVyLCBkZWx0YSwgYXR0YWNoZXIucGFyZW50KTtcblxuICAgICAgZm9yRWFjaChhdHRhY2hlci5sYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgIG1vZGVsaW5nLm1vdmVTaGFwZShsYWJlbCwgZGVsdGEsIGxhYmVsLnBhcmVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIGF0dGFjaG1lbnRzXG4gIHRoaXMucHJlRXhlY3V0ZSgnc2hhcGUuZGVsZXRlJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBzaGFwZSA9IGV2ZW50LmNvbnRleHQuc2hhcGU7XG5cbiAgICBzYXZlQ2xlYXIoc2hhcGUuYXR0YWNoZXJzLCBmdW5jdGlvbihhdHRhY2hlcikge1xuICAgICAgbW9kZWxpbmcucmVtb3ZlU2hhcGUoYXR0YWNoZXIpO1xuICAgIH0pO1xuXG4gICAgaWYgKHNoYXBlLmhvc3QpIHtcbiAgICAgIG1vZGVsaW5nLnVwZGF0ZUF0dGFjaG1lbnQoc2hhcGUsIG51bGwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmluaGVyaXRzKEF0dGFjaFN1cHBvcnQsIENvbW1hbmRJbnRlcmNlcHRvcik7XG5cbkF0dGFjaFN1cHBvcnQuJGluamVjdCA9IFtcbiAgJ2luamVjdG9yJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcycsXG4gICdydWxlcycsXG4gICdtb2RlbGluZydcbl07XG5cblxuLyoqXG4gKiBSZXR1cm4gYXR0YWNoZXJzIG9mIHRoZSBnaXZlbiBzaGFwZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gc2hhcGVzXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59XG4gKi9cbmZ1bmN0aW9uIGdldEF0dGFjaGVycyhzaGFwZXMpIHtcbiAgcmV0dXJuIGZsYXR0ZW4obWFwKHNoYXBlcywgZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzLmF0dGFjaGVycyB8fCBbXTtcbiAgfSkpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGNvbWJpbmVkIGxpc3Qgb2YgZWxlbWVudHMgYW5kXG4gKiBhdHRhY2hlcnMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGZpbHRlcmVkXG4gKi9cbmZ1bmN0aW9uIGFkZEF0dGFjaGVkKGVsZW1lbnRzKSB7XG4gIHZhciBhdHRhY2hlcnMgPSBnZXRBdHRhY2hlcnMoZWxlbWVudHMpO1xuXG4gIHJldHVybiB1bmlvbkJ5KCdpZCcsIGVsZW1lbnRzLCBhdHRhY2hlcnMpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZpbHRlcmVkIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCBkbyBub3RcbiAqIGNvbnRhaW4gYXR0YWNoZWQgZWxlbWVudHMgd2l0aCBob3N0cyBiZWluZyBwYXJ0XG4gKiBvZiB0aGUgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSAge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZWxlbWVudHNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGZpbHRlcmVkXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUF0dGFjaGVkKGVsZW1lbnRzKSB7XG5cbiAgdmFyIGlkcyA9IGdyb3VwQnkoZWxlbWVudHMsICdpZCcpO1xuXG4gIHJldHVybiBmaWx0ZXIoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB3aGlsZSAoZWxlbWVudCkge1xuXG4gICAgICAvLyBob3N0IGluIHNlbGVjdGlvblxuICAgICAgaWYgKGVsZW1lbnQuaG9zdCAmJiBpZHNbZWxlbWVudC5ob3N0LmlkXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzQXR0YWNoZXIoc2hhcGUpIHtcbiAgcmV0dXJuICEhc2hhcGUuaG9zdDtcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIGl0ZW0pIHtcbiAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufSIsImltcG9ydCBSdWxlc01vZHVsZSBmcm9tICcuLi9ydWxlcyc7XG5cbmltcG9ydCBBdHRhY2hTdXBwb3J0IGZyb20gJy4vQXR0YWNoU3VwcG9ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBSdWxlc01vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAnYXR0YWNoU3VwcG9ydCcgXSxcbiAgYXR0YWNoU3VwcG9ydDogWyAndHlwZScsIEF0dGFjaFN1cHBvcnQgXVxufTtcbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgdG9Qb2ludFxufSBmcm9tICcuLi8uLi91dGlsL0V2ZW50JztcblxuXG4vKipcbiAqIEluaXRpYXRlcyBjYW52YXMgc2Nyb2xsaW5nIGlmIGN1cnJlbnQgY3Vyc29yIHBvaW50IGlzIGNsb3NlIHRvIGEgYm9yZGVyLlxuICogQ2FuY2VsbGVkIHdoZW4gY3VycmVudCBwb2ludCBtb3ZlcyBiYWNrIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGJvcmRlcnNcbiAqIG9yIGNhbmNlbGxlZCBtYW51YWxseS5cbiAqXG4gKiBEZWZhdWx0IG9wdGlvbnMgOlxuICogICBzY3JvbGxUaHJlc2hvbGRJbjogWyAyMCwgMjAsIDIwLCAyMCBdLFxuICogICBzY3JvbGxUaHJlc2hvbGRPdXQ6IFsgMCwgMCwgMCwgMCBdLFxuICogICBzY3JvbGxSZXBlYXRUaW1lb3V0OiAxNSxcbiAqICAgc2Nyb2xsU3RlcDogMTBcbiAqXG4gKiBUaHJlc2hvbGQgb3JkZXI6XG4gKiAgIFsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIF1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXV0b1Njcm9sbChjb25maWcsIGV2ZW50QnVzLCBjYW52YXMpIHtcblxuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG5cbiAgdGhpcy5fb3B0cyA9IGFzc2lnbih7XG4gICAgc2Nyb2xsVGhyZXNob2xkSW46IFsgMjAsIDIwLCAyMCwgMjAgXSxcbiAgICBzY3JvbGxUaHJlc2hvbGRPdXQ6IFsgMCwgMCwgMCwgMCBdLFxuICAgIHNjcm9sbFJlcGVhdFRpbWVvdXQ6IDE1LFxuICAgIHNjcm9sbFN0ZXA6IDEwXG4gIH0sIGNvbmZpZyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGV2ZW50QnVzLm9uKCdkcmFnLm1vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHBvaW50ID0gc2VsZi5fdG9Cb3JkZXJQb2ludChlKTtcblxuICAgIHNlbGYuc3RhcnRTY3JvbGwocG9pbnQpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbihbICdkcmFnLmNsZWFudXAnIF0sIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuc3RvcFNjcm9sbCgpO1xuICB9KTtcbn1cblxuQXV0b1Njcm9sbC4kaW5qZWN0ID0gW1xuICAnY29uZmlnLmF1dG9TY3JvbGwnLFxuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJ1xuXTtcblxuXG4vKipcbiAqIFN0YXJ0cyBzY3JvbGxpbmcgbG9vcC5cbiAqIFBvaW50IGlzIGdpdmVuIGluIGdsb2JhbCBzY2FsZSBpbiBjYW52YXMgY29udGFpbmVyIGJveCBwbGFuZS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBvaW50IHsgeDogWCwgeTogWSB9XG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLnN0YXJ0U2Nyb2xsID0gZnVuY3Rpb24ocG9pbnQpIHtcblxuICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgY2xpZW50UmVjdCA9IGNhbnZhcy5nZXRDb250YWluZXIoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICB2YXIgZGlmZiA9IFtcbiAgICBwb2ludC54LFxuICAgIHBvaW50LnksXG4gICAgY2xpZW50UmVjdC53aWR0aCAtIHBvaW50LngsXG4gICAgY2xpZW50UmVjdC5oZWlnaHQgLSBwb2ludC55XG4gIF07XG5cbiAgdGhpcy5zdG9wU2Nyb2xsKCk7XG5cbiAgdmFyIGR4ID0gMCxcbiAgICAgIGR5ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGlmIChiZXR3ZWVuKGRpZmZbaV0sIG9wdHMuc2Nyb2xsVGhyZXNob2xkT3V0W2ldLCBvcHRzLnNjcm9sbFRocmVzaG9sZEluW2ldKSkge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgZHggPSBvcHRzLnNjcm9sbFN0ZXA7XG4gICAgICB9IGVsc2UgaWYgKGkgPT0gMSkge1xuICAgICAgICBkeSA9IG9wdHMuc2Nyb2xsU3RlcDtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PSAyKSB7XG4gICAgICAgIGR4ID0gLW9wdHMuc2Nyb2xsU3RlcDtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PSAzKSB7XG4gICAgICAgIGR5ID0gLW9wdHMuc2Nyb2xsU3RlcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcbiAgICBjYW52YXMuc2Nyb2xsKHsgZHg6IGR4LCBkeTogZHkgfSk7XG5cbiAgICB0aGlzLl9zY3JvbGxpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5zdGFydFNjcm9sbChwb2ludCk7XG4gICAgfSwgb3B0cy5zY3JvbGxSZXBlYXRUaW1lb3V0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmV0d2Vlbih2YWwsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0IDwgdmFsICYmIHZhbCA8IGVuZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogU3RvcHMgc2Nyb2xsaW5nIGxvb3AuXG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLnN0b3BTY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3Njcm9sbGluZyk7XG59O1xuXG5cbi8qKlxuICogT3ZlcnJpZGVzIGRlZmF1bHRzIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbkF1dG9TY3JvbGwucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMuX29wdHMgPSBhc3NpZ24oe30sIHRoaXMuX29wdHMsIG9wdGlvbnMpO1xufTtcblxuXG4vKipcbiAqIENvbnZlcnRzIGV2ZW50IHRvIGEgcG9pbnQgaW4gY2FudmFzIGNvbnRhaW5lciBwbGFuZSBpbiBnbG9iYWwgc2NhbGUuXG4gKlxuICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtQb2ludH1cbiAqL1xuQXV0b1Njcm9sbC5wcm90b3R5cGUuX3RvQm9yZGVyUG9pbnQgPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IHRoaXMuX2NhbnZhcy5fY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIHZhciBnbG9iYWxQb3NpdGlvbiA9IHRvUG9pbnQoZXZlbnQub3JpZ2luYWxFdmVudCk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBnbG9iYWxQb3NpdGlvbi54IC0gY2xpZW50UmVjdC5sZWZ0LFxuICAgIHk6IGdsb2JhbFBvc2l0aW9uLnkgLSBjbGllbnRSZWN0LnRvcFxuICB9O1xufTsiLCJpbXBvcnQgRHJhZ2dpbmdNb2R1bGUgZnJvbSAnLi4vZHJhZ2dpbmcnO1xuXG5pbXBvcnQgQXV0b1Njcm9sbCBmcm9tICcuL0F1dG9TY3JvbGwnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBEcmFnZ2luZ01vZHVsZSxcbiAgXSxcbiAgX19pbml0X186IFsgJ2F1dG9TY3JvbGwnIF0sXG4gIGF1dG9TY3JvbGw6IFsgJ3R5cGUnLCBBdXRvU2Nyb2xsIF1cbn07IiwiaW1wb3J0IHsgZmlsdGVyUmVkdW5kYW50V2F5cG9pbnRzIH0gZnJvbSAnLi4vLi4vbGF5b3V0L0xheW91dFV0aWwnO1xuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG52YXIgUkVDT05ORUNUX1NUQVJUID0gJ3JlY29ubmVjdFN0YXJ0JyxcbiAgICBSRUNPTk5FQ1RfRU5EID0gJ3JlY29ubmVjdEVuZCcsXG4gICAgVVBEQVRFX1dBWVBPSU5UUyA9ICd1cGRhdGVXYXlwb2ludHMnO1xuXG5cbi8qKlxuICogTW92ZSBiZW5kcG9pbnRzIHRocm91Z2ggZHJhZyBhbmQgZHJvcCB0byBhZGQvcmVtb3ZlIGJlbmRwb2ludHMgb3IgcmVjb25uZWN0IGNvbm5lY3Rpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJlbmRwb2ludE1vdmUoaW5qZWN0b3IsIGV2ZW50QnVzLCBjYW52YXMsIGRyYWdnaW5nLCBydWxlcywgbW9kZWxpbmcpIHtcbiAgdGhpcy5faW5qZWN0b3IgPSBpbmplY3RvcjtcblxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQsIGNvbm5lY3Rpb24sIGJlbmRwb2ludEluZGV4LCBpbnNlcnQpIHtcbiAgICB2YXIgZ2Z4ID0gY2FudmFzLmdldEdyYXBoaWNzKGNvbm5lY3Rpb24pLFxuICAgICAgICBzb3VyY2UgPSBjb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0ID0gY29ubmVjdGlvbi50YXJnZXQsXG4gICAgICAgIHdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzLFxuICAgICAgICB0eXBlO1xuXG4gICAgaWYgKCFpbnNlcnQgJiYgYmVuZHBvaW50SW5kZXggPT09IDApIHtcbiAgICAgIHR5cGUgPSBSRUNPTk5FQ1RfU1RBUlQ7XG4gICAgfSBlbHNlXG4gICAgaWYgKCFpbnNlcnQgJiYgYmVuZHBvaW50SW5kZXggPT09IHdheXBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICB0eXBlID0gUkVDT05ORUNUX0VORDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IFVQREFURV9XQVlQT0lOVFM7XG4gICAgfVxuXG4gICAgdmFyIGNvbW1hbmQgPSB0eXBlID09PSBVUERBVEVfV0FZUE9JTlRTID8gJ2Nvbm5lY3Rpb24udXBkYXRlV2F5cG9pbnRzJyA6ICdjb25uZWN0aW9uLnJlY29ubmVjdCc7XG5cbiAgICB2YXIgYWxsb3dlZCA9IHJ1bGVzLmFsbG93ZWQoY29tbWFuZCwge1xuICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICB9KTtcblxuICAgIGlmIChhbGxvd2VkID09PSBmYWxzZSkge1xuICAgICAgYWxsb3dlZCA9IHJ1bGVzLmFsbG93ZWQoY29tbWFuZCwge1xuICAgICAgICBjb25uZWN0aW9uOiBjb25uZWN0aW9uLFxuICAgICAgICBzb3VyY2U6IHRhcmdldCxcbiAgICAgICAgdGFyZ2V0OiBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhbGxvd2VkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRyYWdnaW5nLmluaXQoZXZlbnQsICdiZW5kcG9pbnQubW92ZScsIHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgICAgY29ubmVjdGlvbkdmeDogZ2Z4LFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgYWxsb3dlZDogYWxsb3dlZCxcbiAgICAgICAgICBiZW5kcG9pbnRJbmRleDogYmVuZHBvaW50SW5kZXgsXG4gICAgICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICBpbnNlcnQ6IGluc2VydCxcbiAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBldmVudEJ1cy5vbignYmVuZHBvaW50Lm1vdmUuaG92ZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgICAgc291cmNlID0gY29ubmVjdGlvbi5zb3VyY2UsXG4gICAgICAgIHRhcmdldCA9IGNvbm5lY3Rpb24udGFyZ2V0LFxuICAgICAgICBob3ZlciA9IGV2ZW50LmhvdmVyLFxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlO1xuXG4gICAgLy8gY2FjaGUgaG92ZXIgc3RhdGVcbiAgICBjb250ZXh0LmhvdmVyID0gaG92ZXI7XG5cbiAgICB2YXIgYWxsb3dlZDtcblxuICAgIGlmICghaG92ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29tbWFuZCA9IHR5cGUgPT09IFVQREFURV9XQVlQT0lOVFMgPyAnY29ubmVjdGlvbi51cGRhdGVXYXlwb2ludHMnIDogJ2Nvbm5lY3Rpb24ucmVjb25uZWN0JztcblxuICAgIGFsbG93ZWQgPSBjb250ZXh0LmFsbG93ZWQgPSBydWxlcy5hbGxvd2VkKGNvbW1hbmQsIHtcbiAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgICBzb3VyY2U6IHR5cGUgPT09IFJFQ09OTkVDVF9TVEFSVCA/IGhvdmVyIDogc291cmNlLFxuICAgICAgdGFyZ2V0OiB0eXBlID09PSBSRUNPTk5FQ1RfRU5EID8gaG92ZXIgOiB0YXJnZXRcbiAgICB9KTtcblxuICAgIGlmIChhbGxvd2VkKSB7XG4gICAgICBjb250ZXh0LnNvdXJjZSA9IHR5cGUgPT09IFJFQ09OTkVDVF9TVEFSVCA/IGhvdmVyIDogc291cmNlO1xuICAgICAgY29udGV4dC50YXJnZXQgPSB0eXBlID09PSBSRUNPTk5FQ1RfRU5EID8gaG92ZXIgOiB0YXJnZXQ7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGFsbG93ZWQgPSBjb250ZXh0LmFsbG93ZWQgPSBydWxlcy5hbGxvd2VkKGNvbW1hbmQsIHtcbiAgICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgICAgc291cmNlOiB0eXBlID09PSBSRUNPTk5FQ1RfRU5EID8gaG92ZXIgOiB0YXJnZXQsXG4gICAgICAgIHRhcmdldDogdHlwZSA9PT0gUkVDT05ORUNUX1NUQVJUID8gaG92ZXIgOiBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhbGxvd2VkKSB7XG4gICAgICBjb250ZXh0LnNvdXJjZSA9IHR5cGUgPT09IFJFQ09OTkVDVF9FTkQgPyBob3ZlciA6IHRhcmdldDtcbiAgICAgIGNvbnRleHQudGFyZ2V0ID0gdHlwZSA9PT0gUkVDT05ORUNUX1NUQVJUID8gaG92ZXIgOiBzb3VyY2U7XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbihbICdiZW5kcG9pbnQubW92ZS5vdXQnLCAnYmVuZHBvaW50Lm1vdmUuY2xlYW51cCcgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIHR5cGUgPSBjb250ZXh0LnR5cGU7XG5cbiAgICBjb250ZXh0LmhvdmVyID0gbnVsbDtcbiAgICBjb250ZXh0LnNvdXJjZSA9IG51bGw7XG4gICAgY29udGV4dC50YXJnZXQgPSBudWxsO1xuXG4gICAgaWYgKHR5cGUgIT09IFVQREFURV9XQVlQT0lOVFMpIHtcbiAgICAgIGNvbnRleHQuYWxsb3dlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2JlbmRwb2ludC5tb3ZlLmVuZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBhbGxvd2VkID0gY29udGV4dC5hbGxvd2VkLFxuICAgICAgICBiZW5kcG9pbnRJbmRleCA9IGNvbnRleHQuYmVuZHBvaW50SW5kZXgsXG4gICAgICAgIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICAgIGluc2VydCA9IGNvbnRleHQuaW5zZXJ0LFxuICAgICAgICBuZXdXYXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cy5zbGljZSgpLFxuICAgICAgICBzb3VyY2UgPSBjb250ZXh0LnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0ID0gY29udGV4dC50YXJnZXQsXG4gICAgICAgIHR5cGUgPSBjb250ZXh0LnR5cGUsXG4gICAgICAgIGhpbnRzID0gY29udGV4dC5oaW50cyB8fCB7fTtcblxuICAgIC8vIGVuc3VyZSBpbnRlZ2VyIHZhbHVlcyAoaW1wb3J0YW50IGlmIHpvb20gbGV2ZWwgd2FzID4gMSBkdXJpbmcgbW92ZSlcbiAgICB2YXIgZG9ja2luZyA9IHtcbiAgICAgIHg6IHJvdW5kKGV2ZW50LngpLFxuICAgICAgeTogcm91bmQoZXZlbnQueSlcbiAgICB9O1xuXG4gICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFVQREFURV9XQVlQT0lOVFMpIHtcbiAgICAgIGlmIChpbnNlcnQpIHtcblxuICAgICAgICAvLyBpbnNlcnQgbmV3IGJlbmRwb2ludFxuICAgICAgICBuZXdXYXlwb2ludHMuc3BsaWNlKGJlbmRwb2ludEluZGV4LCAwLCBkb2NraW5nKTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gc3dhcCBwcmV2aW91cyB3YXlwb2ludCB3aXRoIG1vdmVkIG9uZVxuICAgICAgICBuZXdXYXlwb2ludHNbYmVuZHBvaW50SW5kZXhdID0gZG9ja2luZztcbiAgICAgIH1cblxuICAgICAgLy8gcGFzcyBoaW50cyBhYm91dCBhY3R1YWwgbW92ZWQgYmVuZHBvaW50XG4gICAgICAvLyB1c2VmdWwgZm9yIGNvbm5lY3Rpb24vbGFiZWwgbGF5b3V0XG4gICAgICBoaW50cy5iZW5kcG9pbnRNb3ZlID0ge1xuICAgICAgICBpbnNlcnQ6IGluc2VydCxcbiAgICAgICAgYmVuZHBvaW50SW5kZXg6IGJlbmRwb2ludEluZGV4XG4gICAgICB9O1xuXG4gICAgICBuZXdXYXlwb2ludHMgPSB0aGlzLmNyb3BXYXlwb2ludHMoY29ubmVjdGlvbiwgbmV3V2F5cG9pbnRzKTtcblxuICAgICAgbW9kZWxpbmcudXBkYXRlV2F5cG9pbnRzKGNvbm5lY3Rpb24sIGZpbHRlclJlZHVuZGFudFdheXBvaW50cyhuZXdXYXlwb2ludHMpLCBoaW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09PSBSRUNPTk5FQ1RfU1RBUlQpIHtcbiAgICAgICAgaGludHMuZG9ja2luZyA9ICdzb3VyY2UnO1xuXG4gICAgICAgIGlmIChpc1JldmVyc2UoY29udGV4dCkpIHtcbiAgICAgICAgICBoaW50cy5kb2NraW5nID0gJ3RhcmdldCc7XG5cbiAgICAgICAgICBoaW50cy5uZXdXYXlwb2ludHMgPSBuZXdXYXlwb2ludHMucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFJFQ09OTkVDVF9FTkQpIHtcbiAgICAgICAgaGludHMuZG9ja2luZyA9ICd0YXJnZXQnO1xuXG4gICAgICAgIGlmIChpc1JldmVyc2UoY29udGV4dCkpIHtcbiAgICAgICAgICBoaW50cy5kb2NraW5nID0gJ3NvdXJjZSc7XG5cbiAgICAgICAgICBoaW50cy5uZXdXYXlwb2ludHMgPSBuZXdXYXlwb2ludHMucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1vZGVsaW5nLnJlY29ubmVjdChjb25uZWN0aW9uLCBzb3VyY2UsIHRhcmdldCwgZG9ja2luZywgaGludHMpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG59XG5cbkJlbmRwb2ludE1vdmUuJGluamVjdCA9IFtcbiAgJ2luamVjdG9yJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcycsXG4gICdkcmFnZ2luZycsXG4gICdydWxlcycsXG4gICdtb2RlbGluZydcbl07XG5cbkJlbmRwb2ludE1vdmUucHJvdG90eXBlLmNyb3BXYXlwb2ludHMgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBuZXdXYXlwb2ludHMpIHtcbiAgdmFyIGNvbm5lY3Rpb25Eb2NraW5nID0gdGhpcy5faW5qZWN0b3IuZ2V0KCdjb25uZWN0aW9uRG9ja2luZycsIGZhbHNlKTtcblxuICBpZiAoIWNvbm5lY3Rpb25Eb2NraW5nKSB7XG4gICAgcmV0dXJuIG5ld1dheXBvaW50cztcbiAgfVxuXG4gIHZhciB3YXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cztcblxuICBjb25uZWN0aW9uLndheXBvaW50cyA9IG5ld1dheXBvaW50cztcblxuICBjb25uZWN0aW9uLndheXBvaW50cyA9IGNvbm5lY3Rpb25Eb2NraW5nLmdldENyb3BwZWRXYXlwb2ludHMoY29ubmVjdGlvbik7XG5cbiAgbmV3V2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHM7XG5cbiAgY29ubmVjdGlvbi53YXlwb2ludHMgPSB3YXlwb2ludHM7XG5cbiAgcmV0dXJuIG5ld1dheXBvaW50cztcbn07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JldmVyc2UoY29udGV4dCkge1xuICB2YXIgaG92ZXIgPSBjb250ZXh0LmhvdmVyLFxuICAgICAgc291cmNlID0gY29udGV4dC5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBjb250ZXh0LnRhcmdldCxcbiAgICAgIHR5cGUgPSBjb250ZXh0LnR5cGU7XG5cbiAgaWYgKHR5cGUgPT09IFJFQ09OTkVDVF9TVEFSVCkge1xuICAgIHJldHVybiBob3ZlciAmJiB0YXJnZXQgJiYgaG92ZXIgPT09IHRhcmdldCAmJiBzb3VyY2UgIT09IHRhcmdldDtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBSRUNPTk5FQ1RfRU5EKSB7XG4gICAgcmV0dXJuIGhvdmVyICYmIHNvdXJjZSAmJiBob3ZlciA9PT0gc291cmNlICYmIHNvdXJjZSAhPT0gdGFyZ2V0O1xuICB9XG59IiwiaW1wb3J0IHtcbiAgY2xhc3NlcyBhcyBzdmdDbGFzc2VzLFxuICByZW1vdmUgYXMgc3ZnUmVtb3ZlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IHsgYWRkQmVuZHBvaW50IH0gZnJvbSAnLi9CZW5kcG9pbnRVdGlsJztcblxuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbC9TdmdUcmFuc2Zvcm1VdGlsJztcblxuaW1wb3J0IHsgaXNSZXZlcnNlIH0gZnJvbSAnLi9CZW5kcG9pbnRNb3ZlJztcblxudmFyIFJFQ09OTkVDVF9TVEFSVCA9ICdyZWNvbm5lY3RTdGFydCcsXG4gICAgUkVDT05ORUNUX0VORCA9ICdyZWNvbm5lY3RFbmQnLFxuICAgIFVQREFURV9XQVlQT0lOVFMgPSAndXBkYXRlV2F5cG9pbnRzJztcblxudmFyIE1BUktFUl9PSyA9ICdjb25uZWN0LW9rJyxcbiAgICBNQVJLRVJfTk9UX09LID0gJ2Nvbm5lY3Qtbm90LW9rJyxcbiAgICBNQVJLRVJfQ09OTkVDVF9IT1ZFUiA9ICdjb25uZWN0LWhvdmVyJyxcbiAgICBNQVJLRVJfQ09OTkVDVF9VUERBVElORyA9ICdkanMtdXBkYXRpbmcnLFxuICAgIE1BUktFUl9FTEVNRU5UX0hJRERFTiA9ICdkanMtZWxlbWVudC1oaWRkZW4nO1xuXG52YXIgSElHSF9QUklPUklUWSA9IDExMDA7XG5cbi8qKlxuICogUHJldmlldyBjb25uZWN0aW9uIHdoaWxlIG1vdmluZyBiZW5kcG9pbnRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCZW5kcG9pbnRNb3ZlUHJldmlldyhiZW5kcG9pbnRNb3ZlLCBpbmplY3RvciwgZXZlbnRCdXMsIGNhbnZhcykge1xuICB0aGlzLl9pbmplY3RvciA9IGluamVjdG9yO1xuXG4gIHZhciBjb25uZWN0aW9uUHJldmlldyA9IGluamVjdG9yLmdldCgnY29ubmVjdGlvblByZXZpZXcnLCBmYWxzZSk7XG5cbiAgZXZlbnRCdXMub24oJ2JlbmRwb2ludC5tb3ZlLnN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGJlbmRwb2ludEluZGV4ID0gY29udGV4dC5iZW5kcG9pbnRJbmRleCxcbiAgICAgICAgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgICAgaW5zZXJ0ID0gY29udGV4dC5pbnNlcnQsXG4gICAgICAgIHdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzLFxuICAgICAgICBuZXdXYXlwb2ludHMgPSB3YXlwb2ludHMuc2xpY2UoKTtcblxuICAgIGNvbnRleHQud2F5cG9pbnRzID0gd2F5cG9pbnRzO1xuXG4gICAgaWYgKGluc2VydCkge1xuXG4gICAgICAvLyBpbnNlcnQgcGxhY2Vob2xkZXIgZm9yIG5ldyBiZW5kcG9pbnRcbiAgICAgIG5ld1dheXBvaW50cy5zcGxpY2UoYmVuZHBvaW50SW5kZXgsIDAsIHsgeDogZXZlbnQueCwgeTogZXZlbnQueSB9KTtcbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLndheXBvaW50cyA9IG5ld1dheXBvaW50cztcblxuICAgIC8vIGFkZCBkcmFnZ2VyIGdmeFxuICAgIHZhciBkcmFnZ2VyR2Z4ID0gY29udGV4dC5kcmFnZ2VyR2Z4ID0gYWRkQmVuZHBvaW50KGNhbnZhcy5nZXRMYXllcignb3ZlcmxheXMnKSk7XG5cbiAgICBzdmdDbGFzc2VzKGRyYWdnZXJHZngpLmFkZCgnZGpzLWRyYWdnaW5nJyk7XG5cbiAgICBjYW52YXMuYWRkTWFya2VyKGNvbm5lY3Rpb24sIE1BUktFUl9FTEVNRU5UX0hJRERFTik7XG4gICAgY2FudmFzLmFkZE1hcmtlcihjb25uZWN0aW9uLCBNQVJLRVJfQ09OTkVDVF9VUERBVElORyk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdiZW5kcG9pbnQubW92ZS5ob3ZlcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBhbGxvd2VkID0gY29udGV4dC5hbGxvd2VkLFxuICAgICAgICBob3ZlciA9IGNvbnRleHQuaG92ZXIsXG4gICAgICAgIHR5cGUgPSBjb250ZXh0LnR5cGU7XG5cbiAgICBpZiAoaG92ZXIpIHtcbiAgICAgIGNhbnZhcy5hZGRNYXJrZXIoaG92ZXIsIE1BUktFUl9DT05ORUNUX0hPVkVSKTtcblxuICAgICAgaWYgKHR5cGUgPT09IFVQREFURV9XQVlQT0lOVFMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGhvdmVyLCBNQVJLRVJfTk9UX09LKTtcbiAgICAgICAgY2FudmFzLmFkZE1hcmtlcihob3ZlciwgTUFSS0VSX09LKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZU1hcmtlcihob3ZlciwgTUFSS0VSX09LKTtcbiAgICAgICAgY2FudmFzLmFkZE1hcmtlcihob3ZlciwgTUFSS0VSX05PVF9PSyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbihbXG4gICAgJ2JlbmRwb2ludC5tb3ZlLm91dCcsXG4gICAgJ2JlbmRwb2ludC5tb3ZlLmNsZWFudXAnXG4gIF0sIEhJR0hfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBob3ZlciA9IGNvbnRleHQuaG92ZXIsXG4gICAgICAgIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0O1xuXG4gICAgaWYgKGhvdmVyKSB7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGhvdmVyLCBNQVJLRVJfQ09OTkVDVF9IT1ZFUik7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGhvdmVyLCB0YXJnZXQgPyBNQVJLRVJfT0sgOiBNQVJLRVJfTk9UX09LKTtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdiZW5kcG9pbnQubW92ZS5tb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGFsbG93ZWQgPSBjb250ZXh0LmFsbG93ZWQsXG4gICAgICAgIGJlbmRwb2ludEluZGV4ID0gY29udGV4dC5iZW5kcG9pbnRJbmRleCxcbiAgICAgICAgZHJhZ2dlckdmeCA9IGNvbnRleHQuZHJhZ2dlckdmeCxcbiAgICAgICAgaG92ZXIgPSBjb250ZXh0LmhvdmVyLFxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlLFxuICAgICAgICBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgICBzb3VyY2UgPSBjb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0ID0gY29ubmVjdGlvbi50YXJnZXQsXG4gICAgICAgIG5ld1dheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzLnNsaWNlKCksXG4gICAgICAgIGJlbmRwb2ludCA9IHsgeDogZXZlbnQueCwgeTogZXZlbnQueSB9LFxuICAgICAgICBoaW50cyA9IGNvbnRleHQuaGludHMgfHwge30sXG4gICAgICAgIGRyYXdQcmV2aWV3SGludHMgPSB7fTtcblxuICAgIGlmIChjb25uZWN0aW9uUHJldmlldykge1xuICAgICAgaWYgKGhpbnRzLmNvbm5lY3Rpb25TdGFydCkge1xuICAgICAgICBkcmF3UHJldmlld0hpbnRzLmNvbm5lY3Rpb25TdGFydCA9IGhpbnRzLmNvbm5lY3Rpb25TdGFydDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhpbnRzLmNvbm5lY3Rpb25FbmQpIHtcbiAgICAgICAgZHJhd1ByZXZpZXdIaW50cy5jb25uZWN0aW9uRW5kID0gaGludHMuY29ubmVjdGlvbkVuZDtcbiAgICAgIH1cblxuXG4gICAgICBpZiAodHlwZSA9PT0gUkVDT05ORUNUX1NUQVJUKSB7XG4gICAgICAgIGlmIChpc1JldmVyc2UoY29udGV4dCkpIHtcbiAgICAgICAgICBkcmF3UHJldmlld0hpbnRzLmNvbm5lY3Rpb25FbmQgPSBkcmF3UHJldmlld0hpbnRzLmNvbm5lY3Rpb25FbmQgfHwgYmVuZHBvaW50O1xuXG4gICAgICAgICAgZHJhd1ByZXZpZXdIaW50cy5zb3VyY2UgPSB0YXJnZXQ7XG4gICAgICAgICAgZHJhd1ByZXZpZXdIaW50cy50YXJnZXQgPSBob3ZlciB8fCBzb3VyY2U7XG5cbiAgICAgICAgICBuZXdXYXlwb2ludHMgPSBuZXdXYXlwb2ludHMucmV2ZXJzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRyYXdQcmV2aWV3SGludHMuY29ubmVjdGlvblN0YXJ0ID0gZHJhd1ByZXZpZXdIaW50cy5jb25uZWN0aW9uU3RhcnQgfHwgYmVuZHBvaW50O1xuXG4gICAgICAgICAgZHJhd1ByZXZpZXdIaW50cy5zb3VyY2UgPSBob3ZlciB8fCBzb3VyY2U7XG4gICAgICAgICAgZHJhd1ByZXZpZXdIaW50cy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gUkVDT05ORUNUX0VORCkge1xuICAgICAgICBpZiAoaXNSZXZlcnNlKGNvbnRleHQpKSB7XG4gICAgICAgICAgZHJhd1ByZXZpZXdIaW50cy5jb25uZWN0aW9uU3RhcnQgPSBkcmF3UHJldmlld0hpbnRzLmNvbm5lY3Rpb25TdGFydCB8fCBiZW5kcG9pbnQ7XG5cbiAgICAgICAgICBkcmF3UHJldmlld0hpbnRzLnNvdXJjZSA9IGhvdmVyIHx8IHRhcmdldDtcbiAgICAgICAgICBkcmF3UHJldmlld0hpbnRzLnRhcmdldCA9IHNvdXJjZTtcblxuICAgICAgICAgIG5ld1dheXBvaW50cyA9IG5ld1dheXBvaW50cy5yZXZlcnNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhd1ByZXZpZXdIaW50cy5jb25uZWN0aW9uRW5kID0gZHJhd1ByZXZpZXdIaW50cy5jb25uZWN0aW9uRW5kIHx8IGJlbmRwb2ludDtcblxuICAgICAgICAgIGRyYXdQcmV2aWV3SGludHMuc291cmNlID0gc291cmNlO1xuICAgICAgICAgIGRyYXdQcmV2aWV3SGludHMudGFyZ2V0ID0gaG92ZXIgfHwgdGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYXdQcmV2aWV3SGludHMubm9Dcm9wcGluZyA9IHRydWU7XG4gICAgICAgIGRyYXdQcmV2aWV3SGludHMubm9MYXlvdXQgPSB0cnVlO1xuICAgICAgICBuZXdXYXlwb2ludHNbIGJlbmRwb2ludEluZGV4IF0gPSBiZW5kcG9pbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBVUERBVEVfV0FZUE9JTlRTKSB7XG4gICAgICAgIG5ld1dheXBvaW50cyA9IGJlbmRwb2ludE1vdmUuY3JvcFdheXBvaW50cyhjb25uZWN0aW9uLCBuZXdXYXlwb2ludHMpO1xuICAgICAgfVxuXG4gICAgICBkcmF3UHJldmlld0hpbnRzLndheXBvaW50cyA9IG5ld1dheXBvaW50cztcblxuICAgICAgY29ubmVjdGlvblByZXZpZXcuZHJhd1ByZXZpZXcoY29udGV4dCwgYWxsb3dlZCwgZHJhd1ByZXZpZXdIaW50cyk7XG4gICAgfVxuXG4gICAgdHJhbnNsYXRlKGRyYWdnZXJHZngsIGV2ZW50LngsIGV2ZW50LnkpO1xuICB9LCB0aGlzKTtcblxuICBldmVudEJ1cy5vbihbXG4gICAgJ2JlbmRwb2ludC5tb3ZlLmVuZCcsXG4gICAgJ2JlbmRwb2ludC5tb3ZlLmNhbmNlbCdcbiAgXSwgSElHSF9QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICAgIGRyYWdnZXJHZnggPSBjb250ZXh0LmRyYWdnZXJHZngsXG4gICAgICAgIGhvdmVyID0gY29udGV4dC5ob3ZlcixcbiAgICAgICAgdGFyZ2V0ID0gY29udGV4dC50YXJnZXQsXG4gICAgICAgIHdheXBvaW50cyA9IGNvbnRleHQud2F5cG9pbnRzO1xuXG4gICAgY29ubmVjdGlvbi53YXlwb2ludHMgPSB3YXlwb2ludHM7XG5cbiAgICAvLyByZW1vdmUgZHJhZ2dlciBnZnhcbiAgICBzdmdSZW1vdmUoZHJhZ2dlckdmeCk7XG5cbiAgICBjYW52YXMucmVtb3ZlTWFya2VyKGNvbm5lY3Rpb24sIE1BUktFUl9DT05ORUNUX1VQREFUSU5HKTtcbiAgICBjYW52YXMucmVtb3ZlTWFya2VyKGNvbm5lY3Rpb24sIE1BUktFUl9FTEVNRU5UX0hJRERFTik7XG5cbiAgICBpZiAoaG92ZXIpIHtcbiAgICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoaG92ZXIsIE1BUktFUl9PSyk7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGhvdmVyLCB0YXJnZXQgPyBNQVJLRVJfT0sgOiBNQVJLRVJfTk9UX09LKTtcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdGlvblByZXZpZXcpIHtcbiAgICAgIGNvbm5lY3Rpb25QcmV2aWV3LmNsZWFuVXAoY29udGV4dCk7XG4gICAgfVxuICB9KTtcbn1cblxuQmVuZHBvaW50TW92ZVByZXZpZXcuJGluamVjdCA9IFtcbiAgJ2JlbmRwb2ludE1vdmUnLFxuICAnaW5qZWN0b3InLFxuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJ1xuXTsiLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZvckVhY2gsXG4gIGlzQXJyYXlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgeyBzZXRTbmFwcGVkIH0gZnJvbSAnLi4vc25hcHBpbmcvU25hcFV0aWwnO1xuXG52YXIgYWJzPSBNYXRoLmFicyxcbiAgICByb3VuZCA9IE1hdGgucm91bmQ7XG5cbnZhciBUT0xFUkFOQ0UgPSAxMDtcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCZW5kcG9pbnRTbmFwcGluZyhldmVudEJ1cykge1xuXG4gIGZ1bmN0aW9uIHNuYXBUbyh2YWx1ZXMsIHZhbHVlKSB7XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICB2YXIgaSA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIGlmIChhYnModmFsdWVzW2ldIC0gdmFsdWUpIDw9IFRPTEVSQU5DRSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMgPSArdmFsdWVzO1xuICAgICAgdmFyIHJlbSA9IHZhbHVlICUgdmFsdWVzO1xuXG4gICAgICBpZiAocmVtIDwgVE9MRVJBTkNFKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAtIHJlbTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbSA+IHZhbHVlcyAtIFRPTEVSQU5DRSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgLSByZW0gKyB2YWx1ZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWlkKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC53aWR0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcm91bmQoZWxlbWVudC53aWR0aCAvIDIgKyBlbGVtZW50LngpLFxuICAgICAgICB5OiByb3VuZChlbGVtZW50LmhlaWdodCAvIDIgKyBlbGVtZW50LnkpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbm5lY3Rpb24gc2VnbWVudCBzbmFwcGluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblNlZ21lbnRTbmFwcyhjb250ZXh0KSB7XG5cbiAgICB2YXIgc25hcFBvaW50cyA9IGNvbnRleHQuc25hcFBvaW50cyxcbiAgICAgICAgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgICAgd2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHMsXG4gICAgICAgIHNlZ21lbnRTdGFydCA9IGNvbnRleHQuc2VnbWVudFN0YXJ0LFxuICAgICAgICBzZWdtZW50U3RhcnRJbmRleCA9IGNvbnRleHQuc2VnbWVudFN0YXJ0SW5kZXgsXG4gICAgICAgIHNlZ21lbnRFbmQgPSBjb250ZXh0LnNlZ21lbnRFbmQsXG4gICAgICAgIHNlZ21lbnRFbmRJbmRleCA9IGNvbnRleHQuc2VnbWVudEVuZEluZGV4LFxuICAgICAgICBheGlzID0gY29udGV4dC5heGlzO1xuXG4gICAgaWYgKHNuYXBQb2ludHMpIHtcbiAgICAgIHJldHVybiBzbmFwUG9pbnRzO1xuICAgIH1cblxuICAgIHZhciByZWZlcmVuY2VXYXlwb2ludHMgPSBbXG4gICAgICB3YXlwb2ludHNbc2VnbWVudFN0YXJ0SW5kZXggLSAxXSxcbiAgICAgIHNlZ21lbnRTdGFydCxcbiAgICAgIHNlZ21lbnRFbmQsXG4gICAgICB3YXlwb2ludHNbc2VnbWVudEVuZEluZGV4ICsgMV1cbiAgICBdO1xuXG4gICAgaWYgKHNlZ21lbnRTdGFydEluZGV4IDwgMikge1xuICAgICAgcmVmZXJlbmNlV2F5cG9pbnRzLnVuc2hpZnQobWlkKGNvbm5lY3Rpb24uc291cmNlKSk7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnRFbmRJbmRleCA+IHdheXBvaW50cy5sZW5ndGggLSAzKSB7XG4gICAgICByZWZlcmVuY2VXYXlwb2ludHMudW5zaGlmdChtaWQoY29ubmVjdGlvbi50YXJnZXQpKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LnNuYXBQb2ludHMgPSBzbmFwUG9pbnRzID0geyBob3Jpem9udGFsOiBbXSAsIHZlcnRpY2FsOiBbXSB9O1xuXG4gICAgZm9yRWFjaChyZWZlcmVuY2VXYXlwb2ludHMsIGZ1bmN0aW9uKHApIHtcblxuICAgICAgLy8gd2Ugc25hcCBvbiBleGlzdGluZyBiZW5kcG9pbnRzIG9ubHksXG4gICAgICAvLyBub3QgcGxhY2Vob2xkZXJzIHRoYXQgYXJlIGluc2VydGVkIGR1cmluZyBhZGRcbiAgICAgIGlmIChwKSB7XG4gICAgICAgIHAgPSBwLm9yaWdpbmFsIHx8IHA7XG5cbiAgICAgICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgICAgIHNuYXBQb2ludHMuaG9yaXpvbnRhbC5wdXNoKHAueSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICAgICAgc25hcFBvaW50cy52ZXJ0aWNhbC5wdXNoKHAueCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzbmFwUG9pbnRzO1xuICB9XG5cbiAgZXZlbnRCdXMub24oJ2Nvbm5lY3Rpb25TZWdtZW50Lm1vdmUubW92ZScsIDE1MDAsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBzbmFwUG9pbnRzID0gZ2V0Q29ubmVjdGlvblNlZ21lbnRTbmFwcyhjb250ZXh0KSxcbiAgICAgICAgeCA9IGV2ZW50LngsXG4gICAgICAgIHkgPSBldmVudC55LFxuICAgICAgICBzeCwgc3k7XG5cbiAgICBpZiAoIXNuYXBQb2ludHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzbmFwXG4gICAgc3ggPSBzbmFwVG8oc25hcFBvaW50cy52ZXJ0aWNhbCwgeCk7XG4gICAgc3kgPSBzbmFwVG8oc25hcFBvaW50cy5ob3Jpem9udGFsLCB5KTtcblxuXG4gICAgLy8gY29ycmVjdGlvbiB4L3lcbiAgICB2YXIgY3ggPSAoeCAtIHN4KSxcbiAgICAgICAgY3kgPSAoeSAtIHN5KTtcblxuICAgIC8vIHVwZGF0ZSBkZWx0YVxuICAgIGFzc2lnbihldmVudCwge1xuICAgICAgZHg6IGV2ZW50LmR4IC0gY3gsXG4gICAgICBkeTogZXZlbnQuZHkgLSBjeSxcbiAgICAgIHg6IHN4LFxuICAgICAgeTogc3lcbiAgICB9KTtcblxuICAgIC8vIG9ubHkgc2V0IHNuYXBwZWQgaWYgYWN0dWFsbHkgc25hcHBlZFxuICAgIGlmIChjeCB8fCBzbmFwUG9pbnRzLnZlcnRpY2FsLmluZGV4T2YoeCkgIT09IC0xKSB7XG4gICAgICBzZXRTbmFwcGVkKGV2ZW50LCAneCcsIHN4KTtcbiAgICB9XG5cbiAgICBpZiAoY3kgfHwgc25hcFBvaW50cy5ob3Jpem9udGFsLmluZGV4T2YoeSkgIT09IC0xKSB7XG4gICAgICBzZXRTbmFwcGVkKGV2ZW50LCAneScsIHN5KTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgLy8gYmVuZHBvaW50IHNuYXBwaW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiBnZXRCZW5kcG9pbnRTbmFwcyhjb250ZXh0KSB7XG5cbiAgICB2YXIgc25hcFBvaW50cyA9IGNvbnRleHQuc25hcFBvaW50cyxcbiAgICAgICAgd2F5cG9pbnRzID0gY29udGV4dC5jb25uZWN0aW9uLndheXBvaW50cyxcbiAgICAgICAgYmVuZHBvaW50SW5kZXggPSBjb250ZXh0LmJlbmRwb2ludEluZGV4O1xuXG4gICAgaWYgKHNuYXBQb2ludHMpIHtcbiAgICAgIHJldHVybiBzbmFwUG9pbnRzO1xuICAgIH1cblxuICAgIHZhciByZWZlcmVuY2VXYXlwb2ludHMgPSBbIHdheXBvaW50c1tiZW5kcG9pbnRJbmRleCAtIDFdLCB3YXlwb2ludHNbYmVuZHBvaW50SW5kZXggKyAxXSBdO1xuXG4gICAgY29udGV4dC5zbmFwUG9pbnRzID0gc25hcFBvaW50cyA9IHsgaG9yaXpvbnRhbDogW10gLCB2ZXJ0aWNhbDogW10gfTtcblxuICAgIGZvckVhY2gocmVmZXJlbmNlV2F5cG9pbnRzLCBmdW5jdGlvbihwKSB7XG5cbiAgICAgIC8vIHdlIHNuYXAgb24gZXhpc3RpbmcgYmVuZHBvaW50cyBvbmx5LFxuICAgICAgLy8gbm90IHBsYWNlaG9sZGVycyB0aGF0IGFyZSBpbnNlcnRlZCBkdXJpbmcgYWRkXG4gICAgICBpZiAocCkge1xuICAgICAgICBwID0gcC5vcmlnaW5hbCB8fCBwO1xuXG4gICAgICAgIHNuYXBQb2ludHMuaG9yaXpvbnRhbC5wdXNoKHAueSk7XG4gICAgICAgIHNuYXBQb2ludHMudmVydGljYWwucHVzaChwLngpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNuYXBQb2ludHM7XG4gIH1cblxuXG4gIGV2ZW50QnVzLm9uKFsgJ2JlbmRwb2ludC5tb3ZlLm1vdmUnLCAnYmVuZHBvaW50Lm1vdmUuZW5kJyBdLCAxNTAwLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBzbmFwUG9pbnRzID0gZ2V0QmVuZHBvaW50U25hcHMoY29udGV4dCksXG4gICAgICAgIGhvdmVyID0gY29udGV4dC5ob3ZlcixcbiAgICAgICAgaG92ZXJNaWQgPSBob3ZlciAmJiBtaWQoaG92ZXIpLFxuICAgICAgICB4ID0gZXZlbnQueCxcbiAgICAgICAgeSA9IGV2ZW50LnksXG4gICAgICAgIHN4LCBzeTtcblxuICAgIGlmICghc25hcFBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNuYXAgdG8gaG92ZXIgbWlkXG4gICAgc3ggPSBzbmFwVG8oaG92ZXJNaWQgPyBzbmFwUG9pbnRzLnZlcnRpY2FsLmNvbmNhdChbIGhvdmVyTWlkLnggXSkgOiBzbmFwUG9pbnRzLnZlcnRpY2FsLCB4KTtcbiAgICBzeSA9IHNuYXBUbyhob3Zlck1pZCA/IHNuYXBQb2ludHMuaG9yaXpvbnRhbC5jb25jYXQoWyBob3Zlck1pZC55IF0pIDogc25hcFBvaW50cy5ob3Jpem9udGFsLCB5KTtcblxuICAgIC8vIGNvcnJlY3Rpb24geC95XG4gICAgdmFyIGN4ID0gKHggLSBzeCksXG4gICAgICAgIGN5ID0gKHkgLSBzeSk7XG5cbiAgICAvLyB1cGRhdGUgZGVsdGFcbiAgICBhc3NpZ24oZXZlbnQsIHtcbiAgICAgIGR4OiBldmVudC5keCAtIGN4LFxuICAgICAgZHk6IGV2ZW50LmR5IC0gY3ksXG4gICAgICB4OiBldmVudC54IC0gY3gsXG4gICAgICB5OiBldmVudC55IC0gY3lcbiAgICB9KTtcblxuICAgIC8vIG9ubHkgc2V0IHNuYXBwZWQgaWYgYWN0dWFsbHkgc25hcHBlZFxuICAgIGlmIChjeCB8fCBzbmFwUG9pbnRzLnZlcnRpY2FsLmluZGV4T2YoeCkgIT09IC0xKSB7XG4gICAgICBzZXRTbmFwcGVkKGV2ZW50LCAneCcsIHN4KTtcbiAgICB9XG5cbiAgICBpZiAoY3kgfHwgc25hcFBvaW50cy5ob3Jpem9udGFsLmluZGV4T2YoeSkgIT09IC0xKSB7XG4gICAgICBzZXRTbmFwcGVkKGV2ZW50LCAneScsIHN5KTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbkJlbmRwb2ludFNuYXBwaW5nLiRpbmplY3QgPSBbICdldmVudEJ1cycgXTsiLCJpbXBvcnQge1xuICB0b1BvaW50XG59IGZyb20gJy4uLy4uL3V0aWwvRXZlbnQnO1xuXG5pbXBvcnQge1xuICBnZXRNaWRQb2ludCxcbiAgcG9pbnRzQWxpZ25lZFxufSBmcm9tICcuLi8uLi91dGlsL0dlb21ldHJ5JztcblxuaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjbGFzc2VzIGFzIHN2Z0NsYXNzZXMsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQge1xuICByb3RhdGUsXG4gIHRyYW5zbGF0ZVxufSBmcm9tICcuLi8uLi91dGlsL1N2Z1RyYW5zZm9ybVV0aWwnO1xuXG5pbXBvcnQge1xuICBnZXRBcHByb3hJbnRlcnNlY3Rpb25cbn0gZnJvbSAnLi4vLi4vdXRpbC9MaW5lSW50ZXJzZWN0aW9uJztcblxuZXhwb3J0IHZhciBCRU5EUE9JTlRfQ0xTID0gJ2Rqcy1iZW5kcG9pbnQnO1xuZXhwb3J0IHZhciBTRUdNRU5UX0RSQUdHRVJfQ0xTID0gJ2Rqcy1zZWdtZW50LWRyYWdnZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9DYW52YXNDb29yZGluYXRlcyhjYW52YXMsIGV2ZW50KSB7XG5cbiAgdmFyIHBvc2l0aW9uID0gdG9Qb2ludChldmVudCksXG4gICAgICBjbGllbnRSZWN0ID0gY2FudmFzLl9jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBvZmZzZXQ7XG5cbiAgLy8gY2FudmFzIHJlbGF0aXZlIHBvc2l0aW9uXG5cbiAgb2Zmc2V0ID0ge1xuICAgIHg6IGNsaWVudFJlY3QubGVmdCxcbiAgICB5OiBjbGllbnRSZWN0LnRvcFxuICB9O1xuXG4gIC8vIHVwZGF0ZSBhY3R1YWwgZXZlbnQgcGF5bG9hZCB3aXRoIGNhbnZhcyByZWxhdGl2ZSBtZWFzdXJlc1xuXG4gIHZhciB2aWV3Ym94ID0gY2FudmFzLnZpZXdib3goKTtcblxuICByZXR1cm4ge1xuICAgIHg6IHZpZXdib3gueCArIChwb3NpdGlvbi54IC0gb2Zmc2V0LngpIC8gdmlld2JveC5zY2FsZSxcbiAgICB5OiB2aWV3Ym94LnkgKyAocG9zaXRpb24ueSAtIG9mZnNldC55KSAvIHZpZXdib3guc2NhbGVcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbm5lY3Rpb25JbnRlcnNlY3Rpb24oY2FudmFzLCB3YXlwb2ludHMsIGV2ZW50KSB7XG4gIHZhciBsb2NhbFBvc2l0aW9uID0gdG9DYW52YXNDb29yZGluYXRlcyhjYW52YXMsIGV2ZW50KSxcbiAgICAgIGludGVyc2VjdGlvbiA9IGdldEFwcHJveEludGVyc2VjdGlvbih3YXlwb2ludHMsIGxvY2FsUG9zaXRpb24pO1xuXG4gIHJldHVybiBpbnRlcnNlY3Rpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRCZW5kcG9pbnQocGFyZW50R2Z4LCBjbHMpIHtcbiAgdmFyIGdyb3VwR2Z4ID0gc3ZnQ3JlYXRlKCdnJyk7XG4gIHN2Z0NsYXNzZXMoZ3JvdXBHZngpLmFkZChCRU5EUE9JTlRfQ0xTKTtcblxuICBzdmdBcHBlbmQocGFyZW50R2Z4LCBncm91cEdmeCk7XG5cbiAgdmFyIHZpc3VhbCA9IHN2Z0NyZWF0ZSgnY2lyY2xlJyk7XG4gIHN2Z0F0dHIodmlzdWFsLCB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogNFxuICB9KTtcbiAgc3ZnQ2xhc3Nlcyh2aXN1YWwpLmFkZCgnZGpzLXZpc3VhbCcpO1xuXG4gIHN2Z0FwcGVuZChncm91cEdmeCwgdmlzdWFsKTtcblxuICB2YXIgaGl0ID0gc3ZnQ3JlYXRlKCdjaXJjbGUnKTtcbiAgc3ZnQXR0cihoaXQsIHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAxMFxuICB9KTtcbiAgc3ZnQ2xhc3NlcyhoaXQpLmFkZCgnZGpzLWhpdCcpO1xuXG4gIHN2Z0FwcGVuZChncm91cEdmeCwgaGl0KTtcblxuICBpZiAoY2xzKSB7XG4gICAgc3ZnQ2xhc3Nlcyhncm91cEdmeCkuYWRkKGNscyk7XG4gIH1cblxuICByZXR1cm4gZ3JvdXBHZng7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFsbGVsRHJhZ2dlcihwYXJlbnRHZngsIHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCwgYWxpZ25tZW50KSB7XG4gIHZhciBkcmFnZ2VyR2Z4ID0gc3ZnQ3JlYXRlKCdnJyk7XG5cbiAgc3ZnQXBwZW5kKHBhcmVudEdmeCwgZHJhZ2dlckdmeCk7XG5cbiAgdmFyIHdpZHRoID0gMTQsXG4gICAgICBoZWlnaHQgPSAzLFxuICAgICAgcGFkZGluZyA9IDExLFxuICAgICAgaGl0V2lkdGggPSBjYWxjdWxhdGVIaXRXaWR0aChzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQsIGFsaWdubWVudCksXG4gICAgICBoaXRIZWlnaHQgPSBoZWlnaHQgKyBwYWRkaW5nO1xuXG4gIHZhciB2aXN1YWwgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcbiAgc3ZnQXR0cih2aXN1YWwsIHtcbiAgICB4OiAtd2lkdGggLyAyLFxuICAgIHk6IC1oZWlnaHQgLyAyLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9KTtcbiAgc3ZnQ2xhc3Nlcyh2aXN1YWwpLmFkZCgnZGpzLXZpc3VhbCcpO1xuXG4gIHN2Z0FwcGVuZChkcmFnZ2VyR2Z4LCB2aXN1YWwpO1xuXG4gIHZhciBoaXQgPSBzdmdDcmVhdGUoJ3JlY3QnKTtcbiAgc3ZnQXR0cihoaXQsIHtcbiAgICB4OiAtaGl0V2lkdGggLyAyLFxuICAgIHk6IC1oaXRIZWlnaHQgLyAyLFxuICAgIHdpZHRoOiBoaXRXaWR0aCxcbiAgICBoZWlnaHQ6IGhpdEhlaWdodFxuICB9KTtcbiAgc3ZnQ2xhc3NlcyhoaXQpLmFkZCgnZGpzLWhpdCcpO1xuXG4gIHN2Z0FwcGVuZChkcmFnZ2VyR2Z4LCBoaXQpO1xuXG4gIHJvdGF0ZShkcmFnZ2VyR2Z4LCBhbGlnbm1lbnQgPT09ICd2JyA/IDkwIDogMCwgMCwgMCk7XG5cbiAgcmV0dXJuIGRyYWdnZXJHZng7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFNlZ21lbnREcmFnZ2VyKHBhcmVudEdmeCwgc2VnbWVudFN0YXJ0LCBzZWdtZW50RW5kKSB7XG5cbiAgdmFyIGdyb3VwR2Z4ID0gc3ZnQ3JlYXRlKCdnJyksXG4gICAgICBtaWQgPSBnZXRNaWRQb2ludChzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQpLFxuICAgICAgYWxpZ25tZW50ID0gcG9pbnRzQWxpZ25lZChzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQpO1xuXG4gIHN2Z0FwcGVuZChwYXJlbnRHZngsIGdyb3VwR2Z4KTtcblxuICBjcmVhdGVQYXJhbGxlbERyYWdnZXIoZ3JvdXBHZngsIHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCwgYWxpZ25tZW50KTtcblxuICBzdmdDbGFzc2VzKGdyb3VwR2Z4KS5hZGQoU0VHTUVOVF9EUkFHR0VSX0NMUyk7XG4gIHN2Z0NsYXNzZXMoZ3JvdXBHZngpLmFkZChhbGlnbm1lbnQgPT09ICdoJyA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCcpO1xuXG4gIHRyYW5zbGF0ZShncm91cEdmeCwgbWlkLngsIG1pZC55KTtcblxuICByZXR1cm4gZ3JvdXBHZng7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyByZWdpb24gZm9yIHNlZ21lbnQgbW92ZSB3aGljaCBpcyAyLzMgb2YgdGhlIGZ1bGwgc2VnbWVudCBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50TGVuZ3RoXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU2VnbWVudE1vdmVSZWdpb24oc2VnbWVudExlbmd0aCkge1xuICByZXR1cm4gTWF0aC5hYnMoTWF0aC5yb3VuZChzZWdtZW50TGVuZ3RoICogMiAvIDMpKTtcbn1cblxuLy8gaGVscGVyIC8vLy8vLy8vLy9cblxuZnVuY3Rpb24gY2FsY3VsYXRlSGl0V2lkdGgoc2VnbWVudFN0YXJ0LCBzZWdtZW50RW5kLCBhbGlnbm1lbnQpIHtcbiAgdmFyIHNlZ21lbnRMZW5ndGhYQXhpcyA9IHNlZ21lbnRFbmQueCAtIHNlZ21lbnRTdGFydC54LFxuICAgICAgc2VnbWVudExlbmd0aFlBeGlzID0gc2VnbWVudEVuZC55IC0gc2VnbWVudFN0YXJ0Lnk7XG5cbiAgcmV0dXJuIGFsaWdubWVudCA9PT0gJ2gnID9cbiAgICBjYWxjdWxhdGVTZWdtZW50TW92ZVJlZ2lvbihzZWdtZW50TGVuZ3RoWEF4aXMpIDpcbiAgICBjYWxjdWxhdGVTZWdtZW50TW92ZVJlZ2lvbihzZWdtZW50TGVuZ3RoWUF4aXMpO1xufVxuIiwiaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZXZlbnQgYXMgZG9tRXZlbnQsXG4gIHF1ZXJ5IGFzIGRvbVF1ZXJ5LFxuICBxdWVyeUFsbCBhcyBkb21RdWVyeUFsbFxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgQkVORFBPSU5UX0NMUyxcbiAgU0VHTUVOVF9EUkFHR0VSX0NMUyxcbiAgYWRkQmVuZHBvaW50LFxuICBhZGRTZWdtZW50RHJhZ2dlcixcbiAgY2FsY3VsYXRlU2VnbWVudE1vdmVSZWdpb24sXG4gIGdldENvbm5lY3Rpb25JbnRlcnNlY3Rpb25cbn0gZnJvbSAnLi9CZW5kcG9pbnRVdGlsJztcblxuaW1wb3J0IHtcbiAgZXNjYXBlQ1NTXG59IGZyb20gJy4uLy4uL3V0aWwvRXNjYXBlVXRpbCc7XG5cbmltcG9ydCB7XG4gIHBvaW50c0FsaWduZWQsXG4gIGdldE1pZFBvaW50XG59IGZyb20gJy4uLy4uL3V0aWwvR2VvbWV0cnknO1xuXG5pbXBvcnQge1xuICBpc1ByaW1hcnlCdXR0b25cbn0gZnJvbSAnLi4vLi4vdXRpbC9Nb3VzZSc7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY2xhc3NlcyBhcyBzdmdDbGFzc2VzLFxuICBjcmVhdGUgYXMgc3ZnQ3JlYXRlLFxuICByZW1vdmUgYXMgc3ZnUmVtb3ZlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IHtcbiAgdHJhbnNsYXRlXG59IGZyb20gJy4uLy4uL3V0aWwvU3ZnVHJhbnNmb3JtVXRpbCc7XG5cblxuLyoqXG4gKiBBIHNlcnZpY2UgdGhhdCBhZGRzIGVkaXRhYmxlIGJlbmRwb2ludHMgdG8gY29ubmVjdGlvbnMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJlbmRwb2ludHMoXG4gICAgZXZlbnRCdXMsIGNhbnZhcywgaW50ZXJhY3Rpb25FdmVudHMsXG4gICAgYmVuZHBvaW50TW92ZSwgY29ubmVjdGlvblNlZ21lbnRNb3ZlKSB7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgaW5zaWRlIG1pZGRsZSByZWdpb24gb2Ygc2VnbWVudCwgYWRqdXN0ZWQgYnlcbiAgICogb3B0aW9uYWwgdGhyZXNob2xkXG4gICAqL1xuICBmdW5jdGlvbiBpc0ludGVyc2VjdGlvbk1pZGRsZShpbnRlcnNlY3Rpb24sIHdheXBvaW50cywgdHJlc2hvbGQpIHtcbiAgICB2YXIgaWR4ID0gaW50ZXJzZWN0aW9uLmluZGV4LFxuICAgICAgICBwID0gaW50ZXJzZWN0aW9uLnBvaW50LFxuICAgICAgICBwMCwgcDEsIG1pZCwgYWxpZ25lZCwgeERlbHRhLCB5RGVsdGE7XG5cbiAgICBpZiAoaWR4IDw9IDAgfHwgaW50ZXJzZWN0aW9uLmJlbmRwb2ludCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHAwID0gd2F5cG9pbnRzW2lkeCAtIDFdO1xuICAgIHAxID0gd2F5cG9pbnRzW2lkeF07XG4gICAgbWlkID0gZ2V0TWlkUG9pbnQocDAsIHAxKSxcbiAgICBhbGlnbmVkID0gcG9pbnRzQWxpZ25lZChwMCwgcDEpO1xuICAgIHhEZWx0YSA9IE1hdGguYWJzKHAueCAtIG1pZC54KTtcbiAgICB5RGVsdGEgPSBNYXRoLmFicyhwLnkgLSBtaWQueSk7XG5cbiAgICByZXR1cm4gYWxpZ25lZCAmJiB4RGVsdGEgPD0gdHJlc2hvbGQgJiYgeURlbHRhIDw9IHRyZXNob2xkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHRocmVzaG9sZCBmcm9tIGEgY29ubmVjdGlvbidzIG1pZGRsZSB3aGljaCBmaXRzIHRoZSB0d28tdGhpcmQtcmVnaW9uXG4gICAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVJbnRlcnNlY3Rpb25UaHJlc2hvbGQoY29ubmVjdGlvbiwgaW50ZXJzZWN0aW9uKSB7XG4gICAgdmFyIHdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzLFxuICAgICAgICByZWxldmFudFNlZ21lbnQsIGFsaWdubWVudCwgc2VnbWVudExlbmd0aCwgdGhyZXNob2xkO1xuXG4gICAgaWYgKGludGVyc2VjdGlvbi5pbmRleCA8PSAwIHx8IGludGVyc2VjdGlvbi5iZW5kcG9pbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHNlZ21lbnQgcmVsYXRpdmUgdG8gY29ubmVjdGlvbiBpbnRlcnNlY3Rpb25cbiAgICByZWxldmFudFNlZ21lbnQgPSB7XG4gICAgICBzdGFydDogd2F5cG9pbnRzW2ludGVyc2VjdGlvbi5pbmRleCAtIDFdLFxuICAgICAgZW5kOiB3YXlwb2ludHNbaW50ZXJzZWN0aW9uLmluZGV4XVxuICAgIH07XG5cbiAgICBhbGlnbm1lbnQgPSBwb2ludHNBbGlnbmVkKHJlbGV2YW50U2VnbWVudC5zdGFydCwgcmVsZXZhbnRTZWdtZW50LmVuZCk7XG5cbiAgICBpZiAoIWFsaWdubWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGFsaWdubWVudCA9PT0gJ2gnKSB7XG4gICAgICBzZWdtZW50TGVuZ3RoID0gcmVsZXZhbnRTZWdtZW50LmVuZC54IC0gcmVsZXZhbnRTZWdtZW50LnN0YXJ0Lng7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZ21lbnRMZW5ndGggPSByZWxldmFudFNlZ21lbnQuZW5kLnkgLSByZWxldmFudFNlZ21lbnQuc3RhcnQueTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhyZXNob2xkIHJlbGF0aXZlIHRvIDIvMyBvZiBzZWdtZW50IGxlbmd0aFxuICAgIHRocmVzaG9sZCA9IGNhbGN1bGF0ZVNlZ21lbnRNb3ZlUmVnaW9uKHNlZ21lbnRMZW5ndGgpIC8gMjtcblxuICAgIHJldHVybiB0aHJlc2hvbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBhY3RpdmF0ZUJlbmRwb2ludE1vdmUoZXZlbnQsIGNvbm5lY3Rpb24pIHtcbiAgICB2YXIgd2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHMsXG4gICAgICAgIGludGVyc2VjdGlvbiA9IGdldENvbm5lY3Rpb25JbnRlcnNlY3Rpb24oY2FudmFzLCB3YXlwb2ludHMsIGV2ZW50KSxcbiAgICAgICAgdGhyZXNob2xkO1xuXG4gICAgaWYgKCFpbnRlcnNlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aHJlc2hvbGQgPSBjYWxjdWxhdGVJbnRlcnNlY3Rpb25UaHJlc2hvbGQoY29ubmVjdGlvbiwgaW50ZXJzZWN0aW9uKTtcblxuICAgIGlmIChpc0ludGVyc2VjdGlvbk1pZGRsZShpbnRlcnNlY3Rpb24sIHdheXBvaW50cywgdGhyZXNob2xkKSkge1xuICAgICAgY29ubmVjdGlvblNlZ21lbnRNb3ZlLnN0YXJ0KGV2ZW50LCBjb25uZWN0aW9uLCBpbnRlcnNlY3Rpb24uaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiZW5kcG9pbnRNb3ZlLnN0YXJ0KGV2ZW50LCBjb25uZWN0aW9uLCBpbnRlcnNlY3Rpb24uaW5kZXgsICFpbnRlcnNlY3Rpb24uYmVuZHBvaW50KTtcbiAgICB9XG5cbiAgICAvLyB3ZSd2ZSBoYW5kbGVkIHRoZSBldmVudFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gYmluZEludGVyYWN0aW9uRXZlbnRzKG5vZGUsIGV2ZW50TmFtZSwgZWxlbWVudCkge1xuXG4gICAgZG9tRXZlbnQuYmluZChub2RlLCBldmVudE5hbWUsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpbnRlcmFjdGlvbkV2ZW50cy50cmlnZ2VyTW91c2VFdmVudChldmVudE5hbWUsIGV2ZW50LCBlbGVtZW50KTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmVuZHBvaW50c0NvbnRhaW5lcihlbGVtZW50LCBjcmVhdGUpIHtcblxuICAgIHZhciBsYXllciA9IGNhbnZhcy5nZXRMYXllcignb3ZlcmxheXMnKSxcbiAgICAgICAgZ2Z4ID0gZG9tUXVlcnkoJy5kanMtYmVuZHBvaW50c1tkYXRhLWVsZW1lbnQtaWQ9XCInICsgZXNjYXBlQ1NTKGVsZW1lbnQuaWQpICsgJ1wiXScsIGxheWVyKTtcblxuICAgIGlmICghZ2Z4ICYmIGNyZWF0ZSkge1xuICAgICAgZ2Z4ID0gc3ZnQ3JlYXRlKCdnJyk7XG4gICAgICBzdmdBdHRyKGdmeCwgeyAnZGF0YS1lbGVtZW50LWlkJzogZWxlbWVudC5pZCB9KTtcbiAgICAgIHN2Z0NsYXNzZXMoZ2Z4KS5hZGQoJ2Rqcy1iZW5kcG9pbnRzJyk7XG5cbiAgICAgIHN2Z0FwcGVuZChsYXllciwgZ2Z4KTtcblxuICAgICAgYmluZEludGVyYWN0aW9uRXZlbnRzKGdmeCwgJ21vdXNlZG93bicsIGVsZW1lbnQpO1xuICAgICAgYmluZEludGVyYWN0aW9uRXZlbnRzKGdmeCwgJ2NsaWNrJywgZWxlbWVudCk7XG4gICAgICBiaW5kSW50ZXJhY3Rpb25FdmVudHMoZ2Z4LCAnZGJsY2xpY2snLCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2Z4O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VnbWVudERyYWdnZXIoaWR4LCBwYXJlbnRHZngpIHtcbiAgICByZXR1cm4gZG9tUXVlcnkoXG4gICAgICAnLmRqcy1zZWdtZW50LWRyYWdnZXJbZGF0YS1zZWdtZW50LWlkeD1cIicgKyBpZHggKyAnXCJdJyxcbiAgICAgIHBhcmVudEdmeFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVCZW5kcG9pbnRzKGdmeCwgY29ubmVjdGlvbikge1xuICAgIGNvbm5lY3Rpb24ud2F5cG9pbnRzLmZvckVhY2goZnVuY3Rpb24ocCwgaWR4KSB7XG4gICAgICB2YXIgYmVuZHBvaW50ID0gYWRkQmVuZHBvaW50KGdmeCk7XG5cbiAgICAgIHN2Z0FwcGVuZChnZngsIGJlbmRwb2ludCk7XG5cbiAgICAgIHRyYW5zbGF0ZShiZW5kcG9pbnQsIHAueCwgcC55KTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBmbG9hdGluZyBiZW5kcG9pbnRcbiAgICBhZGRCZW5kcG9pbnQoZ2Z4LCAnZmxvYXRpbmcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNlZ21lbnREcmFnZ2VycyhnZngsIGNvbm5lY3Rpb24pIHtcblxuICAgIHZhciB3YXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cztcblxuICAgIHZhciBzZWdtZW50U3RhcnQsXG4gICAgICAgIHNlZ21lbnRFbmQsXG4gICAgICAgIHNlZ21lbnREcmFnZ2VyR2Z4O1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB3YXlwb2ludHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgc2VnbWVudFN0YXJ0ID0gd2F5cG9pbnRzW2kgLSAxXTtcbiAgICAgIHNlZ21lbnRFbmQgPSB3YXlwb2ludHNbaV07XG5cbiAgICAgIGlmIChwb2ludHNBbGlnbmVkKHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCkpIHtcbiAgICAgICAgc2VnbWVudERyYWdnZXJHZnggPSBhZGRTZWdtZW50RHJhZ2dlcihnZngsIHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCk7XG5cbiAgICAgICAgc3ZnQXR0cihzZWdtZW50RHJhZ2dlckdmeCwgeyAnZGF0YS1zZWdtZW50LWlkeCc6IGkgfSk7XG5cbiAgICAgICAgYmluZEludGVyYWN0aW9uRXZlbnRzKHNlZ21lbnREcmFnZ2VyR2Z4LCAnbW91c2Vtb3ZlJywgY29ubmVjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJCZW5kcG9pbnRzKGdmeCkge1xuICAgIGZvckVhY2goZG9tUXVlcnlBbGwoJy4nICsgQkVORFBPSU5UX0NMUywgZ2Z4KSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgc3ZnUmVtb3ZlKG5vZGUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJTZWdtZW50RHJhZ2dlcnMoZ2Z4KSB7XG4gICAgZm9yRWFjaChkb21RdWVyeUFsbCgnLicgKyBTRUdNRU5UX0RSQUdHRVJfQ0xTLCBnZngpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBzdmdSZW1vdmUobm9kZSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRIYW5kbGVzKGNvbm5lY3Rpb24pIHtcblxuICAgIHZhciBnZnggPSBnZXRCZW5kcG9pbnRzQ29udGFpbmVyKGNvbm5lY3Rpb24pO1xuXG4gICAgaWYgKCFnZngpIHtcbiAgICAgIGdmeCA9IGdldEJlbmRwb2ludHNDb250YWluZXIoY29ubmVjdGlvbiwgdHJ1ZSk7XG5cbiAgICAgIGNyZWF0ZUJlbmRwb2ludHMoZ2Z4LCBjb25uZWN0aW9uKTtcbiAgICAgIGNyZWF0ZVNlZ21lbnREcmFnZ2VycyhnZngsIGNvbm5lY3Rpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBnZng7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIYW5kbGVzKGNvbm5lY3Rpb24pIHtcblxuICAgIHZhciBnZnggPSBnZXRCZW5kcG9pbnRzQ29udGFpbmVyKGNvbm5lY3Rpb24pO1xuXG4gICAgaWYgKGdmeCkge1xuICAgICAgY2xlYXJTZWdtZW50RHJhZ2dlcnMoZ2Z4KTtcbiAgICAgIGNsZWFyQmVuZHBvaW50cyhnZngpO1xuICAgICAgY3JlYXRlU2VnbWVudERyYWdnZXJzKGdmeCwgY29ubmVjdGlvbik7XG4gICAgICBjcmVhdGVCZW5kcG9pbnRzKGdmeCwgY29ubmVjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRmxvYXRpbmdCZW5kcG9pbnRQb3NpdGlvbihwYXJlbnRHZngsIGludGVyc2VjdGlvbikge1xuICAgIHZhciBmbG9hdGluZyA9IGRvbVF1ZXJ5KCcuZmxvYXRpbmcnLCBwYXJlbnRHZngpLFxuICAgICAgICBwb2ludCA9IGludGVyc2VjdGlvbi5wb2ludDtcblxuICAgIGlmICghZmxvYXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmFuc2xhdGUoZmxvYXRpbmcsIHBvaW50LngsIHBvaW50LnkpO1xuXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTZWdtZW50RHJhZ2dlclBvc2l0aW9uKHBhcmVudEdmeCwgaW50ZXJzZWN0aW9uLCB3YXlwb2ludHMpIHtcblxuICAgIHZhciBkcmFnZ2VyR2Z4ID0gZ2V0U2VnbWVudERyYWdnZXIoaW50ZXJzZWN0aW9uLmluZGV4LCBwYXJlbnRHZngpLFxuICAgICAgICBzZWdtZW50U3RhcnQgPSB3YXlwb2ludHNbaW50ZXJzZWN0aW9uLmluZGV4IC0gMV0sXG4gICAgICAgIHNlZ21lbnRFbmQgPSB3YXlwb2ludHNbaW50ZXJzZWN0aW9uLmluZGV4XSxcbiAgICAgICAgcG9pbnQgPSBpbnRlcnNlY3Rpb24ucG9pbnQsXG4gICAgICAgIG1pZCA9IGdldE1pZFBvaW50KHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCksXG4gICAgICAgIGFsaWdubWVudCA9IHBvaW50c0FsaWduZWQoc2VnbWVudFN0YXJ0LCBzZWdtZW50RW5kKSxcbiAgICAgICAgZHJhZ2dlclZpc3VhbCwgcmVsYXRpdmVQb3NpdGlvbjtcblxuICAgIGlmICghZHJhZ2dlckdmeCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRyYWdnZXJWaXN1YWwgPSBnZXREcmFnZ2VyVmlzdWFsKGRyYWdnZXJHZngpO1xuXG4gICAgcmVsYXRpdmVQb3NpdGlvbiA9IHtcbiAgICAgIHg6IHBvaW50LnggLSBtaWQueCxcbiAgICAgIHk6IHBvaW50LnkgLSBtaWQueVxuICAgIH07XG5cbiAgICBpZiAoYWxpZ25tZW50ID09PSAndicpIHtcblxuICAgICAgLy8gcm90YXRlIHBvc2l0aW9uXG4gICAgICByZWxhdGl2ZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiByZWxhdGl2ZVBvc2l0aW9uLnksXG4gICAgICAgIHk6IHJlbGF0aXZlUG9zaXRpb24ueFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0cmFuc2xhdGUoZHJhZ2dlclZpc3VhbCwgcmVsYXRpdmVQb3NpdGlvbi54LCByZWxhdGl2ZVBvc2l0aW9uLnkpO1xuICB9XG5cbiAgZXZlbnRCdXMub24oJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdXBkYXRlSGFuZGxlcyhldmVudC5lbGVtZW50KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2Nvbm5lY3Rpb24ucmVtb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZ2Z4ID0gZ2V0QmVuZHBvaW50c0NvbnRhaW5lcihldmVudC5lbGVtZW50KTtcblxuICAgIGlmIChnZngpIHtcbiAgICAgIHN2Z1JlbW92ZShnZngpO1xuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2VsZW1lbnQubWFya2VyLnVwZGF0ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQsXG4gICAgICAgIGJlbmRwb2ludHNHZng7XG5cbiAgICBpZiAoIWVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYmVuZHBvaW50c0dmeCA9IGFkZEhhbmRsZXMoZWxlbWVudCk7XG5cbiAgICBpZiAoZXZlbnQuYWRkKSB7XG4gICAgICBzdmdDbGFzc2VzKGJlbmRwb2ludHNHZngpLmFkZChldmVudC5tYXJrZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdmdDbGFzc2VzKGJlbmRwb2ludHNHZngpLnJlbW92ZShldmVudC5tYXJrZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2VsZW1lbnQubW91c2Vtb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudCxcbiAgICAgICAgd2F5cG9pbnRzID0gZWxlbWVudC53YXlwb2ludHMsXG4gICAgICAgIGJlbmRwb2ludHNHZngsXG4gICAgICAgIGludGVyc2VjdGlvbjtcblxuICAgIGlmICh3YXlwb2ludHMpIHtcbiAgICAgIGJlbmRwb2ludHNHZnggPSBnZXRCZW5kcG9pbnRzQ29udGFpbmVyKGVsZW1lbnQsIHRydWUpO1xuXG4gICAgICBpbnRlcnNlY3Rpb24gPSBnZXRDb25uZWN0aW9uSW50ZXJzZWN0aW9uKGNhbnZhcywgd2F5cG9pbnRzLCBldmVudC5vcmlnaW5hbEV2ZW50KTtcblxuICAgICAgaWYgKCFpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVGbG9hdGluZ0JlbmRwb2ludFBvc2l0aW9uKGJlbmRwb2ludHNHZngsIGludGVyc2VjdGlvbik7XG5cbiAgICAgIGlmICghaW50ZXJzZWN0aW9uLmJlbmRwb2ludCkge1xuICAgICAgICB1cGRhdGVTZWdtZW50RHJhZ2dlclBvc2l0aW9uKGJlbmRwb2ludHNHZngsIGludGVyc2VjdGlvbiwgd2F5cG9pbnRzKTtcbiAgICAgIH1cblxuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2VsZW1lbnQubW91c2Vkb3duJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIGlmICghaXNQcmltYXJ5QnV0dG9uKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCxcbiAgICAgICAgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQ7XG5cbiAgICBpZiAoIWVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGl2YXRlQmVuZHBvaW50TW92ZShvcmlnaW5hbEV2ZW50LCBlbGVtZW50KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ3NlbGVjdGlvbi5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgbmV3U2VsZWN0aW9uID0gZXZlbnQubmV3U2VsZWN0aW9uLFxuICAgICAgICBwcmltYXJ5ID0gbmV3U2VsZWN0aW9uWzBdO1xuXG4gICAgaWYgKHByaW1hcnkgJiYgcHJpbWFyeS53YXlwb2ludHMpIHtcbiAgICAgIGFkZEhhbmRsZXMocHJpbWFyeSk7XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbignZWxlbWVudC5ob3ZlcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC5lbGVtZW50O1xuXG4gICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgICBhZGRIYW5kbGVzKGVsZW1lbnQpO1xuICAgICAgaW50ZXJhY3Rpb25FdmVudHMucmVnaXN0ZXJFdmVudChldmVudC5nZngsICdtb3VzZW1vdmUnLCAnZWxlbWVudC5tb3VzZW1vdmUnKTtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm91dCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaW50ZXJhY3Rpb25FdmVudHMudW5yZWdpc3RlckV2ZW50KGV2ZW50LmdmeCwgJ21vdXNlbW92ZScsICdlbGVtZW50Lm1vdXNlbW92ZScpO1xuICB9KTtcblxuICAvLyB1cGRhdGUgYmVuZHBvaW50IGNvbnRhaW5lciBkYXRhIGF0dHJpYnV0ZSBvbiBlbGVtZW50IElEIGNoYW5nZVxuICBldmVudEJ1cy5vbignZWxlbWVudC51cGRhdGVJZCcsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudCxcbiAgICAgICAgbmV3SWQgPSBjb250ZXh0Lm5ld0lkO1xuXG4gICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgICB2YXIgYmVuZHBvaW50Q29udGFpbmVyID0gZ2V0QmVuZHBvaW50c0NvbnRhaW5lcihlbGVtZW50KTtcblxuICAgICAgaWYgKGJlbmRwb2ludENvbnRhaW5lcikge1xuICAgICAgICBzdmdBdHRyKGJlbmRwb2ludENvbnRhaW5lciwgeyAnZGF0YS1lbGVtZW50LWlkJzogbmV3SWQgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBBUElcblxuICB0aGlzLmFkZEhhbmRsZXMgPSBhZGRIYW5kbGVzO1xuICB0aGlzLnVwZGF0ZUhhbmRsZXMgPSB1cGRhdGVIYW5kbGVzO1xuICB0aGlzLmdldEJlbmRwb2ludHNDb250YWluZXIgPSBnZXRCZW5kcG9pbnRzQ29udGFpbmVyO1xuICB0aGlzLmdldFNlZ21lbnREcmFnZ2VyID0gZ2V0U2VnbWVudERyYWdnZXI7XG59XG5cbkJlbmRwb2ludHMuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcycsXG4gICdpbnRlcmFjdGlvbkV2ZW50cycsXG4gICdiZW5kcG9pbnRNb3ZlJyxcbiAgJ2Nvbm5lY3Rpb25TZWdtZW50TW92ZSdcbl07XG5cblxuXG4vLyBoZWxwZXIgLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBnZXREcmFnZ2VyVmlzdWFsKGRyYWdnZXJHZngpIHtcbiAgcmV0dXJuIGRvbVF1ZXJ5KCcuZGpzLXZpc3VhbCcsIGRyYWdnZXJHZngpO1xufSIsImltcG9ydCB7XG4gIHBvaW50c0FsaWduZWQsXG4gIHBvaW50c09uTGluZVxufSBmcm9tICcuLi8uLi91dGlsL0dlb21ldHJ5JztcblxuaW1wb3J0IHtcbiAgYWRkU2VnbWVudERyYWdnZXIsXG4gIGdldENvbm5lY3Rpb25JbnRlcnNlY3Rpb25cbn0gZnJvbSAnLi9CZW5kcG9pbnRVdGlsJztcblxuaW1wb3J0IHtcbiAgZ2V0TWlkLFxuICBnZXRPcmllbnRhdGlvblxufSBmcm9tICcuLi8uLi9sYXlvdXQvTGF5b3V0VXRpbCc7XG5cbnZhciBNQVJLRVJfQ09OTkVDVF9IT1ZFUiA9ICdjb25uZWN0LWhvdmVyJyxcbiAgICBNQVJLRVJfQ09OTkVDVF9VUERBVElORyA9ICdkanMtdXBkYXRpbmcnO1xuXG5pbXBvcnQge1xuICBjbGFzc2VzIGFzIHN2Z0NsYXNzZXMsXG4gIHJlbW92ZSBhcyBzdmdSZW1vdmVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQge1xuICB0cmFuc2xhdGVcbn0gZnJvbSAnLi4vLi4vdXRpbC9TdmdUcmFuc2Zvcm1VdGlsJztcblxuXG5mdW5jdGlvbiBheGlzQWRkKHBvaW50LCBheGlzLCBkZWx0YSkge1xuICByZXR1cm4gYXhpc1NldChwb2ludCwgYXhpcywgcG9pbnRbYXhpc10gKyBkZWx0YSk7XG59XG5cbmZ1bmN0aW9uIGF4aXNTZXQocG9pbnQsIGF4aXMsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgeDogKGF4aXMgPT09ICd4JyA/IHZhbHVlIDogcG9pbnQueCksXG4gICAgeTogKGF4aXMgPT09ICd5JyA/IHZhbHVlIDogcG9pbnQueSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXhpc0ZlbmNlZChwb3NpdGlvbiwgc2VnbWVudFN0YXJ0LCBzZWdtZW50RW5kLCBheGlzKSB7XG5cbiAgdmFyIG1heFZhbHVlID0gTWF0aC5tYXgoc2VnbWVudFN0YXJ0W2F4aXNdLCBzZWdtZW50RW5kW2F4aXNdKSxcbiAgICAgIG1pblZhbHVlID0gTWF0aC5taW4oc2VnbWVudFN0YXJ0W2F4aXNdLCBzZWdtZW50RW5kW2F4aXNdKTtcblxuICB2YXIgcGFkZGluZyA9IDIwO1xuXG4gIHZhciBmZW5jZWRWYWx1ZSA9IE1hdGgubWluKE1hdGgubWF4KG1pblZhbHVlICsgcGFkZGluZywgcG9zaXRpb25bYXhpc10pLCBtYXhWYWx1ZSAtIHBhZGRpbmcpO1xuXG4gIHJldHVybiBheGlzU2V0KHNlZ21lbnRTdGFydCwgYXhpcywgZmVuY2VkVmFsdWUpO1xufVxuXG5mdW5jdGlvbiBmbGlwQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkb2NraW5nIHBvaW50IG9uIHRoZSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIENvbXB1dGUgYSByZWFzb25hYmxlIGRvY2tpbmcsIGlmIG5vbiBleGlzdHMuXG4gKlxuICogQHBhcmFtICB7UG9pbnR9IHBvaW50XG4gKiBAcGFyYW0gIHtkanMubW9kZWwuU2hhcGV9IHJlZmVyZW5jZUVsZW1lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gbW92ZUF4aXMgKHh8eSlcbiAqXG4gKiBAcmV0dXJuIHtQb2ludH1cbiAqL1xuZnVuY3Rpb24gZ2V0RG9ja2luZyhwb2ludCwgcmVmZXJlbmNlRWxlbWVudCwgbW92ZUF4aXMpIHtcblxuICB2YXIgcmVmZXJlbmNlTWlkLFxuICAgICAgaW52ZXJzZUF4aXM7XG5cbiAgaWYgKHBvaW50Lm9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIHBvaW50Lm9yaWdpbmFsO1xuICB9IGVsc2Uge1xuICAgIHJlZmVyZW5jZU1pZCA9IGdldE1pZChyZWZlcmVuY2VFbGVtZW50KTtcbiAgICBpbnZlcnNlQXhpcyA9IGZsaXBBeGlzKG1vdmVBeGlzKTtcblxuICAgIHJldHVybiBheGlzU2V0KHBvaW50LCBpbnZlcnNlQXhpcywgcmVmZXJlbmNlTWlkW2ludmVyc2VBeGlzXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgbW92aW5nIG9mIGJlbmRwb2ludHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29ubmVjdGlvblNlZ21lbnRNb3ZlKFxuICAgIGluamVjdG9yLCBldmVudEJ1cywgY2FudmFzLFxuICAgIGRyYWdnaW5nLCBncmFwaGljc0ZhY3RvcnksIG1vZGVsaW5nKSB7XG5cbiAgLy8gb3B0aW9uYWwgY29ubmVjdGlvbiBkb2NraW5nIGludGVncmF0aW9uXG4gIHZhciBjb25uZWN0aW9uRG9ja2luZyA9IGluamVjdG9yLmdldCgnY29ubmVjdGlvbkRvY2tpbmcnLCBmYWxzZSk7XG5cblxuICAvLyBBUElcblxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQsIGNvbm5lY3Rpb24sIGlkeCkge1xuXG4gICAgdmFyIGNvbnRleHQsXG4gICAgICAgIGdmeCA9IGNhbnZhcy5nZXRHcmFwaGljcyhjb25uZWN0aW9uKSxcbiAgICAgICAgc2VnbWVudFN0YXJ0SW5kZXggPSBpZHggLSAxLFxuICAgICAgICBzZWdtZW50RW5kSW5kZXggPSBpZHgsXG4gICAgICAgIHdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzLFxuICAgICAgICBzZWdtZW50U3RhcnQgPSB3YXlwb2ludHNbc2VnbWVudFN0YXJ0SW5kZXhdLFxuICAgICAgICBzZWdtZW50RW5kID0gd2F5cG9pbnRzW3NlZ21lbnRFbmRJbmRleF0sXG4gICAgICAgIGludGVyc2VjdGlvbiA9IGdldENvbm5lY3Rpb25JbnRlcnNlY3Rpb24oY2FudmFzLCB3YXlwb2ludHMsIGV2ZW50KSxcbiAgICAgICAgZGlyZWN0aW9uLCBheGlzLCBkcmFnUG9zaXRpb247XG5cbiAgICBkaXJlY3Rpb24gPSBwb2ludHNBbGlnbmVkKHNlZ21lbnRTdGFydCwgc2VnbWVudEVuZCk7XG5cbiAgICAvLyBkbyBub3QgbW92ZSBkaWFnb25hbCBjb25uZWN0aW9uXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0aGUgYXhpcyB3aGVyZSB3ZSBhcmUgZ29pbmcgdG8gbW92ZSB0aGluZ3NcbiAgICBheGlzID0gZGlyZWN0aW9uID09PSAndicgPyAneCcgOiAneSc7XG5cbiAgICBpZiAoc2VnbWVudFN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgIHNlZ21lbnRTdGFydCA9IGdldERvY2tpbmcoc2VnbWVudFN0YXJ0LCBjb25uZWN0aW9uLnNvdXJjZSwgYXhpcyk7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnRFbmRJbmRleCA9PT0gd2F5cG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHNlZ21lbnRFbmQgPSBnZXREb2NraW5nKHNlZ21lbnRFbmQsIGNvbm5lY3Rpb24udGFyZ2V0LCBheGlzKTtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICBkcmFnUG9zaXRpb24gPSBpbnRlcnNlY3Rpb24ucG9pbnQ7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gc2V0IHRvIHNlZ21lbnQgY2VudGVyIGFzIGRlZmF1bHRcbiAgICAgIGRyYWdQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogKHNlZ21lbnRTdGFydC54ICsgc2VnbWVudEVuZC54KSAvIDIsXG4gICAgICAgIHk6IChzZWdtZW50U3RhcnQueSArIHNlZ21lbnRFbmQueSkgLyAyXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnRleHQgPSB7XG4gICAgICBjb25uZWN0aW9uOiBjb25uZWN0aW9uLFxuICAgICAgc2VnbWVudFN0YXJ0SW5kZXg6IHNlZ21lbnRTdGFydEluZGV4LFxuICAgICAgc2VnbWVudEVuZEluZGV4OiBzZWdtZW50RW5kSW5kZXgsXG4gICAgICBzZWdtZW50U3RhcnQ6IHNlZ21lbnRTdGFydCxcbiAgICAgIHNlZ21lbnRFbmQ6IHNlZ21lbnRFbmQsXG4gICAgICBheGlzOiBheGlzLFxuICAgICAgZHJhZ1Bvc2l0aW9uOiBkcmFnUG9zaXRpb25cbiAgICB9O1xuXG4gICAgZHJhZ2dpbmcuaW5pdChldmVudCwgZHJhZ1Bvc2l0aW9uLCAnY29ubmVjdGlvblNlZ21lbnQubW92ZScsIHtcbiAgICAgIGN1cnNvcjogYXhpcyA9PT0gJ3gnID8gJ3Jlc2l6ZS1ldycgOiAncmVzaXplLW5zJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgICAgY29ubmVjdGlvbkdmeDogZ2Z4LFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyb3AgY29ubmVjdGlvbiBpZiBjb25uZWN0aW9uIGNyb3BwaW5nIGlzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheTxQb2ludD59IG5ld1dheXBvaW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxQb2ludD59IGNyb3BwZWQgY29ubmVjdGlvbiB3YXlwb2ludHNcbiAgICovXG4gIGZ1bmN0aW9uIGNyb3BDb25uZWN0aW9uKGNvbm5lY3Rpb24sIG5ld1dheXBvaW50cykge1xuXG4gICAgLy8gY3JvcCBjb25uZWN0aW9uLCBpZiBkb2NraW5nIHNlcnZpY2UgaXMgcHJvdmlkZWQgb25seVxuICAgIGlmICghY29ubmVjdGlvbkRvY2tpbmcpIHtcbiAgICAgIHJldHVybiBuZXdXYXlwb2ludHM7XG4gICAgfVxuXG4gICAgdmFyIG9sZFdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzLFxuICAgICAgICBjcm9wcGVkV2F5cG9pbnRzO1xuXG4gICAgLy8gdGVtcG9yYXJ5IHNldCBuZXcgd2F5cG9pbnRzXG4gICAgY29ubmVjdGlvbi53YXlwb2ludHMgPSBuZXdXYXlwb2ludHM7XG5cbiAgICBjcm9wcGVkV2F5cG9pbnRzID0gY29ubmVjdGlvbkRvY2tpbmcuZ2V0Q3JvcHBlZFdheXBvaW50cyhjb25uZWN0aW9uKTtcblxuICAgIC8vIHJlc3RvcmUgb2xkIHdheXBvaW50c1xuICAgIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gb2xkV2F5cG9pbnRzO1xuXG4gICAgcmV0dXJuIGNyb3BwZWRXYXlwb2ludHM7XG4gIH1cblxuICAvLyBEUkFHR0lORyBJTVBMRU1FTlRBVElPTlxuXG4gIGZ1bmN0aW9uIHJlZHJhd0Nvbm5lY3Rpb24oZGF0YSkge1xuICAgIGdyYXBoaWNzRmFjdG9yeS51cGRhdGUoJ2Nvbm5lY3Rpb24nLCBkYXRhLmNvbm5lY3Rpb24sIGRhdGEuY29ubmVjdGlvbkdmeCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVEcmFnZ2VyKGNvbnRleHQsIHNlZ21lbnRPZmZzZXQsIGV2ZW50KSB7XG5cbiAgICB2YXIgbmV3V2F5cG9pbnRzID0gY29udGV4dC5uZXdXYXlwb2ludHMsXG4gICAgICAgIHNlZ21lbnRTdGFydEluZGV4ID0gY29udGV4dC5zZWdtZW50U3RhcnRJbmRleCArIHNlZ21lbnRPZmZzZXQsXG4gICAgICAgIHNlZ21lbnRTdGFydCA9IG5ld1dheXBvaW50c1tzZWdtZW50U3RhcnRJbmRleF0sXG4gICAgICAgIHNlZ21lbnRFbmRJbmRleCA9IGNvbnRleHQuc2VnbWVudEVuZEluZGV4ICsgc2VnbWVudE9mZnNldCxcbiAgICAgICAgc2VnbWVudEVuZCA9IG5ld1dheXBvaW50c1tzZWdtZW50RW5kSW5kZXhdLFxuICAgICAgICBheGlzID0gZmxpcEF4aXMoY29udGV4dC5heGlzKTtcblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgZHJhZ2dlciBkb2VzIG5vdCBtb3ZlXG4gICAgLy8gb3V0c2lkZSB0aGUgY29ubmVjdGlvblxuICAgIHZhciBkcmFnZ2VyUG9zaXRpb24gPSBheGlzRmVuY2VkKGV2ZW50LCBzZWdtZW50U3RhcnQsIHNlZ21lbnRFbmQsIGF4aXMpO1xuXG4gICAgLy8gdXBkYXRlIGRyYWdnZXJcbiAgICB0cmFuc2xhdGUoY29udGV4dC5kcmFnZ2VyR2Z4LCBkcmFnZ2VyUG9zaXRpb24ueCwgZHJhZ2dlclBvc2l0aW9uLnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlciB3YXlwb2ludHMgZm9yIHJlZHVuZGFudCBvbmVzIChpLmUuIG9uIHRoZSBzYW1lIGF4aXMpLlxuICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXJlZCB3YXlwb2ludHMgYW5kIHRoZSBvZmZzZXQgcmVsYXRlZCB0byB0aGUgc2VnbWVudCBtb3ZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gd2F5cG9pbnRzXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gc2VnbWVudFN0YXJ0SW5kZXggb2YgbW92ZWQgc2VnbWVudCBzdGFydFxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHsgZmlsdGVyZWRXYXlwb2ludHMsIHNlZ21lbnRPZmZzZXQgfVxuICAgKi9cbiAgZnVuY3Rpb24gZmlsdGVyUmVkdW5kYW50V2F5cG9pbnRzKHdheXBvaW50cywgc2VnbWVudFN0YXJ0SW5kZXgpIHtcblxuICAgIHZhciBzZWdtZW50T2Zmc2V0ID0gMDtcblxuICAgIHZhciBmaWx0ZXJlZFdheXBvaW50cyA9IHdheXBvaW50cy5maWx0ZXIoZnVuY3Rpb24ociwgaWR4KSB7XG4gICAgICBpZiAocG9pbnRzT25MaW5lKHdheXBvaW50c1tpZHggLSAxXSwgd2F5cG9pbnRzW2lkeCArIDFdLCByKSkge1xuXG4gICAgICAgIC8vIHJlbW92ZSBwb2ludCBhbmQgaW5jcmVtZW50IG9mZnNldFxuICAgICAgICBzZWdtZW50T2Zmc2V0ID0gaWR4IDw9IHNlZ21lbnRTdGFydEluZGV4ID8gc2VnbWVudE9mZnNldCAtIDEgOiBzZWdtZW50T2Zmc2V0O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbnQgcmVtb3ZlIHBvaW50XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICB3YXlwb2ludHM6IGZpbHRlcmVkV2F5cG9pbnRzLFxuICAgICAgc2VnbWVudE9mZnNldDogc2VnbWVudE9mZnNldFxuICAgIH07XG4gIH1cblxuICBldmVudEJ1cy5vbignY29ubmVjdGlvblNlZ21lbnQubW92ZS5zdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGNvbm5lY3Rpb24gPSBldmVudC5jb25uZWN0aW9uLFxuICAgICAgICBsYXllciA9IGNhbnZhcy5nZXRMYXllcignb3ZlcmxheXMnKTtcblxuICAgIGNvbnRleHQub3JpZ2luYWxXYXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cy5zbGljZSgpO1xuXG4gICAgLy8gYWRkIGRyYWdnZXIgZ2Z4XG4gICAgY29udGV4dC5kcmFnZ2VyR2Z4ID0gYWRkU2VnbWVudERyYWdnZXIobGF5ZXIsIGNvbnRleHQuc2VnbWVudFN0YXJ0LCBjb250ZXh0LnNlZ21lbnRFbmQpO1xuICAgIHN2Z0NsYXNzZXMoY29udGV4dC5kcmFnZ2VyR2Z4KS5hZGQoJ2Rqcy1kcmFnZ2luZycpO1xuXG4gICAgY2FudmFzLmFkZE1hcmtlcihjb25uZWN0aW9uLCBNQVJLRVJfQ09OTkVDVF9VUERBVElORyk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjb25uZWN0aW9uU2VnbWVudC5tb3ZlLm1vdmUnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgICBzZWdtZW50U3RhcnRJbmRleCA9IGNvbnRleHQuc2VnbWVudFN0YXJ0SW5kZXgsXG4gICAgICAgIHNlZ21lbnRFbmRJbmRleCA9IGNvbnRleHQuc2VnbWVudEVuZEluZGV4LFxuICAgICAgICBzZWdtZW50U3RhcnQgPSBjb250ZXh0LnNlZ21lbnRTdGFydCxcbiAgICAgICAgc2VnbWVudEVuZCA9IGNvbnRleHQuc2VnbWVudEVuZCxcbiAgICAgICAgYXhpcyA9IGNvbnRleHQuYXhpcztcblxuICAgIHZhciBuZXdXYXlwb2ludHMgPSBjb250ZXh0Lm9yaWdpbmFsV2F5cG9pbnRzLnNsaWNlKCksXG4gICAgICAgIG5ld1NlZ21lbnRTdGFydCA9IGF4aXNBZGQoc2VnbWVudFN0YXJ0LCBheGlzLCBldmVudFsnZCcgKyBheGlzXSksXG4gICAgICAgIG5ld1NlZ21lbnRFbmQgPSBheGlzQWRkKHNlZ21lbnRFbmQsIGF4aXMsIGV2ZW50WydkJyArIGF4aXNdKTtcblxuICAgIC8vIG9yaWdpbmFsIHdheXBvaW50IGNvdW50IGFuZCBhZGRlZCAvIHJlbW92ZWRcbiAgICAvLyBmcm9tIHN0YXJ0IHdheXBvaW50IGRlbHRhLiBXZSB1c2UgdGhlIGxhdGVyXG4gICAgLy8gdG8gcmV0cmlldmUgdGhlIHVwZGF0ZWQgc2VnbWVudFN0YXJ0SW5kZXggLyBzZWdtZW50RW5kSW5kZXhcbiAgICB2YXIgd2F5cG9pbnRDb3VudCA9IG5ld1dheXBvaW50cy5sZW5ndGgsXG4gICAgICAgIHNlZ21lbnRPZmZzZXQgPSAwO1xuXG4gICAgLy8gbW92ZSBzZWdtZW50IHN0YXJ0IC8gZW5kIGJ5IGF4aXMgZGVsdGFcbiAgICBuZXdXYXlwb2ludHNbc2VnbWVudFN0YXJ0SW5kZXhdID0gbmV3U2VnbWVudFN0YXJ0O1xuICAgIG5ld1dheXBvaW50c1tzZWdtZW50RW5kSW5kZXhdID0gbmV3U2VnbWVudEVuZDtcblxuICAgIHZhciBzb3VyY2VUb1NlZ21lbnRPcmllbnRhdGlvbixcbiAgICAgICAgdGFyZ2V0VG9TZWdtZW50T3JpZW50YXRpb247XG5cbiAgICAvLyBoYW5kbGUgZmlyc3Qgc2VnbWVudFxuICAgIGlmIChzZWdtZW50U3RhcnRJbmRleCA8IDIpIHtcbiAgICAgIHNvdXJjZVRvU2VnbWVudE9yaWVudGF0aW9uID0gZ2V0T3JpZW50YXRpb24oY29ubmVjdGlvbi5zb3VyY2UsIG5ld1NlZ21lbnRTdGFydCk7XG5cbiAgICAgIC8vIGZpcnN0IGJlbmRwb2ludCwgcmVtb3ZlIGZpcnN0IHNlZ21lbnQgaWYgaW50ZXJzZWN0aW5nXG4gICAgICBpZiAoc2VnbWVudFN0YXJ0SW5kZXggPT09IDEpIHtcblxuICAgICAgICBpZiAoc291cmNlVG9TZWdtZW50T3JpZW50YXRpb24gPT09ICdpbnRlcnNlY3QnKSB7XG4gICAgICAgICAgbmV3V2F5cG9pbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgbmV3V2F5cG9pbnRzWzBdID0gbmV3U2VnbWVudFN0YXJ0O1xuICAgICAgICAgIHNlZ21lbnRPZmZzZXQtLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkb2NraW5nIHBvaW50LCBhZGQgc2VnbWVudCBpZiBub3QgaW50ZXJzZWN0aW5nIGFueW1vcmVcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc291cmNlVG9TZWdtZW50T3JpZW50YXRpb24gIT09ICdpbnRlcnNlY3QnKSB7XG4gICAgICAgICAgbmV3V2F5cG9pbnRzLnVuc2hpZnQoc2VnbWVudFN0YXJ0KTtcbiAgICAgICAgICBzZWdtZW50T2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgbGFzdCBzZWdtZW50XG4gICAgaWYgKHNlZ21lbnRFbmRJbmRleCA+IHdheXBvaW50Q291bnQgLSAzKSB7XG4gICAgICB0YXJnZXRUb1NlZ21lbnRPcmllbnRhdGlvbiA9IGdldE9yaWVudGF0aW9uKGNvbm5lY3Rpb24udGFyZ2V0LCBuZXdTZWdtZW50RW5kKTtcblxuICAgICAgLy8gbGFzdCBiZW5kcG9pbnQsIHJlbW92ZSBsYXN0IHNlZ21lbnQgaWYgaW50ZXJzZWN0aW5nXG4gICAgICBpZiAoc2VnbWVudEVuZEluZGV4ID09PSB3YXlwb2ludENvdW50IC0gMikge1xuXG4gICAgICAgIGlmICh0YXJnZXRUb1NlZ21lbnRPcmllbnRhdGlvbiA9PT0gJ2ludGVyc2VjdCcpIHtcbiAgICAgICAgICBuZXdXYXlwb2ludHMucG9wKCk7XG4gICAgICAgICAgbmV3V2F5cG9pbnRzW25ld1dheXBvaW50cy5sZW5ndGggLSAxXSA9IG5ld1NlZ21lbnRFbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbGFzdCBiZW5kcG9pbnQsIHJlbW92ZSBsYXN0IHNlZ21lbnQgaWYgaW50ZXJzZWN0aW5nXG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldFRvU2VnbWVudE9yaWVudGF0aW9uICE9PSAnaW50ZXJzZWN0Jykge1xuICAgICAgICAgIG5ld1dheXBvaW50cy5wdXNoKHNlZ21lbnRFbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGNvbm5lY3Rpb24gd2F5cG9pbnRzXG4gICAgY29udGV4dC5uZXdXYXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cyA9IGNyb3BDb25uZWN0aW9uKGNvbm5lY3Rpb24sIG5ld1dheXBvaW50cyk7XG5cbiAgICAvLyB1cGRhdGUgZHJhZ2dlciBwb3NpdGlvblxuICAgIHVwZGF0ZURyYWdnZXIoY29udGV4dCwgc2VnbWVudE9mZnNldCwgZXZlbnQpO1xuXG4gICAgLy8gc2F2ZSBzZWdtZW50T2Zmc2V0IGluIGNvbnRleHRcbiAgICBjb250ZXh0Lm5ld1NlZ21lbnRTdGFydEluZGV4ID0gc2VnbWVudFN0YXJ0SW5kZXggKyBzZWdtZW50T2Zmc2V0O1xuXG4gICAgLy8gcmVkcmF3IGNvbm5lY3Rpb25cbiAgICByZWRyYXdDb25uZWN0aW9uKGV2ZW50KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2Nvbm5lY3Rpb25TZWdtZW50Lm1vdmUuaG92ZXInLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgZXZlbnQuY29udGV4dC5ob3ZlciA9IGV2ZW50LmhvdmVyO1xuICAgIGNhbnZhcy5hZGRNYXJrZXIoZXZlbnQuaG92ZXIsIE1BUktFUl9DT05ORUNUX0hPVkVSKTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oW1xuICAgICdjb25uZWN0aW9uU2VnbWVudC5tb3ZlLm91dCcsXG4gICAgJ2Nvbm5lY3Rpb25TZWdtZW50Lm1vdmUuY2xlYW51cCdcbiAgXSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIC8vIHJlbW92ZSBjb25uZWN0IG1hcmtlclxuICAgIC8vIGlmIGl0IHdhcyBhZGRlZFxuICAgIHZhciBob3ZlciA9IGV2ZW50LmNvbnRleHQuaG92ZXI7XG5cbiAgICBpZiAoaG92ZXIpIHtcbiAgICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoaG92ZXIsIE1BUktFUl9DT05ORUNUX0hPVkVSKTtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjb25uZWN0aW9uU2VnbWVudC5tb3ZlLmNsZWFudXAnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uO1xuXG4gICAgLy8gcmVtb3ZlIGRyYWdnZXIgZ2Z4XG4gICAgaWYgKGNvbnRleHQuZHJhZ2dlckdmeCkge1xuICAgICAgc3ZnUmVtb3ZlKGNvbnRleHQuZHJhZ2dlckdmeCk7XG4gICAgfVxuXG4gICAgY2FudmFzLnJlbW92ZU1hcmtlcihjb25uZWN0aW9uLCBNQVJLRVJfQ09OTkVDVF9VUERBVElORyk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKFtcbiAgICAnY29ubmVjdGlvblNlZ21lbnQubW92ZS5jYW5jZWwnLFxuICAgICdjb25uZWN0aW9uU2VnbWVudC5tb3ZlLmVuZCdcbiAgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb247XG5cbiAgICBjb25uZWN0aW9uLndheXBvaW50cyA9IGNvbnRleHQub3JpZ2luYWxXYXlwb2ludHM7XG5cbiAgICByZWRyYXdDb25uZWN0aW9uKGV2ZW50KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2Nvbm5lY3Rpb25TZWdtZW50Lm1vdmUuZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgICAgbmV3V2F5cG9pbnRzID0gY29udGV4dC5uZXdXYXlwb2ludHMsXG4gICAgICAgIG5ld1NlZ21lbnRTdGFydEluZGV4ID0gY29udGV4dC5uZXdTZWdtZW50U3RhcnRJbmRleDtcblxuICAgIC8vIGVuc3VyZSB3ZSBoYXZlIGFjdHVhbCBwaXhlbCB2YWx1ZXMgYmVuZHBvaW50XG4gICAgLy8gY29vcmRpbmF0ZXMgKGltcG9ydGFudCB3aGVuIHpvb20gbGV2ZWwgd2FzID4gMSBkdXJpbmcgbW92ZSlcbiAgICBuZXdXYXlwb2ludHMgPSBuZXdXYXlwb2ludHMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbmFsOiBwLm9yaWdpbmFsLFxuICAgICAgICB4OiBNYXRoLnJvdW5kKHAueCksXG4gICAgICAgIHk6IE1hdGgucm91bmQocC55KVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGZpbHRlciByZWR1bmFudCB3YXlwb2ludHNcbiAgICB2YXIgZmlsdGVyZWQgPSBmaWx0ZXJSZWR1bmRhbnRXYXlwb2ludHMobmV3V2F5cG9pbnRzLCBuZXdTZWdtZW50U3RhcnRJbmRleCk7XG5cbiAgICAvLyBnZXQgZmlsdGVyZWQgd2F5cG9pbnRzXG4gICAgdmFyIGZpbHRlcmVkV2F5cG9pbnRzID0gZmlsdGVyZWQud2F5cG9pbnRzLFxuICAgICAgICBjcm9wcGVkV2F5cG9pbnRzID0gY3JvcENvbm5lY3Rpb24oY29ubmVjdGlvbiwgZmlsdGVyZWRXYXlwb2ludHMpLFxuICAgICAgICBzZWdtZW50T2Zmc2V0ID0gZmlsdGVyZWQuc2VnbWVudE9mZnNldDtcblxuICAgIHZhciBoaW50cyA9IHtcbiAgICAgIHNlZ21lbnRNb3ZlOiB7XG4gICAgICAgIHNlZ21lbnRTdGFydEluZGV4OiBjb250ZXh0LnNlZ21lbnRTdGFydEluZGV4LFxuICAgICAgICBuZXdTZWdtZW50U3RhcnRJbmRleDogbmV3U2VnbWVudFN0YXJ0SW5kZXggKyBzZWdtZW50T2Zmc2V0XG4gICAgICB9XG4gICAgfTtcblxuICAgIG1vZGVsaW5nLnVwZGF0ZVdheXBvaW50cyhjb25uZWN0aW9uLCBjcm9wcGVkV2F5cG9pbnRzLCBoaW50cyk7XG4gIH0pO1xufVxuXG5Db25uZWN0aW9uU2VnbWVudE1vdmUuJGluamVjdCA9IFtcbiAgJ2luamVjdG9yJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcycsXG4gICdkcmFnZ2luZycsXG4gICdncmFwaGljc0ZhY3RvcnknLFxuICAnbW9kZWxpbmcnXG5dO1xuIiwiaW1wb3J0IERyYWdnaW5nTW9kdWxlIGZyb20gJy4uL2RyYWdnaW5nJztcbmltcG9ydCBSdWxlc01vZHVsZSBmcm9tICcuLi9ydWxlcyc7XG5cbmltcG9ydCBCZW5kcG9pbnRzIGZyb20gJy4vQmVuZHBvaW50cyc7XG5pbXBvcnQgQmVuZHBvaW50TW92ZSBmcm9tICcuL0JlbmRwb2ludE1vdmUnO1xuaW1wb3J0IEJlbmRwb2ludE1vdmVQcmV2aWV3IGZyb20gJy4vQmVuZHBvaW50TW92ZVByZXZpZXcnO1xuaW1wb3J0IENvbm5lY3Rpb25TZWdtZW50TW92ZSBmcm9tICcuL0Nvbm5lY3Rpb25TZWdtZW50TW92ZSc7XG5pbXBvcnQgQmVuZHBvaW50U25hcHBpbmcgZnJvbSAnLi9CZW5kcG9pbnRTbmFwcGluZyc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIERyYWdnaW5nTW9kdWxlLFxuICAgIFJ1bGVzTW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbICdiZW5kcG9pbnRzJywgJ2JlbmRwb2ludFNuYXBwaW5nJywgJ2JlbmRwb2ludE1vdmVQcmV2aWV3JyBdLFxuICBiZW5kcG9pbnRzOiBbICd0eXBlJywgQmVuZHBvaW50cyBdLFxuICBiZW5kcG9pbnRNb3ZlOiBbICd0eXBlJywgQmVuZHBvaW50TW92ZSBdLFxuICBiZW5kcG9pbnRNb3ZlUHJldmlldzogWyAndHlwZScsIEJlbmRwb2ludE1vdmVQcmV2aWV3IF0sXG4gIGNvbm5lY3Rpb25TZWdtZW50TW92ZTogWyAndHlwZScsIENvbm5lY3Rpb25TZWdtZW50TW92ZSBdLFxuICBiZW5kcG9pbnRTbmFwcGluZzogWyAndHlwZScsIEJlbmRwb2ludFNuYXBwaW5nIF1cbn07XG4iLCJpbXBvcnQge1xuICBnZXRUeXBlIGFzIGdldEVsZW1lbnRUeXBlXG59IGZyb20gJy4uLy4uL3V0aWwvRWxlbWVudHMnO1xuXG4vKipcbiAqIEFkZHMgY2hhbmdlIHN1cHBvcnQgdG8gdGhlIGRpYWdyYW0sIGluY2x1ZGluZ1xuICpcbiAqIDx1bD5cbiAqICAgPGxpPnJlZHJhd2luZyBzaGFwZXMgYW5kIGNvbm5lY3Rpb25zIG9uIGNoYW5nZTwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKiBAcGFyYW0ge0VsZW1lbnRSZWdpc3RyeX0gZWxlbWVudFJlZ2lzdHJ5XG4gKiBAcGFyYW0ge0dyYXBoaWNzRmFjdG9yeX0gZ3JhcGhpY3NGYWN0b3J5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENoYW5nZVN1cHBvcnQoXG4gICAgZXZlbnRCdXMsIGNhbnZhcywgZWxlbWVudFJlZ2lzdHJ5LFxuICAgIGdyYXBoaWNzRmFjdG9yeSkge1xuXG5cbiAgLy8gcmVkcmF3IHNoYXBlcyAvIGNvbm5lY3Rpb25zIG9uIGNoYW5nZVxuXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50LmNoYW5nZWQnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC5lbGVtZW50O1xuXG4gICAgLy8gZWxlbWVudCBtaWdodCBoYXZlIGJlZW4gZGVsZXRlZCBhbmQgcmVwbGFjZWQgYnkgbmV3IGVsZW1lbnQgd2l0aCBzYW1lIElEXG4gICAgLy8gdGh1cyBjaGVjayBmb3IgcGFyZW50IG9mIGVsZW1lbnQgZXhjZXB0IGZvciByb290IGVsZW1lbnRcbiAgICBpZiAoZWxlbWVudC5wYXJlbnQgfHwgZWxlbWVudCA9PT0gY2FudmFzLmdldFJvb3RFbGVtZW50KCkpIHtcbiAgICAgIGV2ZW50LmdmeCA9IGVsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBzaGFwZSArIGdmeCBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWRcbiAgICBpZiAoIWV2ZW50LmdmeCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50QnVzLmZpcmUoZ2V0RWxlbWVudFR5cGUoZWxlbWVudCkgKyAnLmNoYW5nZWQnLCBldmVudCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50cy5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBlbGVtZW50cyA9IGV2ZW50LmVsZW1lbnRzO1xuXG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICBldmVudEJ1cy5maXJlKCdlbGVtZW50LmNoYW5nZWQnLCB7IGVsZW1lbnQ6IGUgfSk7XG4gICAgfSk7XG5cbiAgICBncmFwaGljc0ZhY3RvcnkudXBkYXRlQ29udGFpbm1lbnRzKGVsZW1lbnRzKTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ3NoYXBlLmNoYW5nZWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIGdyYXBoaWNzRmFjdG9yeS51cGRhdGUoJ3NoYXBlJywgZXZlbnQuZWxlbWVudCwgZXZlbnQuZ2Z4KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgZ3JhcGhpY3NGYWN0b3J5LnVwZGF0ZSgnY29ubmVjdGlvbicsIGV2ZW50LmVsZW1lbnQsIGV2ZW50LmdmeCk7XG4gIH0pO1xufVxuXG5DaGFuZ2VTdXBwb3J0LiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnZWxlbWVudFJlZ2lzdHJ5JyxcbiAgJ2dyYXBoaWNzRmFjdG9yeSdcbl07IiwiaW1wb3J0IENoYW5nZVN1cHBvcnQgZnJvbSAnLi9DaGFuZ2VTdXBwb3J0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAnY2hhbmdlU3VwcG9ydCddLFxuICBjaGFuZ2VTdXBwb3J0OiBbICd0eXBlJywgQ2hhbmdlU3VwcG9ydCBdXG59OyIsIi8qKlxuICogQSBjbGlwIGJvYXJkIHN0dWJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2xpcGJvYXJkKCkge31cblxuXG5DbGlwYm9hcmQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZGF0YTtcbn07XG5cbkNsaXBib2FyZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbn07XG5cbkNsaXBib2FyZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gIGRlbGV0ZSB0aGlzLl9kYXRhO1xuXG4gIHJldHVybiBkYXRhO1xufTtcblxuQ2xpcGJvYXJkLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5fZGF0YTtcbn07IiwiaW1wb3J0IENsaXBib2FyZCBmcm9tICcuL0NsaXBib2FyZCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY2xpcGJvYXJkOiBbICd0eXBlJywgQ2xpcGJvYXJkIF1cbn07XG4iLCJpbXBvcnQge1xuICBnZXRNaWRcbn0gZnJvbSAnLi4vLi4vbGF5b3V0L0xheW91dFV0aWwnO1xuXG5pbXBvcnQge1xuICBpc05pbCxcbiAgaXNPYmplY3Rcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbm5lY3QoZXZlbnRCdXMsIGRyYWdnaW5nLCBtb2RlbGluZywgcnVsZXMpIHtcblxuICAvLyBydWxlc1xuXG4gIGZ1bmN0aW9uIGNhbkNvbm5lY3Qoc291cmNlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gcnVsZXMuYWxsb3dlZCgnY29ubmVjdGlvbi5jcmVhdGUnLCB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5Db25uZWN0UmV2ZXJzZShzb3VyY2UsIHRhcmdldCkge1xuICAgIHJldHVybiBjYW5Db25uZWN0KHRhcmdldCwgc291cmNlKTtcbiAgfVxuXG5cbiAgLy8gZXZlbnQgaGFuZGxlcnNcblxuICBldmVudEJ1cy5vbignY29ubmVjdC5ob3ZlcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBzdGFydCA9IGNvbnRleHQuc3RhcnQsXG4gICAgICAgIGhvdmVyID0gZXZlbnQuaG92ZXIsXG4gICAgICAgIGNhbkV4ZWN1dGU7XG5cbiAgICAvLyBjYWNoZSBob3ZlciBzdGF0ZVxuICAgIGNvbnRleHQuaG92ZXIgPSBob3ZlcjtcblxuICAgIGNhbkV4ZWN1dGUgPSBjb250ZXh0LmNhbkV4ZWN1dGUgPSBjYW5Db25uZWN0KHN0YXJ0LCBob3Zlcik7XG5cbiAgICAvLyBpZ25vcmUgaG92ZXJcbiAgICBpZiAoaXNOaWwoY2FuRXhlY3V0ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2FuRXhlY3V0ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnRleHQuc291cmNlID0gc3RhcnQ7XG4gICAgICBjb250ZXh0LnRhcmdldCA9IGhvdmVyO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FuRXhlY3V0ZSA9IGNvbnRleHQuY2FuRXhlY3V0ZSA9IGNhbkNvbm5lY3RSZXZlcnNlKHN0YXJ0LCBob3Zlcik7XG5cbiAgICAvLyBpZ25vcmUgaG92ZXJcbiAgICBpZiAoaXNOaWwoY2FuRXhlY3V0ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2FuRXhlY3V0ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnRleHQuc291cmNlID0gaG92ZXI7XG4gICAgICBjb250ZXh0LnRhcmdldCA9IHN0YXJ0O1xuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oWyAnY29ubmVjdC5vdXQnLCAnY29ubmVjdC5jbGVhbnVwJyBdLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dDtcblxuICAgIGNvbnRleHQuaG92ZXIgPSBudWxsO1xuICAgIGNvbnRleHQuc291cmNlID0gbnVsbDtcbiAgICBjb250ZXh0LnRhcmdldCA9IG51bGw7XG5cbiAgICBjb250ZXh0LmNhbkV4ZWN1dGUgPSBmYWxzZTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2Nvbm5lY3QuZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGNhbkV4ZWN1dGUgPSBjb250ZXh0LmNhbkV4ZWN1dGUsXG4gICAgICAgIGNvbm5lY3Rpb25TdGFydCA9IGNvbnRleHQuY29ubmVjdGlvblN0YXJ0LFxuICAgICAgICBjb25uZWN0aW9uRW5kID0ge1xuICAgICAgICAgIHg6IGV2ZW50LngsXG4gICAgICAgICAgeTogZXZlbnQueVxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2UgPSBjb250ZXh0LnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0ID0gY29udGV4dC50YXJnZXQ7XG5cbiAgICBpZiAoIWNhbkV4ZWN1dGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYXR0cnMgPSBudWxsLFxuICAgICAgICBoaW50cyA9IHtcbiAgICAgICAgICBjb25uZWN0aW9uU3RhcnQ6IGlzUmV2ZXJzZShjb250ZXh0KSA/IGNvbm5lY3Rpb25FbmQgOiBjb25uZWN0aW9uU3RhcnQsXG4gICAgICAgICAgY29ubmVjdGlvbkVuZDogaXNSZXZlcnNlKGNvbnRleHQpID8gY29ubmVjdGlvblN0YXJ0IDogY29ubmVjdGlvbkVuZFxuICAgICAgICB9O1xuXG4gICAgaWYgKGlzT2JqZWN0KGNhbkV4ZWN1dGUpKSB7XG4gICAgICBhdHRycyA9IGNhbkV4ZWN1dGU7XG4gICAgfVxuXG4gICAgbW9kZWxpbmcuY29ubmVjdChzb3VyY2UsIHRhcmdldCwgYXR0cnMsIGhpbnRzKTtcbiAgfSk7XG5cblxuICAvLyBBUElcblxuICAvKipcbiAgICogU3RhcnQgY29ubmVjdCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IHN0YXJ0XG4gICAqIEBwYXJhbSB7UG9pbnR9IFtjb25uZWN0aW9uU3RhcnRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9BY3RpdmF0ZT1mYWxzZV1cbiAgICovXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbihldmVudCwgc3RhcnQsIGNvbm5lY3Rpb25TdGFydCwgYXV0b0FjdGl2YXRlKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25uZWN0aW9uU3RhcnQpKSB7XG4gICAgICBhdXRvQWN0aXZhdGUgPSBjb25uZWN0aW9uU3RhcnQ7XG4gICAgICBjb25uZWN0aW9uU3RhcnQgPSBnZXRNaWQoc3RhcnQpO1xuICAgIH1cblxuICAgIGRyYWdnaW5nLmluaXQoZXZlbnQsICdjb25uZWN0Jywge1xuICAgICAgYXV0b0FjdGl2YXRlOiBhdXRvQWN0aXZhdGUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNoYXBlOiBzdGFydCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBjb25uZWN0aW9uU3RhcnQ6IGNvbm5lY3Rpb25TdGFydFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbkNvbm5lY3QuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2RyYWdnaW5nJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ3J1bGVzJ1xuXTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmV2ZXJzZShjb250ZXh0KSB7XG4gIHZhciBob3ZlciA9IGNvbnRleHQuaG92ZXIsXG4gICAgICBzb3VyY2UgPSBjb250ZXh0LnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0O1xuXG4gIHJldHVybiBob3ZlciAmJiBzb3VyY2UgJiYgaG92ZXIgPT09IHNvdXJjZSAmJiBzb3VyY2UgIT09IHRhcmdldDtcbn0iLCJpbXBvcnQgeyBpc1JldmVyc2UgfSBmcm9tICcuL0Nvbm5lY3QnO1xuXG52YXIgSElHSF9QUklPUklUWSA9IDExMDAsXG4gICAgTE9XX1BSSU9SSVRZID0gOTAwO1xuXG52YXIgTUFSS0VSX09LID0gJ2Nvbm5lY3Qtb2snLFxuICAgIE1BUktFUl9OT1RfT0sgPSAnY29ubmVjdC1ub3Qtb2snO1xuXG4vKipcbiAqIFNob3dzIGNvbm5lY3Rpb24gcHJldmlldyBkdXJpbmcgY29ubmVjdC5cbiAqXG4gKiBAcGFyYW0ge2RpZGkuSW5qZWN0b3J9IGluamVjdG9yXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb25uZWN0UHJldmlldyhpbmplY3RvciwgZXZlbnRCdXMsIGNhbnZhcykge1xuICB2YXIgY29ubmVjdGlvblByZXZpZXcgPSBpbmplY3Rvci5nZXQoJ2Nvbm5lY3Rpb25QcmV2aWV3JywgZmFsc2UpO1xuXG4gIGNvbm5lY3Rpb25QcmV2aWV3ICYmIGV2ZW50QnVzLm9uKCdjb25uZWN0Lm1vdmUnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgY2FuQ29ubmVjdCA9IGNvbnRleHQuY2FuRXhlY3V0ZSxcbiAgICAgICAgaG92ZXIgPSBjb250ZXh0LmhvdmVyLFxuICAgICAgICBzb3VyY2UgPSBjb250ZXh0LnNvdXJjZSxcbiAgICAgICAgc3RhcnQgPSBjb250ZXh0LnN0YXJ0LFxuICAgICAgICBzdGFydFBvc2l0aW9uID0gY29udGV4dC5zdGFydFBvc2l0aW9uLFxuICAgICAgICBjb25uZWN0aW9uU3RhcnQgPSBjb250ZXh0LmNvbm5lY3Rpb25TdGFydCxcbiAgICAgICAgY29ubmVjdGlvbkVuZCA9IGNvbnRleHQuY29ubmVjdGlvbkVuZCxcbiAgICAgICAgdGFyZ2V0ID0gY29udGV4dC50YXJnZXQ7XG5cbiAgICBpZiAoIWNvbm5lY3Rpb25TdGFydCkge1xuICAgICAgY29ubmVjdGlvblN0YXJ0ID0gaXNSZXZlcnNlKGNvbnRleHQpID8ge1xuICAgICAgICB4OiBldmVudC54LFxuICAgICAgICB5OiBldmVudC55XG4gICAgICB9IDogc3RhcnRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoIWNvbm5lY3Rpb25FbmQpIHtcbiAgICAgIGNvbm5lY3Rpb25FbmQgPSBpc1JldmVyc2UoY29udGV4dCkgPyBzdGFydFBvc2l0aW9uIDoge1xuICAgICAgICB4OiBldmVudC54LFxuICAgICAgICB5OiBldmVudC55XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbm5lY3Rpb25QcmV2aWV3LmRyYXdQcmV2aWV3KGNvbnRleHQsIGNhbkNvbm5lY3QsIHtcbiAgICAgIHNvdXJjZTogc291cmNlIHx8IHN0YXJ0LFxuICAgICAgdGFyZ2V0OiB0YXJnZXQgfHwgaG92ZXIsXG4gICAgICBjb25uZWN0aW9uU3RhcnQ6IGNvbm5lY3Rpb25TdGFydCxcbiAgICAgIGNvbm5lY3Rpb25FbmQ6IGNvbm5lY3Rpb25FbmRcbiAgICB9KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2Nvbm5lY3QuaG92ZXInLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBob3ZlciA9IGV2ZW50LmhvdmVyLFxuICAgICAgICBjYW5FeGVjdXRlID0gY29udGV4dC5jYW5FeGVjdXRlO1xuXG4gICAgLy8gaWdub3JlIGhvdmVyXG4gICAgaWYgKGNhbkV4ZWN1dGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYW52YXMuYWRkTWFya2VyKGhvdmVyLCBjYW5FeGVjdXRlID8gTUFSS0VSX09LIDogTUFSS0VSX05PVF9PSyk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKFtcbiAgICAnY29ubmVjdC5vdXQnLFxuICAgICdjb25uZWN0LmNsZWFudXAnXG4gIF0sIEhJR0hfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGhvdmVyID0gZXZlbnQuaG92ZXI7XG5cbiAgICBpZiAoaG92ZXIpIHtcbiAgICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoaG92ZXIsIE1BUktFUl9PSyk7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGhvdmVyLCBNQVJLRVJfTk9UX09LKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbm5lY3Rpb25QcmV2aWV3ICYmIGV2ZW50QnVzLm9uKCdjb25uZWN0LmNsZWFudXAnLCBmdW5jdGlvbihldmVudCkge1xuICAgIGNvbm5lY3Rpb25QcmV2aWV3LmNsZWFuVXAoZXZlbnQuY29udGV4dCk7XG4gIH0pO1xufVxuXG5Db25uZWN0UHJldmlldy4kaW5qZWN0ID0gW1xuICAnaW5qZWN0b3InLFxuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJ1xuXTtcbiIsImltcG9ydCBTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnLi4vc2VsZWN0aW9uJztcbmltcG9ydCBSdWxlc01vZHVsZSBmcm9tICcuLi9ydWxlcyc7XG5pbXBvcnQgRHJhZ2dpbmdNb2R1bGUgZnJvbSAnLi4vZHJhZ2dpbmcnO1xuXG5pbXBvcnQgQ29ubmVjdCBmcm9tICcuL0Nvbm5lY3QnO1xuaW1wb3J0IENvbm5lY3RQcmV2aWV3IGZyb20gJy4vQ29ubmVjdFByZXZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgU2VsZWN0aW9uTW9kdWxlLFxuICAgIFJ1bGVzTW9kdWxlLFxuICAgIERyYWdnaW5nTW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbXG4gICAgJ2Nvbm5lY3RQcmV2aWV3J1xuICBdLFxuICBjb25uZWN0OiBbICd0eXBlJywgQ29ubmVjdCBdLFxuICBjb25uZWN0UHJldmlldzogWyAndHlwZScsIENvbm5lY3RQcmV2aWV3IF1cbn07XG4iLCJpbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNsYXNzZXMgYXMgc3ZnQ2xhc3NlcyxcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZSxcbiAgcmVtb3ZlIGFzIHN2Z1JlbW92ZSxcbiAgY2xlYXIgYXMgc3ZnQ2xlYXJcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQge1xuICBpc09iamVjdFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGdldEVsZW1lbnRMaW5lSW50ZXJzZWN0aW9uLFxuICBnZXRNaWRcbn0gZnJvbSAnLi4vLi4vbGF5b3V0L0xheW91dFV0aWwnO1xuXG5cbnZhciBNQVJLRVJfQ09OTkVDVElPTl9QUkVWSUVXID0gJ2Rqcy1jb25uZWN0aW9uLXByZXZpZXcnO1xuXG4vKipcbiAqIERyYXdzIGNvbm5lY3Rpb24gcHJldmlldy4gT3B0aW9uYWxseSwgdGhpcyBjYW4gdXNlIGxheW91dGVyIGFuZCBjb25uZWN0aW9uIGRvY2tpbmcgdG8gZHJhd1xuICogYmV0dGVyIGxvb2tpbmcgcHJldmlld3MuXG4gKlxuICogQHBhcmFtIHtkaWRpLkluamVjdG9yfSBpbmplY3RvclxuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtHcmFwaGljc0ZhY3Rvcnl9IGdyYXBoaWNzRmFjdG9yeVxuICogQHBhcmFtIHtFbGVtZW50RmFjdG9yeX0gZWxlbWVudEZhY3RvcnlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29ubmVjdGlvblByZXZpZXcoXG4gICAgaW5qZWN0b3IsXG4gICAgY2FudmFzLFxuICAgIGdyYXBoaWNzRmFjdG9yeSxcbiAgICBlbGVtZW50RmFjdG9yeVxuKSB7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fZ3JhcGhpY3NGYWN0b3J5ID0gZ3JhcGhpY3NGYWN0b3J5O1xuICB0aGlzLl9lbGVtZW50RmFjdG9yeSA9IGVsZW1lbnRGYWN0b3J5O1xuXG4gIC8vIG9wdGlvbmFsIGNvbXBvbmVudHNcbiAgdGhpcy5fY29ubmVjdGlvbkRvY2tpbmcgPSBpbmplY3Rvci5nZXQoJ2Nvbm5lY3Rpb25Eb2NraW5nJywgZmFsc2UpO1xuICB0aGlzLl9sYXlvdXRlciA9IGluamVjdG9yLmdldCgnbGF5b3V0ZXInLCBmYWxzZSk7XG59XG5cbkNvbm5lY3Rpb25QcmV2aWV3LiRpbmplY3QgPSBbXG4gICdpbmplY3RvcicsXG4gICdjYW52YXMnLFxuICAnZ3JhcGhpY3NGYWN0b3J5JyxcbiAgJ2VsZW1lbnRGYWN0b3J5J1xuXTtcblxuLyoqXG4gKiBEcmF3IGNvbm5lY3Rpb24gcHJldmlldy5cbiAqXG4gKiBQcm92aWRlIGF0IGxlYXN0IG9uZSBvZiA8c291cmNlLCBjb25uZWN0aW9uU3RhcnQ+IGFuZCA8dGFyZ2V0LCBjb25uZWN0aW9uRW5kPiB0byBjcmVhdGUgYSBwcmV2aWV3LlxuICogSW4gdGhlIGNsZWFuIHVwIHN0YWdlLCBjYWxsIGBjb25uZWN0aW9uUHJldmlldyNjbGVhblVwYCB3aXRoIHRoZSBjb250ZXh0IHRvIHJlbW92ZSBwcmV2aWV3LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdHxib29sZWFufSBjYW5Db25uZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gaGludHNcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLnNoYXBlfSBbaGludHMuc291cmNlXSBzb3VyY2UgZWxlbWVudFxuICogQHBhcmFtIHtkanMubW9kZWwuc2hhcGV9IFtoaW50cy50YXJnZXRdIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0ge1BvaW50fSBbaGludHMuY29ubmVjdGlvblN0YXJ0XSBjb25uZWN0aW9uIHByZXZpZXcgc3RhcnRcbiAqIEBwYXJhbSB7UG9pbnR9IFtoaW50cy5jb25uZWN0aW9uRW5kXSBjb25uZWN0aW9uIHByZXZpZXcgZW5kXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gW2hpbnRzLndheXBvaW50c10gcHJvdmlkZWQgd2F5cG9pbnRzIGZvciBwcmV2aWV3XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoaW50cy5ub0xheW91dF0gdHJ1ZSBpZiBwcmV2aWV3IHNob3VsZCBub3QgYmUgbGFpZCBvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpbnRzLm5vQ3JvcHBpbmddIHRydWUgaWYgcHJldmlldyBzaG91bGQgbm90IGJlIGNyb3BwZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpbnRzLm5vTm9vcF0gdHJ1ZSBpZiBzaW1wbGUgY29ubmVjdGlvbiBzaG91bGQgbm90IGJlIGRyYXduXG4gKi9cbkNvbm5lY3Rpb25QcmV2aWV3LnByb3RvdHlwZS5kcmF3UHJldmlldyA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbkNvbm5lY3QsIGhpbnRzKSB7XG5cbiAgaGludHMgPSBoaW50cyB8fCB7fTtcblxuICB2YXIgY29ubmVjdGlvblByZXZpZXdHZnggPSBjb250ZXh0LmNvbm5lY3Rpb25QcmV2aWV3R2Z4LFxuICAgICAgZ2V0Q29ubmVjdGlvbiA9IGNvbnRleHQuZ2V0Q29ubmVjdGlvbixcbiAgICAgIHNvdXJjZSA9IGhpbnRzLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IGhpbnRzLnRhcmdldCxcbiAgICAgIHdheXBvaW50cyA9IGhpbnRzLndheXBvaW50cyxcbiAgICAgIGNvbm5lY3Rpb25TdGFydCA9IGhpbnRzLmNvbm5lY3Rpb25TdGFydCxcbiAgICAgIGNvbm5lY3Rpb25FbmQgPSBoaW50cy5jb25uZWN0aW9uRW5kLFxuICAgICAgbm9MYXlvdXQgPSBoaW50cy5ub0xheW91dCxcbiAgICAgIG5vQ3JvcHBpbmcgPSBoaW50cy5ub0Nyb3BwaW5nLFxuICAgICAgbm9Ob29wID0gaGludHMubm9Ob29wLFxuICAgICAgY29ubmVjdGlvbjtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCFjb25uZWN0aW9uUHJldmlld0dmeCkge1xuICAgIGNvbm5lY3Rpb25QcmV2aWV3R2Z4ID0gY29udGV4dC5jb25uZWN0aW9uUHJldmlld0dmeCA9IHRoaXMuY3JlYXRlQ29ubmVjdGlvblByZXZpZXdHZngoKTtcbiAgfVxuXG4gIHN2Z0NsZWFyKGNvbm5lY3Rpb25QcmV2aWV3R2Z4KTtcblxuICBpZiAoIWdldENvbm5lY3Rpb24pIHtcbiAgICBnZXRDb25uZWN0aW9uID0gY29udGV4dC5nZXRDb25uZWN0aW9uID0gY2FjaGVSZXR1cm5WYWx1ZXMoZnVuY3Rpb24oY2FuQ29ubmVjdCwgc291cmNlLCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBzZWxmLmdldENvbm5lY3Rpb24oY2FuQ29ubmVjdCwgc291cmNlLCB0YXJnZXQpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGNhbkNvbm5lY3QpIHtcbiAgICBjb25uZWN0aW9uID0gZ2V0Q29ubmVjdGlvbihjYW5Db25uZWN0LCBzb3VyY2UsIHRhcmdldCk7XG4gIH1cblxuICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAhbm9Ob29wICYmIHRoaXMuZHJhd05vb3BQcmV2aWV3KGNvbm5lY3Rpb25QcmV2aWV3R2Z4LCBoaW50cyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29ubmVjdGlvbi53YXlwb2ludHMgPSB3YXlwb2ludHMgfHwgW107XG5cbiAgLy8gb3B0aW9uYWwgbGF5b3V0XG4gIGlmICh0aGlzLl9sYXlvdXRlciAmJiAhbm9MYXlvdXQpIHtcbiAgICBjb25uZWN0aW9uLndheXBvaW50cyA9IHRoaXMuX2xheW91dGVyLmxheW91dENvbm5lY3Rpb24oY29ubmVjdGlvbiwge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGNvbm5lY3Rpb25TdGFydDogY29ubmVjdGlvblN0YXJ0LFxuICAgICAgY29ubmVjdGlvbkVuZDogY29ubmVjdGlvbkVuZCxcbiAgICAgIHdheXBvaW50czogaGludHMud2F5cG9pbnRzIHx8IGNvbm5lY3Rpb24ud2F5cG9pbnRzXG4gICAgfSk7XG4gIH1cblxuICAvLyBmYWxsYmFjayBpZiBubyB3YXlwb2ludHMgd2VyZSBwcm92aWRlZCBub3IgY3JlYXRlZCB3aXRoIGxheW91dGVyXG4gIGlmICghY29ubmVjdGlvbi53YXlwb2ludHMgfHwgIWNvbm5lY3Rpb24ud2F5cG9pbnRzLmxlbmd0aCkge1xuICAgIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gW1xuICAgICAgc291cmNlID8gZ2V0TWlkKHNvdXJjZSkgOiBjb25uZWN0aW9uU3RhcnQsXG4gICAgICB0YXJnZXQgPyBnZXRNaWQodGFyZ2V0KSA6IGNvbm5lY3Rpb25FbmRcbiAgICBdO1xuICB9XG5cbiAgLy8gb3B0aW9uYWwgY3JvcHBpbmdcbiAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25Eb2NraW5nICYmIChzb3VyY2UgfHwgdGFyZ2V0KSAmJiAhbm9Dcm9wcGluZykge1xuICAgIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gdGhpcy5fY29ubmVjdGlvbkRvY2tpbmcuZ2V0Q3JvcHBlZFdheXBvaW50cyhjb25uZWN0aW9uLCBzb3VyY2UsIHRhcmdldCk7XG4gIH1cblxuICB0aGlzLl9ncmFwaGljc0ZhY3RvcnkuZHJhd0Nvbm5lY3Rpb24oY29ubmVjdGlvblByZXZpZXdHZngsIGNvbm5lY3Rpb24pO1xufTtcblxuLyoqXG4gKiBEcmF3IHNpbXBsZSBjb25uZWN0aW9uIGJldHdlZW4gc291cmNlIGFuZCB0YXJnZXQgb3IgcHJvdmlkZWQgcG9pbnRzLlxuICpcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gY29ubmVjdGlvblByZXZpZXdHZnggY29udGFpbmVyIGZvciB0aGUgY29ubmVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGhpbnRzXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5zaGFwZX0gW2hpbnRzLnNvdXJjZV0gc291cmNlIGVsZW1lbnRcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLnNoYXBlfSBbaGludHMudGFyZ2V0XSB0YXJnZXQgZWxlbWVudFxuICogQHBhcmFtIHtQb2ludH0gW2hpbnRzLmNvbm5lY3Rpb25TdGFydF0gcmVxdWlyZWQgaWYgc291cmNlIGlzIG5vdCBwcm92aWRlZFxuICogQHBhcmFtIHtQb2ludH0gW2hpbnRzLmNvbm5lY3Rpb25FbmRdIHJlcXVpcmVkIGlmIHRhcmdldCBpcyBub3QgcHJvdmlkZWRcbiAqL1xuQ29ubmVjdGlvblByZXZpZXcucHJvdG90eXBlLmRyYXdOb29wUHJldmlldyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25QcmV2aWV3R2Z4LCBoaW50cykge1xuICB2YXIgc291cmNlID0gaGludHMuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gaGludHMudGFyZ2V0LFxuICAgICAgc3RhcnQgPSBoaW50cy5jb25uZWN0aW9uU3RhcnQgfHwgZ2V0TWlkKHNvdXJjZSksXG4gICAgICBlbmQgPSBoaW50cy5jb25uZWN0aW9uRW5kIHx8IGdldE1pZCh0YXJnZXQpO1xuXG4gIHZhciB3YXlwb2ludHMgPSB0aGlzLmNyb3BXYXlwb2ludHMoc3RhcnQsIGVuZCwgc291cmNlLCB0YXJnZXQpO1xuXG4gIHZhciBjb25uZWN0aW9uID0gdGhpcy5jcmVhdGVOb29wQ29ubmVjdGlvbih3YXlwb2ludHNbMF0sIHdheXBvaW50c1sxXSk7XG5cbiAgc3ZnQXBwZW5kKGNvbm5lY3Rpb25QcmV2aWV3R2Z4LCBjb25uZWN0aW9uKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGNyb3BwZWQgd2F5cG9pbnRzLlxuICpcbiAqIEBwYXJhbSB7UG9pbnR9IHN0YXJ0XG4gKiBAcGFyYW0ge1BvaW50fSBlbmRcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLnNoYXBlfSBzb3VyY2VcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLnNoYXBlfSB0YXJnZXRcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbkNvbm5lY3Rpb25QcmV2aWV3LnByb3RvdHlwZS5jcm9wV2F5cG9pbnRzID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc291cmNlLCB0YXJnZXQpIHtcbiAgdmFyIGdyYXBoaWNzRmFjdG9yeSA9IHRoaXMuX2dyYXBoaWNzRmFjdG9yeSxcbiAgICAgIHNvdXJjZVBhdGggPSBzb3VyY2UgJiYgZ3JhcGhpY3NGYWN0b3J5LmdldFNoYXBlUGF0aChzb3VyY2UpLFxuICAgICAgdGFyZ2V0UGF0aCA9IHRhcmdldCAmJiBncmFwaGljc0ZhY3RvcnkuZ2V0U2hhcGVQYXRoKHRhcmdldCksXG4gICAgICBjb25uZWN0aW9uUGF0aCA9IGdyYXBoaWNzRmFjdG9yeS5nZXRDb25uZWN0aW9uUGF0aCh7IHdheXBvaW50czogWyBzdGFydCwgZW5kIF0gfSk7XG5cbiAgc3RhcnQgPSAoc291cmNlICYmIGdldEVsZW1lbnRMaW5lSW50ZXJzZWN0aW9uKHNvdXJjZVBhdGgsIGNvbm5lY3Rpb25QYXRoLCB0cnVlKSkgfHwgc3RhcnQ7XG4gIGVuZCA9ICh0YXJnZXQgJiYgZ2V0RWxlbWVudExpbmVJbnRlcnNlY3Rpb24odGFyZ2V0UGF0aCwgY29ubmVjdGlvblBhdGgsIGZhbHNlKSkgfHwgZW5kO1xuXG4gIHJldHVybiBbIHN0YXJ0LCBlbmQgXTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGNvbm5lY3Rpb24gcHJldmlldyBjb250YWluZXIgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gW2NvbnRleHQuY29ubmVjdGlvblByZXZpZXdHZnhdIHByZXZpZXcgY29udGFpbmVyXG4gKi9cbkNvbm5lY3Rpb25QcmV2aWV3LnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24oY29udGV4dCkge1xuICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNvbm5lY3Rpb25QcmV2aWV3R2Z4KSB7XG4gICAgc3ZnUmVtb3ZlKGNvbnRleHQuY29ubmVjdGlvblByZXZpZXdHZngpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBjb25uZWN0aW9uIHRoYXQgY29ubmVjdHMgc291cmNlIGFuZCB0YXJnZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gY2FuQ29ubmVjdFxuICpcbiAqIEByZXR1cm5zIHtkanMubW9kZWwuY29ubmVjdGlvbn1cbiAqL1xuQ29ubmVjdGlvblByZXZpZXcucHJvdG90eXBlLmdldENvbm5lY3Rpb24gPSBmdW5jdGlvbihjYW5Db25uZWN0KSB7XG4gIHZhciBhdHRycyA9IGVuc3VyZUNvbm5lY3Rpb25BdHRycyhjYW5Db25uZWN0KTtcblxuICByZXR1cm4gdGhpcy5fZWxlbWVudEZhY3RvcnkuY3JlYXRlQ29ubmVjdGlvbihhdHRycyk7XG59O1xuXG5cbi8qKlxuICogQWRkIGFuZCByZXR1cm4gcHJldmlldyBncmFwaGljcy5cbiAqXG4gKiBAcmV0dXJucyB7U1ZHRWxlbWVudH1cbiAqL1xuQ29ubmVjdGlvblByZXZpZXcucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb25QcmV2aWV3R2Z4ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBnZnggPSBzdmdDcmVhdGUoJ2cnKTtcblxuICBzdmdBdHRyKGdmeCwge1xuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICB9KTtcblxuICBzdmdDbGFzc2VzKGdmeCkuYWRkKE1BUktFUl9DT05ORUNUSU9OX1BSRVZJRVcpO1xuXG4gIHN2Z0FwcGVuZCh0aGlzLl9jYW52YXMuZ2V0RGVmYXVsdExheWVyKCksIGdmeCk7XG5cbiAgcmV0dXJuIGdmeDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gc2ltcGxlIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtQb2ludH0gc3RhcnRcbiAqIEBwYXJhbSB7UG9pbnR9IGVuZFxuICpcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fVxuICovXG5Db25uZWN0aW9uUHJldmlldy5wcm90b3R5cGUuY3JlYXRlTm9vcENvbm5lY3Rpb24gPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBjb25uZWN0aW9uID0gc3ZnQ3JlYXRlKCdwb2x5bGluZScpO1xuXG4gIHN2Z0F0dHIoY29ubmVjdGlvbiwge1xuICAgICdzdHJva2UnOiAnIzMzMycsXG4gICAgJ3N0cm9rZURhc2hhcnJheSc6IFsgMSBdLFxuICAgICdzdHJva2VXaWR0aCc6IDIsXG4gICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnXG4gIH0pO1xuXG4gIHN2Z0F0dHIoY29ubmVjdGlvbiwgeyAncG9pbnRzJzogWyBzdGFydC54LCBzdGFydC55LCBlbmQueCwgZW5kLnkgXSB9KTtcblxuICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG4vKipcbiAqIFJldHVybnMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGNhY2hlZCByZXR1cm4gdmFsdWVzIHJlZmVyZW5jZWQgYnkgc3RyaW5naWZpZWQgZmlyc3QgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY2FjaGVSZXR1cm5WYWx1ZXMoZm4pIHtcbiAgdmFyIHJldHVyblZhbHVlcyA9IHt9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gY2FjaGVkIHJldHVybiB2YWx1ZSByZWZlcmVuY2VkIGJ5IHN0cmluZ2lmaWVkIGZpcnN0IGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbihmaXJzdEFyZ3VtZW50KSB7XG4gICAgdmFyIGtleSA9IEpTT04uc3RyaW5naWZ5KGZpcnN0QXJndW1lbnQpO1xuXG4gICAgdmFyIHJldHVyblZhbHVlID0gcmV0dXJuVmFsdWVzW2tleV07XG5cbiAgICBpZiAoIXJldHVyblZhbHVlKSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlc1trZXldID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH07XG59XG5cbi8qKlxuICogRW5zdXJlIGNvbm5lY3Rpb24gYXR0cmlidXRlcyBpcyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gY2FuQ29ubmVjdFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUNvbm5lY3Rpb25BdHRycyhjYW5Db25uZWN0KSB7XG4gIGlmIChpc09iamVjdChjYW5Db25uZWN0KSkge1xuICAgIHJldHVybiBjYW5Db25uZWN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuIiwiaW1wb3J0IENvbm5lY3Rpb25QcmV2aWV3IGZyb20gJy4vQ29ubmVjdGlvblByZXZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdjb25uZWN0aW9uUHJldmlldycgXSxcbiAgY29ubmVjdGlvblByZXZpZXc6IFsgJ3R5cGUnLCBDb25uZWN0aW9uUHJldmlldyBdXG59O1xuIiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBpc0Z1bmN0aW9uLFxuICBpc0FycmF5LFxuICBmb3JFYWNoLFxuICBpc0RlZmluZWRcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBkZWxlZ2F0ZSBhcyBkb21EZWxlZ2F0ZSxcbiAgZXZlbnQgYXMgZG9tRXZlbnQsXG4gIGF0dHIgYXMgZG9tQXR0cixcbiAgcXVlcnkgYXMgZG9tUXVlcnksXG4gIGNsYXNzZXMgYXMgZG9tQ2xhc3NlcyxcbiAgZG9taWZ5IGFzIGRvbWlmeVxufSBmcm9tICdtaW4tZG9tJztcblxudmFyIGVudHJ5U2VsZWN0b3IgPSAnLmVudHJ5JztcblxudmFyIERFRkFVTFRfUFJJT1JJVFkgPSAxMDAwO1xuXG5cbi8qKlxuICogQSBjb250ZXh0IHBhZCB0aGF0IGRpc3BsYXlzIGVsZW1lbnQgc3BlY2lmaWMsIGNvbnRleHR1YWwgYWN0aW9ucyBuZXh0XG4gKiB0byBhIGRpYWdyYW0gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbY29uZmlnLnNjYWxlPXsgbWluOiAxLjAsIG1heDogMS41IH1dXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5zY2FsZS5taW5dXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5zY2FsZS5tYXhdXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtPdmVybGF5c30gb3ZlcmxheXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29udGV4dFBhZChjb25maWcsIGV2ZW50QnVzLCBvdmVybGF5cykge1xuXG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX292ZXJsYXlzID0gb3ZlcmxheXM7XG5cbiAgdmFyIHNjYWxlID0gaXNEZWZpbmVkKGNvbmZpZyAmJiBjb25maWcuc2NhbGUpID8gY29uZmlnLnNjYWxlIDoge1xuICAgIG1pbjogMSxcbiAgICBtYXg6IDEuNVxuICB9O1xuXG4gIHRoaXMuX292ZXJsYXlzQ29uZmlnID0ge1xuICAgIHBvc2l0aW9uOiB7XG4gICAgICByaWdodDogLTksXG4gICAgICB0b3A6IC02XG4gICAgfSxcbiAgICBzY2FsZTogc2NhbGVcbiAgfTtcblxuICB0aGlzLl9jdXJyZW50ID0gbnVsbDtcblxuICB0aGlzLl9pbml0KCk7XG59XG5cbkNvbnRleHRQYWQuJGluamVjdCA9IFtcbiAgJ2NvbmZpZy5jb250ZXh0UGFkJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ292ZXJsYXlzJ1xuXTtcblxuXG4vKipcbiAqIFJlZ2lzdGVycyBldmVudHMgbmVlZGVkIGZvciBpbnRlcmFjdGlvbiB3aXRoIG90aGVyIGNvbXBvbmVudHNcbiAqL1xuQ29udGV4dFBhZC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRCdXMub24oJ3NlbGVjdGlvbi5jaGFuZ2VkJywgZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIHNlbGVjdGlvbiA9IGUubmV3U2VsZWN0aW9uO1xuXG4gICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNlbGYub3BlbihzZWxlY3Rpb25bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcblxuICBldmVudEJ1cy5vbignZWxlbWVudHMuZGVsZXRlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBldmVudC5lbGVtZW50cztcblxuICAgIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChzZWxmLmlzT3BlbihlKSkge1xuICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50LmNoYW5nZWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudCxcbiAgICAgICAgY3VycmVudCA9IHNlbGYuX2N1cnJlbnQ7XG5cbiAgICAvLyBmb3JjZSByZW9wZW4gaWYgZWxlbWVudCBmb3Igd2hpY2ggd2UgYXJlIGN1cnJlbnRseSBvcGVuZWQgY2hhbmdlZFxuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuZWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgICAgc2VsZi5vcGVuKGVsZW1lbnQsIHRydWUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBwcm92aWRlciB3aXRoIHRoZSBjb250ZXh0IHBhZFxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gW3ByaW9yaXR5PTEwMDBdXG4gKiBAcGFyYW0gIHtDb250ZXh0UGFkUHJvdmlkZXJ9IHByb3ZpZGVyXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGNvbnRleHRQYWRQcm92aWRlciA9IHtcbiAgKiAgIGdldENvbnRleHRQYWRFbnRyaWVzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICogICAgIHJldHVybiBmdW5jdGlvbihlbnRyaWVzKSB7XG4gICogICAgICAgcmV0dXJuIHtcbiAgKiAgICAgICAgIC4uLmVudHJpZXMsXG4gICogICAgICAgICAnZW50cnktMSc6IHtcbiAgKiAgICAgICAgICAgbGFiZWw6ICdNeSBFbnRyeScsXG4gICogICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IGFsZXJ0KFwiSSBoYXZlIGJlZW4gY2xpY2tlZCFcIik7IH1cbiAgKiAgICAgICAgIH1cbiAgKiAgICAgICB9O1xuICAqICAgICB9XG4gICogICB9XG4gICogfTtcbiAgKlxuICogY29udGV4dFBhZC5yZWdpc3RlclByb3ZpZGVyKDgwMCwgY29udGV4dFBhZFByb3ZpZGVyKTtcbiAqL1xuQ29udGV4dFBhZC5wcm90b3R5cGUucmVnaXN0ZXJQcm92aWRlciA9IGZ1bmN0aW9uKHByaW9yaXR5LCBwcm92aWRlcikge1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgcHJvdmlkZXIgPSBwcmlvcml0eTtcbiAgICBwcmlvcml0eSA9IERFRkFVTFRfUFJJT1JJVFk7XG4gIH1cblxuICB0aGlzLl9ldmVudEJ1cy5vbignY29udGV4dFBhZC5nZXRQcm92aWRlcnMnLCBwcmlvcml0eSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBldmVudC5wcm92aWRlcnMucHVzaChwcm92aWRlcik7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRleHQgcGFkIGVudHJpZXMgZm9yIGEgZ2l2ZW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7ZGpzLmVsZW1lbnQuQmFzZX0gZWxlbWVudFxuICpcbiAqIEByZXR1cm4ge0FycmF5PENvbnRleHRQYWRFbnRyeURlc2NyaXB0b3I+fSBsaXN0IG9mIGVudHJpZXNcbiAqL1xuQ29udGV4dFBhZC5wcm90b3R5cGUuZ2V0RW50cmllcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIHByb3ZpZGVycyA9IHRoaXMuX2dldFByb3ZpZGVycygpO1xuXG4gIHZhciBlbnRyaWVzID0ge307XG5cbiAgLy8gbG9vcCB0aHJvdWdoIGFsbCBwcm92aWRlcnMgYW5kIHRoZWlyIGVudHJpZXMuXG4gIC8vIGdyb3VwIGVudHJpZXMgYnkgaWQgc28gdGhhdCBvdmVycmlkaW5nIGFuIGVudHJ5IGlzIHBvc3NpYmxlXG4gIGZvckVhY2gocHJvdmlkZXJzLCBmdW5jdGlvbihwcm92aWRlcikge1xuICAgIHZhciBlbnRyaWVzT3JVcGRhdGVyID0gcHJvdmlkZXIuZ2V0Q29udGV4dFBhZEVudHJpZXMoZWxlbWVudCk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihlbnRyaWVzT3JVcGRhdGVyKSkge1xuICAgICAgZW50cmllcyA9IGVudHJpZXNPclVwZGF0ZXIoZW50cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2goZW50cmllc09yVXBkYXRlciwgZnVuY3Rpb24oZW50cnksIGlkKSB7XG4gICAgICAgIGVudHJpZXNbaWRdID0gZW50cnk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlbnRyaWVzO1xufTtcblxuXG4vKipcbiAqIFRyaWdnZXIgYW4gYWN0aW9uIGF2YWlsYWJsZSBvbiB0aGUgb3BlbmVkIGNvbnRleHQgcGFkXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBhY3Rpb25cbiAqIEBwYXJhbSAge0V2ZW50fSBldmVudFxuICogQHBhcmFtICB7Ym9vbGVhbn0gW2F1dG9BY3RpdmF0ZT1mYWxzZV1cbiAqL1xuQ29udGV4dFBhZC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGFjdGlvbiwgZXZlbnQsIGF1dG9BY3RpdmF0ZSkge1xuXG4gIHZhciBlbGVtZW50ID0gdGhpcy5fY3VycmVudC5lbGVtZW50LFxuICAgICAgZW50cmllcyA9IHRoaXMuX2N1cnJlbnQuZW50cmllcyxcbiAgICAgIGVudHJ5LFxuICAgICAgaGFuZGxlcixcbiAgICAgIG9yaWdpbmFsRXZlbnQsXG4gICAgICBidXR0b24gPSBldmVudC5kZWxlZ2F0ZVRhcmdldCB8fCBldmVudC50YXJnZXQ7XG5cbiAgaWYgKCFidXR0b24pIHtcbiAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIGVudHJ5ID0gZW50cmllc1tkb21BdHRyKGJ1dHRvbiwgJ2RhdGEtYWN0aW9uJyldO1xuICBoYW5kbGVyID0gZW50cnkuYWN0aW9uO1xuXG4gIG9yaWdpbmFsRXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50O1xuXG4gIC8vIHNpbXBsZSBhY3Rpb24gKHZpYSBjYWxsYmFjayBmdW5jdGlvbilcbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBpZiAoYWN0aW9uID09PSAnY2xpY2snKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcihvcmlnaW5hbEV2ZW50LCBlbGVtZW50LCBhdXRvQWN0aXZhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaGFuZGxlclthY3Rpb25dKSB7XG4gICAgICByZXR1cm4gaGFuZGxlclthY3Rpb25dKG9yaWdpbmFsRXZlbnQsIGVsZW1lbnQsIGF1dG9BY3RpdmF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2lsZW5jZSBvdGhlciBhY3Rpb25zXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG5cbi8qKlxuICogT3BlbiB0aGUgY29udGV4dCBwYWQgZm9yIHRoZSBnaXZlbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZSBpZiB0cnVlLCBmb3JjZSByZW9wZW5pbmcgdGhlIGNvbnRleHQgcGFkXG4gKi9cbkNvbnRleHRQYWQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihlbGVtZW50LCBmb3JjZSkge1xuICBpZiAoIWZvcmNlICYmIHRoaXMuaXNPcGVuKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5jbG9zZSgpO1xuICB0aGlzLl91cGRhdGVBbmRPcGVuKGVsZW1lbnQpO1xufTtcblxuQ29udGV4dFBhZC5wcm90b3R5cGUuX2dldFByb3ZpZGVycyA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBldmVudCA9IHRoaXMuX2V2ZW50QnVzLmNyZWF0ZUV2ZW50KHtcbiAgICB0eXBlOiAnY29udGV4dFBhZC5nZXRQcm92aWRlcnMnLFxuICAgIHByb3ZpZGVyczogW11cbiAgfSk7XG5cbiAgdGhpcy5fZXZlbnRCdXMuZmlyZShldmVudCk7XG5cbiAgcmV0dXJuIGV2ZW50LnByb3ZpZGVycztcbn07XG5cbkNvbnRleHRQYWQucHJvdG90eXBlLl91cGRhdGVBbmRPcGVuID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5nZXRFbnRyaWVzKGVsZW1lbnQpLFxuICAgICAgcGFkID0gdGhpcy5nZXRQYWQoZWxlbWVudCksXG4gICAgICBodG1sID0gcGFkLmh0bWw7XG5cbiAgZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSwgaWQpIHtcbiAgICB2YXIgZ3JvdXBpbmcgPSBlbnRyeS5ncm91cCB8fCAnZGVmYXVsdCcsXG4gICAgICAgIGNvbnRyb2wgPSBkb21pZnkoZW50cnkuaHRtbCB8fCAnPGRpdiBjbGFzcz1cImVudHJ5XCIgZHJhZ2dhYmxlPVwidHJ1ZVwiPjwvZGl2PicpLFxuICAgICAgICBjb250YWluZXI7XG5cbiAgICBkb21BdHRyKGNvbnRyb2wsICdkYXRhLWFjdGlvbicsIGlkKTtcblxuICAgIGNvbnRhaW5lciA9IGRvbVF1ZXJ5KCdbZGF0YS1ncm91cD0nICsgZ3JvdXBpbmcgKyAnXScsIGh0bWwpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIgPSBkb21pZnkoJzxkaXYgY2xhc3M9XCJncm91cFwiIGRhdGEtZ3JvdXA9XCInICsgZ3JvdXBpbmcgKyAnXCI+PC9kaXY+Jyk7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2wpO1xuXG4gICAgaWYgKGVudHJ5LmNsYXNzTmFtZSkge1xuICAgICAgYWRkQ2xhc3Nlcyhjb250cm9sLCBlbnRyeS5jbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGlmIChlbnRyeS50aXRsZSkge1xuICAgICAgZG9tQXR0cihjb250cm9sLCAndGl0bGUnLCBlbnRyeS50aXRsZSk7XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5LmltYWdlVXJsKSB7XG4gICAgICBjb250cm9sLmFwcGVuZENoaWxkKGRvbWlmeSgnPGltZyBzcmM9XCInICsgZW50cnkuaW1hZ2VVcmwgKyAnXCI+JykpO1xuICAgIH1cbiAgfSk7XG5cbiAgZG9tQ2xhc3NlcyhodG1sKS5hZGQoJ29wZW4nKTtcblxuICB0aGlzLl9jdXJyZW50ID0ge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgcGFkOiBwYWQsXG4gICAgZW50cmllczogZW50cmllc1xuICB9O1xuXG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NvbnRleHRQYWQub3BlbicsIHsgY3VycmVudDogdGhpcy5fY3VycmVudCB9KTtcbn07XG5cblxuQ29udGV4dFBhZC5wcm90b3R5cGUuZ2V0UGFkID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50LnBhZDtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgb3ZlcmxheXMgPSB0aGlzLl9vdmVybGF5cztcblxuICB2YXIgaHRtbCA9IGRvbWlmeSgnPGRpdiBjbGFzcz1cImRqcy1jb250ZXh0LXBhZFwiPjwvZGl2PicpO1xuXG4gIHZhciBvdmVybGF5c0NvbmZpZyA9IGFzc2lnbih7XG4gICAgaHRtbDogaHRtbFxuICB9LCB0aGlzLl9vdmVybGF5c0NvbmZpZyk7XG5cbiAgZG9tRGVsZWdhdGUuYmluZChodG1sLCBlbnRyeVNlbGVjdG9yLCAnY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgIHNlbGYudHJpZ2dlcignY2xpY2snLCBldmVudCk7XG4gIH0pO1xuXG4gIGRvbURlbGVnYXRlLmJpbmQoaHRtbCwgZW50cnlTZWxlY3RvciwgJ2RyYWdzdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgc2VsZi50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldmVudCk7XG4gIH0pO1xuXG4gIC8vIHN0b3AgcHJvcGFnYXRpb24gb2YgbW91c2UgZXZlbnRzXG4gIGRvbUV2ZW50LmJpbmQoaHRtbCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pO1xuXG4gIHRoaXMuX292ZXJsYXlJZCA9IG92ZXJsYXlzLmFkZChlbGVtZW50LCAnY29udGV4dC1wYWQnLCBvdmVybGF5c0NvbmZpZyk7XG5cbiAgdmFyIHBhZCA9IG92ZXJsYXlzLmdldCh0aGlzLl9vdmVybGF5SWQpO1xuXG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NvbnRleHRQYWQuY3JlYXRlJywgeyBlbGVtZW50OiBlbGVtZW50LCBwYWQ6IHBhZCB9KTtcblxuICByZXR1cm4gcGFkO1xufTtcblxuXG4vKipcbiAqIENsb3NlIHRoZSBjb250ZXh0IHBhZFxuICovXG5Db250ZXh0UGFkLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaXNPcGVuKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9vdmVybGF5cy5yZW1vdmUodGhpcy5fb3ZlcmxheUlkKTtcblxuICB0aGlzLl9vdmVybGF5SWQgPSBudWxsO1xuXG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NvbnRleHRQYWQuY2xvc2UnLCB7IGN1cnJlbnQ6IHRoaXMuX2N1cnJlbnQgfSk7XG5cbiAgdGhpcy5fY3VycmVudCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHBhZCBpcyBvcGVuLiBJZiBlbGVtZW50IGlzIGdpdmVuLCB3aWxsIGNoZWNrXG4gKiBpZiBwYWQgaXMgb3BlbmVkIHdpdGggZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkNvbnRleHRQYWQucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuICEhdGhpcy5fY3VycmVudCAmJiAoIWVsZW1lbnQgPyB0cnVlIDogdGhpcy5fY3VycmVudC5lbGVtZW50ID09PSBlbGVtZW50KTtcbn07XG5cblxuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBhZGRDbGFzc2VzKGVsZW1lbnQsIGNsYXNzTmFtZXMpIHtcblxuICB2YXIgY2xhc3NlcyA9IGRvbUNsYXNzZXMoZWxlbWVudCk7XG5cbiAgdmFyIGFjdHVhbENsYXNzTmFtZXMgPSBpc0FycmF5KGNsYXNzTmFtZXMpID8gY2xhc3NOYW1lcyA6IGNsYXNzTmFtZXMuc3BsaXQoL1xccysvZyk7XG4gIGFjdHVhbENsYXNzTmFtZXMuZm9yRWFjaChmdW5jdGlvbihjbHMpIHtcbiAgICBjbGFzc2VzLmFkZChjbHMpO1xuICB9KTtcbn0iLCJpbXBvcnQgSW50ZXJhY3Rpb25FdmVudHNNb2R1bGUgZnJvbSAnLi4vaW50ZXJhY3Rpb24tZXZlbnRzJztcbmltcG9ydCBPdmVybGF5c01vZHVsZSBmcm9tICcuLi9vdmVybGF5cyc7XG5cbmltcG9ydCBDb250ZXh0UGFkIGZyb20gJy4vQ29udGV4dFBhZCc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIEludGVyYWN0aW9uRXZlbnRzTW9kdWxlLFxuICAgIE92ZXJsYXlzTW9kdWxlXG4gIF0sXG4gIGNvbnRleHRQYWQ6IFsgJ3R5cGUnLCBDb250ZXh0UGFkIF1cbn07IiwiaW1wb3J0IHtcbiAgYXNzaWduLFxuICBmaW5kLFxuICBmb3JFYWNoLFxuICBpc0FycmF5LFxuICBpc051bWJlcixcbiAgbWFwLFxuICBtYXRjaFBhdHRlcm4sXG4gIG9taXQsXG4gIHNvcnRCeVxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGdldEJCb3gsXG4gIGdldFBhcmVudHNcbn0gZnJvbSAnLi4vLi4vdXRpbC9FbGVtZW50cyc7XG5cbmltcG9ydCB7IGVhY2hFbGVtZW50IH0gZnJvbSAnLi4vLi4vdXRpbC9FbGVtZW50cyc7XG5cbi8qKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSA8Y29weVBhc3RlLmNhbkNvcHlFbGVtZW50cz4gbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGNvbnRleHQuZWxlbWVudHNcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fGJvb2xlYW59IC0gUmV0dXJuIGVsZW1lbnRzIHRvIGJlIGNvcGllZCBvciBmYWxzZSB0byBkaXNhbGxvd1xuICogY29weWluZy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtGdW5jdGlvbn0gPGNvcHlQYXN0ZS5jb3B5RWxlbWVudD4gbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQuZGVzY3JpcHRvclxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gY29udGV4dC5lbGVtZW50XG4gKiBAcGFyYW0ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gY29udGV4dC5lbGVtZW50c1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSA8Y29weVBhc3RlLmVsZW1lbnRzQ29waWVkPiBsaXN0ZW5lclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dC5lbGVtZW50c1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQudHJlZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSA8Y29weVBhc3RlLnBhc3RlRWxlbWVudD4gbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQuY2FjaGUgLSBBbHJlYWR5IGNyZWF0ZWQgZWxlbWVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dC5kZXNjcmlwdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RnVuY3Rpb259IDxjb3B5UGFzdGUucGFzdGVFbGVtZW50cz4gbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQuaGludHMgLSBBZGQgaGludHMgYmVmb3JlIHBhc3RpbmcuXG4gKi9cblxuLyoqXG4gKiBDb3B5IGFuZCBwYXN0ZSBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKiBAcGFyYW0ge0NyZWF0ZX0gY3JlYXRlXG4gKiBAcGFyYW0ge0NsaXBib2FyZH0gY2xpcGJvYXJkXG4gKiBAcGFyYW0ge0VsZW1lbnRGYWN0b3J5fSBlbGVtZW50RmFjdG9yeVxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKiBAcGFyYW0ge01vdXNlfSBtb3VzZVxuICogQHBhcmFtIHtSdWxlc30gcnVsZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29weVBhc3RlKFxuICAgIGNhbnZhcyxcbiAgICBjcmVhdGUsXG4gICAgY2xpcGJvYXJkLFxuICAgIGVsZW1lbnRGYWN0b3J5LFxuICAgIGV2ZW50QnVzLFxuICAgIG1vZGVsaW5nLFxuICAgIG1vdXNlLFxuICAgIHJ1bGVzXG4pIHtcblxuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gIHRoaXMuX2NyZWF0ZSA9IGNyZWF0ZTtcbiAgdGhpcy5fY2xpcGJvYXJkID0gY2xpcGJvYXJkO1xuICB0aGlzLl9lbGVtZW50RmFjdG9yeSA9IGVsZW1lbnRGYWN0b3J5O1xuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuICB0aGlzLl9tb3VzZSA9IG1vdXNlO1xuICB0aGlzLl9ydWxlcyA9IHJ1bGVzO1xuXG4gIGV2ZW50QnVzLm9uKCdjb3B5UGFzdGUuY29weUVsZW1lbnQnLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBjb250ZXh0LmRlc2NyaXB0b3IsXG4gICAgICAgIGVsZW1lbnQgPSBjb250ZXh0LmVsZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzID0gY29udGV4dC5lbGVtZW50cztcblxuICAgIC8vIGRlZmF1bHQgcHJpb3JpdHkgKHByaW9yaXR5ID0gMSlcbiAgICBkZXNjcmlwdG9yLnByaW9yaXR5ID0gMTtcblxuICAgIGRlc2NyaXB0b3IuaWQgPSBlbGVtZW50LmlkO1xuXG4gICAgdmFyIHBhcmVudENvcGllZCA9IGZpbmQoZWxlbWVudHMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBlID09PSBlbGVtZW50LnBhcmVudDtcbiAgICB9KTtcblxuICAgIC8vIGRvIE5PVCByZWZlcmVuY2UgcGFyZW50IGlmIHBhcmVudCB3YXNuJ3QgY29waWVkXG4gICAgaWYgKHBhcmVudENvcGllZCkge1xuICAgICAgZGVzY3JpcHRvci5wYXJlbnQgPSBlbGVtZW50LnBhcmVudC5pZDtcbiAgICB9XG5cbiAgICAvLyBhdHRhY2hlcnMgKHByaW9yaXR5ID0gMilcbiAgICBpZiAoaXNBdHRhY2hlcihlbGVtZW50KSkge1xuICAgICAgZGVzY3JpcHRvci5wcmlvcml0eSA9IDI7XG5cbiAgICAgIGRlc2NyaXB0b3IuaG9zdCA9IGVsZW1lbnQuaG9zdC5pZDtcbiAgICB9XG5cbiAgICAvLyBjb25uZWN0aW9ucyAocHJpb3JpdHkgPSAzKVxuICAgIGlmIChpc0Nvbm5lY3Rpb24oZWxlbWVudCkpIHtcbiAgICAgIGRlc2NyaXB0b3IucHJpb3JpdHkgPSAzO1xuXG4gICAgICBkZXNjcmlwdG9yLnNvdXJjZSA9IGVsZW1lbnQuc291cmNlLmlkO1xuICAgICAgZGVzY3JpcHRvci50YXJnZXQgPSBlbGVtZW50LnRhcmdldC5pZDtcblxuICAgICAgZGVzY3JpcHRvci53YXlwb2ludHMgPSBjb3B5V2F5cG9pbnRzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIGxhYmVscyAocHJpb3JpdHkgPSA0KVxuICAgIGlmIChpc0xhYmVsKGVsZW1lbnQpKSB7XG4gICAgICBkZXNjcmlwdG9yLnByaW9yaXR5ID0gNDtcblxuICAgICAgZGVzY3JpcHRvci5sYWJlbFRhcmdldCA9IGVsZW1lbnQubGFiZWxUYXJnZXQuaWQ7XG4gICAgfVxuXG4gICAgZm9yRWFjaChbICd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JyBdLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgaWYgKGlzTnVtYmVyKGVsZW1lbnRbIHByb3BlcnR5IF0pKSB7XG4gICAgICAgIGRlc2NyaXB0b3JbIHByb3BlcnR5IF0gPSBlbGVtZW50WyBwcm9wZXJ0eSBdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVzY3JpcHRvci5oaWRkZW4gPSBlbGVtZW50LmhpZGRlbjtcbiAgICBkZXNjcmlwdG9yLmNvbGxhcHNlZCA9IGVsZW1lbnQuY29sbGFwc2VkO1xuXG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjb3B5UGFzdGUucGFzdGVFbGVtZW50cycsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgaGludHMgPSBjb250ZXh0LmhpbnRzO1xuXG4gICAgYXNzaWduKGhpbnRzLCB7XG4gICAgICBjcmVhdGVFbGVtZW50c0JlaGF2aW9yOiBmYWxzZVxuICAgIH0pO1xuICB9KTtcbn1cblxuQ29weVBhc3RlLiRpbmplY3QgPSBbXG4gICdjYW52YXMnLFxuICAnY3JlYXRlJyxcbiAgJ2NsaXBib2FyZCcsXG4gICdlbGVtZW50RmFjdG9yeScsXG4gICdldmVudEJ1cycsXG4gICdtb2RlbGluZycsXG4gICdtb3VzZScsXG4gICdydWxlcydcbl07XG5cblxuLyoqXG4gKiBDb3B5IGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBlbGVtZW50c1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbkNvcHlQYXN0ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gIHZhciBhbGxvd2VkLFxuICAgICAgdHJlZTtcblxuICBpZiAoIWlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgZWxlbWVudHMgPSBlbGVtZW50cyA/IFsgZWxlbWVudHMgXSA6IFtdO1xuICB9XG5cbiAgYWxsb3dlZCA9IHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NvcHlQYXN0ZS5jYW5Db3B5RWxlbWVudHMnLCB7XG4gICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkID09PSBmYWxzZSkge1xuICAgIHRyZWUgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICB0cmVlID0gdGhpcy5jcmVhdGVUcmVlKGlzQXJyYXkoYWxsb3dlZCkgPyBhbGxvd2VkIDogZWxlbWVudHMpO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGFuIGVtcHR5IHRyZWUsIHNlbGVjdGlvbiBvZiBlbGVtZW50c1xuICAvLyB0byBjb3B5IHdhcyBlbXB0eS5cbiAgdGhpcy5fY2xpcGJvYXJkLnNldCh0cmVlKTtcblxuICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjb3B5UGFzdGUuZWxlbWVudHNDb3BpZWQnLCB7XG4gICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgIHRyZWU6IHRyZWVcbiAgfSk7XG5cbiAgcmV0dXJuIHRyZWU7XG59O1xuXG4vKipcbiAqIFBhc3RlIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLmJhc2V9IFtjb250ZXh0LmVsZW1lbnRdIC0gUGFyZW50LlxuICogQHBhcmFtIHtQb2ludH0gW2NvbnRleHQucG9pbnRdIC0gUG9zaXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQuaGludHNdIC0gSGludHMuXG4gKi9cbkNvcHlQYXN0ZS5wcm90b3R5cGUucGFzdGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciB0cmVlID0gdGhpcy5fY2xpcGJvYXJkLmdldCgpO1xuXG4gIGlmICh0aGlzLl9jbGlwYm9hcmQuaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhpbnRzID0gY29udGV4dCAmJiBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NvcHlQYXN0ZS5wYXN0ZUVsZW1lbnRzJywge1xuICAgIGhpbnRzOiBoaW50c1xuICB9KTtcblxuICB2YXIgZWxlbWVudHMgPSB0aGlzLl9jcmVhdGVFbGVtZW50cyh0cmVlKTtcblxuICAvLyBwYXN0ZSBkaXJlY3RseVxuICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmVsZW1lbnQgJiYgY29udGV4dC5wb2ludCkge1xuICAgIHJldHVybiB0aGlzLl9wYXN0ZShlbGVtZW50cywgY29udGV4dC5lbGVtZW50LCBjb250ZXh0LnBvaW50LCBoaW50cyk7XG4gIH1cblxuICB0aGlzLl9jcmVhdGUuc3RhcnQodGhpcy5fbW91c2UuZ2V0TGFzdE1vdmVFdmVudCgpLCBlbGVtZW50cywge1xuICAgIGhpbnRzOiBoaW50cyB8fCB7fVxuICB9KTtcbn07XG5cbi8qKlxuICogUGFzdGUgZWxlbWVudHMgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5iYXNlfSB0YXJnZXRcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW2hpbnRzXVxuICovXG5Db3B5UGFzdGUucHJvdG90eXBlLl9wYXN0ZSA9IGZ1bmN0aW9uKGVsZW1lbnRzLCB0YXJnZXQsIHBvc2l0aW9uLCBoaW50cykge1xuXG4gIC8vIG1ha2Ugc3VyZSBlYWNoIGVsZW1lbnQgaGFzIHggYW5kIHlcbiAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghaXNOdW1iZXIoZWxlbWVudC54KSkge1xuICAgICAgZWxlbWVudC54ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTnVtYmVyKGVsZW1lbnQueSkpIHtcbiAgICAgIGVsZW1lbnQueSA9IDA7XG4gICAgfVxuICB9KTtcblxuICB2YXIgYmJveCA9IGdldEJCb3goZWxlbWVudHMpO1xuXG4gIC8vIGNlbnRlciBlbGVtZW50cyBhcm91bmQgY3Vyc29yXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoaXNDb25uZWN0aW9uKGVsZW1lbnQpKSB7XG4gICAgICBlbGVtZW50LndheXBvaW50cyA9IG1hcChlbGVtZW50LndheXBvaW50cywgZnVuY3Rpb24od2F5cG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB3YXlwb2ludC54IC0gYmJveC54IC0gYmJveC53aWR0aCAvIDIsXG4gICAgICAgICAgeTogd2F5cG9pbnQueSAtIGJib3gueSAtIGJib3guaGVpZ2h0IC8gMlxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXNzaWduKGVsZW1lbnQsIHtcbiAgICAgIHg6IGVsZW1lbnQueCAtIGJib3gueCAtIGJib3gud2lkdGggLyAyLFxuICAgICAgeTogZWxlbWVudC55IC0gYmJveC55IC0gYmJveC5oZWlnaHQgLyAyXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzLl9tb2RlbGluZy5jcmVhdGVFbGVtZW50cyhlbGVtZW50cywgcG9zaXRpb24sIHRhcmdldCwgYXNzaWduKHt9LCBoaW50cykpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgZWxlbWVudHMgZnJvbSB0cmVlLlxuICovXG5Db3B5UGFzdGUucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50cyA9IGZ1bmN0aW9uKHRyZWUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIHZhciBjYWNoZSA9IHt9O1xuXG4gIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gIGZvckVhY2godHJlZSwgZnVuY3Rpb24oYnJhbmNoLCBkZXB0aCkge1xuXG4gICAgZGVwdGggPSBwYXJzZUludChkZXB0aCwgMTApO1xuXG4gICAgLy8gc29ydCBieSBwcmlvcml0eVxuICAgIGJyYW5jaCA9IHNvcnRCeShicmFuY2gsICdwcmlvcml0eScpO1xuXG4gICAgZm9yRWFjaChicmFuY2gsIGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcblxuICAgICAgLy8gcmVtb3ZlIHByaW9yaXR5XG4gICAgICB2YXIgYXR0cnMgPSBhc3NpZ24oe30sIG9taXQoZGVzY3JpcHRvciwgWyAncHJpb3JpdHknIF0pKTtcblxuICAgICAgaWYgKGNhY2hlWyBkZXNjcmlwdG9yLnBhcmVudCBdKSB7XG4gICAgICAgIGF0dHJzLnBhcmVudCA9IGNhY2hlWyBkZXNjcmlwdG9yLnBhcmVudCBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGF0dHJzLnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgZXZlbnRCdXMuZmlyZSgnY29weVBhc3RlLnBhc3RlRWxlbWVudCcsIHtcbiAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICBkZXNjcmlwdG9yOiBhdHRyc1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBlbGVtZW50O1xuXG4gICAgICBpZiAoaXNDb25uZWN0aW9uKGF0dHJzKSkge1xuICAgICAgICBhdHRycy5zb3VyY2UgPSBjYWNoZVsgZGVzY3JpcHRvci5zb3VyY2UgXTtcbiAgICAgICAgYXR0cnMudGFyZ2V0ID0gY2FjaGVbIGRlc2NyaXB0b3IudGFyZ2V0IF07XG5cbiAgICAgICAgZWxlbWVudCA9IGNhY2hlWyBkZXNjcmlwdG9yLmlkIF0gPSBzZWxmLmNyZWF0ZUNvbm5lY3Rpb24oYXR0cnMpO1xuXG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNMYWJlbChhdHRycykpIHtcbiAgICAgICAgYXR0cnMubGFiZWxUYXJnZXQgPSBjYWNoZVsgYXR0cnMubGFiZWxUYXJnZXQgXTtcblxuICAgICAgICBlbGVtZW50ID0gY2FjaGVbIGRlc2NyaXB0b3IuaWQgXSA9IHNlbGYuY3JlYXRlTGFiZWwoYXR0cnMpO1xuXG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cnMuaG9zdCkge1xuICAgICAgICBhdHRycy5ob3N0ID0gY2FjaGVbIGF0dHJzLmhvc3QgXTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudCA9IGNhY2hlWyBkZXNjcmlwdG9yLmlkIF0gPSBzZWxmLmNyZWF0ZVNoYXBlKGF0dHJzKTtcblxuICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICB9KTtcblxuICB9KTtcblxuICByZXR1cm4gZWxlbWVudHM7XG59O1xuXG5Db3B5UGFzdGUucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihhdHRycykge1xuICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuX2VsZW1lbnRGYWN0b3J5LmNyZWF0ZUNvbm5lY3Rpb24ob21pdChhdHRycywgWyAnaWQnIF0pKTtcblxuICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG5cbkNvcHlQYXN0ZS5wcm90b3R5cGUuY3JlYXRlTGFiZWwgPSBmdW5jdGlvbihhdHRycykge1xuICB2YXIgbGFiZWwgPSB0aGlzLl9lbGVtZW50RmFjdG9yeS5jcmVhdGVMYWJlbChvbWl0KGF0dHJzLCBbICdpZCcgXSkpO1xuXG4gIHJldHVybiBsYWJlbDtcbn07XG5cbkNvcHlQYXN0ZS5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbihhdHRycykge1xuICB2YXIgc2hhcGUgPSB0aGlzLl9lbGVtZW50RmFjdG9yeS5jcmVhdGVTaGFwZShvbWl0KGF0dHJzLCBbICdpZCcgXSkpO1xuXG4gIHJldHVybiBzaGFwZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2V0aGVyIGVsZW1lbnQgaGFzIHJlbGF0aW9ucyB0byBvdGhlciBlbGVtZW50cyBlLmcuIGF0dGFjaGVycywgbGFiZWxzIGFuZCBjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGVsZW1lbnRcbiAqIEBwYXJhbSAge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZWxlbWVudHNcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQ29weVBhc3RlLnByb3RvdHlwZS5oYXNSZWxhdGlvbnMgPSBmdW5jdGlvbihlbGVtZW50LCBlbGVtZW50cykge1xuICB2YXIgbGFiZWxUYXJnZXQsXG4gICAgICBzb3VyY2UsXG4gICAgICB0YXJnZXQ7XG5cbiAgaWYgKGlzQ29ubmVjdGlvbihlbGVtZW50KSkge1xuICAgIHNvdXJjZSA9IGZpbmQoZWxlbWVudHMsIG1hdGNoUGF0dGVybih7IGlkOiBlbGVtZW50LnNvdXJjZS5pZCB9KSk7XG4gICAgdGFyZ2V0ID0gZmluZChlbGVtZW50cywgbWF0Y2hQYXR0ZXJuKHsgaWQ6IGVsZW1lbnQudGFyZ2V0LmlkIH0pKTtcblxuICAgIGlmICghc291cmNlIHx8ICF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNMYWJlbChlbGVtZW50KSkge1xuICAgIGxhYmVsVGFyZ2V0ID0gZmluZChlbGVtZW50cywgbWF0Y2hQYXR0ZXJuKHsgaWQ6IGVsZW1lbnQubGFiZWxUYXJnZXQuaWQgfSkpO1xuXG4gICAgaWYgKCFsYWJlbFRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB0cmVlLWxpa2Ugc3RydWN0dXJlIGZyb20gZWxlbWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIHRyZWU6IHtcbiAgKiAgMDogW1xuICAqICAgIHsgaWQ6ICdTaGFwZV8xJywgcHJpb3JpdHk6IDEsIC4uLiB9LFxuICAqICAgIHsgaWQ6ICdTaGFwZV8yJywgcHJpb3JpdHk6IDEsIC4uLiB9LFxuICAqICAgIHsgaWQ6ICdDb25uZWN0aW9uXzEnLCBzb3VyY2U6ICdTaGFwZV8xJywgdGFyZ2V0OiAnU2hhcGVfMicsIHByaW9yaXR5OiAzLCAuLi4gfSxcbiAgKiAgICAuLi5cbiAgKiAgXSxcbiAgKiAgMTogW1xuICAqICAgIHsgaWQ6ICdTaGFwZV8zJywgcGFyZW50OiAnU2hhcGUxJywgcHJpb3JpdHk6IDEsIC4uLiB9LFxuICAqICAgIC4uLlxuICAqICBdXG4gICogfTtcbiAgKlxuICAqIEBwYXJhbSAge0FycmF5PGRqcy5tb2RlbC5iYXNlPn0gZWxlbWVudHNcbiAgKlxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKi9cbkNvcHlQYXN0ZS5wcm90b3R5cGUuY3JlYXRlVHJlZSA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gIHZhciBydWxlcyA9IHRoaXMuX3J1bGVzLFxuICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHRyZWUgPSB7fSxcbiAgICAgIGVsZW1lbnRzRGF0YSA9IFtdO1xuXG4gIHZhciBwYXJlbnRzID0gZ2V0UGFyZW50cyhlbGVtZW50cyk7XG5cbiAgZnVuY3Rpb24gY2FuQ29weShlbGVtZW50LCBlbGVtZW50cykge1xuICAgIHJldHVybiBydWxlcy5hbGxvd2VkKCdlbGVtZW50LmNvcHknLCB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFbGVtZW50RGF0YShlbGVtZW50LCBkZXB0aCkge1xuXG4gICAgLy8gKDEpIGNoZWNrIHdldGhlciBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gYWRkZWRcbiAgICB2YXIgZm91bmRFbGVtZW50RGF0YSA9IGZpbmQoZWxlbWVudHNEYXRhLCBmdW5jdGlvbihlbGVtZW50c0RhdGEpIHtcbiAgICAgIHJldHVybiBlbGVtZW50ID09PSBlbGVtZW50c0RhdGEuZWxlbWVudDtcbiAgICB9KTtcblxuICAgIC8vICgyKSBhZGQgZWxlbWVudCBpZiBub3QgYWxyZWFkeSBhZGRlZFxuICAgIGlmICghZm91bmRFbGVtZW50RGF0YSkge1xuICAgICAgZWxlbWVudHNEYXRhLnB1c2goe1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBkZXB0aDogZGVwdGhcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gKDMpIHVwZGF0ZSBkZXB0aFxuICAgIGlmIChmb3VuZEVsZW1lbnREYXRhLmRlcHRoIDwgZGVwdGgpIHtcbiAgICAgIGVsZW1lbnRzRGF0YSA9IHJlbW92ZUVsZW1lbnREYXRhKGZvdW5kRWxlbWVudERhdGEsIGVsZW1lbnRzRGF0YSk7XG5cbiAgICAgIGVsZW1lbnRzRGF0YS5wdXNoKHtcbiAgICAgICAgZWxlbWVudDogZm91bmRFbGVtZW50RGF0YS5lbGVtZW50LFxuICAgICAgICBkZXB0aDogZGVwdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnREYXRhKGVsZW1lbnREYXRhLCBlbGVtZW50c0RhdGEpIHtcbiAgICB2YXIgaW5kZXggPSBlbGVtZW50c0RhdGEuaW5kZXhPZihlbGVtZW50RGF0YSk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBlbGVtZW50c0RhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudHNEYXRhO1xuICB9XG5cbiAgLy8gKDEpIGFkZCBlbGVtZW50c1xuICBlYWNoRWxlbWVudChwYXJlbnRzLCBmdW5jdGlvbihlbGVtZW50LCBfaW5kZXgsIGRlcHRoKSB7XG5cbiAgICAvLyBkbyBOT1QgYWRkIGV4dGVybmFsIGxhYmVscyBkaXJlY3RseVxuICAgIGlmIChpc0xhYmVsKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWx3YXlzIGNvcHkgZXh0ZXJuYWwgbGFiZWxzXG4gICAgZm9yRWFjaChlbGVtZW50LmxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgIGFkZEVsZW1lbnREYXRhKGxhYmVsLCBkZXB0aCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRSZWxhdGVkRWxlbWVudHMoZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnRzICYmIGVsZW1lbnRzLmxlbmd0aCAmJiBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICAgICAgLy8gYWRkIGV4dGVybmFsIGxhYmVsc1xuICAgICAgICBmb3JFYWNoKGVsZW1lbnQubGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgIGFkZEVsZW1lbnREYXRhKGxhYmVsLCBkZXB0aCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFkZEVsZW1lbnREYXRhKGVsZW1lbnQsIGRlcHRoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvckVhY2goWyBlbGVtZW50LmF0dGFjaGVycywgZWxlbWVudC5pbmNvbWluZywgZWxlbWVudC5vdXRnb2luZyBdLCBhZGRSZWxhdGVkRWxlbWVudHMpO1xuXG4gICAgYWRkRWxlbWVudERhdGEoZWxlbWVudCwgZGVwdGgpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW47XG4gIH0pO1xuXG4gIGVsZW1lbnRzID0gbWFwKGVsZW1lbnRzRGF0YSwgZnVuY3Rpb24oZWxlbWVudERhdGEpIHtcbiAgICByZXR1cm4gZWxlbWVudERhdGEuZWxlbWVudDtcbiAgfSk7XG5cbiAgLy8gKDIpIGNvcHkgZWxlbWVudHNcbiAgZWxlbWVudHNEYXRhID0gbWFwKGVsZW1lbnRzRGF0YSwgZnVuY3Rpb24oZWxlbWVudERhdGEpIHtcbiAgICBlbGVtZW50RGF0YS5kZXNjcmlwdG9yID0ge307XG5cbiAgICBzZWxmLl9ldmVudEJ1cy5maXJlKCdjb3B5UGFzdGUuY29weUVsZW1lbnQnLCB7XG4gICAgICBkZXNjcmlwdG9yOiBlbGVtZW50RGF0YS5kZXNjcmlwdG9yLFxuICAgICAgZWxlbWVudDogZWxlbWVudERhdGEuZWxlbWVudCxcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9KTtcblxuICAvLyAoMykgc29ydCBlbGVtZW50cyBieSBwcmlvcml0eVxuICBlbGVtZW50c0RhdGEgPSBzb3J0QnkoZWxlbWVudHNEYXRhLCBmdW5jdGlvbihlbGVtZW50RGF0YSkge1xuICAgIHJldHVybiBlbGVtZW50RGF0YS5kZXNjcmlwdG9yLnByaW9yaXR5O1xuICB9KTtcblxuICBlbGVtZW50cyA9IG1hcChlbGVtZW50c0RhdGEsIGZ1bmN0aW9uKGVsZW1lbnREYXRhKSB7XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhLmVsZW1lbnQ7XG4gIH0pO1xuXG4gIC8vICg0KSBjcmVhdGUgdHJlZVxuICBmb3JFYWNoKGVsZW1lbnRzRGF0YSwgZnVuY3Rpb24oZWxlbWVudERhdGEpIHtcbiAgICB2YXIgZGVwdGggPSBlbGVtZW50RGF0YS5kZXB0aDtcblxuICAgIGlmICghc2VsZi5oYXNSZWxhdGlvbnMoZWxlbWVudERhdGEuZWxlbWVudCwgZWxlbWVudHMpKSB7XG4gICAgICByZW1vdmVFbGVtZW50KGVsZW1lbnREYXRhLmVsZW1lbnQsIGVsZW1lbnRzKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghY2FuQ29weShlbGVtZW50RGF0YS5lbGVtZW50LCBlbGVtZW50cykpIHtcbiAgICAgIHJlbW92ZUVsZW1lbnQoZWxlbWVudERhdGEuZWxlbWVudCwgZWxlbWVudHMpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0cmVlW2RlcHRoXSkge1xuICAgICAgdHJlZVtkZXB0aF0gPSBbXTtcbiAgICB9XG5cbiAgICB0cmVlW2RlcHRoXS5wdXNoKGVsZW1lbnREYXRhLmRlc2NyaXB0b3IpO1xuICB9KTtcblxuICByZXR1cm4gdHJlZTtcbn07XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc0F0dGFjaGVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuICEhZWxlbWVudC5ob3N0O1xufVxuXG5mdW5jdGlvbiBpc0Nvbm5lY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gISFlbGVtZW50LndheXBvaW50cztcbn1cblxuZnVuY3Rpb24gaXNMYWJlbChlbGVtZW50KSB7XG4gIHJldHVybiAhIWVsZW1lbnQubGFiZWxUYXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvcHlXYXlwb2ludHMoZWxlbWVudCkge1xuICByZXR1cm4gbWFwKGVsZW1lbnQud2F5cG9pbnRzLCBmdW5jdGlvbih3YXlwb2ludCkge1xuXG4gICAgd2F5cG9pbnQgPSBjb3B5V2F5cG9pbnQod2F5cG9pbnQpO1xuXG4gICAgaWYgKHdheXBvaW50Lm9yaWdpbmFsKSB7XG4gICAgICB3YXlwb2ludC5vcmlnaW5hbCA9IGNvcHlXYXlwb2ludCh3YXlwb2ludC5vcmlnaW5hbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdheXBvaW50O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29weVdheXBvaW50KHdheXBvaW50KSB7XG4gIHJldHVybiBhc3NpZ24oe30sIHdheXBvaW50KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbGVtZW50LCBlbGVtZW50cykge1xuICB2YXIgaW5kZXggPSBlbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpO1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbn1cbiIsImltcG9ydCBDbGlwYm9hcmRNb2R1bGUgZnJvbSAnLi4vY2xpcGJvYXJkJztcbmltcG9ydCBDcmVhdGVNb2R1bGUgZnJvbSAnLi4vY3JlYXRlJztcbmltcG9ydCBNb3VzZU1vZHVsZSBmcm9tICcuLi9tb3VzZSc7XG5pbXBvcnQgUnVsZXNNb2R1bGUgZnJvbSAnLi4vcnVsZXMnO1xuXG5pbXBvcnQgQ29weVBhc3RlIGZyb20gJy4vQ29weVBhc3RlJztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgQ2xpcGJvYXJkTW9kdWxlLFxuICAgIENyZWF0ZU1vZHVsZSxcbiAgICBNb3VzZU1vZHVsZSxcbiAgICBSdWxlc01vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAnY29weVBhc3RlJyBdLFxuICBjb3B5UGFzdGU6IFsgJ3R5cGUnLCBDb3B5UGFzdGUgXVxufTtcbiIsInZhciBNQVJLRVJfT0sgPSAnZHJvcC1vaycsXG4gICAgTUFSS0VSX05PVF9PSyA9ICdkcm9wLW5vdC1vaycsXG4gICAgTUFSS0VSX0FUVEFDSCA9ICdhdHRhY2gtb2snLFxuICAgIE1BUktFUl9ORVdfUEFSRU5UID0gJ25ldy1wYXJlbnQnO1xuXG5pbXBvcnQge1xuICBhc3NpZ24sXG4gIGZpbHRlcixcbiAgZmluZCxcbiAgZm9yRWFjaCxcbiAgaXNBcnJheSxcbiAgaXNOdW1iZXIsXG4gIG1hcFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7IGdldEJCb3ggfSBmcm9tICcuLi8uLi91dGlsL0VsZW1lbnRzJztcblxudmFyIFBSRUZJWCA9ICdjcmVhdGUnO1xuXG52YXIgSElHSF9QUklPUklUWSA9IDIwMDA7XG5cblxuLyoqXG4gKiBDcmVhdGUgbmV3IGVsZW1lbnRzIHRocm91Z2ggZHJhZyBhbmQgZHJvcC5cbiAqXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKiBAcGFyYW0ge0RyYWdnaW5nfSBkcmFnZ2luZ1xuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKiBAcGFyYW0ge1J1bGVzfSBydWxlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDcmVhdGUoXG4gICAgY2FudmFzLFxuICAgIGRyYWdnaW5nLFxuICAgIGV2ZW50QnVzLFxuICAgIG1vZGVsaW5nLFxuICAgIHJ1bGVzXG4pIHtcblxuICAvLyBydWxlcyAvLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIENoZWNrIHdldGhlciBlbGVtZW50cyBjYW4gYmUgY3JlYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IHRhcmdldFxuICAgKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvblxuICAgKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBbc291cmNlXVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxudWxsfE9iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIGNhbkNyZWF0ZShlbGVtZW50cywgdGFyZ2V0LCBwb3NpdGlvbiwgc291cmNlLCBoaW50cykge1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gaWdub3JlIGNoaWxkIGVsZW1lbnRzIGFuZCBleHRlcm5hbCBsYWJlbHNcbiAgICBlbGVtZW50cyA9IGZpbHRlcihlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdmFyIGxhYmVsVGFyZ2V0ID0gZWxlbWVudC5sYWJlbFRhcmdldDtcblxuICAgICAgcmV0dXJuICFlbGVtZW50LnBhcmVudCAmJiAhKGlzTGFiZWwoZWxlbWVudCkgJiYgZWxlbWVudHMuaW5kZXhPZihsYWJlbFRhcmdldCkgIT09IC0xKTtcbiAgICB9KTtcblxuICAgIHZhciBzaGFwZSA9IGZpbmQoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAhaXNDb25uZWN0aW9uKGVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgdmFyIGF0dGFjaCA9IGZhbHNlLFxuICAgICAgICBjb25uZWN0ID0gZmFsc2UsXG4gICAgICAgIGNyZWF0ZSA9IGZhbHNlO1xuXG4gICAgLy8gKDEpIGF0dGFjaGluZyBzaW5nbGUgc2hhcGVzXG4gICAgaWYgKGlzU2luZ2xlU2hhcGUoZWxlbWVudHMpKSB7XG4gICAgICBhdHRhY2ggPSBydWxlcy5hbGxvd2VkKCdzaGFwZS5hdHRhY2gnLCB7XG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFhdHRhY2gpIHtcblxuICAgICAgLy8gKDIpIGNyZWF0aW5nIGVsZW1lbnRzXG4gICAgICBpZiAoaXNTaW5nbGVTaGFwZShlbGVtZW50cykpIHtcbiAgICAgICAgY3JlYXRlID0gcnVsZXMuYWxsb3dlZCgnc2hhcGUuY3JlYXRlJywge1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICBzaGFwZTogc2hhcGUsXG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGUgPSBydWxlcy5hbGxvd2VkKCdlbGVtZW50cy5jcmVhdGUnLCB7XG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBjb25uZWN0aW9uVGFyZ2V0ID0gaGludHMuY29ubmVjdGlvblRhcmdldDtcblxuICAgIC8vICgzKSBhcHBlbmRpbmcgc2luZ2xlIHNoYXBlc1xuICAgIGlmIChjcmVhdGUgfHwgYXR0YWNoKSB7XG4gICAgICBpZiAoc2hhcGUgJiYgc291cmNlKSB7XG4gICAgICAgIGNvbm5lY3QgPSBydWxlcy5hbGxvd2VkKCdjb25uZWN0aW9uLmNyZWF0ZScsIHtcbiAgICAgICAgICBzb3VyY2U6IGNvbm5lY3Rpb25UYXJnZXQgPT09IHNvdXJjZSA/IHNoYXBlIDogc291cmNlLFxuICAgICAgICAgIHRhcmdldDogY29ubmVjdGlvblRhcmdldCA9PT0gc291cmNlID8gc291cmNlIDogc2hhcGUsXG4gICAgICAgICAgaGludHM6IHtcbiAgICAgICAgICAgIHRhcmdldFBhcmVudDogdGFyZ2V0LFxuICAgICAgICAgICAgdGFyZ2V0QXR0YWNoOiBhdHRhY2hcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdHRhY2g6IGF0dGFjaCxcbiAgICAgICAgY29ubmVjdDogY29ubmVjdFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgd2V0aGVyIG9yIG5vdCBlbGVtZW50cyBjYW4gYmUgY3JlYXRlZFxuICAgIGlmIChjcmVhdGUgPT09IG51bGwgfHwgYXR0YWNoID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRNYXJrZXIoZWxlbWVudCwgbWFya2VyKSB7XG4gICAgWyBNQVJLRVJfQVRUQUNILCBNQVJLRVJfT0ssIE1BUktFUl9OT1RfT0ssIE1BUktFUl9ORVdfUEFSRU5UIF0uZm9yRWFjaChmdW5jdGlvbihtKSB7XG5cbiAgICAgIGlmIChtID09PSBtYXJrZXIpIHtcbiAgICAgICAgY2FudmFzLmFkZE1hcmtlcihlbGVtZW50LCBtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoZWxlbWVudCwgbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBldmVudCBoYW5kbGluZyAvLy8vLy8vLy8vXG5cbiAgZXZlbnRCdXMub24oWyAnY3JlYXRlLm1vdmUnLCAnY3JlYXRlLmhvdmVyJyBdLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgZWxlbWVudHMgPSBjb250ZXh0LmVsZW1lbnRzLFxuICAgICAgICBob3ZlciA9IGV2ZW50LmhvdmVyLFxuICAgICAgICBzb3VyY2UgPSBjb250ZXh0LnNvdXJjZSxcbiAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gICAgaWYgKCFob3Zlcikge1xuICAgICAgY29udGV4dC5jYW5FeGVjdXRlID0gZmFsc2U7XG4gICAgICBjb250ZXh0LnRhcmdldCA9IG51bGw7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbnN1cmVDb25zdHJhaW50cyhldmVudCk7XG5cbiAgICB2YXIgcG9zaXRpb24gPSB7XG4gICAgICB4OiBldmVudC54LFxuICAgICAgeTogZXZlbnQueVxuICAgIH07XG5cbiAgICB2YXIgY2FuRXhlY3V0ZSA9IGNvbnRleHQuY2FuRXhlY3V0ZSA9IGhvdmVyICYmIGNhbkNyZWF0ZShlbGVtZW50cywgaG92ZXIsIHBvc2l0aW9uLCBzb3VyY2UsIGhpbnRzKTtcblxuICAgIGlmIChob3ZlciAmJiBjYW5FeGVjdXRlICE9PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnRhcmdldCA9IGhvdmVyO1xuXG4gICAgICBpZiAoY2FuRXhlY3V0ZSAmJiBjYW5FeGVjdXRlLmF0dGFjaCkge1xuICAgICAgICBzZXRNYXJrZXIoaG92ZXIsIE1BUktFUl9BVFRBQ0gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TWFya2VyKGhvdmVyLCBjYW5FeGVjdXRlID8gTUFSS0VSX05FV19QQVJFTlQgOiBNQVJLRVJfTk9UX09LKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKFsgJ2NyZWF0ZS5lbmQnLCAnY3JlYXRlLm91dCcsICdjcmVhdGUuY2xlYW51cCcgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgaG92ZXIgPSBldmVudC5ob3ZlcjtcblxuICAgIGlmIChob3Zlcikge1xuICAgICAgc2V0TWFya2VyKGhvdmVyLCBudWxsKTtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjcmVhdGUuZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIHNvdXJjZSA9IGNvbnRleHQuc291cmNlLFxuICAgICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIGVsZW1lbnRzID0gY29udGV4dC5lbGVtZW50cyxcbiAgICAgICAgdGFyZ2V0ID0gY29udGV4dC50YXJnZXQsXG4gICAgICAgIGNhbkV4ZWN1dGUgPSBjb250ZXh0LmNhbkV4ZWN1dGUsXG4gICAgICAgIGF0dGFjaCA9IGNhbkV4ZWN1dGUgJiYgY2FuRXhlY3V0ZS5hdHRhY2gsXG4gICAgICAgIGNvbm5lY3QgPSBjYW5FeGVjdXRlICYmIGNhbkV4ZWN1dGUuY29ubmVjdCxcbiAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gICAgaWYgKGNhbkV4ZWN1dGUgPT09IGZhbHNlIHx8ICF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnN1cmVDb25zdHJhaW50cyhldmVudCk7XG5cbiAgICB2YXIgcG9zaXRpb24gPSB7XG4gICAgICB4OiBldmVudC54LFxuICAgICAgeTogZXZlbnQueVxuICAgIH07XG5cbiAgICBpZiAoY29ubmVjdCkge1xuICAgICAgc2hhcGUgPSBtb2RlbGluZy5hcHBlbmRTaGFwZShzb3VyY2UsIHNoYXBlLCBwb3NpdGlvbiwgdGFyZ2V0LCB7XG4gICAgICAgIGF0dGFjaDogYXR0YWNoLFxuICAgICAgICBjb25uZWN0aW9uOiBjb25uZWN0ID09PSB0cnVlID8ge30gOiBjb25uZWN0LFxuICAgICAgICBjb25uZWN0aW9uVGFyZ2V0OiBoaW50cy5jb25uZWN0aW9uVGFyZ2V0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudHMgPSBtb2RlbGluZy5jcmVhdGVFbGVtZW50cyhlbGVtZW50cywgcG9zaXRpb24sIHRhcmdldCwgYXNzaWduKHt9LCBoaW50cywge1xuICAgICAgICBhdHRhY2g6IGF0dGFjaFxuICAgICAgfSkpO1xuXG4gICAgICAvLyB1cGRhdGUgc2hhcGVcbiAgICAgIHNoYXBlID0gZmluZChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gIWlzQ29ubmVjdGlvbihlbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBlbGVtZW50cyBhbmQgc2hhcGVcbiAgICBhc3NpZ24oY29udGV4dCwge1xuICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgc2hhcGU6IHNoYXBlXG4gICAgfSk7XG5cbiAgICBhc3NpZ24oZXZlbnQsIHtcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgIHNoYXBlOiBzaGFwZVxuICAgIH0pO1xuICB9KTtcblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgdmFyIGNvbnRleHQgPSBkcmFnZ2luZy5jb250ZXh0KCk7XG5cbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LnByZWZpeCA9PT0gUFJFRklYKSB7XG4gICAgICBkcmFnZ2luZy5jYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICAvLyBjYW5jZWwgb24gPGVsZW1lbnRzLmNoYW5nZWQ+IHRoYXQgaXMgbm90IHJlc3VsdCBvZiA8ZHJhZy5lbmQ+XG4gIGV2ZW50QnVzLm9uKCdjcmVhdGUuaW5pdCcsIGZ1bmN0aW9uKCkge1xuICAgIGV2ZW50QnVzLm9uKCdlbGVtZW50cy5jaGFuZ2VkJywgY2FuY2VsKTtcblxuICAgIGV2ZW50QnVzLm9uY2UoWyAnY3JlYXRlLmNhbmNlbCcsICdjcmVhdGUuZW5kJyBdLCBISUdIX1BSSU9SSVRZLCBmdW5jdGlvbigpIHtcbiAgICAgIGV2ZW50QnVzLm9mZignZWxlbWVudHMuY2hhbmdlZCcsIGNhbmNlbCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIEFQSSAvLy8vLy8vLy8vXG5cbiAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKGV2ZW50LCBlbGVtZW50cywgY29udGV4dCkge1xuICAgIGlmICghaXNBcnJheShlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gWyBlbGVtZW50cyBdO1xuICAgIH1cblxuICAgIHZhciBzaGFwZSA9IGZpbmQoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAhaXNDb25uZWN0aW9uKGVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFzaGFwZSkge1xuXG4gICAgICAvLyBhdCBsZWFzdCBvbmUgc2hhcGUgaXMgcmVxdWlyZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0ID0gYXNzaWduKHtcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgIGhpbnRzOiB7fSxcbiAgICAgIHNoYXBlOiBzaGFwZVxuICAgIH0sIGNvbnRleHQgfHwge30pO1xuXG4gICAgLy8gbWFrZSBzdXJlIGVhY2ggZWxlbWVudCBoYXMgeCBhbmQgeVxuICAgIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGlmICghaXNOdW1iZXIoZWxlbWVudC54KSkge1xuICAgICAgICBlbGVtZW50LnggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTnVtYmVyKGVsZW1lbnQueSkpIHtcbiAgICAgICAgZWxlbWVudC55ID0gMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBiYm94ID0gZ2V0QkJveChlbGVtZW50cyk7XG5cbiAgICAvLyBjZW50ZXIgZWxlbWVudHMgYXJvdW5kIGN1cnNvclxuICAgIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGlmIChpc0Nvbm5lY3Rpb24oZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudC53YXlwb2ludHMgPSBtYXAoZWxlbWVudC53YXlwb2ludHMsIGZ1bmN0aW9uKHdheXBvaW50KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHdheXBvaW50LnggLSBiYm94LnggLSBiYm94LndpZHRoIC8gMixcbiAgICAgICAgICAgIHk6IHdheXBvaW50LnkgLSBiYm94LnkgLSBiYm94LmhlaWdodCAvIDJcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYXNzaWduKGVsZW1lbnQsIHtcbiAgICAgICAgeDogZWxlbWVudC54IC0gYmJveC54IC0gYmJveC53aWR0aCAvIDIsXG4gICAgICAgIHk6IGVsZW1lbnQueSAtIGJib3gueSAtIGJib3guaGVpZ2h0IC8gMlxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkcmFnZ2luZy5pbml0KGV2ZW50LCBQUkVGSVgsIHtcbiAgICAgIGN1cnNvcjogJ2dyYWJiaW5nJyxcbiAgICAgIGF1dG9BY3RpdmF0ZTogdHJ1ZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cblxuQ3JlYXRlLiRpbmplY3QgPSBbXG4gICdjYW52YXMnLFxuICAnZHJhZ2dpbmcnLFxuICAnZXZlbnRCdXMnLFxuICAnbW9kZWxpbmcnLFxuICAncnVsZXMnXG5dO1xuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cblxuZnVuY3Rpb24gZW5zdXJlQ29uc3RyYWludHMoZXZlbnQpIHtcbiAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgY3JlYXRlQ29uc3RyYWludHMgPSBjb250ZXh0LmNyZWF0ZUNvbnN0cmFpbnRzO1xuXG4gIGlmICghY3JlYXRlQ29uc3RyYWludHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY3JlYXRlQ29uc3RyYWludHMubGVmdCkge1xuICAgIGV2ZW50LnggPSBNYXRoLm1heChldmVudC54LCBjcmVhdGVDb25zdHJhaW50cy5sZWZ0KTtcbiAgfVxuXG4gIGlmIChjcmVhdGVDb25zdHJhaW50cy5yaWdodCkge1xuICAgIGV2ZW50LnggPSBNYXRoLm1pbihldmVudC54LCBjcmVhdGVDb25zdHJhaW50cy5yaWdodCk7XG4gIH1cblxuICBpZiAoY3JlYXRlQ29uc3RyYWludHMudG9wKSB7XG4gICAgZXZlbnQueSA9IE1hdGgubWF4KGV2ZW50LnksIGNyZWF0ZUNvbnN0cmFpbnRzLnRvcCk7XG4gIH1cblxuICBpZiAoY3JlYXRlQ29uc3RyYWludHMuYm90dG9tKSB7XG4gICAgZXZlbnQueSA9IE1hdGgubWluKGV2ZW50LnksIGNyZWF0ZUNvbnN0cmFpbnRzLmJvdHRvbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb25uZWN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuICEhZWxlbWVudC53YXlwb2ludHM7XG59XG5cbmZ1bmN0aW9uIGlzU2luZ2xlU2hhcGUoZWxlbWVudHMpIHtcbiAgcmV0dXJuIGVsZW1lbnRzICYmIGVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAhaXNDb25uZWN0aW9uKGVsZW1lbnRzWzBdKTtcbn1cblxuZnVuY3Rpb24gaXNMYWJlbChlbGVtZW50KSB7XG4gIHJldHVybiAhIWVsZW1lbnQubGFiZWxUYXJnZXQ7XG59XG4iLCJpbXBvcnQge1xyXG4gIHRyYW5zbGF0ZVxyXG59IGZyb20gJy4uLy4uL3V0aWwvU3ZnVHJhbnNmb3JtVXRpbCc7XHJcblxyXG5pbXBvcnQgeyBnZXRWaXN1YWwgfSBmcm9tICcuLi8uLi91dGlsL0dyYXBoaWNzVXRpbCc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXHJcbiAgYXR0ciBhcyBzdmdBdHRyLFxyXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXHJcbiAgcmVtb3ZlIGFzIHN2Z1JlbW92ZVxyXG59IGZyb20gJ3Rpbnktc3ZnJztcclxuXHJcbnZhciBMT1dfUFJJT1JJVFkgPSA3NTA7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ3JlYXRlUHJldmlldyhcclxuICAgIGNhbnZhcyxcclxuICAgIGV2ZW50QnVzLFxyXG4gICAgZ3JhcGhpY3NGYWN0b3J5LFxyXG4gICAgcHJldmlld1N1cHBvcnQsXHJcbiAgICBzdHlsZXNcclxuKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlRHJhZ0dyb3VwKGVsZW1lbnRzKSB7XHJcbiAgICB2YXIgZHJhZ0dyb3VwID0gc3ZnQ3JlYXRlKCdnJyk7XHJcblxyXG4gICAgc3ZnQXR0cihkcmFnR3JvdXAsIHN0eWxlcy5jbHMoJ2Rqcy1kcmFnLWdyb3VwJywgWyAnbm8tZXZlbnRzJyBdKSk7XHJcblxyXG4gICAgdmFyIGNoaWxkcmVuR2Z4ID0gc3ZnQ3JlYXRlKCdnJyk7XHJcblxyXG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XHJcblxyXG4gICAgICAvLyBjcmVhdGUgZ3JhcGhpY3NcclxuICAgICAgdmFyIGdmeDtcclxuXHJcbiAgICAgIGlmIChlbGVtZW50LmhpZGRlbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XHJcbiAgICAgICAgZ2Z4ID0gZ3JhcGhpY3NGYWN0b3J5Ll9jcmVhdGVDb250YWluZXIoJ2Nvbm5lY3Rpb24nLCBjaGlsZHJlbkdmeCk7XHJcblxyXG4gICAgICAgIGdyYXBoaWNzRmFjdG9yeS5kcmF3Q29ubmVjdGlvbihnZXRWaXN1YWwoZ2Z4KSwgZWxlbWVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZ2Z4ID0gZ3JhcGhpY3NGYWN0b3J5Ll9jcmVhdGVDb250YWluZXIoJ3NoYXBlJywgY2hpbGRyZW5HZngpO1xyXG5cclxuICAgICAgICBncmFwaGljc0ZhY3RvcnkuZHJhd1NoYXBlKGdldFZpc3VhbChnZngpLCBlbGVtZW50KTtcclxuXHJcbiAgICAgICAgdHJhbnNsYXRlKGdmeCwgZWxlbWVudC54LCBlbGVtZW50LnkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhZGQgcHJldmlld1xyXG4gICAgICBwcmV2aWV3U3VwcG9ydC5hZGREcmFnZ2VyKGVsZW1lbnQsIGRyYWdHcm91cCwgZ2Z4KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBkcmFnR3JvdXA7XHJcbiAgfVxyXG5cclxuICBldmVudEJ1cy5vbignY3JlYXRlLm1vdmUnLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblxyXG4gICAgdmFyIGhvdmVyID0gZXZlbnQuaG92ZXIsXHJcbiAgICAgICAgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXHJcbiAgICAgICAgZWxlbWVudHMgPSBjb250ZXh0LmVsZW1lbnRzLFxyXG4gICAgICAgIGRyYWdHcm91cCA9IGNvbnRleHQuZHJhZ0dyb3VwO1xyXG5cclxuICAgIC8vIGxhemlseSBjcmVhdGUgcHJldmlld3NcclxuICAgIGlmICghZHJhZ0dyb3VwKSB7XHJcbiAgICAgIGRyYWdHcm91cCA9IGNvbnRleHQuZHJhZ0dyb3VwID0gY3JlYXRlRHJhZ0dyb3VwKGVsZW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdExheWVyO1xyXG5cclxuICAgIGlmIChob3Zlcikge1xyXG4gICAgICBpZiAoIWRyYWdHcm91cC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgZGVmYXVsdExheWVyID0gY2FudmFzLmdldERlZmF1bHRMYXllcigpO1xyXG5cclxuICAgICAgICBzdmdBcHBlbmQoZGVmYXVsdExheWVyLCBkcmFnR3JvdXApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0cmFuc2xhdGUoZHJhZ0dyb3VwLCBldmVudC54LCBldmVudC55KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN2Z1JlbW92ZShkcmFnR3JvdXApO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBldmVudEJ1cy5vbignY3JlYXRlLmNsZWFudXAnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxyXG4gICAgICAgIGRyYWdHcm91cCA9IGNvbnRleHQuZHJhZ0dyb3VwO1xyXG5cclxuICAgIGlmIChkcmFnR3JvdXApIHtcclxuICAgICAgc3ZnUmVtb3ZlKGRyYWdHcm91cCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbkNyZWF0ZVByZXZpZXcuJGluamVjdCA9IFtcclxuICAnY2FudmFzJyxcclxuICAnZXZlbnRCdXMnLFxyXG4gICdncmFwaGljc0ZhY3RvcnknLFxyXG4gICdwcmV2aWV3U3VwcG9ydCcsXHJcbiAgJ3N0eWxlcydcclxuXTtcclxuIiwiaW1wb3J0IERyYWdnaW5nTW9kdWxlIGZyb20gJy4uL2RyYWdnaW5nJztcbmltcG9ydCBQcmV2aWV3U3VwcG9ydE1vZHVsZSBmcm9tICcuLi9wcmV2aWV3LXN1cHBvcnQnO1xuaW1wb3J0IFJ1bGVzTW9kdWxlIGZyb20gJy4uL3J1bGVzJztcbmltcG9ydCBTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnLi4vc2VsZWN0aW9uJztcblxuaW1wb3J0IENyZWF0ZSBmcm9tICcuL0NyZWF0ZSc7XG5pbXBvcnQgQ3JlYXRlUHJldmlldyBmcm9tICcuL0NyZWF0ZVByZXZpZXcnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBEcmFnZ2luZ01vZHVsZSxcbiAgICBQcmV2aWV3U3VwcG9ydE1vZHVsZSxcbiAgICBSdWxlc01vZHVsZSxcbiAgICBTZWxlY3Rpb25Nb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFtcbiAgICAnY3JlYXRlJyxcbiAgICAnY3JlYXRlUHJldmlldydcbiAgXSxcbiAgY3JlYXRlOiBbICd0eXBlJywgQ3JlYXRlIF0sXG4gIGNyZWF0ZVByZXZpZXc6IFsgJ3R5cGUnLCBDcmVhdGVQcmV2aWV3IF1cbn07XG4iLCJ2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGV2ZW50IGFzIGRvbUV2ZW50XG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQge1xuICBnZXRPcmlnaW5hbCxcbiAgdG9Qb2ludCxcbiAgc3RvcFByb3BhZ2F0aW9uXG59IGZyb20gJy4uLy4uL3V0aWwvRXZlbnQnO1xuXG5pbXBvcnQge1xuICBzZXQgYXMgY3Vyc29yU2V0LFxuICB1bnNldCBhcyBjdXJzb3JVbnNldFxufSBmcm9tICcuLi8uLi91dGlsL0N1cnNvcic7XG5cbmltcG9ydCB7XG4gIGluc3RhbGwgYXMgaW5zdGFsbENsaWNrVHJhcFxufSBmcm9tICcuLi8uLi91dGlsL0NsaWNrVHJhcCc7XG5cbmltcG9ydCB7XG4gIGRlbHRhIGFzIGRlbHRhUG9zXG59IGZyb20gJy4uLy4uL3V0aWwvUG9zaXRpb25VdGlsJztcblxudmFyIERSQUdfQUNUSVZFX0NMUyA9ICdkanMtZHJhZy1hY3RpdmUnO1xuXG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xuXG4gIC8vIGNoZWNrIGZvciBUb3VjaEV2ZW50IGJlaW5nIGF2YWlsYWJsZSBmaXJzdFxuICAvLyAoaS5lLiBub3QgYXZhaWxhYmxlIG9uIGRlc2t0b3AgRmlyZWZveClcbiAgcmV0dXJuIHR5cGVvZiBUb3VjaEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aChwb2ludCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50LngsIDIpICsgTWF0aC5wb3cocG9pbnQueSwgMikpO1xufVxuXG4vKipcbiAqIEEgaGVscGVyIHRoYXQgZmlyZXMgY2FudmFzIGxvY2FsaXplZCBkcmFnIGV2ZW50cyBhbmQgcmVhbGl6ZXNcbiAqIHRoZSBnZW5lcmFsIFwiZHJhZy1hbmQtZHJvcFwiIGxvb2sgYW5kIGZlZWwuXG4gKlxuICogQ2FsbGluZyB7QGxpbmsgRHJhZ2dpbmcjYWN0aXZhdGV9IGFjdGl2YXRlcyBkcmFnZ2luZyBvbiBhIGNhbnZhcy5cbiAqXG4gKiBJdCBwcm92aWRlcyB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAgKiBlbWl0cyBsaWZlIGN5Y2xlIGV2ZW50cywgbmFtZXNwYWNlZCB3aXRoIGEgcHJlZml4IGFzc2lnbmVkXG4gKiAgICAgZHVyaW5nIGRyYWdnaW5nIGFjdGl2YXRpb25cbiAqICAgKiBzZXRzIGFuZCByZXN0b3JlcyB0aGUgY3Vyc29yXG4gKiAgICogc2V0cyBhbmQgcmVzdG9yZXMgdGhlIHNlbGVjdGlvbiBpZiBlbGVtZW50cyBzdGlsbCBleGlzdFxuICogICAqIGVuc3VyZXMgdGhlcmUgY2FuIGJlIG9ubHkgb25lIGRyYWcgb3BlcmF0aW9uIGFjdGl2ZSBhdCBhIHRpbWVcbiAqXG4gKiBEcmFnZ2luZyBtYXkgYmUgY2FuY2VsZWQgbWFudWFsbHkgYnkgY2FsbGluZyB7QGxpbmsgRHJhZ2dpbmcjY2FuY2VsfVxuICogb3IgYnkgcHJlc3NpbmcgRVNDLlxuICpcbiAqXG4gKiAjIyBMaWZlLWN5Y2xlIGV2ZW50c1xuICpcbiAqIERyYWdnaW5nIGNhbiBiZSBpbiB0aHJlZSBkaWZmZXJlbnQgc3RhdGVzLCBvZmYsIGluaXRpYWxpemVkXG4gKiBhbmQgYWN0aXZlLlxuICpcbiAqICgxKSBvZmY6IG5vIGRyYWdnaW5nIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzc1xuICogKDIpIGluaXRpYWxpemVkOiBhIG5ldyBkcmFnIG9wZXJhdGlvbiBnb3QgaW5pdGlhbGl6ZWQgYnV0IG5vdCB5ZXRcbiAqICAgICAgICAgICAgICAgICAgc3RhcnRlZCAoaS5lLiBiZWNhdXNlIG9mIG5vIGluaXRpYWwgbW92ZSlcbiAqICgzKSBzdGFydGVkOiBkcmFnZ2luZyBpcyBpbiBwcm9ncmVzc1xuICpcbiAqIEV2ZW50dWFsbHkgZHJhZ2dpbmcgd2lsbCBiZSBvZmYgYWdhaW4gYWZ0ZXIgYSBkcmFnIG9wZXJhdGlvbiBoYXNcbiAqIGJlZW4gZW5kZWQgb3IgY2FuY2VsZWQgdmlhIHVzZXIgY2xpY2sgb3IgRVNDIGtleSBwcmVzcy5cbiAqXG4gKiBUbyBpbmRpY2F0ZSB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyBkcmFnZ2luZyBlbWl0cyBnZW5lcmljXG4gKiBsaWZlLWN5Y2xlIGV2ZW50cyB3aXRoIHRoZSBgZHJhZy5gIHByZWZpeCBfYW5kXyBldmVudHMgbmFtZXNwYWNlZFxuICogdG8gYSBwcmVmaXggY2hvb3NlbiBieSBhIHVzZXIgZHVyaW5nIGRyYWcgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogVGhlIGZvbGxvd2luZyBldmVudHMgYXJlIGVtaXR0ZWQgKGFwcHJvcHJpYXRlbHkgcHJlZml4ZWQpIHZpYVxuICogdGhlIHtAbGluayBFdmVudEJ1c30uXG4gKlxuICogKiBgaW5pdGBcbiAqICogYHN0YXJ0YFxuICogKiBgbW92ZWBcbiAqICogYGVuZGBcbiAqICogYGVuZGVkYCAoZHJhZ2dpbmcgYWxyZWFkeSBpbiBvZmYgc3RhdGUpXG4gKiAqIGBjYW5jZWxgIChvbmx5IGlmIHByZXZpb3VzbHkgc3RhcnRlZClcbiAqICogYGNhbmNlbGVkYCAoZHJhZ2dpbmcgYWxyZWFkeSBpbiBvZmYgc3RhdGUsIG9ubHkgaWYgcHJldmlvdXNseSBzdGFydGVkKVxuICogKiBgY2xlYW51cGBcbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBNeURyYWdDb21wb25lbnQoZXZlbnRCdXMsIGRyYWdnaW5nKSB7XG4gKlxuICogICBldmVudEJ1cy5vbignbXlkcmFnLnN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgICBjb25zb2xlLmxvZygneWVzLCB3ZSBzdGFydCBkcmFnZ2luZycpO1xuICogICB9KTtcbiAqXG4gKiAgIGV2ZW50QnVzLm9uKCdteWRyYWcubW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2NhbnZhcyBsb2NhbCBjb29yZGluYXRlcycsIGV2ZW50LngsIGV2ZW50LnksIGV2ZW50LmR4LCBldmVudC5keSk7XG4gKlxuICogICAgIC8vIGxvY2FsIGRyYWcgZGF0YSBpcyBwYXNzZWQgd2l0aCB0aGUgZXZlbnRcbiAqICAgICBldmVudC5jb250ZXh0LmZvbzsgLy8gXCJCQVJcIlxuICpcbiAqICAgICAvLyB0aGUgb3JpZ2luYWwgbW91c2UgZXZlbnQsIHRvb1xuICogICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQ7IC8vIE1vdXNlRXZlbnQoLi4uKVxuICogICB9KTtcbiAqXG4gKiAgIGV2ZW50QnVzLm9uKCdlbGVtZW50LmNsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgICBkcmFnZ2luZy5pbml0KGV2ZW50LCAnbXlkcmFnJywge1xuICogICAgICAgY3Vyc29yOiAnZ3JhYmJpbmcnLFxuICogICAgICAgZGF0YToge1xuICogICAgICAgICBjb250ZXh0OiB7XG4gKiAgICAgICAgICAgZm9vOiBcIkJBUlwiXG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgfSk7XG4gKiB9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERyYWdnaW5nKGV2ZW50QnVzLCBjYW52YXMsIHNlbGVjdGlvbiwgZWxlbWVudFJlZ2lzdHJ5KSB7XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHRocmVzaG9sZDogNSxcbiAgICB0cmFwQ2xpY2s6IHRydWVcbiAgfTtcblxuICAvLyB0aGUgY3VycmVudGx5IGFjdGl2ZSBkcmFnIG9wZXJhdGlvblxuICAvLyBkcmFnZ2luZyBpcyBhY3RpdmUgYXMgc29vbiBhcyB0aGlzIGNvbnRleHQgZXhpc3RzLlxuICAvL1xuICAvLyBpdCBpcyB2aXN1YWxseSBfYWN0aXZlXyBvbmx5IHdoZW4gYSBjb250ZXh0LmFjdGl2ZSBmbGFnIGlzIHNldCB0byB0cnVlLlxuICB2YXIgY29udGV4dDtcblxuICAvKiBjb252ZXJ0IGEgZ2xvYmFsIGV2ZW50IGludG8gbG9jYWwgY29vcmRpbmF0ZXMgKi9cbiAgZnVuY3Rpb24gdG9Mb2NhbFBvaW50KGdsb2JhbFBvc2l0aW9uKSB7XG5cbiAgICB2YXIgdmlld2JveCA9IGNhbnZhcy52aWV3Ym94KCk7XG5cbiAgICB2YXIgY2xpZW50UmVjdCA9IGNhbnZhcy5fY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHZpZXdib3gueCArIChnbG9iYWxQb3NpdGlvbi54IC0gY2xpZW50UmVjdC5sZWZ0KSAvIHZpZXdib3guc2NhbGUsXG4gICAgICB5OiB2aWV3Ym94LnkgKyAoZ2xvYmFsUG9zaXRpb24ueSAtIGNsaWVudFJlY3QudG9wKSAvIHZpZXdib3guc2NhbGVcbiAgICB9O1xuICB9XG5cbiAgLy8gaGVscGVyc1xuXG4gIGZ1bmN0aW9uIGZpcmUodHlwZSwgZHJhZ0NvbnRleHQpIHtcbiAgICBkcmFnQ29udGV4dCA9IGRyYWdDb250ZXh0IHx8IGNvbnRleHQ7XG5cbiAgICB2YXIgZXZlbnQgPSBldmVudEJ1cy5jcmVhdGVFdmVudChcbiAgICAgIGFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIGRyYWdDb250ZXh0LnBheWxvYWQsXG4gICAgICAgIGRyYWdDb250ZXh0LmRhdGEsXG4gICAgICAgIHsgaXNUb3VjaDogZHJhZ0NvbnRleHQuaXNUb3VjaCB9XG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIGRlZmF1bHQgaW50ZWdyYXRpb25cbiAgICBpZiAoZXZlbnRCdXMuZmlyZSgnZHJhZy4nICsgdHlwZSwgZXZlbnQpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudEJ1cy5maXJlKGRyYWdDb250ZXh0LnByZWZpeCArICcuJyArIHR5cGUsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJldmlvdXNTZWxlY3Rpb24pIHtcbiAgICB2YXIgZXhpc3RpbmdTZWxlY3Rpb24gPSBwcmV2aW91c1NlbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRSZWdpc3RyeS5nZXQoZWxlbWVudC5pZCk7XG4gICAgfSk7XG5cbiAgICBleGlzdGluZ1NlbGVjdGlvbi5sZW5ndGggJiYgc2VsZWN0aW9uLnNlbGVjdChleGlzdGluZ1NlbGVjdGlvbik7XG4gIH1cblxuICAvLyBldmVudCBsaXN0ZW5lcnNcblxuICBmdW5jdGlvbiBtb3ZlKGV2ZW50LCBhY3RpdmF0ZSkge1xuICAgIHZhciBwYXlsb2FkID0gY29udGV4dC5wYXlsb2FkLFxuICAgICAgICBkaXNwbGFjZW1lbnQgPSBjb250ZXh0LmRpc3BsYWNlbWVudDtcblxuICAgIHZhciBnbG9iYWxTdGFydCA9IGNvbnRleHQuZ2xvYmFsU3RhcnQsXG4gICAgICAgIGdsb2JhbEN1cnJlbnQgPSB0b1BvaW50KGV2ZW50KSxcbiAgICAgICAgZ2xvYmFsRGVsdGEgPSBkZWx0YVBvcyhnbG9iYWxDdXJyZW50LCBnbG9iYWxTdGFydCk7XG5cbiAgICB2YXIgbG9jYWxTdGFydCA9IGNvbnRleHQubG9jYWxTdGFydCxcbiAgICAgICAgbG9jYWxDdXJyZW50ID0gdG9Mb2NhbFBvaW50KGdsb2JhbEN1cnJlbnQpLFxuICAgICAgICBsb2NhbERlbHRhID0gZGVsdGFQb3MobG9jYWxDdXJyZW50LCBsb2NhbFN0YXJ0KTtcblxuXG4gICAgLy8gYWN0aXZhdGUgY29udGV4dCBleHBsaWNpdGx5IG9yIG9uY2UgdGhyZXNob2xkIGlzIHJlYWNoZWRcbiAgICBpZiAoIWNvbnRleHQuYWN0aXZlICYmIChhY3RpdmF0ZSB8fCBnZXRMZW5ndGgoZ2xvYmFsRGVsdGEpID4gY29udGV4dC50aHJlc2hvbGQpKSB7XG5cbiAgICAgIC8vIGZpcmUgc3RhcnQgZXZlbnQgd2l0aCBvcmlnaW5hbFxuICAgICAgLy8gc3RhcnRpbmcgY29vcmRpbmF0ZXNcblxuICAgICAgYXNzaWduKHBheWxvYWQsIHtcbiAgICAgICAgeDogcm91bmQobG9jYWxTdGFydC54ICsgZGlzcGxhY2VtZW50LngpLFxuICAgICAgICB5OiByb3VuZChsb2NhbFN0YXJ0LnkgKyBkaXNwbGFjZW1lbnQueSksXG4gICAgICAgIGR4OiAwLFxuICAgICAgICBkeTogMFxuICAgICAgfSwgeyBvcmlnaW5hbEV2ZW50OiBldmVudCB9KTtcblxuICAgICAgaWYgKGZhbHNlID09PSBmaXJlKCdzdGFydCcpKSB7XG4gICAgICAgIHJldHVybiBjYW5jZWwoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5hY3RpdmUgPSB0cnVlO1xuXG4gICAgICAvLyB1bnNldCBzZWxlY3Rpb24gYW5kIHJlbWVtYmVyIG9sZCBzZWxlY3Rpb25cbiAgICAgIC8vIHRoZSBwcmV2aW91cyAob2xkKSBzZWxlY3Rpb24gd2lsbCBhbHdheXMgcGFzc2VkXG4gICAgICAvLyB3aXRoIHRoZSBldmVudCB2aWEgdGhlIGV2ZW50LnByZXZpb3VzU2VsZWN0aW9uIHByb3BlcnR5XG4gICAgICBpZiAoIWNvbnRleHQua2VlcFNlbGVjdGlvbikge1xuICAgICAgICBwYXlsb2FkLnByZXZpb3VzU2VsZWN0aW9uID0gc2VsZWN0aW9uLmdldCgpO1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBhbGxvdyBjdXN0b20gY3Vyc29yXG4gICAgICBpZiAoY29udGV4dC5jdXJzb3IpIHtcbiAgICAgICAgY3Vyc29yU2V0KGNvbnRleHQuY3Vyc29yKTtcbiAgICAgIH1cblxuICAgICAgLy8gaW5kaWNhdGUgZHJhZ2dpbmcgdmlhIG1hcmtlciBvbiByb290IGVsZW1lbnRcbiAgICAgIGNhbnZhcy5hZGRNYXJrZXIoY2FudmFzLmdldFJvb3RFbGVtZW50KCksIERSQUdfQUNUSVZFX0NMUyk7XG4gICAgfVxuXG4gICAgc3RvcFByb3BhZ2F0aW9uKGV2ZW50KTtcblxuICAgIGlmIChjb250ZXh0LmFjdGl2ZSkge1xuXG4gICAgICAvLyB1cGRhdGUgcGF5bG9hZCB3aXRoIGFjdHVhbCBjb29yZGluYXRlc1xuICAgICAgYXNzaWduKHBheWxvYWQsIHtcbiAgICAgICAgeDogcm91bmQobG9jYWxDdXJyZW50LnggKyBkaXNwbGFjZW1lbnQueCksXG4gICAgICAgIHk6IHJvdW5kKGxvY2FsQ3VycmVudC55ICsgZGlzcGxhY2VtZW50LnkpLFxuICAgICAgICBkeDogcm91bmQobG9jYWxEZWx0YS54KSxcbiAgICAgICAgZHk6IHJvdW5kKGxvY2FsRGVsdGEueSlcbiAgICAgIH0sIHsgb3JpZ2luYWxFdmVudDogZXZlbnQgfSk7XG5cbiAgICAgIC8vIGVtaXQgbW92ZSBldmVudFxuICAgICAgZmlyZSgnbW92ZScpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZChldmVudCkge1xuICAgIHZhciBwcmV2aW91c0NvbnRleHQsXG4gICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcblxuICAgIGlmIChjb250ZXh0LmFjdGl2ZSkge1xuXG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgY29udGV4dC5wYXlsb2FkLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcblxuICAgICAgICAvLyBzdXBwcmVzcyBvcmlnaW5hbCBldmVudCAoY2xpY2ssIC4uLilcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBqdXN0IGVuZGVkIGEgZHJhZyBvcGVyYXRpb25cbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gaW1wbGVtZW50YXRpb25zIG1heSBzdG9wIHJlc3RvcmluZyB0aGVcbiAgICAgIC8vIG9yaWdpbmFsIHN0YXRlIChzZWxlY3Rpb25zLCAuLi4pIGJ5IHByZXZlbnRpbmcgdGhlXG4gICAgICAvLyBlbmQgZXZlbnRzIGRlZmF1bHQgYWN0aW9uXG4gICAgICByZXR1cm5WYWx1ZSA9IGZpcmUoJ2VuZCcpO1xuICAgIH1cblxuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGZpcmUoJ3JlamVjdGVkJyk7XG4gICAgfVxuXG4gICAgcHJldmlvdXNDb250ZXh0ID0gY2xlYW51cChyZXR1cm5WYWx1ZSAhPT0gdHJ1ZSk7XG5cbiAgICAvLyBsYXN0IGV2ZW50IHRvIGJlIGZpcmVkIHdoZW4gYWxsIGRyYWcgb3BlcmF0aW9ucyBhcmUgZG9uZVxuICAgIC8vIGF0IHRoaXMgcG9pbnQgaW4gdGltZSBubyBkcmFnIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzcyBhbnltb3JlXG4gICAgZmlyZSgnZW5kZWQnLCBwcmV2aW91c0NvbnRleHQpO1xuICB9XG5cblxuICAvLyBjYW5jZWwgYWN0aXZlIGRyYWcgb3BlcmF0aW9uIGlmIHRoZSB1c2VyIHByZXNzZXNcbiAgLy8gdGhlIEVTQyBrZXkgb24gdGhlIGtleWJvYXJkXG5cbiAgZnVuY3Rpb24gY2hlY2tDYW5jZWwoZXZlbnQpIHtcblxuICAgIGlmIChldmVudC53aGljaCA9PT0gMjcpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcblxuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9XG5cblxuICAvLyBwcmV2ZW50IGdob3N0IGNsaWNrIHRoYXQgbWlnaHQgb2NjdXIgYWZ0ZXIgYSBmaW5pc2hlZFxuICAvLyBkcmFnIGFuZCBkcm9wIHNlc3Npb25cblxuICBmdW5jdGlvbiB0cmFwQ2xpY2tBbmRFbmQoZXZlbnQpIHtcblxuICAgIHZhciB1bnRyYXA7XG5cbiAgICAvLyB0cmFwIHRoZSBjbGljayBpbiBjYXNlIHdlIGFyZSBwYXJ0IG9mIGFuIGFjdGl2ZVxuICAgIC8vIGRyYWcgb3BlcmF0aW9uLiBUaGlzIHdpbGwgZWZmZWN0aXZlbHkgcHJldmVudFxuICAgIC8vIHRoZSBnaG9zdCBjbGljayB0aGF0IGNhbm5vdCBiZSBjYW5jZWxlZCBvdGhlcndpc2UuXG4gICAgaWYgKGNvbnRleHQuYWN0aXZlKSB7XG5cbiAgICAgIHVudHJhcCA9IGluc3RhbGxDbGlja1RyYXAoZXZlbnRCdXMpO1xuXG4gICAgICAvLyByZW1vdmUgdHJhcCBhZnRlciBtaW5pbWFsIGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KHVudHJhcCwgNDAwKTtcblxuICAgICAgLy8gcHJldmVudCBkZWZhdWx0IGFjdGlvbiAoY2xpY2spXG4gICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgfVxuXG4gICAgZW5kKGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYXBUb3VjaChldmVudCkge1xuICAgIG1vdmUoZXZlbnQpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHRoZSBkcmFnIGV2ZW50cyBob3ZlciAoZGpzLm1vZGVsLkJhc2UpIGFuZCBob3ZlckdmeCAoU25hcDxTVkdFbGVtZW50PilcbiAgLy8gcHJvcGVydGllcyBkdXJpbmcgaG92ZXIgYW5kIG91dCBhbmQgZmlyZSB7cHJlZml4fS5ob3ZlciBhbmQge3ByZWZpeH0ub3V0IHByb3BlcnRpZXNcbiAgLy8gcmVzcGVjdGl2ZWx5XG5cbiAgZnVuY3Rpb24gaG92ZXIoZXZlbnQpIHtcbiAgICB2YXIgcGF5bG9hZCA9IGNvbnRleHQucGF5bG9hZDtcblxuICAgIHBheWxvYWQuaG92ZXJHZnggPSBldmVudC5nZng7XG4gICAgcGF5bG9hZC5ob3ZlciA9IGV2ZW50LmVsZW1lbnQ7XG5cbiAgICBmaXJlKCdob3ZlcicpO1xuICB9XG5cbiAgZnVuY3Rpb24gb3V0KGV2ZW50KSB7XG4gICAgZmlyZSgnb3V0Jyk7XG5cbiAgICB2YXIgcGF5bG9hZCA9IGNvbnRleHQucGF5bG9hZDtcblxuICAgIHBheWxvYWQuaG92ZXJHZnggPSBudWxsO1xuICAgIHBheWxvYWQuaG92ZXIgPSBudWxsO1xuICB9XG5cblxuICAvLyBsaWZlLWN5Y2xlIG1ldGhvZHNcblxuICBmdW5jdGlvbiBjYW5jZWwocmVzdG9yZSkge1xuICAgIHZhciBwcmV2aW91c0NvbnRleHQ7XG5cbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FzQWN0aXZlID0gY29udGV4dC5hY3RpdmU7XG5cbiAgICBpZiAod2FzQWN0aXZlKSB7XG4gICAgICBmaXJlKCdjYW5jZWwnKTtcbiAgICB9XG5cbiAgICBwcmV2aW91c0NvbnRleHQgPSBjbGVhbnVwKHJlc3RvcmUpO1xuXG4gICAgaWYgKHdhc0FjdGl2ZSkge1xuXG4gICAgICAvLyBsYXN0IGV2ZW50IHRvIGJlIGZpcmVkIHdoZW4gYWxsIGRyYWcgb3BlcmF0aW9ucyBhcmUgZG9uZVxuICAgICAgLy8gYXQgdGhpcyBwb2ludCBpbiB0aW1lIG5vIGRyYWcgb3BlcmF0aW9uIGlzIGluIHByb2dyZXNzIGFueW1vcmVcbiAgICAgIGZpcmUoJ2NhbmNlbGVkJywgcHJldmlvdXNDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwKHJlc3RvcmUpIHtcbiAgICB2YXIgcHJldmlvdXNDb250ZXh0LFxuICAgICAgICBlbmREcmFnO1xuXG4gICAgZmlyZSgnY2xlYW51cCcpO1xuXG4gICAgLy8gcmVzZXQgY3Vyc29yXG4gICAgY3Vyc29yVW5zZXQoKTtcblxuICAgIGlmIChjb250ZXh0LnRyYXBDbGljaykge1xuICAgICAgZW5kRHJhZyA9IHRyYXBDbGlja0FuZEVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kRHJhZyA9IGVuZDtcbiAgICB9XG5cbiAgICAvLyByZXNldCBkb20gbGlzdGVuZXJzXG4gICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW92ZSk7XG5cbiAgICBkb21FdmVudC51bmJpbmQoZG9jdW1lbnQsICdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG5cbiAgICBkb21FdmVudC51bmJpbmQoZG9jdW1lbnQsICdtb3VzZWRvd24nLCBlbmREcmFnLCB0cnVlKTtcbiAgICBkb21FdmVudC51bmJpbmQoZG9jdW1lbnQsICdtb3VzZXVwJywgZW5kRHJhZywgdHJ1ZSk7XG5cbiAgICBkb21FdmVudC51bmJpbmQoZG9jdW1lbnQsICdrZXl1cCcsIGNoZWNrQ2FuY2VsKTtcblxuICAgIGRvbUV2ZW50LnVuYmluZChkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCB0cmFwVG91Y2gsIHRydWUpO1xuICAgIGRvbUV2ZW50LnVuYmluZChkb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgY2FuY2VsLCB0cnVlKTtcbiAgICBkb21FdmVudC51bmJpbmQoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBtb3ZlLCB0cnVlKTtcbiAgICBkb21FdmVudC51bmJpbmQoZG9jdW1lbnQsICd0b3VjaGVuZCcsIGVuZCwgdHJ1ZSk7XG5cbiAgICBldmVudEJ1cy5vZmYoJ2VsZW1lbnQuaG92ZXInLCBob3Zlcik7XG4gICAgZXZlbnRCdXMub2ZmKCdlbGVtZW50Lm91dCcsIG91dCk7XG5cbiAgICAvLyByZW1vdmUgZHJhZyBtYXJrZXIgb24gcm9vdCBlbGVtZW50XG4gICAgY2FudmFzLnJlbW92ZU1hcmtlcihjYW52YXMuZ2V0Um9vdEVsZW1lbnQoKSwgRFJBR19BQ1RJVkVfQ0xTKTtcblxuICAgIC8vIHJlc3RvcmUgc2VsZWN0aW9uLCB1bmxlc3MgaXQgaGFzIGNoYW5nZWRcbiAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSBjb250ZXh0LnBheWxvYWQucHJldmlvdXNTZWxlY3Rpb247XG5cbiAgICBpZiAocmVzdG9yZSAhPT0gZmFsc2UgJiYgcHJldmlvdXNTZWxlY3Rpb24gJiYgIXNlbGVjdGlvbi5nZXQoKS5sZW5ndGgpIHtcbiAgICAgIHJlc3RvcmVTZWxlY3Rpb24ocHJldmlvdXNTZWxlY3Rpb24pO1xuICAgIH1cblxuICAgIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICBjb250ZXh0ID0gbnVsbDtcblxuICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIGRyYWcgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBJZiBgbG9jYWxQb3NpdGlvbmAgaXMgZ2l2ZW4sIGRyYWcgZXZlbnRzIHdpbGwgYmUgZW1pdHRlZFxuICAgKiByZWxhdGl2ZSB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fFRvdWNoRXZlbnR9IFtldmVudF1cbiAgICogQHBhcmFtIHtQb2ludH0gW2xvY2FsUG9zaXRpb25dIGFjdHVhbCBkaWFncmFtIGxvY2FsIHBvc2l0aW9uIHRoaXMgZHJhZyBvcGVyYXRpb24gc2hvdWxkIHN0YXJ0IGF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdChldmVudCwgcmVsYXRpdmVUbywgcHJlZml4LCBvcHRpb25zKSB7XG5cbiAgICAvLyBvbmx5IG9uZSBkcmFnIG9wZXJhdGlvbiBtYXkgYmUgYWN0aXZlLCBhdCBhIHRpbWVcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgY2FuY2VsKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlbGF0aXZlVG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0gcHJlZml4O1xuICAgICAgcHJlZml4ID0gcmVsYXRpdmVUbztcbiAgICAgIHJlbGF0aXZlVG8gPSBudWxsO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhIHx8IHt9LFxuICAgICAgICBvcmlnaW5hbEV2ZW50LFxuICAgICAgICBnbG9iYWxTdGFydCxcbiAgICAgICAgbG9jYWxTdGFydCxcbiAgICAgICAgZW5kRHJhZyxcbiAgICAgICAgaXNUb3VjaDtcblxuICAgIGlmIChvcHRpb25zLnRyYXBDbGljaykge1xuICAgICAgZW5kRHJhZyA9IHRyYXBDbGlja0FuZEVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kRHJhZyA9IGVuZDtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQgPSBnZXRPcmlnaW5hbChldmVudCkgfHwgZXZlbnQ7XG4gICAgICBnbG9iYWxTdGFydCA9IHRvUG9pbnQoZXZlbnQpO1xuXG4gICAgICBzdG9wUHJvcGFnYXRpb24oZXZlbnQpO1xuXG4gICAgICAvLyBwcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBkcmFnZ2luZyBiZWhhdmlvclxuICAgICAgaWYgKG9yaWdpbmFsRXZlbnQudHlwZSA9PT0gJ2RyYWdzdGFydCcpIHtcbiAgICAgICAgcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQgPSBudWxsO1xuICAgICAgZ2xvYmFsU3RhcnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG5cbiAgICBsb2NhbFN0YXJ0ID0gdG9Mb2NhbFBvaW50KGdsb2JhbFN0YXJ0KTtcblxuICAgIGlmICghcmVsYXRpdmVUbykge1xuICAgICAgcmVsYXRpdmVUbyA9IGxvY2FsU3RhcnQ7XG4gICAgfVxuXG4gICAgaXNUb3VjaCA9IGlzVG91Y2hFdmVudChvcmlnaW5hbEV2ZW50KTtcblxuICAgIGNvbnRleHQgPSBhc3NpZ24oe1xuICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgcGF5bG9hZDoge30sXG4gICAgICBnbG9iYWxTdGFydDogZ2xvYmFsU3RhcnQsXG4gICAgICBkaXNwbGFjZW1lbnQ6IGRlbHRhUG9zKHJlbGF0aXZlVG8sIGxvY2FsU3RhcnQpLFxuICAgICAgbG9jYWxTdGFydDogbG9jYWxTdGFydCxcbiAgICAgIGlzVG91Y2g6IGlzVG91Y2hcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8vIHNraXAgZG9tIHJlZ2lzdHJhdGlvbiBpZiB0cmlnZ2VyXG4gICAgLy8gaXMgc2V0IHRvIG1hbnVhbCAoZHVyaW5nIHRlc3RpbmcpXG4gICAgaWYgKCFvcHRpb25zLm1hbnVhbCkge1xuXG4gICAgICAvLyBhZGQgZG9tIGxpc3RlbmVyc1xuXG4gICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICBkb21FdmVudC5iaW5kKGRvY3VtZW50LCAndG91Y2hzdGFydCcsIHRyYXBUb3VjaCwgdHJ1ZSk7XG4gICAgICAgIGRvbUV2ZW50LmJpbmQoZG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIGNhbmNlbCwgdHJ1ZSk7XG4gICAgICAgIGRvbUV2ZW50LmJpbmQoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBtb3ZlLCB0cnVlKTtcbiAgICAgICAgZG9tRXZlbnQuYmluZChkb2N1bWVudCwgJ3RvdWNoZW5kJywgZW5kLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gYXNzdW1lIHdlIHVzZSB0aGUgbW91c2UgdG8gaW50ZXJhY3QgcGVyIGRlZmF1bHRcbiAgICAgICAgZG9tRXZlbnQuYmluZChkb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdmUpO1xuXG4gICAgICAgIC8vIHByZXZlbnQgZGVmYXVsdCBicm93c2VyIGRyYWcgYW5kIHRleHQgc2VsZWN0aW9uIGJlaGF2aW9yXG4gICAgICAgIGRvbUV2ZW50LmJpbmQoZG9jdW1lbnQsICdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgIGRvbUV2ZW50LmJpbmQoZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcblxuICAgICAgICBkb21FdmVudC5iaW5kKGRvY3VtZW50LCAnbW91c2Vkb3duJywgZW5kRHJhZywgdHJ1ZSk7XG4gICAgICAgIGRvbUV2ZW50LmJpbmQoZG9jdW1lbnQsICdtb3VzZXVwJywgZW5kRHJhZywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGRvbUV2ZW50LmJpbmQoZG9jdW1lbnQsICdrZXl1cCcsIGNoZWNrQ2FuY2VsKTtcblxuICAgICAgZXZlbnRCdXMub24oJ2VsZW1lbnQuaG92ZXInLCBob3Zlcik7XG4gICAgICBldmVudEJ1cy5vbignZWxlbWVudC5vdXQnLCBvdXQpO1xuICAgIH1cblxuICAgIGZpcmUoJ2luaXQnKTtcblxuICAgIGlmIChvcHRpb25zLmF1dG9BY3RpdmF0ZSkge1xuICAgICAgbW92ZShldmVudCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FuY2VsIG9uIGRpYWdyYW0gZGVzdHJ1Y3Rpb25cbiAgZXZlbnRCdXMub24oJ2RpYWdyYW0uZGVzdHJveScsIGNhbmNlbCk7XG5cblxuICAvLyBBUElcblxuICB0aGlzLmluaXQgPSBpbml0O1xuICB0aGlzLm1vdmUgPSBtb3ZlO1xuICB0aGlzLmhvdmVyID0gaG92ZXI7XG4gIHRoaXMub3V0ID0gb3V0O1xuICB0aGlzLmVuZCA9IGVuZDtcblxuICB0aGlzLmNhbmNlbCA9IGNhbmNlbDtcblxuICAvLyBmb3IgaW50cm9zcGVjdGlvblxuXG4gIHRoaXMuY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9O1xuXG4gIHRoaXMuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBhc3NpZ24oZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICB9O1xufVxuXG5EcmFnZ2luZy4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJyxcbiAgJ3NlbGVjdGlvbicsXG4gICdlbGVtZW50UmVnaXN0cnknXG5dO1xuIiwiaW1wb3J0IEhvdmVyRml4TW9kdWxlIGZyb20gJy4uL2hvdmVyLWZpeCc7XG5pbXBvcnQgU2VsZWN0aW9uTW9kdWxlIGZyb20gJy4uL3NlbGVjdGlvbic7XG5cbmltcG9ydCBEcmFnZ2luZyBmcm9tICcuL0RyYWdnaW5nJztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgSG92ZXJGaXhNb2R1bGUsXG4gICAgU2VsZWN0aW9uTW9kdWxlLFxuICBdLFxuICBkcmFnZ2luZzogWyAndHlwZScsIERyYWdnaW5nIF0sXG59OyIsImltcG9ydCB7XG4gIGZvckVhY2gsXG4gIGlzQXJyYXlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG52YXIgTk9UX1JFR0lTVEVSRURfRVJST1IgPSAnaXMgbm90IGEgcmVnaXN0ZXJlZCBhY3Rpb24nLFxuICAgIElTX1JFR0lTVEVSRURfRVJST1IgPSAnaXMgYWxyZWFkeSByZWdpc3RlcmVkJztcblxuXG4vKipcbiAqIEFuIGludGVyZmFjZSB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBtb2RlbGluZyBhY3Rpb25zIGJ5IGRlY291cGxpbmdcbiAqIHRoZSBvbmUgd2hvIHJlcXVlc3RzIHRoZSBhY3Rpb24gdG8gYmUgdHJpZ2dlcmVkIGFuZCB0aGUgdHJpZ2dlciBpdHNlbGYuXG4gKlxuICogSXQncyBwb3NzaWJsZSB0byBhZGQgbmV3IGFjdGlvbnMgYnkgcmVnaXN0ZXJpbmcgdGhlbSB3aXRoIMK0cmVnaXN0ZXJBY3Rpb27CtFxuICogYW5kIGxpa2V3aXNlIHVucmVnaXN0ZXIgZXhpc3Rpbmcgb25lcyB3aXRoIMK0dW5yZWdpc3RlckFjdGlvbsK0LlxuICpcbiAqXG4gKiAjIyBMaWZlLUN5Y2xlIGFuZCBjb25maWd1cmF0aW9uXG4gKlxuICogVGhlIGVkaXRvciBhY3Rpb25zIHdpbGwgd2FpdCBmb3IgZGlhZ3JhbSBpbml0aWFsaXphdGlvbiBiZWZvcmVcbiAqIHJlZ2lzdGVyaW5nIGRlZmF1bHQgYWN0aW9ucyBfYW5kXyBmaXJpbmcgYW4gYGVkaXRvckFjdGlvbnMuaW5pdGAgZXZlbnQuXG4gKlxuICogSW50ZXJlc3RlZCBwYXJ0aWVzIG1heSBsaXN0ZW4gdG8gdGhlIGBlZGl0b3JBY3Rpb25zLmluaXRgIGV2ZW50IHdpdGhcbiAqIGxvdyBwcmlvcml0eSB0byBjaGVjaywgd2hpY2ggYWN0aW9ucyBnb3QgcmVnaXN0ZXJlZC4gT3RoZXIgY29tcG9uZW50c1xuICogbWF5IHVzZSB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgdGhlaXIgb3duIGFjdGlvbnMgdmlhIGByZWdpc3RlckFjdGlvbmAuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7SW5qZWN0b3J9IGluamVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVkaXRvckFjdGlvbnMoZXZlbnRCdXMsIGluamVjdG9yKSB7XG5cbiAgLy8gaW5pdGlhbGl6ZSBhY3Rpb25zXG4gIHRoaXMuX2FjdGlvbnMgPSB7fTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRCdXMub24oJ2RpYWdyYW0uaW5pdCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gYWxsIGRpYWdyYW0gbW9kdWxlcyBnb3QgbG9hZGVkOyBjaGVjayB3aGljaCBvbmVzXG4gICAgLy8gYXJlIGF2YWlsYWJsZSBhbmQgcmVnaXN0ZXIgdGhlIHJlc3BlY3RpdmUgZGVmYXVsdCBhY3Rpb25zXG4gICAgc2VsZi5fcmVnaXN0ZXJEZWZhdWx0QWN0aW9ucyhpbmplY3Rvcik7XG5cbiAgICAvLyBhc2sgaW50ZXJlc3RlZCBwYXJ0aWVzIHRvIHJlZ2lzdGVyIGF2YWlsYWJsZSBlZGl0b3JcbiAgICAvLyBhY3Rpb25zIG9uIGRpYWdyYW0gaW5pdGlhbGl6YXRpb25cbiAgICBldmVudEJ1cy5maXJlKCdlZGl0b3JBY3Rpb25zLmluaXQnLCB7XG4gICAgICBlZGl0b3JBY3Rpb25zOiBzZWxmXG4gICAgfSk7XG4gIH0pO1xuXG59XG5cbkVkaXRvckFjdGlvbnMuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2luamVjdG9yJ1xuXTtcblxuLyoqXG4gKiBSZWdpc3RlciBkZWZhdWx0IGFjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtJbmplY3Rvcn0gaW5qZWN0b3JcbiAqL1xuRWRpdG9yQWN0aW9ucy5wcm90b3R5cGUuX3JlZ2lzdGVyRGVmYXVsdEFjdGlvbnMgPSBmdW5jdGlvbihpbmplY3Rvcikge1xuXG4gIC8vICgxKSByZXRyaWV2ZSBvcHRpb25hbCBjb21wb25lbnRzIHRvIGludGVncmF0ZSB3aXRoXG5cbiAgdmFyIGNvbW1hbmRTdGFjayA9IGluamVjdG9yLmdldCgnY29tbWFuZFN0YWNrJywgZmFsc2UpO1xuICB2YXIgbW9kZWxpbmcgPSBpbmplY3Rvci5nZXQoJ21vZGVsaW5nJywgZmFsc2UpO1xuICB2YXIgc2VsZWN0aW9uID0gaW5qZWN0b3IuZ2V0KCdzZWxlY3Rpb24nLCBmYWxzZSk7XG4gIHZhciB6b29tU2Nyb2xsID0gaW5qZWN0b3IuZ2V0KCd6b29tU2Nyb2xsJywgZmFsc2UpO1xuICB2YXIgY29weVBhc3RlID0gaW5qZWN0b3IuZ2V0KCdjb3B5UGFzdGUnLCBmYWxzZSk7XG4gIHZhciBjYW52YXMgPSBpbmplY3Rvci5nZXQoJ2NhbnZhcycsIGZhbHNlKTtcbiAgdmFyIHJ1bGVzID0gaW5qZWN0b3IuZ2V0KCdydWxlcycsIGZhbHNlKTtcbiAgdmFyIGtleWJvYXJkTW92ZSA9IGluamVjdG9yLmdldCgna2V5Ym9hcmRNb3ZlJywgZmFsc2UpO1xuICB2YXIga2V5Ym9hcmRNb3ZlU2VsZWN0aW9uID0gaW5qZWN0b3IuZ2V0KCdrZXlib2FyZE1vdmVTZWxlY3Rpb24nLCBmYWxzZSk7XG5cbiAgLy8gKDIpIGNoZWNrIGNvbXBvbmVudHMgYW5kIHJlZ2lzdGVyIGFjdGlvbnNcblxuICBpZiAoY29tbWFuZFN0YWNrKSB7XG4gICAgdGhpcy5yZWdpc3RlcigndW5kbycsIGZ1bmN0aW9uKCkge1xuICAgICAgY29tbWFuZFN0YWNrLnVuZG8oKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXIoJ3JlZG8nLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbW1hbmRTdGFjay5yZWRvKCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoY29weVBhc3RlICYmIHNlbGVjdGlvbikge1xuICAgIHRoaXMucmVnaXN0ZXIoJ2NvcHknLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxlY3RlZEVsZW1lbnRzID0gc2VsZWN0aW9uLmdldCgpO1xuXG4gICAgICBjb3B5UGFzdGUuY29weShzZWxlY3RlZEVsZW1lbnRzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjb3B5UGFzdGUpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKCdwYXN0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgY29weVBhc3RlLnBhc3RlKCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoem9vbVNjcm9sbCkge1xuICAgIHRoaXMucmVnaXN0ZXIoJ3N0ZXBab29tJywgZnVuY3Rpb24ob3B0cykge1xuICAgICAgem9vbVNjcm9sbC5zdGVwWm9vbShvcHRzLnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjYW52YXMpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKCd6b29tJywgZnVuY3Rpb24ob3B0cykge1xuICAgICAgY2FudmFzLnpvb20ob3B0cy52YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAobW9kZWxpbmcgJiYgc2VsZWN0aW9uICYmIHJ1bGVzKSB7XG4gICAgdGhpcy5yZWdpc3RlcigncmVtb3ZlU2VsZWN0aW9uJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBzZWxlY3RlZEVsZW1lbnRzID0gc2VsZWN0aW9uLmdldCgpO1xuXG4gICAgICBpZiAoIXNlbGVjdGVkRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFsbG93ZWQgPSBydWxlcy5hbGxvd2VkKCdlbGVtZW50cy5kZWxldGUnLCB7IGVsZW1lbnRzOiBzZWxlY3RlZEVsZW1lbnRzIH0pLFxuICAgICAgICAgIHJlbW92YWJsZUVsZW1lbnRzO1xuXG4gICAgICBpZiAoYWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheShhbGxvd2VkKSkge1xuICAgICAgICByZW1vdmFibGVFbGVtZW50cyA9IGFsbG93ZWQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZhYmxlRWxlbWVudHMgPSBzZWxlY3RlZEVsZW1lbnRzO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZhYmxlRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIG1vZGVsaW5nLnJlbW92ZUVsZW1lbnRzKHJlbW92YWJsZUVsZW1lbnRzLnNsaWNlKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGtleWJvYXJkTW92ZSkge1xuICAgIHRoaXMucmVnaXN0ZXIoJ21vdmVDYW52YXMnLCBmdW5jdGlvbihvcHRzKSB7XG4gICAgICBrZXlib2FyZE1vdmUubW92ZUNhbnZhcyhvcHRzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChrZXlib2FyZE1vdmVTZWxlY3Rpb24pIHtcbiAgICB0aGlzLnJlZ2lzdGVyKCdtb3ZlU2VsZWN0aW9uJywgZnVuY3Rpb24ob3B0cykge1xuICAgICAga2V5Ym9hcmRNb3ZlU2VsZWN0aW9uLm1vdmVTZWxlY3Rpb24ob3B0cy5kaXJlY3Rpb24sIG9wdHMuYWNjZWxlcmF0ZWQpO1xuICAgIH0pO1xuICB9XG5cbn07XG5cblxuLyoqXG4gKiBUcmlnZ2VycyBhIHJlZ2lzdGVyZWQgYWN0aW9uXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBhY3Rpb25cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0c1xuICpcbiAqIEByZXR1cm4ge1Vua25vd259IFJldHVybnMgd2hhdCB0aGUgcmVnaXN0ZXJlZCBsaXN0ZW5lciByZXR1cm5zXG4gKi9cbkVkaXRvckFjdGlvbnMucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihhY3Rpb24sIG9wdHMpIHtcbiAgaWYgKCF0aGlzLl9hY3Rpb25zW2FjdGlvbl0pIHtcbiAgICB0aHJvdyBlcnJvcihhY3Rpb24sIE5PVF9SRUdJU1RFUkVEX0VSUk9SKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9hY3Rpb25zW2FjdGlvbl0ob3B0cyk7XG59O1xuXG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgY29sbGVjdGlvbnMgb2YgYWN0aW9ucy5cbiAqIFRoZSBrZXkgb2YgdGhlIG9iamVjdCB3aWxsIGJlIHRoZSBuYW1lIG9mIHRoZSBhY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIMK0wrTCtFxuICogdmFyIGFjdGlvbnMgPSB7XG4gKiAgIHNwYWNlVG9vbDogZnVuY3Rpb24oKSB7XG4gKiAgICAgc3BhY2VUb29sLmFjdGl2YXRlU2VsZWN0aW9uKCk7XG4gKiAgIH0sXG4gKiAgIGxhc3NvVG9vbDogZnVuY3Rpb24oKSB7XG4gKiAgICAgbGFzc29Ub29sLmFjdGl2YXRlU2VsZWN0aW9uKCk7XG4gKiAgIH1cbiAqIF07XG4gKlxuICogZWRpdG9yQWN0aW9ucy5yZWdpc3RlcihhY3Rpb25zKTtcbiAqXG4gKiBlZGl0b3JBY3Rpb25zLmlzUmVnaXN0ZXJlZCgnc3BhY2VUb29sJyk7IC8vIHRydWVcbiAqIMK0wrTCtFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYWN0aW9uc1xuICovXG5FZGl0b3JBY3Rpb25zLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGFjdGlvbnMsIGxpc3RlbmVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodHlwZW9mIGFjdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyQWN0aW9uKGFjdGlvbnMsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGZvckVhY2goYWN0aW9ucywgZnVuY3Rpb24obGlzdGVuZXIsIGFjdGlvbikge1xuICAgIHNlbGYuX3JlZ2lzdGVyQWN0aW9uKGFjdGlvbiwgbGlzdGVuZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdG8gYW4gYWN0aW9uIGtleVxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gYWN0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqL1xuRWRpdG9yQWN0aW9ucy5wcm90b3R5cGUuX3JlZ2lzdGVyQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBsaXN0ZW5lcikge1xuICBpZiAodGhpcy5pc1JlZ2lzdGVyZWQoYWN0aW9uKSkge1xuICAgIHRocm93IGVycm9yKGFjdGlvbiwgSVNfUkVHSVNURVJFRF9FUlJPUik7XG4gIH1cblxuICB0aGlzLl9hY3Rpb25zW2FjdGlvbl0gPSBsaXN0ZW5lcjtcbn07XG5cbi8qKlxuICogVW5yZWdpc3RlciBhbiBleGlzdGluZyBhY3Rpb25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gKi9cbkVkaXRvckFjdGlvbnMucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihhY3Rpb24pIHtcbiAgaWYgKCF0aGlzLmlzUmVnaXN0ZXJlZChhY3Rpb24pKSB7XG4gICAgdGhyb3cgZXJyb3IoYWN0aW9uLCBOT1RfUkVHSVNURVJFRF9FUlJPUik7XG4gIH1cblxuICB0aGlzLl9hY3Rpb25zW2FjdGlvbl0gPSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBhY3Rpb25zIHRoYXQgYXJlIGN1cnJlbnRseSByZWdpc3RlcmVkXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5FZGl0b3JBY3Rpb25zLnByb3RvdHlwZS5nZXRBY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9hY3Rpb25zKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdldGhlciB0aGUgZ2l2ZW4gYWN0aW9uIGlzIHJlZ2lzdGVyZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuRWRpdG9yQWN0aW9ucy5wcm90b3R5cGUuaXNSZWdpc3RlcmVkID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gIHJldHVybiAhIXRoaXMuX2FjdGlvbnNbYWN0aW9uXTtcbn07XG5cblxuZnVuY3Rpb24gZXJyb3IoYWN0aW9uLCBtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoYWN0aW9uICsgJyAnICsgbWVzc2FnZSk7XG59XG4iLCJpbXBvcnQgRWRpdG9yQWN0aW9ucyBmcm9tICcuL0VkaXRvckFjdGlvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdlZGl0b3JBY3Rpb25zJyBdLFxuICBlZGl0b3JBY3Rpb25zOiBbICd0eXBlJywgRWRpdG9yQWN0aW9ucyBdXG59O1xuIiwiaW1wb3J0IHtcbiAgaGFzUHJpbWFyeU1vZGlmaWVyXG59IGZyb20gJy4uLy4uL3V0aWwvTW91c2UnO1xuXG5pbXBvcnQgeyBpc0tleSB9IGZyb20gJy4uLy4uL2ZlYXR1cmVzL2tleWJvYXJkL0tleWJvYXJkVXRpbCc7XG5cbnZhciBISUdIX1BSSU9SSVRZID0gMTUwMDtcbnZhciBIQU5EX0NVUlNPUiA9ICdncmFiJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIYW5kVG9vbChcbiAgICBldmVudEJ1cywgY2FudmFzLCBkcmFnZ2luZyxcbiAgICBpbmplY3RvciwgdG9vbE1hbmFnZXIsIG1vdXNlKSB7XG5cbiAgdGhpcy5fZHJhZ2dpbmcgPSBkcmFnZ2luZztcbiAgdGhpcy5fbW91c2UgPSBtb3VzZTtcblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBrZXlib2FyZCA9IGluamVjdG9yLmdldCgna2V5Ym9hcmQnLCBmYWxzZSk7XG5cbiAgdG9vbE1hbmFnZXIucmVnaXN0ZXJUb29sKCdoYW5kJywge1xuICAgIHRvb2w6ICdoYW5kJyxcbiAgICBkcmFnZ2luZzogJ2hhbmQubW92ZSdcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2VsZW1lbnQubW91c2Vkb3duJywgSElHSF9QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIGlmICghaGFzUHJpbWFyeU1vZGlmaWVyKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuYWN0aXZhdGVNb3ZlKGV2ZW50Lm9yaWdpbmFsRXZlbnQsIHRydWUpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcblxuICBrZXlib2FyZCAmJiBrZXlib2FyZC5hZGRMaXN0ZW5lcihISUdIX1BSSU9SSVRZLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1NwYWNlKGUua2V5RXZlbnQpIHx8IHNlbGYuaXNBY3RpdmUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5fbW91c2UuZ2V0TGFzdE1vdmVFdmVudCgpO1xuXG4gICAgc2VsZi5hY3RpdmF0ZU1vdmUobW91c2VFdmVudCwgISFtb3VzZUV2ZW50KTtcbiAgfSwgJ2tleWJvYXJkLmtleWRvd24nKTtcblxuICBrZXlib2FyZCAmJiBrZXlib2FyZC5hZGRMaXN0ZW5lcihISUdIX1BSSU9SSVRZLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1NwYWNlKGUua2V5RXZlbnQpIHx8ICFzZWxmLmlzQWN0aXZlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLnRvZ2dsZSgpO1xuICB9LCAna2V5Ym9hcmQua2V5dXAnKTtcblxuICBldmVudEJ1cy5vbignaGFuZC5lbmQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBldmVudC5vcmlnaW5hbEV2ZW50LnRhcmdldDtcblxuICAgIC8vIG9ubHkgcmVhY3RpdmUgb24gZGlhZ3JhbSBjbGlja1xuICAgIC8vIG9uIHNvbWUgb2NjYXNpb25zLCBldmVudC5ob3ZlciBpcyBub3Qgc2V0IGFuZCB3ZSBoYXZlIHRvIGNoZWNrIGlmIHRoZSB0YXJnZXQgaXMgYW4gc3ZnXG4gICAgaWYgKCFldmVudC5ob3ZlciAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZXZlbnRCdXMub25jZSgnaGFuZC5lbmRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5hY3RpdmF0ZU1vdmUoZXZlbnQub3JpZ2luYWxFdmVudCwgeyByZWFjdGl2YXRlOiB0cnVlIH0pO1xuICAgIH0pO1xuXG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdoYW5kLm1vdmUubW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHNjYWxlID0gY2FudmFzLnZpZXdib3goKS5zY2FsZTtcblxuICAgIGNhbnZhcy5zY3JvbGwoe1xuICAgICAgZHg6IGV2ZW50LmR4ICogc2NhbGUsXG4gICAgICBkeTogZXZlbnQuZHkgKiBzY2FsZVxuICAgIH0pO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignaGFuZC5tb3ZlLmVuZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICByZWFjdGl2YXRlID0gY29udGV4dC5yZWFjdGl2YXRlO1xuXG4gICAgLy8gRG9uJ3QgcmVhY3RpdmF0ZSBpZiB0aGUgdXNlciBpcyB1c2luZyB0aGUga2V5Ym9hcmQga2V5YmluZGluZ1xuICAgIGlmICghaGFzUHJpbWFyeU1vZGlmaWVyKGV2ZW50KSAmJiByZWFjdGl2YXRlKSB7XG5cbiAgICAgIGV2ZW50QnVzLm9uY2UoJ2hhbmQubW92ZS5lbmRlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHNlbGYuYWN0aXZhdGVIYW5kKGV2ZW50Lm9yaWdpbmFsRXZlbnQsIHRydWUsIHRydWUpO1xuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuXG59XG5cbkhhbmRUb29sLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnZHJhZ2dpbmcnLFxuICAnaW5qZWN0b3InLFxuICAndG9vbE1hbmFnZXInLFxuICAnbW91c2UnXG5dO1xuXG5cbkhhbmRUb29sLnByb3RvdHlwZS5hY3RpdmF0ZU1vdmUgPSBmdW5jdGlvbihldmVudCwgYXV0b0FjdGl2YXRlLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgYXV0b0FjdGl2YXRlID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnRleHQgPSBhdXRvQWN0aXZhdGU7XG4gICAgYXV0b0FjdGl2YXRlID0gZmFsc2U7XG4gIH1cblxuICB0aGlzLl9kcmFnZ2luZy5pbml0KGV2ZW50LCAnaGFuZC5tb3ZlJywge1xuICAgIGF1dG9BY3RpdmF0ZTogYXV0b0FjdGl2YXRlLFxuICAgIGN1cnNvcjogSEFORF9DVVJTT1IsXG4gICAgZGF0YToge1xuICAgICAgY29udGV4dDogY29udGV4dCB8fCB7fVxuICAgIH1cbiAgfSk7XG59O1xuXG5IYW5kVG9vbC5wcm90b3R5cGUuYWN0aXZhdGVIYW5kID0gZnVuY3Rpb24oZXZlbnQsIGF1dG9BY3RpdmF0ZSwgcmVhY3RpdmF0ZSkge1xuICB0aGlzLl9kcmFnZ2luZy5pbml0KGV2ZW50LCAnaGFuZCcsIHtcbiAgICB0cmFwQ2xpY2s6IGZhbHNlLFxuICAgIGF1dG9BY3RpdmF0ZTogYXV0b0FjdGl2YXRlLFxuICAgIGN1cnNvcjogSEFORF9DVVJTT1IsXG4gICAgZGF0YToge1xuICAgICAgY29udGV4dDoge1xuICAgICAgICByZWFjdGl2YXRlOiByZWFjdGl2YXRlXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkhhbmRUb29sLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgIHJldHVybiB0aGlzLl9kcmFnZ2luZy5jYW5jZWwoKTtcbiAgfVxuXG4gIHZhciBtb3VzZUV2ZW50ID0gdGhpcy5fbW91c2UuZ2V0TGFzdE1vdmVFdmVudCgpO1xuXG4gIHRoaXMuYWN0aXZhdGVIYW5kKG1vdXNlRXZlbnQsICEhbW91c2VFdmVudCk7XG59O1xuXG5IYW5kVG9vbC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLl9kcmFnZ2luZy5jb250ZXh0KCk7XG5cbiAgaWYgKGNvbnRleHQpIHtcbiAgICByZXR1cm4gL14oaGFuZHxoYW5kXFwubW92ZSkkLy50ZXN0KGNvbnRleHQucHJlZml4KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc1NwYWNlKGtleUV2ZW50KSB7XG4gIHJldHVybiBpc0tleSgnICcsIGtleUV2ZW50KTtcbn0iLCJpbXBvcnQgVG9vbE1hbmFnZXJNb2R1bGUgZnJvbSAnLi4vdG9vbC1tYW5hZ2VyJztcbmltcG9ydCBNb3VzZU1vZHVsZSBmcm9tICcuLi9tb3VzZSc7XG5cbmltcG9ydCBIYW5kVG9vbCBmcm9tICcuL0hhbmRUb29sJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIFRvb2xNYW5hZ2VyTW9kdWxlLFxuICAgIE1vdXNlTW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbICdoYW5kVG9vbCcgXSxcbiAgaGFuZFRvb2w6IFsgJ3R5cGUnLCBIYW5kVG9vbCBdXG59O1xuIiwiaW1wb3J0IHtcbiAgY2xvc2VzdCBhcyBkb21DbG9zZXN0XG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQge1xuICB0b1BvaW50XG59IGZyb20gJy4uLy4uL3V0aWwvRXZlbnQnO1xuXG52YXIgSElHSF9QUklPUklUWSA9IDE1MDA7XG5cblxuLyoqXG4gKiBCcm93c2VycyBtYXkgc3dhbGxvdyBjZXJ0YWluIGV2ZW50cyAoaG92ZXIsIG91dCAuLi4pIGlmIHVzZXJzIGFyZSB0b1xuICogZmFzdCB3aXRoIHRoZSBtb3VzZS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQ0ODQ2OC93aHktY2FudC1pLXJlbGlhYmx5LWNhcHR1cmUtYS1tb3VzZW91dC1ldmVudFxuICpcbiAqIFRoZSBmaXggaW1wbGVtZW50ZWQgaW4gdGhpcyBjb21wb25lbnQgZW5zdXJlIHRoYXQgd2VcbiAqXG4gKiAxKSBoYXZlIGEgaG92ZXIgc3RhdGUgYWZ0ZXIgYSBzdWNjZXNzZnVsIGRyYWcubW92ZSBldmVudFxuICogMikgaGF2ZSBhbiBvdXQgZXZlbnQgd2hlbiBkcmFnZ2luZyBsZWF2ZXMgYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0luamVjdG9yfSBpbmplY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb3ZlckZpeChlbGVtZW50UmVnaXN0cnksIGV2ZW50QnVzLCBpbmplY3Rvcikge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgZHJhZ2dpbmcgPSBpbmplY3Rvci5nZXQoJ2RyYWdnaW5nJywgZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBNYWtlIHN1cmUgd2UgYXJlIGdvZCBkYW1uIGhvdmVyaW5nIVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBkcmFnZ2luZyBldmVudFxuICAgKi9cbiAgZnVuY3Rpb24gZW5zdXJlSG92ZXIoZXZlbnQpIHtcblxuICAgIGlmIChldmVudC5ob3Zlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudDtcblxuICAgIHZhciBnZnggPSBzZWxmLl9maW5kVGFyZ2V0R2Z4KG9yaWdpbmFsRXZlbnQpO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBnZnggJiYgZWxlbWVudFJlZ2lzdHJ5LmdldChnZngpO1xuXG4gICAgaWYgKGdmeCAmJiBlbGVtZW50KSB7XG5cbiAgICAgIC8vIDEpIGNhbmNlbCBjdXJyZW50IG1vdXNlbW92ZVxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIC8vIDIpIGVtaXQgZmFrZSBob3ZlciBmb3IgbmV3IHRhcmdldFxuICAgICAgZHJhZ2dpbmcuaG92ZXIoeyBlbGVtZW50OiBlbGVtZW50LCBnZng6IGdmeCB9KTtcblxuICAgICAgLy8gMykgcmUtdHJpZ2dlciBtb3ZlIGV2ZW50XG4gICAgICBkcmFnZ2luZy5tb3ZlKG9yaWdpbmFsRXZlbnQpO1xuICAgIH1cbiAgfVxuXG5cbiAgaWYgKGRyYWdnaW5nKSB7XG5cbiAgICAvKipcbiAgICAgKiBXZSB3YWl0IGZvciBhIHNwZWNpZmljIHNlcXVlbmNlIG9mIGV2ZW50cyBiZWZvcmVcbiAgICAgKiBlbWl0dGluZyBhIGZha2UgZHJhZy5ob3ZlciBldmVudC5cbiAgICAgKlxuICAgICAqIEV2ZW50IFNlcXVlbmNlOlxuICAgICAqXG4gICAgICogZHJhZy5zdGFydFxuICAgICAqIGRyYWcubW92ZSA+PiBlbnN1cmUgd2UgYXJlIGhvdmVyaW5nXG4gICAgICovXG4gICAgZXZlbnRCdXMub24oJ2RyYWcuc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICBldmVudEJ1cy5vbmNlKCdkcmFnLm1vdmUnLCBISUdIX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIGVuc3VyZUhvdmVyKGV2ZW50KTtcblxuICAgICAgfSk7XG5cbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdlIG1ha2Ugc3VyZSB0aGF0IGVsZW1lbnQub3V0IGlzIGFsd2F5cyBmaXJlZCwgZXZlbiBpZiB0aGVcbiAgICogYnJvd3NlciBzd2FsbG93cyBhbiBlbGVtZW50Lm91dCBldmVudC5cbiAgICpcbiAgICogRXZlbnQgc2VxdWVuY2U6XG4gICAqXG4gICAqIGVsZW1lbnQuaG92ZXJcbiAgICogKGVsZW1lbnQub3V0ID4+IHNvbWV0aW1lcyBzd2FsbG93ZWQpXG4gICAqIGVsZW1lbnQuaG92ZXIgPj4gZW5zdXJlIHdlIGZpcmVkIGVsZW1lbnQub3V0XG4gICAqL1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhvdmVyR2Z4O1xuICAgIHZhciBob3ZlcjtcblxuICAgIGV2ZW50QnVzLm9uKCdlbGVtZW50LmhvdmVyJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgLy8gKDEpIHJlbWVtYmVyIGN1cnJlbnQgaG92ZXIgZWxlbWVudFxuICAgICAgaG92ZXJHZnggPSBldmVudC5nZng7XG4gICAgICBob3ZlciA9IGV2ZW50LmVsZW1lbnQ7XG4gICAgfSk7XG5cbiAgICBldmVudEJ1cy5vbignZWxlbWVudC5ob3ZlcicsIEhJR0hfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgIC8vICgzKSBhbSBJIG9uIGFuIGVsZW1lbnQgc3RpbGw/XG4gICAgICBpZiAoaG92ZXIpIHtcblxuICAgICAgICAvLyAoNCkgdGhhdCBpcyBhIHByb2JsZW0sIGdvdHRhIFwic2ltdWxhdGUgdGhlIG91dFwiXG4gICAgICAgIGV2ZW50QnVzLmZpcmUoJ2VsZW1lbnQub3V0Jywge1xuICAgICAgICAgIGVsZW1lbnQ6IGhvdmVyLFxuICAgICAgICAgIGdmeDogaG92ZXJHZnhcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm91dCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAvLyAoMikgdW5zZXQgaG92ZXIgc3RhdGUgaWYgd2UgY29ycmVjdGx5IG91dGVkIHVzICpHRypcbiAgICAgIGhvdmVyR2Z4ID0gbnVsbDtcbiAgICAgIGhvdmVyID0gbnVsbDtcbiAgICB9KTtcblxuICB9KSgpO1xuXG4gIHRoaXMuX2ZpbmRUYXJnZXRHZnggPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBwb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0O1xuXG4gICAgaWYgKCEoZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBvc2l0aW9uID0gdG9Qb2ludChldmVudCk7XG5cbiAgICAvLyBkYW1uIGV4cGVuc2l2ZSBvcGVyYXRpb24sIG91Y2ghXG4gICAgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcblxuICAgIHJldHVybiBnZXRHZngodGFyZ2V0KTtcbiAgfTtcblxufVxuXG5Ib3ZlckZpeC4kaW5qZWN0ID0gW1xuICAnZWxlbWVudFJlZ2lzdHJ5JyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ2luamVjdG9yJ1xuXTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBnZXRHZngodGFyZ2V0KSB7XG4gIHJldHVybiBkb21DbG9zZXN0KHRhcmdldCwgJ3N2ZywgLmRqcy1lbGVtZW50JywgdHJ1ZSk7XG59IiwiaW1wb3J0IEhvdmVyRml4IGZyb20gJy4vSG92ZXJGaXgnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbXG4gICAgJ2hvdmVyRml4J1xuICBdLFxuICBob3ZlckZpeDogWyAndHlwZScsIEhvdmVyRml4IF0sXG59OyIsImltcG9ydCB7XG4gIGZvckVhY2gsXG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGRlbGVnYXRlIGFzIGRvbURlbGVnYXRlLFxuICBxdWVyeSBhcyBkb21RdWVyeSxcbiAgcXVlcnlBbGwgYXMgZG9tUXVlcnlBbGxcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIGlzUHJpbWFyeUJ1dHRvbixcbiAgaXNBdXhpbGlhcnlCdXR0b25cbn0gZnJvbSAnLi4vLi4vdXRpbC9Nb3VzZSc7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZSxcbiAgcmVtb3ZlIGFzIHN2Z1JlbW92ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZUxpbmUsXG4gIHVwZGF0ZUxpbmVcbn0gZnJvbSAnLi4vLi4vdXRpbC9SZW5kZXJVdGlsJztcblxuZnVuY3Rpb24gYWxsb3dBbGwoZXZlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuZnVuY3Rpb24gYWxsb3dQcmltYXJ5QW5kQXV4aWxpYXJ5KGV2ZW50KSB7XG4gIHJldHVybiBpc1ByaW1hcnlCdXR0b24oZXZlbnQpIHx8IGlzQXV4aWxpYXJ5QnV0dG9uKGV2ZW50KTtcbn1cblxudmFyIExPV19QUklPUklUWSA9IDUwMDtcblxuXG4vKipcbiAqIEEgcGx1Z2luIHRoYXQgcHJvdmlkZXMgaW50ZXJhY3Rpb24gZXZlbnRzIGZvciBkaWFncmFtIGVsZW1lbnRzLlxuICpcbiAqIEl0IGVtaXRzIHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxuICpcbiAqICAgKiBlbGVtZW50LmNsaWNrXG4gKiAgICogZWxlbWVudC5jb250ZXh0bWVudVxuICogICAqIGVsZW1lbnQuZGJsY2xpY2tcbiAqICAgKiBlbGVtZW50LmhvdmVyXG4gKiAgICogZWxlbWVudC5tb3VzZWRvd25cbiAqICAgKiBlbGVtZW50Lm1vdXNlbW92ZVxuICogICAqIGVsZW1lbnQubW91c2V1cFxuICogICAqIGVsZW1lbnQub3V0XG4gKlxuICogRWFjaCBldmVudCBpcyBhIHR1cGxlIHsgZWxlbWVudCwgZ2Z4LCBvcmlnaW5hbEV2ZW50IH0uXG4gKlxuICogQ2FuY2VsaW5nIHRoZSBldmVudCB2aWEgRXZlbnQjcHJldmVudERlZmF1bHQoKVxuICogcHJldmVudHMgdGhlIG9yaWdpbmFsIERPTSBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSW50ZXJhY3Rpb25FdmVudHMoZXZlbnRCdXMsIGVsZW1lbnRSZWdpc3RyeSwgc3R5bGVzKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8qKlxuICAgKiBGaXJlIGFuIGludGVyYWN0aW9uIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBsb2NhbCBldmVudCBuYW1lLCBlLmcuIGVsZW1lbnQuY2xpY2suXG4gICAqIEBwYXJhbSB7RE9NRXZlbnR9IGV2ZW50IG5hdGl2ZSBldmVudFxuICAgKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBbZWxlbWVudF0gdGhlIGRpYWdyYW0gZWxlbWVudCB0byBlbWl0IHRoZSBldmVudCBvbjtcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzIHRvIHRoZSBldmVudCB0YXJnZXRcbiAgICovXG4gIGZ1bmN0aW9uIGZpcmUodHlwZSwgZXZlbnQsIGVsZW1lbnQpIHtcblxuICAgIGlmIChpc0lnbm9yZWQodHlwZSwgZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCwgZ2Z4LCByZXR1cm5WYWx1ZTtcblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgdGFyZ2V0ID0gZXZlbnQuZGVsZWdhdGVUYXJnZXQgfHwgZXZlbnQudGFyZ2V0O1xuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGdmeCA9IHRhcmdldDtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRSZWdpc3RyeS5nZXQoZ2Z4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2Z4ID0gZWxlbWVudFJlZ2lzdHJ5LmdldEdyYXBoaWNzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmICghZ2Z4IHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuVmFsdWUgPSBldmVudEJ1cy5maXJlKHR5cGUsIHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBnZng6IGdmeCxcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG5cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETyhuaWtrdSk6IGRvY3VtZW50IHRoaXNcbiAgdmFyIGhhbmRsZXJzID0ge307XG5cbiAgZnVuY3Rpb24gbW91c2VIYW5kbGVyKGxvY2FsRXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIGhhbmRsZXJzW2xvY2FsRXZlbnROYW1lXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSWdub3JlZChsb2NhbEV2ZW50TmFtZSwgZXZlbnQpIHtcblxuICAgIHZhciBmaWx0ZXIgPSBpZ25vcmVkRmlsdGVyc1tsb2NhbEV2ZW50TmFtZV0gfHwgaXNQcmltYXJ5QnV0dG9uO1xuXG4gICAgLy8gb25seSByZWFjdCBvbiBsZWZ0IG1vdXNlIGJ1dHRvbiBpbnRlcmFjdGlvbnNcbiAgICAvLyBleGNlcHQgZm9yIGludGVyYWN0aW9uIGV2ZW50cyB0aGF0IGFyZSBlbmFibGVkXG4gICAgLy8gZm9yIHNlY3VuZGFyeSBtb3VzZSBidXR0b25cbiAgICByZXR1cm4gIWZpbHRlcihldmVudCk7XG4gIH1cblxuICB2YXIgYmluZGluZ3MgPSB7XG4gICAgY2xpY2s6ICdlbGVtZW50LmNsaWNrJyxcbiAgICBjb250ZXh0bWVudTogJ2VsZW1lbnQuY29udGV4dG1lbnUnLFxuICAgIGRibGNsaWNrOiAnZWxlbWVudC5kYmxjbGljaycsXG4gICAgbW91c2Vkb3duOiAnZWxlbWVudC5tb3VzZWRvd24nLFxuICAgIG1vdXNlbW92ZTogJ2VsZW1lbnQubW91c2Vtb3ZlJyxcbiAgICBtb3VzZW92ZXI6ICdlbGVtZW50LmhvdmVyJyxcbiAgICBtb3VzZW91dDogJ2VsZW1lbnQub3V0JyxcbiAgICBtb3VzZXVwOiAnZWxlbWVudC5tb3VzZXVwJyxcbiAgfTtcblxuICB2YXIgaWdub3JlZEZpbHRlcnMgPSB7XG4gICAgJ2VsZW1lbnQuY29udGV4dG1lbnUnOiBhbGxvd0FsbCxcbiAgICAnZWxlbWVudC5tb3VzZWRvd24nOiBhbGxvd1ByaW1hcnlBbmRBdXhpbGlhcnksXG4gICAgJ2VsZW1lbnQubW91c2V1cCc6IGFsbG93UHJpbWFyeUFuZEF1eGlsaWFyeSxcbiAgICAnZWxlbWVudC5jbGljayc6IGFsbG93UHJpbWFyeUFuZEF1eGlsaWFyeSxcbiAgICAnZWxlbWVudC5kYmxjbGljayc6IGFsbG93UHJpbWFyeUFuZEF1eGlsaWFyeVxuICB9O1xuXG5cbiAgLy8gbWFudWFsIGV2ZW50IHRyaWdnZXIgLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFuIGludGVyYWN0aW9uIGV2ZW50IChiYXNlZCBvbiBhIG5hdGl2ZSBkb20gZXZlbnQpXG4gICAqIG9uIHRoZSB0YXJnZXQgc2hhcGUgb3IgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSB0aGUgbmFtZSBvZiB0aGUgdHJpZ2dlcmVkIERPTSBldmVudFxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IHRhcmdldEVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHRyaWdnZXJNb3VzZUV2ZW50KGV2ZW50TmFtZSwgZXZlbnQsIHRhcmdldEVsZW1lbnQpIHtcblxuICAgIC8vIGkuZS4gZWxlbWVudC5tb3VzZWRvd24uLi5cbiAgICB2YXIgbG9jYWxFdmVudE5hbWUgPSBiaW5kaW5nc1tldmVudE5hbWVdO1xuXG4gICAgaWYgKCFsb2NhbEV2ZW50TmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bm1hcHBlZCBET00gZXZlbnQgbmFtZSA8JyArIGV2ZW50TmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcmUobG9jYWxFdmVudE5hbWUsIGV2ZW50LCB0YXJnZXRFbGVtZW50KTtcbiAgfVxuXG5cbiAgdmFyIEVMRU1FTlRfU0VMRUNUT1IgPSAnc3ZnLCAuZGpzLWVsZW1lbnQnO1xuXG4gIC8vIGV2ZW50IGhhbmRsaW5nIC8vLy8vLy9cblxuICBmdW5jdGlvbiByZWdpc3RlckV2ZW50KG5vZGUsIGV2ZW50LCBsb2NhbEV2ZW50LCBpZ25vcmVkRmlsdGVyKSB7XG5cbiAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2xvY2FsRXZlbnRdID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGZpcmUobG9jYWxFdmVudCwgZXZlbnQpO1xuICAgIH07XG5cbiAgICBpZiAoaWdub3JlZEZpbHRlcikge1xuICAgICAgaWdub3JlZEZpbHRlcnNbbG9jYWxFdmVudF0gPSBpZ25vcmVkRmlsdGVyO1xuICAgIH1cblxuICAgIGhhbmRsZXIuJGRlbGVnYXRlID0gZG9tRGVsZWdhdGUuYmluZChub2RlLCBFTEVNRU5UX1NFTEVDVE9SLCBldmVudCwgaGFuZGxlcik7XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyRXZlbnQobm9kZSwgZXZlbnQsIGxvY2FsRXZlbnQpIHtcblxuICAgIHZhciBoYW5kbGVyID0gbW91c2VIYW5kbGVyKGxvY2FsRXZlbnQpO1xuXG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9tRGVsZWdhdGUudW5iaW5kKG5vZGUsIGV2ZW50LCBoYW5kbGVyLiRkZWxlZ2F0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3RlckV2ZW50cyhzdmcpIHtcbiAgICBmb3JFYWNoKGJpbmRpbmdzLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgcmVnaXN0ZXJFdmVudChzdmcsIGtleSwgdmFsKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJFdmVudHMoc3ZnKSB7XG4gICAgZm9yRWFjaChiaW5kaW5ncywgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgIHVucmVnaXN0ZXJFdmVudChzdmcsIGtleSwgdmFsKTtcbiAgICB9KTtcbiAgfVxuXG4gIGV2ZW50QnVzLm9uKCdjYW52YXMuZGVzdHJveScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdW5yZWdpc3RlckV2ZW50cyhldmVudC5zdmcpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignY2FudmFzLmluaXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHJlZ2lzdGVyRXZlbnRzKGV2ZW50LnN2Zyk7XG4gIH0pO1xuXG5cbiAgLy8gaGl0IGJveCB1cGRhdGluZyAvLy8vLy8vLy8vLy8vLy8vXG5cbiAgZXZlbnRCdXMub24oWyAnc2hhcGUuYWRkZWQnLCAnY29ubmVjdGlvbi5hZGRlZCcgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQsXG4gICAgICAgIGdmeCA9IGV2ZW50LmdmeDtcblxuICAgIGV2ZW50QnVzLmZpcmUoJ2ludGVyYWN0aW9uRXZlbnRzLmNyZWF0ZUhpdCcsIHsgZWxlbWVudDogZWxlbWVudCwgZ2Z4OiBnZnggfSk7XG4gIH0pO1xuXG4gIC8vIFVwZGF0ZSBkanMtaGl0IG9uIGNoYW5nZS5cbiAgLy8gQSBsb3cgcHJpb3J0aXR5IGlzIG5lY2Vzc2FyeSwgYmVjYXVzZSBkanMtaGl0IG9mIGxhYmVscyBoYXMgdG8gYmUgdXBkYXRlZFxuICAvLyBhZnRlciB0aGUgbGFiZWwgYm91bmRzIGhhdmUgYmVlbiB1cGRhdGVkIGluIHRoZSByZW5kZXJlci5cbiAgZXZlbnRCdXMub24oW1xuICAgICdzaGFwZS5jaGFuZ2VkJyxcbiAgICAnY29ubmVjdGlvbi5jaGFuZ2VkJ1xuICBdLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQsXG4gICAgICAgIGdmeCA9IGV2ZW50LmdmeDtcblxuICAgIGV2ZW50QnVzLmZpcmUoJ2ludGVyYWN0aW9uRXZlbnRzLnVwZGF0ZUhpdCcsIHsgZWxlbWVudDogZWxlbWVudCwgZ2Z4OiBnZnggfSk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdpbnRlcmFjdGlvbkV2ZW50cy5jcmVhdGVIaXQnLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC5lbGVtZW50LFxuICAgICAgICBnZnggPSBldmVudC5nZng7XG5cbiAgICBzZWxmLmNyZWF0ZURlZmF1bHRIaXQoZWxlbWVudCwgZ2Z4KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2ludGVyYWN0aW9uRXZlbnRzLnVwZGF0ZUhpdCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC5lbGVtZW50LFxuICAgICAgICBnZnggPSBldmVudC5nZng7XG5cbiAgICBzZWxmLnVwZGF0ZURlZmF1bHRIaXQoZWxlbWVudCwgZ2Z4KTtcbiAgfSk7XG5cblxuICAvLyBoaXQgc3R5bGVzIC8vLy8vLy8vLy8vL1xuXG4gIHZhciBTVFJPS0VfSElUX1NUWUxFID0gY3JlYXRlSGl0U3R5bGUoJ2Rqcy1oaXQgZGpzLWhpdC1zdHJva2UnKTtcblxuICB2YXIgQ0xJQ0tfU1RST0tFX0hJVF9TVFlMRSA9IGNyZWF0ZUhpdFN0eWxlKCdkanMtaGl0IGRqcy1oaXQtY2xpY2stc3Ryb2tlJyk7XG5cbiAgdmFyIEFMTF9ISVRfU1RZTEUgPSBjcmVhdGVIaXRTdHlsZSgnZGpzLWhpdCBkanMtaGl0LWFsbCcpO1xuXG4gIHZhciBISVRfVFlQRVMgPSB7XG4gICAgJ2FsbCc6IEFMTF9ISVRfU1RZTEUsXG4gICAgJ2NsaWNrLXN0cm9rZSc6IENMSUNLX1NUUk9LRV9ISVRfU1RZTEUsXG4gICAgJ3N0cm9rZSc6IFNUUk9LRV9ISVRfU1RZTEVcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVIaXRTdHlsZShjbGFzc05hbWVzLCBhdHRycykge1xuXG4gICAgYXR0cnMgPSBhc3NpZ24oe1xuICAgICAgc3Ryb2tlOiAnd2hpdGUnLFxuICAgICAgc3Ryb2tlV2lkdGg6IDE1XG4gICAgfSwgYXR0cnMgfHwge30pO1xuXG4gICAgcmV0dXJuIHN0eWxlcy5jbHMoY2xhc3NOYW1lcywgWyAnbm8tZmlsbCcsICduby1ib3JkZXInIF0sIGF0dHJzKTtcbiAgfVxuXG5cbiAgLy8gc3R5bGUgaGVscGVycyAvLy8vLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiBhcHBseVN0eWxlKGhpdCwgdHlwZSkge1xuXG4gICAgdmFyIGF0dHJzID0gSElUX1RZUEVTW3R5cGVdO1xuXG4gICAgaWYgKCFhdHRycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGhpdCB0eXBlIDwnICsgdHlwZSArICc+Jyk7XG4gICAgfVxuXG4gICAgc3ZnQXR0cihoaXQsIGF0dHJzKTtcblxuICAgIHJldHVybiBoaXQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRIaXQoZ2Z4LCBoaXQpIHtcbiAgICBzdmdBcHBlbmQoZ2Z4LCBoaXQpO1xuICB9XG5cblxuICAvLyBBUElcblxuICAvKipcbiAgICogUmVtb3ZlIGhpbnRzIG9uIHRoZSBnaXZlbiBncmFwaGljcy5cbiAgICpcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBnZnhcbiAgICovXG4gIHRoaXMucmVtb3ZlSGl0cyA9IGZ1bmN0aW9uKGdmeCkge1xuICAgIHZhciBoaXRzID0gZG9tUXVlcnlBbGwoJy5kanMtaGl0JywgZ2Z4KTtcblxuICAgIGZvckVhY2goaGl0cywgc3ZnUmVtb3ZlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGRlZmF1bHQgaGl0IGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fSBjcmVhdGVkIGhpdFxuICAgKi9cbiAgdGhpcy5jcmVhdGVEZWZhdWx0SGl0ID0gZnVuY3Rpb24oZWxlbWVudCwgZ2Z4KSB7XG4gICAgdmFyIHdheXBvaW50cyA9IGVsZW1lbnQud2F5cG9pbnRzLFxuICAgICAgICBpc0ZyYW1lID0gZWxlbWVudC5pc0ZyYW1lLFxuICAgICAgICBib3hUeXBlO1xuXG4gICAgaWYgKHdheXBvaW50cykge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlV2F5cG9pbnRzSGl0KGdmeCwgd2F5cG9pbnRzKTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICBib3hUeXBlID0gaXNGcmFtZSA/ICdzdHJva2UnIDogJ2FsbCc7XG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUJveEhpdChnZngsIGJveFR5cGUsIHtcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGhpdHMgZm9yIHRoZSBnaXZlbiB3YXlwb2ludHMuXG4gICAqXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ2Z4XG4gICAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSB3YXlwb2ludHNcbiAgICpcbiAgICogQHJldHVybiB7U1ZHRWxlbWVudH1cbiAgICovXG4gIHRoaXMuY3JlYXRlV2F5cG9pbnRzSGl0ID0gZnVuY3Rpb24oZ2Z4LCB3YXlwb2ludHMpIHtcblxuICAgIHZhciBoaXQgPSBjcmVhdGVMaW5lKHdheXBvaW50cyk7XG5cbiAgICBhcHBseVN0eWxlKGhpdCwgJ3N0cm9rZScpO1xuXG4gICAgYXBwZW5kSGl0KGdmeCwgaGl0KTtcblxuICAgIHJldHVybiBoaXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBoaXRzIGZvciBhIGJveC5cbiAgICpcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBnZnhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhpdFR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXG4gICAqXG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9XG4gICAqL1xuICB0aGlzLmNyZWF0ZUJveEhpdCA9IGZ1bmN0aW9uKGdmeCwgdHlwZSwgYXR0cnMpIHtcblxuICAgIGF0dHJzID0gYXNzaWduKHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSwgYXR0cnMpO1xuXG4gICAgdmFyIGhpdCA9IHN2Z0NyZWF0ZSgncmVjdCcpO1xuXG4gICAgYXBwbHlTdHlsZShoaXQsIHR5cGUpO1xuXG4gICAgc3ZnQXR0cihoaXQsIGF0dHJzKTtcblxuICAgIGFwcGVuZEhpdChnZngsIGhpdCk7XG5cbiAgICByZXR1cm4gaGl0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgZGVmYXVsdCBoaXQgb2YgdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gICAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IGdmeFxuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fSB1cGRhdGVkIGhpdFxuICAgKi9cbiAgdGhpcy51cGRhdGVEZWZhdWx0SGl0ID0gZnVuY3Rpb24oZWxlbWVudCwgZ2Z4KSB7XG5cbiAgICB2YXIgaGl0ID0gZG9tUXVlcnkoJy5kanMtaGl0JywgZ2Z4KTtcblxuICAgIGlmICghaGl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgICB1cGRhdGVMaW5lKGhpdCwgZWxlbWVudC53YXlwb2ludHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdmdBdHRyKGhpdCwge1xuICAgICAgICB3aWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhpdDtcbiAgfTtcblxuICB0aGlzLmZpcmUgPSBmaXJlO1xuXG4gIHRoaXMudHJpZ2dlck1vdXNlRXZlbnQgPSB0cmlnZ2VyTW91c2VFdmVudDtcblxuICB0aGlzLm1vdXNlSGFuZGxlciA9IG1vdXNlSGFuZGxlcjtcblxuICB0aGlzLnJlZ2lzdGVyRXZlbnQgPSByZWdpc3RlckV2ZW50O1xuICB0aGlzLnVucmVnaXN0ZXJFdmVudCA9IHVucmVnaXN0ZXJFdmVudDtcbn1cblxuXG5JbnRlcmFjdGlvbkV2ZW50cy4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnZWxlbWVudFJlZ2lzdHJ5JyxcbiAgJ3N0eWxlcydcbl07XG5cblxuLyoqXG4gKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgdGhlIG1vdXNlIGhvdmVyZWQgb3ZlciBhbiBlbGVtZW50XG4gKlxuICogQGV2ZW50IGVsZW1lbnQuaG92ZXJcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnhcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnRcbiAqL1xuXG4vKipcbiAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgbW91c2UgaGFzIGxlZnQgYW4gZWxlbWVudFxuICpcbiAqIEBldmVudCBlbGVtZW50Lm91dFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IGdmeFxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudFxuICovXG5cbi8qKlxuICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IHRoZSBtb3VzZSBoYXMgY2xpY2tlZCBhbiBlbGVtZW50XG4gKlxuICogQGV2ZW50IGVsZW1lbnQuY2xpY2tcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnhcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnRcbiAqL1xuXG4vKipcbiAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgbW91c2UgaGFzIGRvdWJsZSBjbGlja2VkIGFuIGVsZW1lbnRcbiAqXG4gKiBAZXZlbnQgZWxlbWVudC5kYmxjbGlja1xuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IGdmeFxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudFxuICovXG5cbi8qKlxuICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IHRoZSBtb3VzZSBoYXMgZ29uZSBkb3duIG9uIGFuIGVsZW1lbnQuXG4gKlxuICogQGV2ZW50IGVsZW1lbnQubW91c2Vkb3duXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gZ2Z4XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50XG4gKi9cblxuLyoqXG4gKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgdGhlIG1vdXNlIGhhcyBnb25lIHVwIG9uIGFuIGVsZW1lbnQuXG4gKlxuICogQGV2ZW50IGVsZW1lbnQubW91c2V1cFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge2Rqcy5tb2RlbC5CYXNlfSBlbGVtZW50XG4gKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IGdmeFxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudFxuICovXG5cbi8qKlxuICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IHRoZSBjb250ZXh0IG1lbnUgYWN0aW9uIGlzIHRyaWdnZXJlZFxuICogdmlhIG1vdXNlIG9yIHRvdWNoIGNvbnRyb2xzLlxuICpcbiAqIEBldmVudCBlbGVtZW50LmNvbnRleHRtZW51XG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gZ2Z4XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50XG4gKi8iLCJpbXBvcnQgSW50ZXJhY3Rpb25FdmVudHMgZnJvbSAnLi9JbnRlcmFjdGlvbkV2ZW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ2ludGVyYWN0aW9uRXZlbnRzJyBdLFxuICBpbnRlcmFjdGlvbkV2ZW50czogWyAndHlwZScsIEludGVyYWN0aW9uRXZlbnRzIF1cbn07IiwiaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuXG52YXIgREVGQVVMVF9DT05GSUcgPSB7XG4gIG1vdmVTcGVlZDogMSxcbiAgbW92ZVNwZWVkQWNjZWxlcmF0ZWQ6IDEwXG59O1xuXG52YXIgSElHSEVSX1BSSU9SSVRZID0gMTUwMDtcblxudmFyIExFRlQgPSAnbGVmdCc7XG52YXIgVVAgPSAndXAnO1xudmFyIFJJR0hUID0gJ3JpZ2h0JztcbnZhciBET1dOID0gJ2Rvd24nO1xuXG52YXIgS0VZX1RPX0RJUkVDVElPTiA9IHtcbiAgQXJyb3dMZWZ0OiBMRUZULFxuICBMZWZ0OiBMRUZULFxuICBBcnJvd1VwOiBVUCxcbiAgVXA6IFVQLFxuICBBcnJvd1JpZ2h0OiBSSUdIVCxcbiAgUmlnaHQ6IFJJR0hULFxuICBBcnJvd0Rvd246IERPV04sXG4gIERvd246IERPV05cbn07XG5cbnZhciBESVJFQ1RJT05TX0RFTFRBID0ge1xuICBsZWZ0OiBmdW5jdGlvbihzcGVlZCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAtc3BlZWQsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfSxcbiAgdXA6IGZ1bmN0aW9uKHNwZWVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAtc3BlZWRcbiAgICB9O1xuICB9LFxuICByaWdodDogZnVuY3Rpb24oc3BlZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogc3BlZWQsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfSxcbiAgZG93bjogZnVuY3Rpb24oc3BlZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IHNwZWVkXG4gICAgfTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEVuYWJsZXMgdG8gbW92ZSBzZWxlY3Rpb24gd2l0aCBrZXlib2FyZCBhcnJvd3MuXG4gKiBVc2Ugd2l0aCBTaGlmdCBmb3IgbW9kaWZpZWQgc3BlZWQgKGRlZmF1bHQ9MSwgd2l0aCBTaGlmdD0xMCkuXG4gKiBQcmVzc2VkIENtZC9DdHJsIHR1cm5zIHRoZSBmZWF0dXJlIG9mZi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tb3ZlU3BlZWQ9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1vdmVTcGVlZEFjY2VsZXJhdGVkPTEwXVxuICogQHBhcmFtIHtLZXlib2FyZH0ga2V5Ym9hcmRcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsZWN0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEtleWJvYXJkTW92ZVNlbGVjdGlvbihcbiAgICBjb25maWcsXG4gICAga2V5Ym9hcmQsXG4gICAgbW9kZWxpbmcsXG4gICAgcnVsZXMsXG4gICAgc2VsZWN0aW9uXG4pIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5fY29uZmlnID0gYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJRywgY29uZmlnIHx8IHt9KTtcblxuICBrZXlib2FyZC5hZGRMaXN0ZW5lcihISUdIRVJfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIga2V5RXZlbnQgPSBldmVudC5rZXlFdmVudDtcblxuICAgIHZhciBkaXJlY3Rpb24gPSBLRVlfVE9fRElSRUNUSU9OW2tleUV2ZW50LmtleV07XG5cbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXlib2FyZC5pc0NtZChrZXlFdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYWNjZWxlcmF0ZWQgPSBrZXlib2FyZC5pc1NoaWZ0KGtleUV2ZW50KTtcblxuICAgIHNlbGYubW92ZVNlbGVjdGlvbihkaXJlY3Rpb24sIGFjY2VsZXJhdGVkKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuXG4gIC8qKlxuICAgKiBNb3ZlIHNlbGVjdGVkIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24sXG4gICAqIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBhY2NlbGVyYXRlZCBtb3ZlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthY2NlbGVyYXRlZD1mYWxzZV1cbiAgICovXG4gIHRoaXMubW92ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgYWNjZWxlcmF0ZWQpIHtcblxuICAgIHZhciBzZWxlY3RlZEVsZW1lbnRzID0gc2VsZWN0aW9uLmdldCgpO1xuXG4gICAgaWYgKCFzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzcGVlZCA9IHRoaXMuX2NvbmZpZ1tcbiAgICAgIGFjY2VsZXJhdGVkID9cbiAgICAgICAgJ21vdmVTcGVlZEFjY2VsZXJhdGVkJyA6XG4gICAgICAgICdtb3ZlU3BlZWQnXG4gICAgXTtcblxuICAgIHZhciBkZWx0YSA9IERJUkVDVElPTlNfREVMVEFbZGlyZWN0aW9uXShzcGVlZCk7XG5cbiAgICB2YXIgY2FuTW92ZSA9IHJ1bGVzLmFsbG93ZWQoJ2VsZW1lbnRzLm1vdmUnLCB7XG4gICAgICBzaGFwZXM6IHNlbGVjdGVkRWxlbWVudHNcbiAgICB9KTtcblxuICAgIGlmIChjYW5Nb3ZlKSB7XG4gICAgICBtb2RlbGluZy5tb3ZlRWxlbWVudHMoc2VsZWN0ZWRFbGVtZW50cywgZGVsdGEpO1xuICAgIH1cbiAgfTtcblxufVxuXG5LZXlib2FyZE1vdmVTZWxlY3Rpb24uJGluamVjdCA9IFtcbiAgJ2NvbmZpZy5rZXlib2FyZE1vdmVTZWxlY3Rpb24nLFxuICAna2V5Ym9hcmQnLFxuICAnbW9kZWxpbmcnLFxuICAncnVsZXMnLFxuICAnc2VsZWN0aW9uJ1xuXTsiLCJpbXBvcnQgS2V5Ym9hcmRNb2R1bGUgZnJvbSAnLi4va2V5Ym9hcmQnO1xuaW1wb3J0IFNlbGVjdGlvbk1vZHVsZSBmcm9tICcuLi9zZWxlY3Rpb24nO1xuXG5pbXBvcnQgS2V5Ym9hcmRNb3ZlU2VsZWN0aW9uIGZyb20gJy4vS2V5Ym9hcmRNb3ZlU2VsZWN0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIEtleWJvYXJkTW9kdWxlLFxuICAgIFNlbGVjdGlvbk1vZHVsZVxuICBdLFxuICBfX2luaXRfXzogW1xuICAgICdrZXlib2FyZE1vdmVTZWxlY3Rpb24nXG4gIF0sXG4gIGtleWJvYXJkTW92ZVNlbGVjdGlvbjogWyAndHlwZScsIEtleWJvYXJkTW92ZVNlbGVjdGlvbiBdXG59O1xuIiwiaW1wb3J0IHtcbiAgaXNGdW5jdGlvblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGV2ZW50IGFzIGRvbUV2ZW50LFxuICBtYXRjaGVzIGFzIGRvbU1hdGNoZXNcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCB7XG4gIGhhc01vZGlmaWVyLFxuICBpc0NtZCxcbiAgaXNLZXksXG4gIGlzU2hpZnRcbn0gZnJvbSAnLi9LZXlib2FyZFV0aWwnO1xuXG52YXIgS0VZRE9XTl9FVkVOVCA9ICdrZXlib2FyZC5rZXlkb3duJyxcbiAgICBLRVlVUF9FVkVOVCA9ICdrZXlib2FyZC5rZXl1cCc7XG5cbnZhciBERUZBVUxUX1BSSU9SSVRZID0gMTAwMDtcblxuXG4vKipcbiAqIEEga2V5Ym9hcmQgYWJzdHJhY3Rpb24gdGhhdCBtYXkgYmUgYWN0aXZhdGVkIGFuZFxuICogZGVhY3RpdmF0ZWQgYnkgdXNlcnMgYXQgd2lsbCwgY29uc3VtaW5nIGtleSBldmVudHNcbiAqIGFuZCB0cmlnZ2VyaW5nIGRpYWdyYW0gYWN0aW9ucy5cbiAqXG4gKiBGb3Iga2V5cyBwcmVzc2VkIGRvd24sIGtleWJvYXJkIGZpcmVzIGBrZXlib2FyZC5rZXlkb3duYCBldmVudC5cbiAqIFRoZSBldmVudCBjb250ZXh0IGNvbnRhaW5zIG9uZSBmaWVsZCB3aGljaCBpcyBgS2V5Ym9hcmRFdmVudGAgZXZlbnQuXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIGZpcmVzIHRoZSBmb2xsb3dpbmcga2V5IGV2ZW50cyB0aGF0IGFsbG93XG4gKiBvdGhlciBjb21wb25lbnRzIHRvIGhvb2sgaW50byBrZXkgaGFuZGxpbmc6XG4gKlxuICogIC0ga2V5Ym9hcmQuYmluZFxuICogIC0ga2V5Ym9hcmQudW5iaW5kXG4gKiAgLSBrZXlib2FyZC5pbml0XG4gKiAgLSBrZXlib2FyZC5kZXN0cm95XG4gKlxuICogQWxsIGV2ZW50cyBjb250YWluIG9uZSBmaWVsZCB3aGljaCBpcyBub2RlLlxuICpcbiAqIEEgZGVmYXVsdCBiaW5kaW5nIGZvciB0aGUga2V5Ym9hcmQgbWF5IGJlIHNwZWNpZmllZCB2aWEgdGhlXG4gKiBga2V5Ym9hcmQuYmluZFRvYCBjb25maWd1cmF0aW9uIG9wdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0NvbmZpZ30gY29uZmlnXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBLZXlib2FyZChjb25maWcsIGV2ZW50QnVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLl9jb25maWcgPSBjb25maWcgfHwge307XG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG5cbiAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9rZXlkb3duSGFuZGxlci5iaW5kKHRoaXMpO1xuICB0aGlzLl9rZXl1cEhhbmRsZXIgPSB0aGlzLl9rZXl1cEhhbmRsZXIuYmluZCh0aGlzKTtcblxuICAvLyBwcm9wZXJseSBjbGVhbiBkb20gcmVnaXN0cmF0aW9uc1xuICBldmVudEJ1cy5vbignZGlhZ3JhbS5kZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fZmlyZSgnZGVzdHJveScpO1xuXG4gICAgc2VsZi51bmJpbmQoKTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2RpYWdyYW0uaW5pdCcsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2ZpcmUoJ2luaXQnKTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2F0dGFjaCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmJpbmRUbykge1xuICAgICAgc2VsZi5iaW5kKGNvbmZpZy5iaW5kVG8pO1xuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2RldGFjaCcsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYudW5iaW5kKCk7XG4gIH0pO1xufVxuXG5LZXlib2FyZC4kaW5qZWN0ID0gW1xuICAnY29uZmlnLmtleWJvYXJkJyxcbiAgJ2V2ZW50QnVzJ1xuXTtcblxuS2V5Ym9hcmQucHJvdG90eXBlLl9rZXlkb3duSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHRoaXMuX2tleUhhbmRsZXIoZXZlbnQsIEtFWURPV05fRVZFTlQpO1xufTtcblxuS2V5Ym9hcmQucHJvdG90eXBlLl9rZXl1cEhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICB0aGlzLl9rZXlIYW5kbGVyKGV2ZW50LCBLRVlVUF9FVkVOVCk7XG59O1xuXG5LZXlib2FyZC5wcm90b3R5cGUuX2tleUhhbmRsZXIgPSBmdW5jdGlvbihldmVudCwgdHlwZSkge1xuICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0LFxuICAgICAgZXZlbnRCdXNSZXN1bHQ7XG5cbiAgaWYgKGlzSW5wdXQodGFyZ2V0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGtleUV2ZW50OiBldmVudFxuICB9O1xuXG4gIGV2ZW50QnVzUmVzdWx0ID0gdGhpcy5fZXZlbnRCdXMuZmlyZSh0eXBlIHx8IEtFWURPV05fRVZFTlQsIGNvbnRleHQpO1xuXG4gIGlmIChldmVudEJ1c1Jlc3VsdCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn07XG5cbktleWJvYXJkLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24obm9kZSkge1xuXG4gIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBrZXlib2FyZCBpcyBvbmx5IGJvdW5kIG9uY2UgdG8gdGhlIERPTVxuICB0aGlzLnVuYmluZCgpO1xuXG4gIHRoaXMuX25vZGUgPSBub2RlO1xuXG4gIC8vIGJpbmQga2V5IGV2ZW50c1xuICBkb21FdmVudC5iaW5kKG5vZGUsICdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkhhbmRsZXIsIHRydWUpO1xuICBkb21FdmVudC5iaW5kKG5vZGUsICdrZXl1cCcsIHRoaXMuX2tleXVwSGFuZGxlciwgdHJ1ZSk7XG5cbiAgdGhpcy5fZmlyZSgnYmluZCcpO1xufTtcblxuS2V5Ym9hcmQucHJvdG90eXBlLmdldEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGU7XG59O1xuXG5LZXlib2FyZC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5fbm9kZTtcblxuICBpZiAobm9kZSkge1xuICAgIHRoaXMuX2ZpcmUoJ3VuYmluZCcpO1xuXG4gICAgLy8gdW5iaW5kIGtleSBldmVudHNcbiAgICBkb21FdmVudC51bmJpbmQobm9kZSwgJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duSGFuZGxlciwgdHJ1ZSk7XG4gICAgZG9tRXZlbnQudW5iaW5kKG5vZGUsICdrZXl1cCcsIHRoaXMuX2tleXVwSGFuZGxlciwgdHJ1ZSk7XG4gIH1cblxuICB0aGlzLl9ub2RlID0gbnVsbDtcbn07XG5cbktleWJvYXJkLnByb3RvdHlwZS5fZmlyZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2tleWJvYXJkLicgKyBldmVudCwgeyBub2RlOiB0aGlzLl9ub2RlIH0pO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvbiB0aGF0IGlzIG5vdGlmaWVkIHdpdGggYEtleWJvYXJkRXZlbnRgIHdoZW5ldmVyXG4gKiB0aGUga2V5Ym9hcmQgaXMgYm91bmQgYW5kIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkuIElmIG5vIHByaW9yaXR5IGlzXG4gKiBwcm92aWRlZCwgdGhlIGRlZmF1bHQgdmFsdWUgb2YgMTAwMCBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHldXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqL1xuS2V5Ym9hcmQucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24ocHJpb3JpdHksIGxpc3RlbmVyLCB0eXBlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHByaW9yaXR5KSkge1xuICAgIHR5cGUgPSBsaXN0ZW5lcjtcbiAgICBsaXN0ZW5lciA9IHByaW9yaXR5O1xuICAgIHByaW9yaXR5ID0gREVGQVVMVF9QUklPUklUWTtcbiAgfVxuXG4gIHRoaXMuX2V2ZW50QnVzLm9uKHR5cGUgfHwgS0VZRE9XTl9FVkVOVCwgcHJpb3JpdHksIGxpc3RlbmVyKTtcbn07XG5cbktleWJvYXJkLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyLCB0eXBlKSB7XG4gIHRoaXMuX2V2ZW50QnVzLm9mZih0eXBlIHx8IEtFWURPV05fRVZFTlQsIGxpc3RlbmVyKTtcbn07XG5cbktleWJvYXJkLnByb3RvdHlwZS5oYXNNb2RpZmllciA9IGhhc01vZGlmaWVyO1xuS2V5Ym9hcmQucHJvdG90eXBlLmlzQ21kID0gaXNDbWQ7XG5LZXlib2FyZC5wcm90b3R5cGUuaXNTaGlmdCA9IGlzU2hpZnQ7XG5LZXlib2FyZC5wcm90b3R5cGUuaXNLZXkgPSBpc0tleTtcblxuXG5cbi8vIGhlbHBlcnMgLy8vLy8vL1xuXG5mdW5jdGlvbiBpc0lucHV0KHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0ICYmIChkb21NYXRjaGVzKHRhcmdldCwgJ2lucHV0LCB0ZXh0YXJlYScpIHx8IHRhcmdldC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG59XG4iLCJpbXBvcnQge1xuICBpc0NtZCxcbiAgaXNLZXksXG4gIGlzU2hpZnRcbn0gZnJvbSAnLi9LZXlib2FyZFV0aWwnO1xuXG52YXIgTE9XX1BSSU9SSVRZID0gNTAwO1xuXG5leHBvcnQgdmFyIEtFWUNPREVfQyA9IDY3O1xuZXhwb3J0IHZhciBLRVlDT0RFX1YgPSA4NjtcbmV4cG9ydCB2YXIgS0VZQ09ERV9ZID0gODk7XG5leHBvcnQgdmFyIEtFWUNPREVfWiA9IDkwO1xuXG5leHBvcnQgdmFyIEtFWVNfQ09QWSA9IFsnYycsICdDJywgS0VZQ09ERV9DIF07XG5leHBvcnQgdmFyIEtFWVNfUEFTVEUgPSBbICd2JywgJ1YnLCBLRVlDT0RFX1YgXTtcbmV4cG9ydCB2YXIgS0VZU19SRURPID0gWyAneScsICdZJywgS0VZQ09ERV9ZIF07XG5leHBvcnQgdmFyIEtFWVNfVU5ETyA9IFsgJ3onLCAnWicsIEtFWUNPREVfWiBdO1xuXG5cbi8qKlxuICogQWRkcyBkZWZhdWx0IGtleWJvYXJkIGJpbmRpbmdzLlxuICpcbiAqIFRoaXMgZG9lcyBub3QgcHVsbCBpbiBhbnkgZmVhdHVyZXMgd2lsbCBiaW5kIG9ubHkgYWN0aW9ucyB0aGF0XG4gKiBoYXZlIHByZXZpb3VzbHkgYmVlbiByZWdpc3RlcmVkIGFnYWluc3QgdGhlIGVkaXRvckFjdGlvbnMgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0tleWJvYXJkfSBrZXlib2FyZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBLZXlib2FyZEJpbmRpbmdzKGV2ZW50QnVzLCBrZXlib2FyZCkge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBldmVudEJ1cy5vbignZWRpdG9yQWN0aW9ucy5pbml0JywgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGVkaXRvckFjdGlvbnMgPSBldmVudC5lZGl0b3JBY3Rpb25zO1xuXG4gICAgc2VsZi5yZWdpc3RlckJpbmRpbmdzKGtleWJvYXJkLCBlZGl0b3JBY3Rpb25zKTtcbiAgfSk7XG59XG5cbktleWJvYXJkQmluZGluZ3MuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2tleWJvYXJkJ1xuXTtcblxuXG4vKipcbiAqIFJlZ2lzdGVyIGF2YWlsYWJsZSBrZXlib2FyZCBiaW5kaW5ncy5cbiAqXG4gKiBAcGFyYW0ge0tleWJvYXJkfSBrZXlib2FyZFxuICogQHBhcmFtIHtFZGl0b3JBY3Rpb25zfSBlZGl0b3JBY3Rpb25zXG4gKi9cbktleWJvYXJkQmluZGluZ3MucHJvdG90eXBlLnJlZ2lzdGVyQmluZGluZ3MgPSBmdW5jdGlvbihrZXlib2FyZCwgZWRpdG9yQWN0aW9ucykge1xuXG4gIC8qKlxuICAgKiBBZGQga2V5Ym9hcmQgYmluZGluZyBpZiByZXNwZWN0aXZlIGVkaXRvciBhY3Rpb25cbiAgICogaXMgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRoYXQgaW1wbGVtZW50cyB0aGUga2V5IGJpbmRpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGFjdGlvbiwgZm4pIHtcblxuICAgIGlmIChlZGl0b3JBY3Rpb25zLmlzUmVnaXN0ZXJlZChhY3Rpb24pKSB7XG4gICAgICBrZXlib2FyZC5hZGRMaXN0ZW5lcihmbik7XG4gICAgfVxuICB9XG5cblxuICAvLyB1bmRvXG4gIC8vIChDVFJMfENNRCkgKyBaXG4gIGFkZExpc3RlbmVyKCd1bmRvJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudDtcblxuICAgIGlmIChpc0NtZChldmVudCkgJiYgIWlzU2hpZnQoZXZlbnQpICYmIGlzS2V5KEtFWVNfVU5ETywgZXZlbnQpKSB7XG4gICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ3VuZG8nKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyByZWRvXG4gIC8vIENUUkwgKyBZXG4gIC8vIENNRCArIFNISUZUICsgWlxuICBhZGRMaXN0ZW5lcigncmVkbycsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBldmVudCA9IGNvbnRleHQua2V5RXZlbnQ7XG5cbiAgICBpZiAoaXNDbWQoZXZlbnQpICYmIChpc0tleShLRVlTX1JFRE8sIGV2ZW50KSB8fCAoaXNLZXkoS0VZU19VTkRPLCBldmVudCkgJiYgaXNTaGlmdChldmVudCkpKSkge1xuICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdyZWRvJyk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gY29weVxuICAvLyBDVFJML0NNRCArIENcbiAgYWRkTGlzdGVuZXIoJ2NvcHknLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgaWYgKGlzQ21kKGV2ZW50KSAmJiBpc0tleShLRVlTX0NPUFksIGV2ZW50KSkge1xuICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdjb3B5Jyk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcGFzdGVcbiAgLy8gQ1RSTC9DTUQgKyBWXG4gIGFkZExpc3RlbmVyKCdwYXN0ZScsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBldmVudCA9IGNvbnRleHQua2V5RXZlbnQ7XG5cbiAgICBpZiAoaXNDbWQoZXZlbnQpICYmIGlzS2V5KEtFWVNfUEFTVEUsIGV2ZW50KSkge1xuICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdwYXN0ZScpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHpvb20gaW4gb25lIHN0ZXBcbiAgLy8gQ1RSTC9DTUQgKyArXG4gIGFkZExpc3RlbmVyKCdzdGVwWm9vbScsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgIHZhciBldmVudCA9IGNvbnRleHQua2V5RXZlbnQ7XG5cbiAgICAvLyBxdWlyazogaXQgaGFzIHRvIGJlIHRyaWdnZXJlZCBieSBgPWAgYXMgd2VsbCB0byB3b3JrIG9uIGludGVybmF0aW9uYWwga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gY2Y6IGh0dHBzOi8vZ2l0aHViLmNvbS9icG1uLWlvL2JwbW4tanMvaXNzdWVzLzEzNjIjaXNzdWVjb21tZW50LTcyMjk4OTc1NFxuICAgIGlmIChpc0tleShbICcrJywgJ0FkZCcsICc9JyBdLCBldmVudCkgJiYgaXNDbWQoZXZlbnQpKSB7XG4gICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ3N0ZXBab29tJywgeyB2YWx1ZTogMSB9KTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyB6b29tIG91dCBvbmUgc3RlcFxuICAvLyBDVFJMICsgLVxuICBhZGRMaXN0ZW5lcignc3RlcFpvb20nLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgaWYgKGlzS2V5KFsgJy0nLCAnU3VidHJhY3QnIF0sIGV2ZW50KSAmJiBpc0NtZChldmVudCkpIHtcbiAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcignc3RlcFpvb20nLCB7IHZhbHVlOiAtMSB9KTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyB6b29tIHRvIHRoZSBkZWZhdWx0IGxldmVsXG4gIC8vIENUUkwgKyAwXG4gIGFkZExpc3RlbmVyKCd6b29tJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudDtcblxuICAgIGlmIChpc0tleSgnMCcsIGV2ZW50KSAmJiBpc0NtZChldmVudCkpIHtcbiAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcignem9vbScsIHsgdmFsdWU6IDEgfSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZGVsZXRlIHNlbGVjdGVkIGVsZW1lbnRcbiAgLy8gREVMXG4gIGFkZExpc3RlbmVyKCdyZW1vdmVTZWxlY3Rpb24nLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgaWYgKGlzS2V5KFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnIF0sIGV2ZW50KSkge1xuICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdyZW1vdmVTZWxlY3Rpb24nKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn07IiwiaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ21pbi1kYXNoJztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgZXZlbnQgd2FzIHRyaWdnZXJlZCB3aXRoIGFueSBtb2RpZmllclxyXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzTW9kaWZpZXIoZXZlbnQpIHtcclxuICByZXR1cm4gKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkpO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQ21kKGV2ZW50KSB7XHJcblxyXG4gIC8vIGVuc3VyZSB3ZSBkb24ndCByZWFjdCB0byBBbHRHclxyXG4gIC8vIChtYXBwZWQgdG8gQ1RSTCArIEFMVClcclxuICBpZiAoZXZlbnQuYWx0S2V5KSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGtleSBwcmVzc2VkIGlzIG9uZSBvZiBwcm92aWRlZCBrZXlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBrZXlzXHJcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0tleShrZXlzLCBldmVudCkge1xyXG4gIGtleXMgPSBpc0FycmF5KGtleXMpID8ga2V5cyA6IFsga2V5cyBdO1xyXG5cclxuICByZXR1cm4ga2V5cy5pbmRleE9mKGV2ZW50LmtleSkgIT09IC0xIHx8IGtleXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSAhPT0gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTaGlmdChldmVudCkge1xyXG4gIHJldHVybiBldmVudC5zaGlmdEtleTtcclxufSIsImltcG9ydCBLZXlib2FyZCBmcm9tICcuL0tleWJvYXJkJztcbmltcG9ydCBLZXlib2FyZEJpbmRpbmdzIGZyb20gJy4vS2V5Ym9hcmRCaW5kaW5ncyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ2tleWJvYXJkJywgJ2tleWJvYXJkQmluZGluZ3MnIF0sXG4gIGtleWJvYXJkOiBbICd0eXBlJywgS2V5Ym9hcmQgXSxcbiAga2V5Ym9hcmRCaW5kaW5nczogWyAndHlwZScsIEtleWJvYXJkQmluZGluZ3MgXVxufTtcbiIsImltcG9ydCB7XG4gIGZvckVhY2gsXG4gIGZpbHRlclxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbnZhciBMT1dfUFJJT1JJVFkgPSAyNTAsXG4gICAgSElHSF9QUklPUklUWSA9IDE0MDA7XG5cbmltcG9ydCB7XG4gIGFkZCBhcyBjb2xsZWN0aW9uQWRkLFxuICBpbmRleE9mIGFzIGNvbGxlY3Rpb25JZHhcbn0gZnJvbSAnLi4vLi4vdXRpbC9Db2xsZWN0aW9ucyc7XG5cbmltcG9ydCB7IHNhdmVDbGVhciB9IGZyb20gJy4uLy4uL3V0aWwvUmVtb3ZhbCc7XG5cbmltcG9ydCBDb21tYW5kSW50ZXJjZXB0b3IgZnJvbSAnLi4vLi4vY29tbWFuZC9Db21tYW5kSW50ZXJjZXB0b3InO1xuXG5cbi8qKlxuICogQSBoYW5kbGVyIHRoYXQgbWFrZXMgc3VyZSBsYWJlbHMgYXJlIHByb3Blcmx5IG1vdmVkIHdpdGhcbiAqIHRoZWlyIGxhYmVsIHRhcmdldHMuXG4gKlxuICogQHBhcmFtIHtkaWRpLkluamVjdG9yfSBpbmplY3RvclxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7TW9kZWxpbmd9IG1vZGVsaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExhYmVsU3VwcG9ydChpbmplY3RvciwgZXZlbnRCdXMsIG1vZGVsaW5nKSB7XG5cbiAgQ29tbWFuZEludGVyY2VwdG9yLmNhbGwodGhpcywgZXZlbnRCdXMpO1xuXG4gIHZhciBtb3ZlUHJldmlldyA9IGluamVjdG9yLmdldCgnbW92ZVByZXZpZXcnLCBmYWxzZSk7XG5cbiAgLy8gcmVtb3ZlIGxhYmVscyBmcm9tIHRoZSBjb2xsZWN0aW9uIHRoYXQgYXJlIGJlaW5nXG4gIC8vIG1vdmVkIHdpdGggb3RoZXIgZWxlbWVudHMgYW55d2F5XG4gIGV2ZW50QnVzLm9uKCdzaGFwZS5tb3ZlLnN0YXJ0JywgSElHSF9QUklPUklUWSwgZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBlLmNvbnRleHQsXG4gICAgICAgIHNoYXBlcyA9IGNvbnRleHQuc2hhcGVzLFxuICAgICAgICB2YWxpZGF0ZWRTaGFwZXMgPSBjb250ZXh0LnZhbGlkYXRlZFNoYXBlcztcblxuICAgIGNvbnRleHQuc2hhcGVzID0gcmVtb3ZlTGFiZWxzKHNoYXBlcyk7XG4gICAgY29udGV4dC52YWxpZGF0ZWRTaGFwZXMgPSByZW1vdmVMYWJlbHModmFsaWRhdGVkU2hhcGVzKTtcbiAgfSk7XG5cbiAgLy8gYWRkIGxhYmVscyB0byB2aXN1YWwncyBncm91cFxuICBtb3ZlUHJldmlldyAmJiBldmVudEJ1cy5vbignc2hhcGUubW92ZS5zdGFydCcsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBlLmNvbnRleHQsXG4gICAgICAgIHNoYXBlcyA9IGNvbnRleHQuc2hhcGVzO1xuXG4gICAgdmFyIGxhYmVscyA9IFtdO1xuXG4gICAgZm9yRWFjaChzaGFwZXMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgICAgZm9yRWFjaChlbGVtZW50LmxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcblxuICAgICAgICBpZiAoIWxhYmVsLmhpZGRlbiAmJiBjb250ZXh0LnNoYXBlcy5pbmRleE9mKGxhYmVsKSA9PT0gLTEpIHtcbiAgICAgICAgICBsYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudC5sYWJlbFRhcmdldCkge1xuICAgICAgICAgIGxhYmVscy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZvckVhY2gobGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgbW92ZVByZXZpZXcubWFrZURyYWdnYWJsZShjb250ZXh0LCBsYWJlbCwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgLy8gYWRkIGFsbCBsYWJlbHMgdG8gbW92ZSBjbG9zdXJlXG4gIHRoaXMucHJlRXhlY3V0ZWQoJ2VsZW1lbnRzLm1vdmUnLCBISUdIX1BSSU9SSVRZLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNvbnRleHQgPSBlLmNvbnRleHQsXG4gICAgICAgIGNsb3N1cmUgPSBjb250ZXh0LmNsb3N1cmUsXG4gICAgICAgIGVuY2xvc2VkRWxlbWVudHMgPSBjbG9zdXJlLmVuY2xvc2VkRWxlbWVudHM7XG5cbiAgICB2YXIgZW5jbG9zZWRMYWJlbHMgPSBbXTtcblxuICAgIC8vIGZpbmQgbGFiZWxzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mXG4gICAgLy8gbW92ZSBjbG9zdXJlIHlldCBhbmQgYWRkIHRoZW1cbiAgICBmb3JFYWNoKGVuY2xvc2VkRWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGZvckVhY2goZWxlbWVudC5sYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG5cbiAgICAgICAgaWYgKCFlbmNsb3NlZEVsZW1lbnRzW2xhYmVsLmlkXSkge1xuICAgICAgICAgIGVuY2xvc2VkTGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNsb3N1cmUuYWRkQWxsKGVuY2xvc2VkTGFiZWxzKTtcbiAgfSk7XG5cblxuICB0aGlzLnByZUV4ZWN1dGUoW1xuICAgICdjb25uZWN0aW9uLmRlbGV0ZScsXG4gICAgJ3NoYXBlLmRlbGV0ZSdcbiAgXSwgZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBlLmNvbnRleHQsXG4gICAgICAgIGVsZW1lbnQgPSBjb250ZXh0LmNvbm5lY3Rpb24gfHwgY29udGV4dC5zaGFwZTtcblxuICAgIHNhdmVDbGVhcihlbGVtZW50LmxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgIG1vZGVsaW5nLnJlbW92ZVNoYXBlKGxhYmVsLCB7IG5lc3RlZDogdHJ1ZSB9KTtcbiAgICB9KTtcbiAgfSk7XG5cblxuICB0aGlzLmV4ZWN1dGUoJ3NoYXBlLmRlbGV0ZScsIGZ1bmN0aW9uKGUpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIGxhYmVsVGFyZ2V0ID0gc2hhcGUubGFiZWxUYXJnZXQ7XG5cbiAgICAvLyB1bnNldCBsYWJlbFRhcmdldFxuICAgIGlmIChsYWJlbFRhcmdldCkge1xuICAgICAgY29udGV4dC5sYWJlbFRhcmdldEluZGV4ID0gY29sbGVjdGlvbklkeChsYWJlbFRhcmdldC5sYWJlbHMsIHNoYXBlKTtcbiAgICAgIGNvbnRleHQubGFiZWxUYXJnZXQgPSBsYWJlbFRhcmdldDtcblxuICAgICAgc2hhcGUubGFiZWxUYXJnZXQgPSBudWxsO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5yZXZlcnQoJ3NoYXBlLmRlbGV0ZScsIGZ1bmN0aW9uKGUpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZS5jb250ZXh0LFxuICAgICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIGxhYmVsVGFyZ2V0ID0gY29udGV4dC5sYWJlbFRhcmdldCxcbiAgICAgICAgbGFiZWxUYXJnZXRJbmRleCA9IGNvbnRleHQubGFiZWxUYXJnZXRJbmRleDtcblxuICAgIC8vIHJlc3RvcmUgbGFiZWxUYXJnZXRcbiAgICBpZiAobGFiZWxUYXJnZXQpIHtcbiAgICAgIGNvbGxlY3Rpb25BZGQobGFiZWxUYXJnZXQubGFiZWxzLCBzaGFwZSwgbGFiZWxUYXJnZXRJbmRleCk7XG5cbiAgICAgIHNoYXBlLmxhYmVsVGFyZ2V0ID0gbGFiZWxUYXJnZXQ7XG4gICAgfVxuICB9KTtcblxufVxuXG5pbmhlcml0cyhMYWJlbFN1cHBvcnQsIENvbW1hbmRJbnRlcmNlcHRvcik7XG5cbkxhYmVsU3VwcG9ydC4kaW5qZWN0ID0gW1xuICAnaW5qZWN0b3InLFxuICAnZXZlbnRCdXMnLFxuICAnbW9kZWxpbmcnXG5dO1xuXG5cbi8qKlxuICogUmV0dXJuIGEgZmlsdGVyZWQgbGlzdCBvZiBlbGVtZW50cyB0aGF0IGRvIG5vdFxuICogY29udGFpbiBhdHRhY2hlZCBlbGVtZW50cyB3aXRoIGhvc3RzIGJlaW5nIHBhcnRcbiAqIG9mIHRoZSBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtICB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBlbGVtZW50c1xuICpcbiAqIEByZXR1cm4ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZmlsdGVyZWRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGFiZWxzKGVsZW1lbnRzKSB7XG5cbiAgcmV0dXJuIGZpbHRlcihlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgLy8gZmlsdGVyIG91dCBsYWJlbHMgdGhhdCBhcmUgbW92ZSB0b2dldGhlclxuICAgIC8vIHdpdGggdGhlaXIgbGFiZWwgdGFyZ2V0c1xuICAgIHJldHVybiBlbGVtZW50cy5pbmRleE9mKGVsZW1lbnQubGFiZWxUYXJnZXQpID09PSAtMTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgTGFiZWxTdXBwb3J0IGZyb20gJy4vTGFiZWxTdXBwb3J0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAnbGFiZWxTdXBwb3J0J10sXG4gIGxhYmVsU3VwcG9ydDogWyAndHlwZScsIExhYmVsU3VwcG9ydCBdXG59O1xuIiwiaW1wb3J0IHsgdmFsdWVzIH0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgeyBnZXRFbmNsb3NlZEVsZW1lbnRzIH0gZnJvbSAnLi4vLi4vdXRpbC9FbGVtZW50cyc7XG5cbmltcG9ydCB7XG4gIGhhc1NlY29uZGFyeU1vZGlmaWVyXG59IGZyb20gJy4uLy4uL3V0aWwvTW91c2UnO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXG4gIHJlbW92ZSBhcyBzdmdSZW1vdmVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG52YXIgTEFTU09fVE9PTF9DVVJTT1IgPSAnY3Jvc3NoYWlyJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYXNzb1Rvb2woXG4gICAgZXZlbnRCdXMsIGNhbnZhcywgZHJhZ2dpbmcsXG4gICAgZWxlbWVudFJlZ2lzdHJ5LCBzZWxlY3Rpb24sIHRvb2xNYW5hZ2VyLFxuICAgIG1vdXNlKSB7XG5cbiAgdGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICB0aGlzLl9kcmFnZ2luZyA9IGRyYWdnaW5nO1xuICB0aGlzLl9tb3VzZSA9IG1vdXNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBsYXNzbyB2aXN1YWxzIGltcGxlbWVudGF0aW9uXG5cbiAgLyoqXG4gICogQSBoZWxwZXIgdGhhdCByZWFsaXplcyB0aGUgc2VsZWN0aW9uIGJveCB2aXN1YWxcbiAgKi9cbiAgdmFyIHZpc3VhbHMgPSB7XG5cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBjYW52YXMuZ2V0RGVmYXVsdExheWVyKCksXG4gICAgICAgICAgZnJhbWU7XG5cbiAgICAgIGZyYW1lID0gY29udGV4dC5mcmFtZSA9IHN2Z0NyZWF0ZSgncmVjdCcpO1xuICAgICAgc3ZnQXR0cihmcmFtZSwge1xuICAgICAgICBjbGFzczogJ2Rqcy1sYXNzby1vdmVybGF5JyxcbiAgICAgICAgd2lkdGg6ICAxLFxuICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0pO1xuXG4gICAgICBzdmdBcHBlbmQoY29udGFpbmVyLCBmcmFtZSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIGZyYW1lID0gY29udGV4dC5mcmFtZSxcbiAgICAgICAgICBiYm94ID0gY29udGV4dC5iYm94O1xuXG4gICAgICBzdmdBdHRyKGZyYW1lLCB7XG4gICAgICAgIHg6IGJib3gueCxcbiAgICAgICAgeTogYmJveC55LFxuICAgICAgICB3aWR0aDogYmJveC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBiYm94LmhlaWdodFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgICBpZiAoY29udGV4dC5mcmFtZSkge1xuICAgICAgICBzdmdSZW1vdmUoY29udGV4dC5mcmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRvb2xNYW5hZ2VyLnJlZ2lzdGVyVG9vbCgnbGFzc28nLCB7XG4gICAgdG9vbDogJ2xhc3NvLnNlbGVjdGlvbicsXG4gICAgZHJhZ2dpbmc6ICdsYXNzbydcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2xhc3NvLnNlbGVjdGlvbi5lbmQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBldmVudC5vcmlnaW5hbEV2ZW50LnRhcmdldDtcblxuICAgIC8vIG9ubHkgcmVhY3RpdmUgb24gZGlhZ3JhbSBjbGlja1xuICAgIC8vIG9uIHNvbWUgb2NjYXNpb25zLCBldmVudC5ob3ZlciBpcyBub3Qgc2V0IGFuZCB3ZSBoYXZlIHRvIGNoZWNrIGlmIHRoZSB0YXJnZXQgaXMgYW4gc3ZnXG4gICAgaWYgKCFldmVudC5ob3ZlciAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnRCdXMub25jZSgnbGFzc28uc2VsZWN0aW9uLmVuZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmFjdGl2YXRlTGFzc28oZXZlbnQub3JpZ2luYWxFdmVudCwgdHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGxhc3NvIGludGVyYWN0aW9uIGltcGxlbWVudGF0aW9uXG5cbiAgZXZlbnRCdXMub24oJ2xhc3NvLmVuZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgYmJveCA9IHRvQkJveChldmVudCk7XG5cbiAgICB2YXIgZWxlbWVudHMgPSBlbGVtZW50UmVnaXN0cnkuZmlsdGVyKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0pO1xuXG4gICAgc2VsZi5zZWxlY3QoZWxlbWVudHMsIGJib3gpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignbGFzc28uc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0O1xuXG4gICAgY29udGV4dC5iYm94ID0gdG9CQm94KGV2ZW50KTtcbiAgICB2aXN1YWxzLmNyZWF0ZShjb250ZXh0KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2xhc3NvLm1vdmUnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0O1xuXG4gICAgY29udGV4dC5iYm94ID0gdG9CQm94KGV2ZW50KTtcbiAgICB2aXN1YWxzLnVwZGF0ZShjb250ZXh0KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2xhc3NvLmNsZWFudXAnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0O1xuXG4gICAgdmlzdWFscy5yZW1vdmUoY29udGV4dCk7XG4gIH0pO1xuXG5cbiAgLy8gZXZlbnQgaW50ZWdyYXRpb25cblxuICBldmVudEJ1cy5vbignZWxlbWVudC5tb3VzZWRvd24nLCAxNTAwLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgaWYgKCFoYXNTZWNvbmRhcnlNb2RpZmllcihldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLmFjdGl2YXRlTGFzc28oZXZlbnQub3JpZ2luYWxFdmVudCk7XG5cbiAgICAvLyB3ZSd2ZSBoYW5kbGVkIHRoZSBldmVudFxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuTGFzc29Ub29sLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnZHJhZ2dpbmcnLFxuICAnZWxlbWVudFJlZ2lzdHJ5JyxcbiAgJ3NlbGVjdGlvbicsXG4gICd0b29sTWFuYWdlcicsXG4gICdtb3VzZSdcbl07XG5cblxuTGFzc29Ub29sLnByb3RvdHlwZS5hY3RpdmF0ZUxhc3NvID0gZnVuY3Rpb24oZXZlbnQsIGF1dG9BY3RpdmF0ZSkge1xuXG4gIHRoaXMuX2RyYWdnaW5nLmluaXQoZXZlbnQsICdsYXNzbycsIHtcbiAgICBhdXRvQWN0aXZhdGU6IGF1dG9BY3RpdmF0ZSxcbiAgICBjdXJzb3I6IExBU1NPX1RPT0xfQ1VSU09SLFxuICAgIGRhdGE6IHtcbiAgICAgIGNvbnRleHQ6IHt9XG4gICAgfVxuICB9KTtcbn07XG5cbkxhc3NvVG9vbC5wcm90b3R5cGUuYWN0aXZhdGVTZWxlY3Rpb24gPSBmdW5jdGlvbihldmVudCwgYXV0b0FjdGl2YXRlKSB7XG5cbiAgdGhpcy5fZHJhZ2dpbmcuaW5pdChldmVudCwgJ2xhc3NvLnNlbGVjdGlvbicsIHtcbiAgICB0cmFwQ2xpY2s6IGZhbHNlLFxuICAgIGF1dG9BY3RpdmF0ZTogYXV0b0FjdGl2YXRlLFxuICAgIGN1cnNvcjogTEFTU09fVE9PTF9DVVJTT1IsXG4gICAgZGF0YToge1xuICAgICAgY29udGV4dDoge31cbiAgICB9XG4gIH0pO1xufTtcblxuTGFzc29Ub29sLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihlbGVtZW50cywgYmJveCkge1xuICB2YXIgc2VsZWN0ZWRFbGVtZW50cyA9IGdldEVuY2xvc2VkRWxlbWVudHMoZWxlbWVudHMsIGJib3gpO1xuXG4gIHRoaXMuX3NlbGVjdGlvbi5zZWxlY3QodmFsdWVzKHNlbGVjdGVkRWxlbWVudHMpKTtcbn07XG5cbkxhc3NvVG9vbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJhZ2dpbmcuY2FuY2VsKCk7XG4gIH1cblxuICB2YXIgbW91c2VFdmVudCA9IHRoaXMuX21vdXNlLmdldExhc3RNb3ZlRXZlbnQoKTtcblxuICB0aGlzLmFjdGl2YXRlU2VsZWN0aW9uKG1vdXNlRXZlbnQsICEhbW91c2VFdmVudCk7XG59O1xuXG5MYXNzb1Rvb2wucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5fZHJhZ2dpbmcuY29udGV4dCgpO1xuXG4gIHJldHVybiBjb250ZXh0ICYmIC9ebGFzc28vLnRlc3QoY29udGV4dC5wcmVmaXgpO1xufTtcblxuXG5cbmZ1bmN0aW9uIHRvQkJveChldmVudCkge1xuXG4gIHZhciBzdGFydCA9IHtcblxuICAgIHg6IGV2ZW50LnggLSBldmVudC5keCxcbiAgICB5OiBldmVudC55IC0gZXZlbnQuZHlcbiAgfTtcblxuICB2YXIgZW5kID0ge1xuICAgIHg6IGV2ZW50LngsXG4gICAgeTogZXZlbnQueVxuICB9O1xuXG4gIHZhciBiYm94O1xuXG4gIGlmICgoc3RhcnQueCA8PSBlbmQueCAmJiBzdGFydC55IDwgZW5kLnkpIHx8XG4gICAgICAoc3RhcnQueCA8IGVuZC54ICYmIHN0YXJ0LnkgPD0gZW5kLnkpKSB7XG5cbiAgICBiYm94ID0ge1xuICAgICAgeDogc3RhcnQueCxcbiAgICAgIHk6IHN0YXJ0LnksXG4gICAgICB3aWR0aDogIGVuZC54IC0gc3RhcnQueCxcbiAgICAgIGhlaWdodDogZW5kLnkgLSBzdGFydC55XG4gICAgfTtcbiAgfSBlbHNlIGlmICgoc3RhcnQueCA+PSBlbmQueCAmJiBzdGFydC55IDwgZW5kLnkpIHx8XG4gICAgICAgICAgICAgKHN0YXJ0LnggPiBlbmQueCAmJiBzdGFydC55IDw9IGVuZC55KSkge1xuXG4gICAgYmJveCA9IHtcbiAgICAgIHg6IGVuZC54LFxuICAgICAgeTogc3RhcnQueSxcbiAgICAgIHdpZHRoOiAgc3RhcnQueCAtIGVuZC54LFxuICAgICAgaGVpZ2h0OiBlbmQueSAtIHN0YXJ0LnlcbiAgICB9O1xuICB9IGVsc2UgaWYgKChzdGFydC54IDw9IGVuZC54ICYmIHN0YXJ0LnkgPiBlbmQueSkgfHxcbiAgICAgICAgICAgICAoc3RhcnQueCA8IGVuZC54ICYmIHN0YXJ0LnkgPj0gZW5kLnkpKSB7XG5cbiAgICBiYm94ID0ge1xuICAgICAgeDogc3RhcnQueCxcbiAgICAgIHk6IGVuZC55LFxuICAgICAgd2lkdGg6ICBlbmQueCAtIHN0YXJ0LngsXG4gICAgICBoZWlnaHQ6IHN0YXJ0LnkgLSBlbmQueVxuICAgIH07XG4gIH0gZWxzZSBpZiAoKHN0YXJ0LnggPj0gZW5kLnggJiYgc3RhcnQueSA+IGVuZC55KSB8fFxuICAgICAgICAgICAgIChzdGFydC54ID4gZW5kLnggJiYgc3RhcnQueSA+PSBlbmQueSkpIHtcblxuICAgIGJib3ggPSB7XG4gICAgICB4OiBlbmQueCxcbiAgICAgIHk6IGVuZC55LFxuICAgICAgd2lkdGg6ICBzdGFydC54IC0gZW5kLngsXG4gICAgICBoZWlnaHQ6IHN0YXJ0LnkgLSBlbmQueVxuICAgIH07XG4gIH0gZWxzZSB7XG5cbiAgICBiYm94ID0ge1xuICAgICAgeDogZW5kLngsXG4gICAgICB5OiBlbmQueSxcbiAgICAgIHdpZHRoOiAgMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJib3g7XG59XG4iLCJpbXBvcnQgVG9vbE1hbmFnZXJNb2R1bGUgZnJvbSAnLi4vdG9vbC1tYW5hZ2VyJztcbmltcG9ydCBNb3VzZU1vZHVsZSBmcm9tICcuLi9tb3VzZSc7XG5cbmltcG9ydCBMYXNzb1Rvb2wgZnJvbSAnLi9MYXNzb1Rvb2wnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgVG9vbE1hbmFnZXJNb2R1bGUsXG4gICAgTW91c2VNb2R1bGVcbiAgXSxcbiAgX19pbml0X186IFsgJ2xhc3NvVG9vbCcgXSxcbiAgbGFzc29Ub29sOiBbICd0eXBlJywgTGFzc29Ub29sIF1cbn07XG4iLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZvckVhY2gsXG4gIGlzQXJyYXlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBCYXNlXG59IGZyb20gJy4uLy4uL21vZGVsJztcblxuaW1wb3J0IEFsaWduRWxlbWVudHNIYW5kbGVyIGZyb20gJy4vY21kL0FsaWduRWxlbWVudHNIYW5kbGVyJztcbmltcG9ydCBBcHBlbmRTaGFwZUhhbmRsZXIgZnJvbSAnLi9jbWQvQXBwZW5kU2hhcGVIYW5kbGVyJztcbmltcG9ydCBDcmVhdGVDb25uZWN0aW9uSGFuZGxlciBmcm9tICcuL2NtZC9DcmVhdGVDb25uZWN0aW9uSGFuZGxlcic7XG5pbXBvcnQgQ3JlYXRlRWxlbWVudHNIYW5kbGVyIGZyb20gJy4vY21kL0NyZWF0ZUVsZW1lbnRzSGFuZGxlcic7XG5pbXBvcnQgQ3JlYXRlTGFiZWxIYW5kbGVyIGZyb20gJy4vY21kL0NyZWF0ZUxhYmVsSGFuZGxlcic7XG5pbXBvcnQgQ3JlYXRlU2hhcGVIYW5kbGVyIGZyb20gJy4vY21kL0NyZWF0ZVNoYXBlSGFuZGxlcic7XG5pbXBvcnQgRGVsZXRlQ29ubmVjdGlvbkhhbmRsZXIgZnJvbSAnLi9jbWQvRGVsZXRlQ29ubmVjdGlvbkhhbmRsZXInO1xuaW1wb3J0IERlbGV0ZUVsZW1lbnRzSGFuZGxlciBmcm9tICcuL2NtZC9EZWxldGVFbGVtZW50c0hhbmRsZXInO1xuaW1wb3J0IERlbGV0ZVNoYXBlSGFuZGxlciBmcm9tICcuL2NtZC9EZWxldGVTaGFwZUhhbmRsZXInO1xuaW1wb3J0IERpc3RyaWJ1dGVFbGVtZW50c0hhbmRsZXIgZnJvbSAnLi9jbWQvRGlzdHJpYnV0ZUVsZW1lbnRzSGFuZGxlcic7XG5pbXBvcnQgTGF5b3V0Q29ubmVjdGlvbkhhbmRsZXIgZnJvbSAnLi9jbWQvTGF5b3V0Q29ubmVjdGlvbkhhbmRsZXInO1xuaW1wb3J0IE1vdmVDb25uZWN0aW9uSGFuZGxlciBmcm9tICcuL2NtZC9Nb3ZlQ29ubmVjdGlvbkhhbmRsZXInO1xuaW1wb3J0IE1vdmVFbGVtZW50c0hhbmRsZXIgZnJvbSAnLi9jbWQvTW92ZUVsZW1lbnRzSGFuZGxlcic7XG5pbXBvcnQgTW92ZVNoYXBlSGFuZGxlciBmcm9tICcuL2NtZC9Nb3ZlU2hhcGVIYW5kbGVyJztcbmltcG9ydCBSZWNvbm5lY3RDb25uZWN0aW9uSGFuZGxlciBmcm9tICcuL2NtZC9SZWNvbm5lY3RDb25uZWN0aW9uSGFuZGxlcic7XG5pbXBvcnQgUmVwbGFjZVNoYXBlSGFuZGxlciBmcm9tICcuL2NtZC9SZXBsYWNlU2hhcGVIYW5kbGVyJztcbmltcG9ydCBSZXNpemVTaGFwZUhhbmRsZXIgZnJvbSAnLi9jbWQvUmVzaXplU2hhcGVIYW5kbGVyJztcbmltcG9ydCBTcGFjZVRvb2xIYW5kbGVyIGZyb20gJy4vY21kL1NwYWNlVG9vbEhhbmRsZXInO1xuaW1wb3J0IFRvZ2dsZVNoYXBlQ29sbGFwc2VIYW5kbGVyIGZyb20gJy4vY21kL1RvZ2dsZVNoYXBlQ29sbGFwc2VIYW5kbGVyJztcbmltcG9ydCBVcGRhdGVBdHRhY2htZW50SGFuZGxlciBmcm9tICcuL2NtZC9VcGRhdGVBdHRhY2htZW50SGFuZGxlcic7XG5pbXBvcnQgVXBkYXRlV2F5cG9pbnRzSGFuZGxlciBmcm9tICcuL2NtZC9VcGRhdGVXYXlwb2ludHNIYW5kbGVyJztcblxuXG4vKipcbiAqIFRoZSBiYXNpYyBtb2RlbGluZyBlbnRyeSBwb2ludC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtFbGVtZW50RmFjdG9yeX0gZWxlbWVudEZhY3RvcnlcbiAqIEBwYXJhbSB7Q29tbWFuZFN0YWNrfSBjb21tYW5kU3RhY2tcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW9kZWxpbmcoZXZlbnRCdXMsIGVsZW1lbnRGYWN0b3J5LCBjb21tYW5kU3RhY2spIHtcbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fZWxlbWVudEZhY3RvcnkgPSBlbGVtZW50RmFjdG9yeTtcbiAgdGhpcy5fY29tbWFuZFN0YWNrID0gY29tbWFuZFN0YWNrO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBldmVudEJ1cy5vbignZGlhZ3JhbS5pbml0JywgZnVuY3Rpb24oKSB7XG5cbiAgICAvLyByZWdpc3RlciBtb2RlbGluZyBoYW5kbGVyc1xuICAgIHNlbGYucmVnaXN0ZXJIYW5kbGVycyhjb21tYW5kU3RhY2spO1xuICB9KTtcbn1cblxuTW9kZWxpbmcuJGluamVjdCA9IFsgJ2V2ZW50QnVzJywgJ2VsZW1lbnRGYWN0b3J5JywgJ2NvbW1hbmRTdGFjaycgXTtcblxuXG5Nb2RlbGluZy5wcm90b3R5cGUuZ2V0SGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICAnc2hhcGUuYXBwZW5kJzogQXBwZW5kU2hhcGVIYW5kbGVyLFxuICAgICdzaGFwZS5jcmVhdGUnOiBDcmVhdGVTaGFwZUhhbmRsZXIsXG4gICAgJ3NoYXBlLmRlbGV0ZSc6IERlbGV0ZVNoYXBlSGFuZGxlcixcbiAgICAnc2hhcGUubW92ZSc6IE1vdmVTaGFwZUhhbmRsZXIsXG4gICAgJ3NoYXBlLnJlc2l6ZSc6IFJlc2l6ZVNoYXBlSGFuZGxlcixcbiAgICAnc2hhcGUucmVwbGFjZSc6IFJlcGxhY2VTaGFwZUhhbmRsZXIsXG4gICAgJ3NoYXBlLnRvZ2dsZUNvbGxhcHNlJzogVG9nZ2xlU2hhcGVDb2xsYXBzZUhhbmRsZXIsXG5cbiAgICAnc3BhY2VUb29sJzogU3BhY2VUb29sSGFuZGxlcixcblxuICAgICdsYWJlbC5jcmVhdGUnOiBDcmVhdGVMYWJlbEhhbmRsZXIsXG5cbiAgICAnY29ubmVjdGlvbi5jcmVhdGUnOiBDcmVhdGVDb25uZWN0aW9uSGFuZGxlcixcbiAgICAnY29ubmVjdGlvbi5kZWxldGUnOiBEZWxldGVDb25uZWN0aW9uSGFuZGxlcixcbiAgICAnY29ubmVjdGlvbi5tb3ZlJzogTW92ZUNvbm5lY3Rpb25IYW5kbGVyLFxuICAgICdjb25uZWN0aW9uLmxheW91dCc6IExheW91dENvbm5lY3Rpb25IYW5kbGVyLFxuXG4gICAgJ2Nvbm5lY3Rpb24udXBkYXRlV2F5cG9pbnRzJzogVXBkYXRlV2F5cG9pbnRzSGFuZGxlcixcblxuICAgICdjb25uZWN0aW9uLnJlY29ubmVjdCc6IFJlY29ubmVjdENvbm5lY3Rpb25IYW5kbGVyLFxuXG4gICAgJ2VsZW1lbnRzLmNyZWF0ZSc6IENyZWF0ZUVsZW1lbnRzSGFuZGxlcixcbiAgICAnZWxlbWVudHMubW92ZSc6IE1vdmVFbGVtZW50c0hhbmRsZXIsXG4gICAgJ2VsZW1lbnRzLmRlbGV0ZSc6IERlbGV0ZUVsZW1lbnRzSGFuZGxlcixcblxuICAgICdlbGVtZW50cy5kaXN0cmlidXRlJzogRGlzdHJpYnV0ZUVsZW1lbnRzSGFuZGxlcixcbiAgICAnZWxlbWVudHMuYWxpZ24nOiBBbGlnbkVsZW1lbnRzSGFuZGxlcixcblxuICAgICdlbGVtZW50LnVwZGF0ZUF0dGFjaG1lbnQnOiBVcGRhdGVBdHRhY2htZW50SGFuZGxlclxuICB9O1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBoYW5kbGVycyB3aXRoIHRoZSBjb21tYW5kIHN0YWNrXG4gKlxuICogQHBhcmFtIHtDb21tYW5kU3RhY2t9IGNvbW1hbmRTdGFja1xuICovXG5Nb2RlbGluZy5wcm90b3R5cGUucmVnaXN0ZXJIYW5kbGVycyA9IGZ1bmN0aW9uKGNvbW1hbmRTdGFjaykge1xuICBmb3JFYWNoKHRoaXMuZ2V0SGFuZGxlcnMoKSwgZnVuY3Rpb24oaGFuZGxlciwgaWQpIHtcbiAgICBjb21tYW5kU3RhY2sucmVnaXN0ZXJIYW5kbGVyKGlkLCBoYW5kbGVyKTtcbiAgfSk7XG59O1xuXG5cbi8vIG1vZGVsaW5nIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5Nb2RlbGluZy5wcm90b3R5cGUubW92ZVNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIGRlbHRhLCBuZXdQYXJlbnQsIG5ld1BhcmVudEluZGV4LCBoaW50cykge1xuXG4gIGlmICh0eXBlb2YgbmV3UGFyZW50SW5kZXggPT09ICdvYmplY3QnKSB7XG4gICAgaGludHMgPSBuZXdQYXJlbnRJbmRleDtcbiAgICBuZXdQYXJlbnRJbmRleCA9IG51bGw7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICBzaGFwZTogc2hhcGUsXG4gICAgZGVsdGE6ICBkZWx0YSxcbiAgICBuZXdQYXJlbnQ6IG5ld1BhcmVudCxcbiAgICBuZXdQYXJlbnRJbmRleDogbmV3UGFyZW50SW5kZXgsXG4gICAgaGludHM6IGhpbnRzIHx8IHt9XG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ3NoYXBlLm1vdmUnLCBjb250ZXh0KTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGF0dGFjaG1lbnQgb2YgdGhlIGdpdmVuIHNoYXBlLlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGUuQmFzZX0gc2hhcGVcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IFtuZXdIb3N0XVxuICovXG5Nb2RlbGluZy5wcm90b3R5cGUudXBkYXRlQXR0YWNobWVudCA9IGZ1bmN0aW9uKHNoYXBlLCBuZXdIb3N0KSB7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIHNoYXBlOiBzaGFwZSxcbiAgICBuZXdIb3N0OiBuZXdIb3N0XG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2VsZW1lbnQudXBkYXRlQXR0YWNobWVudCcsIGNvbnRleHQpO1xufTtcblxuXG4vKipcbiAqIE1vdmUgYSBudW1iZXIgb2Ygc2hhcGVzIHRvIGEgbmV3IHRhcmdldCwgZWl0aGVyIHNldHRpbmcgaXQgYXNcbiAqIHRoZSBuZXcgcGFyZW50IG9yIGF0dGFjaGluZyBpdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGRqcy5tb2RlLkJhc2U+fSBzaGFwZXNcbiAqIEBwYXJhbSB7UG9pbnR9IGRlbHRhXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBbdGFyZ2V0XVxuICogQHBhcmFtIHtPYmplY3R9IFtoaW50c11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpbnRzLmF0dGFjaD1mYWxzZV1cbiAqL1xuTW9kZWxpbmcucHJvdG90eXBlLm1vdmVFbGVtZW50cyA9IGZ1bmN0aW9uKHNoYXBlcywgZGVsdGEsIHRhcmdldCwgaGludHMpIHtcblxuICBoaW50cyA9IGhpbnRzIHx8IHt9O1xuXG4gIHZhciBhdHRhY2ggPSBoaW50cy5hdHRhY2g7XG5cbiAgdmFyIG5ld1BhcmVudCA9IHRhcmdldCxcbiAgICAgIG5ld0hvc3Q7XG5cbiAgaWYgKGF0dGFjaCA9PT0gdHJ1ZSkge1xuICAgIG5ld0hvc3QgPSB0YXJnZXQ7XG4gICAgbmV3UGFyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgfSBlbHNlXG5cbiAgaWYgKGF0dGFjaCA9PT0gZmFsc2UpIHtcbiAgICBuZXdIb3N0ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgIHNoYXBlczogc2hhcGVzLFxuICAgIGRlbHRhOiBkZWx0YSxcbiAgICBuZXdQYXJlbnQ6IG5ld1BhcmVudCxcbiAgICBuZXdIb3N0OiBuZXdIb3N0LFxuICAgIGhpbnRzOiBoaW50c1xuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdlbGVtZW50cy5tb3ZlJywgY29udGV4dCk7XG59O1xuXG5cbk1vZGVsaW5nLnByb3RvdHlwZS5tb3ZlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIGRlbHRhLCBuZXdQYXJlbnQsIG5ld1BhcmVudEluZGV4LCBoaW50cykge1xuXG4gIGlmICh0eXBlb2YgbmV3UGFyZW50SW5kZXggPT09ICdvYmplY3QnKSB7XG4gICAgaGludHMgPSBuZXdQYXJlbnRJbmRleDtcbiAgICBuZXdQYXJlbnRJbmRleCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgZGVsdGE6IGRlbHRhLFxuICAgIG5ld1BhcmVudDogbmV3UGFyZW50LFxuICAgIG5ld1BhcmVudEluZGV4OiBuZXdQYXJlbnRJbmRleCxcbiAgICBoaW50czogaGludHMgfHwge31cbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnY29ubmVjdGlvbi5tb3ZlJywgY29udGV4dCk7XG59O1xuXG5cbk1vZGVsaW5nLnByb3RvdHlwZS5sYXlvdXRDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgaGludHMpIHtcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICBoaW50czogaGludHMgfHwge31cbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnY29ubmVjdGlvbi5sYXlvdXQnLCBjb250ZXh0KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBzb3VyY2VcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IHRhcmdldFxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJlbnRJbmRleF1cbiAqIEBwYXJhbSB7T2JqZWN0fGRqcy5tb2RlbC5Db25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBoaW50c1xuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5Db25uZWN0aW9ufSB0aGUgY3JlYXRlZCBjb25uZWN0aW9uLlxuICovXG5Nb2RlbGluZy5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0LCBwYXJlbnRJbmRleCwgY29ubmVjdGlvbiwgcGFyZW50LCBoaW50cykge1xuXG4gIGlmICh0eXBlb2YgcGFyZW50SW5kZXggPT09ICdvYmplY3QnKSB7XG4gICAgaGludHMgPSBwYXJlbnQ7XG4gICAgcGFyZW50ID0gY29ubmVjdGlvbjtcbiAgICBjb25uZWN0aW9uID0gcGFyZW50SW5kZXg7XG4gICAgcGFyZW50SW5kZXggPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25uZWN0aW9uID0gdGhpcy5fY3JlYXRlKCdjb25uZWN0aW9uJywgY29ubmVjdGlvbik7XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcGFyZW50SW5kZXg6IHBhcmVudEluZGV4LFxuICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgaGludHM6IGhpbnRzXG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2Nvbm5lY3Rpb24uY3JlYXRlJywgY29udGV4dCk7XG5cbiAgcmV0dXJuIGNvbnRleHQuY29ubmVjdGlvbjtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBzaGFwZSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLlNoYXBlfE9iamVjdH0gc2hhcGVcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5TaGFwZXxkanMubW9kZWwuUm9vdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmVudEluZGV4XSBwb3NpdGlvbiBpbiBwYXJlbnRzIGNoaWxkcmVuIGxpc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGludHNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoaW50cy5hdHRhY2hdIHdoZXRoZXIgdG8gYXR0YWNoIHRvIHRhcmdldCBvciBiZWNvbWUgYSBjaGlsZFxuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5TaGFwZX0gdGhlIGNyZWF0ZWQgc2hhcGVcbiAqL1xuTW9kZWxpbmcucHJvdG90eXBlLmNyZWF0ZVNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIHBvc2l0aW9uLCB0YXJnZXQsIHBhcmVudEluZGV4LCBoaW50cykge1xuXG4gIGlmICh0eXBlb2YgcGFyZW50SW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgaGludHMgPSBwYXJlbnRJbmRleDtcbiAgICBwYXJlbnRJbmRleCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGhpbnRzID0gaGludHMgfHwge307XG5cbiAgdmFyIGF0dGFjaCA9IGhpbnRzLmF0dGFjaCxcbiAgICAgIHBhcmVudCxcbiAgICAgIGhvc3Q7XG5cbiAgc2hhcGUgPSB0aGlzLl9jcmVhdGUoJ3NoYXBlJywgc2hhcGUpO1xuXG4gIGlmIChhdHRhY2gpIHtcbiAgICBwYXJlbnQgPSB0YXJnZXQucGFyZW50O1xuICAgIGhvc3QgPSB0YXJnZXQ7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50ID0gdGFyZ2V0O1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIHNoYXBlOiBzaGFwZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwYXJlbnRJbmRleDogcGFyZW50SW5kZXgsXG4gICAgaG9zdDogaG9zdCxcbiAgICBoaW50czogaGludHNcbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnc2hhcGUuY3JlYXRlJywgY29udGV4dCk7XG5cbiAgcmV0dXJuIGNvbnRleHQuc2hhcGU7XG59O1xuXG5cbk1vZGVsaW5nLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBwb3NpdGlvbiwgcGFyZW50LCBwYXJlbnRJbmRleCwgaGludHMpIHtcbiAgaWYgKCFpc0FycmF5KGVsZW1lbnRzKSkge1xuICAgIGVsZW1lbnRzID0gWyBlbGVtZW50cyBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJlbnRJbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICBoaW50cyA9IHBhcmVudEluZGV4O1xuICAgIHBhcmVudEluZGV4ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaGludHMgPSBoaW50cyB8fCB7fTtcblxuICB2YXIgY29udGV4dCA9IHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHBhcmVudEluZGV4OiBwYXJlbnRJbmRleCxcbiAgICBoaW50czogaGludHNcbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnZWxlbWVudHMuY3JlYXRlJywgY29udGV4dCk7XG5cbiAgcmV0dXJuIGNvbnRleHQuZWxlbWVudHM7XG59O1xuXG5cbk1vZGVsaW5nLnByb3RvdHlwZS5jcmVhdGVMYWJlbCA9IGZ1bmN0aW9uKGxhYmVsVGFyZ2V0LCBwb3NpdGlvbiwgbGFiZWwsIHBhcmVudCkge1xuXG4gIGxhYmVsID0gdGhpcy5fY3JlYXRlKCdsYWJlbCcsIGxhYmVsKTtcblxuICB2YXIgY29udGV4dCA9IHtcbiAgICBsYWJlbFRhcmdldDogbGFiZWxUYXJnZXQsXG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIHBhcmVudDogcGFyZW50IHx8IGxhYmVsVGFyZ2V0LnBhcmVudCxcbiAgICBzaGFwZTogbGFiZWxcbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnbGFiZWwuY3JlYXRlJywgY29udGV4dCk7XG5cbiAgcmV0dXJuIGNvbnRleHQuc2hhcGU7XG59O1xuXG5cbi8qKlxuICogQXBwZW5kIHNoYXBlIHRvIGdpdmVuIHNvdXJjZSwgZHJhd2luZyBhIGNvbm5lY3Rpb25cbiAqIGJldHdlZW4gc291cmNlIGFuZCB0aGUgbmV3bHkgY3JlYXRlZCBzaGFwZS5cbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5TaGFwZX0gc291cmNlXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5TaGFwZXxPYmplY3R9IHNoYXBlXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvblxuICogQHBhcmFtIHtkanMubW9kZWwuU2hhcGV9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IFtoaW50c11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpbnRzLmF0dGFjaF1cbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkNvbm5lY3Rpb258T2JqZWN0fSBbaGludHMuY29ubmVjdGlvbl1cbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IFtoaW50cy5jb25uZWN0aW9uUGFyZW50XVxuICpcbiAqIEByZXR1cm4ge2Rqcy5tb2RlbC5TaGFwZX0gdGhlIG5ld2x5IGNyZWF0ZWQgc2hhcGVcbiAqL1xuTW9kZWxpbmcucHJvdG90eXBlLmFwcGVuZFNoYXBlID0gZnVuY3Rpb24oc291cmNlLCBzaGFwZSwgcG9zaXRpb24sIHRhcmdldCwgaGludHMpIHtcblxuICBoaW50cyA9IGhpbnRzIHx8IHt9O1xuXG4gIHNoYXBlID0gdGhpcy5fY3JlYXRlKCdzaGFwZScsIHNoYXBlKTtcblxuICB2YXIgY29udGV4dCA9IHtcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgc2hhcGU6IHNoYXBlLFxuICAgIGNvbm5lY3Rpb246IGhpbnRzLmNvbm5lY3Rpb24sXG4gICAgY29ubmVjdGlvblBhcmVudDogaGludHMuY29ubmVjdGlvblBhcmVudCxcbiAgICBoaW50czogaGludHNcbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnc2hhcGUuYXBwZW5kJywgY29udGV4dCk7XG5cbiAgcmV0dXJuIGNvbnRleHQuc2hhcGU7XG59O1xuXG5cbk1vZGVsaW5nLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdlbGVtZW50cy5kZWxldGUnLCBjb250ZXh0KTtcbn07XG5cblxuTW9kZWxpbmcucHJvdG90eXBlLmRpc3RyaWJ1dGVFbGVtZW50cyA9IGZ1bmN0aW9uKGdyb3VwcywgYXhpcywgZGltZW5zaW9uKSB7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGdyb3VwczogZ3JvdXBzLFxuICAgIGF4aXM6IGF4aXMsXG4gICAgZGltZW5zaW9uOiBkaW1lbnNpb25cbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnZWxlbWVudHMuZGlzdHJpYnV0ZScsIGNvbnRleHQpO1xufTtcblxuXG5Nb2RlbGluZy5wcm90b3R5cGUucmVtb3ZlU2hhcGUgPSBmdW5jdGlvbihzaGFwZSwgaGludHMpIHtcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgc2hhcGU6IHNoYXBlLFxuICAgIGhpbnRzOiBoaW50cyB8fCB7fVxuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdzaGFwZS5kZWxldGUnLCBjb250ZXh0KTtcbn07XG5cblxuTW9kZWxpbmcucHJvdG90eXBlLnJlbW92ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uLCBoaW50cykge1xuICB2YXIgY29udGV4dCA9IHtcbiAgICBjb25uZWN0aW9uOiBjb25uZWN0aW9uLFxuICAgIGhpbnRzOiBoaW50cyB8fCB7fVxuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdjb25uZWN0aW9uLmRlbGV0ZScsIGNvbnRleHQpO1xufTtcblxuTW9kZWxpbmcucHJvdG90eXBlLnJlcGxhY2VTaGFwZSA9IGZ1bmN0aW9uKG9sZFNoYXBlLCBuZXdTaGFwZSwgaGludHMpIHtcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgb2xkU2hhcGU6IG9sZFNoYXBlLFxuICAgIG5ld0RhdGE6IG5ld1NoYXBlLFxuICAgIGhpbnRzOiBoaW50cyB8fCB7fVxuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdzaGFwZS5yZXBsYWNlJywgY29udGV4dCk7XG5cbiAgcmV0dXJuIGNvbnRleHQubmV3U2hhcGU7XG59O1xuXG5Nb2RlbGluZy5wcm90b3R5cGUuYWxpZ25FbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBhbGlnbm1lbnQpIHtcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgIGFsaWdubWVudDogYWxpZ25tZW50XG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2VsZW1lbnRzLmFsaWduJywgY29udGV4dCk7XG59O1xuXG5Nb2RlbGluZy5wcm90b3R5cGUucmVzaXplU2hhcGUgPSBmdW5jdGlvbihzaGFwZSwgbmV3Qm91bmRzLCBtaW5Cb3VuZHMsIGhpbnRzKSB7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIHNoYXBlOiBzaGFwZSxcbiAgICBuZXdCb3VuZHM6IG5ld0JvdW5kcyxcbiAgICBtaW5Cb3VuZHM6IG1pbkJvdW5kcyxcbiAgICBoaW50czogaGludHNcbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnc2hhcGUucmVzaXplJywgY29udGV4dCk7XG59O1xuXG5Nb2RlbGluZy5wcm90b3R5cGUuY3JlYXRlU3BhY2UgPSBmdW5jdGlvbihtb3ZpbmdTaGFwZXMsIHJlc2l6aW5nU2hhcGVzLCBkZWx0YSwgZGlyZWN0aW9uLCBzdGFydCkge1xuICB2YXIgY29udGV4dCA9IHtcbiAgICBkZWx0YTogZGVsdGEsXG4gICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgbW92aW5nU2hhcGVzOiBtb3ZpbmdTaGFwZXMsXG4gICAgcmVzaXppbmdTaGFwZXM6IHJlc2l6aW5nU2hhcGVzLFxuICAgIHN0YXJ0OiBzdGFydFxuICB9O1xuXG4gIHRoaXMuX2NvbW1hbmRTdGFjay5leGVjdXRlKCdzcGFjZVRvb2wnLCBjb250ZXh0KTtcbn07XG5cbk1vZGVsaW5nLnByb3RvdHlwZS51cGRhdGVXYXlwb2ludHMgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBuZXdXYXlwb2ludHMsIGhpbnRzKSB7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgbmV3V2F5cG9pbnRzOiBuZXdXYXlwb2ludHMsXG4gICAgaGludHM6IGhpbnRzIHx8IHt9XG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ2Nvbm5lY3Rpb24udXBkYXRlV2F5cG9pbnRzJywgY29udGV4dCk7XG59O1xuXG5Nb2RlbGluZy5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgc291cmNlLCB0YXJnZXQsIGRvY2tpbmdPclBvaW50cywgaGludHMpIHtcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICBuZXdTb3VyY2U6IHNvdXJjZSxcbiAgICBuZXdUYXJnZXQ6IHRhcmdldCxcbiAgICBkb2NraW5nT3JQb2ludHM6IGRvY2tpbmdPclBvaW50cyxcbiAgICBoaW50czogaGludHMgfHwge31cbiAgfTtcblxuICB0aGlzLl9jb21tYW5kU3RhY2suZXhlY3V0ZSgnY29ubmVjdGlvbi5yZWNvbm5lY3QnLCBjb250ZXh0KTtcbn07XG5cbk1vZGVsaW5nLnByb3RvdHlwZS5yZWNvbm5lY3RTdGFydCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIG5ld1NvdXJjZSwgZG9ja2luZ09yUG9pbnRzLCBoaW50cykge1xuICBpZiAoIWhpbnRzKSB7XG4gICAgaGludHMgPSB7fTtcbiAgfVxuXG4gIHRoaXMucmVjb25uZWN0KGNvbm5lY3Rpb24sIG5ld1NvdXJjZSwgY29ubmVjdGlvbi50YXJnZXQsIGRvY2tpbmdPclBvaW50cywgYXNzaWduKGhpbnRzLCB7XG4gICAgZG9ja2luZzogJ3NvdXJjZSdcbiAgfSkpO1xufTtcblxuTW9kZWxpbmcucHJvdG90eXBlLnJlY29ubmVjdEVuZCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIG5ld1RhcmdldCwgZG9ja2luZ09yUG9pbnRzLCBoaW50cykge1xuICBpZiAoIWhpbnRzKSB7XG4gICAgaGludHMgPSB7fTtcbiAgfVxuXG4gIHRoaXMucmVjb25uZWN0KGNvbm5lY3Rpb24sIGNvbm5lY3Rpb24uc291cmNlLCBuZXdUYXJnZXQsIGRvY2tpbmdPclBvaW50cywgYXNzaWduKGhpbnRzLCB7XG4gICAgZG9ja2luZzogJ3RhcmdldCdcbiAgfSkpO1xufTtcblxuTW9kZWxpbmcucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCwgYXR0cnMsIGhpbnRzKSB7XG4gIHJldHVybiB0aGlzLmNyZWF0ZUNvbm5lY3Rpb24oc291cmNlLCB0YXJnZXQsIGF0dHJzIHx8IHt9LCBzb3VyY2UucGFyZW50LCBoaW50cyk7XG59O1xuXG5Nb2RlbGluZy5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKHR5cGUsIGF0dHJzKSB7XG4gIGlmIChhdHRycyBpbnN0YW5jZW9mIEJhc2UpIHtcbiAgICByZXR1cm4gYXR0cnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRGYWN0b3J5LmNyZWF0ZSh0eXBlLCBhdHRycyk7XG4gIH1cbn07XG5cbk1vZGVsaW5nLnByb3RvdHlwZS50b2dnbGVDb2xsYXBzZSA9IGZ1bmN0aW9uKHNoYXBlLCBoaW50cykge1xuICB2YXIgY29udGV4dCA9IHtcbiAgICBzaGFwZTogc2hhcGUsXG4gICAgaGludHM6IGhpbnRzIHx8IHt9XG4gIH07XG5cbiAgdGhpcy5fY29tbWFuZFN0YWNrLmV4ZWN1dGUoJ3NoYXBlLnRvZ2dsZUNvbGxhcHNlJywgY29udGV4dCk7XG59O1xuIiwiaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gJ21pbi1kYXNoJztcblxuLyoqXG4gKiBBIGhhbmRsZXIgdGhhdCBhbGlnbiBlbGVtZW50cyBpbiBhIGNlcnRhaW4gd2F5LlxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWxpZ25FbGVtZW50cyhtb2RlbGluZywgY2FudmFzKSB7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbn1cblxuQWxpZ25FbGVtZW50cy4kaW5qZWN0ID0gWyAnbW9kZWxpbmcnLCAnY2FudmFzJyBdO1xuXG5cbkFsaWduRWxlbWVudHMucHJvdG90eXBlLnByZUV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBtb2RlbGluZyA9IHRoaXMuX21vZGVsaW5nO1xuXG4gIHZhciBlbGVtZW50cyA9IGNvbnRleHQuZWxlbWVudHMsXG4gICAgICBhbGlnbm1lbnQgPSBjb250ZXh0LmFsaWdubWVudDtcblxuXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB2YXIgZGVsdGEgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG5cbiAgICBpZiAoYWxpZ25tZW50LmxlZnQpIHtcbiAgICAgIGRlbHRhLnggPSBhbGlnbm1lbnQubGVmdCAtIGVsZW1lbnQueDtcblxuICAgIH0gZWxzZSBpZiAoYWxpZ25tZW50LnJpZ2h0KSB7XG4gICAgICBkZWx0YS54ID0gKGFsaWdubWVudC5yaWdodCAtIGVsZW1lbnQud2lkdGgpIC0gZWxlbWVudC54O1xuXG4gICAgfSBlbHNlIGlmIChhbGlnbm1lbnQuY2VudGVyKSB7XG4gICAgICBkZWx0YS54ID0gKGFsaWdubWVudC5jZW50ZXIgLSBNYXRoLnJvdW5kKGVsZW1lbnQud2lkdGggLyAyKSkgLSBlbGVtZW50Lng7XG5cbiAgICB9IGVsc2UgaWYgKGFsaWdubWVudC50b3ApIHtcbiAgICAgIGRlbHRhLnkgPSBhbGlnbm1lbnQudG9wIC0gZWxlbWVudC55O1xuXG4gICAgfSBlbHNlIGlmIChhbGlnbm1lbnQuYm90dG9tKSB7XG4gICAgICBkZWx0YS55ID0gKGFsaWdubWVudC5ib3R0b20gLSBlbGVtZW50LmhlaWdodCkgLSBlbGVtZW50Lnk7XG5cbiAgICB9IGVsc2UgaWYgKGFsaWdubWVudC5taWRkbGUpIHtcbiAgICAgIGRlbHRhLnkgPSAoYWxpZ25tZW50Lm1pZGRsZSAtIE1hdGgucm91bmQoZWxlbWVudC5oZWlnaHQgLyAyKSkgLSBlbGVtZW50Lnk7XG4gICAgfVxuXG4gICAgbW9kZWxpbmcubW92ZUVsZW1lbnRzKFsgZWxlbWVudCBdLCBkZWx0YSwgZWxlbWVudC5wYXJlbnQpO1xuICB9KTtcbn07XG5cbkFsaWduRWxlbWVudHMucHJvdG90eXBlLnBvc3RFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG59O1xuIiwiaW1wb3J0IHsgc29tZSB9IGZyb20gJ21pbi1kYXNoJztcblxuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IGltcGxlbWVudHMgcmV2ZXJzaWJsZSBhcHBlbmRpbmcgb2Ygc2hhcGVzXG4gKiB0byBhIHNvdXJjZSBzaGFwZS5cbiAqXG4gKiBAcGFyYW0ge2NhbnZhc30gQ2FudmFzXG4gKiBAcGFyYW0ge2VsZW1lbnRGYWN0b3J5fSBFbGVtZW50RmFjdG9yeVxuICogQHBhcmFtIHttb2RlbGluZ30gTW9kZWxpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwZW5kU2hhcGVIYW5kbGVyKG1vZGVsaW5nKSB7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG59XG5cbkFwcGVuZFNoYXBlSGFuZGxlci4kaW5qZWN0ID0gWyAnbW9kZWxpbmcnIF07XG5cblxuLy8gYXBpIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc2hhcGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50RGVzY3JpcHRvcn0gY29udGV4dC5zaGFwZSB0aGUgbmV3IHNoYXBlXG4gKiBAcGFyYW0ge0VsZW1lbnREZXNjcmlwdG9yfSBjb250ZXh0LnNvdXJjZSB0aGUgc291cmNlIG9iamVjdFxuICogQHBhcmFtIHtFbGVtZW50RGVzY3JpcHRvcn0gY29udGV4dC5wYXJlbnQgdGhlIHBhcmVudCBvYmplY3RcbiAqIEBwYXJhbSB7UG9pbnR9IGNvbnRleHQucG9zaXRpb24gcG9zaXRpb24gb2YgdGhlIG5ldyBlbGVtZW50XG4gKi9cbkFwcGVuZFNoYXBlSGFuZGxlci5wcm90b3R5cGUucHJlRXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgc291cmNlID0gY29udGV4dC5zb3VyY2U7XG5cbiAgaWYgKCFzb3VyY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSByZXF1aXJlZCcpO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0IHx8IHNvdXJjZS5wYXJlbnQsXG4gICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICBoaW50cyA9IGNvbnRleHQuaGludHMgfHwge307XG5cbiAgc2hhcGUgPSBjb250ZXh0LnNoYXBlID1cbiAgICB0aGlzLl9tb2RlbGluZy5jcmVhdGVTaGFwZShcbiAgICAgIHNoYXBlLFxuICAgICAgY29udGV4dC5wb3NpdGlvbixcbiAgICAgIHRhcmdldCwgeyBhdHRhY2g6IGhpbnRzLmF0dGFjaCB9KTtcblxuICBjb250ZXh0LnNoYXBlID0gc2hhcGU7XG59O1xuXG5BcHBlbmRTaGFwZUhhbmRsZXIucHJvdG90eXBlLnBvc3RFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gIGlmICghZXhpc3RzQ29ubmVjdGlvbihjb250ZXh0LnNvdXJjZSwgY29udGV4dC5zaGFwZSkpIHtcblxuICAgIC8vIGNyZWF0ZSBjb25uZWN0aW9uXG4gICAgaWYgKGhpbnRzLmNvbm5lY3Rpb25UYXJnZXQgPT09IGNvbnRleHQuc291cmNlKSB7XG4gICAgICB0aGlzLl9tb2RlbGluZy5jb25uZWN0KGNvbnRleHQuc2hhcGUsIGNvbnRleHQuc291cmNlLCBjb250ZXh0LmNvbm5lY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9tb2RlbGluZy5jb25uZWN0KGNvbnRleHQuc291cmNlLCBjb250ZXh0LnNoYXBlLCBjb250ZXh0LmNvbm5lY3Rpb24pO1xuICAgIH1cbiAgfVxufTtcblxuXG5mdW5jdGlvbiBleGlzdHNDb25uZWN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiBzb21lKHNvdXJjZS5vdXRnb2luZywgZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBjLnRhcmdldCA9PT0gdGFyZ2V0O1xuICB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDcmVhdGVDb25uZWN0aW9uSGFuZGxlcihjYW52YXMsIGxheW91dGVyKSB7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fbGF5b3V0ZXIgPSBsYXlvdXRlcjtcbn1cblxuQ3JlYXRlQ29ubmVjdGlvbkhhbmRsZXIuJGluamVjdCA9IFsgJ2NhbnZhcycsICdsYXlvdXRlcicgXTtcblxuXG4vLyBhcGkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8qKlxuICogQXBwZW5kcyBhIHNoYXBlIHRvIGEgdGFyZ2V0IHNoYXBlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7ZGpzLmVsZW1lbnQuQmFzZX0gY29udGV4dC5zb3VyY2UgdGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7ZGpzLmVsZW1lbnQuQmFzZX0gY29udGV4dC50YXJnZXQgdGhlIHBhcmVudCBvYmplY3RcbiAqIEBwYXJhbSB7UG9pbnR9IGNvbnRleHQucG9zaXRpb24gcG9zaXRpb24gb2YgdGhlIG5ldyBlbGVtZW50XG4gKi9cbkNyZWF0ZUNvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgc291cmNlID0gY29udGV4dC5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBjb250ZXh0LnRhcmdldCxcbiAgICAgIHBhcmVudCA9IGNvbnRleHQucGFyZW50LFxuICAgICAgcGFyZW50SW5kZXggPSBjb250ZXh0LnBhcmVudEluZGV4LFxuICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzO1xuXG4gIGlmICghc291cmNlIHx8ICF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBhbmQgdGFyZ2V0IHJlcXVpcmVkJyk7XG4gIH1cblxuICBpZiAoIXBhcmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFyZW50IHJlcXVpcmVkJyk7XG4gIH1cblxuICBjb25uZWN0aW9uLnNvdXJjZSA9IHNvdXJjZTtcbiAgY29ubmVjdGlvbi50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgaWYgKCFjb25uZWN0aW9uLndheXBvaW50cykge1xuICAgIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gdGhpcy5fbGF5b3V0ZXIubGF5b3V0Q29ubmVjdGlvbihjb25uZWN0aW9uLCBoaW50cyk7XG4gIH1cblxuICAvLyBhZGQgY29ubmVjdGlvblxuICB0aGlzLl9jYW52YXMuYWRkQ29ubmVjdGlvbihjb25uZWN0aW9uLCBwYXJlbnQsIHBhcmVudEluZGV4KTtcblxuICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG5cbkNyZWF0ZUNvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uO1xuXG4gIHRoaXMuX2NhbnZhcy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuXG4gIGNvbm5lY3Rpb24uc291cmNlID0gbnVsbDtcbiAgY29ubmVjdGlvbi50YXJnZXQgPSBudWxsO1xuXG4gIHJldHVybiBjb25uZWN0aW9uO1xufTsiLCJpbXBvcnQge1xyXG4gIGFzc2lnbixcclxuICBmb3JFYWNoLFxyXG4gIGlzTnVtYmVyLFxyXG4gIG1hcCxcclxuICBwaWNrLFxyXG4gIHZhbHVlc1xyXG59IGZyb20gJ21pbi1kYXNoJztcclxuXHJcbmltcG9ydCB7XHJcbiAgZ2V0QkJveCxcclxuICBnZXRQYXJlbnRzXHJcbn0gZnJvbSAnLi4vLi4vLi4vdXRpbC9FbGVtZW50cyc7XHJcblxyXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ3JlYXRlRWxlbWVudHNIYW5kbGVyKG1vZGVsaW5nKSB7XHJcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcclxufVxyXG5cclxuQ3JlYXRlRWxlbWVudHNIYW5kbGVyLiRpbmplY3QgPSBbXHJcbiAgJ21vZGVsaW5nJ1xyXG5dO1xyXG5cclxuQ3JlYXRlRWxlbWVudHNIYW5kbGVyLnByb3RvdHlwZS5wcmVFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG4gIHZhciBlbGVtZW50cyA9IGNvbnRleHQuZWxlbWVudHMsXHJcbiAgICAgIHBhcmVudCA9IGNvbnRleHQucGFyZW50LFxyXG4gICAgICBwYXJlbnRJbmRleCA9IGNvbnRleHQucGFyZW50SW5kZXgsXHJcbiAgICAgIHBvc2l0aW9uID0gY29udGV4dC5wb3NpdGlvbixcclxuICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzO1xyXG5cclxuICB2YXIgbW9kZWxpbmcgPSB0aGlzLl9tb2RlbGluZztcclxuXHJcbiAgLy8gbWFrZSBzdXJlIGVhY2ggZWxlbWVudCBoYXMgeCBhbmQgeVxyXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGlmICghaXNOdW1iZXIoZWxlbWVudC54KSkge1xyXG4gICAgICBlbGVtZW50LnggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNOdW1iZXIoZWxlbWVudC55KSkge1xyXG4gICAgICBlbGVtZW50LnkgPSAwO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICB2YXIgYmJveCA9IGdldEJCb3goZWxlbWVudHMpO1xyXG5cclxuICAvLyBjZW50ZXIgZWxlbWVudHMgYXJvdW5kIHBvc2l0aW9uXHJcbiAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgaWYgKGlzQ29ubmVjdGlvbihlbGVtZW50KSkge1xyXG4gICAgICBlbGVtZW50LndheXBvaW50cyA9IG1hcChlbGVtZW50LndheXBvaW50cywgZnVuY3Rpb24od2F5cG9pbnQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgeDogcm91bmQod2F5cG9pbnQueCAtIGJib3gueCAtIGJib3gud2lkdGggLyAyICsgcG9zaXRpb24ueCksXHJcbiAgICAgICAgICB5OiByb3VuZCh3YXlwb2ludC55IC0gYmJveC55IC0gYmJveC5oZWlnaHQgLyAyICsgcG9zaXRpb24ueSlcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBhc3NpZ24oZWxlbWVudCwge1xyXG4gICAgICB4OiByb3VuZChlbGVtZW50LnggLSBiYm94LnggLSBiYm94LndpZHRoIC8gMiArIHBvc2l0aW9uLngpLFxyXG4gICAgICB5OiByb3VuZChlbGVtZW50LnkgLSBiYm94LnkgLSBiYm94LmhlaWdodCAvIDIgKyBwb3NpdGlvbi55KVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIHZhciBwYXJlbnRzID0gZ2V0UGFyZW50cyhlbGVtZW50cyk7XHJcblxyXG4gIHZhciBjYWNoZSA9IHt9O1xyXG5cclxuICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICBpZiAoaXNDb25uZWN0aW9uKGVsZW1lbnQpKSB7XHJcbiAgICAgIGNhY2hlWyBlbGVtZW50LmlkIF0gPSBpc051bWJlcihwYXJlbnRJbmRleCkgP1xyXG4gICAgICAgIG1vZGVsaW5nLmNyZWF0ZUNvbm5lY3Rpb24oXHJcbiAgICAgICAgICBjYWNoZVsgZWxlbWVudC5zb3VyY2UuaWQgXSxcclxuICAgICAgICAgIGNhY2hlWyBlbGVtZW50LnRhcmdldC5pZCBdLFxyXG4gICAgICAgICAgcGFyZW50SW5kZXgsXHJcbiAgICAgICAgICBlbGVtZW50LFxyXG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgfHwgcGFyZW50LFxyXG4gICAgICAgICAgaGludHNcclxuICAgICAgICApIDpcclxuICAgICAgICBtb2RlbGluZy5jcmVhdGVDb25uZWN0aW9uKFxyXG4gICAgICAgICAgY2FjaGVbIGVsZW1lbnQuc291cmNlLmlkIF0sXHJcbiAgICAgICAgICBjYWNoZVsgZWxlbWVudC50YXJnZXQuaWQgXSxcclxuICAgICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCB8fCBwYXJlbnQsXHJcbiAgICAgICAgICBoaW50c1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNyZWF0ZVNoYXBlSGludHMgPSBhc3NpZ24oe30sIGhpbnRzKTtcclxuXHJcbiAgICBpZiAocGFyZW50cy5pbmRleE9mKGVsZW1lbnQpID09PSAtMSkge1xyXG4gICAgICBjcmVhdGVTaGFwZUhpbnRzLmF1dG9SZXNpemUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjYWNoZVsgZWxlbWVudC5pZCBdID0gaXNOdW1iZXIocGFyZW50SW5kZXgpID9cclxuICAgICAgbW9kZWxpbmcuY3JlYXRlU2hhcGUoXHJcbiAgICAgICAgZWxlbWVudCxcclxuICAgICAgICBwaWNrKGVsZW1lbnQsIFsgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnIF0pLFxyXG4gICAgICAgIGVsZW1lbnQucGFyZW50IHx8IHBhcmVudCxcclxuICAgICAgICBwYXJlbnRJbmRleCxcclxuICAgICAgICBjcmVhdGVTaGFwZUhpbnRzXHJcbiAgICAgICkgOlxyXG4gICAgICBtb2RlbGluZy5jcmVhdGVTaGFwZShcclxuICAgICAgICBlbGVtZW50LFxyXG4gICAgICAgIHBpY2soZWxlbWVudCwgWyAneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcgXSksXHJcbiAgICAgICAgZWxlbWVudC5wYXJlbnQgfHwgcGFyZW50LFxyXG4gICAgICAgIGNyZWF0ZVNoYXBlSGludHNcclxuICAgICAgKTtcclxuICB9KTtcclxuXHJcbiAgY29udGV4dC5lbGVtZW50cyA9IHZhbHVlcyhjYWNoZSk7XHJcbn07XHJcblxyXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cclxuXHJcbmZ1bmN0aW9uIGlzQ29ubmVjdGlvbihlbGVtZW50KSB7XHJcbiAgcmV0dXJuICEhZWxlbWVudC53YXlwb2ludHM7XHJcbn0iLCJpbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgQ3JlYXRlU2hhcGVIYW5kbGVyIGZyb20gJy4vQ3JlYXRlU2hhcGVIYW5kbGVyJztcblxuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IGF0dGFjaGVzIGEgbGFiZWwgdG8gYSBnaXZlbiB0YXJnZXQgc2hhcGUuXG4gKlxuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDcmVhdGVMYWJlbEhhbmRsZXIoY2FudmFzKSB7XG4gIENyZWF0ZVNoYXBlSGFuZGxlci5jYWxsKHRoaXMsIGNhbnZhcyk7XG59XG5cbmluaGVyaXRzKENyZWF0ZUxhYmVsSGFuZGxlciwgQ3JlYXRlU2hhcGVIYW5kbGVyKTtcblxuQ3JlYXRlTGFiZWxIYW5kbGVyLiRpbmplY3QgPSBbICdjYW52YXMnIF07XG5cblxuLy8gYXBpIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgb3JpZ2luYWxFeGVjdXRlID0gQ3JlYXRlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlO1xuXG4vKipcbiAqIEFwcGVuZHMgYSBsYWJlbCB0byBhIHRhcmdldCBzaGFwZS5cbiAqXG4gKiBAbWV0aG9kIENyZWF0ZUxhYmVsSGFuZGxlciNleGVjdXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudERlc2NyaXB0b3J9IGNvbnRleHQudGFyZ2V0IHRoZSBlbGVtZW50IHRoZSBsYWJlbCBpcyBhdHRhY2hlZCB0b1xuICogQHBhcmFtIHtFbGVtZW50RGVzY3JpcHRvcn0gY29udGV4dC5wYXJlbnQgdGhlIHBhcmVudCBvYmplY3RcbiAqIEBwYXJhbSB7UG9pbnR9IGNvbnRleHQucG9zaXRpb24gcG9zaXRpb24gb2YgdGhlIG5ldyBlbGVtZW50XG4gKi9cbkNyZWF0ZUxhYmVsSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgbGFiZWwgPSBjb250ZXh0LnNoYXBlO1xuXG4gIGVuc3VyZVZhbGlkRGltZW5zaW9ucyhsYWJlbCk7XG5cbiAgbGFiZWwubGFiZWxUYXJnZXQgPSBjb250ZXh0LmxhYmVsVGFyZ2V0O1xuXG4gIHJldHVybiBvcmlnaW5hbEV4ZWN1dGUuY2FsbCh0aGlzLCBjb250ZXh0KTtcbn07XG5cbnZhciBvcmlnaW5hbFJldmVydCA9IENyZWF0ZVNoYXBlSGFuZGxlci5wcm90b3R5cGUucmV2ZXJ0O1xuXG4vKipcbiAqIFVuZG8gYXBwZW5kIGJ5IHJlbW92aW5nIHRoZSBzaGFwZVxuICovXG5DcmVhdGVMYWJlbEhhbmRsZXIucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29udGV4dC5zaGFwZS5sYWJlbFRhcmdldCA9IG51bGw7XG5cbiAgcmV0dXJuIG9yaWdpbmFsUmV2ZXJ0LmNhbGwodGhpcywgY29udGV4dCk7XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBlbnN1cmVWYWxpZERpbWVuc2lvbnMobGFiZWwpIHtcblxuICAvLyBtYWtlIHN1cmUgYSBsYWJlbCBoYXMgdmFsaWQgeyB3aWR0aCwgaGVpZ2h0IH0gZGltZW5zaW9uc1xuICBbICd3aWR0aCcsICdoZWlnaHQnIF0uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBsYWJlbFtwcm9wXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxhYmVsW3Byb3BdID0gMDtcbiAgICB9XG4gIH0pO1xufSIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ21pbi1kYXNoJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IGltcGxlbWVudHMgcmV2ZXJzaWJsZSBhZGRpdGlvbiBvZiBzaGFwZXMuXG4gKlxuICogQHBhcmFtIHtjYW52YXN9IENhbnZhc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDcmVhdGVTaGFwZUhhbmRsZXIoY2FudmFzKSB7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbn1cblxuQ3JlYXRlU2hhcGVIYW5kbGVyLiRpbmplY3QgPSBbICdjYW52YXMnIF07XG5cblxuLy8gYXBpIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vKipcbiAqIEFwcGVuZHMgYSBzaGFwZSB0byBhIHRhcmdldCBzaGFwZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5CYXNlfSBjb250ZXh0LnBhcmVudCB0aGUgcGFyZW50IG9iamVjdFxuICogQHBhcmFtIHtQb2ludH0gY29udGV4dC5wb3NpdGlvbiBwb3NpdGlvbiBvZiB0aGUgbmV3IGVsZW1lbnRcbiAqL1xuQ3JlYXRlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICBwb3NpdGlvbk9yQm91bmRzID0gY29udGV4dC5wb3NpdGlvbixcbiAgICAgIHBhcmVudCA9IGNvbnRleHQucGFyZW50LFxuICAgICAgcGFyZW50SW5kZXggPSBjb250ZXh0LnBhcmVudEluZGV4O1xuXG4gIGlmICghcGFyZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXJlbnQgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIGlmICghcG9zaXRpb25PckJvdW5kcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncG9zaXRpb24gcmVxdWlyZWQnKTtcbiAgfVxuXG4gIC8vICgxKSBhZGQgYXQgZXZlbnQgY2VudGVyIHBvc2l0aW9uIF9vcl8gYXQgZ2l2ZW4gYm91bmRzXG4gIGlmIChwb3NpdGlvbk9yQm91bmRzLndpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NpZ24oc2hhcGUsIHBvc2l0aW9uT3JCb3VuZHMpO1xuICB9IGVsc2Uge1xuICAgIGFzc2lnbihzaGFwZSwge1xuICAgICAgeDogcG9zaXRpb25PckJvdW5kcy54IC0gcm91bmQoc2hhcGUud2lkdGggLyAyKSxcbiAgICAgIHk6IHBvc2l0aW9uT3JCb3VuZHMueSAtIHJvdW5kKHNoYXBlLmhlaWdodCAvIDIpXG4gICAgfSk7XG4gIH1cblxuICAvLyAoMikgYWRkIHRvIGNhbnZhc1xuICB0aGlzLl9jYW52YXMuYWRkU2hhcGUoc2hhcGUsIHBhcmVudCwgcGFyZW50SW5kZXgpO1xuXG4gIHJldHVybiBzaGFwZTtcbn07XG5cblxuLyoqXG4gKiBVbmRvIGFwcGVuZCBieSByZW1vdmluZyB0aGUgc2hhcGVcbiAqL1xuQ3JlYXRlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZTtcblxuICAvLyAoMykgcmVtb3ZlIGZvcm0gY2FudmFzXG4gIHRoaXMuX2NhbnZhcy5yZW1vdmVTaGFwZShzaGFwZSk7XG5cbiAgcmV0dXJuIHNoYXBlO1xufTsiLCJpbXBvcnQge1xuICBhZGQgYXMgY29sbGVjdGlvbkFkZCxcbiAgaW5kZXhPZiBhcyBjb2xsZWN0aW9uSWR4XG59IGZyb20gJy4uLy4uLy4uL3V0aWwvQ29sbGVjdGlvbnMnO1xuXG5cbi8qKlxuICogQSBoYW5kbGVyIHRoYXQgaW1wbGVtZW50cyByZXZlcnNpYmxlIGRlbGV0aW9uIG9mIENvbm5lY3Rpb25zLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWxldGVDb25uZWN0aW9uSGFuZGxlcihjYW52YXMsIG1vZGVsaW5nKSB7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbn1cblxuRGVsZXRlQ29ubmVjdGlvbkhhbmRsZXIuJGluamVjdCA9IFtcbiAgJ2NhbnZhcycsXG4gICdtb2RlbGluZydcbl07XG5cblxuRGVsZXRlQ29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICBwYXJlbnQgPSBjb25uZWN0aW9uLnBhcmVudDtcblxuICBjb250ZXh0LnBhcmVudCA9IHBhcmVudDtcblxuICAvLyByZW1lbWJlciBjb250YWlubWVudFxuICBjb250ZXh0LnBhcmVudEluZGV4ID0gY29sbGVjdGlvbklkeChwYXJlbnQuY2hpbGRyZW4sIGNvbm5lY3Rpb24pO1xuXG4gIGNvbnRleHQuc291cmNlID0gY29ubmVjdGlvbi5zb3VyY2U7XG4gIGNvbnRleHQudGFyZ2V0ID0gY29ubmVjdGlvbi50YXJnZXQ7XG5cbiAgdGhpcy5fY2FudmFzLnJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbik7XG5cbiAgY29ubmVjdGlvbi5zb3VyY2UgPSBudWxsO1xuICBjb25uZWN0aW9uLnRhcmdldCA9IG51bGw7XG5cbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG4vKipcbiAqIENvbW1hbmQgcmV2ZXJ0IGltcGxlbWVudGF0aW9uLlxuICovXG5EZWxldGVDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgcGFyZW50ID0gY29udGV4dC5wYXJlbnQsXG4gICAgICBwYXJlbnRJbmRleCA9IGNvbnRleHQucGFyZW50SW5kZXg7XG5cbiAgY29ubmVjdGlvbi5zb3VyY2UgPSBjb250ZXh0LnNvdXJjZTtcbiAgY29ubmVjdGlvbi50YXJnZXQgPSBjb250ZXh0LnRhcmdldDtcblxuICAvLyByZXN0b3JlIGNvbnRhaW5tZW50XG4gIGNvbGxlY3Rpb25BZGQocGFyZW50LmNoaWxkcmVuLCBjb25uZWN0aW9uLCBwYXJlbnRJbmRleCk7XG5cbiAgdGhpcy5fY2FudmFzLmFkZENvbm5lY3Rpb24oY29ubmVjdGlvbiwgcGFyZW50KTtcblxuICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG4iLCJpbXBvcnQgeyBmb3JFYWNoIH0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERlbGV0ZUVsZW1lbnRzSGFuZGxlcihtb2RlbGluZywgZWxlbWVudFJlZ2lzdHJ5KSB7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG4gIHRoaXMuX2VsZW1lbnRSZWdpc3RyeSA9IGVsZW1lbnRSZWdpc3RyeTtcbn1cblxuRGVsZXRlRWxlbWVudHNIYW5kbGVyLiRpbmplY3QgPSBbXG4gICdtb2RlbGluZycsXG4gICdlbGVtZW50UmVnaXN0cnknXG5dO1xuXG5cbkRlbGV0ZUVsZW1lbnRzSGFuZGxlci5wcm90b3R5cGUucG9zdEV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIG1vZGVsaW5nID0gdGhpcy5fbW9kZWxpbmcsXG4gICAgICBlbGVtZW50UmVnaXN0cnkgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnksXG4gICAgICBlbGVtZW50cyA9IGNvbnRleHQuZWxlbWVudHM7XG5cbiAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQgd2l0aCBwcmV2aW91c1xuICAgIC8vIHJlbW92ZSBvcGVyYXRpb25zIGFscmVhZHkgKGUuZy4gaW4gY2FzZSBvZiBuZXN0aW5nKVxuICAgIGlmICghZWxlbWVudFJlZ2lzdHJ5LmdldChlbGVtZW50LmlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LndheXBvaW50cykge1xuICAgICAgbW9kZWxpbmcucmVtb3ZlQ29ubmVjdGlvbihlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWxpbmcucmVtb3ZlU2hhcGUoZWxlbWVudCk7XG4gICAgfVxuICB9KTtcbn07IiwiaW1wb3J0IHtcbiAgYWRkIGFzIGNvbGxlY3Rpb25BZGQsXG4gIGluZGV4T2YgYXMgY29sbGVjdGlvbklkeFxufSBmcm9tICcuLi8uLi8uLi91dGlsL0NvbGxlY3Rpb25zJztcblxuaW1wb3J0IHsgc2F2ZUNsZWFyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9SZW1vdmFsJztcblxuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IGltcGxlbWVudHMgcmV2ZXJzaWJsZSBkZWxldGlvbiBvZiBzaGFwZXMuXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWxldGVTaGFwZUhhbmRsZXIoY2FudmFzLCBtb2RlbGluZykge1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG59XG5cbkRlbGV0ZVNoYXBlSGFuZGxlci4kaW5qZWN0ID0gWyAnY2FudmFzJywgJ21vZGVsaW5nJyBdO1xuXG5cbi8qKlxuICogLSBSZW1vdmUgY29ubmVjdGlvbnNcbiAqIC0gUmVtb3ZlIGFsbCBkaXJlY3QgY2hpbGRyZW5cbiAqL1xuRGVsZXRlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5wcmVFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBtb2RlbGluZyA9IHRoaXMuX21vZGVsaW5nO1xuXG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGU7XG5cbiAgLy8gcmVtb3ZlIGNvbm5lY3Rpb25zXG4gIHNhdmVDbGVhcihzaGFwZS5pbmNvbWluZywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuXG4gICAgLy8gVG8gbWFrZSBzdXJlIHRoYXQgdGhlIGNvbm5lY3Rpb24gaXNuJ3QgcmVtb3ZlZCB0d2ljZVxuICAgIC8vIEZvciBleGFtcGxlIGlmIGEgY29udGFpbmVyIGlzIHJlbW92ZWRcbiAgICBtb2RlbGluZy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24sIHsgbmVzdGVkOiB0cnVlIH0pO1xuICB9KTtcblxuICBzYXZlQ2xlYXIoc2hhcGUub3V0Z29pbmcsIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICBtb2RlbGluZy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24sIHsgbmVzdGVkOiB0cnVlIH0pO1xuICB9KTtcblxuICAvLyByZW1vdmUgY2hpbGQgc2hhcGVzIGFuZCBjb25uZWN0aW9uc1xuICBzYXZlQ2xlYXIoc2hhcGUuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgaWYgKGlzQ29ubmVjdGlvbihjaGlsZCkpIHtcbiAgICAgIG1vZGVsaW5nLnJlbW92ZUNvbm5lY3Rpb24oY2hpbGQsIHsgbmVzdGVkOiB0cnVlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbGluZy5yZW1vdmVTaGFwZShjaGlsZCwgeyBuZXN0ZWQ6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHNoYXBlIGFuZCByZW1lbWJlciB0aGUgcGFyZW50XG4gKi9cbkRlbGV0ZVNoYXBlSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblxuICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgb2xkUGFyZW50ID0gc2hhcGUucGFyZW50O1xuXG4gIGNvbnRleHQub2xkUGFyZW50ID0gb2xkUGFyZW50O1xuXG4gIC8vIHJlbW92ZSBjb250YWlubWVudFxuICBjb250ZXh0Lm9sZFBhcmVudEluZGV4ID0gY29sbGVjdGlvbklkeChvbGRQYXJlbnQuY2hpbGRyZW4sIHNoYXBlKTtcblxuICAvLyByZW1vdmUgc2hhcGVcbiAgY2FudmFzLnJlbW92ZVNoYXBlKHNoYXBlKTtcblxuICByZXR1cm4gc2hhcGU7XG59O1xuXG5cbi8qKlxuICogQ29tbWFuZCByZXZlcnQgaW1wbGVtZW50YXRpb25cbiAqL1xuRGVsZXRlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblxuICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgb2xkUGFyZW50ID0gY29udGV4dC5vbGRQYXJlbnQsXG4gICAgICBvbGRQYXJlbnRJbmRleCA9IGNvbnRleHQub2xkUGFyZW50SW5kZXg7XG5cbiAgLy8gcmVzdG9yZSBjb250YWlubWVudFxuICBjb2xsZWN0aW9uQWRkKG9sZFBhcmVudC5jaGlsZHJlbiwgc2hhcGUsIG9sZFBhcmVudEluZGV4KTtcblxuICBjYW52YXMuYWRkU2hhcGUoc2hhcGUsIG9sZFBhcmVudCk7XG5cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuZnVuY3Rpb24gaXNDb25uZWN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQud2F5cG9pbnRzO1xufVxuIiwiaW1wb3J0IHtcbiAgZm9yRWFjaCxcbiAgc29ydEJ5XG59IGZyb20gJ21pbi1kYXNoJztcblxuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IGRpc3RyaWJ1dGVzIGVsZW1lbnRzIGV2ZW5seS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGlzdHJpYnV0ZUVsZW1lbnRzKG1vZGVsaW5nKSB7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG59XG5cbkRpc3RyaWJ1dGVFbGVtZW50cy4kaW5qZWN0ID0gWyAnbW9kZWxpbmcnIF07XG5cbnZhciBPRkZfQVhJUyA9IHtcbiAgeDogJ3knLFxuICB5OiAneCdcbn07XG5cbkRpc3RyaWJ1dGVFbGVtZW50cy5wcm90b3R5cGUucHJlRXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIG1vZGVsaW5nID0gdGhpcy5fbW9kZWxpbmc7XG5cbiAgdmFyIGdyb3VwcyA9IGNvbnRleHQuZ3JvdXBzLFxuICAgICAgYXhpcyA9IGNvbnRleHQuYXhpcyxcbiAgICAgIGRpbWVuc2lvbiA9IGNvbnRleHQuZGltZW5zaW9uO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVJhbmdlKGdyb3VwLCBlbGVtZW50KSB7XG4gICAgZ3JvdXAucmFuZ2UubWluID0gTWF0aC5taW4oZWxlbWVudFtheGlzXSwgZ3JvdXAucmFuZ2UubWluKTtcbiAgICBncm91cC5yYW5nZS5tYXggPSBNYXRoLm1heChlbGVtZW50W2F4aXNdICsgZWxlbWVudFtkaW1lbnNpb25dLCBncm91cC5yYW5nZS5tYXgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudGVyKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudFtheGlzXSArIGVsZW1lbnRbZGltZW5zaW9uXSAvIDI7XG4gIH1cblxuICBmdW5jdGlvbiBsYXN0SWR4KGFycikge1xuICAgIHJldHVybiBhcnIubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbmdlRGlmZihyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS5tYXggLSByYW5nZS5taW47XG4gIH1cblxuICBmdW5jdGlvbiBjZW50ZXJFbGVtZW50KHJlZkNlbnRlciwgZWxlbWVudCkge1xuICAgIHZhciBkZWx0YSA9IHsgeTogMCB9O1xuXG4gICAgZGVsdGFbYXhpc10gPSByZWZDZW50ZXIgLSBjZW50ZXIoZWxlbWVudCk7XG5cbiAgICBpZiAoZGVsdGFbYXhpc10pIHtcblxuICAgICAgZGVsdGFbT0ZGX0FYSVNbYXhpc11dID0gMDtcblxuICAgICAgbW9kZWxpbmcubW92ZUVsZW1lbnRzKFsgZWxlbWVudCBdLCBkZWx0YSwgZWxlbWVudC5wYXJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaXJzdEdyb3VwID0gZ3JvdXBzWzBdLFxuICAgICAgbGFzdEdyb3VwSWR4ID0gbGFzdElkeChncm91cHMpLFxuICAgICAgbGFzdEdyb3VwID0gZ3JvdXBzWyBsYXN0R3JvdXBJZHggXTtcblxuICB2YXIgbWFyZ2luLFxuICAgICAgc3BhY2VJbkJldHdlZW4sXG4gICAgICBncm91cHNTaXplID0gMDsgLy8gdGhlIHNpemUgb2YgZWFjaCByYW5nZVxuXG4gIGZvckVhY2goZ3JvdXBzLCBmdW5jdGlvbihncm91cCwgaWR4KSB7XG4gICAgdmFyIHNvcnRlZEVsZW1lbnRzLFxuICAgICAgICByZWZFbGVtLFxuICAgICAgICByZWZDZW50ZXI7XG5cbiAgICBpZiAoZ3JvdXAuZWxlbWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKGlkeCAmJiBpZHggIT09IGdyb3Vwcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHVwZGF0ZVJhbmdlKGdyb3VwLCBncm91cC5lbGVtZW50c1swXSk7XG5cbiAgICAgICAgZ3JvdXBzU2l6ZSArPSByYW5nZURpZmYoZ3JvdXAucmFuZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNvcnRlZEVsZW1lbnRzID0gc29ydEJ5KGdyb3VwLmVsZW1lbnRzLCBheGlzKTtcblxuICAgIHJlZkVsZW0gPSBzb3J0ZWRFbGVtZW50c1swXTtcblxuICAgIGlmIChpZHggPT09IGxhc3RHcm91cElkeCkge1xuICAgICAgcmVmRWxlbSA9IHNvcnRlZEVsZW1lbnRzW2xhc3RJZHgoc29ydGVkRWxlbWVudHMpXTtcbiAgICB9XG5cbiAgICByZWZDZW50ZXIgPSBjZW50ZXIocmVmRWxlbSk7XG5cbiAgICAvLyB3YW5uYSB1cGRhdGUgdGhlIHJhbmdlcyBhZnRlciB0aGUgc2hhcGVzIGhhdmUgYmVlbiBjZW50ZXJlZFxuICAgIGdyb3VwLnJhbmdlID0gbnVsbDtcblxuICAgIGZvckVhY2goc29ydGVkRWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgICAgY2VudGVyRWxlbWVudChyZWZDZW50ZXIsIGVsZW1lbnQpO1xuXG4gICAgICBpZiAoZ3JvdXAucmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgZ3JvdXAucmFuZ2UgPSB7XG4gICAgICAgICAgbWluOiBlbGVtZW50W2F4aXNdLFxuICAgICAgICAgIG1heDogZWxlbWVudFtheGlzXSArIGVsZW1lbnRbZGltZW5zaW9uXVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIGdyb3VwJ3MgcmFuZ2UgYWZ0ZXIgY2VudGVyaW5nIHRoZSByYW5nZSBlbGVtZW50c1xuICAgICAgdXBkYXRlUmFuZ2UoZ3JvdXAsIGVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgaWYgKGlkeCAmJiBpZHggIT09IGdyb3Vwcy5sZW5ndGggLSAxKSB7XG4gICAgICBncm91cHNTaXplICs9IHJhbmdlRGlmZihncm91cC5yYW5nZSk7XG4gICAgfVxuICB9KTtcblxuICBzcGFjZUluQmV0d2VlbiA9IE1hdGguYWJzKGxhc3RHcm91cC5yYW5nZS5taW4gLSBmaXJzdEdyb3VwLnJhbmdlLm1heCk7XG5cbiAgbWFyZ2luID0gTWF0aC5yb3VuZCgoc3BhY2VJbkJldHdlZW4gLSBncm91cHNTaXplKSAvIChncm91cHMubGVuZ3RoIC0gMSkpO1xuXG4gIGlmIChtYXJnaW4gPCBncm91cHMubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2goZ3JvdXBzLCBmdW5jdGlvbihncm91cCwgZ3JvdXBJZHgpIHtcbiAgICB2YXIgZGVsdGEgPSB7fSxcbiAgICAgICAgcHJldkdyb3VwO1xuXG4gICAgaWYgKGdyb3VwID09PSBmaXJzdEdyb3VwIHx8IGdyb3VwID09PSBsYXN0R3JvdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcmV2R3JvdXAgPSBncm91cHNbZ3JvdXBJZHggLSAxXTtcblxuICAgIGdyb3VwLnJhbmdlLm1heCA9IDA7XG5cbiAgICBmb3JFYWNoKGdyb3VwLmVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50LCBpZHgpIHtcbiAgICAgIGRlbHRhW09GRl9BWElTW2F4aXNdXSA9IDA7XG4gICAgICBkZWx0YVtheGlzXSA9IChwcmV2R3JvdXAucmFuZ2UubWF4IC0gZWxlbWVudFtheGlzXSkgKyBtYXJnaW47XG5cbiAgICAgIGlmIChncm91cC5yYW5nZS5taW4gIT09IGVsZW1lbnRbYXhpc10pIHtcbiAgICAgICAgZGVsdGFbYXhpc10gKz0gZWxlbWVudFtheGlzXSAtIGdyb3VwLnJhbmdlLm1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbHRhW2F4aXNdKSB7XG4gICAgICAgIG1vZGVsaW5nLm1vdmVFbGVtZW50cyhbIGVsZW1lbnQgXSwgZGVsdGEsIGVsZW1lbnQucGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgZ3JvdXAucmFuZ2UubWF4ID0gTWF0aC5tYXgoZWxlbWVudFtheGlzXSArIGVsZW1lbnRbZGltZW5zaW9uXSwgaWR4ID8gZ3JvdXAucmFuZ2UubWF4IDogMCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuRGlzdHJpYnV0ZUVsZW1lbnRzLnByb3RvdHlwZS5wb3N0RXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxufTtcbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ21pbi1kYXNoJztcblxuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IGltcGxlbWVudHMgcmV2ZXJzaWJsZSBtb3Zpbmcgb2Ygc2hhcGVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYXlvdXRDb25uZWN0aW9uSGFuZGxlcihsYXlvdXRlciwgY2FudmFzKSB7XG4gIHRoaXMuX2xheW91dGVyID0gbGF5b3V0ZXI7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbn1cblxuTGF5b3V0Q29ubmVjdGlvbkhhbmRsZXIuJGluamVjdCA9IFsgJ2xheW91dGVyJywgJ2NhbnZhcycgXTtcblxuTGF5b3V0Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb247XG5cbiAgdmFyIG9sZFdheXBvaW50cyA9IGNvbm5lY3Rpb24ud2F5cG9pbnRzO1xuXG4gIGFzc2lnbihjb250ZXh0LCB7XG4gICAgb2xkV2F5cG9pbnRzOiBvbGRXYXlwb2ludHNcbiAgfSk7XG5cbiAgY29ubmVjdGlvbi53YXlwb2ludHMgPSB0aGlzLl9sYXlvdXRlci5sYXlvdXRDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGNvbnRleHQuaGludHMpO1xuXG4gIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuTGF5b3V0Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbjtcblxuICBjb25uZWN0aW9uLndheXBvaW50cyA9IGNvbnRleHQub2xkV2F5cG9pbnRzO1xuXG4gIHJldHVybiBjb25uZWN0aW9uO1xufTtcbiIsImltcG9ydCB7IGZvckVhY2ggfSBmcm9tICdtaW4tZGFzaCc7XG5cblxuaW1wb3J0IHtcbiAgYWRkIGFzIGNvbGxlY3Rpb25BZGQsXG4gIHJlbW92ZSBhcyBjb2xsZWN0aW9uUmVtb3ZlXG59IGZyb20gJy4uLy4uLy4uL3V0aWwvQ29sbGVjdGlvbnMnO1xuXG5cbi8qKlxuICogQSBoYW5kbGVyIHRoYXQgaW1wbGVtZW50cyByZXZlcnNpYmxlIG1vdmluZyBvZiBjb25uZWN0aW9ucy5cbiAqXG4gKiBUaGUgaGFuZGxlciBkaWZmZXJzIGZyb20gdGhlIGxheW91dCBjb25uZWN0aW9uIGhhbmRsZXIgaW4gYSBzZW5zZVxuICogdGhhdCBpdCBwcmVzZXJ2ZXMgdGhlIGNvbm5lY3Rpb24gbGF5b3V0LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNb3ZlQ29ubmVjdGlvbkhhbmRsZXIoKSB7IH1cblxuXG5Nb3ZlQ29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb24sXG4gICAgICBkZWx0YSA9IGNvbnRleHQuZGVsdGE7XG5cbiAgdmFyIG5ld1BhcmVudCA9IGNvbnRleHQubmV3UGFyZW50IHx8IGNvbm5lY3Rpb24ucGFyZW50LFxuICAgICAgbmV3UGFyZW50SW5kZXggPSBjb250ZXh0Lm5ld1BhcmVudEluZGV4LFxuICAgICAgb2xkUGFyZW50ID0gY29ubmVjdGlvbi5wYXJlbnQ7XG5cbiAgLy8gc2F2ZSBvbGQgcGFyZW50IGluIGNvbnRleHRcbiAgY29udGV4dC5vbGRQYXJlbnQgPSBvbGRQYXJlbnQ7XG4gIGNvbnRleHQub2xkUGFyZW50SW5kZXggPSBjb2xsZWN0aW9uUmVtb3ZlKG9sZFBhcmVudC5jaGlsZHJlbiwgY29ubmVjdGlvbik7XG5cbiAgLy8gYWRkIHRvIG5ldyBwYXJlbnQgYXQgcG9zaXRpb25cbiAgY29sbGVjdGlvbkFkZChuZXdQYXJlbnQuY2hpbGRyZW4sIGNvbm5lY3Rpb24sIG5ld1BhcmVudEluZGV4KTtcblxuICAvLyB1cGRhdGUgcGFyZW50XG4gIGNvbm5lY3Rpb24ucGFyZW50ID0gbmV3UGFyZW50O1xuXG4gIC8vIHVwZGF0ZSB3YXlwb2ludCBwb3NpdGlvbnNcbiAgZm9yRWFjaChjb25uZWN0aW9uLndheXBvaW50cywgZnVuY3Rpb24ocCkge1xuICAgIHAueCArPSBkZWx0YS54O1xuICAgIHAueSArPSBkZWx0YS55O1xuXG4gICAgaWYgKHAub3JpZ2luYWwpIHtcbiAgICAgIHAub3JpZ2luYWwueCArPSBkZWx0YS54O1xuICAgICAgcC5vcmlnaW5hbC55ICs9IGRlbHRhLnk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG5cbk1vdmVDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgbmV3UGFyZW50ID0gY29ubmVjdGlvbi5wYXJlbnQsXG4gICAgICBvbGRQYXJlbnQgPSBjb250ZXh0Lm9sZFBhcmVudCxcbiAgICAgIG9sZFBhcmVudEluZGV4ID0gY29udGV4dC5vbGRQYXJlbnRJbmRleCxcbiAgICAgIGRlbHRhID0gY29udGV4dC5kZWx0YTtcblxuICAvLyByZW1vdmUgZnJvbSBuZXdQYXJlbnRcbiAgY29sbGVjdGlvblJlbW92ZShuZXdQYXJlbnQuY2hpbGRyZW4sIGNvbm5lY3Rpb24pO1xuXG4gIC8vIHJlc3RvcmUgcHJldmlvdXMgbG9jYXRpb24gaW4gb2xkIHBhcmVudFxuICBjb2xsZWN0aW9uQWRkKG9sZFBhcmVudC5jaGlsZHJlbiwgY29ubmVjdGlvbiwgb2xkUGFyZW50SW5kZXgpO1xuXG4gIC8vIHJlc3RvcmUgcGFyZW50XG4gIGNvbm5lY3Rpb24ucGFyZW50ID0gb2xkUGFyZW50O1xuXG4gIC8vIHJldmVydCB0byBvbGQgd2F5cG9pbnQgcG9zaXRpb25zXG4gIGZvckVhY2goY29ubmVjdGlvbi53YXlwb2ludHMsIGZ1bmN0aW9uKHApIHtcbiAgICBwLnggLT0gZGVsdGEueDtcbiAgICBwLnkgLT0gZGVsdGEueTtcblxuICAgIGlmIChwLm9yaWdpbmFsKSB7XG4gICAgICBwLm9yaWdpbmFsLnggLT0gZGVsdGEueDtcbiAgICAgIHAub3JpZ2luYWwueSAtPSBkZWx0YS55O1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59OyIsImltcG9ydCBNb3ZlSGVscGVyIGZyb20gJy4vaGVscGVyL01vdmVIZWxwZXInO1xuXG5cbi8qKlxuICogQSBoYW5kbGVyIHRoYXQgaW1wbGVtZW50cyByZXZlcnNpYmxlIG1vdmluZyBvZiBzaGFwZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1vdmVFbGVtZW50c0hhbmRsZXIobW9kZWxpbmcpIHtcbiAgdGhpcy5faGVscGVyID0gbmV3IE1vdmVIZWxwZXIobW9kZWxpbmcpO1xufVxuXG5Nb3ZlRWxlbWVudHNIYW5kbGVyLiRpbmplY3QgPSBbICdtb2RlbGluZycgXTtcblxuTW92ZUVsZW1lbnRzSGFuZGxlci5wcm90b3R5cGUucHJlRXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29udGV4dC5jbG9zdXJlID0gdGhpcy5faGVscGVyLmdldENsb3N1cmUoY29udGV4dC5zaGFwZXMpO1xufTtcblxuTW92ZUVsZW1lbnRzSGFuZGxlci5wcm90b3R5cGUucG9zdEV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGhpbnRzID0gY29udGV4dC5oaW50cyxcbiAgICAgIHByaW1hcnlTaGFwZTtcblxuICBpZiAoaGludHMgJiYgaGludHMucHJpbWFyeVNoYXBlKSB7XG4gICAgcHJpbWFyeVNoYXBlID0gaGludHMucHJpbWFyeVNoYXBlO1xuICAgIGhpbnRzLm9sZFBhcmVudCA9IHByaW1hcnlTaGFwZS5wYXJlbnQ7XG4gIH1cblxuICB0aGlzLl9oZWxwZXIubW92ZUNsb3N1cmUoXG4gICAgY29udGV4dC5jbG9zdXJlLFxuICAgIGNvbnRleHQuZGVsdGEsXG4gICAgY29udGV4dC5uZXdQYXJlbnQsXG4gICAgY29udGV4dC5uZXdIb3N0LFxuICAgIHByaW1hcnlTaGFwZVxuICApO1xufTsiLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZvckVhY2gsXG4gIHBpY2tcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgTW92ZUhlbHBlciBmcm9tICcuL2hlbHBlci9Nb3ZlSGVscGVyJztcblxuaW1wb3J0IHtcbiAgYWRkIGFzIGNvbGxlY3Rpb25BZGQsXG4gIHJlbW92ZSBhcyBjb2xsZWN0aW9uUmVtb3ZlXG59IGZyb20gJy4uLy4uLy4uL3V0aWwvQ29sbGVjdGlvbnMnO1xuXG5pbXBvcnQge1xuICBnZXRNb3ZlZFNvdXJjZUFuY2hvcixcbiAgZ2V0TW92ZWRUYXJnZXRBbmNob3Jcbn0gZnJvbSAnLi9oZWxwZXIvQW5jaG9yc0hlbHBlcic7XG5cblxuLyoqXG4gKiBBIGhhbmRsZXIgdGhhdCBpbXBsZW1lbnRzIHJldmVyc2libGUgbW92aW5nIG9mIHNoYXBlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW92ZVNoYXBlSGFuZGxlcihtb2RlbGluZykge1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xuXG4gIHRoaXMuX2hlbHBlciA9IG5ldyBNb3ZlSGVscGVyKG1vZGVsaW5nKTtcbn1cblxuTW92ZVNoYXBlSGFuZGxlci4kaW5qZWN0ID0gWyAnbW9kZWxpbmcnIF07XG5cblxuTW92ZVNoYXBlSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgZGVsdGEgPSBjb250ZXh0LmRlbHRhLFxuICAgICAgbmV3UGFyZW50ID0gY29udGV4dC5uZXdQYXJlbnQgfHwgc2hhcGUucGFyZW50LFxuICAgICAgbmV3UGFyZW50SW5kZXggPSBjb250ZXh0Lm5ld1BhcmVudEluZGV4LFxuICAgICAgb2xkUGFyZW50ID0gc2hhcGUucGFyZW50O1xuXG4gIGNvbnRleHQub2xkQm91bmRzID0gcGljayhzaGFwZSwgWyAneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddKTtcblxuICAvLyBzYXZlIG9sZCBwYXJlbnQgaW4gY29udGV4dFxuICBjb250ZXh0Lm9sZFBhcmVudCA9IG9sZFBhcmVudDtcbiAgY29udGV4dC5vbGRQYXJlbnRJbmRleCA9IGNvbGxlY3Rpb25SZW1vdmUob2xkUGFyZW50LmNoaWxkcmVuLCBzaGFwZSk7XG5cbiAgLy8gYWRkIHRvIG5ldyBwYXJlbnQgYXQgcG9zaXRpb25cbiAgY29sbGVjdGlvbkFkZChuZXdQYXJlbnQuY2hpbGRyZW4sIHNoYXBlLCBuZXdQYXJlbnRJbmRleCk7XG5cbiAgLy8gdXBkYXRlIHNoYXBlIHBhcmVudCArIHBvc2l0aW9uXG4gIGFzc2lnbihzaGFwZSwge1xuICAgIHBhcmVudDogbmV3UGFyZW50LFxuICAgIHg6IHNoYXBlLnggKyBkZWx0YS54LFxuICAgIHk6IHNoYXBlLnkgKyBkZWx0YS55XG4gIH0pO1xuXG4gIHJldHVybiBzaGFwZTtcbn07XG5cbk1vdmVTaGFwZUhhbmRsZXIucHJvdG90eXBlLnBvc3RFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICBkZWx0YSA9IGNvbnRleHQuZGVsdGEsXG4gICAgICBoaW50cyA9IGNvbnRleHQuaGludHM7XG5cbiAgdmFyIG1vZGVsaW5nID0gdGhpcy5fbW9kZWxpbmc7XG5cbiAgaWYgKGhpbnRzLmxheW91dCAhPT0gZmFsc2UpIHtcblxuICAgIGZvckVhY2goc2hhcGUuaW5jb21pbmcsIGZ1bmN0aW9uKGMpIHtcbiAgICAgIG1vZGVsaW5nLmxheW91dENvbm5lY3Rpb24oYywge1xuICAgICAgICBjb25uZWN0aW9uRW5kOiBnZXRNb3ZlZFRhcmdldEFuY2hvcihjLCBzaGFwZSwgZGVsdGEpXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZvckVhY2goc2hhcGUub3V0Z29pbmcsIGZ1bmN0aW9uKGMpIHtcbiAgICAgIG1vZGVsaW5nLmxheW91dENvbm5lY3Rpb24oYywge1xuICAgICAgICBjb25uZWN0aW9uU3RhcnQ6IGdldE1vdmVkU291cmNlQW5jaG9yKGMsIHNoYXBlLCBkZWx0YSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGhpbnRzLnJlY3Vyc2UgIT09IGZhbHNlKSB7XG4gICAgdGhpcy5tb3ZlQ2hpbGRyZW4oY29udGV4dCk7XG4gIH1cbn07XG5cbk1vdmVTaGFwZUhhbmRsZXIucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgb2xkUGFyZW50ID0gY29udGV4dC5vbGRQYXJlbnQsXG4gICAgICBvbGRQYXJlbnRJbmRleCA9IGNvbnRleHQub2xkUGFyZW50SW5kZXgsXG4gICAgICBkZWx0YSA9IGNvbnRleHQuZGVsdGE7XG5cbiAgLy8gcmVzdG9yZSBwcmV2aW91cyBsb2NhdGlvbiBpbiBvbGQgcGFyZW50XG4gIGNvbGxlY3Rpb25BZGQob2xkUGFyZW50LmNoaWxkcmVuLCBzaGFwZSwgb2xkUGFyZW50SW5kZXgpO1xuXG4gIC8vIHJldmVydCB0byBvbGQgcG9zaXRpb24gYW5kIHBhcmVudFxuICBhc3NpZ24oc2hhcGUsIHtcbiAgICBwYXJlbnQ6IG9sZFBhcmVudCxcbiAgICB4OiBzaGFwZS54IC0gZGVsdGEueCxcbiAgICB5OiBzaGFwZS55IC0gZGVsdGEueVxuICB9KTtcblxuICByZXR1cm4gc2hhcGU7XG59O1xuXG5Nb3ZlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5tb3ZlQ2hpbGRyZW4gPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIGRlbHRhID0gY29udGV4dC5kZWx0YSxcbiAgICAgIHNoYXBlID0gY29udGV4dC5zaGFwZTtcblxuICB0aGlzLl9oZWxwZXIubW92ZVJlY3Vyc2l2ZShzaGFwZS5jaGlsZHJlbiwgZGVsdGEsIG51bGwpO1xufTtcblxuTW92ZVNoYXBlSGFuZGxlci5wcm90b3R5cGUuZ2V0TmV3UGFyZW50ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5uZXdQYXJlbnQgfHwgY29udGV4dC5zaGFwZS5wYXJlbnQ7XG59O1xuIiwiaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ21pbi1kYXNoJztcblxuXG4vKipcbiAqIFJlY29ubmVjdCBjb25uZWN0aW9uIGhhbmRsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmVjb25uZWN0Q29ubmVjdGlvbkhhbmRsZXIobW9kZWxpbmcpIHtcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbn1cblxuUmVjb25uZWN0Q29ubmVjdGlvbkhhbmRsZXIuJGluamVjdCA9IFsgJ21vZGVsaW5nJyBdO1xuXG5SZWNvbm5lY3RDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIG5ld1NvdXJjZSA9IGNvbnRleHQubmV3U291cmNlLFxuICAgICAgbmV3VGFyZ2V0ID0gY29udGV4dC5uZXdUYXJnZXQsXG4gICAgICBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgZG9ja2luZ09yUG9pbnRzID0gY29udGV4dC5kb2NraW5nT3JQb2ludHM7XG5cbiAgaWYgKCFuZXdTb3VyY2UgJiYgIW5ld1RhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbmV3U291cmNlIG9yIG5ld1RhcmdldCByZXF1aXJlZCcpO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkoZG9ja2luZ09yUG9pbnRzKSkge1xuICAgIGNvbnRleHQub2xkV2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHM7XG4gICAgY29ubmVjdGlvbi53YXlwb2ludHMgPSBkb2NraW5nT3JQb2ludHM7XG4gIH1cblxuICBpZiAobmV3U291cmNlKSB7XG4gICAgY29udGV4dC5vbGRTb3VyY2UgPSBjb25uZWN0aW9uLnNvdXJjZTtcbiAgICBjb25uZWN0aW9uLnNvdXJjZSA9IG5ld1NvdXJjZTtcbiAgfVxuXG4gIGlmIChuZXdUYXJnZXQpIHtcbiAgICBjb250ZXh0Lm9sZFRhcmdldCA9IGNvbm5lY3Rpb24udGFyZ2V0O1xuICAgIGNvbm5lY3Rpb24udGFyZ2V0ID0gbmV3VGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG5SZWNvbm5lY3RDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUucG9zdEV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgbmV3U291cmNlID0gY29udGV4dC5uZXdTb3VyY2UsXG4gICAgICBuZXdUYXJnZXQgPSBjb250ZXh0Lm5ld1RhcmdldCxcbiAgICAgIGRvY2tpbmdPclBvaW50cyA9IGNvbnRleHQuZG9ja2luZ09yUG9pbnRzLFxuICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9O1xuXG4gIHZhciBsYXlvdXRDb25uZWN0aW9uSGludHMgPSB7fTtcblxuICBpZiAoaGludHMuY29ubmVjdGlvblN0YXJ0KSB7XG4gICAgbGF5b3V0Q29ubmVjdGlvbkhpbnRzLmNvbm5lY3Rpb25TdGFydCA9IGhpbnRzLmNvbm5lY3Rpb25TdGFydDtcbiAgfVxuXG4gIGlmIChoaW50cy5jb25uZWN0aW9uRW5kKSB7XG4gICAgbGF5b3V0Q29ubmVjdGlvbkhpbnRzLmNvbm5lY3Rpb25FbmQgPSBoaW50cy5jb25uZWN0aW9uRW5kO1xuICB9XG5cbiAgaWYgKGhpbnRzLmxheW91dENvbm5lY3Rpb24gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG5ld1NvdXJjZSAmJiAoIW5ld1RhcmdldCB8fCBoaW50cy5kb2NraW5nID09PSAnc291cmNlJykpIHtcbiAgICBsYXlvdXRDb25uZWN0aW9uSGludHMuY29ubmVjdGlvblN0YXJ0ID0gbGF5b3V0Q29ubmVjdGlvbkhpbnRzLmNvbm5lY3Rpb25TdGFydFxuICAgICAgfHwgZ2V0RG9ja2luZyhpc0FycmF5KGRvY2tpbmdPclBvaW50cykgPyBkb2NraW5nT3JQb2ludHNbIDAgXSA6IGRvY2tpbmdPclBvaW50cyk7XG4gIH1cblxuICBpZiAobmV3VGFyZ2V0ICYmICghbmV3U291cmNlIHx8IGhpbnRzLmRvY2tpbmcgPT09ICd0YXJnZXQnKSkge1xuICAgIGxheW91dENvbm5lY3Rpb25IaW50cy5jb25uZWN0aW9uRW5kID0gbGF5b3V0Q29ubmVjdGlvbkhpbnRzLmNvbm5lY3Rpb25FbmRcbiAgICAgIHx8IGdldERvY2tpbmcoaXNBcnJheShkb2NraW5nT3JQb2ludHMpID8gZG9ja2luZ09yUG9pbnRzWyBkb2NraW5nT3JQb2ludHMubGVuZ3RoIC0gMSBdIDogZG9ja2luZ09yUG9pbnRzKTtcbiAgfVxuXG4gIGlmIChoaW50cy5uZXdXYXlwb2ludHMpIHtcbiAgICBsYXlvdXRDb25uZWN0aW9uSGludHMud2F5cG9pbnRzID0gaGludHMubmV3V2F5cG9pbnRzO1xuICB9XG5cbiAgdGhpcy5fbW9kZWxpbmcubGF5b3V0Q29ubmVjdGlvbihjb25uZWN0aW9uLCBsYXlvdXRDb25uZWN0aW9uSGludHMpO1xufTtcblxuUmVjb25uZWN0Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIG9sZFNvdXJjZSA9IGNvbnRleHQub2xkU291cmNlLFxuICAgICAgb2xkVGFyZ2V0ID0gY29udGV4dC5vbGRUYXJnZXQsXG4gICAgICBvbGRXYXlwb2ludHMgPSBjb250ZXh0Lm9sZFdheXBvaW50cyxcbiAgICAgIGNvbm5lY3Rpb24gPSBjb250ZXh0LmNvbm5lY3Rpb247XG5cbiAgaWYgKG9sZFNvdXJjZSkge1xuICAgIGNvbm5lY3Rpb24uc291cmNlID0gb2xkU291cmNlO1xuICB9XG5cbiAgaWYgKG9sZFRhcmdldCkge1xuICAgIGNvbm5lY3Rpb24udGFyZ2V0ID0gb2xkVGFyZ2V0O1xuICB9XG5cbiAgaWYgKG9sZFdheXBvaW50cykge1xuICAgIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gb2xkV2F5cG9pbnRzO1xuICB9XG5cbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGdldERvY2tpbmcocG9pbnQpIHtcbiAgcmV0dXJuIHBvaW50Lm9yaWdpbmFsIHx8IHBvaW50O1xufSIsImltcG9ydCB7IGZvckVhY2ggfSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGdldFJlc2l6ZWRTb3VyY2VBbmNob3IsXG4gIGdldFJlc2l6ZWRUYXJnZXRBbmNob3Jcbn0gZnJvbSAnLi9oZWxwZXIvQW5jaG9yc0hlbHBlcic7XG5cbi8qKlxuICogUmVwbGFjZSBzaGFwZSBieSBhZGRpbmcgbmV3IHNoYXBlIGFuZCByZW1vdmluZyBvbGQgc2hhcGUuIEluY29taW5nIGFuZCBvdXRnb2luZyBjb25uZWN0aW9ucyB3aWxsXG4gKiBiZSBrZXB0IGlmIHBvc3NpYmxlLlxuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtNb2RlbGluZ30gbW9kZWxpbmdcbiAqIEBwYXJhbSB7UnVsZXN9IHJ1bGVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJlcGxhY2VTaGFwZUhhbmRsZXIobW9kZWxpbmcsIHJ1bGVzKSB7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG4gIHRoaXMuX3J1bGVzID0gcnVsZXM7XG59XG5cblJlcGxhY2VTaGFwZUhhbmRsZXIuJGluamVjdCA9IFsgJ21vZGVsaW5nJywgJ3J1bGVzJyBdO1xuXG5cbi8qKlxuICogQWRkIG5ldyBzaGFwZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtkanMubW9kZWwuU2hhcGV9IGNvbnRleHQub2xkU2hhcGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0Lm5ld0RhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0Lm5ld0RhdGEudHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbnRleHQubmV3RGF0YS54XG4gKiBAcGFyYW0ge251bWJlcn0gY29udGV4dC5uZXdEYXRhLnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGludHNdXG4gKi9cblJlcGxhY2VTaGFwZUhhbmRsZXIucHJvdG90eXBlLnByZUV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIG1vZGVsaW5nID0gdGhpcy5fbW9kZWxpbmcsXG4gICAgICBydWxlcyA9IHRoaXMuX3J1bGVzO1xuXG4gIHZhciBvbGRTaGFwZSA9IGNvbnRleHQub2xkU2hhcGUsXG4gICAgICBuZXdEYXRhID0gY29udGV4dC5uZXdEYXRhLFxuICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9LFxuICAgICAgbmV3U2hhcGU7XG5cbiAgZnVuY3Rpb24gY2FuUmVjb25uZWN0KHNvdXJjZSwgdGFyZ2V0LCBjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIHJ1bGVzLmFsbG93ZWQoJ2Nvbm5lY3Rpb24ucmVjb25uZWN0Jywge1xuICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICB9KTtcbiAgfVxuXG4gIC8vICgxKSBhZGQgbmV3IHNoYXBlIGF0IGdpdmVuIHBvc2l0aW9uXG4gIHZhciBwb3NpdGlvbiA9IHtcbiAgICB4OiBuZXdEYXRhLngsXG4gICAgeTogbmV3RGF0YS55XG4gIH07XG5cbiAgdmFyIG9sZEJvdW5kcyA9IHtcbiAgICB4OiBvbGRTaGFwZS54LFxuICAgIHk6IG9sZFNoYXBlLnksXG4gICAgd2lkdGg6IG9sZFNoYXBlLndpZHRoLFxuICAgIGhlaWdodDogb2xkU2hhcGUuaGVpZ2h0XG4gIH07XG5cbiAgbmV3U2hhcGUgPSBjb250ZXh0Lm5ld1NoYXBlID1cbiAgICBjb250ZXh0Lm5ld1NoYXBlIHx8XG4gICAgc2VsZi5jcmVhdGVTaGFwZShuZXdEYXRhLCBwb3NpdGlvbiwgb2xkU2hhcGUucGFyZW50LCBoaW50cyk7XG5cbiAgLy8gKDIpIHVwZGF0ZSBob3N0XG4gIGlmIChvbGRTaGFwZS5ob3N0KSB7XG4gICAgbW9kZWxpbmcudXBkYXRlQXR0YWNobWVudChuZXdTaGFwZSwgb2xkU2hhcGUuaG9zdCk7XG4gIH1cblxuICAvLyAoMykgYWRvcHQgYWxsIGNoaWxkcmVuIGZyb20gb2xkIHNoYXBlXG4gIHZhciBjaGlsZHJlbjtcblxuICBpZiAoaGludHMubW92ZUNoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgIGNoaWxkcmVuID0gb2xkU2hhcGUuY2hpbGRyZW4uc2xpY2UoKTtcblxuICAgIG1vZGVsaW5nLm1vdmVFbGVtZW50cyhjaGlsZHJlbiwgeyB4OiAwLCB5OiAwIH0sIG5ld1NoYXBlLCBoaW50cyk7XG4gIH1cblxuICAvLyAoNCkgcmVjb25uZWN0IGNvbm5lY3Rpb25zIHRvIG5ldyBzaGFwZSBpZiBwb3NzaWJsZVxuICB2YXIgaW5jb21pbmcgPSBvbGRTaGFwZS5pbmNvbWluZy5zbGljZSgpLFxuICAgICAgb3V0Z29pbmcgPSBvbGRTaGFwZS5vdXRnb2luZy5zbGljZSgpO1xuXG4gIGZvckVhY2goaW5jb21pbmcsIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICB2YXIgc291cmNlID0gY29ubmVjdGlvbi5zb3VyY2UsXG4gICAgICAgIGFsbG93ZWQgPSBjYW5SZWNvbm5lY3Qoc291cmNlLCBuZXdTaGFwZSwgY29ubmVjdGlvbik7XG5cbiAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgc2VsZi5yZWNvbm5lY3RFbmQoXG4gICAgICAgIGNvbm5lY3Rpb24sIG5ld1NoYXBlLFxuICAgICAgICBnZXRSZXNpemVkVGFyZ2V0QW5jaG9yKGNvbm5lY3Rpb24sIG5ld1NoYXBlLCBvbGRCb3VuZHMpLFxuICAgICAgICBoaW50c1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZvckVhY2gob3V0Z29pbmcsIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICB2YXIgdGFyZ2V0ID0gY29ubmVjdGlvbi50YXJnZXQsXG4gICAgICAgIGFsbG93ZWQgPSBjYW5SZWNvbm5lY3QobmV3U2hhcGUsIHRhcmdldCwgY29ubmVjdGlvbik7XG5cbiAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgc2VsZi5yZWNvbm5lY3RTdGFydChcbiAgICAgICAgY29ubmVjdGlvbiwgbmV3U2hhcGUsXG4gICAgICAgIGdldFJlc2l6ZWRTb3VyY2VBbmNob3IoY29ubmVjdGlvbiwgbmV3U2hhcGUsIG9sZEJvdW5kcyksXG4gICAgICAgIGhpbnRzXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIG9sZCBzaGFwZS5cbiAqL1xuUmVwbGFjZVNoYXBlSGFuZGxlci5wcm90b3R5cGUucG9zdEV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBvbGRTaGFwZSA9IGNvbnRleHQub2xkU2hhcGU7XG5cbiAgdGhpcy5fbW9kZWxpbmcucmVtb3ZlU2hhcGUob2xkU2hhcGUpO1xufTtcblxuXG5SZXBsYWNlU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge307XG5cblxuUmVwbGFjZVNoYXBlSGFuZGxlci5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29udGV4dCkge307XG5cblxuUmVwbGFjZVNoYXBlSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbihzaGFwZSwgcG9zaXRpb24sIHRhcmdldCwgaGludHMpIHtcbiAgcmV0dXJuIHRoaXMuX21vZGVsaW5nLmNyZWF0ZVNoYXBlKHNoYXBlLCBwb3NpdGlvbiwgdGFyZ2V0LCBoaW50cyk7XG59O1xuXG5cblJlcGxhY2VTaGFwZUhhbmRsZXIucHJvdG90eXBlLnJlY29ubmVjdFN0YXJ0ID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgbmV3U291cmNlLCBkb2NraW5nUG9pbnQsIGhpbnRzKSB7XG4gIHRoaXMuX21vZGVsaW5nLnJlY29ubmVjdFN0YXJ0KGNvbm5lY3Rpb24sIG5ld1NvdXJjZSwgZG9ja2luZ1BvaW50LCBoaW50cyk7XG59O1xuXG5cblJlcGxhY2VTaGFwZUhhbmRsZXIucHJvdG90eXBlLnJlY29ubmVjdEVuZCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIG5ld1RhcmdldCwgZG9ja2luZ1BvaW50LCBoaW50cykge1xuICB0aGlzLl9tb2RlbGluZy5yZWNvbm5lY3RFbmQoY29ubmVjdGlvbiwgbmV3VGFyZ2V0LCBkb2NraW5nUG9pbnQsIGhpbnRzKTtcbn07XG4iLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRSZXNpemVkU291cmNlQW5jaG9yLFxuICBnZXRSZXNpemVkVGFyZ2V0QW5jaG9yXG59IGZyb20gJy4vaGVscGVyL0FuY2hvcnNIZWxwZXInO1xuXG5cbi8qKlxuICogQSBoYW5kbGVyIHRoYXQgaW1wbGVtZW50cyByZXZlcnNpYmxlIHJlc2l6aW5nIG9mIHNoYXBlcy5cbiAqXG4gKiBAcGFyYW0ge01vZGVsaW5nfSBtb2RlbGluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZXNpemVTaGFwZUhhbmRsZXIobW9kZWxpbmcpIHtcbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbn1cblxuUmVzaXplU2hhcGVIYW5kbGVyLiRpbmplY3QgPSBbICdtb2RlbGluZycgXTtcblxuLyoqXG4gKiB7XG4gKiAgIHNoYXBlOiB7Li4uLn1cbiAqICAgbmV3Qm91bmRzOiB7XG4gKiAgICAgd2lkdGg6ICAyMCxcbiAqICAgICBoZWlnaHQ6IDQwLFxuICogICAgIHg6ICAgICAgIDUsXG4gKiAgICAgeTogICAgICAxMFxuICogICB9XG4gKlxuICogfVxuICovXG5SZXNpemVTaGFwZUhhbmRsZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICBuZXdCb3VuZHMgPSBjb250ZXh0Lm5ld0JvdW5kcyxcbiAgICAgIG1pbkJvdW5kcyA9IGNvbnRleHQubWluQm91bmRzO1xuXG4gIGlmIChuZXdCb3VuZHMueCA9PT0gdW5kZWZpbmVkIHx8IG5ld0JvdW5kcy55ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIG5ld0JvdW5kcy53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IG5ld0JvdW5kcy5oZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbmV3Qm91bmRzIG11c3QgaGF2ZSB7eCwgeSwgd2lkdGgsIGhlaWdodH0gcHJvcGVydGllcycpO1xuICB9XG5cbiAgaWYgKG1pbkJvdW5kcyAmJiAobmV3Qm91bmRzLndpZHRoIDwgbWluQm91bmRzLndpZHRoXG4gICAgfHwgbmV3Qm91bmRzLmhlaWdodCA8IG1pbkJvdW5kcy5oZWlnaHQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3aWR0aCBhbmQgaGVpZ2h0IGNhbm5vdCBiZSBsZXNzIHRoYW4gbWluaW11bSBoZWlnaHQgYW5kIHdpZHRoJyk7XG4gIH0gZWxzZSBpZiAoIW1pbkJvdW5kc1xuICAgICYmIG5ld0JvdW5kcy53aWR0aCA8IDEwIHx8IG5ld0JvdW5kcy5oZWlnaHQgPCAxMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignd2lkdGggYW5kIGhlaWdodCBjYW5ub3QgYmUgbGVzcyB0aGFuIDEwcHgnKTtcbiAgfVxuXG4gIC8vIHNhdmUgb2xkIGJib3ggaW4gY29udGV4dFxuICBjb250ZXh0Lm9sZEJvdW5kcyA9IHtcbiAgICB3aWR0aDogIHNoYXBlLndpZHRoLFxuICAgIGhlaWdodDogc2hhcGUuaGVpZ2h0LFxuICAgIHg6ICAgICAgc2hhcGUueCxcbiAgICB5OiAgICAgIHNoYXBlLnlcbiAgfTtcblxuICAvLyB1cGRhdGUgc2hhcGVcbiAgYXNzaWduKHNoYXBlLCB7XG4gICAgd2lkdGg6ICBuZXdCb3VuZHMud2lkdGgsXG4gICAgaGVpZ2h0OiBuZXdCb3VuZHMuaGVpZ2h0LFxuICAgIHg6ICAgICAgbmV3Qm91bmRzLngsXG4gICAgeTogICAgICBuZXdCb3VuZHMueVxuICB9KTtcblxuICByZXR1cm4gc2hhcGU7XG59O1xuXG5SZXNpemVTaGFwZUhhbmRsZXIucHJvdG90eXBlLnBvc3RFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgbW9kZWxpbmcgPSB0aGlzLl9tb2RlbGluZztcblxuICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgb2xkQm91bmRzID0gY29udGV4dC5vbGRCb3VuZHMsXG4gICAgICBoaW50cyA9IGNvbnRleHQuaGludHMgfHwge307XG5cbiAgaWYgKGhpbnRzLmxheW91dCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3JFYWNoKHNoYXBlLmluY29taW5nLCBmdW5jdGlvbihjKSB7XG4gICAgbW9kZWxpbmcubGF5b3V0Q29ubmVjdGlvbihjLCB7XG4gICAgICBjb25uZWN0aW9uRW5kOiBnZXRSZXNpemVkVGFyZ2V0QW5jaG9yKGMsIHNoYXBlLCBvbGRCb3VuZHMpXG4gICAgfSk7XG4gIH0pO1xuXG4gIGZvckVhY2goc2hhcGUub3V0Z29pbmcsIGZ1bmN0aW9uKGMpIHtcbiAgICBtb2RlbGluZy5sYXlvdXRDb25uZWN0aW9uKGMsIHtcbiAgICAgIGNvbm5lY3Rpb25TdGFydDogZ2V0UmVzaXplZFNvdXJjZUFuY2hvcihjLCBzaGFwZSwgb2xkQm91bmRzKVxuICAgIH0pO1xuICB9KTtcblxufTtcblxuUmVzaXplU2hhcGVIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgIG9sZEJvdW5kcyA9IGNvbnRleHQub2xkQm91bmRzO1xuXG4gIC8vIHJlc3RvcmUgcHJldmlvdXMgYmJveFxuICBhc3NpZ24oc2hhcGUsIHtcbiAgICB3aWR0aDogIG9sZEJvdW5kcy53aWR0aCxcbiAgICBoZWlnaHQ6IG9sZEJvdW5kcy5oZWlnaHQsXG4gICAgeDogICAgICBvbGRCb3VuZHMueCxcbiAgICB5OiAgICAgIG9sZEJvdW5kcy55XG4gIH0pO1xuXG4gIHJldHVybiBzaGFwZTtcbn07XG4iLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZvckVhY2gsXG4gIG1hcFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGdldFdheXBvaW50c1VwZGF0aW5nQ29ubmVjdGlvbnMsXG4gIHJlc2l6ZUJvdW5kc1xufSBmcm9tICcuLi8uLi9zcGFjZS10b29sL1NwYWNlVXRpbCc7XG5cbmltcG9ydCB7XG4gIGdldE1vdmVkU291cmNlQW5jaG9yLFxuICBnZXRNb3ZlZFRhcmdldEFuY2hvcixcbiAgZ2V0UmVzaXplZFNvdXJjZUFuY2hvcixcbiAgZ2V0UmVzaXplZFRhcmdldEFuY2hvclxufSBmcm9tICcuL2hlbHBlci9BbmNob3JzSGVscGVyJztcblxuXG4vKipcbiAqIEFkZCBvciByZW1vdmUgc3BhY2UgYnkgbW92aW5nIGFuZCByZXNpemluZyBzaGFwZXMgYW5kIHVwZGF0aW5nIGNvbm5lY3Rpb24gd2F5cG9pbnRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTcGFjZVRvb2xIYW5kbGVyKG1vZGVsaW5nKSB7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG59XG5cblNwYWNlVG9vbEhhbmRsZXIuJGluamVjdCA9IFsgJ21vZGVsaW5nJyBdO1xuXG5TcGFjZVRvb2xIYW5kbGVyLnByb3RvdHlwZS5wcmVFeGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgZGVsdGEgPSBjb250ZXh0LmRlbHRhLFxuICAgICAgZGlyZWN0aW9uID0gY29udGV4dC5kaXJlY3Rpb24sXG4gICAgICBtb3ZpbmdTaGFwZXMgPSBjb250ZXh0Lm1vdmluZ1NoYXBlcyxcbiAgICAgIHJlc2l6aW5nU2hhcGVzID0gY29udGV4dC5yZXNpemluZ1NoYXBlcyxcbiAgICAgIHN0YXJ0ID0gY29udGV4dC5zdGFydCxcbiAgICAgIG9sZEJvdW5kcyA9IHt9O1xuXG4gIC8vICgxKSBtb3ZlIHNoYXBlc1xuICB0aGlzLm1vdmVTaGFwZXMobW92aW5nU2hhcGVzLCBkZWx0YSk7XG5cbiAgLy8gKDJhKSBzYXZlIG9sZCBib3VuZHMgb2YgcmVzaXplZCBzaGFwZXNcbiAgZm9yRWFjaChyZXNpemluZ1NoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcbiAgICBvbGRCb3VuZHNbc2hhcGUuaWRdID0gZ2V0Qm91bmRzKHNoYXBlKTtcbiAgfSk7XG5cbiAgLy8gKDJiKSByZXNpemUgc2hhcGVzXG4gIHRoaXMucmVzaXplU2hhcGVzKHJlc2l6aW5nU2hhcGVzLCBkZWx0YSwgZGlyZWN0aW9uKTtcblxuICAvLyAoMykgdXBkYXRlIGNvbm5lY3Rpb24gd2F5cG9pbnRzXG4gIHRoaXMudXBkYXRlQ29ubmVjdGlvbldheXBvaW50cyhcbiAgICBnZXRXYXlwb2ludHNVcGRhdGluZ0Nvbm5lY3Rpb25zKG1vdmluZ1NoYXBlcywgcmVzaXppbmdTaGFwZXMpLFxuICAgIGRlbHRhLFxuICAgIGRpcmVjdGlvbixcbiAgICBzdGFydCxcbiAgICBtb3ZpbmdTaGFwZXMsXG4gICAgcmVzaXppbmdTaGFwZXMsXG4gICAgb2xkQm91bmRzXG4gICk7XG59O1xuXG5TcGFjZVRvb2xIYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oKSB7fTtcblNwYWNlVG9vbEhhbmRsZXIucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uKCkge307XG5cblNwYWNlVG9vbEhhbmRsZXIucHJvdG90eXBlLm1vdmVTaGFwZXMgPSBmdW5jdGlvbihzaGFwZXMsIGRlbHRhKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3JFYWNoKHNoYXBlcywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHNlbGYuX21vZGVsaW5nLm1vdmVTaGFwZShlbGVtZW50LCBkZWx0YSwgbnVsbCwge1xuICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXG4gICAgICBsYXlvdXQ6IGZhbHNlLFxuICAgICAgcmVjdXJzZTogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5TcGFjZVRvb2xIYW5kbGVyLnByb3RvdHlwZS5yZXNpemVTaGFwZXMgPSBmdW5jdGlvbihzaGFwZXMsIGRlbHRhLCBkaXJlY3Rpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZvckVhY2goc2hhcGVzLCBmdW5jdGlvbihzaGFwZSkge1xuICAgIHZhciBuZXdCb3VuZHMgPSByZXNpemVCb3VuZHMoc2hhcGUsIGRpcmVjdGlvbiwgZGVsdGEpO1xuXG4gICAgc2VsZi5fbW9kZWxpbmcucmVzaXplU2hhcGUoc2hhcGUsIG5ld0JvdW5kcywgbnVsbCwge1xuICAgICAgYXR0YWNoU3VwcG9ydDogZmFsc2UsXG4gICAgICBhdXRvUmVzaXplOiBmYWxzZSxcbiAgICAgIGxheW91dDogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBjb25uZWN0aW9ucyB3YXlwb2ludHMgYWNjb3JkaW5nIHRvIHRoZSBydWxlczpcbiAqICAgMS4gQm90aCBzb3VyY2UgYW5kIHRhcmdldCBhcmUgbW92ZWQvcmVzaXplZCA9PiBtb3ZlIHdheXBvaW50cyBieSB0aGUgZGVsdGFcbiAqICAgMi4gT25seSBvbmUgb2Ygc291cmNlIGFuZCB0YXJnZXQgaXMgbW92ZWQvcmVzaXplZCA9PiByZS1sYXlvdXQgY29ubmVjdGlvbiB3aXRoIG1vdmVkIHN0YXJ0L2VuZFxuICovXG5TcGFjZVRvb2xIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVDb25uZWN0aW9uV2F5cG9pbnRzID0gZnVuY3Rpb24oXG4gICAgY29ubmVjdGlvbnMsXG4gICAgZGVsdGEsXG4gICAgZGlyZWN0aW9uLFxuICAgIHN0YXJ0LFxuICAgIG1vdmluZ1NoYXBlcyxcbiAgICByZXNpemluZ1NoYXBlcyxcbiAgICBvbGRCb3VuZHNcbikge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBhZmZlY3RlZFNoYXBlcyA9IG1vdmluZ1NoYXBlcy5jb25jYXQocmVzaXppbmdTaGFwZXMpO1xuXG4gIGZvckVhY2goY29ubmVjdGlvbnMsIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICB2YXIgc291cmNlID0gY29ubmVjdGlvbi5zb3VyY2UsXG4gICAgICAgIHRhcmdldCA9IGNvbm5lY3Rpb24udGFyZ2V0LFxuICAgICAgICB3YXlwb2ludHMgPSBjb3B5V2F5cG9pbnRzKGNvbm5lY3Rpb24pLFxuICAgICAgICBheGlzID0gZ2V0QXhpc0Zyb21EaXJlY3Rpb24oZGlyZWN0aW9uKSxcbiAgICAgICAgbGF5b3V0SGludHMgPSB7XG4gICAgICAgICAgbGFiZWxCZWhhdmlvcjogZmFsc2VcbiAgICAgICAgfTtcblxuICAgIGlmIChpbmNsdWRlcyhhZmZlY3RlZFNoYXBlcywgc291cmNlKSAmJiBpbmNsdWRlcyhhZmZlY3RlZFNoYXBlcywgdGFyZ2V0KSkge1xuXG4gICAgICAvLyBtb3ZlIHdheXBvaW50c1xuICAgICAgd2F5cG9pbnRzID0gbWFwKHdheXBvaW50cywgZnVuY3Rpb24od2F5cG9pbnQpIHtcbiAgICAgICAgaWYgKHNob3VsZE1vdmVXYXlwb2ludCh3YXlwb2ludCwgc3RhcnQsIGRpcmVjdGlvbikpIHtcblxuICAgICAgICAgIC8vIG1vdmUgd2F5cG9pbnRcbiAgICAgICAgICB3YXlwb2ludFsgYXhpcyBdID0gd2F5cG9pbnRbIGF4aXMgXSArIGRlbHRhWyBheGlzIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2F5cG9pbnQub3JpZ2luYWwgJiYgc2hvdWxkTW92ZVdheXBvaW50KHdheXBvaW50Lm9yaWdpbmFsLCBzdGFydCwgZGlyZWN0aW9uKSkge1xuXG4gICAgICAgICAgLy8gbW92ZSB3YXlwb2ludCBvcmlnaW5hbFxuICAgICAgICAgIHdheXBvaW50Lm9yaWdpbmFsWyBheGlzIF0gPSB3YXlwb2ludC5vcmlnaW5hbFsgYXhpcyBdICsgZGVsdGFbIGF4aXMgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3YXlwb2ludDtcbiAgICAgIH0pO1xuXG4gICAgICBzZWxmLl9tb2RlbGluZy51cGRhdGVXYXlwb2ludHMoY29ubmVjdGlvbiwgd2F5cG9pbnRzLCB7XG4gICAgICAgIGxhYmVsQmVoYXZpb3I6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGluY2x1ZGVzKGFmZmVjdGVkU2hhcGVzLCBzb3VyY2UpIHx8IGluY2x1ZGVzKGFmZmVjdGVkU2hhcGVzLCB0YXJnZXQpKSB7XG5cbiAgICAgIC8vIHJlLWxheW91dCBjb25uZWN0aW9uIHdpdGggbW92ZWQgc3RhcnQvZW5kXG4gICAgICBpZiAoaW5jbHVkZXMobW92aW5nU2hhcGVzLCBzb3VyY2UpKSB7XG4gICAgICAgIGxheW91dEhpbnRzLmNvbm5lY3Rpb25TdGFydCA9IGdldE1vdmVkU291cmNlQW5jaG9yKGNvbm5lY3Rpb24sIHNvdXJjZSwgZGVsdGEpO1xuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlcyhtb3ZpbmdTaGFwZXMsIHRhcmdldCkpIHtcbiAgICAgICAgbGF5b3V0SGludHMuY29ubmVjdGlvbkVuZCA9IGdldE1vdmVkVGFyZ2V0QW5jaG9yKGNvbm5lY3Rpb24sIHRhcmdldCwgZGVsdGEpO1xuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlcyhyZXNpemluZ1NoYXBlcywgc291cmNlKSkge1xuICAgICAgICBsYXlvdXRIaW50cy5jb25uZWN0aW9uU3RhcnQgPSBnZXRSZXNpemVkU291cmNlQW5jaG9yKFxuICAgICAgICAgIGNvbm5lY3Rpb24sIHNvdXJjZSwgb2xkQm91bmRzW3NvdXJjZS5pZF1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZXMocmVzaXppbmdTaGFwZXMsIHRhcmdldCkpIHtcbiAgICAgICAgbGF5b3V0SGludHMuY29ubmVjdGlvbkVuZCA9IGdldFJlc2l6ZWRUYXJnZXRBbmNob3IoXG4gICAgICAgICAgY29ubmVjdGlvbiwgdGFyZ2V0LCBvbGRCb3VuZHNbdGFyZ2V0LmlkXVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9tb2RlbGluZy5sYXlvdXRDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGxheW91dEhpbnRzKTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cblxuZnVuY3Rpb24gY29weVdheXBvaW50KHdheXBvaW50KSB7XG4gIHJldHVybiBhc3NpZ24oe30sIHdheXBvaW50KTtcbn1cblxuZnVuY3Rpb24gY29weVdheXBvaW50cyhjb25uZWN0aW9uKSB7XG4gIHJldHVybiBtYXAoY29ubmVjdGlvbi53YXlwb2ludHMsIGZ1bmN0aW9uKHdheXBvaW50KSB7XG5cbiAgICB3YXlwb2ludCA9IGNvcHlXYXlwb2ludCh3YXlwb2ludCk7XG5cbiAgICBpZiAod2F5cG9pbnQub3JpZ2luYWwpIHtcbiAgICAgIHdheXBvaW50Lm9yaWdpbmFsID0gY29weVdheXBvaW50KHdheXBvaW50Lm9yaWdpbmFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2F5cG9pbnQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzRnJvbURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgY2FzZSAnbic6XG4gICAgcmV0dXJuICd5JztcbiAgY2FzZSAndyc6XG4gICAgcmV0dXJuICd4JztcbiAgY2FzZSAncyc6XG4gICAgcmV0dXJuICd5JztcbiAgY2FzZSAnZSc6XG4gICAgcmV0dXJuICd4JztcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRNb3ZlV2F5cG9pbnQod2F5cG9pbnQsIHN0YXJ0LCBkaXJlY3Rpb24pIHtcbiAgdmFyIHJlbGV2YW50QXhpcyA9IGdldEF4aXNGcm9tRGlyZWN0aW9uKGRpcmVjdGlvbik7XG5cbiAgaWYgKC9lfHMvLnRlc3QoZGlyZWN0aW9uKSkge1xuICAgIHJldHVybiB3YXlwb2ludFsgcmVsZXZhbnRBeGlzIF0gPiBzdGFydDtcbiAgfSBlbHNlIGlmICgvbnx3Ly50ZXN0KGRpcmVjdGlvbikpIHtcbiAgICByZXR1cm4gd2F5cG9pbnRbIHJlbGV2YW50QXhpcyBdIDwgc3RhcnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIGl0ZW0pIHtcbiAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZHMoc2hhcGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBzaGFwZS54LFxuICAgIHk6IHNoYXBlLnksXG4gICAgaGVpZ2h0OiBzaGFwZS5oZWlnaHQsXG4gICAgd2lkdGg6IHNoYXBlLndpZHRoXG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG4vKipcbiAqIEEgaGFuZGxlciB0aGF0IHRvZ2dsZXMgdGhlIGNvbGxhcHNlZCBzdGF0ZSBvZiBhbiBlbGVtZW50XG4gKiBhbmQgdGhlIHZpc2liaWxpdHkgb2YgYWxsIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge01vZGVsaW5nfSBtb2RlbGluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUb2dnbGVTaGFwZUNvbGxhcHNlSGFuZGxlcihtb2RlbGluZykge1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xufVxuXG5Ub2dnbGVTaGFwZUNvbGxhcHNlSGFuZGxlci4kaW5qZWN0ID0gWyAnbW9kZWxpbmcnIF07XG5cblxuVG9nZ2xlU2hhcGVDb2xsYXBzZUhhbmRsZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgIGNoaWxkcmVuID0gc2hhcGUuY2hpbGRyZW47XG5cbiAgLy8gcmVjdXJzaXZlbHkgcmVtZW1iZXIgcHJldmlvdXMgdmlzaWJpbGl0eSBvZiBjaGlsZHJlblxuICBjb250ZXh0Lm9sZENoaWxkcmVuVmlzaWJpbGl0eSA9IGdldEVsZW1lbnRzVmlzaWJpbGl0eVJlY3Vyc2l2ZShjaGlsZHJlbik7XG5cbiAgLy8gdG9nZ2xlIHN0YXRlXG4gIHNoYXBlLmNvbGxhcHNlZCA9ICFzaGFwZS5jb2xsYXBzZWQ7XG5cbiAgLy8gcmVjdXJzaXZlbHkgaGlkZS9zaG93IGNoaWxkcmVuXG4gIHZhciByZXN1bHQgPSBzZXRIaWRkZW5SZWN1cnNpdmUoY2hpbGRyZW4sIHNoYXBlLmNvbGxhcHNlZCk7XG5cbiAgcmV0dXJuIFtzaGFwZV0uY29uY2F0KHJlc3VsdCk7XG59O1xuXG5cblRvZ2dsZVNoYXBlQ29sbGFwc2VIYW5kbGVyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgIG9sZENoaWxkcmVuVmlzaWJpbGl0eSA9IGNvbnRleHQub2xkQ2hpbGRyZW5WaXNpYmlsaXR5O1xuXG4gIHZhciBjaGlsZHJlbiA9IHNoYXBlLmNoaWxkcmVuO1xuXG4gIC8vIHJlY3Vyc2l2ZWx5IHNldCBvbGQgdmlzYWJpbGl0eSBvZiBjaGlsZHJlblxuICB2YXIgcmVzdWx0ID0gcmVzdG9yZVZpc2liaWxpdHlSZWN1cnNpdmUoY2hpbGRyZW4sIG9sZENoaWxkcmVuVmlzaWJpbGl0eSk7XG5cbiAgLy8gcmV0b2dnbGUgc3RhdGVcbiAgc2hhcGUuY29sbGFwc2VkID0gIXNoYXBlLmNvbGxhcHNlZDtcblxuICByZXR1cm4gW3NoYXBlXS5jb25jYXQocmVzdWx0KTtcbn07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUmV0dXJuIGEgbWFwIHsgZWxlbWVudElkIC0+IGhpZGRlblN0YXRlfS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGRqcy5tb2RlbC5TaGFwZT59IGVsZW1lbnRzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50c1Zpc2liaWxpdHlSZWN1cnNpdmUoZWxlbWVudHMpIHtcblxuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJlc3VsdFtlbGVtZW50LmlkXSA9IGVsZW1lbnQuaGlkZGVuO1xuXG4gICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4pIHtcbiAgICAgIHJlc3VsdCA9IGFzc2lnbih7fSwgcmVzdWx0LCBnZXRFbGVtZW50c1Zpc2liaWxpdHlSZWN1cnNpdmUoZWxlbWVudC5jaGlsZHJlbikpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBzZXRIaWRkZW5SZWN1cnNpdmUoZWxlbWVudHMsIG5ld0hpZGRlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmhpZGRlbiA9IG5ld0hpZGRlbjtcblxuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChzZXRIaWRkZW5SZWN1cnNpdmUoZWxlbWVudC5jaGlsZHJlbiwgZWxlbWVudC5jb2xsYXBzZWQgfHwgbmV3SGlkZGVuKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZXN0b3JlVmlzaWJpbGl0eVJlY3Vyc2l2ZShlbGVtZW50cywgbGFzdFN0YXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaGlkZGVuID0gbGFzdFN0YXRlW2VsZW1lbnQuaWRdO1xuXG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50LmNoaWxkcmVuKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHJlc3RvcmVWaXNpYmlsaXR5UmVjdXJzaXZlKGVsZW1lbnQuY2hpbGRyZW4sIGxhc3RTdGF0ZSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7XG4gIGFkZCBhcyBjb2xsZWN0aW9uQWRkLFxuICByZW1vdmUgYXMgY29sbGVjdGlvblJlbW92ZVxufSBmcm9tICcuLi8uLi8uLi91dGlsL0NvbGxlY3Rpb25zJztcblxuLyoqXG4gKiBBIGhhbmRsZXIgdGhhdCBpbXBsZW1lbnRzIHJldmVyc2libGUgYXR0YWNoaW5nL2RldGFjaGluZyBvZiBzaGFwZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFVwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKG1vZGVsaW5nKSB7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG59XG5cblVwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyLiRpbmplY3QgPSBbICdtb2RlbGluZycgXTtcblxuXG5VcGRhdGVBdHRhY2htZW50SGFuZGxlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgIG5ld0hvc3QgPSBjb250ZXh0Lm5ld0hvc3QsXG4gICAgICBvbGRIb3N0ID0gc2hhcGUuaG9zdDtcblxuICAvLyAoMCkgZGV0YWNoIGZyb20gb2xkIGhvc3RcbiAgY29udGV4dC5vbGRIb3N0ID0gb2xkSG9zdDtcbiAgY29udGV4dC5hdHRhY2hlcklkeCA9IHJlbW92ZUF0dGFjaGVyKG9sZEhvc3QsIHNoYXBlKTtcblxuICAvLyAoMSkgYXR0YWNoIHRvIG5ldyBob3N0XG4gIGFkZEF0dGFjaGVyKG5ld0hvc3QsIHNoYXBlKTtcblxuICAvLyAoMikgdXBkYXRlIGhvc3RcbiAgc2hhcGUuaG9zdCA9IG5ld0hvc3Q7XG5cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuVXBkYXRlQXR0YWNobWVudEhhbmRsZXIucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgIG5ld0hvc3QgPSBjb250ZXh0Lm5ld0hvc3QsXG4gICAgICBvbGRIb3N0ID0gY29udGV4dC5vbGRIb3N0LFxuICAgICAgYXR0YWNoZXJJZHggPSBjb250ZXh0LmF0dGFjaGVySWR4O1xuXG4gIC8vICgyKSB1cGRhdGUgaG9zdFxuICBzaGFwZS5ob3N0ID0gb2xkSG9zdDtcblxuICAvLyAoMSkgYXR0YWNoIHRvIG5ldyBob3N0XG4gIHJlbW92ZUF0dGFjaGVyKG5ld0hvc3QsIHNoYXBlKTtcblxuICAvLyAoMCkgZGV0YWNoIGZyb20gb2xkIGhvc3RcbiAgYWRkQXR0YWNoZXIob2xkSG9zdCwgc2hhcGUsIGF0dGFjaGVySWR4KTtcblxuICByZXR1cm4gc2hhcGU7XG59O1xuXG5cbmZ1bmN0aW9uIHJlbW92ZUF0dGFjaGVyKGhvc3QsIGF0dGFjaGVyKSB7XG5cbiAgLy8gcmVtb3ZlIGF0dGFjaGVyIGZyb20gaG9zdFxuICByZXR1cm4gY29sbGVjdGlvblJlbW92ZShob3N0ICYmIGhvc3QuYXR0YWNoZXJzLCBhdHRhY2hlcik7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dGFjaGVyKGhvc3QsIGF0dGFjaGVyLCBpZHgpIHtcblxuICBpZiAoIWhvc3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYXR0YWNoZXJzID0gaG9zdC5hdHRhY2hlcnM7XG5cbiAgaWYgKCFhdHRhY2hlcnMpIHtcbiAgICBob3N0LmF0dGFjaGVycyA9IGF0dGFjaGVycyA9IFtdO1xuICB9XG5cbiAgY29sbGVjdGlvbkFkZChhdHRhY2hlcnMsIGF0dGFjaGVyLCBpZHgpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVXBkYXRlV2F5cG9pbnRzSGFuZGxlcigpIHsgfVxuXG5VcGRhdGVXYXlwb2ludHNIYW5kbGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXG4gIHZhciBjb25uZWN0aW9uID0gY29udGV4dC5jb25uZWN0aW9uLFxuICAgICAgbmV3V2F5cG9pbnRzID0gY29udGV4dC5uZXdXYXlwb2ludHM7XG5cbiAgY29udGV4dC5vbGRXYXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cztcblxuICBjb25uZWN0aW9uLndheXBvaW50cyA9IG5ld1dheXBvaW50cztcblxuICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG5cblVwZGF0ZVdheXBvaW50c0hhbmRsZXIucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICB2YXIgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgIG9sZFdheXBvaW50cyA9IGNvbnRleHQub2xkV2F5cG9pbnRzO1xuXG4gIGNvbm5lY3Rpb24ud2F5cG9pbnRzID0gb2xkV2F5cG9pbnRzO1xuXG4gIHJldHVybiBjb25uZWN0aW9uO1xufTsiLCJpbXBvcnQge1xuICBnZXROZXdBdHRhY2hQb2ludFxufSBmcm9tICcuLi8uLi8uLi8uLi91dGlsL0F0dGFjaFV0aWwnO1xuXG5pbXBvcnQge1xuICBnZXRPcmllbnRhdGlvblxufSBmcm9tICcuLi8uLi8uLi8uLi9sYXlvdXQvTGF5b3V0VXRpbCc7XG5cbmltcG9ydCB7XG4gIGZpbHRlcixcbiAgbWFwXG59IGZyb20gJ21pbi1kYXNoJztcblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVzaXplZFNvdXJjZUFuY2hvcihjb25uZWN0aW9uLCBzaGFwZSwgb2xkQm91bmRzKSB7XG5cbiAgdmFyIHdheXBvaW50cyA9IHNhZmVHZXRXYXlwb2ludHMoY29ubmVjdGlvbiksXG4gICAgICB3YXlwb2ludHNJbnNpZGVOZXdCb3VuZHMgPSBnZXRXYXlwb2ludHNJbnNpZGVCb3VuZHMod2F5cG9pbnRzLCBzaGFwZSksXG4gICAgICBvbGRBbmNob3IgPSB3YXlwb2ludHNbMF07XG5cbiAgLy8gbmV3IGFuY2hvciBpcyB0aGUgbGFzdCB3YXlwb2ludCBlbmNsb3NlZCBiZSByZXNpemVkIHNvdXJjZVxuICBpZiAod2F5cG9pbnRzSW5zaWRlTmV3Qm91bmRzLmxlbmd0aCkge1xuICAgIHJldHVybiB3YXlwb2ludHNJbnNpZGVOZXdCb3VuZHNbIHdheXBvaW50c0luc2lkZU5ld0JvdW5kcy5sZW5ndGggLSAxIF07XG4gIH1cblxuICByZXR1cm4gZ2V0TmV3QXR0YWNoUG9pbnQob2xkQW5jaG9yLm9yaWdpbmFsIHx8IG9sZEFuY2hvciwgb2xkQm91bmRzLCBzaGFwZSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlc2l6ZWRUYXJnZXRBbmNob3IoY29ubmVjdGlvbiwgc2hhcGUsIG9sZEJvdW5kcykge1xuXG4gIHZhciB3YXlwb2ludHMgPSBzYWZlR2V0V2F5cG9pbnRzKGNvbm5lY3Rpb24pLFxuICAgICAgd2F5cG9pbnRzSW5zaWRlTmV3Qm91bmRzID0gZ2V0V2F5cG9pbnRzSW5zaWRlQm91bmRzKHdheXBvaW50cywgc2hhcGUpLFxuICAgICAgb2xkQW5jaG9yID0gd2F5cG9pbnRzW3dheXBvaW50cy5sZW5ndGggLSAxXTtcblxuICAvLyBuZXcgYW5jaG9yIGlzIHRoZSBmaXJzdCB3YXlwb2ludCBlbmNsb3NlZCBiZSByZXNpemVkIHRhcmdldFxuICBpZiAod2F5cG9pbnRzSW5zaWRlTmV3Qm91bmRzLmxlbmd0aCkge1xuICAgIHJldHVybiB3YXlwb2ludHNJbnNpZGVOZXdCb3VuZHNbIDAgXTtcbiAgfVxuXG4gIHJldHVybiBnZXROZXdBdHRhY2hQb2ludChvbGRBbmNob3Iub3JpZ2luYWwgfHwgb2xkQW5jaG9yLCBvbGRCb3VuZHMsIHNoYXBlKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW92ZWRTb3VyY2VBbmNob3IoY29ubmVjdGlvbiwgc291cmNlLCBtb3ZlRGVsdGEpIHtcblxuICB2YXIgd2F5cG9pbnRzID0gc2FmZUdldFdheXBvaW50cyhjb25uZWN0aW9uKSxcbiAgICAgIG9sZEJvdW5kcyA9IHN1YnRyYWN0KHNvdXJjZSwgbW92ZURlbHRhKSxcbiAgICAgIG9sZEFuY2hvciA9IHdheXBvaW50c1sgMCBdO1xuXG4gIHJldHVybiBnZXROZXdBdHRhY2hQb2ludChvbGRBbmNob3Iub3JpZ2luYWwgfHwgb2xkQW5jaG9yLCBvbGRCb3VuZHMsIHNvdXJjZSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vdmVkVGFyZ2V0QW5jaG9yKGNvbm5lY3Rpb24sIHRhcmdldCwgbW92ZURlbHRhKSB7XG5cbiAgdmFyIHdheXBvaW50cyA9IHNhZmVHZXRXYXlwb2ludHMoY29ubmVjdGlvbiksXG4gICAgICBvbGRCb3VuZHMgPSBzdWJ0cmFjdCh0YXJnZXQsIG1vdmVEZWx0YSksXG4gICAgICBvbGRBbmNob3IgPSB3YXlwb2ludHNbIHdheXBvaW50cy5sZW5ndGggLSAxIF07XG5cbiAgcmV0dXJuIGdldE5ld0F0dGFjaFBvaW50KG9sZEFuY2hvci5vcmlnaW5hbCB8fCBvbGRBbmNob3IsIG9sZEJvdW5kcywgdGFyZ2V0KTtcbn1cblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gc3VidHJhY3QoYm91bmRzLCBkZWx0YSkge1xuICByZXR1cm4ge1xuICAgIHg6IGJvdW5kcy54IC0gZGVsdGEueCxcbiAgICB5OiBib3VuZHMueSAtIGRlbHRhLnksXG4gICAgd2lkdGg6IGJvdW5kcy53aWR0aCxcbiAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHRcbiAgfTtcbn1cblxuXG4vKipcbiAqIFJldHVybiB3YXlwb2ludHMgb2YgZ2l2ZW4gY29ubmVjdGlvbjsgdGhyb3cgaWYgbm9uIGV4aXN0cyAoc2hvdWxkIG5vdCBoYXBwZW4hISkuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKlxuICogQHJldHVybiB7QXJyYXk8UG9pbnQ+fVxuICovXG5mdW5jdGlvbiBzYWZlR2V0V2F5cG9pbnRzKGNvbm5lY3Rpb24pIHtcblxuICB2YXIgd2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHM7XG5cbiAgaWYgKCF3YXlwb2ludHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb25uZWN0aW9uIycgKyBjb25uZWN0aW9uLmlkICsgJzogbm8gd2F5cG9pbnRzJyk7XG4gIH1cblxuICByZXR1cm4gd2F5cG9pbnRzO1xufVxuXG5mdW5jdGlvbiBnZXRXYXlwb2ludHNJbnNpZGVCb3VuZHMod2F5cG9pbnRzLCBib3VuZHMpIHtcbiAgdmFyIG9yaWdpbmFsV2F5cG9pbnRzID0gbWFwKHdheXBvaW50cywgZ2V0T3JpZ2luYWwpO1xuXG4gIHJldHVybiBmaWx0ZXIob3JpZ2luYWxXYXlwb2ludHMsIGZ1bmN0aW9uKHdheXBvaW50KSB7XG4gICAgcmV0dXJuIGlzSW5zaWRlQm91bmRzKHdheXBvaW50LCBib3VuZHMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgcG9pbnQgaXMgaW5zaWRlIGJvdW5kcywgaW5jbC4gZWRnZXMuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAqIEBwYXJhbSB7Qm91bmRzfSBib3VuZHNcbiAqL1xuZnVuY3Rpb24gaXNJbnNpZGVCb3VuZHMocG9pbnQsIGJvdW5kcykge1xuICByZXR1cm4gZ2V0T3JpZW50YXRpb24oYm91bmRzLCBwb2ludCwgMSkgPT09ICdpbnRlcnNlY3QnO1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5hbChwb2ludCkge1xuICByZXR1cm4gcG9pbnQub3JpZ2luYWwgfHwgcG9pbnQ7XG59XG4iLCJpbXBvcnQge1xuICBhc3NpZ25cbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRDbG9zdXJlXG59IGZyb20gJy4uLy4uLy4uLy4uL3V0aWwvRWxlbWVudHMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1vdmVDbG9zdXJlKCkge1xuXG4gIHRoaXMuYWxsU2hhcGVzID0ge307XG4gIHRoaXMuYWxsQ29ubmVjdGlvbnMgPSB7fTtcblxuICB0aGlzLmVuY2xvc2VkRWxlbWVudHMgPSB7fTtcbiAgdGhpcy5lbmNsb3NlZENvbm5lY3Rpb25zID0ge307XG5cbiAgdGhpcy50b3BMZXZlbCA9IHt9O1xufVxuXG5cbk1vdmVDbG9zdXJlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlbGVtZW50LCBpc1RvcExldmVsKSB7XG4gIHJldHVybiB0aGlzLmFkZEFsbChbIGVsZW1lbnQgXSwgaXNUb3BMZXZlbCk7XG59O1xuXG5cbk1vdmVDbG9zdXJlLnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbihlbGVtZW50cywgaXNUb3BMZXZlbCkge1xuXG4gIHZhciBuZXdDbG9zdXJlID0gZ2V0Q2xvc3VyZShlbGVtZW50cywgISFpc1RvcExldmVsLCB0aGlzKTtcblxuICBhc3NpZ24odGhpcywgbmV3Q2xvc3VyZSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59OyIsImltcG9ydCB7XG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBnZXRNb3ZlZFNvdXJjZUFuY2hvcixcbiAgZ2V0TW92ZWRUYXJnZXRBbmNob3Jcbn0gZnJvbSAnLi9BbmNob3JzSGVscGVyJztcblxuaW1wb3J0IE1vdmVDbG9zdXJlIGZyb20gJy4vTW92ZUNsb3N1cmUnO1xuXG5cbi8qKlxuICogQSBoZWxwZXIgdGhhdCBpcyBhYmxlIHRvIGNhcnJ5IG91dCBzZXJpYWxpemVkIG1vdmVcbiAqIG9wZXJhdGlvbnMgb24gbXVsdGlwbGUgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtNb2RlbGluZ30gbW9kZWxpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW92ZUhlbHBlcihtb2RlbGluZykge1xuICB0aGlzLl9tb2RlbGluZyA9IG1vZGVsaW5nO1xufVxuXG4vKipcbiAqIE1vdmUgdGhlIHNwZWNpZmllZCBlbGVtZW50cyBhbmQgYWxsIGNoaWxkcmVuIGJ5IHRoZSBnaXZlbiBkZWx0YS5cbiAqXG4gKiBUaGlzIG1vdmVzIGFsbCBlbmNsb3NlZCBjb25uZWN0aW9ucywgdG9vIGFuZCBsYXlvdXRzIGFsbCBhZmZlY3RlZFxuICogZXh0ZXJuYWwgY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtICB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBlbGVtZW50c1xuICogQHBhcmFtICB7UG9pbnR9IGRlbHRhXG4gKiBAcGFyYW0gIHtkanMubW9kZWwuQmFzZX0gbmV3UGFyZW50IGFwcGxpZWQgdG8gdGhlIGZpcnN0IGxldmVsIG9mIHNoYXBlc1xuICpcbiAqIEByZXR1cm4ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gbGlzdCBvZiB0b3VjaGVkIGVsZW1lbnRzXG4gKi9cbk1vdmVIZWxwZXIucHJvdG90eXBlLm1vdmVSZWN1cnNpdmUgPSBmdW5jdGlvbihlbGVtZW50cywgZGVsdGEsIG5ld1BhcmVudCkge1xuICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm1vdmVDbG9zdXJlKHRoaXMuZ2V0Q2xvc3VyZShlbGVtZW50cyksIGRlbHRhLCBuZXdQYXJlbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIE1vdmUgdGhlIGdpdmVuIGNsb3N1cmUgb2YgZWxtZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjbG9zdXJlXG4gKiBAcGFyYW0ge1BvaW50fSBkZWx0YVxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gW25ld1BhcmVudF1cbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IFtuZXdIb3N0XVxuICovXG5Nb3ZlSGVscGVyLnByb3RvdHlwZS5tb3ZlQ2xvc3VyZSA9IGZ1bmN0aW9uKGNsb3N1cmUsIGRlbHRhLCBuZXdQYXJlbnQsIG5ld0hvc3QsIHByaW1hcnlTaGFwZSkge1xuICB2YXIgbW9kZWxpbmcgPSB0aGlzLl9tb2RlbGluZztcblxuICB2YXIgYWxsU2hhcGVzID0gY2xvc3VyZS5hbGxTaGFwZXMsXG4gICAgICBhbGxDb25uZWN0aW9ucyA9IGNsb3N1cmUuYWxsQ29ubmVjdGlvbnMsXG4gICAgICBlbmNsb3NlZENvbm5lY3Rpb25zID0gY2xvc3VyZS5lbmNsb3NlZENvbm5lY3Rpb25zLFxuICAgICAgdG9wTGV2ZWwgPSBjbG9zdXJlLnRvcExldmVsLFxuICAgICAga2VlcFBhcmVudCA9IGZhbHNlO1xuXG4gIGlmIChwcmltYXJ5U2hhcGUgJiYgcHJpbWFyeVNoYXBlLnBhcmVudCA9PT0gbmV3UGFyZW50KSB7XG4gICAga2VlcFBhcmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBtb3ZlIGFsbCBzaGFwZXNcbiAgZm9yRWFjaChhbGxTaGFwZXMsIGZ1bmN0aW9uKHNoYXBlKSB7XG5cbiAgICAvLyBtb3ZlIHRoZSBlbGVtZW50IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZGVsdGFcbiAgICBtb2RlbGluZy5tb3ZlU2hhcGUoc2hhcGUsIGRlbHRhLCB0b3BMZXZlbFtzaGFwZS5pZF0gJiYgIWtlZXBQYXJlbnQgJiYgbmV3UGFyZW50LCB7XG4gICAgICByZWN1cnNlOiBmYWxzZSxcbiAgICAgIGxheW91dDogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gbW92ZSBhbGwgY2hpbGQgY29ubmVjdGlvbnMgLyBsYXlvdXQgZXh0ZXJuYWwgY29ubmVjdGlvbnNcbiAgZm9yRWFjaChhbGxDb25uZWN0aW9ucywgZnVuY3Rpb24oYykge1xuXG4gICAgdmFyIHNvdXJjZU1vdmVkID0gISFhbGxTaGFwZXNbYy5zb3VyY2UuaWRdLFxuICAgICAgICB0YXJnZXRNb3ZlZCA9ICEhYWxsU2hhcGVzW2MudGFyZ2V0LmlkXTtcblxuICAgIGlmIChlbmNsb3NlZENvbm5lY3Rpb25zW2MuaWRdICYmIHNvdXJjZU1vdmVkICYmIHRhcmdldE1vdmVkKSB7XG4gICAgICBtb2RlbGluZy5tb3ZlQ29ubmVjdGlvbihjLCBkZWx0YSwgdG9wTGV2ZWxbYy5pZF0gJiYgIWtlZXBQYXJlbnQgJiYgbmV3UGFyZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWxpbmcubGF5b3V0Q29ubmVjdGlvbihjLCB7XG4gICAgICAgIGNvbm5lY3Rpb25TdGFydDogc291cmNlTW92ZWQgJiYgZ2V0TW92ZWRTb3VyY2VBbmNob3IoYywgYy5zb3VyY2UsIGRlbHRhKSxcbiAgICAgICAgY29ubmVjdGlvbkVuZDogdGFyZ2V0TW92ZWQgJiYgZ2V0TW92ZWRUYXJnZXRBbmNob3IoYywgYy50YXJnZXQsIGRlbHRhKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2xvc3VyZSBmb3IgdGhlIHNlbGVjdGVkIGVsZW1lbnRzXG4gKlxuICogQHBhcmFtICB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBlbGVtZW50c1xuICogQHJldHVybiB7TW92ZUNsb3N1cmV9IGNsb3N1cmVcbiAqL1xuTW92ZUhlbHBlci5wcm90b3R5cGUuZ2V0Q2xvc3VyZSA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gIHJldHVybiBuZXcgTW92ZUNsb3N1cmUoKS5hZGRBbGwoZWxlbWVudHMsIHRydWUpO1xufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNb3VzZShldmVudEJ1cykge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgdGhpcy5fbGFzdE1vdmVFdmVudCA9IG51bGw7XHJcblxyXG4gIGZ1bmN0aW9uIHNldExhc3RNb3ZlRXZlbnQobW91c2Vtb3ZlRXZlbnQpIHtcclxuICAgIHNlbGYuX2xhc3RNb3ZlRXZlbnQgPSBtb3VzZW1vdmVFdmVudDtcclxuICB9XHJcblxyXG4gIGV2ZW50QnVzLm9uKCdjYW52YXMuaW5pdCcsIGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgIHZhciBzdmcgPSBzZWxmLl9zdmcgPSBjb250ZXh0LnN2ZztcclxuXHJcbiAgICBzdmcuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc2V0TGFzdE1vdmVFdmVudCk7XHJcbiAgfSk7XHJcblxyXG4gIGV2ZW50QnVzLm9uKCdjYW52YXMuZGVzdHJveScsIGZ1bmN0aW9uKCkge1xyXG4gICAgc2VsZi5fbGFzdE1vdXNlRXZlbnQgPSBudWxsO1xyXG5cclxuICAgIHNlbGYuX3N2Zy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzZXRMYXN0TW92ZUV2ZW50KTtcclxuICB9KTtcclxufVxyXG5cclxuTW91c2UuJGluamVjdCA9IFsgJ2V2ZW50QnVzJyBdO1xyXG5cclxuTW91c2UucHJvdG90eXBlLmdldExhc3RNb3ZlRXZlbnQgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5fbGFzdE1vdmVFdmVudCB8fCBjcmVhdGVNb3ZlRXZlbnQoMCwgMCk7XHJcbn07XHJcblxyXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNb3ZlRXZlbnQoeCwgeSkge1xyXG4gIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XHJcblxyXG4gIHZhciBzY3JlZW5YID0geCxcclxuICAgICAgc2NyZWVuWSA9IHksXHJcbiAgICAgIGNsaWVudFggPSB4LFxyXG4gICAgICBjbGllbnRZID0geTtcclxuXHJcbiAgaWYgKGV2ZW50LmluaXRNb3VzZUV2ZW50KSB7XHJcbiAgICBldmVudC5pbml0TW91c2VFdmVudChcclxuICAgICAgJ21vdXNlbW92ZScsXHJcbiAgICAgIHRydWUsXHJcbiAgICAgIHRydWUsXHJcbiAgICAgIHdpbmRvdyxcclxuICAgICAgMCxcclxuICAgICAgc2NyZWVuWCxcclxuICAgICAgc2NyZWVuWSxcclxuICAgICAgY2xpZW50WCxcclxuICAgICAgY2xpZW50WSxcclxuICAgICAgZmFsc2UsXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgZmFsc2UsXHJcbiAgICAgIDAsXHJcbiAgICAgIG51bGxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZXZlbnQ7XHJcbn0iLCJpbXBvcnQgTW91c2UgZnJvbSAnLi9Nb3VzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ21vdXNlJyBdLFxuICBtb3VzZTogWyAndHlwZScsIE1vdXNlIF1cbn07XG4iLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZpbHRlcixcbiAgZ3JvdXBCeSxcbiAgaXNPYmplY3Rcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG52YXIgTE9XX1BSSU9SSVRZID0gNTAwLFxuICAgIE1FRElVTV9QUklPUklUWSA9IDEyNTAsXG4gICAgSElHSF9QUklPUklUWSA9IDE1MDA7XG5cbmltcG9ydCB7IGdldE9yaWdpbmFsIGFzIGdldE9yaWdpbmFsRXZlbnQgfSBmcm9tICcuLi8uLi91dGlsL0V2ZW50JztcblxuaW1wb3J0IHtcbiAgaXNQcmltYXJ5QnV0dG9uXG59IGZyb20gJy4uLy4uL3V0aWwvTW91c2UnO1xuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG5mdW5jdGlvbiBtaWQoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQueCArIHJvdW5kKGVsZW1lbnQud2lkdGggLyAyKSxcbiAgICB5OiBlbGVtZW50LnkgKyByb3VuZChlbGVtZW50LmhlaWdodCAvIDIpXG4gIH07XG59XG5cbi8qKlxuICogQSBwbHVnaW4gdGhhdCBtYWtlcyBzaGFwZXMgZHJhZ2dhYmxlIC8gZHJvcHBhYmxlLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0RyYWdnaW5nfSBkcmFnZ2luZ1xuICogQHBhcmFtIHtNb2RlbGluZ30gbW9kZWxpbmdcbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7UnVsZXN9IHJ1bGVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1vdmVFdmVudHMoXG4gICAgZXZlbnRCdXMsIGRyYWdnaW5nLCBtb2RlbGluZyxcbiAgICBzZWxlY3Rpb24sIHJ1bGVzKSB7XG5cbiAgLy8gcnVsZXNcblxuICBmdW5jdGlvbiBjYW5Nb3ZlKHNoYXBlcywgZGVsdGEsIHBvc2l0aW9uLCB0YXJnZXQpIHtcblxuICAgIHJldHVybiBydWxlcy5hbGxvd2VkKCdlbGVtZW50cy5tb3ZlJywge1xuICAgICAgc2hhcGVzOiBzaGFwZXMsXG4gICAgICBkZWx0YTogZGVsdGEsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICB0YXJnZXQ6IHRhcmdldFxuICAgIH0pO1xuICB9XG5cblxuICAvLyBtb3ZlIGV2ZW50c1xuXG4gIC8vIGFzc2lnbiBhIGhpZ2ggcHJpb3JpdHkgdG8gdGhpcyBoYW5kbGVyIHRvIHNldHVwIHRoZSBlbnZpcm9ubWVudFxuICAvLyBvdGhlcnMgbWF5IGhvb2sgdXAgbGF0ZXIsIGUuZy4gYXQgZGVmYXVsdCBwcmlvcml0eSBhbmQgbW9kaWZ5XG4gIC8vIHRoZSBtb3ZlIGVudmlyb25tZW50LlxuICAvL1xuICAvLyBUaGlzIHNldHMgdXAgdGhlIGNvbnRleHQgd2l0aFxuICAvL1xuICAvLyAqIHNoYXBlOiB0aGUgcHJpbWFyeSBzaGFwZSBiZWluZyBtb3ZlZFxuICAvLyAqIHNoYXBlczogYSBsaXN0IG9mIHNoYXBlcyB0byBiZSBtb3ZlZFxuICAvLyAqIHZhbGlkYXRlZFNoYXBlczogYSBsaXN0IG9mIHNoYXBlcyB0aGF0IGFyZSBiZWluZyBjaGVja2VkXG4gIC8vICAgICAgICAgICAgICAgICAgICBhZ2FpbnN0IHRoZSBydWxlcyBiZWZvcmUgYW5kIGR1cmluZyBtb3ZlXG4gIC8vXG4gIGV2ZW50QnVzLm9uKCdzaGFwZS5tb3ZlLnN0YXJ0JywgSElHSF9QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgc2hhcGUgPSBldmVudC5zaGFwZSxcbiAgICAgICAgc2hhcGVzID0gc2VsZWN0aW9uLmdldCgpLnNsaWNlKCk7XG5cbiAgICAvLyBtb3ZlIG9ubHkgc2luZ2xlIHNoYXBlIGlmIHRoZSBkcmFnZ2VkIGVsZW1lbnRcbiAgICAvLyBpcyBub3QgcGFydCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICBpZiAoc2hhcGVzLmluZGV4T2Yoc2hhcGUpID09PSAtMSkge1xuICAgICAgc2hhcGVzID0gWyBzaGFwZSBdO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSB3ZSByZW1vdmUgbmVzdGVkIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgLy8gYW5kIGFkZCBhdHRhY2hlcnMgZm9yIGEgcHJvcGVyIGRyYWdnZXJcbiAgICBzaGFwZXMgPSByZW1vdmVOZXN0ZWQoc2hhcGVzKTtcblxuICAgIC8vIGF0dGFjaCBzaGFwZXMgdG8gZHJhZyBjb250ZXh0XG4gICAgYXNzaWduKGNvbnRleHQsIHtcbiAgICAgIHNoYXBlczogc2hhcGVzLFxuICAgICAgdmFsaWRhdGVkU2hhcGVzOiBzaGFwZXMsXG4gICAgICBzaGFwZTogc2hhcGVcbiAgICB9KTtcbiAgfSk7XG5cblxuICAvLyBhc3NpZ24gYSBoaWdoIHByaW9yaXR5IHRvIHRoaXMgaGFuZGxlciB0byBzZXR1cCB0aGUgZW52aXJvbm1lbnRcbiAgLy8gb3RoZXJzIG1heSBob29rIHVwIGxhdGVyLCBlLmcuIGF0IGRlZmF1bHQgcHJpb3JpdHkgYW5kIG1vZGlmeVxuICAvLyB0aGUgbW92ZSBlbnZpcm9ubWVudFxuICAvL1xuICBldmVudEJ1cy5vbignc2hhcGUubW92ZS5zdGFydCcsIE1FRElVTV9QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgdmFsaWRhdGVkU2hhcGVzID0gY29udGV4dC52YWxpZGF0ZWRTaGFwZXMsXG4gICAgICAgIGNhbkV4ZWN1dGU7XG5cbiAgICBjYW5FeGVjdXRlID0gY29udGV4dC5jYW5FeGVjdXRlID0gY2FuTW92ZSh2YWxpZGF0ZWRTaGFwZXMpO1xuXG4gICAgLy8gY2hlY2sgaWYgd2UgY2FuIG1vdmUgdGhlIGVsZW1lbnRzXG4gICAgaWYgKCFjYW5FeGVjdXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICAvLyBhc3NpZ24gYSBsb3cgcHJpb3JpdHkgdG8gdGhpcyBoYW5kbGVyXG4gIC8vIHRvIGxldCBvdGhlcnMgbW9kaWZ5IHRoZSBtb3ZlIGV2ZW50IGJlZm9yZSB3ZSB1cGRhdGVcbiAgLy8gdGhlIGNvbnRleHRcbiAgLy9cbiAgZXZlbnRCdXMub24oJ3NoYXBlLm1vdmUubW92ZScsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgdmFsaWRhdGVkU2hhcGVzID0gY29udGV4dC52YWxpZGF0ZWRTaGFwZXMsXG4gICAgICAgIGhvdmVyID0gZXZlbnQuaG92ZXIsXG4gICAgICAgIGRlbHRhID0geyB4OiBldmVudC5keCwgeTogZXZlbnQuZHkgfSxcbiAgICAgICAgcG9zaXRpb24gPSB7IHg6IGV2ZW50LngsIHk6IGV2ZW50LnkgfSxcbiAgICAgICAgY2FuRXhlY3V0ZTtcblxuICAgIC8vIGNoZWNrIGlmIHdlIGNhbiBtb3ZlIHRoZSBlbGVtZW50c1xuICAgIGNhbkV4ZWN1dGUgPSBjYW5Nb3ZlKHZhbGlkYXRlZFNoYXBlcywgZGVsdGEsIHBvc2l0aW9uLCBob3Zlcik7XG5cbiAgICBjb250ZXh0LmRlbHRhID0gZGVsdGE7XG4gICAgY29udGV4dC5jYW5FeGVjdXRlID0gY2FuRXhlY3V0ZTtcblxuICAgIC8vIHNpbXBseSBpZ25vcmUgbW92ZSBvdmVyXG4gICAgaWYgKGNhbkV4ZWN1dGUgPT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQudGFyZ2V0ID0gbnVsbDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQudGFyZ2V0ID0gaG92ZXI7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdzaGFwZS5tb3ZlLmVuZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQ7XG5cbiAgICB2YXIgZGVsdGEgPSBjb250ZXh0LmRlbHRhLFxuICAgICAgICBjYW5FeGVjdXRlID0gY29udGV4dC5jYW5FeGVjdXRlLFxuICAgICAgICBpc0F0dGFjaCA9IGNhbkV4ZWN1dGUgPT09ICdhdHRhY2gnLFxuICAgICAgICBzaGFwZXMgPSBjb250ZXh0LnNoYXBlcztcblxuICAgIGlmIChjYW5FeGVjdXRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSB3ZSBoYXZlIGFjdHVhbCBwaXhlbCB2YWx1ZXMgZGVsdGFzXG4gICAgLy8gKGltcG9ydGFudCB3aGVuIHpvb20gbGV2ZWwgd2FzID4gMSBkdXJpbmcgbW92ZSlcbiAgICBkZWx0YS54ID0gcm91bmQoZGVsdGEueCk7XG4gICAgZGVsdGEueSA9IHJvdW5kKGRlbHRhLnkpO1xuXG4gICAgaWYgKGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkge1xuXG4gICAgICAvLyBkaWRuJ3QgbW92ZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vZGVsaW5nLm1vdmVFbGVtZW50cyhzaGFwZXMsIGRlbHRhLCBjb250ZXh0LnRhcmdldCwge1xuICAgICAgcHJpbWFyeVNoYXBlOiBjb250ZXh0LnNoYXBlLFxuICAgICAgYXR0YWNoOiBpc0F0dGFjaFxuICAgIH0pO1xuICB9KTtcblxuXG4gIC8vIG1vdmUgYWN0aXZhdGlvblxuXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm1vdXNlZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICBpZiAoIWlzUHJpbWFyeUJ1dHRvbihldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGdldE9yaWdpbmFsRXZlbnQoZXZlbnQpO1xuXG4gICAgaWYgKCFvcmlnaW5hbEV2ZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3VwcGx5IERPTSBtb3VzZWRvd24gZXZlbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhcnQob3JpZ2luYWxFdmVudCwgZXZlbnQuZWxlbWVudCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTdGFydCBtb3ZlLlxuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7ZGpzLm1vZGVsLlNoYXBlfSBzaGFwZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthY3RpdmF0ZV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnQoZXZlbnQsIGVsZW1lbnQsIGFjdGl2YXRlLCBjb250ZXh0KSB7XG4gICAgaWYgKGlzT2JqZWN0KGFjdGl2YXRlKSkge1xuICAgICAgY29udGV4dCA9IGFjdGl2YXRlO1xuICAgICAgYWN0aXZhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBkbyBub3QgbW92ZSBjb25uZWN0aW9ucyBvciB0aGUgcm9vdCBlbGVtZW50XG4gICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzIHx8ICFlbGVtZW50LnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZWZlcmVuY2VQb2ludCA9IG1pZChlbGVtZW50KTtcblxuICAgIGRyYWdnaW5nLmluaXQoZXZlbnQsIHJlZmVyZW5jZVBvaW50LCAnc2hhcGUubW92ZScsIHtcbiAgICAgIGN1cnNvcjogJ2dyYWJiaW5nJyxcbiAgICAgIGF1dG9BY3RpdmF0ZTogYWN0aXZhdGUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNoYXBlOiBlbGVtZW50LFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0IHx8IHt9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB3ZSd2ZSBoYW5kbGVkIHRoZSBldmVudFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gQVBJXG5cbiAgdGhpcy5zdGFydCA9IHN0YXJ0O1xufVxuXG5Nb3ZlRXZlbnRzLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdkcmFnZ2luZycsXG4gICdtb2RlbGluZycsXG4gICdzZWxlY3Rpb24nLFxuICAncnVsZXMnXG5dO1xuXG5cbi8qKlxuICogUmV0dXJuIGEgZmlsdGVyZWQgbGlzdCBvZiBlbGVtZW50cyB0aGF0IGRvIG5vdCBjb250YWluXG4gKiB0aG9zZSBuZXN0ZWQgaW50byBvdGhlcnMuXG4gKlxuICogQHBhcmFtICB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBlbGVtZW50c1xuICpcbiAqIEByZXR1cm4ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZmlsdGVyZWRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTmVzdGVkKGVsZW1lbnRzKSB7XG5cbiAgdmFyIGlkcyA9IGdyb3VwQnkoZWxlbWVudHMsICdpZCcpO1xuXG4gIHJldHVybiBmaWx0ZXIoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCkpIHtcblxuICAgICAgLy8gcGFyZW50IGluIHNlbGVjdGlvblxuICAgICAgaWYgKGlkc1tlbGVtZW50LmlkXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtcbiAgZmxhdHRlbixcbiAgZm9yRWFjaCxcbiAgZmlsdGVyLFxuICBmaW5kLFxuICBncm91cEJ5LFxuICBtYXAsXG4gIG1hdGNoUGF0dGVybixcbiAgc2l6ZVxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIHNlbGZBbmRBbGxDaGlsZHJlblxufSBmcm9tICcuLi8uLi91dGlsL0VsZW1lbnRzJztcblxuaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjcmVhdGUgYXMgc3ZnQ3JlYXRlLFxuICByZW1vdmUgYXMgc3ZnUmVtb3ZlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbC9TdmdUcmFuc2Zvcm1VdGlsJztcblxudmFyIExPV19QUklPUklUWSA9IDQ5OTtcblxudmFyIE1BUktFUl9EUkFHR0lORyA9ICdkanMtZHJhZ2dpbmcnLFxuICAgIE1BUktFUl9PSyA9ICdkcm9wLW9rJyxcbiAgICBNQVJLRVJfTk9UX09LID0gJ2Ryb3Atbm90LW9rJyxcbiAgICBNQVJLRVJfTkVXX1BBUkVOVCA9ICduZXctcGFyZW50JyxcbiAgICBNQVJLRVJfQVRUQUNIID0gJ2F0dGFjaC1vayc7XG5cblxuLyoqXG4gKiBQcm92aWRlcyBwcmV2aWV3cyBmb3IgbW92aW5nIHNoYXBlcyB3aGVuIG1vdmluZy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnl9IGVsZW1lbnRSZWdpc3RyeVxuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtTdHlsZXN9IHN0eWxlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNb3ZlUHJldmlldyhcbiAgICBldmVudEJ1cywgY2FudmFzLCBzdHlsZXMsIHByZXZpZXdTdXBwb3J0KSB7XG5cbiAgZnVuY3Rpb24gZ2V0VmlzdWFsRHJhZ1NoYXBlcyhzaGFwZXMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBnZXRBbGxEcmFnZ2VkRWxlbWVudHMoc2hhcGVzKTtcblxuICAgIHZhciBmaWx0ZXJlZEVsZW1lbnRzID0gcmVtb3ZlRWRnZXMoZWxlbWVudHMpO1xuXG4gICAgcmV0dXJuIGZpbHRlcmVkRWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBbGxEcmFnZ2VkRWxlbWVudHMoc2hhcGVzKSB7XG4gICAgdmFyIGFsbFNoYXBlcyA9IHNlbGZBbmRBbGxDaGlsZHJlbihzaGFwZXMsIHRydWUpO1xuXG4gICAgdmFyIGFsbENvbm5lY3Rpb25zID0gbWFwKGFsbFNoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHJldHVybiAoc2hhcGUuaW5jb21pbmcgfHwgW10pLmNvbmNhdChzaGFwZS5vdXRnb2luZyB8fCBbXSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmxhdHRlbihhbGxTaGFwZXMuY29uY2F0KGFsbENvbm5lY3Rpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBkcm9wIG1hcmtlciBvbiBhbiBlbGVtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0TWFya2VyKGVsZW1lbnQsIG1hcmtlcikge1xuXG4gICAgWyBNQVJLRVJfQVRUQUNILCBNQVJLRVJfT0ssIE1BUktFUl9OT1RfT0ssIE1BUktFUl9ORVdfUEFSRU5UIF0uZm9yRWFjaChmdW5jdGlvbihtKSB7XG5cbiAgICAgIGlmIChtID09PSBtYXJrZXIpIHtcbiAgICAgICAgY2FudmFzLmFkZE1hcmtlcihlbGVtZW50LCBtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoZWxlbWVudCwgbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhbiBlbGVtZW50IGRyYWdnYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFkZE1hcmtlclxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZURyYWdnYWJsZShjb250ZXh0LCBlbGVtZW50LCBhZGRNYXJrZXIpIHtcblxuICAgIHByZXZpZXdTdXBwb3J0LmFkZERyYWdnZXIoZWxlbWVudCwgY29udGV4dC5kcmFnR3JvdXApO1xuXG4gICAgaWYgKGFkZE1hcmtlcikge1xuICAgICAgY2FudmFzLmFkZE1hcmtlcihlbGVtZW50LCBNQVJLRVJfRFJBR0dJTkcpO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LmFsbERyYWdnZWRFbGVtZW50cykge1xuICAgICAgY29udGV4dC5hbGxEcmFnZ2VkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5hbGxEcmFnZ2VkRWxlbWVudHMgPSBbIGVsZW1lbnQgXTtcbiAgICB9XG4gIH1cblxuICAvLyBhc3NpZ24gYSBsb3cgcHJpb3JpdHkgdG8gdGhpcyBoYW5kbGVyXG4gIC8vIHRvIGxldCBvdGhlcnMgbW9kaWZ5IHRoZSBtb3ZlIGNvbnRleHQgYmVmb3JlXG4gIC8vIHdlIGRyYXcgdGhpbmdzXG4gIGV2ZW50QnVzLm9uKCdzaGFwZS5tb3ZlLnN0YXJ0JywgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgZHJhZ1NoYXBlcyA9IGNvbnRleHQuc2hhcGVzLFxuICAgICAgICBhbGxEcmFnZ2VkRWxlbWVudHMgPSBjb250ZXh0LmFsbERyYWdnZWRFbGVtZW50cztcblxuICAgIHZhciB2aXN1YWxseURyYWdnZWRTaGFwZXMgPSBnZXRWaXN1YWxEcmFnU2hhcGVzKGRyYWdTaGFwZXMpO1xuXG4gICAgaWYgKCFjb250ZXh0LmRyYWdHcm91cCkge1xuICAgICAgdmFyIGRyYWdHcm91cCA9IHN2Z0NyZWF0ZSgnZycpO1xuXG4gICAgICBzdmdBdHRyKGRyYWdHcm91cCwgc3R5bGVzLmNscygnZGpzLWRyYWctZ3JvdXAnLCBbICduby1ldmVudHMnIF0pKTtcblxuICAgICAgdmFyIGRlZmF1bHRMYXllciA9IGNhbnZhcy5nZXREZWZhdWx0TGF5ZXIoKTtcblxuICAgICAgc3ZnQXBwZW5kKGRlZmF1bHRMYXllciwgZHJhZ0dyb3VwKTtcblxuICAgICAgY29udGV4dC5kcmFnR3JvdXAgPSBkcmFnR3JvdXA7XG4gICAgfVxuXG4gICAgLy8gYWRkIHByZXZpZXdzXG4gICAgdmlzdWFsbHlEcmFnZ2VkU2hhcGVzLmZvckVhY2goZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHByZXZpZXdTdXBwb3J0LmFkZERyYWdnZXIoc2hhcGUsIGNvbnRleHQuZHJhZ0dyb3VwKTtcbiAgICB9KTtcblxuICAgIC8vIGNhY2hlIGFsbCBkcmFnZ2VkIGVsZW1lbnRzIC8gZ2Z4XG4gICAgLy8gc28gdGhhdCB3ZSBjYW4gcXVpY2tseSB1bmRvIHRoZWlyIHN0YXRlIGNoYW5nZXMgbGF0ZXJcbiAgICBpZiAoIWFsbERyYWdnZWRFbGVtZW50cykge1xuICAgICAgYWxsRHJhZ2dlZEVsZW1lbnRzID0gZ2V0QWxsRHJhZ2dlZEVsZW1lbnRzKGRyYWdTaGFwZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGxEcmFnZ2VkRWxlbWVudHMgPSBmbGF0dGVuKFtcbiAgICAgICAgYWxsRHJhZ2dlZEVsZW1lbnRzLFxuICAgICAgICBnZXRBbGxEcmFnZ2VkRWxlbWVudHMoZHJhZ1NoYXBlcylcbiAgICAgIF0pO1xuICAgIH1cblxuICAgIC8vIGFkZCBkcmFnZ2luZyBtYXJrZXJcbiAgICBmb3JFYWNoKGFsbERyYWdnZWRFbGVtZW50cywgZnVuY3Rpb24oZSkge1xuICAgICAgY2FudmFzLmFkZE1hcmtlcihlLCBNQVJLRVJfRFJBR0dJTkcpO1xuICAgIH0pO1xuXG4gICAgY29udGV4dC5hbGxEcmFnZ2VkRWxlbWVudHMgPSBhbGxEcmFnZ2VkRWxlbWVudHM7XG5cbiAgICAvLyBkZXRlcm1pbmUsIGlmIGFueSBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50cyBoYXZlIGRpZmZlcmVudCBwYXJlbnRzXG4gICAgY29udGV4dC5kaWZmZXJlbnRQYXJlbnRzID0gaGF2ZURpZmZlcmVudFBhcmVudHMoZHJhZ1NoYXBlcyk7XG4gIH0pO1xuXG4gIC8vIHVwZGF0ZSBwcmV2aWV3c1xuICBldmVudEJ1cy5vbignc2hhcGUubW92ZS5tb3ZlJywgTE9XX1BSSU9SSVRZLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBkcmFnR3JvdXAgPSBjb250ZXh0LmRyYWdHcm91cCxcbiAgICAgICAgdGFyZ2V0ID0gY29udGV4dC50YXJnZXQsXG4gICAgICAgIHBhcmVudCA9IGNvbnRleHQuc2hhcGUucGFyZW50LFxuICAgICAgICBjYW5FeGVjdXRlID0gY29udGV4dC5jYW5FeGVjdXRlO1xuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgaWYgKGNhbkV4ZWN1dGUgPT09ICdhdHRhY2gnKSB7XG4gICAgICAgIHNldE1hcmtlcih0YXJnZXQsIE1BUktFUl9BVFRBQ0gpO1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmNhbkV4ZWN1dGUgJiYgdGFyZ2V0ICYmIHRhcmdldC5pZCAhPT0gcGFyZW50LmlkKSB7XG4gICAgICAgIHNldE1hcmtlcih0YXJnZXQsIE1BUktFUl9ORVdfUEFSRU5UKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1hcmtlcih0YXJnZXQsIGNvbnRleHQuY2FuRXhlY3V0ZSA/IE1BUktFUl9PSyA6IE1BUktFUl9OT1RfT0spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyYW5zbGF0ZShkcmFnR3JvdXAsIGV2ZW50LmR4LCBldmVudC5keSk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKFsgJ3NoYXBlLm1vdmUub3V0JywgJ3NoYXBlLm1vdmUuY2xlYW51cCcgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0O1xuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgc2V0TWFya2VyKHRhcmdldCwgbnVsbCk7XG4gICAgfVxuICB9KTtcblxuICAvLyByZW1vdmUgcHJldmlld3NcbiAgZXZlbnRCdXMub24oJ3NoYXBlLm1vdmUuY2xlYW51cCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGFsbERyYWdnZWRFbGVtZW50cyA9IGNvbnRleHQuYWxsRHJhZ2dlZEVsZW1lbnRzLFxuICAgICAgICBkcmFnR3JvdXAgPSBjb250ZXh0LmRyYWdHcm91cDtcblxuXG4gICAgLy8gcmVtb3ZlIGRyYWdnaW5nIG1hcmtlclxuICAgIGZvckVhY2goYWxsRHJhZ2dlZEVsZW1lbnRzLCBmdW5jdGlvbihlKSB7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGUsIE1BUktFUl9EUkFHR0lORyk7XG4gICAgfSk7XG5cbiAgICBpZiAoZHJhZ0dyb3VwKSB7XG4gICAgICBzdmdSZW1vdmUoZHJhZ0dyb3VwKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgLy8gQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogTWFrZSBhbiBlbGVtZW50IGRyYWdnYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFkZE1hcmtlclxuICAgKi9cbiAgdGhpcy5tYWtlRHJhZ2dhYmxlID0gbWFrZURyYWdnYWJsZTtcbn1cblxuTW92ZVByZXZpZXcuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ2NhbnZhcycsXG4gICdzdHlsZXMnLFxuICAncHJldmlld1N1cHBvcnQnXG5dO1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIHJldHVybnMgZWxlbWVudHMgbWludXMgYWxsIGNvbm5lY3Rpb25zXG4gKiB3aGVyZSBzb3VyY2Ugb3IgdGFyZ2V0IGlzIG5vdCBlbGVtZW50c1xuICovXG5mdW5jdGlvbiByZW1vdmVFZGdlcyhlbGVtZW50cykge1xuXG4gIHZhciBmaWx0ZXJlZEVsZW1lbnRzID0gZmlsdGVyKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICBpZiAoIWlzQ29ubmVjdGlvbihlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgZmluZChlbGVtZW50cywgbWF0Y2hQYXR0ZXJuKHsgaWQ6IGVsZW1lbnQuc291cmNlLmlkIH0pKSAmJlxuICAgICAgICBmaW5kKGVsZW1lbnRzLCBtYXRjaFBhdHRlcm4oeyBpZDogZWxlbWVudC50YXJnZXQuaWQgfSkpXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZpbHRlcmVkRWxlbWVudHM7XG59XG5cbmZ1bmN0aW9uIGhhdmVEaWZmZXJlbnRQYXJlbnRzKGVsZW1lbnRzKSB7XG4gIHJldHVybiBzaXplKGdyb3VwQnkoZWxlbWVudHMsIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUucGFyZW50ICYmIGUucGFyZW50LmlkOyB9KSkgIT09IDE7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGVsZW1lbnQgaXMgYSBjb25uZWN0aW9uLlxuICovXG5mdW5jdGlvbiBpc0Nvbm5lY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC53YXlwb2ludHM7XG59XG4iLCJpbXBvcnQgSW50ZXJhY3Rpb25FdmVudHNNb2R1bGUgZnJvbSAnLi4vaW50ZXJhY3Rpb24tZXZlbnRzJztcbmltcG9ydCBTZWxlY3Rpb25Nb2R1bGUgZnJvbSAnLi4vc2VsZWN0aW9uJztcbmltcG9ydCBPdXRsaW5lTW9kdWxlIGZyb20gJy4uL291dGxpbmUnO1xuaW1wb3J0IFJ1bGVzTW9kdWxlIGZyb20gJy4uL3J1bGVzJztcbmltcG9ydCBEcmFnZ2luZ01vZHVsZSBmcm9tICcuLi9kcmFnZ2luZyc7XG5pbXBvcnQgUHJldmlld1N1cHBvcnRNb2R1bGUgZnJvbSAnLi4vcHJldmlldy1zdXBwb3J0JztcblxuaW1wb3J0IE1vdmUgZnJvbSAnLi9Nb3ZlJztcbmltcG9ydCBNb3ZlUHJldmlldyBmcm9tICcuL01vdmVQcmV2aWV3JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIEludGVyYWN0aW9uRXZlbnRzTW9kdWxlLFxuICAgIFNlbGVjdGlvbk1vZHVsZSxcbiAgICBPdXRsaW5lTW9kdWxlLFxuICAgIFJ1bGVzTW9kdWxlLFxuICAgIERyYWdnaW5nTW9kdWxlLFxuICAgIFByZXZpZXdTdXBwb3J0TW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbXG4gICAgJ21vdmUnLFxuICAgICdtb3ZlUHJldmlldydcbiAgXSxcbiAgbW92ZTogWyAndHlwZScsIE1vdmUgXSxcbiAgbW92ZVByZXZpZXc6IFsgJ3R5cGUnLCBNb3ZlUHJldmlldyBdXG59O1xuIiwiaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IENvbW1hbmRJbnRlcmNlcHRvciBmcm9tICcuLi8uLi9jb21tYW5kL0NvbW1hbmRJbnRlcmNlcHRvcic7XG5cblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBwcm92aWRlciB0aGF0IGFsbG93cyBtb2RlbGVycyB0byBpbXBsZW1lbnQgYSBjdXN0b21cbiAqIG9yZGVyaW5nIG9mIGRpYWdyYW0gZWxlbWVudHMgb24gdGhlIGNhbnZhcy5cbiAqXG4gKiBJdCBtYWtlcyBzdXJlIHRoYXQgdGhlIG9yZGVyIGlzIGFsd2F5cyBwcmVzZXJ2ZWQgZHVyaW5nIGVsZW1lbnRcbiAqIGNyZWF0aW9uIGFuZCBtb3ZlIG9wZXJhdGlvbnMuXG4gKlxuICogSW4gb3JkZXIgdG8gdXNlIHRoaXMgYmVoYXZpb3IsIGluaGVyaXQgZnJvbSBpdCBhbmQgb3ZlcnJpZGVcbiAqIHRoZSBtZXRob2Qge0BsaW5rIE9yZGVyaW5nUHJvdmlkZXIjZ2V0T3JkZXJpbmd9LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24gQ3VzdG9tT3JkZXJpbmdQcm92aWRlcihldmVudEJ1cykge1xuICogICBPcmRlcmluZ1Byb3ZpZGVyLmNhbGwodGhpcywgZXZlbnRCdXMpO1xuICpcbiAqICAgdGhpcy5nZXRPcmRlcmluZyA9IGZ1bmN0aW9uKGVsZW1lbnQsIG5ld1BhcmVudCkge1xuICogICAgIC8vIGFsd2F5cyBpbnNlcnQgZWxlbWVudHMgYXQgdGhlIGZyb250XG4gKiAgICAgLy8gd2hlbiBtb3ZpbmdcbiAqICAgICByZXR1cm4ge1xuICogICAgICAgaW5kZXg6IDAsXG4gKiAgICAgICBwYXJlbnQ6IG5ld1BhcmVudFxuICogICAgIH07XG4gKiAgIH07XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBPcmRlcmluZ1Byb3ZpZGVyKGV2ZW50QnVzKSB7XG5cbiAgQ29tbWFuZEludGVyY2VwdG9yLmNhbGwodGhpcywgZXZlbnRCdXMpO1xuXG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucHJlRXhlY3V0ZShbICdzaGFwZS5jcmVhdGUnLCAnY29ubmVjdGlvbi5jcmVhdGUnIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnNoYXBlIHx8IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgICAgcGFyZW50ID0gY29udGV4dC5wYXJlbnQ7XG5cbiAgICB2YXIgb3JkZXJpbmcgPSBzZWxmLmdldE9yZGVyaW5nKGVsZW1lbnQsIHBhcmVudCk7XG5cbiAgICBpZiAob3JkZXJpbmcpIHtcblxuICAgICAgaWYgKG9yZGVyaW5nLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRleHQucGFyZW50ID0gb3JkZXJpbmcucGFyZW50O1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnBhcmVudEluZGV4ID0gb3JkZXJpbmcuaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLnByZUV4ZWN1dGUoWyAnc2hhcGUubW92ZScsICdjb25uZWN0aW9uLm1vdmUnIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnNoYXBlIHx8IGNvbnRleHQuY29ubmVjdGlvbixcbiAgICAgICAgcGFyZW50ID0gY29udGV4dC5uZXdQYXJlbnQgfHwgZWxlbWVudC5wYXJlbnQ7XG5cbiAgICB2YXIgb3JkZXJpbmcgPSBzZWxmLmdldE9yZGVyaW5nKGVsZW1lbnQsIHBhcmVudCk7XG5cbiAgICBpZiAob3JkZXJpbmcpIHtcblxuICAgICAgaWYgKG9yZGVyaW5nLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRleHQubmV3UGFyZW50ID0gb3JkZXJpbmcucGFyZW50O1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm5ld1BhcmVudEluZGV4ID0gb3JkZXJpbmcuaW5kZXg7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBjdXN0b20gb3JkZXJpbmcgb2YgdGhlIGVsZW1lbnQsIGJvdGggaW4gdGVybXNcbiAqIG9mIHBhcmVudCBlbGVtZW50IGFuZCBpbmRleCBpbiB0aGUgbmV3IHBhcmVudC5cbiAqXG4gKiBJbXBsZW1lbnRvcnMgb2YgdGhpcyBtZXRob2QgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdpdGhcbiAqIGBwYXJlbnRgIF9hbmRfIGBpbmRleGAgaW4gaXQuXG4gKlxuICogQHBhcmFtIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICogQHBhcmFtIHtkanMubW9kZWwuU2hhcGV9IG5ld1BhcmVudFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gb3JkZXJpbmcgZGVzY3JpcHRvclxuICovXG5PcmRlcmluZ1Byb3ZpZGVyLnByb3RvdHlwZS5nZXRPcmRlcmluZyA9IGZ1bmN0aW9uKGVsZW1lbnQsIG5ld1BhcmVudCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbmluaGVyaXRzKE9yZGVyaW5nUHJvdmlkZXIsIENvbW1hbmRJbnRlcmNlcHRvcik7IiwiaW1wb3J0IHsgZ2V0QkJveCB9IGZyb20gJy4uLy4uL3V0aWwvRWxlbWVudHMnO1xuXG52YXIgTE9XX1BSSU9SSVRZID0gNTAwO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5pbXBvcnQge1xuICBxdWVyeSBhcyBkb21RdWVyeVxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuXG4vKipcbiAqIEBjbGFzc1xuICpcbiAqIEEgcGx1Z2luIHRoYXQgYWRkcyBhbiBvdXRsaW5lIHRvIHNoYXBlcyBhbmQgY29ubmVjdGlvbnMgdGhhdCBtYXkgYmUgYWN0aXZhdGVkIGFuZCBzdHlsZWRcbiAqIHZpYSBDU1MgY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtTdHlsZXN9IHN0eWxlc1xuICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnl9IGVsZW1lbnRSZWdpc3RyeVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBPdXRsaW5lKGV2ZW50QnVzLCBzdHlsZXMsIGVsZW1lbnRSZWdpc3RyeSkge1xuXG4gIHRoaXMub2Zmc2V0ID0gNjtcblxuICB2YXIgT1VUTElORV9TVFlMRSA9IHN0eWxlcy5jbHMoJ2Rqcy1vdXRsaW5lJywgWyAnbm8tZmlsbCcgXSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU91dGxpbmUoZ2Z4LCBib3VuZHMpIHtcbiAgICB2YXIgb3V0bGluZSA9IHN2Z0NyZWF0ZSgncmVjdCcpO1xuXG4gICAgc3ZnQXR0cihvdXRsaW5lLCBhc3NpZ24oe1xuICAgICAgeDogMTAsXG4gICAgICB5OiAxMCxcbiAgICAgIHdpZHRoOiAxMDAsXG4gICAgICBoZWlnaHQ6IDEwMFxuICAgIH0sIE9VVExJTkVfU1RZTEUpKTtcblxuICAgIHN2Z0FwcGVuZChnZngsIG91dGxpbmUpO1xuXG4gICAgcmV0dXJuIG91dGxpbmU7XG4gIH1cblxuICAvLyBBIGxvdyBwcmlvcnRpdHkgaXMgbmVjZXNzYXJ5LCBiZWNhdXNlIG91dGxpbmVzIG9mIGxhYmVscyBoYXZlIHRvIGJlIHVwZGF0ZWRcbiAgLy8gYWZ0ZXIgdGhlIGxhYmVsIGJvdW5kcyBoYXZlIGJlZW4gdXBkYXRlZCBpbiB0aGUgcmVuZGVyZXIuXG4gIGV2ZW50QnVzLm9uKFsgJ3NoYXBlLmFkZGVkJywgJ3NoYXBlLmNoYW5nZWQnIF0sIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQsXG4gICAgICAgIGdmeCA9IGV2ZW50LmdmeDtcblxuICAgIHZhciBvdXRsaW5lID0gZG9tUXVlcnkoJy5kanMtb3V0bGluZScsIGdmeCk7XG5cbiAgICBpZiAoIW91dGxpbmUpIHtcbiAgICAgIG91dGxpbmUgPSBjcmVhdGVPdXRsaW5lKGdmeCwgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgc2VsZi51cGRhdGVTaGFwZU91dGxpbmUob3V0bGluZSwgZWxlbWVudCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKFsgJ2Nvbm5lY3Rpb24uYWRkZWQnLCAnY29ubmVjdGlvbi5jaGFuZ2VkJyBdLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudCxcbiAgICAgICAgZ2Z4ID0gZXZlbnQuZ2Z4O1xuXG4gICAgdmFyIG91dGxpbmUgPSBkb21RdWVyeSgnLmRqcy1vdXRsaW5lJywgZ2Z4KTtcblxuICAgIGlmICghb3V0bGluZSkge1xuICAgICAgb3V0bGluZSA9IGNyZWF0ZU91dGxpbmUoZ2Z4LCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICBzZWxmLnVwZGF0ZUNvbm5lY3Rpb25PdXRsaW5lKG91dGxpbmUsIGVsZW1lbnQpO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG91dGxpbmUgb2YgYSBzaGFwZSByZXNwZWN0aW5nIHRoZSBkaW1lbnNpb24gb2YgdGhlXG4gKiBlbGVtZW50IGFuZCBhbiBvdXRsaW5lIG9mZnNldC5cbiAqXG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSBvdXRsaW5lXG4gKiBAcGFyYW0gIHtkanMubW9kZWwuQmFzZX0gZWxlbWVudFxuICovXG5PdXRsaW5lLnByb3RvdHlwZS51cGRhdGVTaGFwZU91dGxpbmUgPSBmdW5jdGlvbihvdXRsaW5lLCBlbGVtZW50KSB7XG5cbiAgc3ZnQXR0cihvdXRsaW5lLCB7XG4gICAgeDogLXRoaXMub2Zmc2V0LFxuICAgIHk6IC10aGlzLm9mZnNldCxcbiAgICB3aWR0aDogZWxlbWVudC53aWR0aCArIHRoaXMub2Zmc2V0ICogMixcbiAgICBoZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0ICsgdGhpcy5vZmZzZXQgKiAyXG4gIH0pO1xuXG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgb3V0bGluZSBvZiBhIGNvbm5lY3Rpb24gcmVzcGVjdGluZyB0aGUgYm91bmRpbmcgYm94IG9mXG4gKiB0aGUgY29ubmVjdGlvbiBhbmQgYW4gb3V0bGluZSBvZmZzZXQuXG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gb3V0bGluZVxuICogQHBhcmFtICB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqL1xuT3V0bGluZS5wcm90b3R5cGUudXBkYXRlQ29ubmVjdGlvbk91dGxpbmUgPSBmdW5jdGlvbihvdXRsaW5lLCBjb25uZWN0aW9uKSB7XG5cbiAgdmFyIGJib3ggPSBnZXRCQm94KGNvbm5lY3Rpb24pO1xuXG4gIHN2Z0F0dHIob3V0bGluZSwge1xuICAgIHg6IGJib3gueCAtIHRoaXMub2Zmc2V0LFxuICAgIHk6IGJib3gueSAtIHRoaXMub2Zmc2V0LFxuICAgIHdpZHRoOiBiYm94LndpZHRoICsgdGhpcy5vZmZzZXQgKiAyLFxuICAgIGhlaWdodDogYmJveC5oZWlnaHQgKyB0aGlzLm9mZnNldCAqIDJcbiAgfSk7XG5cbn07XG5cblxuT3V0bGluZS4kaW5qZWN0ID0gWydldmVudEJ1cycsICdzdHlsZXMnLCAnZWxlbWVudFJlZ2lzdHJ5J107IiwiaW1wb3J0IE91dGxpbmUgZnJvbSAnLi9PdXRsaW5lJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAnb3V0bGluZScgXSxcbiAgb3V0bGluZTogWyAndHlwZScsIE91dGxpbmUgXVxufTsiLCJpbXBvcnQge1xuICBpc0FycmF5LFxuICBpc1N0cmluZyxcbiAgaXNPYmplY3QsXG4gIGFzc2lnbixcbiAgZm9yRWFjaCxcbiAgZmluZCxcbiAgZmlsdGVyLFxuICBtYXRjaFBhdHRlcm4sXG4gIGlzRGVmaW5lZFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGRvbWlmeSxcbiAgY2xhc3NlcyBhcyBkb21DbGFzc2VzLFxuICBhdHRyIGFzIGRvbUF0dHIsXG4gIHJlbW92ZSBhcyBkb21SZW1vdmUsXG4gIGNsZWFyIGFzIGRvbUNsZWFyXG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQge1xuICBnZXRCQm94XG59IGZyb20gJy4uLy4uL3V0aWwvRWxlbWVudHMnO1xuXG5pbXBvcnQgSWRzIGZyb20gJy4uLy4uL3V0aWwvSWRHZW5lcmF0b3InO1xuXG4vLyBkb2N1bWVudCB3aWRlIHVuaXF1ZSBvdmVybGF5IGlkc1xudmFyIGlkcyA9IG5ldyBJZHMoJ292Jyk7XG5cbnZhciBMT1dfUFJJT1JJVFkgPSA1MDA7XG5cblxuLyoqXG4gKiBBIHNlcnZpY2UgdGhhdCBhbGxvd3MgdXNlcnMgdG8gYXR0YWNoIG92ZXJsYXlzIHRvIGRpYWdyYW0gZWxlbWVudHMuXG4gKlxuICogVGhlIG92ZXJsYXkgc2VydmljZSB3aWxsIHRha2UgY2FyZSBvZiBvdmVybGF5IHBvc2l0aW9uaW5nIGR1cmluZyB1cGRhdGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gYWRkIGEgcGluayBiYWRnZSBvbiB0aGUgdG9wIGxlZnQgb2YgdGhlIHNoYXBlXG4gKiBvdmVybGF5cy5hZGQoc29tZVNoYXBlLCB7XG4gKiAgIHBvc2l0aW9uOiB7XG4gKiAgICAgdG9wOiAtNSxcbiAqICAgICBsZWZ0OiAtNVxuICogICB9LFxuICogICBodG1sOiAnPGRpdiBzdHlsZT1cIndpZHRoOiAxMHB4OyBiYWNrZ3JvdW5kOiBmdWNoc2lhOyBjb2xvcjogd2hpdGU7XCI+MDwvZGl2PidcbiAqIH0pO1xuICpcbiAqIC8vIG9yIGFkZCB2aWEgc2hhcGUgaWRcbiAqXG4gKiBvdmVybGF5cy5hZGQoJ3NvbWUtZWxlbWVudC1pZCcsIHtcbiAqICAgcG9zaXRpb246IHtcbiAqICAgICB0b3A6IC01LFxuICogICAgIGxlZnQ6IC01XG4gKiAgIH1cbiAqICAgaHRtbDogJzxkaXYgc3R5bGU9XCJ3aWR0aDogMTBweDsgYmFja2dyb3VuZDogZnVjaHNpYTsgY29sb3I6IHdoaXRlO1wiPjA8L2Rpdj4nXG4gKiB9KTtcbiAqXG4gKiAvLyBvciBhZGQgd2l0aCBvcHRpb25hbCB0eXBlXG4gKlxuICogb3ZlcmxheXMuYWRkKHNvbWVTaGFwZSwgJ2JhZGdlJywge1xuICogICBwb3NpdGlvbjoge1xuICogICAgIHRvcDogLTUsXG4gKiAgICAgbGVmdDogLTVcbiAqICAgfVxuICogICBodG1sOiAnPGRpdiBzdHlsZT1cIndpZHRoOiAxMHB4OyBiYWNrZ3JvdW5kOiBmdWNoc2lhOyBjb2xvcjogd2hpdGU7XCI+MDwvZGl2PidcbiAqIH0pO1xuICpcbiAqXG4gKiAvLyByZW1vdmUgYW4gb3ZlcmxheVxuICpcbiAqIHZhciBpZCA9IG92ZXJsYXlzLmFkZCguLi4pO1xuICogb3ZlcmxheXMucmVtb3ZlKGlkKTtcbiAqXG4gKlxuICogWW91IG1heSBjb25maWd1cmUgb3ZlcmxheSBkZWZhdWx0cyBkdXJpbmcgdG9vbCBieSBwcm92aWRpbmcgYSBgY29uZmlnYCBtb2R1bGVcbiAqIHdpdGggYG92ZXJsYXlzLmRlZmF1bHRzYCBhcyBhbiBlbnRyeTpcbiAqXG4gKiB7XG4gKiAgIG92ZXJsYXlzOiB7XG4gKiAgICAgZGVmYXVsdHM6IHtcbiAqICAgICAgIHNob3c6IHtcbiAqICAgICAgICAgbWluWm9vbTogMC43LFxuICogICAgICAgICBtYXhab29tOiA1LjBcbiAqICAgICAgIH0sXG4gKiAgICAgICBzY2FsZToge1xuICogICAgICAgICBtaW46IDFcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiB9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gT3ZlcmxheXMoY29uZmlnLCBldmVudEJ1cywgY2FudmFzLCBlbGVtZW50UmVnaXN0cnkpIHtcblxuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gIHRoaXMuX2VsZW1lbnRSZWdpc3RyeSA9IGVsZW1lbnRSZWdpc3RyeTtcblxuICB0aGlzLl9pZHMgPSBpZHM7XG5cbiAgdGhpcy5fb3ZlcmxheURlZmF1bHRzID0gYXNzaWduKHtcblxuICAgIC8vIG5vIHNob3cgY29uc3RyYWludHNcbiAgICBzaG93OiBudWxsLFxuXG4gICAgLy8gYWx3YXlzIHNjYWxlXG4gICAgc2NhbGU6IHRydWVcbiAgfSwgY29uZmlnICYmIGNvbmZpZy5kZWZhdWx0cyk7XG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgb3ZlcmxheUlkIC0+IG92ZXJsYXlcbiAgICovXG4gIHRoaXMuX292ZXJsYXlzID0ge307XG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZWxlbWVudElkIC0+IG92ZXJsYXkgY29udGFpbmVyXG4gICAqL1xuICB0aGlzLl9vdmVybGF5Q29udGFpbmVycyA9IFtdO1xuXG4gIC8vIHJvb3QgaHRtbCBlbGVtZW50IGZvciBhbGwgb3ZlcmxheXNcbiAgdGhpcy5fb3ZlcmxheVJvb3QgPSBjcmVhdGVSb290KGNhbnZhcy5nZXRDb250YWluZXIoKSk7XG5cbiAgdGhpcy5faW5pdCgpO1xufVxuXG5cbk92ZXJsYXlzLiRpbmplY3QgPSBbXG4gICdjb25maWcub3ZlcmxheXMnLFxuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJyxcbiAgJ2VsZW1lbnRSZWdpc3RyeSdcbl07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvdmVybGF5IHdpdGggdGhlIHNwZWNpZmllZCBpZCBvciBhIGxpc3Qgb2Ygb3ZlcmxheXNcbiAqIGZvciBhbiBlbGVtZW50IHdpdGggYSBnaXZlbiB0eXBlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gcmV0dXJuIHRoZSBzaW5nbGUgb3ZlcmxheSB3aXRoIHRoZSBnaXZlbiBpZFxuICogb3ZlcmxheXMuZ2V0KCdzb21lLWlkJyk7XG4gKlxuICogLy8gcmV0dXJuIGFsbCBvdmVybGF5cyBmb3IgdGhlIHNoYXBlXG4gKiBvdmVybGF5cy5nZXQoeyBlbGVtZW50OiBzb21lU2hhcGUgfSk7XG4gKlxuICogLy8gcmV0dXJuIGFsbCBvdmVybGF5cyBvbiBzaGFwZSB3aXRoIHR5cGUgJ2JhZGdlJ1xuICogb3ZlcmxheXMuZ2V0KHsgZWxlbWVudDogc29tZVNoYXBlLCB0eXBlOiAnYmFkZ2UnIH0pO1xuICpcbiAqIC8vIHNoYXBlIGNhbiBhbHNvIGJlIHNwZWNpZmllZCBhcyBpZFxuICogb3ZlcmxheXMuZ2V0KHsgZWxlbWVudDogJ2VsZW1lbnQtaWQnLCB0eXBlOiAnYmFkZ2UnIH0pO1xuICpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VhcmNoXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NlYXJjaC5pZF1cbiAqIEBwYXJhbSB7c3RyaW5nfGRqcy5tb2RlbC5CYXNlfSBbc2VhcmNoLmVsZW1lbnRdXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NlYXJjaC50eXBlXVxuICpcbiAqIEByZXR1cm4ge09iamVjdHxBcnJheTxPYmplY3Q+fSB0aGUgb3ZlcmxheShzKVxuICovXG5PdmVybGF5cy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2VhcmNoKSB7XG5cbiAgaWYgKGlzU3RyaW5nKHNlYXJjaCkpIHtcbiAgICBzZWFyY2ggPSB7IGlkOiBzZWFyY2ggfTtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyhzZWFyY2guZWxlbWVudCkpIHtcbiAgICBzZWFyY2guZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5nZXQoc2VhcmNoLmVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKHNlYXJjaC5lbGVtZW50KSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2dldE92ZXJsYXlDb250YWluZXIoc2VhcmNoLmVsZW1lbnQsIHRydWUpO1xuXG4gICAgLy8gcmV0dXJuIGEgbGlzdCBvZiBvdmVybGF5cyB3aGVuIHNlYXJjaGluZyBieSBlbGVtZW50ICgrdHlwZSlcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gc2VhcmNoLnR5cGUgPyBmaWx0ZXIoY29udGFpbmVyLm92ZXJsYXlzLCBtYXRjaFBhdHRlcm4oeyB0eXBlOiBzZWFyY2gudHlwZSB9KSkgOiBjb250YWluZXIub3ZlcmxheXMuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSBlbHNlXG4gIGlmIChzZWFyY2gudHlwZSkge1xuICAgIHJldHVybiBmaWx0ZXIodGhpcy5fb3ZlcmxheXMsIG1hdGNoUGF0dGVybih7IHR5cGU6IHNlYXJjaC50eXBlIH0pKTtcbiAgfSBlbHNlIHtcblxuICAgIC8vIHJldHVybiBzaW5nbGUgZWxlbWVudCB3aGVuIHNlYXJjaGluZyBieSBpZFxuICAgIHJldHVybiBzZWFyY2guaWQgPyB0aGlzLl9vdmVybGF5c1tzZWFyY2guaWRdIDogbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGRzIGEgSFRNTCBvdmVybGF5IHRvIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZGpzLm1vZGVsLkJhc2V9ICAgZWxlbWVudCAgIGF0dGFjaCBvdmVybGF5IHRvIHRoaXMgc2hhcGVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFt0eXBlXSAgICBvcHRpb25hbCB0eXBlIHRvIGFzc2lnbiB0byB0aGUgb3ZlcmxheVxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgb3ZlcmxheSAgIHRoZSBvdmVybGF5IGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xET01FbGVtZW50fSAgICAgICBvdmVybGF5Lmh0bWwgICAgICAgICAgICAgICAgIGh0bWwgZWxlbWVudCB0byB1c2UgYXMgYW4gb3ZlcmxheVxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgW292ZXJsYXkuc2hvd10gICAgICAgICAgICAgICBzaG93IGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgICAgIFtvdmVybGF5LnNob3cubWluWm9vbV0gICAgICAgbWluaW1hbCB6b29tIGxldmVsIHRvIHNob3cgdGhlIG92ZXJsYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgICAgIFtvdmVybGF5LnNob3cubWF4Wm9vbV0gICAgICAgbWF4aW11bSB6b29tIGxldmVsIHRvIHNob3cgdGhlIG92ZXJsYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgICAgIG92ZXJsYXkucG9zaXRpb24gICAgICAgICAgICAgd2hlcmUgdG8gYXR0YWNoIHRoZSBvdmVybGF5XG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgICBbb3ZlcmxheS5wb3NpdGlvbi5sZWZ0XSAgICAgIHJlbGF0aXZlIHRvIGVsZW1lbnQgYmJveCBsZWZ0IGF0dGFjaG1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgICAgIFtvdmVybGF5LnBvc2l0aW9uLnRvcF0gICAgICAgcmVsYXRpdmUgdG8gZWxlbWVudCBiYm94IHRvcCBhdHRhY2htZW50XG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgICBbb3ZlcmxheS5wb3NpdGlvbi5ib3R0b21dICAgIHJlbGF0aXZlIHRvIGVsZW1lbnQgYmJveCBib3R0b20gYXR0YWNobWVudFxuICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgW292ZXJsYXkucG9zaXRpb24ucmlnaHRdICAgICByZWxhdGl2ZSB0byBlbGVtZW50IGJib3ggcmlnaHQgYXR0YWNobWVudFxuICogQHBhcmFtIHtib29sZWFufE9iamVjdH0gICAgICAgICAgW292ZXJsYXkuc2NhbGU9dHJ1ZV0gICAgICAgICBmYWxzZSB0byBwcmVzZXJ2ZSB0aGUgc2FtZSBzaXplIHJlZ2FyZGxlc3Mgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhZ3JhbSB6b29tXG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgICBbb3ZlcmxheS5zY2FsZS5taW5dXG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgICBbb3ZlcmxheS5zY2FsZS5tYXhdXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgICAgICAgaWQgdGhhdCBtYXkgYmUgdXNlZCB0byByZWZlcmVuY2UgdGhlIG92ZXJsYXkgZm9yIHVwZGF0ZSBvciByZW1vdmFsXG4gKi9cbk92ZXJsYXlzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlbGVtZW50LCB0eXBlLCBvdmVybGF5KSB7XG5cbiAgaWYgKGlzT2JqZWN0KHR5cGUpKSB7XG4gICAgb3ZlcmxheSA9IHR5cGU7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWVsZW1lbnQuaWQpIHtcbiAgICBlbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChlbGVtZW50KTtcbiAgfVxuXG4gIGlmICghb3ZlcmxheS5wb3NpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzcGVjaWZpeSBvdmVybGF5IHBvc2l0aW9uJyk7XG4gIH1cblxuICBpZiAoIW92ZXJsYXkuaHRtbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzcGVjaWZpeSBvdmVybGF5IGh0bWwnKTtcbiAgfVxuXG4gIGlmICghZWxlbWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBlbGVtZW50IHNwZWNpZmllZCcpO1xuICB9XG5cbiAgdmFyIGlkID0gdGhpcy5faWRzLm5leHQoKTtcblxuICBvdmVybGF5ID0gYXNzaWduKHt9LCB0aGlzLl9vdmVybGF5RGVmYXVsdHMsIG92ZXJsYXksIHtcbiAgICBpZDogaWQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIGh0bWw6IG92ZXJsYXkuaHRtbFxuICB9KTtcblxuICB0aGlzLl9hZGRPdmVybGF5KG92ZXJsYXkpO1xuXG4gIHJldHVybiBpZDtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYW4gb3ZlcmxheSB3aXRoIHRoZSBnaXZlbiBpZCBvciBhbGwgb3ZlcmxheXMgbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlci5cbiAqXG4gKiBAc2VlIE92ZXJsYXlzI2dldCBmb3IgZmlsdGVyIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtpZF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICovXG5PdmVybGF5cy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZmlsdGVyKSB7XG5cbiAgdmFyIG92ZXJsYXlzID0gdGhpcy5nZXQoZmlsdGVyKSB8fCBbXTtcblxuICBpZiAoIWlzQXJyYXkob3ZlcmxheXMpKSB7XG4gICAgb3ZlcmxheXMgPSBbIG92ZXJsYXlzIF07XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZm9yRWFjaChvdmVybGF5cywgZnVuY3Rpb24ob3ZlcmxheSkge1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuX2dldE92ZXJsYXlDb250YWluZXIob3ZlcmxheS5lbGVtZW50LCB0cnVlKTtcblxuICAgIGlmIChvdmVybGF5KSB7XG4gICAgICBkb21SZW1vdmUob3ZlcmxheS5odG1sKTtcbiAgICAgIGRvbVJlbW92ZShvdmVybGF5Lmh0bWxDb250YWluZXIpO1xuXG4gICAgICBkZWxldGUgb3ZlcmxheS5odG1sQ29udGFpbmVyO1xuICAgICAgZGVsZXRlIG92ZXJsYXkuZWxlbWVudDtcblxuICAgICAgZGVsZXRlIHNlbGYuX292ZXJsYXlzW292ZXJsYXkuaWRdO1xuICAgIH1cblxuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHZhciBpZHggPSBjb250YWluZXIub3ZlcmxheXMuaW5kZXhPZihvdmVybGF5KTtcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIGNvbnRhaW5lci5vdmVybGF5cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG59O1xuXG5cbk92ZXJsYXlzLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIHNldFZpc2libGUodGhpcy5fb3ZlcmxheVJvb3QpO1xufTtcblxuXG5PdmVybGF5cy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBzZXRWaXNpYmxlKHRoaXMuX292ZXJsYXlSb290LCBmYWxzZSk7XG59O1xuXG5PdmVybGF5cy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fb3ZlcmxheXMgPSB7fTtcblxuICB0aGlzLl9vdmVybGF5Q29udGFpbmVycyA9IFtdO1xuXG4gIGRvbUNsZWFyKHRoaXMuX292ZXJsYXlSb290KTtcbn07XG5cbk92ZXJsYXlzLnByb3RvdHlwZS5fdXBkYXRlT3ZlcmxheUNvbnRhaW5lciA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICB2YXIgZWxlbWVudCA9IGNvbnRhaW5lci5lbGVtZW50LFxuICAgICAgaHRtbCA9IGNvbnRhaW5lci5odG1sO1xuXG4gIC8vIHVwZGF0ZSBjb250YWluZXIgbGVmdCx0b3AgYWNjb3JkaW5nIHRvIHRoZSBlbGVtZW50cyB4LHkgY29vcmRpbmF0ZXNcbiAgLy8gdGhpcyBlbnN1cmVzIHdlIGNhbiBhdHRhY2ggY2hpbGQgZWxlbWVudHMgcmVsYXRpdmUgdG8gdGhpcyBjb250YWluZXJcblxuICB2YXIgeCA9IGVsZW1lbnQueCxcbiAgICAgIHkgPSBlbGVtZW50Lnk7XG5cbiAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgdmFyIGJib3ggPSBnZXRCQm94KGVsZW1lbnQpO1xuICAgIHggPSBiYm94Lng7XG4gICAgeSA9IGJib3gueTtcbiAgfVxuXG4gIHNldFBvc2l0aW9uKGh0bWwsIHgsIHkpO1xuXG4gIGRvbUF0dHIoY29udGFpbmVyLmh0bWwsICdkYXRhLWNvbnRhaW5lci1pZCcsIGVsZW1lbnQuaWQpO1xufTtcblxuXG5PdmVybGF5cy5wcm90b3R5cGUuX3VwZGF0ZU92ZXJsYXkgPSBmdW5jdGlvbihvdmVybGF5KSB7XG5cbiAgdmFyIHBvc2l0aW9uID0gb3ZlcmxheS5wb3NpdGlvbixcbiAgICAgIGh0bWxDb250YWluZXIgPSBvdmVybGF5Lmh0bWxDb250YWluZXIsXG4gICAgICBlbGVtZW50ID0gb3ZlcmxheS5lbGVtZW50O1xuXG4gIC8vIHVwZGF0ZSBvdmVybGF5IGh0bWwgcmVsYXRpdmUgdG8gc2hhcGUgYmVjYXVzZVxuICAvLyBpdCBpcyBhbHJlYWR5IHBvc2l0aW9uZWQgb24gdGhlIGVsZW1lbnRcblxuICAvLyB1cGRhdGUgcmVsYXRpdmVcbiAgdmFyIGxlZnQgPSBwb3NpdGlvbi5sZWZ0LFxuICAgICAgdG9wID0gcG9zaXRpb24udG9wO1xuXG4gIGlmIChwb3NpdGlvbi5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICB2YXIgd2lkdGg7XG5cbiAgICBpZiAoZWxlbWVudC53YXlwb2ludHMpIHtcbiAgICAgIHdpZHRoID0gZ2V0QkJveChlbGVtZW50KS53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBlbGVtZW50LndpZHRoO1xuICAgIH1cblxuICAgIGxlZnQgPSBwb3NpdGlvbi5yaWdodCAqIC0xICsgd2lkdGg7XG4gIH1cblxuICBpZiAocG9zaXRpb24uYm90dG9tICE9PSB1bmRlZmluZWQpIHtcblxuICAgIHZhciBoZWlnaHQ7XG5cbiAgICBpZiAoZWxlbWVudC53YXlwb2ludHMpIHtcbiAgICAgIGhlaWdodCA9IGdldEJCb3goZWxlbWVudCkuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSBlbGVtZW50LmhlaWdodDtcbiAgICB9XG5cbiAgICB0b3AgPSBwb3NpdGlvbi5ib3R0b20gKiAtMSArIGhlaWdodDtcbiAgfVxuXG4gIHNldFBvc2l0aW9uKGh0bWxDb250YWluZXIsIGxlZnQgfHwgMCwgdG9wIHx8IDApO1xufTtcblxuXG5PdmVybGF5cy5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXlDb250YWluZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBodG1sID0gZG9taWZ5KCc8ZGl2IGNsYXNzPVwiZGpzLW92ZXJsYXlzXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGVcIiAvPicpO1xuXG4gIHRoaXMuX292ZXJsYXlSb290LmFwcGVuZENoaWxkKGh0bWwpO1xuXG4gIHZhciBjb250YWluZXIgPSB7XG4gICAgaHRtbDogaHRtbCxcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIG92ZXJsYXlzOiBbXVxuICB9O1xuXG4gIHRoaXMuX3VwZGF0ZU92ZXJsYXlDb250YWluZXIoY29udGFpbmVyKTtcblxuICB0aGlzLl9vdmVybGF5Q29udGFpbmVycy5wdXNoKGNvbnRhaW5lcik7XG5cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn07XG5cblxuT3ZlcmxheXMucHJvdG90eXBlLl91cGRhdGVSb290ID0gZnVuY3Rpb24odmlld2JveCkge1xuICB2YXIgc2NhbGUgPSB2aWV3Ym94LnNjYWxlIHx8IDE7XG5cbiAgdmFyIG1hdHJpeCA9ICdtYXRyaXgoJyArXG4gIFtcbiAgICBzY2FsZSxcbiAgICAwLFxuICAgIDAsXG4gICAgc2NhbGUsXG4gICAgLTEgKiB2aWV3Ym94LnggKiBzY2FsZSxcbiAgICAtMSAqIHZpZXdib3gueSAqIHNjYWxlXG4gIF0uam9pbignLCcpICtcbiAgJyknO1xuXG4gIHNldFRyYW5zZm9ybSh0aGlzLl9vdmVybGF5Um9vdCwgbWF0cml4KTtcbn07XG5cblxuT3ZlcmxheXMucHJvdG90eXBlLl9nZXRPdmVybGF5Q29udGFpbmVyID0gZnVuY3Rpb24oZWxlbWVudCwgcmF3KSB7XG4gIHZhciBjb250YWluZXIgPSBmaW5kKHRoaXMuX292ZXJsYXlDb250YWluZXJzLCBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIGMuZWxlbWVudCA9PT0gZWxlbWVudDtcbiAgfSk7XG5cblxuICBpZiAoIWNvbnRhaW5lciAmJiAhcmF3KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZU92ZXJsYXlDb250YWluZXIoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyO1xufTtcblxuXG5PdmVybGF5cy5wcm90b3R5cGUuX2FkZE92ZXJsYXkgPSBmdW5jdGlvbihvdmVybGF5KSB7XG5cbiAgdmFyIGlkID0gb3ZlcmxheS5pZCxcbiAgICAgIGVsZW1lbnQgPSBvdmVybGF5LmVsZW1lbnQsXG4gICAgICBodG1sID0gb3ZlcmxheS5odG1sLFxuICAgICAgaHRtbENvbnRhaW5lcixcbiAgICAgIG92ZXJsYXlDb250YWluZXI7XG5cbiAgLy8gdW53cmFwIGpxdWVyeSAoZm9yIHRob3NlIHdobyBuZWVkIGl0KVxuICBpZiAoaHRtbC5nZXQgJiYgaHRtbC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuanF1ZXJ5KSB7XG4gICAgaHRtbCA9IGh0bWwuZ2V0KDApO1xuICB9XG5cbiAgLy8gY3JlYXRlIHByb3BlciBodG1sIGVsZW1lbnRzIGZyb21cbiAgLy8gb3ZlcmxheSBIVE1MIHN0cmluZ3NcbiAgaWYgKGlzU3RyaW5nKGh0bWwpKSB7XG4gICAgaHRtbCA9IGRvbWlmeShodG1sKTtcbiAgfVxuXG4gIG92ZXJsYXlDb250YWluZXIgPSB0aGlzLl9nZXRPdmVybGF5Q29udGFpbmVyKGVsZW1lbnQpO1xuXG4gIGh0bWxDb250YWluZXIgPSBkb21pZnkoJzxkaXYgY2xhc3M9XCJkanMtb3ZlcmxheVwiIGRhdGEtb3ZlcmxheS1pZD1cIicgKyBpZCArICdcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZVwiPicpO1xuXG4gIGh0bWxDb250YWluZXIuYXBwZW5kQ2hpbGQoaHRtbCk7XG5cbiAgaWYgKG92ZXJsYXkudHlwZSkge1xuICAgIGRvbUNsYXNzZXMoaHRtbENvbnRhaW5lcikuYWRkKCdkanMtb3ZlcmxheS0nICsgb3ZlcmxheS50eXBlKTtcbiAgfVxuXG4gIG92ZXJsYXkuaHRtbENvbnRhaW5lciA9IGh0bWxDb250YWluZXI7XG5cbiAgb3ZlcmxheUNvbnRhaW5lci5vdmVybGF5cy5wdXNoKG92ZXJsYXkpO1xuICBvdmVybGF5Q29udGFpbmVyLmh0bWwuYXBwZW5kQ2hpbGQoaHRtbENvbnRhaW5lcik7XG5cbiAgdGhpcy5fb3ZlcmxheXNbaWRdID0gb3ZlcmxheTtcblxuICB0aGlzLl91cGRhdGVPdmVybGF5KG92ZXJsYXkpO1xuICB0aGlzLl91cGRhdGVPdmVybGF5VmlzaWJpbHR5KG92ZXJsYXksIHRoaXMuX2NhbnZhcy52aWV3Ym94KCkpO1xufTtcblxuXG5PdmVybGF5cy5wcm90b3R5cGUuX3VwZGF0ZU92ZXJsYXlWaXNpYmlsdHkgPSBmdW5jdGlvbihvdmVybGF5LCB2aWV3Ym94KSB7XG4gIHZhciBzaG93ID0gb3ZlcmxheS5zaG93LFxuICAgICAgbWluWm9vbSA9IHNob3cgJiYgc2hvdy5taW5ab29tLFxuICAgICAgbWF4Wm9vbSA9IHNob3cgJiYgc2hvdy5tYXhab29tLFxuICAgICAgaHRtbENvbnRhaW5lciA9IG92ZXJsYXkuaHRtbENvbnRhaW5lcixcbiAgICAgIHZpc2libGUgPSB0cnVlO1xuXG4gIGlmIChzaG93KSB7XG4gICAgaWYgKFxuICAgICAgKGlzRGVmaW5lZChtaW5ab29tKSAmJiBtaW5ab29tID4gdmlld2JveC5zY2FsZSkgfHxcbiAgICAgIChpc0RlZmluZWQobWF4Wm9vbSkgJiYgbWF4Wm9vbSA8IHZpZXdib3guc2NhbGUpXG4gICAgKSB7XG4gICAgICB2aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0VmlzaWJsZShodG1sQ29udGFpbmVyLCB2aXNpYmxlKTtcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZU92ZXJsYXlTY2FsZShvdmVybGF5LCB2aWV3Ym94KTtcbn07XG5cblxuT3ZlcmxheXMucHJvdG90eXBlLl91cGRhdGVPdmVybGF5U2NhbGUgPSBmdW5jdGlvbihvdmVybGF5LCB2aWV3Ym94KSB7XG4gIHZhciBzaG91bGRTY2FsZSA9IG92ZXJsYXkuc2NhbGUsXG4gICAgICBtaW5TY2FsZSxcbiAgICAgIG1heFNjYWxlLFxuICAgICAgaHRtbENvbnRhaW5lciA9IG92ZXJsYXkuaHRtbENvbnRhaW5lcjtcblxuICB2YXIgc2NhbGUsIHRyYW5zZm9ybSA9ICcnO1xuXG4gIGlmIChzaG91bGRTY2FsZSAhPT0gdHJ1ZSkge1xuXG4gICAgaWYgKHNob3VsZFNjYWxlID09PSBmYWxzZSkge1xuICAgICAgbWluU2NhbGUgPSAxO1xuICAgICAgbWF4U2NhbGUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW5TY2FsZSA9IHNob3VsZFNjYWxlLm1pbjtcbiAgICAgIG1heFNjYWxlID0gc2hvdWxkU2NhbGUubWF4O1xuICAgIH1cblxuICAgIGlmIChpc0RlZmluZWQobWluU2NhbGUpICYmIHZpZXdib3guc2NhbGUgPCBtaW5TY2FsZSkge1xuICAgICAgc2NhbGUgPSAoMSAvIHZpZXdib3guc2NhbGUgfHwgMSkgKiBtaW5TY2FsZTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKG1heFNjYWxlKSAmJiB2aWV3Ym94LnNjYWxlID4gbWF4U2NhbGUpIHtcbiAgICAgIHNjYWxlID0gKDEgLyB2aWV3Ym94LnNjYWxlIHx8IDEpICogbWF4U2NhbGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRGVmaW5lZChzY2FsZSkpIHtcbiAgICB0cmFuc2Zvcm0gPSAnc2NhbGUoJyArIHNjYWxlICsgJywnICsgc2NhbGUgKyAnKSc7XG4gIH1cblxuICBzZXRUcmFuc2Zvcm0oaHRtbENvbnRhaW5lciwgdHJhbnNmb3JtKTtcbn07XG5cblxuT3ZlcmxheXMucHJvdG90eXBlLl91cGRhdGVPdmVybGF5c1Zpc2liaWx0eSA9IGZ1bmN0aW9uKHZpZXdib3gpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZm9yRWFjaCh0aGlzLl9vdmVybGF5cywgZnVuY3Rpb24ob3ZlcmxheSkge1xuICAgIHNlbGYuX3VwZGF0ZU92ZXJsYXlWaXNpYmlsdHkob3ZlcmxheSwgdmlld2JveCk7XG4gIH0pO1xufTtcblxuXG5PdmVybGF5cy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cblxuICAvLyBzY3JvbGwvem9vbSBpbnRlZ3JhdGlvblxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVZpZXdib3godmlld2JveCkge1xuICAgIHNlbGYuX3VwZGF0ZVJvb3Qodmlld2JveCk7XG4gICAgc2VsZi5fdXBkYXRlT3ZlcmxheXNWaXNpYmlsdHkodmlld2JveCk7XG5cbiAgICBzZWxmLnNob3coKTtcbiAgfVxuXG4gIGV2ZW50QnVzLm9uKCdjYW52YXMudmlld2JveC5jaGFuZ2luZycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgc2VsZi5oaWRlKCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjYW52YXMudmlld2JveC5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB1cGRhdGVWaWV3Ym94KGV2ZW50LnZpZXdib3gpO1xuICB9KTtcblxuXG4gIC8vIHJlbW92ZSBpbnRlZ3JhdGlvblxuXG4gIGV2ZW50QnVzLm9uKFsgJ3NoYXBlLnJlbW92ZScsICdjb25uZWN0aW9uLnJlbW92ZScgXSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS5lbGVtZW50O1xuICAgIHZhciBvdmVybGF5cyA9IHNlbGYuZ2V0KHsgZWxlbWVudDogZWxlbWVudCB9KTtcblxuICAgIGZvckVhY2gob3ZlcmxheXMsIGZ1bmN0aW9uKG8pIHtcbiAgICAgIHNlbGYucmVtb3ZlKG8uaWQpO1xuICAgIH0pO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuX2dldE92ZXJsYXlDb250YWluZXIoZWxlbWVudCk7XG5cbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICBkb21SZW1vdmUoY29udGFpbmVyLmh0bWwpO1xuICAgICAgdmFyIGkgPSBzZWxmLl9vdmVybGF5Q29udGFpbmVycy5pbmRleE9mKGNvbnRhaW5lcik7XG4gICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgc2VsZi5fb3ZlcmxheUNvbnRhaW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cblxuICAvLyBtb3ZlIGludGVncmF0aW9uXG5cbiAgZXZlbnRCdXMub24oJ2VsZW1lbnQuY2hhbmdlZCcsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS5lbGVtZW50O1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuX2dldE92ZXJsYXlDb250YWluZXIoZWxlbWVudCwgdHJ1ZSk7XG5cbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICBmb3JFYWNoKGNvbnRhaW5lci5vdmVybGF5cywgZnVuY3Rpb24ob3ZlcmxheSkge1xuICAgICAgICBzZWxmLl91cGRhdGVPdmVybGF5KG92ZXJsYXkpO1xuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuX3VwZGF0ZU92ZXJsYXlDb250YWluZXIoY29udGFpbmVyKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgLy8gbWFya2VyIGludGVncmF0aW9uLCBzaW1wbHkgYWRkIHRoZW0gb24gdGhlIG92ZXJsYXlzIGFzIGNsYXNzZXMsIHRvby5cblxuICBldmVudEJ1cy5vbignZWxlbWVudC5tYXJrZXIudXBkYXRlJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBjb250YWluZXIgPSBzZWxmLl9nZXRPdmVybGF5Q29udGFpbmVyKGUuZWxlbWVudCwgdHJ1ZSk7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgZG9tQ2xhc3Nlcyhjb250YWluZXIuaHRtbClbZS5hZGQgPyAnYWRkJyA6ICdyZW1vdmUnXShlLm1hcmtlcik7XG4gICAgfVxuICB9KTtcblxuXG4gIC8vIGNsZWFyIG92ZXJsYXlzIHdpdGggZGlhZ3JhbVxuXG4gIGV2ZW50QnVzLm9uKCdkaWFncmFtLmNsZWFyJywgdGhpcy5jbGVhciwgdGhpcyk7XG59O1xuXG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBjcmVhdGVSb290KHBhcmVudE5vZGUpIHtcbiAgdmFyIHJvb3QgPSBkb21pZnkoXG4gICAgJzxkaXYgY2xhc3M9XCJkanMtb3ZlcmxheS1jb250YWluZXJcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDA7IGhlaWdodDogMDtcIiAvPidcbiAgKTtcblxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShyb290LCBwYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xuXG4gIHJldHVybiByb290O1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGlvbihlbCwgeCwgeSkge1xuICBhc3NpZ24oZWwuc3R5bGUsIHsgbGVmdDogeCArICdweCcsIHRvcDogeSArICdweCcgfSk7XG59XG5cbmZ1bmN0aW9uIHNldFZpc2libGUoZWwsIHZpc2libGUpIHtcbiAgZWwuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPT09IGZhbHNlID8gJ25vbmUnIDogJyc7XG59XG5cbmZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbCwgdHJhbnNmb3JtKSB7XG5cbiAgZWwuc3R5bGVbJ3RyYW5zZm9ybS1vcmlnaW4nXSA9ICd0b3AgbGVmdCc7XG5cbiAgWyAnJywgJy1tcy0nLCAnLXdlYmtpdC0nIF0uZm9yRWFjaChmdW5jdGlvbihwcmVmaXgpIHtcbiAgICBlbC5zdHlsZVtwcmVmaXggKyAndHJhbnNmb3JtJ10gPSB0cmFuc2Zvcm07XG4gIH0pO1xufSIsImltcG9ydCBPdmVybGF5cyBmcm9tICcuL092ZXJsYXlzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAnb3ZlcmxheXMnIF0sXG4gIG92ZXJsYXlzOiBbICd0eXBlJywgT3ZlcmxheXMgXVxufTsiLCJpbXBvcnQge1xuICBpc0FycmF5LFxuICBpc0Z1bmN0aW9uLFxuICBmb3JFYWNoXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZG9taWZ5LFxuICBxdWVyeSBhcyBkb21RdWVyeSxcbiAgYXR0ciBhcyBkb21BdHRyLFxuICBjbGVhciBhcyBkb21DbGVhcixcbiAgY2xhc3NlcyBhcyBkb21DbGFzc2VzLFxuICBtYXRjaGVzIGFzIGRvbU1hdGNoZXMsXG4gIGRlbGVnYXRlIGFzIGRvbURlbGVnYXRlLFxuICBldmVudCBhcyBkb21FdmVudFxufSBmcm9tICdtaW4tZG9tJztcblxuXG52YXIgVE9HR0xFX1NFTEVDVE9SID0gJy5kanMtcGFsZXR0ZS10b2dnbGUnLFxuICAgIEVOVFJZX1NFTEVDVE9SID0gJy5lbnRyeScsXG4gICAgRUxFTUVOVF9TRUxFQ1RPUiA9IFRPR0dMRV9TRUxFQ1RPUiArICcsICcgKyBFTlRSWV9TRUxFQ1RPUjtcblxudmFyIFBBTEVUVEVfT1BFTl9DTFMgPSAnb3BlbicsXG4gICAgUEFMRVRURV9UV09fQ09MVU1OX0NMUyA9ICd0d28tY29sdW1uJztcblxudmFyIERFRkFVTFRfUFJJT1JJVFkgPSAxMDAwO1xuXG5cbi8qKlxuICogQSBwYWxldHRlIGNvbnRhaW5pbmcgbW9kZWxpbmcgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhbGV0dGUoZXZlbnRCdXMsIGNhbnZhcykge1xuXG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRCdXMub24oJ3Rvb2wtbWFuYWdlci51cGRhdGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0b29sID0gZXZlbnQudG9vbDtcblxuICAgIHNlbGYudXBkYXRlVG9vbEhpZ2hsaWdodCh0b29sKTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ2kxOG4uY2hhbmdlZCcsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3VwZGF0ZSgpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbignZGlhZ3JhbS5pbml0JywgZnVuY3Rpb24oKSB7XG5cbiAgICBzZWxmLl9kaWFncmFtSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgc2VsZi5fcmVidWlsZCgpO1xuICB9KTtcbn1cblxuUGFsZXR0ZS4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnLCAnY2FudmFzJyBdO1xuXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBwcm92aWRlciB3aXRoIHRoZSBwYWxldHRlXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBbcHJpb3JpdHk9MTAwMF1cbiAqIEBwYXJhbSAge1BhbGV0dGVQcm92aWRlcn0gcHJvdmlkZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcGFsZXR0ZVByb3ZpZGVyID0ge1xuICogICBnZXRQYWxldHRlRW50cmllczogZnVuY3Rpb24oKSB7XG4gKiAgICAgcmV0dXJuIGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAqICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgIC4uLmVudHJpZXMsXG4gKiAgICAgICAgICdlbnRyeS0xJzoge1xuICogICAgICAgICAgIGxhYmVsOiAnTXkgRW50cnknLFxuICogICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IGFsZXJ0KFwiSSBoYXZlIGJlZW4gY2xpY2tlZCFcIik7IH1cbiAqICAgICAgICAgfVxuICogICAgICAgfTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH07XG4gKlxuICogcGFsZXR0ZS5yZWdpc3RlclByb3ZpZGVyKDgwMCwgcGFsZXR0ZVByb3ZpZGVyKTtcbiAqL1xuUGFsZXR0ZS5wcm90b3R5cGUucmVnaXN0ZXJQcm92aWRlciA9IGZ1bmN0aW9uKHByaW9yaXR5LCBwcm92aWRlcikge1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgcHJvdmlkZXIgPSBwcmlvcml0eTtcbiAgICBwcmlvcml0eSA9IERFRkFVTFRfUFJJT1JJVFk7XG4gIH1cblxuICB0aGlzLl9ldmVudEJ1cy5vbigncGFsZXR0ZS5nZXRQcm92aWRlcnMnLCBwcmlvcml0eSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBldmVudC5wcm92aWRlcnMucHVzaChwcm92aWRlcik7XG4gIH0pO1xuXG4gIHRoaXMuX3JlYnVpbGQoKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYWxldHRlIGVudHJpZXNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBQYWxldHRlRW50cnlEZXNjcmlwdG9yPn0gbWFwIG9mIGVudHJpZXNcbiAqL1xuUGFsZXR0ZS5wcm90b3R5cGUuZ2V0RW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHJvdmlkZXJzID0gdGhpcy5fZ2V0UHJvdmlkZXJzKCk7XG5cbiAgcmV0dXJuIHByb3ZpZGVycy5yZWR1Y2UoYWRkUGFsZXR0ZUVudHJpZXMsIHt9KTtcbn07XG5cblBhbGV0dGUucHJvdG90eXBlLl9yZWJ1aWxkID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKCF0aGlzLl9kaWFncmFtSW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJvdmlkZXJzID0gdGhpcy5fZ2V0UHJvdmlkZXJzKCk7XG5cbiAgaWYgKCFwcm92aWRlcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cblxuICB0aGlzLl91cGRhdGUoKTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZVxuICovXG5QYWxldHRlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICB2YXIgcGFyZW50Q29udGFpbmVyID0gdGhpcy5fZ2V0UGFyZW50Q29udGFpbmVyKCk7XG5cbiAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvbWlmeShQYWxldHRlLkhUTUxfTUFSS1VQKTtcblxuICBwYXJlbnRDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICBkb21EZWxlZ2F0ZS5iaW5kKGNvbnRhaW5lciwgRUxFTUVOVF9TRUxFQ1RPUiwgJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciB0YXJnZXQgPSBldmVudC5kZWxlZ2F0ZVRhcmdldDtcblxuICAgIGlmIChkb21NYXRjaGVzKHRhcmdldCwgVE9HR0xFX1NFTEVDVE9SKSkge1xuICAgICAgcmV0dXJuIHNlbGYudG9nZ2xlKCk7XG4gICAgfVxuXG4gICAgc2VsZi50cmlnZ2VyKCdjbGljaycsIGV2ZW50KTtcbiAgfSk7XG5cbiAgLy8gcHJldmVudCBkcmFnIHByb3BhZ2F0aW9uXG4gIGRvbUV2ZW50LmJpbmQoY29udGFpbmVyLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG5cbiAgLy8gcHJldmVudCBkcmFnIHByb3BhZ2F0aW9uXG4gIGRvbURlbGVnYXRlLmJpbmQoY29udGFpbmVyLCBFTlRSWV9TRUxFQ1RPUiwgJ2RyYWdzdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgc2VsZi50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldmVudCk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdjYW52YXMucmVzaXplZCcsIHRoaXMuX2xheW91dENoYW5nZWQsIHRoaXMpO1xuXG4gIGV2ZW50QnVzLmZpcmUoJ3BhbGV0dGUuY3JlYXRlJywge1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyXG4gIH0pO1xufTtcblxuUGFsZXR0ZS5wcm90b3R5cGUuX2dldFByb3ZpZGVycyA9IGZ1bmN0aW9uKGlkKSB7XG5cbiAgdmFyIGV2ZW50ID0gdGhpcy5fZXZlbnRCdXMuY3JlYXRlRXZlbnQoe1xuICAgIHR5cGU6ICdwYWxldHRlLmdldFByb3ZpZGVycycsXG4gICAgcHJvdmlkZXJzOiBbXVxuICB9KTtcblxuICB0aGlzLl9ldmVudEJ1cy5maXJlKGV2ZW50KTtcblxuICByZXR1cm4gZXZlbnQucHJvdmlkZXJzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgcGFsZXR0ZSBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtzdGF0ZV0geyBvcGVuLCB0d29Db2x1bW4gfVxuICovXG5QYWxldHRlLnByb3RvdHlwZS5fdG9nZ2xlU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuXG4gIHN0YXRlID0gc3RhdGUgfHwge307XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMuX2dldFBhcmVudENvbnRhaW5lcigpLFxuICAgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIHZhciB0d29Db2x1bW47XG5cbiAgdmFyIGNscyA9IGRvbUNsYXNzZXMoY29udGFpbmVyKTtcblxuICBpZiAoJ3R3b0NvbHVtbicgaW4gc3RhdGUpIHtcbiAgICB0d29Db2x1bW4gPSBzdGF0ZS50d29Db2x1bW47XG4gIH0gZWxzZSB7XG4gICAgdHdvQ29sdW1uID0gdGhpcy5fbmVlZHNDb2xsYXBzZShwYXJlbnQuY2xpZW50SGVpZ2h0LCB0aGlzLl9lbnRyaWVzIHx8IHt9KTtcbiAgfVxuXG4gIC8vIGFsd2F5cyB1cGRhdGUgdHdvIGNvbHVtblxuICBjbHMudG9nZ2xlKFBBTEVUVEVfVFdPX0NPTFVNTl9DTFMsIHR3b0NvbHVtbik7XG5cbiAgaWYgKCdvcGVuJyBpbiBzdGF0ZSkge1xuICAgIGNscy50b2dnbGUoUEFMRVRURV9PUEVOX0NMUywgc3RhdGUub3Blbik7XG4gIH1cblxuICBldmVudEJ1cy5maXJlKCdwYWxldHRlLmNoYW5nZWQnLCB7XG4gICAgdHdvQ29sdW1uOiB0d29Db2x1bW4sXG4gICAgb3BlbjogdGhpcy5pc09wZW4oKVxuICB9KTtcbn07XG5cblBhbGV0dGUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgZW50cmllc0NvbnRhaW5lciA9IGRvbVF1ZXJ5KCcuZGpzLXBhbGV0dGUtZW50cmllcycsIHRoaXMuX2NvbnRhaW5lciksXG4gICAgICBlbnRyaWVzID0gdGhpcy5fZW50cmllcyA9IHRoaXMuZ2V0RW50cmllcygpO1xuXG4gIGRvbUNsZWFyKGVudHJpZXNDb250YWluZXIpO1xuXG4gIGZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnksIGlkKSB7XG5cbiAgICB2YXIgZ3JvdXBpbmcgPSBlbnRyeS5ncm91cCB8fCAnZGVmYXVsdCc7XG5cbiAgICB2YXIgY29udGFpbmVyID0gZG9tUXVlcnkoJ1tkYXRhLWdyb3VwPScgKyBncm91cGluZyArICddJywgZW50cmllc0NvbnRhaW5lcik7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lciA9IGRvbWlmeSgnPGRpdiBjbGFzcz1cImdyb3VwXCIgZGF0YS1ncm91cD1cIicgKyBncm91cGluZyArICdcIj48L2Rpdj4nKTtcbiAgICAgIGVudHJpZXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbCA9IGVudHJ5Lmh0bWwgfHwgKFxuICAgICAgZW50cnkuc2VwYXJhdG9yID9cbiAgICAgICAgJzxociBjbGFzcz1cInNlcGFyYXRvclwiIC8+JyA6XG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZW50cnlcIiBkcmFnZ2FibGU9XCJ0cnVlXCI+PC9kaXY+Jyk7XG5cblxuICAgIHZhciBjb250cm9sID0gZG9taWZ5KGh0bWwpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sKTtcblxuICAgIGlmICghZW50cnkuc2VwYXJhdG9yKSB7XG4gICAgICBkb21BdHRyKGNvbnRyb2wsICdkYXRhLWFjdGlvbicsIGlkKTtcblxuICAgICAgaWYgKGVudHJ5LnRpdGxlKSB7XG4gICAgICAgIGRvbUF0dHIoY29udHJvbCwgJ3RpdGxlJywgZW50cnkudGl0bGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW50cnkuY2xhc3NOYW1lKSB7XG4gICAgICAgIGFkZENsYXNzZXMoY29udHJvbCwgZW50cnkuY2xhc3NOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVudHJ5LmltYWdlVXJsKSB7XG4gICAgICAgIGNvbnRyb2wuYXBwZW5kQ2hpbGQoZG9taWZ5KCc8aW1nIHNyYz1cIicgKyBlbnRyeS5pbWFnZVVybCArICdcIj4nKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBvcGVuIGFmdGVyIHVwZGF0ZVxuICB0aGlzLm9wZW4oKTtcbn07XG5cblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGFjdGlvbiBhdmFpbGFibGUgb24gdGhlIHBhbGV0dGVcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGFjdGlvblxuICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG4gKi9cblBhbGV0dGUucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihhY3Rpb24sIGV2ZW50LCBhdXRvQWN0aXZhdGUpIHtcbiAgdmFyIGVudHJpZXMgPSB0aGlzLl9lbnRyaWVzLFxuICAgICAgZW50cnksXG4gICAgICBoYW5kbGVyLFxuICAgICAgb3JpZ2luYWxFdmVudCxcbiAgICAgIGJ1dHRvbiA9IGV2ZW50LmRlbGVnYXRlVGFyZ2V0IHx8IGV2ZW50LnRhcmdldDtcblxuICBpZiAoIWJ1dHRvbikge1xuICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgZW50cnkgPSBlbnRyaWVzW2RvbUF0dHIoYnV0dG9uLCAnZGF0YS1hY3Rpb24nKV07XG5cbiAgLy8gd2hlbiB1c2VyIGNsaWNrcyBvbiB0aGUgcGFsZXR0ZSBhbmQgbm90IG9uIGFuIGFjdGlvblxuICBpZiAoIWVudHJ5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaGFuZGxlciA9IGVudHJ5LmFjdGlvbjtcblxuICBvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudDtcblxuICAvLyBzaW1wbGUgYWN0aW9uICh2aWEgY2FsbGJhY2sgZnVuY3Rpb24pXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgaWYgKGFjdGlvbiA9PT0gJ2NsaWNrJykge1xuICAgICAgaGFuZGxlcihvcmlnaW5hbEV2ZW50LCBhdXRvQWN0aXZhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaGFuZGxlclthY3Rpb25dKSB7XG4gICAgICBoYW5kbGVyW2FjdGlvbl0ob3JpZ2luYWxFdmVudCwgYXV0b0FjdGl2YXRlKTtcbiAgICB9XG4gIH1cblxuICAvLyBzaWxlbmNlIG90aGVyIGFjdGlvbnNcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn07XG5cblBhbGV0dGUucHJvdG90eXBlLl9sYXlvdXRDaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3RvZ2dsZVN0YXRlKHt9KTtcbn07XG5cbi8qKlxuICogRG8gd2UgbmVlZCB0byBjb2xsYXBzZSB0byB0d28gY29sdW1ucz9cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYXZhaWxhYmxlSGVpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gZW50cmllc1xuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblBhbGV0dGUucHJvdG90eXBlLl9uZWVkc0NvbGxhcHNlID0gZnVuY3Rpb24oYXZhaWxhYmxlSGVpZ2h0LCBlbnRyaWVzKSB7XG5cbiAgLy8gdG9wIG1hcmdpbiArIGJvdHRvbSB0b2dnbGUgKyBib3R0b20gbWFyZ2luXG4gIC8vIGltcGxlbWVudG9ycyBtdXN0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHRoZXlcbiAgLy8gY2hhbmdlIHRoZSBwYWxldHRlIHN0eWxlc1xuICB2YXIgbWFyZ2luID0gMjAgKyAxMCArIDIwO1xuXG4gIHZhciBlbnRyaWVzSGVpZ2h0ID0gT2JqZWN0LmtleXMoZW50cmllcykubGVuZ3RoICogNDY7XG5cbiAgcmV0dXJuIGF2YWlsYWJsZUhlaWdodCA8IGVudHJpZXNIZWlnaHQgKyBtYXJnaW47XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBwYWxldHRlXG4gKi9cblBhbGV0dGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cbiAgdGhpcy5fdG9nZ2xlU3RhdGUoe1xuICAgIG9wZW46IGZhbHNlLFxuICAgIHR3b0NvbHVtbjogZmFsc2VcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogT3BlbiB0aGUgcGFsZXR0ZVxuICovXG5QYWxldHRlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3RvZ2dsZVN0YXRlKHsgb3BlbjogdHJ1ZSB9KTtcbn07XG5cblxuUGFsZXR0ZS5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24ob3Blbikge1xuICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wZW4oKTtcbiAgfVxufTtcblxuUGFsZXR0ZS5wcm90b3R5cGUuaXNBY3RpdmVUb29sID0gZnVuY3Rpb24odG9vbCkge1xuICByZXR1cm4gdG9vbCAmJiB0aGlzLl9hY3RpdmVUb29sID09PSB0b29sO1xufTtcblxuUGFsZXR0ZS5wcm90b3R5cGUudXBkYXRlVG9vbEhpZ2hsaWdodCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGVudHJpZXNDb250YWluZXIsXG4gICAgICB0b29sc0NvbnRhaW5lcjtcblxuICBpZiAoIXRoaXMuX3Rvb2xzQ29udGFpbmVyKSB7XG4gICAgZW50cmllc0NvbnRhaW5lciA9IGRvbVF1ZXJ5KCcuZGpzLXBhbGV0dGUtZW50cmllcycsIHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICB0aGlzLl90b29sc0NvbnRhaW5lciA9IGRvbVF1ZXJ5KCdbZGF0YS1ncm91cD10b29sc10nLCBlbnRyaWVzQ29udGFpbmVyKTtcbiAgfVxuXG4gIHRvb2xzQ29udGFpbmVyID0gdGhpcy5fdG9vbHNDb250YWluZXI7XG5cbiAgZm9yRWFjaCh0b29sc0NvbnRhaW5lci5jaGlsZHJlbiwgZnVuY3Rpb24odG9vbCkge1xuICAgIHZhciBhY3Rpb25OYW1lID0gdG9vbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWN0aW9uJyk7XG5cbiAgICBpZiAoIWFjdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdG9vbENsYXNzZXMgPSBkb21DbGFzc2VzKHRvb2wpO1xuXG4gICAgYWN0aW9uTmFtZSA9IGFjdGlvbk5hbWUucmVwbGFjZSgnLXRvb2wnLCAnJyk7XG5cbiAgICBpZiAodG9vbENsYXNzZXMuY29udGFpbnMoJ2VudHJ5JykgJiYgYWN0aW9uTmFtZSA9PT0gbmFtZSkge1xuICAgICAgdG9vbENsYXNzZXMuYWRkKCdoaWdobGlnaHRlZC1lbnRyeScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b29sQ2xhc3Nlcy5yZW1vdmUoJ2hpZ2hsaWdodGVkLWVudHJ5Jyk7XG4gICAgfVxuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcGFsZXR0ZSBpcyBvcGVuZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBwYWxldHRlLm9wZW4oKTtcbiAqXG4gKiBpZiAocGFsZXR0ZS5pc09wZW4oKSkge1xuICogICAvLyB5ZXMsIHdlIGFyZSBvcGVuXG4gKiB9XG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBwYWxldHRlIGlzIG9wZW5lZFxuICovXG5QYWxldHRlLnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGRvbUNsYXNzZXModGhpcy5fY29udGFpbmVyKS5oYXMoUEFMRVRURV9PUEVOX0NMUyk7XG59O1xuXG4vKipcbiAqIEdldCBjb250YWluZXIgdGhlIHBhbGV0dGUgbGl2ZXMgaW4uXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuUGFsZXR0ZS5wcm90b3R5cGUuX2dldFBhcmVudENvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzLmdldENvbnRhaW5lcigpO1xufTtcblxuXG4vKiBtYXJrdXAgZGVmaW5pdGlvbiAqL1xuXG5QYWxldHRlLkhUTUxfTUFSS1VQID1cbiAgJzxkaXYgY2xhc3M9XCJkanMtcGFsZXR0ZVwiPicgK1xuICAgICc8ZGl2IGNsYXNzPVwiZGpzLXBhbGV0dGUtZW50cmllc1wiPjwvZGl2PicgK1xuICAgICc8ZGl2IGNsYXNzPVwiZGpzLXBhbGV0dGUtdG9nZ2xlXCI+PC9kaXY+JyArXG4gICc8L2Rpdj4nO1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBhZGRDbGFzc2VzKGVsZW1lbnQsIGNsYXNzTmFtZXMpIHtcblxuICB2YXIgY2xhc3NlcyA9IGRvbUNsYXNzZXMoZWxlbWVudCk7XG5cbiAgdmFyIGFjdHVhbENsYXNzTmFtZXMgPSBpc0FycmF5KGNsYXNzTmFtZXMpID8gY2xhc3NOYW1lcyA6IGNsYXNzTmFtZXMuc3BsaXQoL1xccysvZyk7XG4gIGFjdHVhbENsYXNzTmFtZXMuZm9yRWFjaChmdW5jdGlvbihjbHMpIHtcbiAgICBjbGFzc2VzLmFkZChjbHMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkUGFsZXR0ZUVudHJpZXMoZW50cmllcywgcHJvdmlkZXIpIHtcblxuICB2YXIgZW50cmllc09yVXBkYXRlciA9IHByb3ZpZGVyLmdldFBhbGV0dGVFbnRyaWVzKCk7XG5cbiAgaWYgKGlzRnVuY3Rpb24oZW50cmllc09yVXBkYXRlcikpIHtcbiAgICByZXR1cm4gZW50cmllc09yVXBkYXRlcihlbnRyaWVzKTtcbiAgfVxuXG4gIGZvckVhY2goZW50cmllc09yVXBkYXRlciwgZnVuY3Rpb24oZW50cnksIGlkKSB7XG4gICAgZW50cmllc1tpZF0gPSBlbnRyeTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVudHJpZXM7XG59IiwiaW1wb3J0IFBhbGV0dGUgZnJvbSAnLi9QYWxldHRlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAncGFsZXR0ZScgXSxcbiAgcGFsZXR0ZTogWyAndHlwZScsIFBhbGV0dGUgXVxufTtcbiIsImltcG9ydCB7XG4gIGFzc2lnbixcbiAgZm9yRWFjaCxcbiAgaXNGdW5jdGlvbixcbiAgaXNEZWZpbmVkLFxuICBvbWl0LFxuICBzaXplXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgZGVsZWdhdGUgYXMgZG9tRGVsZWdhdGUsXG4gIGRvbWlmeSBhcyBkb21pZnksXG4gIGNsYXNzZXMgYXMgZG9tQ2xhc3NlcyxcbiAgYXR0ciBhcyBkb21BdHRyLFxuICByZW1vdmUgYXMgZG9tUmVtb3ZlXG59IGZyb20gJ21pbi1kb20nO1xuXG52YXIgREFUQV9SRUYgPSAnZGF0YS1pZCc7XG5cbnZhciBDTE9TRV9FVkVOVFMgPSBbXG4gICdjb250ZXh0UGFkLmNsb3NlJyxcbiAgJ2NhbnZhcy52aWV3Ym94LmNoYW5naW5nJyxcbiAgJ2NvbW1hbmRTdGFjay5jaGFuZ2VkJ1xuXTtcblxudmFyIERFRkFVTFRfUFJJT1JJVFkgPSAxMDAwO1xuXG5cbi8qKlxuICogQSBwb3B1cCBtZW51IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBhIGxpc3Qgb2YgYWN0aW9ucyBhbnl3aGVyZSBpbiB0aGUgY2FudmFzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtjb25maWcuc2NhbGU9eyBtaW46IDEuMCwgbWF4OiAxLjUgfV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLnNjYWxlLm1pbl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLnNjYWxlLm1heF1cbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9wdXBNZW51KGNvbmZpZywgZXZlbnRCdXMsIGNhbnZhcykge1xuXG4gIHZhciBzY2FsZSA9IGlzRGVmaW5lZChjb25maWcgJiYgY29uZmlnLnNjYWxlKSA/IGNvbmZpZy5zY2FsZSA6IHtcbiAgICBtaW46IDEsXG4gICAgbWF4OiAxLjVcbiAgfTtcblxuICB0aGlzLl9jb25maWcgPSB7XG4gICAgc2NhbGU6IHNjYWxlXG4gIH07XG5cbiAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICB0aGlzLl9wcm92aWRlcnMgPSB7fTtcbiAgdGhpcy5fY3VycmVudCA9IHt9O1xufVxuXG5Qb3B1cE1lbnUuJGluamVjdCA9IFtcbiAgJ2NvbmZpZy5wb3B1cE1lbnUnLFxuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJ1xuXTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBwb3B1cCBtZW51IHByb3ZpZGVyXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBpZFxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXVxuICogQHBhcmFtICB7T2JqZWN0fSBwcm92aWRlclxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwb3B1cE1lbnVQcm92aWRlciA9IHtcbiAqICAgZ2V0UG9wdXBNZW51RW50cmllczogZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgIHJldHVybiB7XG4gKiAgICAgICAnZW50cnktMSc6IHtcbiAqICAgICAgICAgbGFiZWw6ICdNeSBFbnRyeScsXG4gKiAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IGFsZXJ0KFwiSSBoYXZlIGJlZW4gY2xpY2tlZCFcIik7IH1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH07XG4gKlxuICogcG9wdXBNZW51LnJlZ2lzdGVyUHJvdmlkZXIoJ215TWVudUlEJywgcG9wdXBNZW51UHJvdmlkZXIpO1xuICovXG5Qb3B1cE1lbnUucHJvdG90eXBlLnJlZ2lzdGVyUHJvdmlkZXIgPSBmdW5jdGlvbihpZCwgcHJpb3JpdHksIHByb3ZpZGVyKSB7XG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICBwcm92aWRlciA9IHByaW9yaXR5O1xuICAgIHByaW9yaXR5ID0gREVGQVVMVF9QUklPUklUWTtcbiAgfVxuXG4gIHRoaXMuX2V2ZW50QnVzLm9uKCdwb3B1cE1lbnUuZ2V0UHJvdmlkZXJzLicgKyBpZCwgcHJpb3JpdHksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgZXZlbnQucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBwb3B1cCBtZW51IGhhcyBlbnRyaWVzLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgZW1wdHlcbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oZWxlbWVudCwgcHJvdmlkZXJJZCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgcGFyYW1ldGVyIGlzIG1pc3NpbmcnKTtcbiAgfVxuXG4gIGlmICghcHJvdmlkZXJJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvdmlkZXJJZCBwYXJhbWV0ZXIgaXMgbWlzc2luZycpO1xuICB9XG5cbiAgdmFyIHByb3ZpZGVycyA9IHRoaXMuX2dldFByb3ZpZGVycyhwcm92aWRlcklkKTtcblxuICBpZiAoIXByb3ZpZGVycykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGVudHJpZXMgPSB0aGlzLl9nZXRFbnRyaWVzKGVsZW1lbnQsIHByb3ZpZGVycyksXG4gICAgICBoZWFkZXJFbnRyaWVzID0gdGhpcy5fZ2V0SGVhZGVyRW50cmllcyhlbGVtZW50LCBwcm92aWRlcnMpO1xuXG4gIHZhciBoYXNFbnRyaWVzID0gc2l6ZShlbnRyaWVzKSA+IDAsXG4gICAgICBoYXNIZWFkZXJFbnRyaWVzID0gaGVhZGVyRW50cmllcyAmJiBzaXplKGhlYWRlckVudHJpZXMpID4gMDtcblxuICByZXR1cm4gIWhhc0VudHJpZXMgJiYgIWhhc0hlYWRlckVudHJpZXM7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGVudHJpZXMgYW5kIG9wZW4gcG9wdXAgbWVudSBhdCBnaXZlbiBwb3NpdGlvblxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gZWxlbWVudFxuICogQHBhcmFtICB7c3RyaW5nfSBpZCBwcm92aWRlciBpZFxuICogQHBhcmFtICB7T2JqZWN0fSBwb3NpdGlvblxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gcG9wdXAgbWVudSBpbnN0YW5jZVxuICovXG5Qb3B1cE1lbnUucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihlbGVtZW50LCBpZCwgcG9zaXRpb24pIHtcblxuICB2YXIgcHJvdmlkZXJzID0gdGhpcy5fZ2V0UHJvdmlkZXJzKGlkKTtcblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgaXMgbWlzc2luZycpO1xuICB9XG5cbiAgaWYgKCFwcm92aWRlcnMgfHwgIXByb3ZpZGVycy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlZ2lzdGVyZWQgcHJvdmlkZXJzIGZvcjogJyArIGlkKTtcbiAgfVxuXG4gIGlmICghcG9zaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBwb3NpdGlvbiBhcmd1bWVudCBpcyBtaXNzaW5nJyk7XG4gIH1cblxuICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIHRoaXMuX2VtaXQoJ29wZW4nKTtcblxuICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgPSB7XG4gICAgY2xhc3NOYW1lOiBpZCxcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9O1xuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5fZ2V0RW50cmllcyhlbGVtZW50LCBwcm92aWRlcnMpLFxuICAgICAgaGVhZGVyRW50cmllcyA9IHRoaXMuX2dldEhlYWRlckVudHJpZXMoZWxlbWVudCwgcHJvdmlkZXJzKTtcblxuICBjdXJyZW50LmVudHJpZXMgPSBhc3NpZ24oe30sIGVudHJpZXMsIGhlYWRlckVudHJpZXMpO1xuXG4gIGN1cnJlbnQuY29udGFpbmVyID0gdGhpcy5fY3JlYXRlQ29udGFpbmVyKCk7XG5cbiAgaWYgKHNpemUoaGVhZGVyRW50cmllcykpIHtcbiAgICBjdXJyZW50LmNvbnRhaW5lci5hcHBlbmRDaGlsZChcbiAgICAgIHRoaXMuX2NyZWF0ZUVudHJpZXMoaGVhZGVyRW50cmllcywgJ2Rqcy1wb3B1cC1oZWFkZXInKVxuICAgICk7XG4gIH1cblxuICBpZiAoc2l6ZShlbnRyaWVzKSkge1xuICAgIGN1cnJlbnQuY29udGFpbmVyLmFwcGVuZENoaWxkKFxuICAgICAgdGhpcy5fY3JlYXRlRW50cmllcyhlbnRyaWVzLCAnZGpzLXBvcHVwLWJvZHknKVxuICAgICk7XG4gIH1cblxuICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzLFxuICAgICAgcGFyZW50ID0gY2FudmFzLmdldENvbnRhaW5lcigpO1xuXG4gIHRoaXMuX2F0dGFjaENvbnRhaW5lcihjdXJyZW50LmNvbnRhaW5lciwgcGFyZW50LCBwb3NpdGlvbi5jdXJzb3IpO1xuICB0aGlzLl9iaW5kQXV0b0Nsb3NlKCk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgcG9wdXAgbWVudSBhbmQgdW5iaW5kcyB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gKi9cblBvcHVwTWVudS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcblxuICBpZiAoIXRoaXMuaXNPcGVuKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9lbWl0KCdjbG9zZScpO1xuXG4gIHRoaXMuX3VuYmluZEF1dG9DbG9zZSgpO1xuICBkb21SZW1vdmUodGhpcy5fY3VycmVudC5jb250YWluZXIpO1xuICB0aGlzLl9jdXJyZW50LmNvbnRhaW5lciA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIG9wZW4gcG9wdXAgbWVudSBleGlzdC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG9wZW5cbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhdGhpcy5fY3VycmVudC5jb250YWluZXI7XG59O1xuXG5cbi8qKlxuICogVHJpZ2dlciBhbiBhY3Rpb24gYXNzb2NpYXRlZCB3aXRoIGFuIGVudHJ5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgYWN0aW9uIGNhbGxiYWNrLCBpZiBhbnlcbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAvLyBzaWxlbmNlIG90aGVyIGFjdGlvbnNcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICB2YXIgZWxlbWVudCA9IGV2ZW50LmRlbGVnYXRlVGFyZ2V0IHx8IGV2ZW50LnRhcmdldCxcbiAgICAgIGVudHJ5SWQgPSBkb21BdHRyKGVsZW1lbnQsIERBVEFfUkVGKTtcblxuICB2YXIgZW50cnkgPSB0aGlzLl9nZXRFbnRyeShlbnRyeUlkKTtcblxuICBpZiAoZW50cnkuYWN0aW9uKSB7XG4gICAgcmV0dXJuIGVudHJ5LmFjdGlvbi5jYWxsKG51bGwsIGV2ZW50LCBlbnRyeSk7XG4gIH1cbn07XG5cblBvcHVwTWVudS5wcm90b3R5cGUuX2dldFByb3ZpZGVycyA9IGZ1bmN0aW9uKGlkKSB7XG5cbiAgdmFyIGV2ZW50ID0gdGhpcy5fZXZlbnRCdXMuY3JlYXRlRXZlbnQoe1xuICAgIHR5cGU6ICdwb3B1cE1lbnUuZ2V0UHJvdmlkZXJzLicgKyBpZCxcbiAgICBwcm92aWRlcnM6IFtdXG4gIH0pO1xuXG4gIHRoaXMuX2V2ZW50QnVzLmZpcmUoZXZlbnQpO1xuXG4gIHJldHVybiBldmVudC5wcm92aWRlcnM7XG59O1xuXG5Qb3B1cE1lbnUucHJvdG90eXBlLl9nZXRFbnRyaWVzID0gZnVuY3Rpb24oZWxlbWVudCwgcHJvdmlkZXJzKSB7XG5cbiAgdmFyIGVudHJpZXMgPSB7fTtcblxuICBmb3JFYWNoKHByb3ZpZGVycywgZnVuY3Rpb24ocHJvdmlkZXIpIHtcblxuICAgIC8vIGhhbmRsZSBsZWdhY3kgbWV0aG9kXG4gICAgaWYgKCFwcm92aWRlci5nZXRQb3B1cE1lbnVFbnRyaWVzKSB7XG4gICAgICBmb3JFYWNoKHByb3ZpZGVyLmdldEVudHJpZXMoZWxlbWVudCksIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHZhciBpZCA9IGVudHJ5LmlkO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V2ZXJ5IGVudHJ5IG11c3QgaGF2ZSB0aGUgaWQgcHJvcGVydHkgc2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBlbnRyaWVzW2lkXSA9IG9taXQoZW50cnksIFsgJ2lkJyBdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVudHJpZXNPclVwZGF0ZXIgPSBwcm92aWRlci5nZXRQb3B1cE1lbnVFbnRyaWVzKGVsZW1lbnQpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZW50cmllc09yVXBkYXRlcikpIHtcbiAgICAgIGVudHJpZXMgPSBlbnRyaWVzT3JVcGRhdGVyKGVudHJpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoKGVudHJpZXNPclVwZGF0ZXIsIGZ1bmN0aW9uKGVudHJ5LCBpZCkge1xuICAgICAgICBlbnRyaWVzW2lkXSA9IGVudHJ5O1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZW50cmllcztcbn07XG5cblBvcHVwTWVudS5wcm90b3R5cGUuX2dldEhlYWRlckVudHJpZXMgPSBmdW5jdGlvbihlbGVtZW50LCBwcm92aWRlcnMpIHtcblxuICB2YXIgZW50cmllcyA9IHt9O1xuXG4gIGZvckVhY2gocHJvdmlkZXJzLCBmdW5jdGlvbihwcm92aWRlcikge1xuXG4gICAgLy8gaGFuZGxlIGxlZ2FjeSBtZXRob2RcbiAgICBpZiAoIXByb3ZpZGVyLmdldFBvcHVwTWVudUhlYWRlckVudHJpZXMpIHtcbiAgICAgIGlmICghcHJvdmlkZXIuZ2V0SGVhZGVyRW50cmllcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvckVhY2gocHJvdmlkZXIuZ2V0SGVhZGVyRW50cmllcyhlbGVtZW50KSwgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgdmFyIGlkID0gZW50cnkuaWQ7XG5cbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXZlcnkgZW50cnkgbXVzdCBoYXZlIHRoZSBpZCBwcm9wZXJ0eSBzZXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVudHJpZXNbaWRdID0gb21pdChlbnRyeSwgWyAnaWQnIF0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZW50cmllc09yVXBkYXRlciA9IHByb3ZpZGVyLmdldFBvcHVwTWVudUhlYWRlckVudHJpZXMoZWxlbWVudCk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihlbnRyaWVzT3JVcGRhdGVyKSkge1xuICAgICAgZW50cmllcyA9IGVudHJpZXNPclVwZGF0ZXIoZW50cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2goZW50cmllc09yVXBkYXRlciwgZnVuY3Rpb24oZW50cnksIGlkKSB7XG4gICAgICAgIGVudHJpZXNbaWRdID0gZW50cnk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlbnRyaWVzO1xuXG5cbn07XG5cbi8qKlxuICogR2V0cyBhbiBlbnRyeSBpbnN0YW5jZSAoZWl0aGVyIGVudHJ5IG9yIGhlYWRlckVudHJ5KSBieSBpZC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGVudHJ5SWRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGVudHJ5IGluc3RhbmNlXG4gKi9cblBvcHVwTWVudS5wcm90b3R5cGUuX2dldEVudHJ5ID0gZnVuY3Rpb24oZW50cnlJZCkge1xuXG4gIHZhciBlbnRyeSA9IHRoaXMuX2N1cnJlbnQuZW50cmllc1tlbnRyeUlkXTtcblxuICBpZiAoIWVudHJ5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbnRyeSBub3QgZm91bmQnKTtcbiAgfVxuXG4gIHJldHVybiBlbnRyeTtcbn07XG5cblBvcHVwTWVudS5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgdGhpcy5fZXZlbnRCdXMuZmlyZSgncG9wdXBNZW51LicgKyBldmVudE5hbWUpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBwb3B1cCBtZW51IGNvbnRhaW5lci5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgRE9NIGNvbnRhaW5lclxuICovXG5Qb3B1cE1lbnUucHJvdG90eXBlLl9jcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnRhaW5lciA9IGRvbWlmeSgnPGRpdiBjbGFzcz1cImRqcy1wb3B1cFwiPicpLFxuICAgICAgcG9zaXRpb24gPSB0aGlzLl9jdXJyZW50LnBvc2l0aW9uLFxuICAgICAgY2xhc3NOYW1lID0gdGhpcy5fY3VycmVudC5jbGFzc05hbWU7XG5cbiAgYXNzaWduKGNvbnRhaW5lci5zdHlsZSwge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGxlZnQ6IHBvc2l0aW9uLnggKyAncHgnLFxuICAgIHRvcDogcG9zaXRpb24ueSArICdweCcsXG4gICAgdmlzaWJpbGl0eTogJ2hpZGRlbidcbiAgfSk7XG5cbiAgZG9tQ2xhc3Nlcyhjb250YWluZXIpLmFkZChjbGFzc05hbWUpO1xuXG4gIHJldHVybiBjb250YWluZXI7XG59O1xuXG5cbi8qKlxuICogQXR0YWNoZXMgdGhlIGNvbnRhaW5lciB0byB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS5fYXR0YWNoQ29udGFpbmVyID0gZnVuY3Rpb24oY29udGFpbmVyLCBwYXJlbnQsIGN1cnNvcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gRXZlbnQgaGFuZGxlclxuICBkb21EZWxlZ2F0ZS5iaW5kKGNvbnRhaW5lciwgJy5lbnRyeScgLCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgc2VsZi50cmlnZ2VyKGV2ZW50KTtcbiAgfSk7XG5cbiAgdGhpcy5fdXBkYXRlU2NhbGUoY29udGFpbmVyKTtcblxuICAvLyBBdHRhY2ggdG8gRE9NXG4gIHBhcmVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gIGlmIChjdXJzb3IpIHtcbiAgICB0aGlzLl9hc3N1cmVJc0luYm91bmRzKGNvbnRhaW5lciwgY3Vyc29yKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgcG9wdXAgc3R5bGUudHJhbnNmb3JtIHdpdGggcmVzcGVjdCB0byB0aGUgY29uZmlnIGFuZCB6b29tIGxldmVsLlxuICpcbiAqIEBtZXRob2QgX3VwZGF0ZVNjYWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lclxuICovXG5Qb3B1cE1lbnUucHJvdG90eXBlLl91cGRhdGVTY2FsZSA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICB2YXIgem9vbSA9IHRoaXMuX2NhbnZhcy56b29tKCk7XG5cbiAgdmFyIHNjYWxlQ29uZmlnID0gdGhpcy5fY29uZmlnLnNjYWxlLFxuICAgICAgbWluU2NhbGUsXG4gICAgICBtYXhTY2FsZSxcbiAgICAgIHNjYWxlID0gem9vbTtcblxuICBpZiAoc2NhbGVDb25maWcgIT09IHRydWUpIHtcblxuICAgIGlmIChzY2FsZUNvbmZpZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1pblNjYWxlID0gMTtcbiAgICAgIG1heFNjYWxlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluU2NhbGUgPSBzY2FsZUNvbmZpZy5taW47XG4gICAgICBtYXhTY2FsZSA9IHNjYWxlQ29uZmlnLm1heDtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKG1pblNjYWxlKSAmJiB6b29tIDwgbWluU2NhbGUpIHtcbiAgICAgIHNjYWxlID0gbWluU2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmaW5lZChtYXhTY2FsZSkgJiYgem9vbSA+IG1heFNjYWxlKSB7XG4gICAgICBzY2FsZSA9IG1heFNjYWxlO1xuICAgIH1cblxuICB9XG5cbiAgc2V0VHJhbnNmb3JtKGNvbnRhaW5lciwgJ3NjYWxlKCcgKyBzY2FsZSArICcpJyk7XG59O1xuXG5cbi8qKlxuICogTWFrZSBzdXJlIHRoYXQgdGhlIG1lbnUgaXMgYWx3YXlzIGZ1bGx5IHNob3duXG4gKlxuICogQG1ldGhvZCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gY29udGFpbmVyXG4gKiBAcGFyYW0gIHtQb3NpdGlvbn0gY3Vyc29yIHt4LCB5fVxuICovXG5Qb3B1cE1lbnUucHJvdG90eXBlLl9hc3N1cmVJc0luYm91bmRzID0gZnVuY3Rpb24oY29udGFpbmVyLCBjdXJzb3IpIHtcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcyxcbiAgICAgIGNsaWVudFJlY3QgPSBjYW52YXMuX2NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICB2YXIgY29udGFpbmVyWCA9IGNvbnRhaW5lci5vZmZzZXRMZWZ0LFxuICAgICAgY29udGFpbmVyWSA9IGNvbnRhaW5lci5vZmZzZXRUb3AsXG4gICAgICBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lci5zY3JvbGxXaWR0aCxcbiAgICAgIGNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lci5zY3JvbGxIZWlnaHQsXG4gICAgICBvdmVyQXhpcyA9IHt9LFxuICAgICAgbGVmdCwgdG9wO1xuXG4gIHZhciBjdXJzb3JQb3NpdGlvbiA9IHtcbiAgICB4OiBjdXJzb3IueCAtIGNsaWVudFJlY3QubGVmdCxcbiAgICB5OiBjdXJzb3IueSAtIGNsaWVudFJlY3QudG9wXG4gIH07XG5cbiAgaWYgKGNvbnRhaW5lclggKyBjb250YWluZXJXaWR0aCA+IGNsaWVudFJlY3Qud2lkdGgpIHtcbiAgICBvdmVyQXhpcy54ID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChjb250YWluZXJZICsgY29udGFpbmVySGVpZ2h0ID4gY2xpZW50UmVjdC5oZWlnaHQpIHtcbiAgICBvdmVyQXhpcy55ID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvdmVyQXhpcy54ICYmIG92ZXJBeGlzLnkpIHtcbiAgICBsZWZ0ID0gY3Vyc29yUG9zaXRpb24ueCAtIGNvbnRhaW5lcldpZHRoICsgJ3B4JztcbiAgICB0b3AgPSBjdXJzb3JQb3NpdGlvbi55IC0gY29udGFpbmVySGVpZ2h0ICsgJ3B4JztcbiAgfSBlbHNlIGlmIChvdmVyQXhpcy54KSB7XG4gICAgbGVmdCA9IGN1cnNvclBvc2l0aW9uLnggLSBjb250YWluZXJXaWR0aCArICdweCc7XG4gICAgdG9wID0gY3Vyc29yUG9zaXRpb24ueSArICdweCc7XG4gIH0gZWxzZSBpZiAob3ZlckF4aXMueSAmJiBjdXJzb3JQb3NpdGlvbi55IDwgY29udGFpbmVySGVpZ2h0KSB7XG4gICAgbGVmdCA9IGN1cnNvclBvc2l0aW9uLnggKyAncHgnO1xuICAgIHRvcCA9IDEwICsgJ3B4JztcbiAgfSBlbHNlIGlmIChvdmVyQXhpcy55KSB7XG4gICAgbGVmdCA9IGN1cnNvclBvc2l0aW9uLnggKyAncHgnO1xuICAgIHRvcCA9IGN1cnNvclBvc2l0aW9uLnkgLSBjb250YWluZXJIZWlnaHQgKyAncHgnO1xuICB9XG5cbiAgYXNzaWduKGNvbnRhaW5lci5zdHlsZSwgeyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9LCB7IHZpc2liaWxpdHk6ICd2aXNpYmxlJywgJ3otaW5kZXgnOiAxMDAwIH0pO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBsaXN0IG9mIGVudHJpZXMgYW5kIHJldHVybnMgdGhlbSBhcyBhIERPTSBjb250YWluZXIuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBlbnRyaWVzIGFuIGFycmF5IG9mIGVudHJ5IG9iamVjdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIGNsYXNzIG5hbWUgb2YgdGhlIGVudHJ5IGNvbnRhaW5lclxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gYSBET00gY29udGFpbmVyXG4gKi9cblBvcHVwTWVudS5wcm90b3R5cGUuX2NyZWF0ZUVudHJpZXMgPSBmdW5jdGlvbihlbnRyaWVzLCBjbGFzc05hbWUpIHtcblxuICB2YXIgZW50cmllc0NvbnRhaW5lciA9IGRvbWlmeSgnPGRpdj4nKSxcbiAgICAgIHNlbGYgPSB0aGlzO1xuXG4gIGRvbUNsYXNzZXMoZW50cmllc0NvbnRhaW5lcikuYWRkKGNsYXNzTmFtZSk7XG5cbiAgZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSwgaWQpIHtcbiAgICB2YXIgZW50cnlDb250YWluZXIgPSBzZWxmLl9jcmVhdGVFbnRyeShlbnRyeSwgaWQpO1xuICAgIGVudHJpZXNDb250YWluZXIuYXBwZW5kQ2hpbGQoZW50cnlDb250YWluZXIpO1xuICB9KTtcblxuICByZXR1cm4gZW50cmllc0NvbnRhaW5lcjtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2luZ2xlIGVudHJ5IGFuZCByZXR1cm5zIGl0IGFzIGEgRE9NIGNvbnRhaW5lci5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGVudHJ5XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBhIERPTSBjb250YWluZXJcbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS5fY3JlYXRlRW50cnkgPSBmdW5jdGlvbihlbnRyeSwgaWQpIHtcblxuICB2YXIgZW50cnlDb250YWluZXIgPSBkb21pZnkoJzxkaXY+JyksXG4gICAgICBlbnRyeUNsYXNzZXMgPSBkb21DbGFzc2VzKGVudHJ5Q29udGFpbmVyKTtcblxuICBlbnRyeUNsYXNzZXMuYWRkKCdlbnRyeScpO1xuXG4gIGlmIChlbnRyeS5jbGFzc05hbWUpIHtcbiAgICBlbnRyeS5jbGFzc05hbWUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgZW50cnlDbGFzc2VzLmFkZChjbGFzc05hbWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZG9tQXR0cihlbnRyeUNvbnRhaW5lciwgREFUQV9SRUYsIGlkKTtcblxuICBpZiAoZW50cnkubGFiZWwpIHtcbiAgICB2YXIgbGFiZWwgPSBkb21pZnkoJzxzcGFuPicpO1xuICAgIGxhYmVsLnRleHRDb250ZW50ID0gZW50cnkubGFiZWw7XG4gICAgZW50cnlDb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICB9XG5cbiAgaWYgKGVudHJ5LmltYWdlVXJsKSB7XG4gICAgZW50cnlDb250YWluZXIuYXBwZW5kQ2hpbGQoZG9taWZ5KCc8aW1nIHNyYz1cIicgKyBlbnRyeS5pbWFnZVVybCArICdcIiAvPicpKTtcbiAgfVxuXG4gIGlmIChlbnRyeS5hY3RpdmUgPT09IHRydWUpIHtcbiAgICBlbnRyeUNsYXNzZXMuYWRkKCdhY3RpdmUnKTtcbiAgfVxuXG4gIGlmIChlbnRyeS5kaXNhYmxlZCA9PT0gdHJ1ZSkge1xuICAgIGVudHJ5Q2xhc3Nlcy5hZGQoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBpZiAoZW50cnkudGl0bGUpIHtcbiAgICBlbnRyeUNvbnRhaW5lci50aXRsZSA9IGVudHJ5LnRpdGxlO1xuICB9XG5cbiAgcmV0dXJuIGVudHJ5Q29udGFpbmVyO1xufTtcblxuXG4vKipcbiAqIFNldCB1cCBsaXN0ZW5lciB0byBjbG9zZSBwb3B1cCBhdXRvbWF0aWNhbGx5IG9uIGNlcnRhaW4gZXZlbnRzLlxuICovXG5Qb3B1cE1lbnUucHJvdG90eXBlLl9iaW5kQXV0b0Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2V2ZW50QnVzLm9uY2UoQ0xPU0VfRVZFTlRTLCB0aGlzLmNsb3NlLCB0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGF1dG8tY2xvc2luZyBsaXN0ZW5lci5cbiAqL1xuUG9wdXBNZW51LnByb3RvdHlwZS5fdW5iaW5kQXV0b0Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2V2ZW50QnVzLm9mZihDTE9TRV9FVkVOVFMsIHRoaXMuY2xvc2UsIHRoaXMpO1xufTtcblxuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsZW1lbnQsIHRyYW5zZm9ybSkge1xuICBlbGVtZW50LnN0eWxlWyd0cmFuc2Zvcm0tb3JpZ2luJ10gPSAndG9wIGxlZnQnO1xuXG4gIFsgJycsICctbXMtJywgJy13ZWJraXQtJyBdLmZvckVhY2goZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgZWxlbWVudC5zdHlsZVtwcmVmaXggKyAndHJhbnNmb3JtJ10gPSB0cmFuc2Zvcm07XG4gIH0pO1xufSIsImltcG9ydCBQb3B1cE1lbnUgZnJvbSAnLi9Qb3B1cE1lbnUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdwb3B1cE1lbnUnIF0sXG4gIHBvcHVwTWVudTogWyAndHlwZScsIFBvcHVwTWVudSBdXG59O1xuIiwiaW1wb3J0IHtcclxuICBmb3JFYWNoXHJcbn0gZnJvbSAnbWluLWRhc2gnO1xyXG5cclxuaW1wb3J0IHtcclxuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxyXG4gIGF0dHIgYXMgc3ZnQXR0cixcclxuICBjbGFzc2VzIGFzIHN2Z0NsYXNzZXMsXHJcbiAgY2xvbmUgYXMgc3ZnQ2xvbmUsXHJcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZSxcclxuICByZW1vdmUgYXMgc3ZnUmVtb3ZlXHJcbn0gZnJvbSAndGlueS1zdmcnO1xyXG5cclxuaW1wb3J0IHsgcXVlcnkgYXMgZG9tUXVlcnkgfSBmcm9tICdtaW4tZG9tJztcclxuXHJcbmltcG9ydCB7IGdldFZpc3VhbCB9IGZyb20gJy4uLy4uL3V0aWwvR3JhcGhpY3NVdGlsJztcclxuXHJcbnZhciBNQVJLRVJfVFlQRVMgPSBbXHJcbiAgJ21hcmtlci1zdGFydCcsXHJcbiAgJ21hcmtlci1taWQnLFxyXG4gICdtYXJrZXItZW5kJ1xyXG5dO1xyXG5cclxudmFyIE5PREVTX0NBTl9IQVZFX01BUktFUiA9IFtcclxuICAnY2lyY2xlJyxcclxuICAnZWxsaXBzZScsXHJcbiAgJ2xpbmUnLFxyXG4gICdwYXRoJyxcclxuICAncG9seWdvbicsXHJcbiAgJ3BvbHlsaW5lJyxcclxuICAncmVjdCdcclxuXTtcclxuXHJcblxyXG4vKipcclxuICogQWRkcyBzdXBwb3J0IGZvciBwcmV2aWV3cyBvZiBtb3ZpbmcvcmVzaXppbmcgZWxlbWVudHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQcmV2aWV3U3VwcG9ydChlbGVtZW50UmVnaXN0cnksIGV2ZW50QnVzLCBjYW52YXMsIHN0eWxlcykge1xyXG4gIHRoaXMuX2VsZW1lbnRSZWdpc3RyeSA9IGVsZW1lbnRSZWdpc3RyeTtcclxuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XHJcbiAgdGhpcy5fc3R5bGVzID0gc3R5bGVzO1xyXG5cclxuICB0aGlzLl9jbG9uZWRNYXJrZXJzID0ge307XHJcblxyXG4gIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgZXZlbnRCdXMub24oJ2RyYWcuY2xlYW51cCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgZm9yRWFjaChzZWxmLl9jbG9uZWRNYXJrZXJzLCBmdW5jdGlvbihjbG9uZWRNYXJrZXIpIHtcclxuICAgICAgc3ZnUmVtb3ZlKGNsb25lZE1hcmtlcik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBzZWxmLl9jbG9uZWRNYXJrZXJzID0ge307XHJcbiAgfSk7XHJcbn1cclxuXHJcblByZXZpZXdTdXBwb3J0LiRpbmplY3QgPSBbXHJcbiAgJ2VsZW1lbnRSZWdpc3RyeScsXHJcbiAgJ2V2ZW50QnVzJyxcclxuICAnY2FudmFzJyxcclxuICAnc3R5bGVzJ1xyXG5dO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGdyYXBoaWNzIG9mIGFuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcclxuICpcclxuICogQHJldHVybiB7U1ZHRWxlbWVudH1cclxuICovXHJcblByZXZpZXdTdXBwb3J0LnByb3RvdHlwZS5nZXRHZnggPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhlbGVtZW50KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgbW92ZSBwcmV2aWV3IG9mIGEgZ2l2ZW4gc2hhcGUgdG8gYSBnaXZlbiBzdmcgZ3JvdXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcclxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBncm91cFxyXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IFtnZnhdXHJcbiAqXHJcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IGRyYWdnZXJcclxuICovXHJcblByZXZpZXdTdXBwb3J0LnByb3RvdHlwZS5hZGREcmFnZ2VyID0gZnVuY3Rpb24oZWxlbWVudCwgZ3JvdXAsIGdmeCkge1xyXG4gIGdmeCA9IGdmeCB8fCB0aGlzLmdldEdmeChlbGVtZW50KTtcclxuXHJcbiAgdmFyIGRyYWdnZXIgPSBzdmdDbG9uZShnZngpO1xyXG4gIHZhciBiYm94ID0gZ2Z4LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICB0aGlzLl9jbG9uZU1hcmtlcnMoZ2V0VmlzdWFsKGRyYWdnZXIpKTtcclxuXHJcbiAgc3ZnQXR0cihkcmFnZ2VyLCB0aGlzLl9zdHlsZXMuY2xzKCdkanMtZHJhZ2dlcicsIFtdLCB7XHJcbiAgICB4OiBiYm94LnRvcCxcclxuICAgIHk6IGJib3gubGVmdFxyXG4gIH0pKTtcclxuXHJcbiAgc3ZnQXBwZW5kKGdyb3VwLCBkcmFnZ2VyKTtcclxuXHJcbiAgcmV0dXJuIGRyYWdnZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhIHJlc2l6ZSBwcmV2aWV3IG9mIGEgZ2l2ZW4gc2hhcGUgdG8gYSBnaXZlbiBzdmcgZ3JvdXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcclxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBncm91cFxyXG4gKlxyXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fSBmcmFtZVxyXG4gKi9cclxuUHJldmlld1N1cHBvcnQucHJvdG90eXBlLmFkZEZyYW1lID0gZnVuY3Rpb24oc2hhcGUsIGdyb3VwKSB7XHJcblxyXG4gIHZhciBmcmFtZSA9IHN2Z0NyZWF0ZSgncmVjdCcsIHtcclxuICAgIGNsYXNzOiAnZGpzLXJlc2l6ZS1vdmVybGF5JyxcclxuICAgIHdpZHRoOiAgc2hhcGUud2lkdGgsXHJcbiAgICBoZWlnaHQ6IHNoYXBlLmhlaWdodCxcclxuICAgIHg6IHNoYXBlLngsXHJcbiAgICB5OiBzaGFwZS55XHJcbiAgfSk7XHJcblxyXG4gIHN2Z0FwcGVuZChncm91cCwgZnJhbWUpO1xyXG5cclxuICByZXR1cm4gZnJhbWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xvbmUgYWxsIG1hcmtlcnMgcmVmZXJlbmNlZCBieSBhIG5vZGUgYW5kIGl0cyBjaGlsZCBub2Rlcy5cclxuICpcclxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBnZnhcclxuICovXHJcblByZXZpZXdTdXBwb3J0LnByb3RvdHlwZS5fY2xvbmVNYXJrZXJzID0gZnVuY3Rpb24oZ2Z4KSB7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICBpZiAoZ2Z4LmNoaWxkTm9kZXMpIHtcclxuXHJcbiAgICAvLyBUT0RPOiB1c2UgZm9yRWFjaCBvbmNlIHdlIGRyb3AgUGhhbnRvbUpTXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdmeC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAvLyByZWN1cnNpdmVseSBjbG9uZSBtYXJrZXJzIG9mIGNoaWxkIG5vZGVzXHJcbiAgICAgIHNlbGYuX2Nsb25lTWFya2VycyhnZnguY2hpbGROb2Rlc1sgaSBdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghY2FuSGF2ZU1hcmtlcihnZngpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBNQVJLRVJfVFlQRVMuZm9yRWFjaChmdW5jdGlvbihtYXJrZXJUeXBlKSB7XHJcbiAgICBpZiAoc3ZnQXR0cihnZngsIG1hcmtlclR5cGUpKSB7XHJcbiAgICAgIHZhciBtYXJrZXIgPSBnZXRNYXJrZXIoZ2Z4LCBtYXJrZXJUeXBlLCBzZWxmLl9jYW52YXMuZ2V0Q29udGFpbmVyKCkpO1xyXG5cclxuICAgICAgc2VsZi5fY2xvbmVNYXJrZXIoZ2Z4LCBtYXJrZXIsIG1hcmtlclR5cGUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsb25lIG1hcmtlciByZWZlcmVuY2VkIGJ5IGFuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ2Z4XHJcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gbWFya2VyXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZXJUeXBlXHJcbiAqL1xyXG5QcmV2aWV3U3VwcG9ydC5wcm90b3R5cGUuX2Nsb25lTWFya2VyID0gZnVuY3Rpb24oZ2Z4LCBtYXJrZXIsIG1hcmtlclR5cGUpIHtcclxuICB2YXIgbWFya2VySWQgPSBtYXJrZXIuaWQ7XHJcblxyXG4gIHZhciBjbG9uZWRNYXJrZXIgPSB0aGlzLl9jbG9uZWRNYXJrZXJzWyBtYXJrZXJJZCBdO1xyXG5cclxuICBpZiAoIWNsb25lZE1hcmtlcikge1xyXG4gICAgY2xvbmVkTWFya2VyID0gc3ZnQ2xvbmUobWFya2VyKTtcclxuXHJcbiAgICB2YXIgY2xvbmVkTWFya2VySWQgPSBtYXJrZXJJZCArICctY2xvbmUnO1xyXG5cclxuICAgIGNsb25lZE1hcmtlci5pZCA9IGNsb25lZE1hcmtlcklkO1xyXG5cclxuICAgIHN2Z0NsYXNzZXMoY2xvbmVkTWFya2VyKVxyXG4gICAgICAuYWRkKCdkanMtZHJhZ2dlcicpXHJcbiAgICAgIC5hZGQoJ2Rqcy1kcmFnZ2VyLW1hcmtlcicpO1xyXG5cclxuICAgIHRoaXMuX2Nsb25lZE1hcmtlcnNbIG1hcmtlcklkIF0gPSBjbG9uZWRNYXJrZXI7XHJcblxyXG4gICAgdmFyIGRlZnMgPSBkb21RdWVyeSgnZGVmcycsIHRoaXMuX2NhbnZhcy5fc3ZnKTtcclxuXHJcbiAgICBpZiAoIWRlZnMpIHtcclxuICAgICAgZGVmcyA9IHN2Z0NyZWF0ZSgnZGVmcycpO1xyXG5cclxuICAgICAgc3ZnQXBwZW5kKHRoaXMuX2NhbnZhcy5fc3ZnLCBkZWZzKTtcclxuICAgIH1cclxuXHJcbiAgICBzdmdBcHBlbmQoZGVmcywgY2xvbmVkTWFya2VyKTtcclxuICB9XHJcblxyXG4gIHZhciByZWZlcmVuY2UgPSBpZFRvUmVmZXJlbmNlKHRoaXMuX2Nsb25lZE1hcmtlcnNbIG1hcmtlcklkIF0uaWQpO1xyXG5cclxuICBzdmdBdHRyKGdmeCwgbWFya2VyVHlwZSwgcmVmZXJlbmNlKTtcclxufTtcclxuXHJcbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIEdldCBtYXJrZXIgb2YgZ2l2ZW4gdHlwZSByZWZlcmVuY2VkIGJ5IG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya2VyVHlwZVxyXG4gKiBAcGFyYW0ge05vZGV9IFtwYXJlbnROb2RlXVxyXG4gKlxyXG4gKiBAcGFyYW0ge05vZGV9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNYXJrZXIobm9kZSwgbWFya2VyVHlwZSwgcGFyZW50Tm9kZSkge1xyXG4gIHZhciBpZCA9IHJlZmVyZW5jZVRvSWQoc3ZnQXR0cihub2RlLCBtYXJrZXJUeXBlKSk7XHJcblxyXG4gIHJldHVybiBkb21RdWVyeSgnbWFya2VyIycgKyBpZCwgcGFyZW50Tm9kZSB8fCBkb2N1bWVudCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgSUQgb2YgZnJhZ21lbnQgd2l0aGluIGN1cnJlbnQgZG9jdW1lbnQgZnJvbSBpdHMgZnVuY3Rpb25hbCBJUkkgcmVmZXJlbmNlLlxyXG4gKiBSZWZlcmVuY2VzIG1heSB1c2Ugc2luZ2xlIG9yIGRvdWJsZSBxdW90ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWZlcmVuY2VcclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIHJlZmVyZW5jZVRvSWQocmVmZXJlbmNlKSB7XHJcbiAgcmV0dXJuIHJlZmVyZW5jZS5tYXRjaCgvdXJsXFwoWydcIl0/IyhbXidcIl0qKVsnXCJdP1xcKS8pWzFdO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGZ1bmN0aW9uYWwgSVJJIHJlZmVyZW5jZSBmb3IgZ2l2ZW4gSUQgb2YgZnJhZ21lbnQgd2l0aGluIGN1cnJlbnQgZG9jdW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gaWRUb1JlZmVyZW5jZShpZCkge1xyXG4gIHJldHVybiAndXJsKCMnICsgaWQgKyAnKSc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayB3ZXRoZXIgbm9kZSB0eXBlIGNhbiBoYXZlIG1hcmtlciBhdHRyaWJ1dGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICpcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBjYW5IYXZlTWFya2VyKG5vZGUpIHtcclxuICByZXR1cm4gTk9ERVNfQ0FOX0hBVkVfTUFSS0VSLmluZGV4T2Yobm9kZS5ub2RlTmFtZSkgIT09IC0xO1xyXG59IiwiaW1wb3J0IFByZXZpZXdTdXBwb3J0IGZyb20gJy4vUHJldmlld1N1cHBvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbICdwcmV2aWV3U3VwcG9ydCcgXSxcbiAgcHJldmlld1N1cHBvcnQ6IFsgJ3R5cGUnLCBQcmV2aWV3U3VwcG9ydCBdXG59O1xuIiwiaW1wb3J0IHtcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuLyoqXG4gKiBTZXJ2aWNlIHRoYXQgYWxsb3cgcmVwbGFjaW5nIG9mIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZXBsYWNlKG1vZGVsaW5nKSB7XG5cbiAgdGhpcy5fbW9kZWxpbmcgPSBtb2RlbGluZztcbn1cblxuUmVwbGFjZS4kaW5qZWN0ID0gWyAnbW9kZWxpbmcnIF07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBvbGRFbGVtZW50IC0gRWxlbWVudCB0byBiZSByZXBsYWNlZFxuICogQHBhcmFtIHtPYmplY3R9ICBuZXdFbGVtZW50RGF0YSAtIENvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG5ldyBlbGVtZW50LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBleGFtcGxlIHRoZSBuZXcgYm91bmRzIGFuZCB0eXBlLlxuICogQHBhcmFtIHtPYmplY3R9ICBvcHRpb25zIC0gQ3VzdG9tIG9wdGlvbnMgdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBjb250ZXh0LiBJdCBjYW4gYmUgdXNlZCB0byBpbmplY3QgZGF0YVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBpcyBuZWVkZWQgaW4gdGhlIGNvbW1hbmQgY2hhaW4uIEZvciBleGFtcGxlIGl0IGNvdWxkIGJlIHVzZWQgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50YnVzLm9uKCdjb21tYW5kU3RhY2suc2hhcGUucmVwbGFjZS5wb3N0RXhlY3V0ZScpIHRvIGNoYW5nZSBzaGFwZSBhdHRyaWJ1dGVzIGFmdGVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZSBjcmVhdGlvbi5cbiAqL1xuUmVwbGFjZS5wcm90b3R5cGUucmVwbGFjZUVsZW1lbnQgPSBmdW5jdGlvbihvbGRFbGVtZW50LCBuZXdFbGVtZW50RGF0YSwgb3B0aW9ucykge1xuXG4gIGlmIChvbGRFbGVtZW50LndheXBvaW50cykge1xuXG4gICAgLy8gVE9ETyhuaWtrdSk6IHdlIGRvIG5vdCByZXBsYWNlIGNvbm5lY3Rpb25zLCB5ZXRcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtb2RlbGluZyA9IHRoaXMuX21vZGVsaW5nO1xuXG4gIHZhciB3aWR0aCA9IG5ld0VsZW1lbnREYXRhLndpZHRoIHx8IG9sZEVsZW1lbnQud2lkdGgsXG4gICAgICBoZWlnaHQgPSBuZXdFbGVtZW50RGF0YS5oZWlnaHQgfHwgb2xkRWxlbWVudC5oZWlnaHQsXG4gICAgICB4ID0gbmV3RWxlbWVudERhdGEueCB8fCBvbGRFbGVtZW50LngsXG4gICAgICB5ID0gbmV3RWxlbWVudERhdGEueSB8fCBvbGRFbGVtZW50LnksXG4gICAgICBjZW50ZXJYID0gcm91bmQoeCArIHdpZHRoIC8gMiksXG4gICAgICBjZW50ZXJZID0gcm91bmQoeSArIGhlaWdodCAvIDIpO1xuXG4gIC8vIG1vZGVsaW5nIEFQSSByZXF1aXJlcyBjZW50ZXIgY29vcmRpbmF0ZXMsXG4gIC8vIGFjY291bnQgZm9yIHRoYXQgd2hlbiBoYW5kbGluZyBzaGFwZSBib3VuZHNcblxuICByZXR1cm4gbW9kZWxpbmcucmVwbGFjZVNoYXBlKFxuICAgIG9sZEVsZW1lbnQsXG4gICAgYXNzaWduKFxuICAgICAge30sXG4gICAgICBuZXdFbGVtZW50RGF0YSxcbiAgICAgIHtcbiAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfVxuICAgICksXG4gICAgb3B0aW9uc1xuICApO1xufTtcbiIsImltcG9ydCBSZXBsYWNlIGZyb20gJy4vUmVwbGFjZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ3JlcGxhY2UnIF0sXG4gIHJlcGxhY2U6IFsgJ3R5cGUnLCBSZXBsYWNlIF1cbn07IiwiaW1wb3J0IHtcbiAgcGljayxcbiAgYXNzaWduXG59IGZyb20gJ21pbi1kYXNoJztcblxuaW1wb3J0IHtcbiAgcmVzaXplQm91bmRzLFxuICBlbnN1cmVDb25zdHJhaW50cyxcbiAgY29tcHV0ZUNoaWxkcmVuQkJveCxcbiAgZ2V0TWluUmVzaXplQm91bmRzXG59IGZyb20gJy4vUmVzaXplVXRpbCc7XG5cbmltcG9ydCB7XG4gIGFzVFJCTCxcbiAgZ2V0TWlkLFxuICByb3VuZEJvdW5kc1xufSBmcm9tICcuLi8uLi9sYXlvdXQvTGF5b3V0VXRpbCc7XG5cbnZhciBERUZBVUxUX01JTl9XSURUSCA9IDEwO1xuXG5cbi8qKlxuICogQSBjb21wb25lbnQgdGhhdCBwcm92aWRlcyByZXNpemluZyBvZiBzaGFwZXMgb24gdGhlIGNhbnZhcy5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGNvbXBvbmVudHMgYXJlIHBhcnQgb2Ygc2hhcGUgcmVzaXplOlxuICpcbiAqICAqIGFkZGluZyByZXNpemUgaGFuZGxlcyxcbiAqICAqIGNyZWF0aW5nIGEgdmlzdWFsIGR1cmluZyByZXNpemVcbiAqICAqIGNoZWNraW5nIHJlc2l6ZSBydWxlc1xuICogICogY29tbWl0dGluZyBhIGNoYW5nZSBvbmNlIGZpbmlzaGVkXG4gKlxuICpcbiAqICMjIEN1c3RvbWl6aW5nXG4gKlxuICogSXQncyBwb3NzaWJsZSB0byBjdXN0b21pemUgdGhlIHJlc2l6aW5nIGJlaGF2aW91ciBieSBpbnRlcmNlcHRpbmcgJ3Jlc2l6ZS5zdGFydCdcbiAqIGFuZCBwcm92aWRpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzIHRocm91Z2ggdGhlICdjb250ZXh0JzpcbiAqXG4gKiAgICogbWluRGltZW5zaW9ucyAoeyB3aWR0aCwgaGVpZ2h0IH0pOiBtaW5pbXVtIHNoYXBlIGRpbWVuc2lvbnNcbiAqXG4gKiAgICogY2hpbGRyZW5Cb3hQYWRkaW5nICh7IGxlZnQsIHRvcCwgYm90dG9tLCByaWdodCB9IHx8IG51bWJlcik6XG4gKiAgICAgZ2FwIGJldHdlZW4gdGhlIG1pbmltdW0gYm91bmRpbmcgYm94IGFuZCB0aGUgY29udGFpbmVyXG4gKlxuICogZi5leDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBldmVudEJ1cy5vbigncmVzaXplLnN0YXJ0JywgMTUwMCwgZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICpcbiAqICBjb250ZXh0Lm1pbkRpbWVuc2lvbnMgPSB7IHdpZHRoOiAxNDAsIGhlaWdodDogMTIwIH07XG4gKlxuICogIC8vIFBhc3NpbmcgZ2VuZXJhbCBwYWRkaW5nXG4gKiAgY29udGV4dC5jaGlsZHJlbkJveFBhZGRpbmcgPSAzMDtcbiAqXG4gKiAgLy8gUGFzc2luZyBwYWRkaW5nIHRvIGEgc3BlY2lmaWMgc2lkZVxuICogIGNvbnRleHQuY2hpbGRyZW5Cb3hQYWRkaW5nLmxlZnQgPSAyMDtcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJlc2l6ZShldmVudEJ1cywgcnVsZXMsIG1vZGVsaW5nLCBkcmFnZ2luZykge1xuXG4gIHRoaXMuX2RyYWdnaW5nID0gZHJhZ2dpbmc7XG4gIHRoaXMuX3J1bGVzID0gcnVsZXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cbiAgLyoqXG4gICAqIEhhbmRsZSByZXNpemUgbW92ZSBieSBzcGVjaWZpZWQgZGVsdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7UG9pbnR9IGRlbHRhXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVNb3ZlKGNvbnRleHQsIGRlbHRhKSB7XG5cbiAgICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBkaXJlY3Rpb24gPSBjb250ZXh0LmRpcmVjdGlvbixcbiAgICAgICAgcmVzaXplQ29uc3RyYWludHMgPSBjb250ZXh0LnJlc2l6ZUNvbnN0cmFpbnRzLFxuICAgICAgICBuZXdCb3VuZHM7XG5cbiAgICBjb250ZXh0LmRlbHRhID0gZGVsdGE7XG5cbiAgICBuZXdCb3VuZHMgPSByZXNpemVCb3VuZHMoc2hhcGUsIGRpcmVjdGlvbiwgZGVsdGEpO1xuXG4gICAgLy8gZW5zdXJlIGNvbnN0cmFpbnRzIGR1cmluZyByZXNpemVcbiAgICBjb250ZXh0Lm5ld0JvdW5kcyA9IGVuc3VyZUNvbnN0cmFpbnRzKG5ld0JvdW5kcywgcmVzaXplQ29uc3RyYWludHMpO1xuXG4gICAgLy8gdXBkYXRlICsgY2FjaGUgZXhlY3V0YWJsZSBzdGF0ZVxuICAgIGNvbnRleHQuY2FuRXhlY3V0ZSA9IHNlbGYuY2FuUmVzaXplKGNvbnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSByZXNpemUgc3RhcnQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnQoY29udGV4dCkge1xuXG4gICAgdmFyIHJlc2l6ZUNvbnN0cmFpbnRzID0gY29udGV4dC5yZXNpemVDb25zdHJhaW50cyxcblxuICAgICAgICAvLyBldmFsdWF0ZSBtaW5Cb3VuZHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIG1pbkJvdW5kcyA9IGNvbnRleHQubWluQm91bmRzO1xuXG4gICAgaWYgKHJlc2l6ZUNvbnN0cmFpbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWluQm91bmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pbkJvdW5kcyA9IHNlbGYuY29tcHV0ZU1pblJlc2l6ZUJveChjb250ZXh0KTtcbiAgICB9XG5cbiAgICBjb250ZXh0LnJlc2l6ZUNvbnN0cmFpbnRzID0ge1xuICAgICAgbWluOiBhc1RSQkwobWluQm91bmRzKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHJlc2l6ZSBlbmQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlRW5kKGNvbnRleHQpIHtcbiAgICB2YXIgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxuICAgICAgICBjYW5FeGVjdXRlID0gY29udGV4dC5jYW5FeGVjdXRlLFxuICAgICAgICBuZXdCb3VuZHMgPSBjb250ZXh0Lm5ld0JvdW5kcztcblxuICAgIGlmIChjYW5FeGVjdXRlKSB7XG5cbiAgICAgIC8vIGVuc3VyZSB3ZSBoYXZlIGFjdHVhbCBwaXhlbCB2YWx1ZXMgZm9yIG5ldyBib3VuZHNcbiAgICAgIC8vIChpbXBvcnRhbnQgd2hlbiB6b29tIGxldmVsIHdhcyA+IDEgZHVyaW5nIG1vdmUpXG4gICAgICBuZXdCb3VuZHMgPSByb3VuZEJvdW5kcyhuZXdCb3VuZHMpO1xuXG4gICAgICBpZiAoIWJvdW5kc0NoYW5nZWQoc2hhcGUsIG5ld0JvdW5kcykpIHtcblxuICAgICAgICAvLyBubyByZXNpemUgbmVjZXNzYXJ5XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcGVyZm9ybSB0aGUgYWN0dWFsIHJlc2l6ZVxuICAgICAgbW9kZWxpbmcucmVzaXplU2hhcGUoc2hhcGUsIG5ld0JvdW5kcyk7XG4gICAgfVxuICB9XG5cblxuICBldmVudEJ1cy5vbigncmVzaXplLnN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBoYW5kbGVTdGFydChldmVudC5jb250ZXh0KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ3Jlc2l6ZS5tb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZGVsdGEgPSB7XG4gICAgICB4OiBldmVudC5keCxcbiAgICAgIHk6IGV2ZW50LmR5XG4gICAgfTtcblxuICAgIGhhbmRsZU1vdmUoZXZlbnQuY29udGV4dCwgZGVsdGEpO1xuICB9KTtcblxuICBldmVudEJ1cy5vbigncmVzaXplLmVuZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaGFuZGxlRW5kKGV2ZW50LmNvbnRleHQpO1xuICB9KTtcblxufVxuXG5cblJlc2l6ZS5wcm90b3R5cGUuY2FuUmVzaXplID0gZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgcnVsZXMgPSB0aGlzLl9ydWxlcztcblxuICB2YXIgY3R4ID0gcGljayhjb250ZXh0LCBbICduZXdCb3VuZHMnLCAnc2hhcGUnLCAnZGVsdGEnLCAnZGlyZWN0aW9uJyBdKTtcblxuICByZXR1cm4gcnVsZXMuYWxsb3dlZCgnc2hhcGUucmVzaXplJywgY3R4KTtcbn07XG5cbi8qKlxuICogQWN0aXZhdGUgYSByZXNpemUgb3BlcmF0aW9uLlxuICpcbiAqIFlvdSBtYXkgc3BlY2lmeSBhZGRpdGlvbmFsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYW5kIG11c3Qgc3BlY2lmeSBhXG4gKiByZXNpemUgZGlyZWN0aW9uIGR1cmluZyBhY3RpdmF0aW9uIG9mIHRoZSByZXNpemUgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICogQHBhcmFtIHtkanMubW9kZWwuU2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGNvbnRleHRPckRpcmVjdGlvblxuICovXG5SZXNpemUucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZXZlbnQsIHNoYXBlLCBjb250ZXh0T3JEaXJlY3Rpb24pIHtcbiAgdmFyIGRyYWdnaW5nID0gdGhpcy5fZHJhZ2dpbmcsXG4gICAgICBjb250ZXh0LFxuICAgICAgZGlyZWN0aW9uO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dE9yRGlyZWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIGNvbnRleHRPckRpcmVjdGlvbiA9IHtcbiAgICAgIGRpcmVjdGlvbjogY29udGV4dE9yRGlyZWN0aW9uXG4gICAgfTtcbiAgfVxuXG4gIGNvbnRleHQgPSBhc3NpZ24oeyBzaGFwZTogc2hhcGUgfSwgY29udGV4dE9yRGlyZWN0aW9uKTtcblxuICBkaXJlY3Rpb24gPSBjb250ZXh0LmRpcmVjdGlvbjtcblxuICBpZiAoIWRpcmVjdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIGEgZGlyZWN0aW9uIChufHd8c3xlfG53fHNlfG5lfHN3KScpO1xuICB9XG5cbiAgZHJhZ2dpbmcuaW5pdChldmVudCwgZ2V0UmVmZXJlbmNlUG9pbnQoc2hhcGUsIGRpcmVjdGlvbiksICdyZXNpemUnLCB7XG4gICAgYXV0b0FjdGl2YXRlOiB0cnVlLFxuICAgIGN1cnNvcjogZ2V0Q3Vyc29yKGRpcmVjdGlvbiksXG4gICAgZGF0YToge1xuICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH1cbiAgfSk7XG59O1xuXG5SZXNpemUucHJvdG90eXBlLmNvbXB1dGVNaW5SZXNpemVCb3ggPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICBkaXJlY3Rpb24gPSBjb250ZXh0LmRpcmVjdGlvbixcbiAgICAgIG1pbkRpbWVuc2lvbnMsXG4gICAgICBjaGlsZHJlbkJvdW5kcztcblxuICBtaW5EaW1lbnNpb25zID0gY29udGV4dC5taW5EaW1lbnNpb25zIHx8IHtcbiAgICB3aWR0aDogREVGQVVMVF9NSU5fV0lEVEgsXG4gICAgaGVpZ2h0OiBERUZBVUxUX01JTl9XSURUSFxuICB9O1xuXG4gIC8vIGdldCBjaGlsZHJlbiBib3VuZHNcbiAgY2hpbGRyZW5Cb3VuZHMgPSBjb21wdXRlQ2hpbGRyZW5CQm94KHNoYXBlLCBjb250ZXh0LmNoaWxkcmVuQm94UGFkZGluZyk7XG5cbiAgLy8gZ2V0IGNvcnJlY3QgbWluaW11bSBib3VuZHMgZnJvbSBnaXZlbiByZXNpemUgZGlyZWN0aW9uXG4gIC8vIGJhc2ljYWxseSBlbnN1cmVzIHRoYXQgdGhlIG1pbkJvdW5kcyBpcyBtYXgoY2hpbGRyZW5Cb3VuZHMsIG1pbkRpbWVuc2lvbnMpXG4gIHJldHVybiBnZXRNaW5SZXNpemVCb3VuZHMoZGlyZWN0aW9uLCBzaGFwZSwgbWluRGltZW5zaW9ucywgY2hpbGRyZW5Cb3VuZHMpO1xufTtcblxuXG5SZXNpemUuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ3J1bGVzJyxcbiAgJ21vZGVsaW5nJyxcbiAgJ2RyYWdnaW5nJ1xuXTtcblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGJvdW5kc0NoYW5nZWQoc2hhcGUsIG5ld0JvdW5kcykge1xuICByZXR1cm4gc2hhcGUueCAhPT0gbmV3Qm91bmRzLnggfHxcbiAgICBzaGFwZS55ICE9PSBuZXdCb3VuZHMueSB8fFxuICAgIHNoYXBlLndpZHRoICE9PSBuZXdCb3VuZHMud2lkdGggfHxcbiAgICBzaGFwZS5oZWlnaHQgIT09IG5ld0JvdW5kcy5oZWlnaHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWZlcmVuY2VQb2ludChzaGFwZSwgZGlyZWN0aW9uKSB7XG4gIHZhciBtaWQgPSBnZXRNaWQoc2hhcGUpLFxuICAgICAgdHJibCA9IGFzVFJCTChzaGFwZSk7XG5cbiAgdmFyIHJlZmVyZW5jZVBvaW50ID0ge1xuICAgIHg6IG1pZC54LFxuICAgIHk6IG1pZC55XG4gIH07XG5cbiAgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCduJykgIT09IC0xKSB7XG4gICAgcmVmZXJlbmNlUG9pbnQueSA9IHRyYmwudG9wO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCdzJykgIT09IC0xKSB7XG4gICAgcmVmZXJlbmNlUG9pbnQueSA9IHRyYmwuYm90dG9tO1xuICB9XG5cbiAgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCdlJykgIT09IC0xKSB7XG4gICAgcmVmZXJlbmNlUG9pbnQueCA9IHRyYmwucmlnaHQ7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uLmluZGV4T2YoJ3cnKSAhPT0gLTEpIHtcbiAgICByZWZlcmVuY2VQb2ludC54ID0gdHJibC5sZWZ0O1xuICB9XG5cbiAgcmV0dXJuIHJlZmVyZW5jZVBvaW50O1xufVxuXG5mdW5jdGlvbiBnZXRDdXJzb3IoZGlyZWN0aW9uKSB7XG4gIHZhciBwcmVmaXggPSAncmVzaXplLSc7XG5cbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ24nIHx8IGRpcmVjdGlvbiA9PT0gJ3MnKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICducyc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnZScgfHwgZGlyZWN0aW9uID09PSAndycpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ2V3JztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdudycgfHwgZGlyZWN0aW9uID09PSAnc2UnKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdud3NlJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ25lc3cnO1xuICB9XG59IiwiaW1wb3J0IHtcbiAgYmluZCxcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY2xhc3NlcyBhcyBzdmdDbGFzc2VzLFxuICBjbGVhciBhcyBzdmdDbGVhcixcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7XG4gIGV2ZW50IGFzIGRvbUV2ZW50XG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQge1xuICBpc1ByaW1hcnlCdXR0b25cbn0gZnJvbSAnLi4vLi4vdXRpbC9Nb3VzZSc7XG5cbmltcG9ydCB7XG4gIHRyYW5zZm9ybVxufSBmcm9tICcuLi8uLi91dGlsL1N2Z1RyYW5zZm9ybVV0aWwnO1xuXG5pbXBvcnQgeyBnZXRSZWZlcmVuY2VQb2ludCB9IGZyb20gJy4vUmVzaXplJztcblxudmFyIEhBTkRMRV9PRkZTRVQgPSAtNixcbiAgICBIQU5ETEVfU0laRSA9IDQsXG4gICAgSEFORExFX0hJVF9TSVpFID0gMjA7XG5cbnZhciBDTFNfUkVTSVpFUiA9ICdkanMtcmVzaXplcic7XG5cbnZhciBkaXJlY3Rpb25zID0gWyAnbicsICd3JywgJ3MnLCAnZScsICdudycsICduZScsICdzZScsICdzdycgXTtcblxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGlzIHJlc3BvbnNpYmxlIGZvciBhZGRpbmcgcmVzaXplIGhhbmRsZXMuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7UmVzaXplfSByZXNpemVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmVzaXplSGFuZGxlcyhldmVudEJ1cywgY2FudmFzLCBzZWxlY3Rpb24sIHJlc2l6ZSkge1xuXG4gIHRoaXMuX3Jlc2l6ZSA9IHJlc2l6ZTtcbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBldmVudEJ1cy5vbignc2VsZWN0aW9uLmNoYW5nZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG5ld1NlbGVjdGlvbiA9IGUubmV3U2VsZWN0aW9uO1xuXG4gICAgLy8gcmVtb3ZlIG9sZCBzZWxlY3Rpb24gbWFya2Vyc1xuICAgIHNlbGYucmVtb3ZlUmVzaXplcnMoKTtcblxuICAgIC8vIGFkZCBuZXcgc2VsZWN0aW9uIG1hcmtlcnMgT05MWSBpZiBzaW5nbGUgc2VsZWN0aW9uXG4gICAgaWYgKG5ld1NlbGVjdGlvbi5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZvckVhY2gobmV3U2VsZWN0aW9uLCBiaW5kKHNlbGYuYWRkUmVzaXplciwgc2VsZikpO1xuICAgIH1cbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oJ3NoYXBlLmNoYW5nZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHNoYXBlID0gZS5lbGVtZW50O1xuXG4gICAgaWYgKHNlbGVjdGlvbi5pc1NlbGVjdGVkKHNoYXBlKSkge1xuICAgICAgc2VsZi5yZW1vdmVSZXNpemVycygpO1xuXG4gICAgICBzZWxmLmFkZFJlc2l6ZXIoc2hhcGUpO1xuICAgIH1cbiAgfSk7XG59XG5cblxuUmVzaXplSGFuZGxlcy5wcm90b3R5cGUubWFrZURyYWdnYWJsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGdmeCwgZGlyZWN0aW9uKSB7XG4gIHZhciByZXNpemUgPSB0aGlzLl9yZXNpemU7XG5cbiAgZnVuY3Rpb24gc3RhcnRSZXNpemUoZXZlbnQpIHtcblxuICAgIC8vIG9ubHkgdHJpZ2dlciBvbiBsZWZ0IG1vdXNlIGJ1dHRvblxuICAgIGlmIChpc1ByaW1hcnlCdXR0b24oZXZlbnQpKSB7XG4gICAgICByZXNpemUuYWN0aXZhdGUoZXZlbnQsIGVsZW1lbnQsIGRpcmVjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZG9tRXZlbnQuYmluZChnZngsICdtb3VzZWRvd24nLCBzdGFydFJlc2l6ZSk7XG4gIGRvbUV2ZW50LmJpbmQoZ2Z4LCAndG91Y2hzdGFydCcsIHN0YXJ0UmVzaXplKTtcbn07XG5cblxuUmVzaXplSGFuZGxlcy5wcm90b3R5cGUuX2NyZWF0ZVJlc2l6ZXIgPSBmdW5jdGlvbihlbGVtZW50LCB4LCB5LCBkaXJlY3Rpb24pIHtcbiAgdmFyIHJlc2l6ZXJzUGFyZW50ID0gdGhpcy5fZ2V0UmVzaXplcnNQYXJlbnQoKTtcblxuICB2YXIgb2Zmc2V0ID0gZ2V0SGFuZGxlT2Zmc2V0KGRpcmVjdGlvbik7XG5cbiAgdmFyIGdyb3VwID0gc3ZnQ3JlYXRlKCdnJyk7XG5cbiAgc3ZnQ2xhc3Nlcyhncm91cCkuYWRkKENMU19SRVNJWkVSKTtcbiAgc3ZnQ2xhc3Nlcyhncm91cCkuYWRkKENMU19SRVNJWkVSICsgJy0nICsgZWxlbWVudC5pZCk7XG4gIHN2Z0NsYXNzZXMoZ3JvdXApLmFkZChDTFNfUkVTSVpFUiArICctJyArIGRpcmVjdGlvbik7XG5cbiAgc3ZnQXBwZW5kKHJlc2l6ZXJzUGFyZW50LCBncm91cCk7XG5cbiAgdmFyIHZpc3VhbCA9IHN2Z0NyZWF0ZSgncmVjdCcpO1xuXG4gIHN2Z0F0dHIodmlzdWFsLCB7XG4gICAgeDogLUhBTkRMRV9TSVpFIC8gMiArIG9mZnNldC54LFxuICAgIHk6IC1IQU5ETEVfU0laRSAvIDIgKyBvZmZzZXQueSxcbiAgICB3aWR0aDogSEFORExFX1NJWkUsXG4gICAgaGVpZ2h0OiBIQU5ETEVfU0laRVxuICB9KTtcblxuICBzdmdDbGFzc2VzKHZpc3VhbCkuYWRkKENMU19SRVNJWkVSICsgJy12aXN1YWwnKTtcblxuICBzdmdBcHBlbmQoZ3JvdXAsIHZpc3VhbCk7XG5cbiAgdmFyIGhpdCA9IHN2Z0NyZWF0ZSgncmVjdCcpO1xuXG4gIHN2Z0F0dHIoaGl0LCB7XG4gICAgeDogLUhBTkRMRV9ISVRfU0laRSAvIDIgKyBvZmZzZXQueCxcbiAgICB5OiAtSEFORExFX0hJVF9TSVpFIC8gMiArIG9mZnNldC55LFxuICAgIHdpZHRoOiBIQU5ETEVfSElUX1NJWkUsXG4gICAgaGVpZ2h0OiBIQU5ETEVfSElUX1NJWkVcbiAgfSk7XG5cbiAgc3ZnQ2xhc3NlcyhoaXQpLmFkZChDTFNfUkVTSVpFUiArICctaGl0Jyk7XG5cbiAgc3ZnQXBwZW5kKGdyb3VwLCBoaXQpO1xuXG4gIHRyYW5zZm9ybShncm91cCwgeCwgeSk7XG5cbiAgcmV0dXJuIGdyb3VwO1xufTtcblxuUmVzaXplSGFuZGxlcy5wcm90b3R5cGUuY3JlYXRlUmVzaXplciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRpcmVjdGlvbikge1xuICB2YXIgcG9pbnQgPSBnZXRSZWZlcmVuY2VQb2ludChlbGVtZW50LCBkaXJlY3Rpb24pO1xuXG4gIHZhciByZXNpemVyID0gdGhpcy5fY3JlYXRlUmVzaXplcihlbGVtZW50LCBwb2ludC54LCBwb2ludC55LCBkaXJlY3Rpb24pO1xuXG4gIHRoaXMubWFrZURyYWdnYWJsZShlbGVtZW50LCByZXNpemVyLCBkaXJlY3Rpb24pO1xufTtcblxuLy8gcmVzaXplIGhhbmRsZXMgaW1wbGVtZW50YXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEFkZCByZXNpemVycyBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLlNoYXBlfSBzaGFwZVxuICovXG5SZXNpemVIYW5kbGVzLnByb3RvdHlwZS5hZGRSZXNpemVyID0gZnVuY3Rpb24oc2hhcGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciByZXNpemUgPSB0aGlzLl9yZXNpemU7XG5cbiAgaWYgKCFyZXNpemUuY2FuUmVzaXplKHsgc2hhcGU6IHNoYXBlIH0pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaChkaXJlY3Rpb25zLCBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICBzZWxmLmNyZWF0ZVJlc2l6ZXIoc2hhcGUsIGRpcmVjdGlvbik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIHJlc2l6ZXJzXG4gKi9cblJlc2l6ZUhhbmRsZXMucHJvdG90eXBlLnJlbW92ZVJlc2l6ZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNpemVyc1BhcmVudCA9IHRoaXMuX2dldFJlc2l6ZXJzUGFyZW50KCk7XG5cbiAgc3ZnQ2xlYXIocmVzaXplcnNQYXJlbnQpO1xufTtcblxuUmVzaXplSGFuZGxlcy5wcm90b3R5cGUuX2dldFJlc2l6ZXJzUGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jYW52YXMuZ2V0TGF5ZXIoJ3Jlc2l6ZXJzJyk7XG59O1xuXG5SZXNpemVIYW5kbGVzLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnc2VsZWN0aW9uJyxcbiAgJ3Jlc2l6ZSdcbl07XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBnZXRIYW5kbGVPZmZzZXQoZGlyZWN0aW9uKSB7XG4gIHZhciBvZmZzZXQgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCdlJykgIT09IC0xKSB7XG4gICAgb2Zmc2V0LnggPSAtSEFORExFX09GRlNFVDtcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24uaW5kZXhPZigndycpICE9PSAtMSkge1xuICAgIG9mZnNldC54ID0gSEFORExFX09GRlNFVDtcbiAgfVxuXG4gIGlmIChkaXJlY3Rpb24uaW5kZXhPZigncycpICE9PSAtMSkge1xuICAgIG9mZnNldC55ID0gLUhBTkRMRV9PRkZTRVQ7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uLmluZGV4T2YoJ24nKSAhPT0gLTEpIHtcbiAgICBvZmZzZXQueSA9IEhBTkRMRV9PRkZTRVQ7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufSIsInZhciBNQVJLRVJfUkVTSVpJTkcgPSAnZGpzLXJlc2l6aW5nJyxcbiAgICBNQVJLRVJfUkVTSVpFX05PVF9PSyA9ICdyZXNpemUtbm90LW9rJztcblxudmFyIExPV19QUklPUklUWSA9IDUwMDtcblxuaW1wb3J0IHtcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICByZW1vdmUgYXMgc3ZnUmVtb3ZlLFxuICBjbGFzc2VzIGFzIHN2Z0NsYXNzZXNcbn0gZnJvbSAndGlueS1zdmcnO1xuXG5cbi8qKlxuICogUHJvdmlkZXMgcHJldmlld3MgZm9yIHJlc2l6aW5nIHNoYXBlcyB3aGVuIHJlc2l6aW5nLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKiBAcGFyYW0ge1ByZXZpZXdTdXBwb3J0fSBwcmV2aWV3U3VwcG9ydFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZXNpemVQcmV2aWV3KGV2ZW50QnVzLCBjYW52YXMsIHByZXZpZXdTdXBwb3J0KSB7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSByZXNpemVyIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlRnJhbWUoY29udGV4dCkge1xuXG4gICAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZSxcbiAgICAgICAgYm91bmRzID0gY29udGV4dC5uZXdCb3VuZHMsXG4gICAgICAgIGZyYW1lID0gY29udGV4dC5mcmFtZTtcblxuICAgIGlmICghZnJhbWUpIHtcbiAgICAgIGZyYW1lID0gY29udGV4dC5mcmFtZSA9IHByZXZpZXdTdXBwb3J0LmFkZEZyYW1lKHNoYXBlLCBjYW52YXMuZ2V0RGVmYXVsdExheWVyKCkpO1xuXG4gICAgICBjYW52YXMuYWRkTWFya2VyKHNoYXBlLCBNQVJLRVJfUkVTSVpJTkcpO1xuICAgIH1cblxuICAgIGlmIChib3VuZHMud2lkdGggPiA1KSB7XG4gICAgICBzdmdBdHRyKGZyYW1lLCB7IHg6IGJvdW5kcy54LCB3aWR0aDogYm91bmRzLndpZHRoIH0pO1xuICAgIH1cblxuICAgIGlmIChib3VuZHMuaGVpZ2h0ID4gNSkge1xuICAgICAgc3ZnQXR0cihmcmFtZSwgeyB5OiBib3VuZHMueSwgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0IH0pO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LmNhbkV4ZWN1dGUpIHtcbiAgICAgIHN2Z0NsYXNzZXMoZnJhbWUpLnJlbW92ZShNQVJLRVJfUkVTSVpFX05PVF9PSyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN2Z0NsYXNzZXMoZnJhbWUpLmFkZChNQVJLRVJfUkVTSVpFX05PVF9PSyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSByZXNpemVyIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlRnJhbWUoY29udGV4dCkge1xuICAgIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXG4gICAgICAgIGZyYW1lID0gY29udGV4dC5mcmFtZTtcblxuICAgIGlmIChmcmFtZSkge1xuICAgICAgc3ZnUmVtb3ZlKGNvbnRleHQuZnJhbWUpO1xuICAgIH1cblxuICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoc2hhcGUsIE1BUktFUl9SRVNJWklORyk7XG4gIH1cblxuICAvLyBhZGQgYW5kIHVwZGF0ZSBwcmV2aWV3c1xuICBldmVudEJ1cy5vbigncmVzaXplLm1vdmUnLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdXBkYXRlRnJhbWUoZXZlbnQuY29udGV4dCk7XG4gIH0pO1xuXG4gIC8vIHJlbW92ZSBwcmV2aWV3c1xuICBldmVudEJ1cy5vbigncmVzaXplLmNsZWFudXAnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHJlbW92ZUZyYW1lKGV2ZW50LmNvbnRleHQpO1xuICB9KTtcblxufVxuXG5SZXNpemVQcmV2aWV3LiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAncHJldmlld1N1cHBvcnQnXG5dOyIsImltcG9ydCB7XG4gIGZpbHRlcixcbiAgaXNOdW1iZXJcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG52YXIgbWF4ID0gTWF0aC5tYXgsXG4gICAgbWluID0gTWF0aC5taW47XG5cbnZhciBERUZBVUxUX0NISUxEX0JPWF9QQURESU5HID0gMjA7XG5cbmltcG9ydCB7XG4gIGdldEJCb3hcbn0gZnJvbSAnLi4vLi4vdXRpbC9FbGVtZW50cyc7XG5cbmltcG9ydCB7XG4gIGFzVFJCTCxcbiAgYXNCb3VuZHNcbn0gZnJvbSAnLi4vLi4vbGF5b3V0L0xheW91dFV0aWwnO1xuXG5cbi8qKlxuICogU3Vic3RyYWN0IGEgVFJCTCBmcm9tIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0gIHtUUkJMfSB0cmJsQVxuICogQHBhcmFtICB7VFJCTH0gdHJibEJcbiAqXG4gKiBAcmV0dXJuIHtUUkJMfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3Vic3RyYWN0VFJCTCh0cmJsQSwgdHJibEIpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHRyYmxBLnRvcCAtIHRyYmxCLnRvcCxcbiAgICByaWdodDogdHJibEEucmlnaHQgLSB0cmJsQi5yaWdodCxcbiAgICBib3R0b206IHRyYmxBLmJvdHRvbSAtIHRyYmxCLmJvdHRvbSxcbiAgICBsZWZ0OiB0cmJsQS5sZWZ0IC0gdHJibEIubGVmdFxuICB9O1xufVxuXG4vKipcbiAqIFJlc2l6ZSB0aGUgZ2l2ZW4gYm91bmRzIGJ5IHRoZSBzcGVjaWZpZWQgZGVsdGEgZnJvbSBhIGdpdmVuIGFuY2hvciBwb2ludC5cbiAqXG4gKiBAcGFyYW0ge0JvdW5kc30gYm91bmRzIHRoZSBib3VuZGluZyBib3ggdGhhdCBzaG91bGQgYmUgcmVzaXplZFxuICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgZWxlbWVudCBpcyByZXNpemVkIChudywgbmUsIHNlLCBzdylcbiAqIEBwYXJhbSB7UG9pbnR9IGRlbHRhIG9mIHRoZSByZXNpemUgb3BlcmF0aW9uXG4gKlxuICogQHJldHVybiB7Qm91bmRzfSByZXNpemVkIGJvdW5kaW5nIGJveFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzaXplQm91bmRzKGJvdW5kcywgZGlyZWN0aW9uLCBkZWx0YSkge1xuICB2YXIgZHggPSBkZWx0YS54LFxuICAgICAgZHkgPSBkZWx0YS55O1xuXG4gIHZhciBuZXdCb3VuZHMgPSB7XG4gICAgeDogYm91bmRzLngsXG4gICAgeTogYm91bmRzLnksXG4gICAgd2lkdGg6IGJvdW5kcy53aWR0aCxcbiAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHRcbiAgfTtcblxuICBpZiAoZGlyZWN0aW9uLmluZGV4T2YoJ24nKSAhPT0gLTEpIHtcbiAgICBuZXdCb3VuZHMueSA9IGJvdW5kcy55ICsgZHk7XG4gICAgbmV3Qm91bmRzLmhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSBkeTtcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24uaW5kZXhPZigncycpICE9PSAtMSkge1xuICAgIG5ld0JvdW5kcy5oZWlnaHQgPSBib3VuZHMuaGVpZ2h0ICsgZHk7XG4gIH1cblxuICBpZiAoZGlyZWN0aW9uLmluZGV4T2YoJ2UnKSAhPT0gLTEpIHtcbiAgICBuZXdCb3VuZHMud2lkdGggPSBib3VuZHMud2lkdGggKyBkeDtcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24uaW5kZXhPZigndycpICE9PSAtMSkge1xuICAgIG5ld0JvdW5kcy54ID0gYm91bmRzLnggKyBkeDtcbiAgICBuZXdCb3VuZHMud2lkdGggPSBib3VuZHMud2lkdGggLSBkeDtcbiAgfVxuXG4gIHJldHVybiBuZXdCb3VuZHM7XG59XG5cblxuLyoqXG4gKiBSZXNpemUgdGhlIGdpdmVuIGJvdW5kcyBieSBhcHBseWluZyB0aGUgcGFzc2VkXG4gKiB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCB9IGRlbHRhLlxuICpcbiAqIEBwYXJhbSB7Qm91bmRzfSBib3VuZHNcbiAqIEBwYXJhbSB7VFJCTH0gdHJibFJlc2l6ZVxuICpcbiAqIEByZXR1cm4ge0JvdW5kc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZVRSQkwoYm91bmRzLCByZXNpemUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBib3VuZHMueCArIChyZXNpemUubGVmdCB8fCAwKSxcbiAgICB5OiBib3VuZHMueSArIChyZXNpemUudG9wIHx8IDApLFxuICAgIHdpZHRoOiBib3VuZHMud2lkdGggLSAocmVzaXplLmxlZnQgfHwgMCkgKyAocmVzaXplLnJpZ2h0IHx8IDApLFxuICAgIGhlaWdodDogYm91bmRzLmhlaWdodCAtIChyZXNpemUudG9wIHx8IDApICsgKHJlc2l6ZS5ib3R0b20gfHwgMClcbiAgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcmVhdHRhY2hQb2ludChib3VuZHMsIG5ld0JvdW5kcywgcG9pbnQpIHtcblxuICB2YXIgc3ggPSBib3VuZHMud2lkdGggLyBuZXdCb3VuZHMud2lkdGgsXG4gICAgICBzeSA9IGJvdW5kcy5oZWlnaHQgLyBuZXdCb3VuZHMuaGVpZ2h0O1xuXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgobmV3Qm91bmRzLnggKyBuZXdCb3VuZHMud2lkdGggLyAyKSkgLSBNYXRoLmZsb29yKCgoYm91bmRzLnggKyBib3VuZHMud2lkdGggLyAyKSAtIHBvaW50LngpIC8gc3gpLFxuICAgIHk6IE1hdGgucm91bmQoKG5ld0JvdW5kcy55ICsgbmV3Qm91bmRzLmhlaWdodCAvIDIpKSAtIE1hdGguZmxvb3IoKChib3VuZHMueSArIGJvdW5kcy5oZWlnaHQgLyAyKSAtIHBvaW50LnkpIC8gc3kpXG4gIH07XG59XG5cblxuZnVuY3Rpb24gYXBwbHlDb25zdHJhaW50cyhhdHRyLCB0cmJsLCByZXNpemVDb25zdHJhaW50cykge1xuXG4gIHZhciB2YWx1ZSA9IHRyYmxbYXR0cl0sXG4gICAgICBtaW5WYWx1ZSA9IHJlc2l6ZUNvbnN0cmFpbnRzLm1pbiAmJiByZXNpemVDb25zdHJhaW50cy5taW5bYXR0cl0sXG4gICAgICBtYXhWYWx1ZSA9IHJlc2l6ZUNvbnN0cmFpbnRzLm1heCAmJiByZXNpemVDb25zdHJhaW50cy5tYXhbYXR0cl07XG5cbiAgaWYgKGlzTnVtYmVyKG1pblZhbHVlKSkge1xuICAgIHZhbHVlID0gKC90b3B8bGVmdC8udGVzdChhdHRyKSA/IG1pbiA6IG1heCkodmFsdWUsIG1pblZhbHVlKTtcbiAgfVxuXG4gIGlmIChpc051bWJlcihtYXhWYWx1ZSkpIHtcbiAgICB2YWx1ZSA9ICgvdG9wfGxlZnQvLnRlc3QoYXR0cikgPyBtYXggOiBtaW4pKHZhbHVlLCBtYXhWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVDb25zdHJhaW50cyhjdXJyZW50Qm91bmRzLCByZXNpemVDb25zdHJhaW50cykge1xuXG4gIGlmICghcmVzaXplQ29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gY3VycmVudEJvdW5kcztcbiAgfVxuXG4gIHZhciBjdXJyZW50VHJibCA9IGFzVFJCTChjdXJyZW50Qm91bmRzKTtcblxuICByZXR1cm4gYXNCb3VuZHMoe1xuICAgIHRvcDogYXBwbHlDb25zdHJhaW50cygndG9wJywgY3VycmVudFRyYmwsIHJlc2l6ZUNvbnN0cmFpbnRzKSxcbiAgICByaWdodDogYXBwbHlDb25zdHJhaW50cygncmlnaHQnLCBjdXJyZW50VHJibCwgcmVzaXplQ29uc3RyYWludHMpLFxuICAgIGJvdHRvbTogYXBwbHlDb25zdHJhaW50cygnYm90dG9tJywgY3VycmVudFRyYmwsIHJlc2l6ZUNvbnN0cmFpbnRzKSxcbiAgICBsZWZ0OiBhcHBseUNvbnN0cmFpbnRzKCdsZWZ0JywgY3VycmVudFRyYmwsIHJlc2l6ZUNvbnN0cmFpbnRzKVxuICB9KTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluUmVzaXplQm91bmRzKGRpcmVjdGlvbiwgY3VycmVudEJvdW5kcywgbWluRGltZW5zaW9ucywgY2hpbGRyZW5Cb3VuZHMpIHtcblxuICB2YXIgY3VycmVudEJveCA9IGFzVFJCTChjdXJyZW50Qm91bmRzKTtcblxuICB2YXIgbWluQm94ID0ge1xuICAgIHRvcDogL24vLnRlc3QoZGlyZWN0aW9uKSA/IGN1cnJlbnRCb3guYm90dG9tIC0gbWluRGltZW5zaW9ucy5oZWlnaHQgOiBjdXJyZW50Qm94LnRvcCxcbiAgICBsZWZ0OiAvdy8udGVzdChkaXJlY3Rpb24pID8gY3VycmVudEJveC5yaWdodCAtIG1pbkRpbWVuc2lvbnMud2lkdGggOiBjdXJyZW50Qm94LmxlZnQsXG4gICAgYm90dG9tOiAvcy8udGVzdChkaXJlY3Rpb24pID8gY3VycmVudEJveC50b3AgKyBtaW5EaW1lbnNpb25zLmhlaWdodCA6IGN1cnJlbnRCb3guYm90dG9tLFxuICAgIHJpZ2h0OiAvZS8udGVzdChkaXJlY3Rpb24pID8gY3VycmVudEJveC5sZWZ0ICsgbWluRGltZW5zaW9ucy53aWR0aCA6IGN1cnJlbnRCb3gucmlnaHRcbiAgfTtcblxuICB2YXIgY2hpbGRyZW5Cb3ggPSBjaGlsZHJlbkJvdW5kcyA/IGFzVFJCTChjaGlsZHJlbkJvdW5kcykgOiBtaW5Cb3g7XG5cbiAgdmFyIGNvbWJpbmVkQm94ID0ge1xuICAgIHRvcDogbWluKG1pbkJveC50b3AsIGNoaWxkcmVuQm94LnRvcCksXG4gICAgbGVmdDogbWluKG1pbkJveC5sZWZ0LCBjaGlsZHJlbkJveC5sZWZ0KSxcbiAgICBib3R0b206IG1heChtaW5Cb3guYm90dG9tLCBjaGlsZHJlbkJveC5ib3R0b20pLFxuICAgIHJpZ2h0OiBtYXgobWluQm94LnJpZ2h0LCBjaGlsZHJlbkJveC5yaWdodClcbiAgfTtcblxuICByZXR1cm4gYXNCb3VuZHMoY29tYmluZWRCb3gpO1xufVxuXG5mdW5jdGlvbiBhc1BhZGRpbmcobWF5QmVQYWRkaW5nLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBtYXlCZVBhZGRpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG1heUJlUGFkZGluZztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVGQVVMVF9DSElMRF9CT1hfUEFERElORztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUGFkZGluZyhiYm94LCBwYWRkaW5nKSB7XG4gIHZhciBsZWZ0LCByaWdodCwgdG9wLCBib3R0b207XG5cbiAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnb2JqZWN0Jykge1xuICAgIGxlZnQgPSBhc1BhZGRpbmcocGFkZGluZy5sZWZ0KTtcbiAgICByaWdodCA9IGFzUGFkZGluZyhwYWRkaW5nLnJpZ2h0KTtcbiAgICB0b3AgPSBhc1BhZGRpbmcocGFkZGluZy50b3ApO1xuICAgIGJvdHRvbSA9IGFzUGFkZGluZyhwYWRkaW5nLmJvdHRvbSk7XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IHJpZ2h0ID0gdG9wID0gYm90dG9tID0gYXNQYWRkaW5nKHBhZGRpbmcpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBiYm94LnggLSBsZWZ0LFxuICAgIHk6IGJib3gueSAtIHRvcCxcbiAgICB3aWR0aDogYmJveC53aWR0aCArIGxlZnQgKyByaWdodCxcbiAgICBoZWlnaHQ6IGJib3guaGVpZ2h0ICsgdG9wICsgYm90dG9tXG4gIH07XG59XG5cblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gZWxlbWVudCBwYXJ0IG9mIHRoZSByZXNpemVcbiAqIHRhcmdldHMgbWluIGJvdW5kYXJ5IGJveD9cbiAqXG4gKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdoaWNoIGV4Y2x1ZGVzXG4gKiBjb25uZWN0aW9ucyBhbmQgbGFiZWxzLlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkJhc2V9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gaXNCQm94Q2hpbGQoZWxlbWVudCkge1xuXG4gIC8vIGV4Y2x1ZGUgY29ubmVjdGlvbnNcbiAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZXhjbHVkZSBsYWJlbHNcbiAgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ2xhYmVsJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybiBjaGlsZHJlbiBib3VuZGluZyBjb21wdXRlZCBmcm9tIGEgc2hhcGVzIGNoaWxkcmVuXG4gKiBvciBhIGxpc3Qgb2YgcHJlZmlsdGVyZWQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtICB7ZGpzLm1vZGVsLlNoYXBlfEFycmF5PGRqcy5tb2RlbC5TaGFwZT59IHNoYXBlT3JDaGlsZHJlblxuICogQHBhcmFtICB7bnVtYmVyfE9iamVjdH0gcGFkZGluZ1xuICpcbiAqIEByZXR1cm4ge0JvdW5kc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVDaGlsZHJlbkJCb3goc2hhcGVPckNoaWxkcmVuLCBwYWRkaW5nKSB7XG5cbiAgdmFyIGVsZW1lbnRzO1xuXG4gIC8vIGNvbXB1dGUgYmFzZWQgb24gc2hhcGVcbiAgaWYgKHNoYXBlT3JDaGlsZHJlbi5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuXG4gICAgLy8gZ3JhYiBhbGwgdGhlIGNoaWxkcmVuIHRoYXQgYXJlIHBhcnQgb2YgdGhlXG4gICAgLy8gcGFyZW50cyBjaGlsZHJlbiBib3hcbiAgICBlbGVtZW50cyA9IGZpbHRlcihzaGFwZU9yQ2hpbGRyZW4uY2hpbGRyZW4sIGlzQkJveENoaWxkKTtcblxuICB9IGVsc2Uge1xuICAgIGVsZW1lbnRzID0gc2hhcGVPckNoaWxkcmVuO1xuICB9XG5cbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBhZGRQYWRkaW5nKGdldEJCb3goZWxlbWVudHMpLCBwYWRkaW5nKTtcbiAgfVxufVxuIiwiaW1wb3J0IFJ1bGVzTW9kdWxlIGZyb20gJy4uL3J1bGVzJztcbmltcG9ydCBEcmFnZ2luZ01vZHVsZSBmcm9tICcuLi9kcmFnZ2luZyc7XG5pbXBvcnQgUHJldmlld1N1cHBvcnRNb2R1bGUgZnJvbSAnLi4vcHJldmlldy1zdXBwb3J0JztcblxuaW1wb3J0IFJlc2l6ZSBmcm9tICcuL1Jlc2l6ZSc7XG5pbXBvcnQgUmVzaXplUHJldmlldyBmcm9tICcuL1Jlc2l6ZVByZXZpZXcnO1xuaW1wb3J0IFJlc2l6ZUhhbmRsZXMgZnJvbSAnLi9SZXNpemVIYW5kbGVzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIFJ1bGVzTW9kdWxlLFxuICAgIERyYWdnaW5nTW9kdWxlLFxuICAgIFByZXZpZXdTdXBwb3J0TW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbXG4gICAgJ3Jlc2l6ZScsXG4gICAgJ3Jlc2l6ZVByZXZpZXcnLFxuICAgICdyZXNpemVIYW5kbGVzJ1xuICBdLFxuICByZXNpemU6IFsgJ3R5cGUnLCBSZXNpemUgXSxcbiAgcmVzaXplUHJldmlldzogWyAndHlwZScsIFJlc2l6ZVByZXZpZXcgXSxcbiAgcmVzaXplSGFuZGxlczogWyAndHlwZScsIFJlc2l6ZUhhbmRsZXMgXVxufTtcbiIsImltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBDb21tYW5kSW50ZXJjZXB0b3IgZnJvbSAnLi4vLi4vY29tbWFuZC9Db21tYW5kSW50ZXJjZXB0b3InO1xuXG4vKipcbiAqIEEgYmFzaWMgcHJvdmlkZXIgdGhhdCBtYXkgYmUgZXh0ZW5kZWQgdG8gaW1wbGVtZW50IG1vZGVsaW5nIHJ1bGVzLlxuICpcbiAqIEV4dGVuc2lvbnMgc2hvdWxkIGltcGxlbWVudCB0aGUgaW5pdCBtZXRob2QgdG8gYWN0dWFsbHkgYWRkIHRoZWlyIGN1c3RvbVxuICogbW9kZWxpbmcgY2hlY2tzLiBDaGVja3MgbWF5IGJlIGFkZGVkIHZpYSB0aGUgI2FkZFJ1bGUoYWN0aW9uLCBmbikgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJ1bGVQcm92aWRlcihldmVudEJ1cykge1xuICBDb21tYW5kSW50ZXJjZXB0b3IuY2FsbCh0aGlzLCBldmVudEJ1cyk7XG5cbiAgdGhpcy5pbml0KCk7XG59XG5cblJ1bGVQcm92aWRlci4kaW5qZWN0ID0gWyAnZXZlbnRCdXMnIF07XG5cbmluaGVyaXRzKFJ1bGVQcm92aWRlciwgQ29tbWFuZEludGVyY2VwdG9yKTtcblxuXG4vKipcbiAqIEFkZHMgYSBtb2RlbGluZyBydWxlIGZvciB0aGUgZ2l2ZW4gYWN0aW9uLCBpbXBsZW1lbnRlZCB0aHJvdWdoXG4gKiBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIG1vZGVsaW5nIHNwZWNpZmljIGFjdGlvbiBjb250ZXh0XG4gKiB0byBwZXJmb3JtIGl0cyBjaGVjay4gSXQgbXVzdCByZXR1cm4gYGZhbHNlYCB0byBkaXNhbGxvdyB0aGVcbiAqIGFjdGlvbiBmcm9tIGhhcHBlbmluZyBvciBgdHJ1ZWAgdG8gYWxsb3cgdGhlIGFjdGlvbi5cbiAqXG4gKiBBIHJ1bGUgcHJvdmlkZXIgbWF5IHBhc3Mgb3ZlciB0aGUgZXZhbHVhdGlvbiB0byBsb3dlciBwcmlvcml0eVxuICogcnVsZXMgYnkgcmV0dXJuaW5nIHJldHVybiBub3RoaW5nIChvciA8Y29kZT51bmRlZmluZWQ8L2NvZGU+KS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFJlc2l6YWJsZVJ1bGVzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gKlxuICogICBcXC8qKlxuICogICAgKiBSZXR1cm4gYHRydWVgLCBgZmFsc2VgIG9yIG5vdGhpbmcgdG8gZGVub3RlXG4gKiAgICAqIF9hbGxvd2VkXywgX25vdCBhbGxvd2VkXyBhbmQgX2NvbnRpbnVlIGV2YWx1YXRpbmdfLlxuICogICAgKlxcL1xuICogICB0aGlzLmFkZFJ1bGUoJ3NoYXBlLnJlc2l6ZScsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAqXG4gKiAgICAgdmFyIHNoYXBlID0gY29udGV4dC5zaGFwZTtcbiAqXG4gKiAgICAgaWYgKCFjb250ZXh0Lm5ld0JvdW5kcykge1xuICogICAgICAgLy8gY2hlY2sgZ2VuZXJhbCByZXNpemFiaWxpdHlcbiAqICAgICAgIGlmICghc2hhcGUucmVzaXphYmxlKSB7XG4gKiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAqICAgICAgIH1cbiAqXG4gKiAgICAgICAvLyBub3QgcmV0dXJuaW5nIGFueXRoaW5nIChyZWFkOiB1bmRlZmluZWQpXG4gKiAgICAgICAvLyB3aWxsIGNvbnRpbnVlIHRoZSBldmFsdWF0aW9uIG9mIG90aGVyIHJ1bGVzXG4gKiAgICAgICAvLyAod2l0aCBsb3dlciBwcmlvcml0eSlcbiAqICAgICAgIHJldHVybjtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgLy8gZWxlbWVudCBtdXN0IGhhdmUgbWluaW11bSBzaXplIG9mIDEwKjEwIHBvaW50c1xuICogICAgICAgcmV0dXJuIGNvbnRleHQubmV3Qm91bmRzLndpZHRoID4gMTAgJiYgY29udGV4dC5uZXdCb3VuZHMuaGVpZ2h0ID4gMTA7XG4gKiAgICAgfVxuICogICB9KTtcbiAqIH07XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gYWN0aW9ucyB0aGUgaWRlbnRpZmllciBmb3IgdGhlIG1vZGVsaW5nIGFjdGlvbiB0byBjaGVja1xuICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eV0gdGhlIHByaW9yaXR5IGF0IHdoaWNoIHRoaXMgcnVsZSBpcyBiZWluZyBhcHBsaWVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGUgYWN0dWFsIGNoZWNrXG4gKi9cblJ1bGVQcm92aWRlci5wcm90b3R5cGUuYWRkUnVsZSA9IGZ1bmN0aW9uKGFjdGlvbnMsIHByaW9yaXR5LCBmbikge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodHlwZW9mIGFjdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgYWN0aW9ucyA9IFsgYWN0aW9ucyBdO1xuICB9XG5cbiAgYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGFjdGlvbikge1xuXG4gICAgc2VsZi5jYW5FeGVjdXRlKGFjdGlvbiwgcHJpb3JpdHksIGZ1bmN0aW9uKGNvbnRleHQsIGFjdGlvbiwgZXZlbnQpIHtcbiAgICAgIHJldHVybiBmbihjb250ZXh0KTtcbiAgICB9LCB0cnVlKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBhZGQgbmV3IHJ1bGVzIGR1cmluZyBwcm92aWRlciBpbml0aWFsaXphdGlvbi5cbiAqL1xuUnVsZVByb3ZpZGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7fTsiLCIvKipcbiAqIEEgc2VydmljZSB0aGF0IHByb3ZpZGVzIHJ1bGVzIGZvciBjZXJ0YWluIGRpYWdyYW0gYWN0aW9ucy5cbiAqXG4gKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGhvb2sgaW50byB0aGUge0BsaW5rIENvbW1hbmRTdGFja31cbiAqIHRvIHBlcmZvcm0gdGhlIGFjdHVhbCBydWxlIGV2YWx1YXRpb24uIE1ha2Ugc3VyZSB0byBwcm92aWRlIHRoZVxuICogYGNvbW1hbmRTdGFja2Agc2VydmljZSB3aXRoIHRoaXMgbW9kdWxlIGlmIHlvdSBwbGFuIHRvIHVzZSBpdC5cbiAqXG4gKiBUb2dldGhlciB3aXRoIHRoaXMgaW1wbGVtZW50YXRpb24geW91IG1heSB1c2UgdGhlIHtAbGluayBSdWxlUHJvdmlkZXJ9XG4gKiB0byBpbXBsZW1lbnQgeW91ciBvd24gcnVsZSBjaGVja2Vycy5cbiAqXG4gKiBUaGlzIG1vZHVsZSBpcyBtZW50IHRvIGJlIGVhc2lseSByZXBsYWNlZCwgdGh1cyB0aGUgdGlueSBmb290IHByaW50LlxuICpcbiAqIEBwYXJhbSB7SW5qZWN0b3J9IGluamVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJ1bGVzKGluamVjdG9yKSB7XG4gIHRoaXMuX2NvbW1hbmRTdGFjayA9IGluamVjdG9yLmdldCgnY29tbWFuZFN0YWNrJywgZmFsc2UpO1xufVxuXG5SdWxlcy4kaW5qZWN0ID0gWyAnaW5qZWN0b3InIF07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEgZ2l2ZW4gbW9kZWxpbmcgYWN0aW9uIGNhbiBiZSBleGVjdXRlZFxuICogaW4gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gd2lsbCByZXNwb25kIHdpdGggYWxsb3cgdW5sZXNzIGFueW9uZVxuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uIHRoZSBhY3Rpb24gdG8gYmUgY2hlY2tlZFxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSB0aGUgY29udGV4dCB0byBjaGVjayB0aGUgYWN0aW9uIGluXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlLCBmYWxzZSBvciBudWxsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZVxuICogICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uIGlzIGFsbG93ZWQsIG5vdCBhbGxvd2VkIG9yIHNob3VsZCBiZSBpZ25vcmVkLlxuICovXG5SdWxlcy5wcm90b3R5cGUuYWxsb3dlZCA9IGZ1bmN0aW9uKGFjdGlvbiwgY29udGV4dCkge1xuICB2YXIgYWxsb3dlZCA9IHRydWU7XG5cbiAgdmFyIGNvbW1hbmRTdGFjayA9IHRoaXMuX2NvbW1hbmRTdGFjaztcblxuICBpZiAoY29tbWFuZFN0YWNrKSB7XG4gICAgYWxsb3dlZCA9IGNvbW1hbmRTdGFjay5jYW5FeGVjdXRlKGFjdGlvbiwgY29udGV4dCk7XG4gIH1cblxuICAvLyBtYXAgdW5kZWZpbmVkIHRvIHRydWUsIGkuZS4gbm8gcnVsZXNcbiAgcmV0dXJuIGFsbG93ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbGxvd2VkO1xufTsiLCJpbXBvcnQgUnVsZXMgZnJvbSAnLi9SdWxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ3J1bGVzJyBdLFxuICBydWxlczogWyAndHlwZScsIFJ1bGVzIF1cbn07XG4iLCJpbXBvcnQge1xuICBpc0FycmF5LFxuICBmb3JFYWNoXG59IGZyb20gJ21pbi1kYXNoJztcblxuXG4vKipcbiAqIEEgc2VydmljZSB0aGF0IG9mZmVycyB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW4gYSBkaWFncmFtLlxuICogT2ZmZXJzIHRoZSBhcGkgdG8gY29udHJvbCB0aGUgc2VsZWN0aW9uLCB0b28uXG4gKlxuICogQGNsYXNzXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXMgdGhlIGV2ZW50IGJ1c1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZWxlY3Rpb24oZXZlbnRCdXMpIHtcblxuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuXG4gIHRoaXMuX3NlbGVjdGVkRWxlbWVudHMgPSBbXTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZXZlbnRCdXMub24oWyAnc2hhcGUucmVtb3ZlJywgJ2Nvbm5lY3Rpb24ucmVtb3ZlJyBdLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBlLmVsZW1lbnQ7XG4gICAgc2VsZi5kZXNlbGVjdChlbGVtZW50KTtcbiAgfSk7XG5cbiAgZXZlbnRCdXMub24oWyAnZGlhZ3JhbS5jbGVhcicgXSwgZnVuY3Rpb24oZSkge1xuICAgIHNlbGYuc2VsZWN0KG51bGwpO1xuICB9KTtcbn1cblxuU2VsZWN0aW9uLiRpbmplY3QgPSBbICdldmVudEJ1cycgXTtcblxuXG5TZWxlY3Rpb24ucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgc2VsZWN0ZWRFbGVtZW50cyA9IHRoaXMuX3NlbGVjdGVkRWxlbWVudHM7XG5cbiAgdmFyIGlkeCA9IHNlbGVjdGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KTtcblxuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIHZhciBvbGRTZWxlY3Rpb24gPSBzZWxlY3RlZEVsZW1lbnRzLnNsaWNlKCk7XG5cbiAgICBzZWxlY3RlZEVsZW1lbnRzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnc2VsZWN0aW9uLmNoYW5nZWQnLCB7IG9sZFNlbGVjdGlvbjogb2xkU2VsZWN0aW9uLCBuZXdTZWxlY3Rpb246IHNlbGVjdGVkRWxlbWVudHMgfSk7XG4gIH1cbn07XG5cblxuU2VsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkRWxlbWVudHM7XG59O1xuXG5TZWxlY3Rpb24ucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiB0aGlzLl9zZWxlY3RlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCkgIT09IC0xO1xufTtcblxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNlbGVjdHMgb25lIG9yIG1vcmUgZWxlbWVudHMgb24gdGhlIGRpYWdyYW0uXG4gKlxuICogQnkgcGFzc2luZyBhbiBhZGRpdGlvbmFsIGFkZCBwYXJhbWV0ZXIgeW91IGNhbiBkZWNpZGUgd2hldGhlciBvciBub3QgdGhlIGVsZW1lbnQocylcbiAqIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgYWxyZWFkeSBleGlzdGluZyBzZWxlY3Rpb24gb3Igbm90LlxuICpcbiAqIEBtZXRob2QgU2VsZWN0aW9uI3NlbGVjdFxuICpcbiAqIEBwYXJhbSAge09iamVjdHxPYmplY3RbXX0gZWxlbWVudHMgZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byBiZSBzZWxlY3RlZFxuICogQHBhcmFtICB7Ym9vbGVhbn0gW2FkZF0gd2hldGhlciB0aGUgZWxlbWVudChzKSBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCBkZWZhdWx0cyB0byBmYWxzZVxuICovXG5TZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBhZGQpIHtcbiAgdmFyIHNlbGVjdGVkRWxlbWVudHMgPSB0aGlzLl9zZWxlY3RlZEVsZW1lbnRzLFxuICAgICAgb2xkU2VsZWN0aW9uID0gc2VsZWN0ZWRFbGVtZW50cy5zbGljZSgpO1xuXG4gIGlmICghaXNBcnJheShlbGVtZW50cykpIHtcbiAgICBlbGVtZW50cyA9IGVsZW1lbnRzID8gWyBlbGVtZW50cyBdIDogW107XG4gIH1cblxuICAvLyBzZWxlY3Rpb24gbWF5IGJlIGNsZWFyZWQgYnkgcGFzc2luZyBhbiBlbXB0eSBhcnJheSBvciBudWxsXG4gIC8vIHRvIHRoZSBtZXRob2RcbiAgaWYgKGFkZCkge1xuICAgIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCkgIT09IC0xKSB7XG5cbiAgICAgICAgLy8gYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc2VsZWN0ZWRFbGVtZW50cyA9IHNlbGVjdGVkRWxlbWVudHMgPSBlbGVtZW50cy5zbGljZSgpO1xuICB9XG5cbiAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnc2VsZWN0aW9uLmNoYW5nZWQnLCB7IG9sZFNlbGVjdGlvbjogb2xkU2VsZWN0aW9uLCBuZXdTZWxlY3Rpb246IHNlbGVjdGVkRWxlbWVudHMgfSk7XG59O1xuIiwiaW1wb3J0IHtcbiAgaGFzUHJpbWFyeU1vZGlmaWVyLFxuICBoYXNTZWNvbmRhcnlNb2RpZmllcixcbiAgaXNQcmltYXJ5QnV0dG9uXG59IGZyb20gJy4uLy4uL3V0aWwvTW91c2UnO1xuXG5pbXBvcnQge1xuICBmaW5kLFxuICBpc0FycmF5XG59IGZyb20gJ21pbi1kYXNoJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZWxlY3Rpb25CZWhhdmlvcihldmVudEJ1cywgc2VsZWN0aW9uLCBjYW52YXMsIGVsZW1lbnRSZWdpc3RyeSkge1xuXG4gIC8vIFNlbGVjdCBlbGVtZW50cyBvbiBjcmVhdGVcbiAgZXZlbnRCdXMub24oJ2NyZWF0ZS5lbmQnLCA1MDAsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBjYW5FeGVjdXRlID0gY29udGV4dC5jYW5FeGVjdXRlLFxuICAgICAgICBlbGVtZW50cyA9IGNvbnRleHQuZWxlbWVudHMsXG4gICAgICAgIGhpbnRzID0gY29udGV4dC5oaW50cyB8fCB7fSxcbiAgICAgICAgYXV0b1NlbGVjdCA9IGhpbnRzLmF1dG9TZWxlY3Q7XG5cbiAgICBpZiAoY2FuRXhlY3V0ZSkge1xuICAgICAgaWYgKGF1dG9TZWxlY3QgPT09IGZhbHNlKSB7XG5cbiAgICAgICAgLy8gU2VsZWN0IG5vIGVsZW1lbnRzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkoYXV0b1NlbGVjdCkpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChhdXRvU2VsZWN0KTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gU2VsZWN0IGFsbCBlbGVtZW50cyBieSBkZWZhdWx0XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoZWxlbWVudHMuZmlsdGVyKGlzU2hvd24pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIFNlbGVjdCBjb25uZWN0aW9uIHRhcmdldHMgb24gY29ubmVjdFxuICBldmVudEJ1cy5vbignY29ubmVjdC5lbmQnLCA1MDAsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgICBjYW5FeGVjdXRlID0gY29udGV4dC5jYW5FeGVjdXRlLFxuICAgICAgICBob3ZlciA9IGNvbnRleHQuaG92ZXI7XG5cbiAgICBpZiAoY2FuRXhlY3V0ZSAmJiBob3Zlcikge1xuICAgICAgc2VsZWN0aW9uLnNlbGVjdChob3Zlcik7XG4gICAgfVxuICB9KTtcblxuICAvLyBTZWxlY3Qgc2hhcGVzIG9uIG1vdmVcbiAgZXZlbnRCdXMub24oJ3NoYXBlLm1vdmUuZW5kJywgNTAwLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBwcmV2aW91c1NlbGVjdGlvbiA9IGV2ZW50LnByZXZpb3VzU2VsZWN0aW9uIHx8IFtdO1xuXG4gICAgdmFyIHNoYXBlID0gZWxlbWVudFJlZ2lzdHJ5LmdldChldmVudC5jb250ZXh0LnNoYXBlLmlkKTtcblxuICAgIC8vIEFsd2F5cyBzZWxlY3QgbWFpbiBzaGFwZSBvbiBtb3ZlXG4gICAgdmFyIGlzU2VsZWN0ZWQgPSBmaW5kKHByZXZpb3VzU2VsZWN0aW9uLCBmdW5jdGlvbihzZWxlY3RlZFNoYXBlKSB7XG4gICAgICByZXR1cm4gc2hhcGUuaWQgPT09IHNlbGVjdGVkU2hhcGUuaWQ7XG4gICAgfSk7XG5cbiAgICBpZiAoIWlzU2VsZWN0ZWQpIHtcbiAgICAgIHNlbGVjdGlvbi5zZWxlY3Qoc2hhcGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU2VsZWN0IGVsZW1lbnRzIG9uIGNsaWNrXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50LmNsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIGlmICghaXNQcmltYXJ5QnV0dG9uKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudDtcblxuICAgIGlmIChlbGVtZW50ID09PSBjYW52YXMuZ2V0Um9vdEVsZW1lbnQoKSkge1xuICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGlzU2VsZWN0ZWQgPSBzZWxlY3Rpb24uaXNTZWxlY3RlZChlbGVtZW50KSxcbiAgICAgICAgaXNNdWx0aVNlbGVjdCA9IHNlbGVjdGlvbi5nZXQoKS5sZW5ndGggPiAxO1xuXG4gICAgLy8gQWRkIHRvIHNlbGVjdGlvbiBpZiBDVFJMIG9yIFNISUZUIHByZXNzZWRcbiAgICB2YXIgYWRkID0gaGFzUHJpbWFyeU1vZGlmaWVyKGV2ZW50KSB8fCBoYXNTZWNvbmRhcnlNb2RpZmllcihldmVudCk7XG5cbiAgICBpZiAoaXNTZWxlY3RlZCAmJiBpc011bHRpU2VsZWN0KSB7XG4gICAgICBpZiAoYWRkKSB7XG5cbiAgICAgICAgLy8gRGVzZWxlY3QgZWxlbWVudFxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmRlc2VsZWN0KGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBTZWxlY3QgZWxlbWVudCBvbmx5XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb24uc2VsZWN0KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU2VsZWN0ZWQpIHtcblxuICAgICAgLy8gU2VsZWN0IGVsZW1lbnRcbiAgICAgIHNlbGVjdGlvbi5zZWxlY3QoZWxlbWVudCwgYWRkKTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBEZXNlbGVjdCBlbGVtZW50XG4gICAgICBzZWxlY3Rpb24uZGVzZWxlY3QoZWxlbWVudCk7XG4gICAgfVxuICB9KTtcbn1cblxuU2VsZWN0aW9uQmVoYXZpb3IuJGluamVjdCA9IFtcbiAgJ2V2ZW50QnVzJyxcbiAgJ3NlbGVjdGlvbicsXG4gICdjYW52YXMnLFxuICAnZWxlbWVudFJlZ2lzdHJ5J1xuXTtcblxuXG5mdW5jdGlvbiBpc1Nob3duKGVsZW1lbnQpIHtcbiAgcmV0dXJuICFlbGVtZW50LmhpZGRlbjtcbn1cbiIsImltcG9ydCB7XG4gIGZvckVhY2hcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG52YXIgTUFSS0VSX0hPVkVSID0gJ2hvdmVyJyxcbiAgICBNQVJLRVJfU0VMRUNURUQgPSAnc2VsZWN0ZWQnO1xuXG5cbi8qKlxuICogQSBwbHVnaW4gdGhhdCBhZGRzIGEgdmlzaWJsZSBzZWxlY3Rpb24gVUkgdG8gc2hhcGVzIGFuZCBjb25uZWN0aW9uc1xuICogYnkgYXBwZW5kaW5nIHRoZSA8Y29kZT5ob3ZlcjwvY29kZT4gYW5kIDxjb2RlPnNlbGVjdGVkPC9jb2RlPiBjbGFzc2VzIHRvIHRoZW0uXG4gKlxuICogQGNsYXNzXG4gKlxuICogTWFrZXMgZWxlbWVudHMgc2VsZWN0YWJsZSwgdG9vLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50c1xuICogQHBhcmFtIHtTZWxlY3Rpb25TZXJ2aWNlfSBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2VsZWN0aW9uVmlzdWFscyhldmVudHMsIGNhbnZhcywgc2VsZWN0aW9uLCBzdHlsZXMpIHtcblxuICB0aGlzLl9tdWx0aVNlbGVjdGlvbkJveCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYWRkTWFya2VyKGUsIGNscykge1xuICAgIGNhbnZhcy5hZGRNYXJrZXIoZSwgY2xzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU1hcmtlcihlLCBjbHMpIHtcbiAgICBjYW52YXMucmVtb3ZlTWFya2VyKGUsIGNscyk7XG4gIH1cblxuICBldmVudHMub24oJ2VsZW1lbnQuaG92ZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgIGFkZE1hcmtlcihldmVudC5lbGVtZW50LCBNQVJLRVJfSE9WRVIpO1xuICB9KTtcblxuICBldmVudHMub24oJ2VsZW1lbnQub3V0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZW1vdmVNYXJrZXIoZXZlbnQuZWxlbWVudCwgTUFSS0VSX0hPVkVSKTtcbiAgfSk7XG5cbiAgZXZlbnRzLm9uKCdzZWxlY3Rpb24uY2hhbmdlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICBmdW5jdGlvbiBkZXNlbGVjdChzKSB7XG4gICAgICByZW1vdmVNYXJrZXIocywgTUFSS0VSX1NFTEVDVEVEKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3Qocykge1xuICAgICAgYWRkTWFya2VyKHMsIE1BUktFUl9TRUxFQ1RFRCk7XG4gICAgfVxuXG4gICAgdmFyIG9sZFNlbGVjdGlvbiA9IGV2ZW50Lm9sZFNlbGVjdGlvbixcbiAgICAgICAgbmV3U2VsZWN0aW9uID0gZXZlbnQubmV3U2VsZWN0aW9uO1xuXG4gICAgZm9yRWFjaChvbGRTZWxlY3Rpb24sIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChuZXdTZWxlY3Rpb24uaW5kZXhPZihlKSA9PT0gLTEpIHtcbiAgICAgICAgZGVzZWxlY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3JFYWNoKG5ld1NlbGVjdGlvbiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKG9sZFNlbGVjdGlvbi5pbmRleE9mKGUpID09PSAtMSkge1xuICAgICAgICBzZWxlY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5TZWxlY3Rpb25WaXN1YWxzLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnLFxuICAnc2VsZWN0aW9uJyxcbiAgJ3N0eWxlcydcbl07IiwiaW1wb3J0IEludGVyYWN0aW9uRXZlbnRzTW9kdWxlIGZyb20gJy4uL2ludGVyYWN0aW9uLWV2ZW50cyc7XG5pbXBvcnQgT3V0bGluZU1vZHVsZSBmcm9tICcuLi9vdXRsaW5lJztcblxuaW1wb3J0IFNlbGVjdGlvbiBmcm9tICcuL1NlbGVjdGlvbic7XG5pbXBvcnQgU2VsZWN0aW9uVmlzdWFscyBmcm9tICcuL1NlbGVjdGlvblZpc3VhbHMnO1xuaW1wb3J0IFNlbGVjdGlvbkJlaGF2aW9yIGZyb20gJy4vU2VsZWN0aW9uQmVoYXZpb3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ3NlbGVjdGlvblZpc3VhbHMnLCAnc2VsZWN0aW9uQmVoYXZpb3InIF0sXG4gIF9fZGVwZW5kc19fOiBbXG4gICAgSW50ZXJhY3Rpb25FdmVudHNNb2R1bGUsXG4gICAgT3V0bGluZU1vZHVsZVxuICBdLFxuICBzZWxlY3Rpb246IFsgJ3R5cGUnLCBTZWxlY3Rpb24gXSxcbiAgc2VsZWN0aW9uVmlzdWFsczogWyAndHlwZScsIFNlbGVjdGlvblZpc3VhbHMgXSxcbiAgc2VsZWN0aW9uQmVoYXZpb3I6IFsgJ3R5cGUnLCBTZWxlY3Rpb25CZWhhdmlvciBdXG59O1xuIiwiaW1wb3J0IFNuYXBDb250ZXh0IGZyb20gJy4vU25hcENvbnRleHQnO1xyXG5cclxuaW1wb3J0IHtcclxuICBnZXRDaGlsZHJlbixcclxuICBpc1NuYXBwZWQsXHJcbiAgbWlkXHJcbn0gZnJvbSAnLi9TbmFwVXRpbCc7XHJcblxyXG5pbXBvcnQgeyBpc0NtZCB9IGZyb20gJy4uL2tleWJvYXJkL0tleWJvYXJkVXRpbCc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGZvckVhY2gsXHJcbiAgaXNOdW1iZXJcclxufSBmcm9tICdtaW4tZGFzaCc7XHJcblxyXG52YXIgSElHSEVSX1BSSU9SSVRZID0gMTI1MDtcclxuXHJcblxyXG4vKipcclxuICogU25hcCBkdXJpbmcgY3JlYXRlIGFuZCBtb3ZlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBlbGVtZW50UmVnaXN0cnlcclxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcclxuICogQHBhcmFtIHtTbmFwcGluZ30gc25hcHBpbmdcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENyZWF0ZU1vdmVTbmFwcGluZyhlbGVtZW50UmVnaXN0cnksIGV2ZW50QnVzLCBzbmFwcGluZykge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgdGhpcy5fZWxlbWVudFJlZ2lzdHJ5ID0gZWxlbWVudFJlZ2lzdHJ5O1xyXG5cclxuICBldmVudEJ1cy5vbihbXHJcbiAgICAnY3JlYXRlLnN0YXJ0JyxcclxuICAgICdzaGFwZS5tb3ZlLnN0YXJ0J1xyXG4gIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICBzZWxmLmluaXRTbmFwKGV2ZW50KTtcclxuICB9KTtcclxuXHJcbiAgZXZlbnRCdXMub24oW1xyXG4gICAgJ2NyZWF0ZS5tb3ZlJyxcclxuICAgICdjcmVhdGUuZW5kJyxcclxuICAgICdzaGFwZS5tb3ZlLm1vdmUnLFxyXG4gICAgJ3NoYXBlLm1vdmUuZW5kJ1xyXG4gIF0sIEhJR0hFUl9QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcclxuICAgICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGUsXHJcbiAgICAgICAgc25hcENvbnRleHQgPSBjb250ZXh0LnNuYXBDb250ZXh0LFxyXG4gICAgICAgIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0O1xyXG5cclxuICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50ICYmIGlzQ21kKGV2ZW50Lm9yaWdpbmFsRXZlbnQpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNTbmFwcGVkKGV2ZW50KSB8fCAhdGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc25hcFBvaW50cyA9IHNuYXBDb250ZXh0LnBvaW50c0ZvclRhcmdldCh0YXJnZXQpO1xyXG5cclxuICAgIGlmICghc25hcFBvaW50cy5pbml0aWFsaXplZCkge1xyXG4gICAgICBzbmFwUG9pbnRzID0gc2VsZi5hZGRTbmFwVGFyZ2V0UG9pbnRzKHNuYXBQb2ludHMsIHNoYXBlLCB0YXJnZXQpO1xyXG5cclxuICAgICAgc25hcFBvaW50cy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgc25hcHBpbmcuc25hcChldmVudCwgc25hcFBvaW50cyk7XHJcbiAgfSk7XHJcblxyXG4gIGV2ZW50QnVzLm9uKFtcclxuICAgICdjcmVhdGUuY2xlYW51cCcsXHJcbiAgICAnc2hhcGUubW92ZS5jbGVhbnVwJ1xyXG4gIF0sIGZ1bmN0aW9uKCkge1xyXG4gICAgc25hcHBpbmcuaGlkZSgpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5DcmVhdGVNb3ZlU25hcHBpbmcuJGluamVjdCA9IFtcclxuICAnZWxlbWVudFJlZ2lzdHJ5JyxcclxuICAnZXZlbnRCdXMnLFxyXG4gICdzbmFwcGluZydcclxuXTtcclxuXHJcbkNyZWF0ZU1vdmVTbmFwcGluZy5wcm90b3R5cGUuaW5pdFNuYXAgPSBmdW5jdGlvbihldmVudCkge1xyXG4gIHZhciBlbGVtZW50UmVnaXN0cnkgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnk7XHJcblxyXG4gIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcclxuICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxyXG4gICAgICBzbmFwQ29udGV4dCA9IGNvbnRleHQuc25hcENvbnRleHQ7XHJcblxyXG4gIGlmICghc25hcENvbnRleHQpIHtcclxuICAgIHNuYXBDb250ZXh0ID0gY29udGV4dC5zbmFwQ29udGV4dCA9IG5ldyBTbmFwQ29udGV4dCgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHNoYXBlTWlkO1xyXG5cclxuICBpZiAoZWxlbWVudFJlZ2lzdHJ5LmdldChzaGFwZS5pZCkpIHtcclxuXHJcbiAgICAvLyBtb3ZlXHJcbiAgICBzaGFwZU1pZCA9IG1pZChzaGFwZSwgZXZlbnQpO1xyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgLy8gY3JlYXRlXHJcbiAgICBzaGFwZU1pZCA9IHtcclxuICAgICAgeDogZXZlbnQueCArIG1pZChzaGFwZSkueCxcclxuICAgICAgeTogZXZlbnQueSArIG1pZChzaGFwZSkueVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHZhciBzaGFwZVRvcExlZnQgPSB7XHJcbiAgICAgICAgeDogc2hhcGVNaWQueCAtIHNoYXBlLndpZHRoIC8gMixcclxuICAgICAgICB5OiBzaGFwZU1pZC55IC0gc2hhcGUuaGVpZ2h0IC8gMlxyXG4gICAgICB9LFxyXG4gICAgICBzaGFwZUJvdHRvbVJpZ2h0ID0ge1xyXG4gICAgICAgIHg6IHNoYXBlTWlkLnggKyBzaGFwZS53aWR0aCAvIDIsXHJcbiAgICAgICAgeTogc2hhcGVNaWQueSArIHNoYXBlLmhlaWdodCAvIDJcclxuICAgICAgfTtcclxuXHJcbiAgc25hcENvbnRleHQuc2V0U25hcE9yaWdpbignbWlkJywge1xyXG4gICAgeDogc2hhcGVNaWQueCAtIGV2ZW50LngsXHJcbiAgICB5OiBzaGFwZU1pZC55IC0gZXZlbnQueVxyXG4gIH0pO1xyXG5cclxuICAvLyBzbmFwIGxhYmVscyB0byBtaWQgb25seVxyXG4gIGlmIChpc0xhYmVsKHNoYXBlKSkge1xyXG4gICAgcmV0dXJuIHNuYXBDb250ZXh0O1xyXG4gIH1cclxuXHJcbiAgc25hcENvbnRleHQuc2V0U25hcE9yaWdpbigndG9wLWxlZnQnLCB7XHJcbiAgICB4OiBzaGFwZVRvcExlZnQueCAtIGV2ZW50LngsXHJcbiAgICB5OiBzaGFwZVRvcExlZnQueSAtIGV2ZW50LnlcclxuICB9KTtcclxuXHJcbiAgc25hcENvbnRleHQuc2V0U25hcE9yaWdpbignYm90dG9tLXJpZ2h0Jywge1xyXG4gICAgeDogc2hhcGVCb3R0b21SaWdodC54IC0gZXZlbnQueCxcclxuICAgIHk6IHNoYXBlQm90dG9tUmlnaHQueSAtIGV2ZW50LnlcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHNuYXBDb250ZXh0O1xyXG59O1xyXG5cclxuQ3JlYXRlTW92ZVNuYXBwaW5nLnByb3RvdHlwZS5hZGRTbmFwVGFyZ2V0UG9pbnRzID0gZnVuY3Rpb24oc25hcFBvaW50cywgc2hhcGUsIHRhcmdldCkge1xyXG4gIHZhciBzbmFwVGFyZ2V0cyA9IHRoaXMuZ2V0U25hcFRhcmdldHMoc2hhcGUsIHRhcmdldCk7XHJcblxyXG4gIGZvckVhY2goc25hcFRhcmdldHMsIGZ1bmN0aW9uKHNuYXBUYXJnZXQpIHtcclxuXHJcbiAgICAvLyBoYW5kbGUgbGFiZWxzXHJcbiAgICBpZiAoaXNMYWJlbChzbmFwVGFyZ2V0KSkge1xyXG5cclxuICAgICAgaWYgKGlzTGFiZWwoc2hhcGUpKSB7XHJcbiAgICAgICAgc25hcFBvaW50cy5hZGQoJ21pZCcsIG1pZChzbmFwVGFyZ2V0KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBoYW5kbGUgY29ubmVjdGlvbnNcclxuICAgIGlmIChpc0Nvbm5lY3Rpb24oc25hcFRhcmdldCkpIHtcclxuXHJcbiAgICAgIC8vIGlnbm9yZSBzaW5nbGUgc2VnbWVudCBjb25uZWN0aW9uc1xyXG4gICAgICBpZiAoc25hcFRhcmdldC53YXlwb2ludHMubGVuZ3RoIDwgMykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWdub3JlIGZpcnN0IGFuZCBsYXN0IHdheXBvaW50XHJcbiAgICAgIHZhciB3YXlwb2ludHMgPSBzbmFwVGFyZ2V0LndheXBvaW50cy5zbGljZSgxLCAtMSk7XHJcblxyXG4gICAgICBmb3JFYWNoKHdheXBvaW50cywgZnVuY3Rpb24od2F5cG9pbnQpIHtcclxuICAgICAgICBzbmFwUG9pbnRzLmFkZCgnbWlkJywgd2F5cG9pbnQpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBoYW5kbGUgc2hhcGVzXHJcbiAgICBzbmFwUG9pbnRzLmFkZCgnbWlkJywgbWlkKHNuYXBUYXJnZXQpKTtcclxuICB9KTtcclxuXHJcbiAgaWYgKCFpc051bWJlcihzaGFwZS54KSB8fCAhaXNOdW1iZXIoc2hhcGUueSkpIHtcclxuICAgIHJldHVybiBzbmFwUG9pbnRzO1xyXG4gIH1cclxuXHJcbiAgLy8gc25hcCB0byBvcmlnaW5hbCBwb3NpdGlvbiB3aGVuIG1vdmluZ1xyXG4gIGlmICh0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0KHNoYXBlLmlkKSkge1xyXG4gICAgc25hcFBvaW50cy5hZGQoJ21pZCcsIG1pZChzaGFwZSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNuYXBQb2ludHM7XHJcbn07XHJcblxyXG5DcmVhdGVNb3ZlU25hcHBpbmcucHJvdG90eXBlLmdldFNuYXBUYXJnZXRzID0gZnVuY3Rpb24oc2hhcGUsIHRhcmdldCkge1xyXG4gIHJldHVybiBnZXRDaGlsZHJlbih0YXJnZXQpLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgcmV0dXJuICFpc0hpZGRlbihjaGlsZCk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy9cclxuXHJcbmZ1bmN0aW9uIGlzQ29ubmVjdGlvbihlbGVtZW50KSB7XHJcbiAgcmV0dXJuICEhZWxlbWVudC53YXlwb2ludHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzSGlkZGVuKGVsZW1lbnQpIHtcclxuICByZXR1cm4gISFlbGVtZW50LmhpZGRlbjtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNMYWJlbChlbGVtZW50KSB7XHJcbiAgcmV0dXJuICEhZWxlbWVudC5sYWJlbFRhcmdldDtcclxufSIsImltcG9ydCBTbmFwQ29udGV4dCBmcm9tICcuL1NuYXBDb250ZXh0JztcclxuXHJcbmltcG9ydCB7XHJcbiAgYm90dG9tUmlnaHQsXHJcbiAgZ2V0Q2hpbGRyZW4sXHJcbiAgaXNTbmFwcGVkLFxyXG4gIHNldFNuYXBwZWQsXHJcbiAgdG9wTGVmdCxcclxufSBmcm9tICcuL1NuYXBVdGlsJztcclxuXHJcbmltcG9ydCB7IGlzQ21kIH0gZnJvbSAnLi4va2V5Ym9hcmQvS2V5Ym9hcmRVdGlsJztcclxuXHJcbmltcG9ydCB7XHJcbiAgYXNUUkJMLFxyXG4gIGdldE1pZFxyXG59IGZyb20gJy4uLy4uL2xheW91dC9MYXlvdXRVdGlsJztcclxuXHJcbmltcG9ydCB7IGZvckVhY2ggfSBmcm9tICdtaW4tZGFzaCc7XHJcblxyXG52YXIgSElHSEVSX1BSSU9SSVRZID0gMTI1MDtcclxuXHJcblxyXG4vKipcclxuICogU25hcCBkdXJpbmcgcmVzaXplLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xyXG4gKiBAcGFyYW0ge1NuYXBwaW5nfSBzbmFwcGluZ1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmVzaXplU25hcHBpbmcoZXZlbnRCdXMsIHNuYXBwaW5nKSB7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICBldmVudEJ1cy5vbihbICdyZXNpemUuc3RhcnQnIF0sIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICBzZWxmLmluaXRTbmFwKGV2ZW50KTtcclxuICB9KTtcclxuXHJcbiAgZXZlbnRCdXMub24oW1xyXG4gICAgJ3Jlc2l6ZS5tb3ZlJyxcclxuICAgICdyZXNpemUuZW5kJyxcclxuICBdLCBISUdIRVJfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXHJcbiAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlLFxyXG4gICAgICAgIHBhcmVudCA9IHNoYXBlLnBhcmVudCxcclxuICAgICAgICBkaXJlY3Rpb24gPSBjb250ZXh0LmRpcmVjdGlvbixcclxuICAgICAgICBzbmFwQ29udGV4dCA9IGNvbnRleHQuc25hcENvbnRleHQ7XHJcblxyXG4gICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgaXNDbWQoZXZlbnQub3JpZ2luYWxFdmVudCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1NuYXBwZWQoZXZlbnQpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc25hcFBvaW50cyA9IHNuYXBDb250ZXh0LnBvaW50c0ZvclRhcmdldChwYXJlbnQpO1xyXG5cclxuICAgIGlmICghc25hcFBvaW50cy5pbml0aWFsaXplZCkge1xyXG4gICAgICBzbmFwUG9pbnRzID0gc2VsZi5hZGRTbmFwVGFyZ2V0UG9pbnRzKHNuYXBQb2ludHMsIHNoYXBlLCBwYXJlbnQsIGRpcmVjdGlvbik7XHJcblxyXG4gICAgICBzbmFwUG9pbnRzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNIb3Jpem9udGFsKGRpcmVjdGlvbikpIHtcclxuICAgICAgc2V0U25hcHBlZChldmVudCwgJ3gnLCBldmVudC54KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNWZXJ0aWNhbChkaXJlY3Rpb24pKSB7XHJcbiAgICAgIHNldFNuYXBwZWQoZXZlbnQsICd5JywgZXZlbnQueSk7XHJcbiAgICB9XHJcblxyXG4gICAgc25hcHBpbmcuc25hcChldmVudCwgc25hcFBvaW50cyk7XHJcbiAgfSk7XHJcblxyXG4gIGV2ZW50QnVzLm9uKFsgJ3Jlc2l6ZS5jbGVhbnVwJyBdLCBmdW5jdGlvbigpIHtcclxuICAgIHNuYXBwaW5nLmhpZGUoKTtcclxuICB9KTtcclxufVxyXG5cclxuUmVzaXplU25hcHBpbmcucHJvdG90eXBlLmluaXRTbmFwID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXHJcbiAgICAgIHNoYXBlID0gY29udGV4dC5zaGFwZSxcclxuICAgICAgZGlyZWN0aW9uID0gY29udGV4dC5kaXJlY3Rpb24sXHJcbiAgICAgIHNuYXBDb250ZXh0ID0gY29udGV4dC5zbmFwQ29udGV4dDtcclxuXHJcbiAgaWYgKCFzbmFwQ29udGV4dCkge1xyXG4gICAgc25hcENvbnRleHQgPSBjb250ZXh0LnNuYXBDb250ZXh0ID0gbmV3IFNuYXBDb250ZXh0KCk7XHJcbiAgfVxyXG5cclxuICB2YXIgc25hcE9yaWdpbiA9IGdldFNuYXBPcmlnaW4oc2hhcGUsIGRpcmVjdGlvbik7XHJcblxyXG4gIHNuYXBDb250ZXh0LnNldFNuYXBPcmlnaW4oJ2Nvcm5lcicsIHtcclxuICAgIHg6IHNuYXBPcmlnaW4ueCAtIGV2ZW50LngsXHJcbiAgICB5OiBzbmFwT3JpZ2luLnkgLSBldmVudC55XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBzbmFwQ29udGV4dDtcclxufTtcclxuXHJcblJlc2l6ZVNuYXBwaW5nLnByb3RvdHlwZS5hZGRTbmFwVGFyZ2V0UG9pbnRzID0gZnVuY3Rpb24oc25hcFBvaW50cywgc2hhcGUsIHRhcmdldCwgZGlyZWN0aW9uKSB7XHJcbiAgdmFyIHNuYXBUYXJnZXRzID0gdGhpcy5nZXRTbmFwVGFyZ2V0cyhzaGFwZSwgdGFyZ2V0KTtcclxuXHJcbiAgZm9yRWFjaChzbmFwVGFyZ2V0cywgZnVuY3Rpb24oc25hcFRhcmdldCkge1xyXG4gICAgc25hcFBvaW50cy5hZGQoJ2Nvcm5lcicsIGJvdHRvbVJpZ2h0KHNuYXBUYXJnZXQpKTtcclxuICAgIHNuYXBQb2ludHMuYWRkKCdjb3JuZXInLCB0b3BMZWZ0KHNuYXBUYXJnZXQpKTtcclxuICB9KTtcclxuXHJcbiAgc25hcFBvaW50cy5hZGQoJ2Nvcm5lcicsIGdldFNuYXBPcmlnaW4oc2hhcGUsIGRpcmVjdGlvbikpO1xyXG5cclxuICByZXR1cm4gc25hcFBvaW50cztcclxufTtcclxuXHJcblJlc2l6ZVNuYXBwaW5nLiRpbmplY3QgPSBbXHJcbiAgJ2V2ZW50QnVzJyxcclxuICAnc25hcHBpbmcnXHJcbl07XHJcblxyXG5SZXNpemVTbmFwcGluZy5wcm90b3R5cGUuZ2V0U25hcFRhcmdldHMgPSBmdW5jdGlvbihzaGFwZSwgdGFyZ2V0KSB7XHJcbiAgcmV0dXJuIGdldENoaWxkcmVuKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICByZXR1cm4gIWlzQXR0YWNoZWQoY2hpbGQsIHNoYXBlKVxyXG4gICAgICAmJiAhaXNDb25uZWN0aW9uKGNoaWxkKVxyXG4gICAgICAmJiAhaXNIaWRkZW4oY2hpbGQpXHJcbiAgICAgICYmICFpc0xhYmVsKGNoaWxkKTtcclxuICB9KTtcclxufTtcclxuXHJcbi8vIGhlbHBlcnMgLy8vLy8vLy8vL1xyXG5cclxuZnVuY3Rpb24gZ2V0U25hcE9yaWdpbihzaGFwZSwgZGlyZWN0aW9uKSB7XHJcbiAgdmFyIG1pZCA9IGdldE1pZChzaGFwZSksXHJcbiAgICAgIHRyYmwgPSBhc1RSQkwoc2hhcGUpO1xyXG5cclxuICB2YXIgc25hcE9yaWdpbiA9IHtcclxuICAgIHg6IG1pZC54LFxyXG4gICAgeTogbWlkLnlcclxuICB9O1xyXG5cclxuICBpZiAoZGlyZWN0aW9uLmluZGV4T2YoJ24nKSAhPT0gLTEpIHtcclxuICAgIHNuYXBPcmlnaW4ueSA9IHRyYmwudG9wO1xyXG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uLmluZGV4T2YoJ3MnKSAhPT0gLTEpIHtcclxuICAgIHNuYXBPcmlnaW4ueSA9IHRyYmwuYm90dG9tO1xyXG4gIH1cclxuXHJcbiAgaWYgKGRpcmVjdGlvbi5pbmRleE9mKCdlJykgIT09IC0xKSB7XHJcbiAgICBzbmFwT3JpZ2luLnggPSB0cmJsLnJpZ2h0O1xyXG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uLmluZGV4T2YoJ3cnKSAhPT0gLTEpIHtcclxuICAgIHNuYXBPcmlnaW4ueCA9IHRyYmwubGVmdDtcclxuICB9XHJcblxyXG4gIHJldHVybiBzbmFwT3JpZ2luO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0F0dGFjaGVkKGVsZW1lbnQsIGhvc3QpIHtcclxuICByZXR1cm4gZWxlbWVudC5ob3N0ID09PSBob3N0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0Nvbm5lY3Rpb24oZWxlbWVudCkge1xyXG4gIHJldHVybiAhIWVsZW1lbnQud2F5cG9pbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0hpZGRlbihlbGVtZW50KSB7XHJcbiAgcmV0dXJuICEhZWxlbWVudC5oaWRkZW47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTGFiZWwoZWxlbWVudCkge1xyXG4gIHJldHVybiAhIWVsZW1lbnQubGFiZWxUYXJnZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzSG9yaXpvbnRhbChkaXJlY3Rpb24pIHtcclxuICByZXR1cm4gZGlyZWN0aW9uID09PSAnbicgfHwgZGlyZWN0aW9uID09PSAncyc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmVydGljYWwoZGlyZWN0aW9uKSB7XHJcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2UnIHx8IGRpcmVjdGlvbiA9PT0gJ3cnO1xyXG59IiwiaW1wb3J0IHtcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIHNuYXBUb1xufSBmcm9tICcuL1NuYXBVdGlsJztcblxuXG4vKipcbiAqIEEgc25hcCBjb250ZXh0LCBjb250YWluaW5nIHRoZSAocG9zc2libHkgaW5jb21wbGV0ZSlcbiAqIG1hcHBpbmdzIG9mIGRyb3AgdGFyZ2V0cyAodG8gaWRlbnRpZnkgdGhlIHNuYXBwaW5nKVxuICogdG8gY29tcHV0ZWQgc25hcCBwb2ludHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNuYXBDb250ZXh0KCkge1xuXG4gIC8qKlxuICAgKiBNYXA8U3RyaW5nLCBTbmFwUG9pbnRzPiBtYXBwaW5nIGRyb3AgdGFyZ2V0cyB0b1xuICAgKiBhIGxpc3Qgb2YgcG9zc2libGUgc25hcHBpbmdzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5fdGFyZ2V0cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBNYXA8U3RyaW5nLCBQb2ludD4gaW5pdGlhbCBwb3NpdGlvbmluZyBvZiBlbGVtZW50XG4gICAqIHJlZ2FyZGluZyB2YXJpb3VzIHNuYXAgZGlyZWN0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuX3NuYXBPcmlnaW5zID0ge307XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygc25hcCBsb2NhdGlvbnNcbiAgICpcbiAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAqL1xuICB0aGlzLl9zbmFwTG9jYXRpb25zID0gW107XG5cbiAgLyoqXG4gICAqIE1hcDxTdHJpbmcsIEFycmF5PFBvaW50Pj4gb2YgZGVmYXVsdCBzbmFwcGluZyBsb2NhdGlvbnNcbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuX2RlZmF1bHRTbmFwcyA9IHt9O1xufVxuXG5cblNuYXBDb250ZXh0LnByb3RvdHlwZS5nZXRTbmFwT3JpZ2luID0gZnVuY3Rpb24oc25hcExvY2F0aW9uKSB7XG4gIHJldHVybiB0aGlzLl9zbmFwT3JpZ2luc1tzbmFwTG9jYXRpb25dO1xufTtcblxuXG5TbmFwQ29udGV4dC5wcm90b3R5cGUuc2V0U25hcE9yaWdpbiA9IGZ1bmN0aW9uKHNuYXBMb2NhdGlvbiwgaW5pdGlhbFZhbHVlKSB7XG4gIHRoaXMuX3NuYXBPcmlnaW5zW3NuYXBMb2NhdGlvbl0gPSBpbml0aWFsVmFsdWU7XG5cbiAgaWYgKHRoaXMuX3NuYXBMb2NhdGlvbnMuaW5kZXhPZihzbmFwTG9jYXRpb24pID09PSAtMSkge1xuICAgIHRoaXMuX3NuYXBMb2NhdGlvbnMucHVzaChzbmFwTG9jYXRpb24pO1xuICB9XG59O1xuXG5cblNuYXBDb250ZXh0LnByb3RvdHlwZS5hZGREZWZhdWx0U25hcCA9IGZ1bmN0aW9uKHR5cGUsIHBvaW50KSB7XG5cbiAgdmFyIHNuYXBWYWx1ZXMgPSB0aGlzLl9kZWZhdWx0U25hcHNbdHlwZV07XG5cbiAgaWYgKCFzbmFwVmFsdWVzKSB7XG4gICAgc25hcFZhbHVlcyA9IHRoaXMuX2RlZmF1bHRTbmFwc1t0eXBlXSA9IFtdO1xuICB9XG5cbiAgc25hcFZhbHVlcy5wdXNoKHBvaW50KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgbnVtYmVyIG9mIGluaXRpYWxpemVkIHNuYXBzLCBpLmUuIHNuYXAgbG9jYXRpb25zIHN1Y2ggYXNcbiAqIHRvcC1sZWZ0LCBtaWQsIGJvdHRvbS1yaWdodCBhbmQgc28gZm9ydGguXG4gKlxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gc25hcExvY2F0aW9uc1xuICovXG5TbmFwQ29udGV4dC5wcm90b3R5cGUuZ2V0U25hcExvY2F0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc25hcExvY2F0aW9ucztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzbmFwIGxvY2F0aW9ucyBmb3IgdGhpcyBjb250ZXh0LlxuICpcbiAqIFRoZSBvcmRlciBvZiBsb2NhdGlvbnMgZGV0ZXJtaW5lcyBwcmVjZWRlbmNlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc25hcExvY2F0aW9uc1xuICovXG5TbmFwQ29udGV4dC5wcm90b3R5cGUuc2V0U25hcExvY2F0aW9ucyA9IGZ1bmN0aW9uKHNuYXBMb2NhdGlvbnMpIHtcbiAgdGhpcy5fc25hcExvY2F0aW9ucyA9IHNuYXBMb2NhdGlvbnM7XG59O1xuXG4vKipcbiAqIEdldCBzbmFwIHBvaW50cyBmb3IgYSBnaXZlbiB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSB0YXJnZXRcbiAqL1xuU25hcENvbnRleHQucHJvdG90eXBlLnBvaW50c0ZvclRhcmdldCA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXG4gIHZhciB0YXJnZXRJZCA9IHRhcmdldC5pZCB8fCB0YXJnZXQ7XG5cbiAgdmFyIHNuYXBQb2ludHMgPSB0aGlzLl90YXJnZXRzW3RhcmdldElkXTtcblxuICBpZiAoIXNuYXBQb2ludHMpIHtcbiAgICBzbmFwUG9pbnRzID0gdGhpcy5fdGFyZ2V0c1t0YXJnZXRJZF0gPSBuZXcgU25hcFBvaW50cygpO1xuICAgIHNuYXBQb2ludHMuaW5pdERlZmF1bHRzKHRoaXMuX2RlZmF1bHRTbmFwcyk7XG4gIH1cblxuICByZXR1cm4gc25hcFBvaW50cztcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBzbmFwIHBvaW50cyBhbmQgaW5pdGlhbGl6ZXMgdGhlbSB3aXRoIHRoZVxuICogZ2l2ZW4gZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxQb2ludD4+fSBbZGVmYXVsdFBvaW50c11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNuYXBQb2ludHMoZGVmYXVsdFNuYXBzKSB7XG5cbiAgLyoqXG4gICAqIE1hcDxTdHJpbmcsIE1hcDwoeHx5KSwgQXJyYXk8bnVtYmVyPj4+IG1hcHBpbmcgc25hcCBsb2NhdGlvbnMsXG4gICAqIGkuZS4gdG9wLWxlZnQsIGJvdHRvbS1yaWdodCwgY2VudGVyIHRvIGFjdHVhbCBzbmFwIHZhbHVlcy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuX3NuYXBWYWx1ZXMgPSB7fTtcbn1cblxuU25hcFBvaW50cy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oc25hcExvY2F0aW9uLCBwb2ludCkge1xuXG4gIHZhciBzbmFwVmFsdWVzID0gdGhpcy5fc25hcFZhbHVlc1tzbmFwTG9jYXRpb25dO1xuXG4gIGlmICghc25hcFZhbHVlcykge1xuICAgIHNuYXBWYWx1ZXMgPSB0aGlzLl9zbmFwVmFsdWVzW3NuYXBMb2NhdGlvbl0gPSB7IHg6IFtdLCB5OiBbXSB9O1xuICB9XG5cbiAgaWYgKHNuYXBWYWx1ZXMueC5pbmRleE9mKHBvaW50LngpID09PSAtMSkge1xuICAgIHNuYXBWYWx1ZXMueC5wdXNoKHBvaW50LngpO1xuICB9XG5cbiAgaWYgKHNuYXBWYWx1ZXMueS5pbmRleE9mKHBvaW50LnkpID09PSAtMSkge1xuICAgIHNuYXBWYWx1ZXMueS5wdXNoKHBvaW50LnkpO1xuICB9XG59O1xuXG5cblNuYXBQb2ludHMucHJvdG90eXBlLnNuYXAgPSBmdW5jdGlvbihwb2ludCwgc25hcExvY2F0aW9uLCBheGlzLCB0b2xlcmFuY2UpIHtcbiAgdmFyIHNuYXBwaW5nVmFsdWVzID0gdGhpcy5fc25hcFZhbHVlc1tzbmFwTG9jYXRpb25dO1xuXG4gIHJldHVybiBzbmFwcGluZ1ZhbHVlcyAmJiBzbmFwVG8ocG9pbnRbYXhpc10sIHNuYXBwaW5nVmFsdWVzW2F4aXNdLCB0b2xlcmFuY2UpO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbnVtYmVyIG9mIGRlZmF1bHQgc25hcHBpbmcgcG9pbnRzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gZGVmYXVsdFNuYXBzXG4gKi9cblNuYXBQb2ludHMucHJvdG90eXBlLmluaXREZWZhdWx0cyA9IGZ1bmN0aW9uKGRlZmF1bHRTbmFwcykge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3JFYWNoKGRlZmF1bHRTbmFwcyB8fCB7fSwgZnVuY3Rpb24oc25hcFBvaW50cywgc25hcExvY2F0aW9uKSB7XG4gICAgZm9yRWFjaChzbmFwUG9pbnRzLCBmdW5jdGlvbihwb2ludCkge1xuICAgICAgc2VsZi5hZGQoc25hcExvY2F0aW9uLCBwb2ludCk7XG4gICAgfSk7XG4gIH0pO1xufTsiLCJ2YXIgYWJzID0gTWF0aC5hYnMsXG4gICAgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG5cbi8qKlxuICogU25hcCB2YWx1ZSB0byBhIGNvbGxlY3Rpb24gb2YgcmVmZXJlbmNlIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0gIHtBcnJheTxudW1iZXI+fSB2YWx1ZXNcbiAqIEBwYXJhbSAge251bWJlcn0gW3RvbGVyYW5jZT0xMF1cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSB2YWx1ZSB3ZSBzbmFwcGVkIHRvIG9yIG51bGwsIGlmIG5vbmUgc25hcHBlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc25hcFRvKHZhbHVlLCB2YWx1ZXMsIHRvbGVyYW5jZSkge1xuICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgPT09IHVuZGVmaW5lZCA/IDEwIDogdG9sZXJhbmNlO1xuXG4gIHZhciBpZHgsIHNuYXBWYWx1ZTtcblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IHZhbHVlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgc25hcFZhbHVlID0gdmFsdWVzW2lkeF07XG5cbiAgICBpZiAoYWJzKHNuYXBWYWx1ZSAtIHZhbHVlKSA8PSB0b2xlcmFuY2UpIHtcbiAgICAgIHJldHVybiBzbmFwVmFsdWU7XG4gICAgfVxuICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcExlZnQoYm91bmRzKSB7XG4gIHJldHVybiB7XG4gICAgeDogYm91bmRzLngsXG4gICAgeTogYm91bmRzLnlcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcFJpZ2h0KGJvdW5kcykge1xuICByZXR1cm4ge1xuICAgIHg6IGJvdW5kcy54ICsgYm91bmRzLndpZHRoLFxuICAgIHk6IGJvdW5kcy55XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3R0b21MZWZ0KGJvdW5kcykge1xuICByZXR1cm4ge1xuICAgIHg6IGJvdW5kcy54LFxuICAgIHk6IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm90dG9tUmlnaHQoYm91bmRzKSB7XG4gIHJldHVybiB7XG4gICAgeDogYm91bmRzLnggKyBib3VuZHMud2lkdGgsXG4gICAgeTogYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaWQoYm91bmRzLCBkZWZhdWx0VmFsdWUpIHtcblxuICBpZiAoIWJvdW5kcyB8fCBpc05hTihib3VuZHMueCkgfHwgaXNOYU4oYm91bmRzLnkpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoYm91bmRzLnggKyBib3VuZHMud2lkdGggLyAyKSxcbiAgICB5OiByb3VuZChib3VuZHMueSArIGJvdW5kcy5oZWlnaHQgLyAyKVxuICB9O1xufVxuXG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHNuYXAgc3RhdGUgb2YgdGhlIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSAge0V2ZW50fSBldmVudFxuICogQHBhcmFtICB7c3RyaW5nfSBheGlzXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHNuYXBwZWQgc3RhdGVcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NuYXBwZWQoZXZlbnQsIGF4aXMpIHtcbiAgdmFyIHNuYXBwZWQgPSBldmVudC5zbmFwcGVkO1xuXG4gIGlmICghc25hcHBlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXhpcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc25hcHBlZFtheGlzXTtcbiAgfVxuXG4gIHJldHVybiBzbmFwcGVkLnggJiYgc25hcHBlZC55O1xufVxuXG5cbi8qKlxuICogU2V0IHRoZSBnaXZlbiBldmVudCBhcyBzbmFwcGVkLlxuICpcbiAqIFRoaXMgbWV0aG9kIG1heSBjaGFuZ2UgdGhlIHggYW5kL29yIHkgcG9zaXRpb24gb2YgdGhlIHNoYXBlXG4gKiBmcm9tIHRoZSBnaXZlbiBldmVudCFcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXNcbiAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IHZhbHVlXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSBvbGQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFNuYXBwZWQoZXZlbnQsIGF4aXMsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgYXhpcyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4aXMgbXVzdCBiZSBpbiBbeCwgeV0nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBOdW1iZXIgb3IgZmFsc2UnKTtcbiAgfVxuXG4gIHZhciBkZWx0YSxcbiAgICAgIHByZXZpb3VzVmFsdWUgPSBldmVudFtheGlzXTtcblxuICB2YXIgc25hcHBlZCA9IGV2ZW50LnNuYXBwZWQgPSAoZXZlbnQuc25hcHBlZCB8fCB7fSk7XG5cblxuICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgc25hcHBlZFtheGlzXSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHNuYXBwZWRbYXhpc10gPSB0cnVlO1xuXG4gICAgZGVsdGEgPSB2YWx1ZSAtIHByZXZpb3VzVmFsdWU7XG5cbiAgICBldmVudFtheGlzXSArPSBkZWx0YTtcbiAgICBldmVudFsnZCcgKyBheGlzXSArPSBkZWx0YTtcbiAgfVxuXG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIEdldCBjaGlsZHJlbiBvZiBhIHNoYXBlLlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLlNoYXBlfSBwYXJlbnRcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8ZGpzLm1vZGVsLlNoYXBlfGRqcy5tb2RlbC5Db25uZWN0aW9uPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkcmVuKHBhcmVudCkge1xuICByZXR1cm4gcGFyZW50LmNoaWxkcmVuIHx8IFtdO1xufSIsImltcG9ydCB7XG4gIGJpbmQsXG4gIGRlYm91bmNlLFxuICBmb3JFYWNoLFxuICBpc051bWJlcixcbiAgaXNPYmplY3Rcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBpc1NuYXBwZWQsXG4gIHNldFNuYXBwZWRcbn0gZnJvbSAnLi9TbmFwVXRpbCc7XG5cbmltcG9ydCB7XG4gIGFwcGVuZCBhcyBzdmdBcHBlbmQsXG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY2xhc3NlcyBhcyBzdmdDbGFzc2VzLFxuICBjcmVhdGUgYXMgc3ZnQ3JlYXRlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxudmFyIFNOQVBfVE9MRVJBTkNFID0gNztcblxuZXhwb3J0IHZhciBTTkFQX0xJTkVfSElERV9ERUxBWSA9IDEwMDA7XG5cblxuLyoqXG4gKiBHZW5lcmljIHNuYXBwaW5nIGZlYXR1cmUuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU25hcHBpbmcoY2FudmFzKSB7XG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcblxuICAvLyBkZWxheSBoaWRlIGJ5IDEwMDAgc2Vjb25kcyBzaW5jZSBsYXN0IHNuYXBcbiAgdGhpcy5fYXN5bmNIaWRlID0gZGVib3VuY2UoYmluZCh0aGlzLmhpZGUsIHRoaXMpLCBTTkFQX0xJTkVfSElERV9ERUxBWSk7XG59XG5cblNuYXBwaW5nLiRpbmplY3QgPSBbICdjYW52YXMnIF07XG5cbi8qKlxuICogU25hcCBhbiBldmVudCB0byBnaXZlbiBzbmFwIHBvaW50cy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtTbmFwUG9pbnRzfSBzbmFwUG9pbnRzXG4gKi9cblNuYXBwaW5nLnByb3RvdHlwZS5zbmFwID0gZnVuY3Rpb24oZXZlbnQsIHNuYXBQb2ludHMpIHtcbiAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0LFxuICAgICAgc25hcENvbnRleHQgPSBjb250ZXh0LnNuYXBDb250ZXh0LFxuICAgICAgc25hcExvY2F0aW9ucyA9IHNuYXBDb250ZXh0LmdldFNuYXBMb2NhdGlvbnMoKTtcblxuICB2YXIgc25hcHBpbmcgPSB7XG4gICAgeDogaXNTbmFwcGVkKGV2ZW50LCAneCcpLFxuICAgIHk6IGlzU25hcHBlZChldmVudCwgJ3knKVxuICB9O1xuXG4gIGZvckVhY2goc25hcExvY2F0aW9ucywgZnVuY3Rpb24obG9jYXRpb24pIHtcbiAgICB2YXIgc25hcE9yaWdpbiA9IHNuYXBDb250ZXh0LmdldFNuYXBPcmlnaW4obG9jYXRpb24pO1xuXG4gICAgdmFyIHNuYXBDdXJyZW50ID0ge1xuICAgICAgeDogZXZlbnQueCArIHNuYXBPcmlnaW4ueCxcbiAgICAgIHk6IGV2ZW50LnkgKyBzbmFwT3JpZ2luLnlcbiAgICB9O1xuXG4gICAgLy8gc25hcCBib3RoIGF4aXMgaWYgbm90IHNuYXBwZWQgYWxyZWFkeVxuICAgIGZvckVhY2goWyAneCcsICd5JyBdLCBmdW5jdGlvbihheGlzKSB7XG4gICAgICB2YXIgbG9jYXRpb25TbmFwcGluZztcblxuICAgICAgaWYgKCFzbmFwcGluZ1theGlzXSkge1xuICAgICAgICBsb2NhdGlvblNuYXBwaW5nID0gc25hcFBvaW50cy5zbmFwKHNuYXBDdXJyZW50LCBsb2NhdGlvbiwgYXhpcywgU05BUF9UT0xFUkFOQ0UpO1xuXG4gICAgICAgIGlmIChsb2NhdGlvblNuYXBwaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzbmFwcGluZ1theGlzXSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBsb2NhdGlvblNuYXBwaW5nLFxuICAgICAgICAgICAgb3JpZ2luVmFsdWU6IGxvY2F0aW9uU25hcHBpbmcgLSBzbmFwT3JpZ2luW2F4aXNdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gbm8gbmVlZCB0byBjb250aW51ZSBzbmFwcGluZ1xuICAgIGlmIChzbmFwcGluZy54ICYmIHNuYXBwaW5nLnkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHNob3cgc25hcCBsaW5lc1xuICB0aGlzLnNob3dTbmFwTGluZSgndmVydGljYWwnLCBzbmFwcGluZy54ICYmIHNuYXBwaW5nLngudmFsdWUpO1xuICB0aGlzLnNob3dTbmFwTGluZSgnaG9yaXpvbnRhbCcsIHNuYXBwaW5nLnkgJiYgc25hcHBpbmcueS52YWx1ZSk7XG5cbiAgLy8gc25hcCBldmVudFxuICBmb3JFYWNoKFsgJ3gnLCAneScgXSwgZnVuY3Rpb24oYXhpcykge1xuICAgIHZhciBheGlzU25hcHBpbmcgPSBzbmFwcGluZ1theGlzXTtcblxuICAgIGlmIChpc09iamVjdChheGlzU25hcHBpbmcpKSB7XG4gICAgICBzZXRTbmFwcGVkKGV2ZW50LCBheGlzLCBheGlzU25hcHBpbmcub3JpZ2luVmFsdWUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5TbmFwcGluZy5wcm90b3R5cGUuX2NyZWF0ZUxpbmUgPSBmdW5jdGlvbihvcmllbnRhdGlvbikge1xuICB2YXIgcm9vdCA9IHRoaXMuX2NhbnZhcy5nZXRMYXllcignc25hcCcpO1xuXG4gIHZhciBsaW5lID0gc3ZnQ3JlYXRlKCdwYXRoJyk7XG5cbiAgc3ZnQXR0cihsaW5lLCB7IGQ6ICdNMCwwIEwwLDAnIH0pO1xuXG4gIHN2Z0NsYXNzZXMobGluZSkuYWRkKCdkanMtc25hcC1saW5lJyk7XG5cbiAgc3ZnQXBwZW5kKHJvb3QsIGxpbmUpO1xuXG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbihwb3NpdGlvbikge1xuXG4gICAgICBpZiAoIWlzTnVtYmVyKHBvc2l0aW9uKSkge1xuICAgICAgICBzdmdBdHRyKGxpbmUsIHsgZGlzcGxheTogJ25vbmUnIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICBzdmdBdHRyKGxpbmUsIHtcbiAgICAgICAgICAgIGQ6ICdNLTEwMDAwMCwnICsgcG9zaXRpb24gKyAnIEwrMTAwMDAwLCcgKyBwb3NpdGlvbixcbiAgICAgICAgICAgIGRpc3BsYXk6ICcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ZnQXR0cihsaW5lLCB7XG4gICAgICAgICAgICBkOiAnTSAnICsgcG9zaXRpb24gKyAnLC0xMDAwMDAgTCAnICsgcG9zaXRpb24gKyAnLCArMTAwMDAwJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5TbmFwcGluZy5wcm90b3R5cGUuX2NyZWF0ZVNuYXBMaW5lcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zbmFwTGluZXMgPSB7XG4gICAgaG9yaXpvbnRhbDogdGhpcy5fY3JlYXRlTGluZSgnaG9yaXpvbnRhbCcpLFxuICAgIHZlcnRpY2FsOiB0aGlzLl9jcmVhdGVMaW5lKCd2ZXJ0aWNhbCcpXG4gIH07XG59O1xuXG5TbmFwcGluZy5wcm90b3R5cGUuc2hvd1NuYXBMaW5lID0gZnVuY3Rpb24ob3JpZW50YXRpb24sIHBvc2l0aW9uKSB7XG5cbiAgdmFyIGxpbmUgPSB0aGlzLmdldFNuYXBMaW5lKG9yaWVudGF0aW9uKTtcblxuICBpZiAobGluZSkge1xuICAgIGxpbmUudXBkYXRlKHBvc2l0aW9uKTtcbiAgfVxuXG4gIHRoaXMuX2FzeW5jSGlkZSgpO1xufTtcblxuU25hcHBpbmcucHJvdG90eXBlLmdldFNuYXBMaW5lID0gZnVuY3Rpb24ob3JpZW50YXRpb24pIHtcbiAgaWYgKCF0aGlzLl9zbmFwTGluZXMpIHtcbiAgICB0aGlzLl9jcmVhdGVTbmFwTGluZXMoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9zbmFwTGluZXNbb3JpZW50YXRpb25dO1xufTtcblxuU25hcHBpbmcucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgZm9yRWFjaCh0aGlzLl9zbmFwTGluZXMsIGZ1bmN0aW9uKHNuYXBMaW5lKSB7XG4gICAgc25hcExpbmUudXBkYXRlKCk7XG4gIH0pO1xufTtcbiIsImltcG9ydCBDcmVhdGVNb3ZlU25hcHBpbmcgZnJvbSAnLi9DcmVhdGVNb3ZlU25hcHBpbmcnO1xuaW1wb3J0IFJlc2l6ZVNuYXBwaW5nIGZyb20gJy4vUmVzaXplU25hcHBpbmcnO1xuaW1wb3J0IFNuYXBwaW5nIGZyb20gJy4vU25hcHBpbmcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9faW5pdF9fOiBbXG4gICAgJ2NyZWF0ZU1vdmVTbmFwcGluZycsXG4gICAgJ3Jlc2l6ZVNuYXBwaW5nJyxcbiAgICAnc25hcHBpbmcnXG4gIF0sXG4gIGNyZWF0ZU1vdmVTbmFwcGluZzogWyAndHlwZScsIENyZWF0ZU1vdmVTbmFwcGluZyBdLFxuICByZXNpemVTbmFwcGluZzogWyAndHlwZScsIFJlc2l6ZVNuYXBwaW5nIF0sXG4gIHNuYXBwaW5nOiBbICd0eXBlJywgU25hcHBpbmcgXVxufTsiLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZpbHRlcixcbiAgZm9yRWFjaCxcbiAgaXNOdW1iZXJcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQgeyBhc1RSQkwgfSBmcm9tICcuLi8uLi9sYXlvdXQvTGF5b3V0VXRpbCc7XG5cbmltcG9ydCB7IGdldEJCb3ggfSBmcm9tICcuLi8uLi91dGlsL0VsZW1lbnRzJztcblxuaW1wb3J0IHsgZ2V0RGlyZWN0aW9uIH0gZnJvbSAnLi9TcGFjZVV0aWwnO1xuXG5pbXBvcnQgeyBoYXNQcmltYXJ5TW9kaWZpZXIgfSBmcm9tICcuLi8uLi91dGlsL01vdXNlJztcblxuaW1wb3J0IHsgc2V0IGFzIHNldEN1cnNvciB9IGZyb20gJy4uLy4uL3V0aWwvQ3Vyc29yJztcblxuaW1wb3J0IHsgc2VsZkFuZEFsbENoaWxkcmVuIH0gZnJvbSAnLi4vLi4vdXRpbC9FbGVtZW50cyc7XG5cbnZhciBhYnMgPSBNYXRoLmFicyxcbiAgICByb3VuZCA9IE1hdGgucm91bmQ7XG5cbnZhciBBWElTX1RPX0RJTUVOU0lPTiA9IHtcbiAgeDogJ3dpZHRoJyxcbiAgeTogJ2hlaWdodCdcbn07XG5cbnZhciBDVVJTT1JfQ1JPU1NIQUlSID0gJ2Nyb3NzaGFpcic7XG5cbnZhciBESVJFQ1RJT05fVE9fVFJCTCA9IHtcbiAgbjogJ3RvcCcsXG4gIHc6ICdsZWZ0JyxcbiAgczogJ2JvdHRvbScsXG4gIGU6ICdyaWdodCdcbn07XG5cbnZhciBISUdIX1BSSU9SSVRZID0gMTUwMDtcblxudmFyIERJUkVDVElPTl9UT19PUFBPU0lURSA9IHtcbiAgbjogJ3MnLFxuICB3OiAnZScsXG4gIHM6ICduJyxcbiAgZTogJ3cnXG59O1xuXG52YXIgUEFERElORyA9IDIwO1xuXG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBzcGFjZSBieSBtb3ZpbmcgYW5kIHJlc2l6aW5nIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAqIEBwYXJhbSB7RHJhZ2dpbmd9IGRyYWdnaW5nXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtNb2RlbGluZ30gbW9kZWxpbmdcbiAqIEBwYXJhbSB7UnVsZXN9IHJ1bGVzXG4gKiBAcGFyYW0ge1Rvb2xNYW5hZ2VyfSB0b29sTWFuYWdlclxuICogQHBhcmFtIHtNb3VzZX0gbW91c2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3BhY2VUb29sKFxuICAgIGNhbnZhcywgZHJhZ2dpbmcsIGV2ZW50QnVzLFxuICAgIG1vZGVsaW5nLCBydWxlcywgdG9vbE1hbmFnZXIsXG4gICAgbW91c2UpIHtcblxuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gIHRoaXMuX2RyYWdnaW5nID0gZHJhZ2dpbmc7XG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX21vZGVsaW5nID0gbW9kZWxpbmc7XG4gIHRoaXMuX3J1bGVzID0gcnVsZXM7XG4gIHRoaXMuX3Rvb2xNYW5hZ2VyID0gdG9vbE1hbmFnZXI7XG4gIHRoaXMuX21vdXNlID0gbW91c2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRvb2xNYW5hZ2VyLnJlZ2lzdGVyVG9vbCgnc3BhY2UnLCB7XG4gICAgdG9vbDogJ3NwYWNlVG9vbC5zZWxlY3Rpb24nLFxuICAgIGRyYWdnaW5nOiAnc3BhY2VUb29sJ1xuICB9KTtcblxuICBldmVudEJ1cy5vbignc3BhY2VUb29sLnNlbGVjdGlvbi5lbmQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIGV2ZW50QnVzLm9uY2UoJ3NwYWNlVG9vbC5zZWxlY3Rpb24uZW5kZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuYWN0aXZhdGVNYWtlU3BhY2UoZXZlbnQub3JpZ2luYWxFdmVudCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdzcGFjZVRvb2wubW92ZScsIEhJR0hfUFJJT1JJVFkgLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgaW5pdGlhbGl6ZWQgPSBjb250ZXh0LmluaXRpYWxpemVkO1xuXG4gICAgaWYgKCFpbml0aWFsaXplZCkge1xuICAgICAgaW5pdGlhbGl6ZWQgPSBjb250ZXh0LmluaXRpYWxpemVkID0gc2VsZi5pbml0KGV2ZW50LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGVuc3VyZUNvbnN0cmFpbnRzKGV2ZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKCdzcGFjZVRvb2wuZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGF4aXMgPSBjb250ZXh0LmF4aXMsXG4gICAgICAgIGRpcmVjdGlvbiA9IGNvbnRleHQuZGlyZWN0aW9uLFxuICAgICAgICBtb3ZpbmdTaGFwZXMgPSBjb250ZXh0Lm1vdmluZ1NoYXBlcyxcbiAgICAgICAgcmVzaXppbmdTaGFwZXMgPSBjb250ZXh0LnJlc2l6aW5nU2hhcGVzLFxuICAgICAgICBzdGFydCA9IGNvbnRleHQuc3RhcnQ7XG5cbiAgICBpZiAoIWNvbnRleHQuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbnN1cmVDb25zdHJhaW50cyhldmVudCk7XG5cbiAgICB2YXIgZGVsdGEgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG5cbiAgICBkZWx0YVsgYXhpcyBdID0gcm91bmQoZXZlbnRbICdkJyArIGF4aXMgXSk7XG5cbiAgICBzZWxmLm1ha2VTcGFjZShtb3ZpbmdTaGFwZXMsIHJlc2l6aW5nU2hhcGVzLCBkZWx0YSwgZGlyZWN0aW9uLCBzdGFydCk7XG5cbiAgICBldmVudEJ1cy5vbmNlKCdzcGFjZVRvb2wuZW5kZWQnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAvLyBhY3RpdmF0ZSBzcGFjZSB0b29sIHNlbGVjdGlvbiBhZnRlciBtYWtlIHNwYWNlXG4gICAgICBzZWxmLmFjdGl2YXRlU2VsZWN0aW9uKGV2ZW50Lm9yaWdpbmFsRXZlbnQsIHRydWUsIHRydWUpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuU3BhY2VUb29sLiRpbmplY3QgPSBbXG4gICdjYW52YXMnLFxuICAnZHJhZ2dpbmcnLFxuICAnZXZlbnRCdXMnLFxuICAnbW9kZWxpbmcnLFxuICAncnVsZXMnLFxuICAndG9vbE1hbmFnZXInLFxuICAnbW91c2UnXG5dO1xuXG4vKipcbiAqIEFjdGl2YXRlIHNwYWNlIHRvb2wgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICogQHBhcmFtIHtib29sZWFufSBhdXRvQWN0aXZhdGVcbiAqL1xuU3BhY2VUb29sLnByb3RvdHlwZS5hY3RpdmF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKGV2ZW50LCBhdXRvQWN0aXZhdGUsIHJlYWN0aXZhdGUpIHtcbiAgdGhpcy5fZHJhZ2dpbmcuaW5pdChldmVudCwgJ3NwYWNlVG9vbC5zZWxlY3Rpb24nLCB7XG4gICAgYXV0b0FjdGl2YXRlOiBhdXRvQWN0aXZhdGUsXG4gICAgY3Vyc29yOiBDVVJTT1JfQ1JPU1NIQUlSLFxuICAgIGRhdGE6IHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgcmVhY3RpdmF0ZTogcmVhY3RpdmF0ZVxuICAgICAgfVxuICAgIH0sXG4gICAgdHJhcENsaWNrOiBmYWxzZVxuICB9KTtcbn07XG5cbi8qKlxuICogQWN0aXZhdGUgc3BhY2UgdG9vbCBtYWtlIHNwYWNlLlxuICpcbiAqIEBwYXJhbSAge01vdXNlRXZlbnR9IGV2ZW50XG4gKi9cblNwYWNlVG9vbC5wcm90b3R5cGUuYWN0aXZhdGVNYWtlU3BhY2UgPSBmdW5jdGlvbihldmVudCkge1xuICB0aGlzLl9kcmFnZ2luZy5pbml0KGV2ZW50LCAnc3BhY2VUb29sJywge1xuICAgIGF1dG9BY3RpdmF0ZTogdHJ1ZSxcbiAgICBjdXJzb3I6IENVUlNPUl9DUk9TU0hBSVIsXG4gICAgZGF0YToge1xuICAgICAgY29udGV4dDoge31cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBNYWtlIHNwYWNlLlxuICpcbiAqIEBwYXJhbSAge0FycmF5PGRqcy5tb2RlbC5TaGFwZT59IG1vdmluZ1NoYXBlc1xuICogQHBhcmFtICB7QXJyYXk8ZGpzLm1vZGVsLlNoYXBlPn0gcmVzaXppbmdTaGFwZXNcbiAqIEBwYXJhbSAge09iamVjdH0gZGVsdGFcbiAqIEBwYXJhbSAge251bWJlcn0gZGVsdGEueFxuICogQHBhcmFtICB7bnVtYmVyfSBkZWx0YS55XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGRpcmVjdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSBzdGFydFxuICovXG5TcGFjZVRvb2wucHJvdG90eXBlLm1ha2VTcGFjZSA9IGZ1bmN0aW9uKG1vdmluZ1NoYXBlcywgcmVzaXppbmdTaGFwZXMsIGRlbHRhLCBkaXJlY3Rpb24sIHN0YXJ0KSB7XG4gIHJldHVybiB0aGlzLl9tb2RlbGluZy5jcmVhdGVTcGFjZShtb3ZpbmdTaGFwZXMsIHJlc2l6aW5nU2hhcGVzLCBkZWx0YSwgZGlyZWN0aW9uLCBzdGFydCk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgbWFrZSBzcGFjZSBhbmQgcmV0dXJuIHRydWUgaWYgdGhhdCB3YXMgc3VjY2Vzc2Z1bC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuU3BhY2VUb29sLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZXZlbnQsIGNvbnRleHQpIHtcbiAgdmFyIGF4aXMgPSBhYnMoZXZlbnQuZHgpID4gYWJzKGV2ZW50LmR5KSA/ICd4JyA6ICd5JyxcbiAgICAgIGRlbHRhID0gZXZlbnRbICdkJyArIGF4aXMgXSxcbiAgICAgIHN0YXJ0ID0gZXZlbnRbIGF4aXMgXSAtIGRlbHRhO1xuXG4gIGlmIChhYnMoZGVsdGEpIDwgNSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGludmVydCBkZWx0YSB0byByZW1vdmUgc3BhY2Ugd2hlbiBtb3ZpbmcgbGVmdFxuICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgZGVsdGEgKj0gLTE7XG4gIH1cblxuICAvLyBpbnZlcnQgZGVsdGEgdG8gYWRkL3JlbW92ZSBzcGFjZSB3aGVuIHJlbW92aW5nL2FkZGluZyBzcGFjZSBpZiBtb2RpZmllciBrZXkgaXMgcHJlc3NlZFxuICBpZiAoaGFzUHJpbWFyeU1vZGlmaWVyKGV2ZW50KSkge1xuICAgIGRlbHRhICo9IC0xO1xuICB9XG5cbiAgdmFyIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihheGlzLCBkZWx0YSk7XG5cbiAgdmFyIHJvb3QgPSB0aGlzLl9jYW52YXMuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICB2YXIgY2hpbGRyZW4gPSBzZWxmQW5kQWxsQ2hpbGRyZW4ocm9vdCwgdHJ1ZSk7XG5cbiAgdmFyIGVsZW1lbnRzID0gdGhpcy5jYWxjdWxhdGVBZGp1c3RtZW50cyhjaGlsZHJlbiwgYXhpcywgZGVsdGEsIHN0YXJ0KTtcblxuICB2YXIgbWluRGltZW5zaW9ucyA9IHRoaXMuX2V2ZW50QnVzLmZpcmUoJ3NwYWNlVG9vbC5nZXRNaW5EaW1lbnNpb25zJywge1xuICAgIGF4aXM6IGF4aXMsXG4gICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgc2hhcGVzOiBlbGVtZW50cy5yZXNpemluZ1NoYXBlcyxcbiAgICBzdGFydDogc3RhcnRcbiAgfSk7XG5cbiAgdmFyIHNwYWNlVG9vbENvbnN0cmFpbnRzID0gZ2V0U3BhY2VUb29sQ29uc3RyYWludHMoZWxlbWVudHMsIGF4aXMsIGRpcmVjdGlvbiwgc3RhcnQsIG1pbkRpbWVuc2lvbnMpO1xuXG4gIGFzc2lnbihcbiAgICBjb250ZXh0LFxuICAgIGVsZW1lbnRzLFxuICAgIHtcbiAgICAgIGF4aXM6IGF4aXMsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzOiBzcGFjZVRvb2xDb25zdHJhaW50cyxcbiAgICAgIHN0YXJ0OiBzdGFydFxuICAgIH1cbiAgKTtcblxuICBzZXRDdXJzb3IoJ3Jlc2l6ZS0nICsgKGF4aXMgPT09ICd4JyA/ICdldycgOiAnbnMnKSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEdldCBlbGVtZW50cyB0byBiZSBtb3ZlZCBhbmQgcmVzaXplZC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxkanMubW9kZWwuU2hhcGU+fSBlbGVtZW50c1xuICogQHBhcmFtICB7c3RyaW5nfSBheGlzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRlbHRhXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0XG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5TcGFjZVRvb2wucHJvdG90eXBlLmNhbGN1bGF0ZUFkanVzdG1lbnRzID0gZnVuY3Rpb24oZWxlbWVudHMsIGF4aXMsIGRlbHRhLCBzdGFydCkge1xuICB2YXIgcnVsZXMgPSB0aGlzLl9ydWxlcztcblxuICB2YXIgbW92aW5nU2hhcGVzID0gW10sXG4gICAgICByZXNpemluZ1NoYXBlcyA9IFtdO1xuXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQucGFyZW50IHx8IGlzQ29ubmVjdGlvbihlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaGFwZVN0YXJ0ID0gZWxlbWVudFsgYXhpcyBdLFxuICAgICAgICBzaGFwZUVuZCA9IHNoYXBlU3RhcnQgKyBlbGVtZW50WyBBWElTX1RPX0RJTUVOU0lPTlsgYXhpcyBdIF07XG5cbiAgICAvLyBzaGFwZSB0byBiZSBtb3ZlZFxuICAgIGlmICgoZGVsdGEgPiAwICYmIHNoYXBlU3RhcnQgPiBzdGFydCkgfHwgKGRlbHRhIDwgMCAmJiBzaGFwZUVuZCA8IHN0YXJ0KSkge1xuICAgICAgcmV0dXJuIG1vdmluZ1NoYXBlcy5wdXNoKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIHNoYXBlIHRvIGJlIHJlc2l6ZWRcbiAgICBpZiAoc2hhcGVTdGFydCA8IHN0YXJ0ICYmXG4gICAgICBzaGFwZUVuZCA+IHN0YXJ0ICYmXG4gICAgICBydWxlcy5hbGxvd2VkKCdzaGFwZS5yZXNpemUnLCB7IHNoYXBlOiBlbGVtZW50IH0pXG4gICAgKSB7XG5cbiAgICAgIHJldHVybiByZXNpemluZ1NoYXBlcy5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtb3ZpbmdTaGFwZXM6IG1vdmluZ1NoYXBlcyxcbiAgICByZXNpemluZ1NoYXBlczogcmVzaXppbmdTaGFwZXNcbiAgfTtcbn07XG5cblNwYWNlVG9vbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgIHJldHVybiB0aGlzLl9kcmFnZ2luZy5jYW5jZWwoKTtcbiAgfVxuXG4gIHZhciBtb3VzZUV2ZW50ID0gdGhpcy5fbW91c2UuZ2V0TGFzdE1vdmVFdmVudCgpO1xuXG4gIHRoaXMuYWN0aXZhdGVTZWxlY3Rpb24obW91c2VFdmVudCwgISFtb3VzZUV2ZW50KTtcbn07XG5cblNwYWNlVG9vbC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLl9kcmFnZ2luZy5jb250ZXh0KCk7XG5cbiAgcmV0dXJuIGNvbnRleHQgJiYgL15zcGFjZVRvb2wvLnRlc3QoY29udGV4dC5wcmVmaXgpO1xufTtcblxuLy8gaGVscGVycyAvLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGFkZFBhZGRpbmcodHJibCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogdHJibC50b3AgLSBQQURESU5HLFxuICAgIHJpZ2h0OiB0cmJsLnJpZ2h0ICsgUEFERElORyxcbiAgICBib3R0b206IHRyYmwuYm90dG9tICsgUEFERElORyxcbiAgICBsZWZ0OiB0cmJsLmxlZnQgLSBQQURESU5HXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUNvbnN0cmFpbnRzKGV2ZW50KSB7XG4gIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzID0gY29udGV4dC5zcGFjZVRvb2xDb25zdHJhaW50cztcblxuICBpZiAoIXNwYWNlVG9vbENvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHgsIHk7XG5cbiAgaWYgKGlzTnVtYmVyKHNwYWNlVG9vbENvbnN0cmFpbnRzLmxlZnQpKSB7XG4gICAgeCA9IE1hdGgubWF4KGV2ZW50LngsIHNwYWNlVG9vbENvbnN0cmFpbnRzLmxlZnQpO1xuXG4gICAgZXZlbnQuZHggPSBldmVudC5keCArIHggLSBldmVudC54O1xuICAgIGV2ZW50LnggPSB4O1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKHNwYWNlVG9vbENvbnN0cmFpbnRzLnJpZ2h0KSkge1xuICAgIHggPSBNYXRoLm1pbihldmVudC54LCBzcGFjZVRvb2xDb25zdHJhaW50cy5yaWdodCk7XG5cbiAgICBldmVudC5keCA9IGV2ZW50LmR4ICsgeCAtIGV2ZW50Lng7XG4gICAgZXZlbnQueCA9IHg7XG4gIH1cblxuICBpZiAoaXNOdW1iZXIoc3BhY2VUb29sQ29uc3RyYWludHMudG9wKSkge1xuICAgIHkgPSBNYXRoLm1heChldmVudC55LCBzcGFjZVRvb2xDb25zdHJhaW50cy50b3ApO1xuXG4gICAgZXZlbnQuZHkgPSBldmVudC5keSArIHkgLSBldmVudC55O1xuICAgIGV2ZW50LnkgPSB5O1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKHNwYWNlVG9vbENvbnN0cmFpbnRzLmJvdHRvbSkpIHtcbiAgICB5ID0gTWF0aC5taW4oZXZlbnQueSwgc3BhY2VUb29sQ29uc3RyYWludHMuYm90dG9tKTtcblxuICAgIGV2ZW50LmR5ID0gZXZlbnQuZHkgKyB5IC0gZXZlbnQueTtcbiAgICBldmVudC55ID0geTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTcGFjZVRvb2xDb25zdHJhaW50cyhlbGVtZW50cywgYXhpcywgZGlyZWN0aW9uLCBzdGFydCwgbWluRGltZW5zaW9ucykge1xuICB2YXIgbW92aW5nU2hhcGVzID0gZWxlbWVudHMubW92aW5nU2hhcGVzLFxuICAgICAgcmVzaXppbmdTaGFwZXMgPSBlbGVtZW50cy5yZXNpemluZ1NoYXBlcztcblxuICBpZiAoIXJlc2l6aW5nU2hhcGVzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzcGFjZVRvb2xDb25zdHJhaW50cyA9IHt9LFxuICAgICAgbWluLFxuICAgICAgbWF4O1xuXG4gIGZvckVhY2gocmVzaXppbmdTaGFwZXMsIGZ1bmN0aW9uKHJlc2l6aW5nU2hhcGUpIHtcbiAgICB2YXIgcmVzaXppbmdTaGFwZUJCb3ggPSBhc1RSQkwocmVzaXppbmdTaGFwZSk7XG5cbiAgICAvLyBmaW5kIGNoaWxkcmVuIHRoYXQgYXJlIG5vdCBtb3Zpbmcgb3IgcmVzaXppbmdcbiAgICB2YXIgbm9uTW92aW5nUmVzaXppbmdDaGlsZHJlbiA9IGZpbHRlcihyZXNpemluZ1NoYXBlLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuICFpc0Nvbm5lY3Rpb24oY2hpbGQpICYmXG4gICAgICAgICFpc0xhYmVsKGNoaWxkKSAmJlxuICAgICAgICAhaW5jbHVkZXMobW92aW5nU2hhcGVzLCBjaGlsZCkgJiZcbiAgICAgICAgIWluY2x1ZGVzKHJlc2l6aW5nU2hhcGVzLCBjaGlsZCk7XG4gICAgfSk7XG5cbiAgICAvLyBmaW5kIGNoaWxkcmVuIHRoYXQgYXJlIG1vdmluZ1xuICAgIHZhciBtb3ZpbmdDaGlsZHJlbiA9IGZpbHRlcihyZXNpemluZ1NoYXBlLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuICFpc0Nvbm5lY3Rpb24oY2hpbGQpICYmICFpc0xhYmVsKGNoaWxkKSAmJiBpbmNsdWRlcyhtb3ZpbmdTaGFwZXMsIGNoaWxkKTtcbiAgICB9KTtcblxuICAgIHZhciBtaW5Pck1heCxcbiAgICAgICAgbm9uTW92aW5nUmVzaXppbmdDaGlsZHJlbkJCb3gsXG4gICAgICAgIG1vdmluZ0NoaWxkcmVuQkJveDtcblxuICAgIGlmIChub25Nb3ZpbmdSZXNpemluZ0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgbm9uTW92aW5nUmVzaXppbmdDaGlsZHJlbkJCb3ggPSBhZGRQYWRkaW5nKGFzVFJCTChnZXRCQm94KG5vbk1vdmluZ1Jlc2l6aW5nQ2hpbGRyZW4pKSk7XG5cbiAgICAgIG1pbk9yTWF4ID0gc3RhcnQgLVxuICAgICAgICByZXNpemluZ1NoYXBlQkJveFsgRElSRUNUSU9OX1RPX1RSQkxbIGRpcmVjdGlvbiBdIF0gK1xuICAgICAgICBub25Nb3ZpbmdSZXNpemluZ0NoaWxkcmVuQkJveFsgRElSRUNUSU9OX1RPX1RSQkxbIGRpcmVjdGlvbiBdIF07XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICduJykge1xuICAgICAgICBzcGFjZVRvb2xDb25zdHJhaW50cy5ib3R0b20gPSBtYXggPSBpc051bWJlcihtYXgpID8gTWF0aC5taW4obWF4LCBtaW5Pck1heCkgOiBtaW5Pck1heDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAndycpIHtcbiAgICAgICAgc3BhY2VUb29sQ29uc3RyYWludHMucmlnaHQgPSBtYXggPSBpc051bWJlcihtYXgpID8gTWF0aC5taW4obWF4LCBtaW5Pck1heCkgOiBtaW5Pck1heDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncycpIHtcbiAgICAgICAgc3BhY2VUb29sQ29uc3RyYWludHMudG9wID0gbWluID0gaXNOdW1iZXIobWluKSA/IE1hdGgubWF4KG1pbiwgbWluT3JNYXgpIDogbWluT3JNYXg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2UnKSB7XG4gICAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzLmxlZnQgPSBtaW4gPSBpc051bWJlcihtaW4pID8gTWF0aC5tYXgobWluLCBtaW5Pck1heCkgOiBtaW5Pck1heDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW92aW5nQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBtb3ZpbmdDaGlsZHJlbkJCb3ggPSBhZGRQYWRkaW5nKGFzVFJCTChnZXRCQm94KG1vdmluZ0NoaWxkcmVuKSkpO1xuXG4gICAgICBtaW5Pck1heCA9IHN0YXJ0IC1cbiAgICAgICAgbW92aW5nQ2hpbGRyZW5CQm94WyBESVJFQ1RJT05fVE9fVFJCTFsgRElSRUNUSU9OX1RPX09QUE9TSVRFWyBkaXJlY3Rpb24gXSBdIF0gK1xuICAgICAgICByZXNpemluZ1NoYXBlQkJveFsgRElSRUNUSU9OX1RPX1RSQkxbIERJUkVDVElPTl9UT19PUFBPU0lURVsgZGlyZWN0aW9uIF0gXSBdO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnbicpIHtcbiAgICAgICAgc3BhY2VUb29sQ29uc3RyYWludHMuYm90dG9tID0gbWF4ID0gaXNOdW1iZXIobWF4KSA/IE1hdGgubWluKG1heCwgbWluT3JNYXgpIDogbWluT3JNYXg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3cnKSB7XG4gICAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzLnJpZ2h0ID0gbWF4ID0gaXNOdW1iZXIobWF4KSA/IE1hdGgubWluKG1heCwgbWluT3JNYXgpIDogbWluT3JNYXg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3MnKSB7XG4gICAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzLnRvcCA9IG1pbiA9IGlzTnVtYmVyKG1pbikgPyBNYXRoLm1heChtaW4sIG1pbk9yTWF4KSA6IG1pbk9yTWF4O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdlJykge1xuICAgICAgICBzcGFjZVRvb2xDb25zdHJhaW50cy5sZWZ0ID0gbWluID0gaXNOdW1iZXIobWluKSA/IE1hdGgubWF4KG1pbiwgbWluT3JNYXgpIDogbWluT3JNYXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc2l6aW5nU2hhcGVNaW5EaW1lbnNpb25zID0gbWluRGltZW5zaW9ucyAmJiBtaW5EaW1lbnNpb25zWyByZXNpemluZ1NoYXBlLmlkIF07XG5cbiAgICBpZiAocmVzaXppbmdTaGFwZU1pbkRpbWVuc2lvbnMpIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICduJykge1xuICAgICAgICBtaW5Pck1heCA9IHN0YXJ0ICtcbiAgICAgICAgICByZXNpemluZ1NoYXBlWyBBWElTX1RPX0RJTUVOU0lPTiBbIGF4aXMgXSBdIC1cbiAgICAgICAgICByZXNpemluZ1NoYXBlTWluRGltZW5zaW9uc1sgQVhJU19UT19ESU1FTlNJT05bIGF4aXMgXSBdO1xuXG4gICAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzLmJvdHRvbSA9IG1heCA9IGlzTnVtYmVyKG1heCkgPyBNYXRoLm1pbihtYXgsIG1pbk9yTWF4KSA6IG1pbk9yTWF4O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICd3Jykge1xuICAgICAgICBtaW5Pck1heCA9IHN0YXJ0ICtcbiAgICAgICAgICByZXNpemluZ1NoYXBlWyBBWElTX1RPX0RJTUVOU0lPTiBbIGF4aXMgXSBdIC1cbiAgICAgICAgICByZXNpemluZ1NoYXBlTWluRGltZW5zaW9uc1sgQVhJU19UT19ESU1FTlNJT05bIGF4aXMgXSBdO1xuXG4gICAgICAgIHNwYWNlVG9vbENvbnN0cmFpbnRzLnJpZ2h0ID0gbWF4ID0gaXNOdW1iZXIobWF4KSA/IE1hdGgubWluKG1heCwgbWluT3JNYXgpIDogbWluT3JNYXg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3MnKSB7XG4gICAgICAgIG1pbk9yTWF4ID0gc3RhcnQgLVxuICAgICAgICAgIHJlc2l6aW5nU2hhcGVbIEFYSVNfVE9fRElNRU5TSU9OIFsgYXhpcyBdIF0gK1xuICAgICAgICAgIHJlc2l6aW5nU2hhcGVNaW5EaW1lbnNpb25zWyBBWElTX1RPX0RJTUVOU0lPTlsgYXhpcyBdIF07XG5cbiAgICAgICAgc3BhY2VUb29sQ29uc3RyYWludHMudG9wID0gbWluID0gaXNOdW1iZXIobWluKSA/IE1hdGgubWF4KG1pbiwgbWluT3JNYXgpIDogbWluT3JNYXg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2UnKSB7XG4gICAgICAgIG1pbk9yTWF4ID0gc3RhcnQgLVxuICAgICAgICAgIHJlc2l6aW5nU2hhcGVbIEFYSVNfVE9fRElNRU5TSU9OIFsgYXhpcyBdIF0gK1xuICAgICAgICAgIHJlc2l6aW5nU2hhcGVNaW5EaW1lbnNpb25zWyBBWElTX1RPX0RJTUVOU0lPTlsgYXhpcyBdIF07XG5cbiAgICAgICAgc3BhY2VUb29sQ29uc3RyYWludHMubGVmdCA9IG1pbiA9IGlzTnVtYmVyKG1pbikgPyBNYXRoLm1heChtaW4sIG1pbk9yTWF4KSA6IG1pbk9yTWF4O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNwYWNlVG9vbENvbnN0cmFpbnRzO1xufVxuXG5mdW5jdGlvbiBpbmNsdWRlcyhhcnJheSwgaXRlbSkge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGlzQ29ubmVjdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiAhIWVsZW1lbnQud2F5cG9pbnRzO1xufVxuXG5mdW5jdGlvbiBpc0xhYmVsKGVsZW1lbnQpIHtcbiAgcmV0dXJuICEhZWxlbWVudC5sYWJlbFRhcmdldDtcbn0iLCJpbXBvcnQge1xuICBmb3JFYWNoXG59IGZyb20gJ21pbi1kYXNoJztcblxudmFyIE1BUktFUl9EUkFHR0lORyA9ICdkanMtZHJhZ2dpbmcnLFxuICAgIE1BUktFUl9SRVNJWklORyA9ICdkanMtcmVzaXppbmcnO1xuXG52YXIgTE9XX1BSSU9SSVRZID0gMjUwO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNsYXNzZXMgYXMgc3ZnQ2xhc3NlcyxcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZSxcbiAgcmVtb3ZlIGFzIHN2Z1JlbW92ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cbmltcG9ydCB7XG4gIHRyYW5zbGF0ZVxufSBmcm9tICcuLi8uLi91dGlsL1N2Z1RyYW5zZm9ybVV0aWwnO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cblxuLyoqXG4gKiBQcm92aWRlcyBwcmV2aWV3cyBmb3Igc2VsZWN0aW5nL21vdmluZy9yZXNpemluZyBzaGFwZXMgd2hlbiBjcmVhdGluZy9yZW1vdmluZyBzcGFjZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnl9IGVsZW1lbnRSZWdpc3RyeVxuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICogQHBhcmFtIHtTdHlsZXN9IHN0eWxlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTcGFjZVRvb2xQcmV2aWV3KFxuICAgIGV2ZW50QnVzLCBlbGVtZW50UmVnaXN0cnksIGNhbnZhcyxcbiAgICBzdHlsZXMsIHByZXZpZXdTdXBwb3J0KSB7XG5cbiAgZnVuY3Rpb24gYWRkUHJldmlld0dmeChjb2xsZWN0aW9uLCBkcmFnR3JvdXApIHtcbiAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHByZXZpZXdTdXBwb3J0LmFkZERyYWdnZXIoZWxlbWVudCwgZHJhZ0dyb3VwKTtcblxuICAgICAgY2FudmFzLmFkZE1hcmtlcihlbGVtZW50LCBNQVJLRVJfRFJBR0dJTkcpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gYWRkIGNyb3NzaGFpclxuICBldmVudEJ1cy5vbignc3BhY2VUb29sLnNlbGVjdGlvbi5zdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHNwYWNlID0gY2FudmFzLmdldExheWVyKCdzcGFjZScpLFxuICAgICAgICBjb250ZXh0ID0gZXZlbnQuY29udGV4dDtcblxuICAgIHZhciBvcmllbnRhdGlvbiA9IHtcbiAgICAgIHg6ICdNIDAsLTEwMDAwIEwgMCwxMDAwMCcsXG4gICAgICB5OiAnTSAtMTAwMDAsMCBMIDEwMDAwLDAnXG4gICAgfTtcblxuICAgIHZhciBjcm9zc2hhaXJHcm91cCA9IHN2Z0NyZWF0ZSgnZycpO1xuICAgIHN2Z0F0dHIoY3Jvc3NoYWlyR3JvdXAsIHN0eWxlcy5jbHMoJ2Rqcy1jcm9zc2hhaXItZ3JvdXAnLCBbICduby1ldmVudHMnIF0pKTtcblxuICAgIHN2Z0FwcGVuZChzcGFjZSwgY3Jvc3NoYWlyR3JvdXApO1xuXG4gICAgLy8gaG9yaXpvbnRhbCBwYXRoXG4gICAgdmFyIHBhdGhYID0gc3ZnQ3JlYXRlKCdwYXRoJyk7XG4gICAgc3ZnQXR0cihwYXRoWCwgJ2QnLCBvcmllbnRhdGlvbi54KTtcbiAgICBzdmdDbGFzc2VzKHBhdGhYKS5hZGQoJ2Rqcy1jcm9zc2hhaXInKTtcblxuICAgIHN2Z0FwcGVuZChjcm9zc2hhaXJHcm91cCwgcGF0aFgpO1xuXG4gICAgLy8gdmVydGljYWwgcGF0aFxuICAgIHZhciBwYXRoWSA9IHN2Z0NyZWF0ZSgncGF0aCcpO1xuICAgIHN2Z0F0dHIocGF0aFksICdkJywgb3JpZW50YXRpb24ueSk7XG4gICAgc3ZnQ2xhc3NlcyhwYXRoWSkuYWRkKCdkanMtY3Jvc3NoYWlyJyk7XG5cbiAgICBzdmdBcHBlbmQoY3Jvc3NoYWlyR3JvdXAsIHBhdGhZKTtcblxuICAgIGNvbnRleHQuY3Jvc3NoYWlyR3JvdXAgPSBjcm9zc2hhaXJHcm91cDtcbiAgfSk7XG5cbiAgLy8gdXBkYXRlIGNyb3NzaGFpclxuICBldmVudEJ1cy5vbignc3BhY2VUb29sLnNlbGVjdGlvbi5tb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY3Jvc3NoYWlyR3JvdXAgPSBldmVudC5jb250ZXh0LmNyb3NzaGFpckdyb3VwO1xuXG4gICAgdHJhbnNsYXRlKGNyb3NzaGFpckdyb3VwLCBldmVudC54LCBldmVudC55KTtcbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIGNyb3NzaGFpclxuICBldmVudEJ1cy5vbignc3BhY2VUb29sLnNlbGVjdGlvbi5jbGVhbnVwJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgIGNyb3NzaGFpckdyb3VwID0gY29udGV4dC5jcm9zc2hhaXJHcm91cDtcblxuICAgIGlmIChjcm9zc2hhaXJHcm91cCkge1xuICAgICAgc3ZnUmVtb3ZlKGNyb3NzaGFpckdyb3VwKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGFkZCBhbmQgdXBkYXRlIG1vdmUvcmVzaXplIHByZXZpZXdzXG4gIGV2ZW50QnVzLm9uKCdzcGFjZVRvb2wubW92ZScsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgbGluZSA9IGNvbnRleHQubGluZSxcbiAgICAgICAgYXhpcyA9IGNvbnRleHQuYXhpcyxcbiAgICAgICAgbW92aW5nU2hhcGVzID0gY29udGV4dC5tb3ZpbmdTaGFwZXMsXG4gICAgICAgIHJlc2l6aW5nU2hhcGVzID0gY29udGV4dC5yZXNpemluZ1NoYXBlcztcblxuICAgIGlmICghY29udGV4dC5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghY29udGV4dC5kcmFnR3JvdXApIHtcbiAgICAgIHZhciBzcGFjZUxheWVyID0gY2FudmFzLmdldExheWVyKCdzcGFjZScpO1xuXG4gICAgICBsaW5lID0gc3ZnQ3JlYXRlKCdwYXRoJyk7XG4gICAgICBzdmdBdHRyKGxpbmUsICdkJywgJ00wLDAgTDAsMCcpO1xuICAgICAgc3ZnQ2xhc3NlcyhsaW5lKS5hZGQoJ2Rqcy1jcm9zc2hhaXInKTtcblxuICAgICAgc3ZnQXBwZW5kKHNwYWNlTGF5ZXIsIGxpbmUpO1xuXG4gICAgICBjb250ZXh0LmxpbmUgPSBsaW5lO1xuXG4gICAgICB2YXIgZHJhZ0dyb3VwID0gc3ZnQ3JlYXRlKCdnJyk7XG4gICAgICBzdmdBdHRyKGRyYWdHcm91cCwgc3R5bGVzLmNscygnZGpzLWRyYWctZ3JvdXAnLCBbICduby1ldmVudHMnIF0pKTtcblxuICAgICAgc3ZnQXBwZW5kKGNhbnZhcy5nZXREZWZhdWx0TGF5ZXIoKSwgZHJhZ0dyb3VwKTtcblxuICAgICAgLy8gc2hhcGVzXG4gICAgICBhZGRQcmV2aWV3R2Z4KG1vdmluZ1NoYXBlcywgZHJhZ0dyb3VwKTtcblxuICAgICAgLy8gY29ubmVjdGlvbnNcbiAgICAgIHZhciBtb3ZpbmdDb25uZWN0aW9ucyA9IGNvbnRleHQubW92aW5nQ29ubmVjdGlvbnMgPSBlbGVtZW50UmVnaXN0cnkuZmlsdGVyKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHNvdXJjZUlzTW92aW5nID0gZmFsc2U7XG5cbiAgICAgICAgZm9yRWFjaChtb3ZpbmdTaGFwZXMsIGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgZm9yRWFjaChzaGFwZS5vdXRnb2luZywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgc291cmNlSXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdGFyZ2V0SXNNb3ZpbmcgPSBmYWxzZTtcblxuICAgICAgICBmb3JFYWNoKG1vdmluZ1NoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICBmb3JFYWNoKHNoYXBlLmluY29taW5nLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICB0YXJnZXRJc01vdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzb3VyY2VJc1Jlc2l6aW5nID0gZmFsc2U7XG5cbiAgICAgICAgZm9yRWFjaChyZXNpemluZ1NoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICBmb3JFYWNoKHNoYXBlLm91dGdvaW5nLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICBzb3VyY2VJc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHRhcmdldElzUmVzaXppbmcgPSBmYWxzZTtcblxuICAgICAgICBmb3JFYWNoKHJlc2l6aW5nU2hhcGVzLCBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgIGZvckVhY2goc2hhcGUuaW5jb21pbmcsIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHRhcmdldElzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaXNDb25uZWN0aW9uKGVsZW1lbnQpXG4gICAgICAgICAgJiYgKHNvdXJjZUlzTW92aW5nIHx8IHNvdXJjZUlzUmVzaXppbmcpXG4gICAgICAgICAgJiYgKHRhcmdldElzTW92aW5nIHx8IHRhcmdldElzUmVzaXppbmcpO1xuICAgICAgfSk7XG5cblxuICAgICAgYWRkUHJldmlld0dmeChtb3ZpbmdDb25uZWN0aW9ucywgZHJhZ0dyb3VwKTtcblxuICAgICAgY29udGV4dC5kcmFnR3JvdXAgPSBkcmFnR3JvdXA7XG4gICAgfVxuXG4gICAgaWYgKCFjb250ZXh0LmZyYW1lR3JvdXApIHtcbiAgICAgIHZhciBmcmFtZUdyb3VwID0gc3ZnQ3JlYXRlKCdnJyk7XG4gICAgICBzdmdBdHRyKGZyYW1lR3JvdXAsIHN0eWxlcy5jbHMoJ2Rqcy1mcmFtZS1ncm91cCcsIFsgJ25vLWV2ZW50cycgXSkpO1xuXG4gICAgICBzdmdBcHBlbmQoY2FudmFzLmdldERlZmF1bHRMYXllcigpLCBmcmFtZUdyb3VwKTtcblxuICAgICAgdmFyIGZyYW1lcyA9IFtdO1xuXG4gICAgICBmb3JFYWNoKHJlc2l6aW5nU2hhcGVzLCBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICB2YXIgZnJhbWUgPSBwcmV2aWV3U3VwcG9ydC5hZGRGcmFtZShzaGFwZSwgZnJhbWVHcm91cCk7XG5cbiAgICAgICAgdmFyIGluaXRpYWxCb3VuZHMgPSBmcmFtZS5nZXRCQm94KCk7XG5cbiAgICAgICAgZnJhbWVzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGZyYW1lLFxuICAgICAgICAgIGluaXRpYWxCb3VuZHM6IGluaXRpYWxCb3VuZHNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FudmFzLmFkZE1hcmtlcihzaGFwZSwgTUFSS0VSX1JFU0laSU5HKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb250ZXh0LmZyYW1lR3JvdXAgPSBmcmFtZUdyb3VwO1xuICAgICAgY29udGV4dC5mcmFtZXMgPSBmcmFtZXM7XG4gICAgfVxuXG4gICAgdmFyIG9yaWVudGF0aW9uID0ge1xuICAgICAgeDogJ00nICsgZXZlbnQueCArICcsIC0xMDAwMCBMJyArIGV2ZW50LnggKyAnLCAxMDAwMCcsXG4gICAgICB5OiAnTSAtMTAwMDAsICcgKyBldmVudC55ICsgJyBMIDEwMDAwLCAnICsgZXZlbnQueVxuICAgIH07XG5cbiAgICBzdmdBdHRyKGxpbmUsIHsgZDogb3JpZW50YXRpb25bIGF4aXMgXSB9KTtcblxuICAgIHZhciBvcHBvc2l0ZSA9IHsgeDogJ3knLCB5OiAneCcgfTtcbiAgICB2YXIgZGVsdGEgPSB7IHg6IGV2ZW50LmR4LCB5OiBldmVudC5keSB9O1xuICAgIGRlbHRhWyBvcHBvc2l0ZVsgY29udGV4dC5heGlzIF0gXSA9IDA7XG5cbiAgICAvLyB1cGRhdGUgbW92ZSBwcmV2aWV3c1xuICAgIHRyYW5zbGF0ZShjb250ZXh0LmRyYWdHcm91cCwgZGVsdGEueCwgZGVsdGEueSk7XG5cbiAgICAvLyB1cGRhdGUgcmVzaXplIHByZXZpZXdzXG4gICAgZm9yRWFjaChjb250ZXh0LmZyYW1lcywgZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZnJhbWUuZWxlbWVudCxcbiAgICAgICAgICBpbml0aWFsQm91bmRzID0gZnJhbWUuaW5pdGlhbEJvdW5kcyxcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ7XG5cbiAgICAgIGlmIChjb250ZXh0LmRpcmVjdGlvbiA9PT0gJ2UnKSB7XG4gICAgICAgIHN2Z0F0dHIoZWxlbWVudCwge1xuICAgICAgICAgIHdpZHRoOiBtYXgoaW5pdGlhbEJvdW5kcy53aWR0aCArIGRlbHRhLngsIDUpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSBtYXgoaW5pdGlhbEJvdW5kcy53aWR0aCAtIGRlbHRhLngsIDUpO1xuXG4gICAgICAgIHN2Z0F0dHIoZWxlbWVudCwge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICB4OiBpbml0aWFsQm91bmRzLnggKyBpbml0aWFsQm91bmRzLndpZHRoIC0gd2lkdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZXh0LmRpcmVjdGlvbiA9PT0gJ3MnKSB7XG4gICAgICAgIHN2Z0F0dHIoZWxlbWVudCwge1xuICAgICAgICAgIGhlaWdodDogbWF4KGluaXRpYWxCb3VuZHMuaGVpZ2h0ICsgZGVsdGEueSwgNSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWlnaHQgPSBtYXgoaW5pdGlhbEJvdW5kcy5oZWlnaHQgLSBkZWx0YS55LCA1KTtcblxuICAgICAgICBzdmdBdHRyKGVsZW1lbnQsIHtcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICB5OiBpbml0aWFsQm91bmRzLnkgKyBpbml0aWFsQm91bmRzLmhlaWdodCAtIGhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9KTtcblxuICAvLyByZW1vdmUgbW92ZS9yZXNpemUgcHJldmlld3NcbiAgZXZlbnRCdXMub24oJ3NwYWNlVG9vbC5jbGVhbnVwJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dCxcbiAgICAgICAgbW92aW5nU2hhcGVzID0gY29udGV4dC5tb3ZpbmdTaGFwZXMsXG4gICAgICAgIG1vdmluZ0Nvbm5lY3Rpb25zID0gY29udGV4dC5tb3ZpbmdDb25uZWN0aW9ucyxcbiAgICAgICAgcmVzaXppbmdTaGFwZXMgPSBjb250ZXh0LnJlc2l6aW5nU2hhcGVzLFxuICAgICAgICBsaW5lID0gY29udGV4dC5saW5lLFxuICAgICAgICBkcmFnR3JvdXAgPSBjb250ZXh0LmRyYWdHcm91cCxcbiAgICAgICAgZnJhbWVHcm91cCA9IGNvbnRleHQuZnJhbWVHcm91cDtcblxuICAgIC8vIG1vdmluZyBzaGFwZXNcbiAgICBmb3JFYWNoKG1vdmluZ1NoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIGNhbnZhcy5yZW1vdmVNYXJrZXIoc2hhcGUsIE1BUktFUl9EUkFHR0lORyk7XG4gICAgfSk7XG5cbiAgICAvLyBtb3ZpbmcgY29ubmVjdGlvbnNcbiAgICBmb3JFYWNoKG1vdmluZ0Nvbm5lY3Rpb25zLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGNvbm5lY3Rpb24sIE1BUktFUl9EUkFHR0lORyk7XG4gICAgfSk7XG5cbiAgICBpZiAoZHJhZ0dyb3VwKSB7XG4gICAgICBzdmdSZW1vdmUobGluZSk7XG4gICAgICBzdmdSZW1vdmUoZHJhZ0dyb3VwKTtcbiAgICB9XG5cbiAgICBmb3JFYWNoKHJlc2l6aW5nU2hhcGVzLCBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgY2FudmFzLnJlbW92ZU1hcmtlcihzaGFwZSwgTUFSS0VSX1JFU0laSU5HKTtcbiAgICB9KTtcblxuICAgIGlmIChmcmFtZUdyb3VwKSB7XG4gICAgICBzdmdSZW1vdmUoZnJhbWVHcm91cCk7XG4gICAgfVxuICB9KTtcbn1cblxuU3BhY2VUb29sUHJldmlldy4kaW5qZWN0ID0gW1xuICAnZXZlbnRCdXMnLFxuICAnZWxlbWVudFJlZ2lzdHJ5JyxcbiAgJ2NhbnZhcycsXG4gICdzdHlsZXMnLFxuICAncHJldmlld1N1cHBvcnQnXG5dO1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBlbGVtZW50IGlzIGEgY29ubmVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gaXNDb25uZWN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQud2F5cG9pbnRzO1xufVxuIiwiaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gJ21pbi1kYXNoJztcblxuLyoqXG4gKiBSZXR1cm4gZGlyZWN0aW9uIGdpdmVuIGF4aXMgYW5kIGRlbHRhLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGFcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXJlY3Rpb24oYXhpcywgZGVsdGEpIHtcblxuICBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgcmV0dXJuICdlJztcbiAgICB9XG5cbiAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICByZXR1cm4gJ3cnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChheGlzID09PSAneScpIHtcbiAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICByZXR1cm4gJ3MnO1xuICAgIH1cblxuICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgIHJldHVybiAnbic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyBjb25uZWN0aW9ucyB3aG9zZSB3YXlwb2ludHMgYXJlIHRvIGJlIHVwZGF0ZWQuIFdheXBvaW50cyBhcmUgdG8gYmUgdXBkYXRlZCBpZiBzdGFydFxuICogb3IgZW5kIGlzIHRvIGJlIG1vdmVkIG9yIHJlc2l6ZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuU2hhcGV9IG1vdmluZ1NoYXBlc1xuICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuU2hhcGV9IHJlc2l6aW5nU2hhcGVzXG4gKlxuICogQHJldHVybnMge0FycmF5PGRqcy5tb2RlbC5Db25uZWN0aW9uPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdheXBvaW50c1VwZGF0aW5nQ29ubmVjdGlvbnMobW92aW5nU2hhcGVzLCByZXNpemluZ1NoYXBlcykge1xuICB2YXIgd2F5cG9pbnRzVXBkYXRpbmdDb25uZWN0aW9ucyA9IFtdO1xuXG4gIGZvckVhY2gobW92aW5nU2hhcGVzLmNvbmNhdChyZXNpemluZ1NoYXBlcyksIGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgdmFyIGluY29taW5nID0gc2hhcGUuaW5jb21pbmcsXG4gICAgICAgIG91dGdvaW5nID0gc2hhcGUub3V0Z29pbmc7XG5cbiAgICBmb3JFYWNoKGluY29taW5nLmNvbmNhdChvdXRnb2luZyksIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgIHZhciBzb3VyY2UgPSBjb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQgPSBjb25uZWN0aW9uLnRhcmdldDtcblxuICAgICAgaWYgKGluY2x1ZGVzKG1vdmluZ1NoYXBlcywgc291cmNlKSB8fFxuICAgICAgICBpbmNsdWRlcyhtb3ZpbmdTaGFwZXMsIHRhcmdldCkgfHxcbiAgICAgICAgaW5jbHVkZXMocmVzaXppbmdTaGFwZXMsIHNvdXJjZSkgfHxcbiAgICAgICAgaW5jbHVkZXMocmVzaXppbmdTaGFwZXMsIHRhcmdldCkpIHtcblxuICAgICAgICBpZiAoIWluY2x1ZGVzKHdheXBvaW50c1VwZGF0aW5nQ29ubmVjdGlvbnMsIGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgd2F5cG9pbnRzVXBkYXRpbmdDb25uZWN0aW9ucy5wdXNoKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB3YXlwb2ludHNVcGRhdGluZ0Nvbm5lY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBpbmNsdWRlcyhhcnJheSwgaXRlbSkge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59XG5cbi8qKlxuICogUmVzaXplIGJvdW5kcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYm91bmRzXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnhcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMueVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy53aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5oZWlnaHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWx0YVxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhLnhcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YS55XG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzaXplQm91bmRzKGJvdW5kcywgZGlyZWN0aW9uLCBkZWx0YSkge1xuICB2YXIgeCA9IGJvdW5kcy54LFxuICAgICAgeSA9IGJvdW5kcy55LFxuICAgICAgd2lkdGggPSBib3VuZHMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0LFxuICAgICAgZHggPSBkZWx0YS54LFxuICAgICAgZHkgPSBkZWx0YS55O1xuXG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gIGNhc2UgJ24nOlxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSArIGR5LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgLSBkeVxuICAgIH07XG4gIGNhc2UgJ3MnOlxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0ICsgZHlcbiAgICB9O1xuICBjYXNlICd3JzpcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIGR4LFxuICAgICAgeTogeSxcbiAgICAgIHdpZHRoOiB3aWR0aCAtIGR4LFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICBjYXNlICdlJzpcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogd2lkdGggKyBkeCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZGlyZWN0aW9uOiAnICsgZGlyZWN0aW9uKTtcbiAgfVxufSIsImltcG9ydCBEcmFnZ2luZ01vZHVsZSBmcm9tICcuLi9kcmFnZ2luZyc7XG5pbXBvcnQgUnVsZXNNb2R1bGUgZnJvbSAnLi4vcnVsZXMnO1xuaW1wb3J0IFRvb2xNYW5hZ2VyTW9kdWxlIGZyb20gJy4uL3Rvb2wtbWFuYWdlcic7XG5pbXBvcnQgUHJldmlld1N1cHBvcnRNb2R1bGUgZnJvbSAnLi4vcHJldmlldy1zdXBwb3J0JztcbmltcG9ydCBNb3VzZU1vZHVsZSBmcm9tICcuLi9tb3VzZSc7XG5cbmltcG9ydCBTcGFjZVRvb2wgZnJvbSAnLi9TcGFjZVRvb2wnO1xuaW1wb3J0IFNwYWNlVG9vbFByZXZpZXcgZnJvbSAnLi9TcGFjZVRvb2xQcmV2aWV3JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWydzcGFjZVRvb2xQcmV2aWV3J10sXG4gIF9fZGVwZW5kc19fOiBbXG4gICAgRHJhZ2dpbmdNb2R1bGUsXG4gICAgUnVsZXNNb2R1bGUsXG4gICAgVG9vbE1hbmFnZXJNb2R1bGUsXG4gICAgUHJldmlld1N1cHBvcnRNb2R1bGUsXG4gICAgTW91c2VNb2R1bGVcbiAgXSxcbiAgc3BhY2VUb29sOiBbJ3R5cGUnLCBTcGFjZVRvb2wgXSxcbiAgc3BhY2VUb29sUHJldmlldzogWyd0eXBlJywgU3BhY2VUb29sUHJldmlldyBdXG59O1xuIiwiaW1wb3J0IHtcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGNsb3Nlc3QgYXMgZG9tQ2xvc2VzdFxufSBmcm9tICdtaW4tZG9tJztcblxudmFyIExPV19QUklPUklUWSA9IDI1MDtcblxuLyoqXG4gKiBUaGUgdG9vbCBtYW5hZ2VyIGFjdHMgYXMgbWlkZGxlLW1hbiBiZXR3ZWVuIHRoZSBhdmFpbGFibGUgdG9vbCdzIGFuZCB0aGUgUGFsZXR0ZSxcbiAqIGl0IHRha2VzIGNhcmUgb2YgbWFraW5nIHN1cmUgdGhhdCB0aGUgY29ycmVjdCBhY3RpdmUgc3RhdGUgaXMgc2V0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gICAgZXZlbnRCdXNcbiAqIEBwYXJhbSAge09iamVjdH0gICAgZHJhZ2dpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVG9vbE1hbmFnZXIoZXZlbnRCdXMsIGRyYWdnaW5nKSB7XG4gIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuX2RyYWdnaW5nID0gZHJhZ2dpbmc7XG5cbiAgdGhpcy5fdG9vbHMgPSBbXTtcbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbn1cblxuVG9vbE1hbmFnZXIuJGluamVjdCA9IFsgJ2V2ZW50QnVzJywgJ2RyYWdnaW5nJyBdO1xuXG5Ub29sTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJUb29sID0gZnVuY3Rpb24obmFtZSwgZXZlbnRzKSB7XG4gIHZhciB0b29scyA9IHRoaXMuX3Rvb2xzO1xuXG4gIGlmICghZXZlbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIHRvb2wgaGFzIHRvIGJlIHJlZ2lzdGVyZWQgd2l0aCBpdFxcJ3MgXCJldmVudHNcIicpO1xuICB9XG5cbiAgdG9vbHMucHVzaChuYW1lKTtcblxuICB0aGlzLmJpbmRFdmVudHMobmFtZSwgZXZlbnRzKTtcbn07XG5cblRvb2xNYW5hZ2VyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKHRvb2wpIHtcbiAgcmV0dXJuIHRvb2wgJiYgdGhpcy5fYWN0aXZlID09PSB0b29sO1xufTtcblxuVG9vbE1hbmFnZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKHRvb2wpIHtcbiAgcmV0dXJuIHRoaXMuX3Rvb2xzLmxlbmd0aDtcbn07XG5cblRvb2xNYW5hZ2VyLnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbih0b29sKSB7XG4gIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gIGlmICh0aGlzLl9hY3RpdmUgIT09IHRvb2wpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSB0b29sO1xuXG4gICAgZXZlbnRCdXMuZmlyZSgndG9vbC1tYW5hZ2VyLnVwZGF0ZScsIHsgdG9vbDogdG9vbCB9KTtcbiAgfVxufTtcblxuVG9vbE1hbmFnZXIucHJvdG90eXBlLmJpbmRFdmVudHMgPSBmdW5jdGlvbihuYW1lLCBldmVudHMpIHtcbiAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXMsXG4gICAgICBkcmFnZ2luZyA9IHRoaXMuX2RyYWdnaW5nO1xuXG4gIHZhciBldmVudHNUb1JlZ2lzdGVyID0gW107XG5cbiAgZXZlbnRCdXMub24oZXZlbnRzLnRvb2wgKyAnLmluaXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dDtcblxuICAgIC8vIEFjdGl2ZSB0b29scyB0aGF0IHdhbnQgdG8gcmVhY3RpdmF0ZSB0aGVtc2VsdmVzIG11c3QgZG8gdGhpcyBleHBsaWNpdGx5XG4gICAgaWYgKCFjb250ZXh0LnJlYWN0aXZhdGUgJiYgdGhpcy5pc0FjdGl2ZShuYW1lKSkge1xuICAgICAgdGhpcy5zZXRBY3RpdmUobnVsbCk7XG5cbiAgICAgIGRyYWdnaW5nLmNhbmNlbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QWN0aXZlKG5hbWUpO1xuXG4gIH0sIHRoaXMpO1xuXG4gIC8vIFRvZG9bcmljYXJkb106IGFkZCB0ZXN0IGNhc2VzXG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuICAgIGV2ZW50c1RvUmVnaXN0ZXIucHVzaChldmVudCArICcuZW5kZWQnKTtcbiAgICBldmVudHNUb1JlZ2lzdGVyLnB1c2goZXZlbnQgKyAnLmNhbmNlbGVkJyk7XG4gIH0pO1xuXG4gIGV2ZW50QnVzLm9uKGV2ZW50c1RvUmVnaXN0ZXIsIExPV19QUklPUklUWSwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIC8vIFdlIGRlZmVyIHRoZSBkZS1hY3RpdmF0aW9uIG9mIHRoZSB0b29sIHRvIHRoZSAuYWN0aXZhdGUgcGhhc2UsXG4gICAgLy8gc28gd2UncmUgYWJsZSB0byBjaGVjayBpZiB3ZSB3YW50IHRvIHRvZ2dsZSBvZmYgdGhlIGN1cnJlbnRcbiAgICAvLyBhY3RpdmUgdG9vbCBvciBzd2l0Y2ggdG8gYSBuZXcgb25lXG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNQYWxldHRlQ2xpY2soZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBY3RpdmUobnVsbCk7XG4gIH0sIHRoaXMpO1xuXG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBldmVudCBpcyBhIHBhbGV0dGUgY2xpY2sgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEJ1cy5FdmVudH0gZXZlbnRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1BhbGV0dGVDbGljayhldmVudCkge1xuICB2YXIgdGFyZ2V0ID0gZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnRhcmdldDtcblxuICByZXR1cm4gdGFyZ2V0ICYmIGRvbUNsb3Nlc3QodGFyZ2V0LCAnLmdyb3VwW2RhdGEtZ3JvdXA9XCJ0b29sc1wiXScpO1xufSIsImltcG9ydCBEcmFnZ2luZ01vZHVsZSBmcm9tICcuLi9kcmFnZ2luZyc7XG5cbmltcG9ydCBUb29sTWFuYWdlciBmcm9tICcuL1Rvb2xNYW5hZ2VyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogW1xuICAgIERyYWdnaW5nTW9kdWxlXG4gIF0sXG4gIF9faW5pdF9fOiBbICd0b29sTWFuYWdlcicgXSxcbiAgdG9vbE1hbmFnZXI6IFsgJ3R5cGUnLCBUb29sTWFuYWdlciBdXG59O1xuIiwiaW1wb3J0IHtcbiAgaXNTdHJpbmcsXG4gIGFzc2lnbixcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGRvbWlmeSxcbiAgYXR0ciBhcyBkb21BdHRyLFxuICBjbGFzc2VzIGFzIGRvbUNsYXNzZXMsXG4gIHJlbW92ZSBhcyBkb21SZW1vdmUsXG4gIGRlbGVnYXRlIGFzIGRvbURlbGVnYXRlXG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQgSWRzIGZyb20gJy4uLy4uL3V0aWwvSWRHZW5lcmF0b3InO1xuXG4vLyBkb2N1bWVudCB3aWRlIHVuaXF1ZSB0b29sdGlwIGlkc1xudmFyIGlkcyA9IG5ldyBJZHMoJ3R0Jyk7XG5cblxuZnVuY3Rpb24gY3JlYXRlUm9vdChwYXJlbnROb2RlKSB7XG4gIHZhciByb290ID0gZG9taWZ5KFxuICAgICc8ZGl2IGNsYXNzPVwiZGpzLXRvb2x0aXAtY29udGFpbmVyXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAwOyBoZWlnaHQ6IDA7XCIgLz4nXG4gICk7XG5cbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocm9vdCwgcGFyZW50Tm9kZS5maXJzdENoaWxkKTtcblxuICByZXR1cm4gcm9vdDtcbn1cblxuXG5mdW5jdGlvbiBzZXRQb3NpdGlvbihlbCwgeCwgeSkge1xuICBhc3NpZ24oZWwuc3R5bGUsIHsgbGVmdDogeCArICdweCcsIHRvcDogeSArICdweCcgfSk7XG59XG5cbmZ1bmN0aW9uIHNldFZpc2libGUoZWwsIHZpc2libGUpIHtcbiAgZWwuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPT09IGZhbHNlID8gJ25vbmUnIDogJyc7XG59XG5cblxudmFyIHRvb2x0aXBDbGFzcyA9ICdkanMtdG9vbHRpcCcsXG4gICAgdG9vbHRpcFNlbGVjdG9yID0gJy4nICsgdG9vbHRpcENsYXNzO1xuXG4vKipcbiAqIEEgc2VydmljZSB0aGF0IGFsbG93cyB1c2VycyB0byByZW5kZXIgdG9vbCB0aXBzIG9uIHRoZSBkaWFncmFtLlxuICpcbiAqIFRoZSB0b29sdGlwIHNlcnZpY2Ugd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRpbmcgdGhlIHRvb2x0aXAgcG9zaXRpb25pbmdcbiAqIGR1cmluZyBuYXZpZ2F0aW9uICsgem9vbWluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqXG4gKiAvLyBhZGQgYSBwaW5rIGJhZGdlIG9uIHRoZSB0b3AgbGVmdCBvZiB0aGUgc2hhcGVcbiAqIHRvb2x0aXBzLmFkZCh7XG4gKiAgIHBvc2l0aW9uOiB7XG4gKiAgICAgeDogNTAsXG4gKiAgICAgeTogMTAwXG4gKiAgIH0sXG4gKiAgIGh0bWw6ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDEwcHg7IGJhY2tncm91bmQ6IGZ1Y2hzaWE7IGNvbG9yOiB3aGl0ZTtcIj4wPC9kaXY+J1xuICogfSk7XG4gKlxuICogLy8gb3Igd2l0aCBvcHRpb25hbCBsaWZlIHNwYW5cbiAqIHRvb2x0aXBzLmFkZCh7XG4gKiAgIHBvc2l0aW9uOiB7XG4gKiAgICAgdG9wOiAtNSxcbiAqICAgICBsZWZ0OiAtNVxuICogICB9LFxuICogICBodG1sOiAnPGRpdiBzdHlsZT1cIndpZHRoOiAxMHB4OyBiYWNrZ3JvdW5kOiBmdWNoc2lhOyBjb2xvcjogd2hpdGU7XCI+MDwvZGl2PicsXG4gKiAgIHR0bDogMjAwMFxuICogfSk7XG4gKlxuICogLy8gcmVtb3ZlIGEgdG9vbCB0aXBcbiAqIHZhciBpZCA9IHRvb2x0aXBzLmFkZCguLi4pO1xuICogdG9vbHRpcHMucmVtb3ZlKGlkKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRvb2x0aXBzKGV2ZW50QnVzLCBjYW52YXMpIHtcblxuICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG5cbiAgdGhpcy5faWRzID0gaWRzO1xuXG4gIHRoaXMuX3Rvb2x0aXBEZWZhdWx0cyA9IHtcbiAgICBzaG93OiB7XG4gICAgICBtaW5ab29tOiAwLjcsXG4gICAgICBtYXhab29tOiA1LjBcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgdG9vbHRpcElkIC0+IHRvb2x0aXBcbiAgICovXG4gIHRoaXMuX3Rvb2x0aXBzID0ge307XG5cbiAgLy8gcm9vdCBodG1sIGVsZW1lbnQgZm9yIGFsbCB0b29sdGlwc1xuICB0aGlzLl90b29sdGlwUm9vdCA9IGNyZWF0ZVJvb3QoY2FudmFzLmdldENvbnRhaW5lcigpKTtcblxuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBkb21EZWxlZ2F0ZS5iaW5kKHRoaXMuX3Rvb2x0aXBSb290LCB0b29sdGlwU2VsZWN0b3IsICdtb3VzZWRvd24nLCBmdW5jdGlvbihldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcblxuICBkb21EZWxlZ2F0ZS5iaW5kKHRoaXMuX3Rvb2x0aXBSb290LCB0b29sdGlwU2VsZWN0b3IsICdtb3VzZW92ZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgIHNlbGYudHJpZ2dlcignbW91c2VvdmVyJywgZXZlbnQpO1xuICB9KTtcblxuICBkb21EZWxlZ2F0ZS5iaW5kKHRoaXMuX3Rvb2x0aXBSb290LCB0b29sdGlwU2VsZWN0b3IsICdtb3VzZW91dCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgc2VsZi50cmlnZ2VyKCdtb3VzZW91dCcsIGV2ZW50KTtcbiAgfSk7XG5cbiAgdGhpcy5faW5pdCgpO1xufVxuXG5cblRvb2x0aXBzLiRpbmplY3QgPSBbICdldmVudEJ1cycsICdjYW52YXMnIF07XG5cblxuLyoqXG4gKiBBZGRzIGEgSFRNTCB0b29sdGlwIHRvIHRoZSBkaWFncmFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgdG9vbHRpcCAgIHRoZSB0b29sdGlwIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xET01FbGVtZW50fSAgICB0b29sdGlwLmh0bWwgICAgICAgICAgICAgICAgIGh0bWwgZWxlbWVudCB0byB1c2UgYXMgYW4gdG9vbHRpcFxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgW3Rvb2x0aXAuc2hvd10gICAgICAgICAgICAgICBzaG93IGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgIFt0b29sdGlwLnNob3cubWluWm9vbV0gICAgICAgbWluaW1hbCB6b29tIGxldmVsIHRvIHNob3cgdGhlIHRvb2x0aXBcbiAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgIFt0b29sdGlwLnNob3cubWF4Wm9vbV0gICAgICAgbWF4aW11bSB6b29tIGxldmVsIHRvIHNob3cgdGhlIHRvb2x0aXBcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIHRvb2x0aXAucG9zaXRpb24gICAgICAgICAgICAgd2hlcmUgdG8gYXR0YWNoIHRoZSB0b29sdGlwXG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICBbdG9vbHRpcC5wb3NpdGlvbi5sZWZ0XSAgICAgIHJlbGF0aXZlIHRvIGVsZW1lbnQgYmJveCBsZWZ0IGF0dGFjaG1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgIFt0b29sdGlwLnBvc2l0aW9uLnRvcF0gICAgICAgcmVsYXRpdmUgdG8gZWxlbWVudCBiYm94IHRvcCBhdHRhY2htZW50XG4gKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICBbdG9vbHRpcC5wb3NpdGlvbi5ib3R0b21dICAgIHJlbGF0aXZlIHRvIGVsZW1lbnQgYmJveCBib3R0b20gYXR0YWNobWVudFxuICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgW3Rvb2x0aXAucG9zaXRpb24ucmlnaHRdICAgICByZWxhdGl2ZSB0byBlbGVtZW50IGJib3ggcmlnaHQgYXR0YWNobWVudFxuICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgW3Rvb2x0aXAudGltZW91dD0tMV1cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgICBpZCB0aGF0IG1heSBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGUgdG9vbHRpcCBmb3IgdXBkYXRlIG9yIHJlbW92YWxcbiAqL1xuVG9vbHRpcHMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHRvb2x0aXApIHtcblxuICBpZiAoIXRvb2x0aXAucG9zaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmaXkgdG9vbHRpcCBwb3NpdGlvbicpO1xuICB9XG5cbiAgaWYgKCF0b29sdGlwLmh0bWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmaXkgdG9vbHRpcCBodG1sJyk7XG4gIH1cblxuICB2YXIgaWQgPSB0aGlzLl9pZHMubmV4dCgpO1xuXG4gIHRvb2x0aXAgPSBhc3NpZ24oe30sIHRoaXMuX3Rvb2x0aXBEZWZhdWx0cywgdG9vbHRpcCwge1xuICAgIGlkOiBpZFxuICB9KTtcblxuICB0aGlzLl9hZGRUb29sdGlwKHRvb2x0aXApO1xuXG4gIGlmICh0b29sdGlwLnRpbWVvdXQpIHtcbiAgICB0aGlzLnNldFRpbWVvdXQodG9vbHRpcCk7XG4gIH1cblxuICByZXR1cm4gaWQ7XG59O1xuXG5Ub29sdGlwcy5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGFjdGlvbiwgZXZlbnQpIHtcblxuICB2YXIgbm9kZSA9IGV2ZW50LmRlbGVnYXRlVGFyZ2V0IHx8IGV2ZW50LnRhcmdldDtcblxuICB2YXIgdG9vbHRpcCA9IHRoaXMuZ2V0KGRvbUF0dHIobm9kZSwgJ2RhdGEtdG9vbHRpcC1pZCcpKTtcblxuICBpZiAoIXRvb2x0aXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoYWN0aW9uID09PSAnbW91c2VvdmVyJyAmJiB0b29sdGlwLnRpbWVvdXQpIHtcbiAgICB0aGlzLmNsZWFyVGltZW91dCh0b29sdGlwKTtcbiAgfVxuXG4gIGlmIChhY3Rpb24gPT09ICdtb3VzZW91dCcgJiYgdG9vbHRpcC50aW1lb3V0KSB7XG5cbiAgICAvLyBjdXQgdGltZW91dCBhZnRlciBtb3VzZSBvdXRcbiAgICB0b29sdGlwLnRpbWVvdXQgPSAxMDAwO1xuXG4gICAgdGhpcy5zZXRUaW1lb3V0KHRvb2x0aXApO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIHRvb2x0aXAgd2l0aCB0aGUgZ2l2ZW4gaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqL1xuVG9vbHRpcHMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGlkKSB7XG5cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICBpZCA9IGlkLmlkO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX3Rvb2x0aXBzW2lkXTtcbn07XG5cblRvb2x0aXBzLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbih0b29sdGlwKSB7XG5cbiAgdG9vbHRpcCA9IHRoaXMuZ2V0KHRvb2x0aXApO1xuXG4gIGlmICghdG9vbHRpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZW1vdmVUaW1lciA9IHRvb2x0aXAucmVtb3ZlVGltZXI7XG5cbiAgaWYgKHJlbW92ZVRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHJlbW92ZVRpbWVyKTtcbiAgICB0b29sdGlwLnJlbW92ZVRpbWVyID0gbnVsbDtcbiAgfVxufTtcblxuVG9vbHRpcHMucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbih0b29sdGlwKSB7XG5cbiAgdG9vbHRpcCA9IHRoaXMuZ2V0KHRvb2x0aXApO1xuXG4gIGlmICghdG9vbHRpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuY2xlYXJUaW1lb3V0KHRvb2x0aXApO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0b29sdGlwLnJlbW92ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLnJlbW92ZSh0b29sdGlwKTtcbiAgfSwgdG9vbHRpcC50aW1lb3V0KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIHRvb2x0aXAgd2l0aCB0aGUgZ2l2ZW4gaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqL1xuVG9vbHRpcHMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGlkKSB7XG5cbiAgdmFyIHRvb2x0aXAgPSB0aGlzLmdldChpZCk7XG5cbiAgaWYgKHRvb2x0aXApIHtcbiAgICBkb21SZW1vdmUodG9vbHRpcC5odG1sKTtcbiAgICBkb21SZW1vdmUodG9vbHRpcC5odG1sQ29udGFpbmVyKTtcblxuICAgIGRlbGV0ZSB0b29sdGlwLmh0bWxDb250YWluZXI7XG5cbiAgICBkZWxldGUgdGhpcy5fdG9vbHRpcHNbdG9vbHRpcC5pZF07XG4gIH1cbn07XG5cblxuVG9vbHRpcHMucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgc2V0VmlzaWJsZSh0aGlzLl90b29sdGlwUm9vdCk7XG59O1xuXG5cblRvb2x0aXBzLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIHNldFZpc2libGUodGhpcy5fdG9vbHRpcFJvb3QsIGZhbHNlKTtcbn07XG5cblxuVG9vbHRpcHMucHJvdG90eXBlLl91cGRhdGVSb290ID0gZnVuY3Rpb24odmlld2JveCkge1xuICB2YXIgYSA9IHZpZXdib3guc2NhbGUgfHwgMTtcbiAgdmFyIGQgPSB2aWV3Ym94LnNjYWxlIHx8IDE7XG5cbiAgdmFyIG1hdHJpeCA9ICdtYXRyaXgoJyArIGEgKyAnLDAsMCwnICsgZCArICcsJyArICgtMSAqIHZpZXdib3gueCAqIGEpICsgJywnICsgKC0xICogdmlld2JveC55ICogZCkgKyAnKSc7XG5cbiAgdGhpcy5fdG9vbHRpcFJvb3Quc3R5bGUudHJhbnNmb3JtID0gbWF0cml4O1xuICB0aGlzLl90b29sdGlwUm9vdC5zdHlsZVsnLW1zLXRyYW5zZm9ybSddID0gbWF0cml4O1xufTtcblxuXG5Ub29sdGlwcy5wcm90b3R5cGUuX2FkZFRvb2x0aXAgPSBmdW5jdGlvbih0b29sdGlwKSB7XG5cbiAgdmFyIGlkID0gdG9vbHRpcC5pZCxcbiAgICAgIGh0bWwgPSB0b29sdGlwLmh0bWwsXG4gICAgICBodG1sQ29udGFpbmVyLFxuICAgICAgdG9vbHRpcFJvb3QgPSB0aGlzLl90b29sdGlwUm9vdDtcblxuICAvLyB1bndyYXAganF1ZXJ5IChmb3IgdGhvc2Ugd2hvIG5lZWQgaXQpXG4gIGlmIChodG1sLmdldCAmJiBodG1sLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5qcXVlcnkpIHtcbiAgICBodG1sID0gaHRtbC5nZXQoMCk7XG4gIH1cblxuICAvLyBjcmVhdGUgcHJvcGVyIGh0bWwgZWxlbWVudHMgZnJvbVxuICAvLyB0b29sdGlwIEhUTUwgc3RyaW5nc1xuICBpZiAoaXNTdHJpbmcoaHRtbCkpIHtcbiAgICBodG1sID0gZG9taWZ5KGh0bWwpO1xuICB9XG5cbiAgaHRtbENvbnRhaW5lciA9IGRvbWlmeSgnPGRpdiBkYXRhLXRvb2x0aXAtaWQ9XCInICsgaWQgKyAnXCIgY2xhc3M9XCInICsgdG9vbHRpcENsYXNzICsgJ1wiIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlXCI+Jyk7XG5cbiAgaHRtbENvbnRhaW5lci5hcHBlbmRDaGlsZChodG1sKTtcblxuICBpZiAodG9vbHRpcC50eXBlKSB7XG4gICAgZG9tQ2xhc3NlcyhodG1sQ29udGFpbmVyKS5hZGQoJ2Rqcy10b29sdGlwLScgKyB0b29sdGlwLnR5cGUpO1xuICB9XG5cbiAgaWYgKHRvb2x0aXAuY2xhc3NOYW1lKSB7XG4gICAgZG9tQ2xhc3NlcyhodG1sQ29udGFpbmVyKS5hZGQodG9vbHRpcC5jbGFzc05hbWUpO1xuICB9XG5cbiAgdG9vbHRpcC5odG1sQ29udGFpbmVyID0gaHRtbENvbnRhaW5lcjtcblxuICB0b29sdGlwUm9vdC5hcHBlbmRDaGlsZChodG1sQ29udGFpbmVyKTtcblxuICB0aGlzLl90b29sdGlwc1tpZF0gPSB0b29sdGlwO1xuXG4gIHRoaXMuX3VwZGF0ZVRvb2x0aXAodG9vbHRpcCk7XG59O1xuXG5cblRvb2x0aXBzLnByb3RvdHlwZS5fdXBkYXRlVG9vbHRpcCA9IGZ1bmN0aW9uKHRvb2x0aXApIHtcblxuICB2YXIgcG9zaXRpb24gPSB0b29sdGlwLnBvc2l0aW9uLFxuICAgICAgaHRtbENvbnRhaW5lciA9IHRvb2x0aXAuaHRtbENvbnRhaW5lcjtcblxuICAvLyB1cGRhdGUgb3ZlcmxheSBodG1sIGJhc2VkIG9uIHRvb2x0aXAgeCwgeVxuXG4gIHNldFBvc2l0aW9uKGh0bWxDb250YWluZXIsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xufTtcblxuXG5Ub29sdGlwcy5wcm90b3R5cGUuX3VwZGF0ZVRvb2x0aXBWaXNpYmlsdHkgPSBmdW5jdGlvbih2aWV3Ym94KSB7XG5cbiAgZm9yRWFjaCh0aGlzLl90b29sdGlwcywgZnVuY3Rpb24odG9vbHRpcCkge1xuICAgIHZhciBzaG93ID0gdG9vbHRpcC5zaG93LFxuICAgICAgICBodG1sQ29udGFpbmVyID0gdG9vbHRpcC5odG1sQ29udGFpbmVyLFxuICAgICAgICB2aXNpYmxlID0gdHJ1ZTtcblxuICAgIGlmIChzaG93KSB7XG4gICAgICBpZiAoc2hvdy5taW5ab29tID4gdmlld2JveC5zY2FsZSB8fFxuICAgICAgICAgIHNob3cubWF4Wm9vbSA8IHZpZXdib3guc2NhbGUpIHtcbiAgICAgICAgdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzZXRWaXNpYmxlKGh0bWxDb250YWluZXIsIHZpc2libGUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5Ub29sdGlwcy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gc2Nyb2xsL3pvb20gaW50ZWdyYXRpb25cblxuICBmdW5jdGlvbiB1cGRhdGVWaWV3Ym94KHZpZXdib3gpIHtcbiAgICBzZWxmLl91cGRhdGVSb290KHZpZXdib3gpO1xuICAgIHNlbGYuX3VwZGF0ZVRvb2x0aXBWaXNpYmlsdHkodmlld2JveCk7XG5cbiAgICBzZWxmLnNob3coKTtcbiAgfVxuXG4gIHRoaXMuX2V2ZW50QnVzLm9uKCdjYW52YXMudmlld2JveC5jaGFuZ2luZycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgc2VsZi5oaWRlKCk7XG4gIH0pO1xuXG4gIHRoaXMuX2V2ZW50QnVzLm9uKCdjYW52YXMudmlld2JveC5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB1cGRhdGVWaWV3Ym94KGV2ZW50LnZpZXdib3gpO1xuICB9KTtcbn07XG4iLCJpbXBvcnQgVG9vbHRpcHMgZnJvbSAnLi9Ub29sdGlwcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ3Rvb2x0aXBzJyBdLFxuICB0b29sdGlwczogWyAndHlwZScsIFRvb2x0aXBzIF1cbn07IiwiaW1wb3J0IHtcbiAgYXBwZW5kIGFzIHN2Z0FwcGVuZCxcbiAgYXR0ciBhcyBzdmdBdHRyLFxuICBjcmVhdGUgYXMgc3ZnQ3JlYXRlXG59IGZyb20gJ3Rpbnktc3ZnJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUb3VjaEZpeChjYW52YXMsIGV2ZW50QnVzKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGV2ZW50QnVzLm9uKCdjYW52YXMuaW5pdCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBzZWxmLmFkZEJCb3hNYXJrZXIoZS5zdmcpO1xuICB9KTtcbn1cblxuVG91Y2hGaXguJGluamVjdCA9IFsgJ2NhbnZhcycsICdldmVudEJ1cycgXTtcblxuXG4vKipcbiAqIFNhZmFyaSBtb2JpbGUgKGlPUyA3KSBkb2VzIG5vdCBmaXJlIHRvdWNoc3RhcnQgZXZlbnQgaW4gPFNWRz4gZWxlbWVudFxuICogaWYgdGhlcmUgaXMgbm8gc2hhcGUgYmV0d2VlbiAwLDAgYW5kIHZpZXdwb3J0IGVsZW1lbnRzIG9yaWdpbi5cbiAqXG4gKiBTbyB0b3VjaHN0YXJ0IGV2ZW50IGlzIG9ubHkgZmlyZWQgd2hlbiB0aGUgPGcgY2xhc3M9XCJ2aWV3cG9ydFwiPiBlbGVtZW50IHdhcyBoaXQuXG4gKiBQdXR0aW5nIGFuIGVsZW1lbnQgb3ZlciBhbmQgYmVsb3cgdGhlICd2aWV3cG9ydCcgZml4ZXMgdGhhdCBiZWhhdmlvci5cbiAqL1xuVG91Y2hGaXgucHJvdG90eXBlLmFkZEJCb3hNYXJrZXIgPSBmdW5jdGlvbihzdmcpIHtcblxuICB2YXIgbWFya2VyU3R5bGUgPSB7XG4gICAgZmlsbDogJ25vbmUnLFxuICAgIGNsYXNzOiAnb3V0ZXItYm91bmQtbWFya2VyJ1xuICB9O1xuXG4gIHZhciByZWN0MSA9IHN2Z0NyZWF0ZSgncmVjdCcpO1xuICBzdmdBdHRyKHJlY3QxLCB7XG4gICAgeDogLTEwMDAwLFxuICAgIHk6IDEwMDAwLFxuICAgIHdpZHRoOiAxMCxcbiAgICBoZWlnaHQ6IDEwXG4gIH0pO1xuICBzdmdBdHRyKHJlY3QxLCBtYXJrZXJTdHlsZSk7XG5cbiAgc3ZnQXBwZW5kKHN2ZywgcmVjdDEpO1xuXG4gIHZhciByZWN0MiA9IHN2Z0NyZWF0ZSgncmVjdCcpO1xuICBzdmdBdHRyKHJlY3QyLCB7XG4gICAgeDogMTAwMDAsXG4gICAgeTogMTAwMDAsXG4gICAgd2lkdGg6IDEwLFxuICAgIGhlaWdodDogMTBcbiAgfSk7XG4gIHN2Z0F0dHIocmVjdDIsIG1hcmtlclN0eWxlKTtcblxuICBzdmdBcHBlbmQoc3ZnLCByZWN0Mik7XG59O1xuIiwiaW1wb3J0IHtcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGV2ZW50IGFzIGRvbUV2ZW50LFxuICBjbG9zZXN0IGFzIGRvbUNsb3Nlc3Rcbn0gZnJvbSAnbWluLWRvbSc7XG5cbmltcG9ydCBIYW1tZXIgZnJvbSAnaGFtbWVyanMnO1xuXG5pbXBvcnQge1xuICB0b1BvaW50XG59IGZyb20gJy4uLy4uL3V0aWwvRXZlbnQnO1xuXG52YXIgTUlOX1pPT00gPSAwLjIsXG4gICAgTUFYX1pPT00gPSA0O1xuXG52YXIgbW91c2VFdmVudHMgPSBbXG4gICdtb3VzZWRvd24nLFxuICAnbW91c2V1cCcsXG4gICdtb3VzZW92ZXInLFxuICAnbW91c2VvdXQnLFxuICAnY2xpY2snLFxuICAnZGJsY2xpY2snXG5dO1xuXG5mdW5jdGlvbiBsb2coKSB7XG5cbiAgLy8gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0KHNlcnZpY2UsIGluamVjdG9yKSB7XG4gIHJldHVybiBpbmplY3Rvci5nZXQoc2VydmljZSwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBzdG9wRXZlbnQoZXZlbnQpIHtcblxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIGlmICh0eXBlb2YgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQuc3JjRXZlbnQgJiYgdHlwZW9mIGV2ZW50LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgLy8gaVBob25lICYgaVBhZFxuICAgIGV2ZW50LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVRvdWNoUmVjb2duaXplcihub2RlKSB7XG5cbiAgZnVuY3Rpb24gc3RvcE1vdXNlKGV2ZW50KSB7XG5cbiAgICBmb3JFYWNoKG1vdXNlRXZlbnRzLCBmdW5jdGlvbihlKSB7XG4gICAgICBkb21FdmVudC5iaW5kKG5vZGUsIGUsIHN0b3BFdmVudCwgdHJ1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhbGxvd01vdXNlKGV2ZW50KSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGZvckVhY2gobW91c2VFdmVudHMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZG9tRXZlbnQudW5iaW5kKG5vZGUsIGUsIHN0b3BFdmVudCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9LCA1MDApO1xuICB9XG5cbiAgZG9tRXZlbnQuYmluZChub2RlLCAndG91Y2hzdGFydCcsIHN0b3BNb3VzZSwgdHJ1ZSk7XG4gIGRvbUV2ZW50LmJpbmQobm9kZSwgJ3RvdWNoZW5kJywgYWxsb3dNb3VzZSwgdHJ1ZSk7XG4gIGRvbUV2ZW50LmJpbmQobm9kZSwgJ3RvdWNoY2FuY2VsJywgYWxsb3dNb3VzZSwgdHJ1ZSk7XG5cbiAgLy8gQSB0b3VjaCBldmVudCByZWNvZ25pemVyIHRoYXQgaGFuZGxlc1xuICAvLyB0b3VjaCBldmVudHMgb25seSAod2Uga25vdywgd2UgY2FuIGFscmVhZHkgaGFuZGxlXG4gIC8vIG1vdXNlIGV2ZW50cyBvdXQgb2YgdGhlIGJveClcblxuICB2YXIgcmVjb2duaXplciA9IG5ldyBIYW1tZXIuTWFuYWdlcihub2RlLCB7XG4gICAgaW5wdXRDbGFzczogSGFtbWVyLlRvdWNoSW5wdXQsXG4gICAgcmVjb2duaXplcnM6IFtdLFxuICAgIGRvbUV2ZW50czogdHJ1ZVxuICB9KTtcblxuXG4gIHZhciB0YXAgPSBuZXcgSGFtbWVyLlRhcCgpO1xuICB2YXIgcGFuID0gbmV3IEhhbW1lci5QYW4oeyB0aHJlc2hvbGQ6IDEwIH0pO1xuICB2YXIgcHJlc3MgPSBuZXcgSGFtbWVyLlByZXNzKCk7XG4gIHZhciBwaW5jaCA9IG5ldyBIYW1tZXIuUGluY2goKTtcblxuICB2YXIgZG91YmxlVGFwID0gbmV3IEhhbW1lci5UYXAoeyBldmVudDogJ2RvdWJsZXRhcCcsIHRhcHM6IDIgfSk7XG5cbiAgcGluY2gucmVxdWlyZUZhaWx1cmUocGFuKTtcbiAgcGluY2gucmVxdWlyZUZhaWx1cmUocHJlc3MpO1xuXG4gIHJlY29nbml6ZXIuYWRkKFsgcGFuLCBwcmVzcywgcGluY2gsIGRvdWJsZVRhcCwgdGFwIF0pO1xuXG4gIHJlY29nbml6ZXIucmVzZXQgPSBmdW5jdGlvbihmb3JjZSkge1xuICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnMsXG4gICAgICAgIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG5cbiAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nKCdyZWNvZ25pemVyJywgJ3N0b3AnKTtcblxuICAgIHJlY29nbml6ZXIuc3RvcChmb3JjZSk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIHI7XG5cbiAgICAgIGxvZygncmVjb2duaXplcicsICdyZXNldCcpO1xuICAgICAgZm9yIChpID0gMDsgKHIgPSByZWNvZ25pemVyc1tpXSk7IGkrKykge1xuICAgICAgICByLnJlc2V0KCk7XG4gICAgICAgIHIuc3RhdGUgPSA4OyAvLyBGQUlMRUQgU1RBVEVcbiAgICAgIH1cblxuICAgICAgc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICB9LCAwKTtcbiAgfTtcblxuICByZWNvZ25pemVyLm9uKCdoYW1tZXIuaW5wdXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIGlmIChldmVudC5zcmNFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZWNvZ25pemVyLnJlc2V0KHRydWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlY29nbml6ZXI7XG59XG5cbi8qKlxuICogQSBwbHVnaW4gdGhhdCBwcm92aWRlcyB0b3VjaCBldmVudHMgZm9yIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0ludGVyYWN0aW9uRXZlbnRzfSBpbnRlcmFjdGlvbkV2ZW50c1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUb3VjaEludGVyYWN0aW9uRXZlbnRzKFxuICAgIGluamVjdG9yLCBjYW52YXMsIGV2ZW50QnVzLFxuICAgIGVsZW1lbnRSZWdpc3RyeSwgaW50ZXJhY3Rpb25FdmVudHMpIHtcblxuICAvLyBvcHRpb25hbCBpbnRlZ3JhdGlvbnNcbiAgdmFyIGRyYWdnaW5nID0gZ2V0KCdkcmFnZ2luZycsIGluamVjdG9yKSxcbiAgICAgIG1vdmUgPSBnZXQoJ21vdmUnLCBpbmplY3RvciksXG4gICAgICBjb250ZXh0UGFkID0gZ2V0KCdjb250ZXh0UGFkJywgaW5qZWN0b3IpLFxuICAgICAgcGFsZXR0ZSA9IGdldCgncGFsZXR0ZScsIGluamVjdG9yKTtcblxuICAvLyB0aGUgdG91Y2ggcmVjb2duaXplclxuICB2YXIgcmVjb2duaXplcjtcblxuICBmdW5jdGlvbiBoYW5kbGVyKHR5cGUpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgbG9nKCdlbGVtZW50JywgdHlwZSwgZXZlbnQpO1xuXG4gICAgICBpbnRlcmFjdGlvbkV2ZW50cy5maXJlKHR5cGUsIGV2ZW50KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0R2Z4KHRhcmdldCkge1xuICAgIHZhciBub2RlID0gZG9tQ2xvc2VzdCh0YXJnZXQsICdzdmcsIC5kanMtZWxlbWVudCcsIHRydWUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEV2ZW50cyhzdmcpIHtcblxuICAgIC8vIHRvdWNoIHJlY29nbml6ZXJcbiAgICByZWNvZ25pemVyID0gY3JlYXRlVG91Y2hSZWNvZ25pemVyKHN2Zyk7XG5cbiAgICByZWNvZ25pemVyLm9uKCdkb3VibGV0YXAnLCBoYW5kbGVyKCdlbGVtZW50LmRibGNsaWNrJykpO1xuXG4gICAgcmVjb2duaXplci5vbigndGFwJywgaGFuZGxlcignZWxlbWVudC5jbGljaycpKTtcblxuICAgIGZ1bmN0aW9uIHN0YXJ0R3JhYkNhbnZhcyhldmVudCkge1xuXG4gICAgICBsb2coJ2NhbnZhcycsICdncmFiIHN0YXJ0Jyk7XG5cbiAgICAgIHZhciBseCA9IDAsIGx5ID0gMDtcblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKGUpIHtcblxuICAgICAgICB2YXIgZHggPSBlLmRlbHRhWCAtIGx4LFxuICAgICAgICAgICAgZHkgPSBlLmRlbHRhWSAtIGx5O1xuXG4gICAgICAgIGNhbnZhcy5zY3JvbGwoeyBkeDogZHgsIGR5OiBkeSB9KTtcblxuICAgICAgICBseCA9IGUuZGVsdGFYO1xuICAgICAgICBseSA9IGUuZGVsdGFZO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbmQoZSkge1xuICAgICAgICByZWNvZ25pemVyLm9mZigncGFubW92ZScsIHVwZGF0ZSk7XG4gICAgICAgIHJlY29nbml6ZXIub2ZmKCdwYW5lbmQnLCBlbmQpO1xuICAgICAgICByZWNvZ25pemVyLm9mZigncGFuY2FuY2VsJywgZW5kKTtcblxuICAgICAgICBsb2coJ2NhbnZhcycsICdncmFiIGVuZCcpO1xuICAgICAgfVxuXG4gICAgICByZWNvZ25pemVyLm9uKCdwYW5tb3ZlJywgdXBkYXRlKTtcbiAgICAgIHJlY29nbml6ZXIub24oJ3BhbmVuZCcsIGVuZCk7XG4gICAgICByZWNvZ25pemVyLm9uKCdwYW5jYW5jZWwnLCBlbmQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0R3JhYihldmVudCkge1xuXG4gICAgICB2YXIgZ2Z4ID0gZ2V0R2Z4KGV2ZW50LnRhcmdldCksXG4gICAgICAgICAgZWxlbWVudCA9IGdmeCAmJiBlbGVtZW50UmVnaXN0cnkuZ2V0KGdmeCk7XG5cbiAgICAgIC8vIHJlY29nbml6ZXJcbiAgICAgIGlmIChtb3ZlICYmIGNhbnZhcy5nZXRSb290RWxlbWVudCgpICE9PSBlbGVtZW50KSB7XG4gICAgICAgIGxvZygnZWxlbWVudCcsICdtb3ZlIHN0YXJ0JywgZWxlbWVudCwgZXZlbnQsIHRydWUpO1xuICAgICAgICByZXR1cm4gbW92ZS5zdGFydChldmVudCwgZWxlbWVudCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydEdyYWJDYW52YXMoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0Wm9vbShlKSB7XG5cbiAgICAgIGxvZygnY2FudmFzJywgJ3pvb20gc3RhcnQnKTtcblxuICAgICAgdmFyIHpvb20gPSBjYW52YXMuem9vbSgpLFxuICAgICAgICAgIG1pZCA9IGUuY2VudGVyO1xuXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoZSkge1xuXG4gICAgICAgIHZhciByYXRpbyA9IDEgLSAoMSAtIGUuc2NhbGUpIC8gMS41MCxcbiAgICAgICAgICAgIG5ld1pvb20gPSBNYXRoLm1heChNSU5fWk9PTSwgTWF0aC5taW4oTUFYX1pPT00sIHJhdGlvICogem9vbSkpO1xuXG4gICAgICAgIGNhbnZhcy56b29tKG5ld1pvb20sIG1pZCk7XG5cbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbmQoZSkge1xuICAgICAgICByZWNvZ25pemVyLm9mZigncGluY2htb3ZlJywgdXBkYXRlKTtcbiAgICAgICAgcmVjb2duaXplci5vZmYoJ3BpbmNoZW5kJywgZW5kKTtcbiAgICAgICAgcmVjb2duaXplci5vZmYoJ3BpbmNoY2FuY2VsJywgZW5kKTtcblxuICAgICAgICByZWNvZ25pemVyLnJlc2V0KHRydWUpO1xuXG4gICAgICAgIGxvZygnY2FudmFzJywgJ3pvb20gZW5kJyk7XG4gICAgICB9XG5cbiAgICAgIHJlY29nbml6ZXIub24oJ3BpbmNobW92ZScsIHVwZGF0ZSk7XG4gICAgICByZWNvZ25pemVyLm9uKCdwaW5jaGVuZCcsIGVuZCk7XG4gICAgICByZWNvZ25pemVyLm9uKCdwaW5jaGNhbmNlbCcsIGVuZCk7XG4gICAgfVxuXG4gICAgcmVjb2duaXplci5vbigncGFuc3RhcnQnLCBzdGFydEdyYWIpO1xuICAgIHJlY29nbml6ZXIub24oJ3ByZXNzJywgc3RhcnRHcmFiKTtcblxuICAgIHJlY29nbml6ZXIub24oJ3BpbmNoc3RhcnQnLCBzdGFydFpvb20pO1xuICB9XG5cbiAgaWYgKGRyYWdnaW5nKSB7XG5cbiAgICAvLyBzaW11bGF0ZSBob3ZlciBkdXJpbmcgZHJhZ2dpbmdcbiAgICBldmVudEJ1cy5vbignZHJhZy5tb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICBpZiAoIW9yaWdpbmFsRXZlbnQgfHwgb3JpZ2luYWxFdmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zaXRpb24gPSB0b1BvaW50KG9yaWdpbmFsRXZlbnQpO1xuXG4gICAgICAvLyB0aGlzIGdldHMgcmVhbGx5IGV4cGVuc2l2ZSAuLi5cbiAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwb3NpdGlvbi54LCBwb3NpdGlvbi55KSxcbiAgICAgICAgICBnZnggPSBnZXRHZngobm9kZSksXG4gICAgICAgICAgZWxlbWVudCA9IGdmeCAmJiBlbGVtZW50UmVnaXN0cnkuZ2V0KGdmeCk7XG5cbiAgICAgIGlmIChlbGVtZW50ICE9PSBldmVudC5ob3Zlcikge1xuICAgICAgICBpZiAoZXZlbnQuaG92ZXIpIHtcbiAgICAgICAgICBkcmFnZ2luZy5vdXQoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICBkcmFnZ2luZy5ob3Zlcih7IGVsZW1lbnQ6IGVsZW1lbnQsIGdmeDogZ2Z4IH0pO1xuXG4gICAgICAgICAgZXZlbnQuaG92ZXIgPSBlbGVtZW50O1xuICAgICAgICAgIGV2ZW50LmhvdmVyR2Z4ID0gZ2Z4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoY29udGV4dFBhZCkge1xuXG4gICAgZXZlbnRCdXMub24oJ2NvbnRleHRQYWQuY3JlYXRlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBub2RlID0gZXZlbnQucGFkLmh0bWw7XG5cbiAgICAgIC8vIHRvdWNoIHJlY29nbml6ZXJcbiAgICAgIHZhciBwYWRSZWNvZ25pemVyID0gY3JlYXRlVG91Y2hSZWNvZ25pemVyKG5vZGUpO1xuXG4gICAgICBwYWRSZWNvZ25pemVyLm9uKCdwYW5zdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGxvZygnY29udGV4dC1wYWQnLCAncGFuc3RhcnQnLCBldmVudCk7XG4gICAgICAgIGNvbnRleHRQYWQudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXZlbnQsIHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHBhZFJlY29nbml6ZXIub24oJ3ByZXNzJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgbG9nKCdjb250ZXh0LXBhZCcsICdwcmVzcycsIGV2ZW50KTtcbiAgICAgICAgY29udGV4dFBhZC50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldmVudCwgdHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgcGFkUmVjb2duaXplci5vbigndGFwJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgbG9nKCdjb250ZXh0LXBhZCcsICd0YXAnLCBldmVudCk7XG4gICAgICAgIGNvbnRleHRQYWQudHJpZ2dlcignY2xpY2snLCBldmVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYWxldHRlKSB7XG4gICAgZXZlbnRCdXMub24oJ3BhbGV0dGUuY3JlYXRlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBub2RlID0gZXZlbnQuY29udGFpbmVyO1xuXG4gICAgICAvLyB0b3VjaCByZWNvZ25pemVyXG4gICAgICB2YXIgcGFkUmVjb2duaXplciA9IGNyZWF0ZVRvdWNoUmVjb2duaXplcihub2RlKTtcblxuICAgICAgcGFkUmVjb2duaXplci5vbigncGFuc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBsb2coJ3BhbGV0dGUnLCAncGFuc3RhcnQnLCBldmVudCk7XG4gICAgICAgIHBhbGV0dGUudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXZlbnQsIHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHBhZFJlY29nbml6ZXIub24oJ3ByZXNzJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgbG9nKCdwYWxldHRlJywgJ3ByZXNzJywgZXZlbnQpO1xuICAgICAgICBwYWxldHRlLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2ZW50LCB0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBwYWRSZWNvZ25pemVyLm9uKCd0YXAnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBsb2coJ3BhbGV0dGUnLCAndGFwJywgZXZlbnQpO1xuICAgICAgICBwYWxldHRlLnRyaWdnZXIoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBldmVudEJ1cy5vbignY2FudmFzLmluaXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIGluaXRFdmVudHMoZXZlbnQuc3ZnKTtcbiAgfSk7XG59XG5cblxuVG91Y2hJbnRlcmFjdGlvbkV2ZW50cy4kaW5qZWN0ID0gW1xuICAnaW5qZWN0b3InLFxuICAnY2FudmFzJyxcbiAgJ2V2ZW50QnVzJyxcbiAgJ2VsZW1lbnRSZWdpc3RyeScsXG4gICdpbnRlcmFjdGlvbkV2ZW50cycsXG4gICd0b3VjaEZpeCdcbl07XG4iLCJpbXBvcnQgSW50ZXJhY3Rpb25FdmVudHNNb2R1bGUgZnJvbSAnLi4vaW50ZXJhY3Rpb24tZXZlbnRzJztcblxuaW1wb3J0IFRvdWNoSW50ZXJhY3Rpb25FdmVudHMgZnJvbSAnLi9Ub3VjaEludGVyYWN0aW9uRXZlbnRzJztcbmltcG9ydCBUb3VjaEZpeCBmcm9tICcuL1RvdWNoRml4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2RlcGVuZHNfXzogWyBJbnRlcmFjdGlvbkV2ZW50c01vZHVsZSBdLFxuICBfX2luaXRfXzogWyAndG91Y2hJbnRlcmFjdGlvbkV2ZW50cycgXSxcbiAgdG91Y2hJbnRlcmFjdGlvbkV2ZW50czogWyAndHlwZScsIFRvdWNoSW50ZXJhY3Rpb25FdmVudHMgXSxcbiAgdG91Y2hGaXg6IFsgJ3R5cGUnLCBUb3VjaEZpeCBdXG59OyIsImltcG9ydCB0cmFuc2xhdGUgZnJvbSAnLi90cmFuc2xhdGUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHRyYW5zbGF0ZTogWyAndmFsdWUnLCB0cmFuc2xhdGUgXVxufTsiLCIvKipcbiAqIEEgc2ltcGxlIHRyYW5zbGF0aW9uIHN0dWIgdG8gYmUgdXNlZCBmb3IgbXVsdGktbGFuZ3VhZ2Ugc3VwcG9ydFxuICogaW4gZGlhZ3JhbXMuIENhbiBiZSBlYXNpbHkgcmVwbGFjZWQgd2l0aCBhIG1vcmUgc29waGlzdGljYXRlZFxuICogc29sdXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyB1c2UgaXQgaW5zaWRlIGFueSBkaWFncmFtIGNvbXBvbmVudCBieSBpbmplY3RpbmcgYHRyYW5zbGF0ZWAuXG4gKlxuICogZnVuY3Rpb24gTXlTZXJ2aWNlKHRyYW5zbGF0ZSkge1xuICogICBhbGVydCh0cmFuc2xhdGUoJ0hFTExPIHt5b3V9JywgeyB5b3U6ICdZb3UhJyB9KSk7XG4gKiB9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIHRvIGludGVycG9sYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcGxhY2VtZW50c10gYSBtYXAgd2l0aCBzdWJzdGl0dXRlc1xuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHRyYW5zbGF0ZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zbGF0ZSh0ZW1wbGF0ZSwgcmVwbGFjZW1lbnRzKSB7XG5cbiAgcmVwbGFjZW1lbnRzID0gcmVwbGFjZW1lbnRzIHx8IHt9O1xuXG4gIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC97KFtefV0rKX0vZywgZnVuY3Rpb24oXywga2V5KSB7XG4gICAgcmV0dXJuIHJlcGxhY2VtZW50c1trZXldIHx8ICd7JyArIGtleSArICd9JztcbiAgfSk7XG59IiwiaW1wb3J0IHtcbiAgZ2V0TWlkXG59IGZyb20gJy4vTGF5b3V0VXRpbCc7XG5cblxuLyoqXG4gKiBBIGJhc2UgY29ubmVjdGlvbiBsYXlvdXRlciBpbXBsZW1lbnRhdGlvblxuICogdGhhdCBsYXlvdXRzIHRoZSBjb25uZWN0aW9uIGJ5IGRpcmVjdGx5IGNvbm5lY3RpbmdcbiAqIG1pZChzb3VyY2UpICsgbWlkKHRhcmdldCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJhc2VMYXlvdXRlcigpIHt9XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIG5ldyBsYXlvdXRlZCB3YXlwb2ludHMgZm9yIHRoZSBnaXZlbiBjb25uZWN0aW9uLlxuICpcbiAqIFRoZSBjb25uZWN0aW9uIHBhc3NlZCBpcyBzdGlsbCB1bmNoYW5nZWQ7IHlvdSBtYXkgZmlndXJlIG91dCBhYm91dFxuICogdGhlIG5ldyBjb25uZWN0aW9uIHN0YXJ0IC8gZW5kIHZpYSB0aGUgbGF5b3V0IGhpbnRzIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSB7ZGpzLm1vZGVsLkNvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGludHNdXG4gKiBAcGFyYW0ge1BvaW50fSBbaGludHMuY29ubmVjdGlvblN0YXJ0XVxuICogQHBhcmFtIHtQb2ludH0gW2hpbnRzLmNvbm5lY3Rpb25FbmRdXG4gKiBAcGFyYW0ge1BvaW50fSBbaGludHMuc291cmNlXVxuICogQHBhcmFtIHtQb2ludH0gW2hpbnRzLnRhcmdldF1cbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxQb2ludD59IHRoZSBsYXlvdXRlZCBjb25uZWN0aW9uIHdheXBvaW50c1xuICovXG5CYXNlTGF5b3V0ZXIucHJvdG90eXBlLmxheW91dENvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uLCBoaW50cykge1xuXG4gIGhpbnRzID0gaGludHMgfHwge307XG5cbiAgcmV0dXJuIFtcbiAgICBoaW50cy5jb25uZWN0aW9uU3RhcnQgfHwgZ2V0TWlkKGhpbnRzLnNvdXJjZSB8fCBjb25uZWN0aW9uLnNvdXJjZSksXG4gICAgaGludHMuY29ubmVjdGlvbkVuZCB8fCBnZXRNaWQoaGludHMudGFyZ2V0IHx8IGNvbm5lY3Rpb24udGFyZ2V0KVxuICBdO1xufTtcbiIsImltcG9ydCB7XG4gIGFzc2lnblxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIGdldEVsZW1lbnRMaW5lSW50ZXJzZWN0aW9uXG59IGZyb20gJy4vTGF5b3V0VXRpbCc7XG5cblxuZnVuY3Rpb24gZG9ja2luZ1RvUG9pbnQoZG9ja2luZykge1xuXG4gIC8vIHVzZSB0aGUgZG9ja2luZ3MgYWN0dWFsIHBvaW50IGFuZFxuICAvLyByZXRhaW4gdGhlIG9yaWdpbmFsIGRvY2tpbmdcbiAgcmV0dXJuIGFzc2lnbih7IG9yaWdpbmFsOiBkb2NraW5nLnBvaW50Lm9yaWdpbmFsIHx8IGRvY2tpbmcucG9pbnQgfSwgZG9ja2luZy5hY3R1YWwpO1xufVxuXG5cbi8qKlxuICogQSB7QGxpbmsgQ29ubmVjdGlvbkRvY2tpbmd9IHRoYXQgY3JvcHMgY29ubmVjdGlvbiB3YXlwb2ludHMgYmFzZWQgb25cbiAqIHRoZSBwYXRoKHMpIG9mIHRoZSBjb25uZWN0aW9uIHNvdXJjZSBhbmQgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSB7ZGpzLmNvcmUuRWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ3JvcHBpbmdDb25uZWN0aW9uRG9ja2luZyhlbGVtZW50UmVnaXN0cnksIGdyYXBoaWNzRmFjdG9yeSkge1xuICB0aGlzLl9lbGVtZW50UmVnaXN0cnkgPSBlbGVtZW50UmVnaXN0cnk7XG4gIHRoaXMuX2dyYXBoaWNzRmFjdG9yeSA9IGdyYXBoaWNzRmFjdG9yeTtcbn1cblxuQ3JvcHBpbmdDb25uZWN0aW9uRG9ja2luZy4kaW5qZWN0ID0gWyAnZWxlbWVudFJlZ2lzdHJ5JywgJ2dyYXBoaWNzRmFjdG9yeScgXTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jIENvbm5lY3Rpb25Eb2NraW5nI2dldENyb3BwZWRXYXlwb2ludHNcbiAqL1xuQ3JvcHBpbmdDb25uZWN0aW9uRG9ja2luZy5wcm90b3R5cGUuZ2V0Q3JvcHBlZFdheXBvaW50cyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIHNvdXJjZSwgdGFyZ2V0KSB7XG5cbiAgc291cmNlID0gc291cmNlIHx8IGNvbm5lY3Rpb24uc291cmNlO1xuICB0YXJnZXQgPSB0YXJnZXQgfHwgY29ubmVjdGlvbi50YXJnZXQ7XG5cbiAgdmFyIHNvdXJjZURvY2tpbmcgPSB0aGlzLmdldERvY2tpbmdQb2ludChjb25uZWN0aW9uLCBzb3VyY2UsIHRydWUpLFxuICAgICAgdGFyZ2V0RG9ja2luZyA9IHRoaXMuZ2V0RG9ja2luZ1BvaW50KGNvbm5lY3Rpb24sIHRhcmdldCk7XG5cbiAgdmFyIGNyb3BwZWRXYXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cy5zbGljZShzb3VyY2VEb2NraW5nLmlkeCArIDEsIHRhcmdldERvY2tpbmcuaWR4KTtcblxuICBjcm9wcGVkV2F5cG9pbnRzLnVuc2hpZnQoZG9ja2luZ1RvUG9pbnQoc291cmNlRG9ja2luZykpO1xuICBjcm9wcGVkV2F5cG9pbnRzLnB1c2goZG9ja2luZ1RvUG9pbnQodGFyZ2V0RG9ja2luZykpO1xuXG4gIHJldHVybiBjcm9wcGVkV2F5cG9pbnRzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGNvbm5lY3Rpb24gZG9ja2luZyBwb2ludCBvbiB0aGUgc3BlY2lmaWVkIHNoYXBlXG4gKlxuICogQGluaGVyaXREb2MgQ29ubmVjdGlvbkRvY2tpbmcjZ2V0RG9ja2luZ1BvaW50XG4gKi9cbkNyb3BwaW5nQ29ubmVjdGlvbkRvY2tpbmcucHJvdG90eXBlLmdldERvY2tpbmdQb2ludCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIHNoYXBlLCBkb2NrU3RhcnQpIHtcblxuICB2YXIgd2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHMsXG4gICAgICBkb2NraW5nSWR4LFxuICAgICAgZG9ja2luZ1BvaW50LFxuICAgICAgY3JvcHBlZFBvaW50O1xuXG4gIGRvY2tpbmdJZHggPSBkb2NrU3RhcnQgPyAwIDogd2F5cG9pbnRzLmxlbmd0aCAtIDE7XG4gIGRvY2tpbmdQb2ludCA9IHdheXBvaW50c1tkb2NraW5nSWR4XTtcblxuICBjcm9wcGVkUG9pbnQgPSB0aGlzLl9nZXRJbnRlcnNlY3Rpb24oc2hhcGUsIGNvbm5lY3Rpb24sIGRvY2tTdGFydCk7XG5cbiAgcmV0dXJuIHtcbiAgICBwb2ludDogZG9ja2luZ1BvaW50LFxuICAgIGFjdHVhbDogY3JvcHBlZFBvaW50IHx8IGRvY2tpbmdQb2ludCxcbiAgICBpZHg6IGRvY2tpbmdJZHhcbiAgfTtcbn07XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbkNyb3BwaW5nQ29ubmVjdGlvbkRvY2tpbmcucHJvdG90eXBlLl9nZXRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihzaGFwZSwgY29ubmVjdGlvbiwgdGFrZUZpcnN0KSB7XG5cbiAgdmFyIHNoYXBlUGF0aCA9IHRoaXMuX2dldFNoYXBlUGF0aChzaGFwZSksXG4gICAgICBjb25uZWN0aW9uUGF0aCA9IHRoaXMuX2dldENvbm5lY3Rpb25QYXRoKGNvbm5lY3Rpb24pO1xuXG4gIHJldHVybiBnZXRFbGVtZW50TGluZUludGVyc2VjdGlvbihzaGFwZVBhdGgsIGNvbm5lY3Rpb25QYXRoLCB0YWtlRmlyc3QpO1xufTtcblxuQ3JvcHBpbmdDb25uZWN0aW9uRG9ja2luZy5wcm90b3R5cGUuX2dldENvbm5lY3Rpb25QYXRoID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICByZXR1cm4gdGhpcy5fZ3JhcGhpY3NGYWN0b3J5LmdldENvbm5lY3Rpb25QYXRoKGNvbm5lY3Rpb24pO1xufTtcblxuQ3JvcHBpbmdDb25uZWN0aW9uRG9ja2luZy5wcm90b3R5cGUuX2dldFNoYXBlUGF0aCA9IGZ1bmN0aW9uKHNoYXBlKSB7XG4gIHJldHVybiB0aGlzLl9ncmFwaGljc0ZhY3RvcnkuZ2V0U2hhcGVQYXRoKHNoYXBlKTtcbn07XG5cbkNyb3BwaW5nQ29ubmVjdGlvbkRvY2tpbmcucHJvdG90eXBlLl9nZXRHZnggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCk7XG59O1xuIiwiaW1wb3J0IHtcbiAgaXNPYmplY3QsXG4gIHNvcnRCeVxufSBmcm9tICdtaW4tZGFzaCc7XG5cbmltcG9ydCB7XG4gIHBvaW50RGlzdGFuY2UsXG4gIHBvaW50c09uTGluZVxufSBmcm9tICcuLi91dGlsL0dlb21ldHJ5JztcblxuaW1wb3J0IGludGVyc2VjdFBhdGhzIGZyb20gJ3BhdGgtaW50ZXJzZWN0aW9uJztcblxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRCb3VuZHMoYm91bmRzKSB7XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZChib3VuZHMueCksXG4gICAgeTogTWF0aC5yb3VuZChib3VuZHMueSksXG4gICAgd2lkdGg6IE1hdGgucm91bmQoYm91bmRzLndpZHRoKSxcbiAgICBoZWlnaHQ6IE1hdGgucm91bmQoYm91bmRzLmhlaWdodClcbiAgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRQb2ludChwb2ludCkge1xuXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZChwb2ludC54KSxcbiAgICB5OiBNYXRoLnJvdW5kKHBvaW50LnkpXG4gIH07XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBib3VuZHMgdG8gYSB7IHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCB9IGRlc2NyaXB0b3IuXG4gKlxuICogQHBhcmFtIHtCb3VuZHN8UG9pbnR9IGJvdW5kc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzVFJCTChib3VuZHMpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGJvdW5kcy55LFxuICAgIHJpZ2h0OiBib3VuZHMueCArIChib3VuZHMud2lkdGggfHwgMCksXG4gICAgYm90dG9tOiBib3VuZHMueSArIChib3VuZHMuaGVpZ2h0IHx8IDApLFxuICAgIGxlZnQ6IGJvdW5kcy54XG4gIH07XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSB0byBhbiBvYmplY3RzIGJvdW5kcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdHJibFxuICpcbiAqIEByZXR1cm4ge0JvdW5kc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzQm91bmRzKHRyYmwpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB0cmJsLmxlZnQsXG4gICAgeTogdHJibC50b3AsXG4gICAgd2lkdGg6IHRyYmwucmlnaHQgLSB0cmJsLmxlZnQsXG4gICAgaGVpZ2h0OiB0cmJsLmJvdHRvbSAtIHRyYmwudG9wXG4gIH07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIG1pZCBvZiB0aGUgZ2l2ZW4gYm91bmRzIG9yIHBvaW50LlxuICpcbiAqIEBwYXJhbSB7Qm91bmRzfFBvaW50fSBib3VuZHNcbiAqXG4gKiBAcmV0dXJuIHtQb2ludH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pZChib3VuZHMpIHtcbiAgcmV0dXJuIHJvdW5kUG9pbnQoe1xuICAgIHg6IGJvdW5kcy54ICsgKGJvdW5kcy53aWR0aCB8fCAwKSAvIDIsXG4gICAgeTogYm91bmRzLnkgKyAoYm91bmRzLmhlaWdodCB8fCAwKSAvIDJcbiAgfSk7XG59XG5cblxuLy8gb3JpZW50YXRpb24gdXRpbHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEdldCBvcmllbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlIHdpdGggcmVzcGVjdCB0b1xuICogdGhlIHJlZmVyZW5jZSByZWN0YW5nbGUuXG4gKlxuICogQSBwYWRkaW5nIChwb3NpdGl2ZSBvciBuZWdhdGl2ZSkgbWF5IGJlIHBhc3NlZCB0byBpbmZsdWVuY2VcbiAqIGhvcml6b250YWwgLyB2ZXJ0aWNhbCBvcmllbnRhdGlvbiBhbmQgaW50ZXJzZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Qm91bmRzfSByZWN0XG4gKiBAcGFyYW0ge0JvdW5kc30gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge1BvaW50fG51bWJlcn0gcGFkZGluZ1xuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIG9yaWVudGF0aW9uOyBvbmUgb2YgdG9wLCB0b3AtbGVmdCwgbGVmdCwgLi4uLCBib3R0b20sIHJpZ2h0IG9yIGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9yaWVudGF0aW9uKHJlY3QsIHJlZmVyZW5jZSwgcGFkZGluZykge1xuXG4gIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG5cbiAgLy8gbWFrZSBzdXJlIHdlIGNhbiB1c2UgYW4gb2JqZWN0LCB0b29cbiAgLy8gZm9yIGluZGl2aWR1YWwgeyB4LCB5IH0gcGFkZGluZ1xuICBpZiAoIWlzT2JqZWN0KHBhZGRpbmcpKSB7XG4gICAgcGFkZGluZyA9IHsgeDogcGFkZGluZywgeTogcGFkZGluZyB9O1xuICB9XG5cblxuICB2YXIgcmVjdE9yaWVudGF0aW9uID0gYXNUUkJMKHJlY3QpLFxuICAgICAgcmVmZXJlbmNlT3JpZW50YXRpb24gPSBhc1RSQkwocmVmZXJlbmNlKTtcblxuICB2YXIgdG9wID0gcmVjdE9yaWVudGF0aW9uLmJvdHRvbSArIHBhZGRpbmcueSA8PSByZWZlcmVuY2VPcmllbnRhdGlvbi50b3AsXG4gICAgICByaWdodCA9IHJlY3RPcmllbnRhdGlvbi5sZWZ0IC0gcGFkZGluZy54ID49IHJlZmVyZW5jZU9yaWVudGF0aW9uLnJpZ2h0LFxuICAgICAgYm90dG9tID0gcmVjdE9yaWVudGF0aW9uLnRvcCAtIHBhZGRpbmcueSA+PSByZWZlcmVuY2VPcmllbnRhdGlvbi5ib3R0b20sXG4gICAgICBsZWZ0ID0gcmVjdE9yaWVudGF0aW9uLnJpZ2h0ICsgcGFkZGluZy54IDw9IHJlZmVyZW5jZU9yaWVudGF0aW9uLmxlZnQ7XG5cbiAgdmFyIHZlcnRpY2FsID0gdG9wID8gJ3RvcCcgOiAoYm90dG9tID8gJ2JvdHRvbScgOiBudWxsKSxcbiAgICAgIGhvcml6b250YWwgPSBsZWZ0ID8gJ2xlZnQnIDogKHJpZ2h0ID8gJ3JpZ2h0JyA6IG51bGwpO1xuXG4gIGlmIChob3Jpem9udGFsICYmIHZlcnRpY2FsKSB7XG4gICAgcmV0dXJuIHZlcnRpY2FsICsgJy0nICsgaG9yaXpvbnRhbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaG9yaXpvbnRhbCB8fCB2ZXJ0aWNhbCB8fCAnaW50ZXJzZWN0JztcbiAgfVxufVxuXG5cbi8vIGludGVyc2VjdGlvbiB1dGlscyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogR2V0IGludGVyc2VjdGlvbiBiZXR3ZWVuIGFuIGVsZW1lbnQgYW5kIGEgbGluZSBwYXRoLlxuICpcbiAqIEBwYXJhbSB7UGF0aERlZn0gZWxlbWVudFBhdGhcbiAqIEBwYXJhbSB7UGF0aERlZn0gbGluZVBhdGhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JvcFN0YXJ0IGNyb3AgZnJvbSBzdGFydCBvciBlbmRcbiAqXG4gKiBAcmV0dXJuIHtQb2ludH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRMaW5lSW50ZXJzZWN0aW9uKGVsZW1lbnRQYXRoLCBsaW5lUGF0aCwgY3JvcFN0YXJ0KSB7XG5cbiAgdmFyIGludGVyc2VjdGlvbnMgPSBnZXRJbnRlcnNlY3Rpb25zKGVsZW1lbnRQYXRoLCBsaW5lUGF0aCk7XG5cbiAgLy8gcmVjb2duaXplIGludGVyc2VjdGlvbnNcbiAgLy8gb25seSBvbmUgLT4gY2hvb3NlXG4gIC8vIHR3byBjbG9zZSB0b2dldGhlciAtPiBjaG9vc2UgZmlyc3RcbiAgLy8gdHdvIG9yIG1vcmUgZGlzdGluY3QgLT4gcHVsbCBvdXQgYXBwcm9wcmlhdGUgb25lXG4gIC8vIG5vbmUgLT4gb2sgKGZhbGxiYWNrIHRvIHBvaW50IGl0c2VsZilcbiAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHJvdW5kUG9pbnQoaW50ZXJzZWN0aW9uc1swXSk7XG4gIH0gZWxzZSBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPT09IDIgJiYgcG9pbnREaXN0YW5jZShpbnRlcnNlY3Rpb25zWzBdLCBpbnRlcnNlY3Rpb25zWzFdKSA8IDEpIHtcbiAgICByZXR1cm4gcm91bmRQb2ludChpbnRlcnNlY3Rpb25zWzBdKTtcbiAgfSBlbHNlIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDEpIHtcblxuICAgIC8vIHNvcnQgYnkgaW50ZXJzZWN0aW9ucyBiYXNlZCBvbiBjb25uZWN0aW9uIHNlZ21lbnQgK1xuICAgIC8vIGRpc3RhbmNlIGZyb20gc3RhcnRcbiAgICBpbnRlcnNlY3Rpb25zID0gc29ydEJ5KGludGVyc2VjdGlvbnMsIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguZmxvb3IoaS50MiAqIDEwMCkgfHwgMTtcblxuICAgICAgZGlzdGFuY2UgPSAxMDAgLSBkaXN0YW5jZTtcblxuICAgICAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgPCAxMCA/ICcwJyA6ICcnKSArIGRpc3RhbmNlO1xuXG4gICAgICAvLyBjcmVhdGUgYSBzb3J0IHN0cmluZyB0aGF0IG1ha2VzIHN1cmUgd2Ugc29ydFxuICAgICAgLy8gbGluZSBzZWdtZW50IEFTQyArIGxpbmUgc2VnbWVudCBwb3NpdGlvbiBERVNDIChmb3IgY3JvcFN0YXJ0KVxuICAgICAgLy8gbGluZSBzZWdtZW50IEFTQyArIGxpbmUgc2VnbWVudCBwb3NpdGlvbiBBU0MgKGZvciBjcm9wRW5kKVxuICAgICAgcmV0dXJuIGkuc2VnbWVudDIgKyAnIycgKyBkaXN0YW5jZTtcbiAgICB9KTtcblxuICAgIHJldHVybiByb3VuZFBvaW50KGludGVyc2VjdGlvbnNbY3JvcFN0YXJ0ID8gMCA6IGludGVyc2VjdGlvbnMubGVuZ3RoIC0gMV0pO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbnMoYSwgYikge1xuICByZXR1cm4gaW50ZXJzZWN0UGF0aHMoYSwgYik7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclJlZHVuZGFudFdheXBvaW50cyh3YXlwb2ludHMpIHtcblxuICAvLyBhbHRlciBjb3B5IG9mIHdheXBvaW50cywgbm90IG9yaWdpbmFsXG4gIHdheXBvaW50cyA9IHdheXBvaW50cy5zbGljZSgpO1xuXG4gIHZhciBpZHggPSAwLFxuICAgICAgcG9pbnQsXG4gICAgICBwcmV2aW91c1BvaW50LFxuICAgICAgbmV4dFBvaW50O1xuXG4gIHdoaWxlICh3YXlwb2ludHNbaWR4XSkge1xuICAgIHBvaW50ID0gd2F5cG9pbnRzW2lkeF07XG4gICAgcHJldmlvdXNQb2ludCA9IHdheXBvaW50c1tpZHggLSAxXTtcbiAgICBuZXh0UG9pbnQgPSB3YXlwb2ludHNbaWR4ICsgMV07XG5cbiAgICBpZiAocG9pbnREaXN0YW5jZShwb2ludCwgbmV4dFBvaW50KSA9PT0gMCB8fFxuICAgICAgICBwb2ludHNPbkxpbmUocHJldmlvdXNQb2ludCwgbmV4dFBvaW50LCBwb2ludCkpIHtcblxuICAgICAgLy8gcmVtb3ZlIHBvaW50LCBpZiBvdmVybGFwcGluZyB3aXRoIHtuZXh0UG9pbnR9XG4gICAgICAvLyBvciBvbiBsaW5lIHdpdGgge3ByZXZpb3VzUG9pbnR9IC0+IHtwb2ludH0gLT4ge25leHRQb2ludH1cbiAgICAgIHdheXBvaW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWR4Kys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdheXBvaW50cztcbn1cbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ21pbi1kYXNoJztcbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBSZWZzIGZyb20gJ29iamVjdC1yZWZzJztcblxudmFyIHBhcmVudFJlZnMgPSBuZXcgUmVmcyh7IG5hbWU6ICdjaGlsZHJlbicsIGVudW1lcmFibGU6IHRydWUsIGNvbGxlY3Rpb246IHRydWUgfSwgeyBuYW1lOiAncGFyZW50JyB9KSxcbiAgICBsYWJlbFJlZnMgPSBuZXcgUmVmcyh7IG5hbWU6ICdsYWJlbHMnLCBlbnVtZXJhYmxlOiB0cnVlLCBjb2xsZWN0aW9uOiB0cnVlIH0sIHsgbmFtZTogJ2xhYmVsVGFyZ2V0JyB9KSxcbiAgICBhdHRhY2hlclJlZnMgPSBuZXcgUmVmcyh7IG5hbWU6ICdhdHRhY2hlcnMnLCBjb2xsZWN0aW9uOiB0cnVlIH0sIHsgbmFtZTogJ2hvc3QnIH0pLFxuICAgIG91dGdvaW5nUmVmcyA9IG5ldyBSZWZzKHsgbmFtZTogJ291dGdvaW5nJywgY29sbGVjdGlvbjogdHJ1ZSB9LCB7IG5hbWU6ICdzb3VyY2UnIH0pLFxuICAgIGluY29taW5nUmVmcyA9IG5ldyBSZWZzKHsgbmFtZTogJ2luY29taW5nJywgY29sbGVjdGlvbjogdHJ1ZSB9LCB7IG5hbWU6ICd0YXJnZXQnIH0pO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgZGpzLm1vZGVsXG4gKi9cblxuLyoqXG4gKiBAbWVtYmVyT2YgZGpzLm1vZGVsXG4gKi9cblxuLyoqXG4gKiBUaGUgYmFzaWMgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uXG4gKlxuICogQGNsYXNzXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCYXNlKCkge1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHRoYXQgYmFja3MgdXAgdGhlIHNoYXBlXG4gICAqXG4gICAqIEBuYW1lIEJhc2UjYnVzaW5lc3NPYmplY3RcbiAgICogQHR5cGUgT2JqZWN0XG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2J1c2luZXNzT2JqZWN0Jywge1xuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqIFNpbmdsZSBsYWJlbCBzdXBwb3J0LCB3aWxsIG1hcHBlZCB0byBtdWx0aSBsYWJlbCBhcnJheVxuICAgKlxuICAgKiBAbmFtZSBCYXNlI2xhYmVsXG4gICAqIEB0eXBlIE9iamVjdFxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdsYWJlbCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWxzWzBdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihuZXdMYWJlbCkge1xuXG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLmxhYmVsLFxuICAgICAgICAgIGxhYmVscyA9IHRoaXMubGFiZWxzO1xuXG4gICAgICBpZiAoIW5ld0xhYmVsICYmIGxhYmVsKSB7XG4gICAgICAgIGxhYmVscy5yZW1vdmUobGFiZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxzLmFkZChuZXdMYWJlbCwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogVGhlIHBhcmVudCBzaGFwZVxuICAgKlxuICAgKiBAbmFtZSBCYXNlI3BhcmVudFxuICAgKiBAdHlwZSBTaGFwZVxuICAgKi9cbiAgcGFyZW50UmVmcy5iaW5kKHRoaXMsICdwYXJlbnQnKTtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgbGFiZWxzXG4gICAqXG4gICAqIEBuYW1lIEJhc2UjbGFiZWxzXG4gICAqIEB0eXBlIExhYmVsXG4gICAqL1xuICBsYWJlbFJlZnMuYmluZCh0aGlzLCAnbGFiZWxzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG91dGdvaW5nIGNvbm5lY3Rpb25zXG4gICAqXG4gICAqIEBuYW1lIEJhc2Ujb3V0Z29pbmdcbiAgICogQHR5cGUgQXJyYXk8Q29ubmVjdGlvbj5cbiAgICovXG4gIG91dGdvaW5nUmVmcy5iaW5kKHRoaXMsICdvdXRnb2luZycpO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBpbmNvbWluZyBjb25uZWN0aW9uc1xuICAgKlxuICAgKiBAbmFtZSBCYXNlI2luY29taW5nXG4gICAqIEB0eXBlIEFycmF5PENvbm5lY3Rpb24+XG4gICAqL1xuICBpbmNvbWluZ1JlZnMuYmluZCh0aGlzLCAnaW5jb21pbmcnKTtcbn1cblxuXG4vKipcbiAqIEEgZ3JhcGhpY2FsIG9iamVjdFxuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQGV4dGVuZHMgQmFzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gU2hhcGUoKSB7XG4gIEJhc2UuY2FsbCh0aGlzKTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGZyYW1lIHNoYXBlc1xuICAgKlxuICAgKiBAbmFtZSBTaGFwZSNpc0ZyYW1lXG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGNoaWxkcmVuXG4gICAqXG4gICAqIEBuYW1lIFNoYXBlI2NoaWxkcmVuXG4gICAqIEB0eXBlIEFycmF5PEJhc2U+XG4gICAqL1xuICBwYXJlbnRSZWZzLmJpbmQodGhpcywgJ2NoaWxkcmVuJyk7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFNoYXBlI2hvc3RcbiAgICogQHR5cGUgU2hhcGVcbiAgICovXG4gIGF0dGFjaGVyUmVmcy5iaW5kKHRoaXMsICdob3N0Jyk7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFNoYXBlI2F0dGFjaGVyc1xuICAgKiBAdHlwZSBTaGFwZVxuICAgKi9cbiAgYXR0YWNoZXJSZWZzLmJpbmQodGhpcywgJ2F0dGFjaGVycycpO1xufVxuXG5pbmhlcml0cyhTaGFwZSwgQmFzZSk7XG5cblxuLyoqXG4gKiBBIHJvb3QgZ3JhcGhpY2FsIG9iamVjdFxuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQGV4dGVuZHMgU2hhcGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvb3QoKSB7XG4gIFNoYXBlLmNhbGwodGhpcyk7XG59XG5cbmluaGVyaXRzKFJvb3QsIFNoYXBlKTtcblxuXG4vKipcbiAqIEEgbGFiZWwgZm9yIGFuIGVsZW1lbnRcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBleHRlbmRzIFNoYXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBMYWJlbCgpIHtcbiAgU2hhcGUuY2FsbCh0aGlzKTtcblxuICAvKipcbiAgICogVGhlIGxhYmVsZWQgZWxlbWVudFxuICAgKlxuICAgKiBAbmFtZSBMYWJlbCNsYWJlbFRhcmdldFxuICAgKiBAdHlwZSBCYXNlXG4gICAqL1xuICBsYWJlbFJlZnMuYmluZCh0aGlzLCAnbGFiZWxUYXJnZXQnKTtcbn1cblxuaW5oZXJpdHMoTGFiZWwsIFNoYXBlKTtcblxuXG4vKipcbiAqIEEgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBlbGVtZW50c1xuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQGV4dGVuZHMgQmFzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gQ29ubmVjdGlvbigpIHtcbiAgQmFzZS5jYWxsKHRoaXMpO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxlbWVudCB0aGlzIGNvbm5lY3Rpb24gb3JpZ2luYXRlcyBmcm9tXG4gICAqXG4gICAqIEBuYW1lIENvbm5lY3Rpb24jc291cmNlXG4gICAqIEB0eXBlIEJhc2VcbiAgICovXG4gIG91dGdvaW5nUmVmcy5iaW5kKHRoaXMsICdzb3VyY2UnKTtcblxuICAvKipcbiAgICogVGhlIGVsZW1lbnQgdGhpcyBjb25uZWN0aW9uIHBvaW50cyB0b1xuICAgKlxuICAgKiBAbmFtZSBDb25uZWN0aW9uI3RhcmdldFxuICAgKiBAdHlwZSBCYXNlXG4gICAqL1xuICBpbmNvbWluZ1JlZnMuYmluZCh0aGlzLCAndGFyZ2V0Jyk7XG59XG5cbmluaGVyaXRzKENvbm5lY3Rpb24sIEJhc2UpO1xuXG5cbnZhciB0eXBlcyA9IHtcbiAgY29ubmVjdGlvbjogQ29ubmVjdGlvbixcbiAgc2hhcGU6IFNoYXBlLFxuICBsYWJlbDogTGFiZWwsXG4gIHJvb3Q6IFJvb3Rcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtb2RlbCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZVxuICpcbiAqIEBtZXRob2QgY3JlYXRlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgc2hhcGUxID0gTW9kZWwuY3JlYXRlKCdzaGFwZScsIHsgeDogMTAsIHk6IDEwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMCB9KTtcbiAqIHZhciBzaGFwZTIgPSBNb2RlbC5jcmVhdGUoJ3NoYXBlJywgeyB4OiAyMTAsIHk6IDIxMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAgfSk7XG4gKlxuICogdmFyIGNvbm5lY3Rpb24gPSBNb2RlbC5jcmVhdGUoJ2Nvbm5lY3Rpb24nLCB7IHdheXBvaW50czogWyB7IHg6IDExMCwgeTogNTUgfSwge3g6IDIxMCwgeTogNTUgfSBdIH0pO1xuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZSBsb3dlci1jYXNlZCBtb2RlbCBuYW1lXG4gKiBAcGFyYW0gIHtPYmplY3R9IGF0dHJzIGF0dHJpYnV0ZXMgdG8gaW5pdGlhbGl6ZSB0aGUgbmV3IG1vZGVsIGluc3RhbmNlIHdpdGhcbiAqXG4gKiBAcmV0dXJuIHtCYXNlfSB0aGUgbmV3IG1vZGVsIGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUodHlwZSwgYXR0cnMpIHtcbiAgdmFyIFR5cGUgPSB0eXBlc1t0eXBlXTtcbiAgaWYgKCFUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHR5cGU6IDwnICsgdHlwZSArICc+Jyk7XG4gIH1cbiAgcmV0dXJuIGFzc2lnbihuZXcgVHlwZSgpLCBhdHRycyk7XG59IiwiaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbWluLWRhc2gnO1xuXG5cbnZhciBERUZBVUxUX0NPTkZJRyA9IHtcbiAgbW92ZVNwZWVkOiA1MCxcbiAgbW92ZVNwZWVkQWNjZWxlcmF0ZWQ6IDIwMFxufTtcblxuXG4vKipcbiAqIEEgZmVhdHVyZSB0aGF0IGFsbG93cyB1c2VycyB0byBtb3ZlIHRoZSBjYW52YXMgdXNpbmcgdGhlIGtleWJvYXJkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1vdmVTcGVlZD01MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1vdmVTcGVlZEFjY2VsZXJhdGVkPTIwMF1cbiAqIEBwYXJhbSB7S2V5Ym9hcmR9IGtleWJvYXJkXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEtleWJvYXJkTW92ZShcbiAgICBjb25maWcsXG4gICAga2V5Ym9hcmQsXG4gICAgY2FudmFzXG4pIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5fY29uZmlnID0gYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJRywgY29uZmlnIHx8IHt9KTtcblxuICBrZXlib2FyZC5hZGRMaXN0ZW5lcihhcnJvd3NMaXN0ZW5lcik7XG5cblxuICBmdW5jdGlvbiBhcnJvd3NMaXN0ZW5lcihjb250ZXh0KSB7XG5cbiAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50LFxuICAgICAgICBjb25maWcgPSBzZWxmLl9jb25maWc7XG5cbiAgICBpZiAoIWtleWJvYXJkLmlzQ21kKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXlib2FyZC5pc0tleShbXG4gICAgICAnQXJyb3dMZWZ0JywgJ0xlZnQnLFxuICAgICAgJ0Fycm93VXAnLCAnVXAnLFxuICAgICAgJ0Fycm93RG93bicsICdEb3duJyxcbiAgICAgICdBcnJvd1JpZ2h0JywgJ1JpZ2h0J1xuICAgIF0sIGV2ZW50KSkge1xuXG4gICAgICB2YXIgc3BlZWQgPSAoXG4gICAgICAgIGtleWJvYXJkLmlzU2hpZnQoZXZlbnQpID9cbiAgICAgICAgICBjb25maWcubW92ZVNwZWVkQWNjZWxlcmF0ZWQgOlxuICAgICAgICAgIGNvbmZpZy5tb3ZlU3BlZWRcbiAgICAgICk7XG5cbiAgICAgIHZhciBkaXJlY3Rpb247XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgY2FzZSAnTGVmdCc6XG4gICAgICAgIGRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgIGNhc2UgJ1VwJzpcbiAgICAgICAgZGlyZWN0aW9uID0gJ3VwJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgIGNhc2UgJ1JpZ2h0JzpcbiAgICAgICAgZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgY2FzZSAnRG93bic6XG4gICAgICAgIGRpcmVjdGlvbiA9ICdkb3duJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHNlbGYubW92ZUNhbnZhcyh7XG4gICAgICAgIHNwZWVkOiBzcGVlZCxcbiAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm1vdmVDYW52YXMgPSBmdW5jdGlvbihvcHRzKSB7XG5cbiAgICB2YXIgZHggPSAwLFxuICAgICAgICBkeSA9IDAsXG4gICAgICAgIHNwZWVkID0gb3B0cy5zcGVlZDtcblxuICAgIHZhciBhY3R1YWxTcGVlZCA9IHNwZWVkIC8gTWF0aC5taW4oTWF0aC5zcXJ0KGNhbnZhcy52aWV3Ym94KCkuc2NhbGUpLCAxKTtcblxuICAgIHN3aXRjaCAob3B0cy5kaXJlY3Rpb24pIHtcbiAgICBjYXNlICdsZWZ0JzogLy8gTGVmdFxuICAgICAgZHggPSBhY3R1YWxTcGVlZDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VwJzogLy8gVXBcbiAgICAgIGR5ID0gYWN0dWFsU3BlZWQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6IC8vIFJpZ2h0XG4gICAgICBkeCA9IC1hY3R1YWxTcGVlZDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rvd24nOiAvLyBEb3duXG4gICAgICBkeSA9IC1hY3R1YWxTcGVlZDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhbnZhcy5zY3JvbGwoe1xuICAgICAgZHg6IGR4LFxuICAgICAgZHk6IGR5XG4gICAgfSk7XG4gIH07XG5cbn1cblxuXG5LZXlib2FyZE1vdmUuJGluamVjdCA9IFtcbiAgJ2NvbmZpZy5rZXlib2FyZE1vdmUnLFxuICAna2V5Ym9hcmQnLFxuICAnY2FudmFzJ1xuXTtcbiIsImltcG9ydCBLZXlib2FyZE1vZHVsZSBmcm9tICcuLi8uLi9mZWF0dXJlcy9rZXlib2FyZCc7XG5cbmltcG9ydCBLZXlib2FyZE1vdmUgZnJvbSAnLi9LZXlib2FyZE1vdmUnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19kZXBlbmRzX186IFtcbiAgICBLZXlib2FyZE1vZHVsZVxuICBdLFxuICBfX2luaXRfXzogWyAna2V5Ym9hcmRNb3ZlJyBdLFxuICBrZXlib2FyZE1vdmU6IFsgJ3R5cGUnLCBLZXlib2FyZE1vdmUgXVxufTsiLCJpbXBvcnQge1xuICBzZXQgYXMgY3Vyc29yU2V0LFxuICB1bnNldCBhcyBjdXJzb3JVbnNldFxufSBmcm9tICcuLi8uLi91dGlsL0N1cnNvcic7XG5cbmltcG9ydCB7XG4gIGluc3RhbGwgYXMgaW5zdGFsbENsaWNrVHJhcFxufSBmcm9tICcuLi8uLi91dGlsL0NsaWNrVHJhcCc7XG5cbmltcG9ydCB7XG4gIGRlbHRhIGFzIGRlbHRhUG9zXG59IGZyb20gJy4uLy4uL3V0aWwvUG9zaXRpb25VdGlsJztcblxuaW1wb3J0IHtcbiAgZXZlbnQgYXMgZG9tRXZlbnQsXG4gIGNsb3Nlc3QgYXMgZG9tQ2xvc2VzdFxufSBmcm9tICdtaW4tZG9tJztcblxuaW1wb3J0IHtcbiAgdG9Qb2ludFxufSBmcm9tICcuLi8uLi91dGlsL0V2ZW50JztcblxuXG52YXIgVEhSRVNIT0xEID0gMTU7XG5cblxuLyoqXG4gKiBNb3ZlIHRoZSBjYW52YXMgdmlhIG1vdXNlLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1vdmVDYW52YXMoZXZlbnRCdXMsIGNhbnZhcykge1xuXG4gIHZhciBjb250ZXh0O1xuXG5cbiAgLy8gbGlzdGVuIGZvciBtb3ZlIG9uIGVsZW1lbnQgbW91c2UgZG93bjtcbiAgLy8gYWxsb3cgb3RoZXJzIHRvIGhvb2sgaW50byB0aGUgZXZlbnQgYmVmb3JlIHVzIHRob3VnaFxuICAvLyAoZHJhZ2dpbmcgLyBlbGVtZW50IG1vdmluZyB3aWxsIGRvIHRoaXMpXG4gIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm1vdXNlZG93bicsIDUwMCwgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBoYW5kbGVTdGFydChlLm9yaWdpbmFsRXZlbnQpO1xuICB9KTtcblxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdmUoZXZlbnQpIHtcblxuICAgIHZhciBzdGFydCA9IGNvbnRleHQuc3RhcnQsXG4gICAgICAgIGJ1dHRvbiA9IGNvbnRleHQuYnV0dG9uLFxuICAgICAgICBwb3NpdGlvbiA9IHRvUG9pbnQoZXZlbnQpLFxuICAgICAgICBkZWx0YSA9IGRlbHRhUG9zKHBvc2l0aW9uLCBzdGFydCk7XG5cbiAgICBpZiAoIWNvbnRleHQuZHJhZ2dpbmcgJiYgbGVuZ3RoKGRlbHRhKSA+IFRIUkVTSE9MRCkge1xuICAgICAgY29udGV4dC5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgIGlmIChidXR0b24gPT09IDApIHtcbiAgICAgICAgaW5zdGFsbENsaWNrVHJhcChldmVudEJ1cyk7XG4gICAgICB9XG5cbiAgICAgIGN1cnNvclNldCgnZ3JhYicpO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LmRyYWdnaW5nKSB7XG5cbiAgICAgIHZhciBsYXN0UG9zaXRpb24gPSBjb250ZXh0Lmxhc3QgfHwgY29udGV4dC5zdGFydDtcblxuICAgICAgZGVsdGEgPSBkZWx0YVBvcyhwb3NpdGlvbiwgbGFzdFBvc2l0aW9uKTtcblxuICAgICAgY2FudmFzLnNjcm9sbCh7XG4gICAgICAgIGR4OiBkZWx0YS54LFxuICAgICAgICBkeTogZGVsdGEueVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnRleHQubGFzdCA9IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgc2VsZWN0XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gaGFuZGxlRW5kKGV2ZW50KSB7XG4gICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgaGFuZGxlTW92ZSk7XG4gICAgZG9tRXZlbnQudW5iaW5kKGRvY3VtZW50LCAnbW91c2V1cCcsIGhhbmRsZUVuZCk7XG5cbiAgICBjb250ZXh0ID0gbnVsbDtcblxuICAgIGN1cnNvclVuc2V0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydChldmVudCkge1xuXG4gICAgLy8gZXZlbnQgaXMgYWxyZWFkeSBoYW5kbGVkIGJ5ICcuZGpzLWRyYWdnYWJsZSdcbiAgICBpZiAoZG9tQ2xvc2VzdChldmVudC50YXJnZXQsICcuZGpzLWRyYWdnYWJsZScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuICAgIC8vIHJlamVjdCByaWdodCBtb3VzZSBidXR0b24gb3IgbW9kaWZpZXIga2V5XG4gICAgaWYgKGJ1dHRvbiA+PSAyIHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dCA9IHtcbiAgICAgIGJ1dHRvbjogYnV0dG9uLFxuICAgICAgc3RhcnQ6IHRvUG9pbnQoZXZlbnQpXG4gICAgfTtcblxuICAgIGRvbUV2ZW50LmJpbmQoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBoYW5kbGVNb3ZlKTtcbiAgICBkb21FdmVudC5iaW5kKGRvY3VtZW50LCAnbW91c2V1cCcsIGhhbmRsZUVuZCk7XG5cbiAgICAvLyB3ZSd2ZSBoYW5kbGVkIHRoZSBldmVudFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdGhpcy5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIWNvbnRleHQ7XG4gIH07XG5cbn1cblxuXG5Nb3ZlQ2FudmFzLiRpbmplY3QgPSBbXG4gICdldmVudEJ1cycsXG4gICdjYW52YXMnXG5dO1xuXG5cblxuLy8gaGVscGVycyAvLy8vLy8vXG5cbmZ1bmN0aW9uIGxlbmd0aChwb2ludCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50LngsIDIpICsgTWF0aC5wb3cocG9pbnQueSwgMikpO1xufVxuIiwiaW1wb3J0IE1vdmVDYW52YXMgZnJvbSAnLi9Nb3ZlQ2FudmFzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2luaXRfXzogWyAnbW92ZUNhbnZhcycgXSxcbiAgbW92ZUNhbnZhczogWyAndHlwZScsIE1vdmVDYW52YXMgXVxufTsiLCJpbXBvcnQgVG91Y2hNb2R1bGUgZnJvbSAnLi4vLi4vZmVhdHVyZXMvdG91Y2gnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZGVwZW5kc19fOiBbXG4gICAgVG91Y2hNb2R1bGVcbiAgXVxufTsiLCJpbXBvcnQge1xuICBldmVudCBhcyBkb21FdmVudCxcbiAgY2xvc2VzdCBhcyBkb21DbG9zZXN0XG59IGZyb20gJ21pbi1kb20nO1xuXG5pbXBvcnQge1xuICBnZXRTdGVwU2l6ZSxcbiAgY2FwXG59IGZyb20gJy4vWm9vbVV0aWwnO1xuXG5pbXBvcnQge1xuICBsb2cxMFxufSBmcm9tICcuLi8uLi91dGlsL01hdGgnO1xuXG5pbXBvcnQge1xuICBiaW5kXG59IGZyb20gJ21pbi1kYXNoJztcblxudmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24obikge1xuICByZXR1cm4gbiA+PSAwID8gMSA6IC0xO1xufTtcblxudmFyIFJBTkdFID0geyBtaW46IDAuMiwgbWF4OiA0IH0sXG4gICAgTlVNX1NURVBTID0gMTA7XG5cbnZhciBERUxUQV9USFJFU0hPTEQgPSAwLjE7XG5cbnZhciBERUZBVUxUX1NDQUxFID0gMC43NTtcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB6b29taW5nIGFuZCBzY3JvbGxpbmcgd2l0aGluIHRoZVxuICoge0BsaW5rIENhbnZhc30gdmlhIHRoZSBtb3VzZSB3aGVlbC5cbiAqXG4gKiBNb3VzZSB3aGVlbCB6b29taW5nIC8gc2Nyb2xsaW5nIG1heSBiZSBkaXNhYmxlZCB1c2luZ1xuICogdGhlIHtAbGluayB0b2dnbGUoZW5hYmxlZCl9IG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbmZpZy5lbmFibGVkPXRydWVdIGRlZmF1bHQgZW5hYmxlZCBzdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuc2NhbGU9Ljc1XSBzY3JvbGwgc2Vuc2l2aXR5XG4gKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBab29tU2Nyb2xsKGNvbmZpZywgZXZlbnRCdXMsIGNhbnZhcykge1xuXG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cbiAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICB0aGlzLl9jb250YWluZXIgPSBjYW52YXMuX2NvbnRhaW5lcjtcblxuICB0aGlzLl9oYW5kbGVXaGVlbCA9IGJpbmQodGhpcy5faGFuZGxlV2hlZWwsIHRoaXMpO1xuXG4gIHRoaXMuX3RvdGFsRGVsdGEgPSAwO1xuICB0aGlzLl9zY2FsZSA9IGNvbmZpZy5zY2FsZSB8fCBERUZBVUxUX1NDQUxFO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBldmVudEJ1cy5vbignY2FudmFzLmluaXQnLCBmdW5jdGlvbihlKSB7XG4gICAgc2VsZi5faW5pdChjb25maWcuZW5hYmxlZCAhPT0gZmFsc2UpO1xuICB9KTtcbn1cblxuWm9vbVNjcm9sbC4kaW5qZWN0ID0gW1xuICAnY29uZmlnLnpvb21TY3JvbGwnLFxuICAnZXZlbnRCdXMnLFxuICAnY2FudmFzJ1xuXTtcblxuWm9vbVNjcm9sbC5wcm90b3R5cGUuc2Nyb2xsID0gZnVuY3Rpb24gc2Nyb2xsKGRlbHRhKSB7XG4gIHRoaXMuX2NhbnZhcy5zY3JvbGwoZGVsdGEpO1xufTtcblxuXG5ab29tU2Nyb2xsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICB0aGlzLl9jYW52YXMuem9vbSgnZml0LXZpZXdwb3J0Jyk7XG59O1xuXG4vKipcbiAqIFpvb20gZGVwZW5kaW5nIG9uIGRlbHRhLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uXG4gKi9cblpvb21TY3JvbGwucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbiB6b29tKGRlbHRhLCBwb3NpdGlvbikge1xuXG4gIC8vIHpvb20gd2l0aCBoYWxmIHRoZSBzdGVwIHNpemUgb2Ygc3RlcFpvb21cbiAgdmFyIHN0ZXBTaXplID0gZ2V0U3RlcFNpemUoUkFOR0UsIE5VTV9TVEVQUyAqIDIpO1xuXG4gIC8vIGFkZCB1bnRpbCB0aHJlc2hvbGQgcmVhY2hlZFxuICB0aGlzLl90b3RhbERlbHRhICs9IGRlbHRhO1xuXG4gIGlmIChNYXRoLmFicyh0aGlzLl90b3RhbERlbHRhKSA+IERFTFRBX1RIUkVTSE9MRCkge1xuICAgIHRoaXMuX3pvb20oZGVsdGEsIHBvc2l0aW9uLCBzdGVwU2l6ZSk7XG5cbiAgICAvLyByZXNldFxuICAgIHRoaXMuX3RvdGFsRGVsdGEgPSAwO1xuICB9XG59O1xuXG5cblpvb21TY3JvbGwucHJvdG90eXBlLl9oYW5kbGVXaGVlbCA9IGZ1bmN0aW9uIGhhbmRsZVdoZWVsKGV2ZW50KSB7XG5cbiAgLy8gZXZlbnQgaXMgYWxyZWFkeSBoYW5kbGVkIGJ5ICcuZGpzLXNjcm9sbGFibGUnXG4gIGlmIChkb21DbG9zZXN0KGV2ZW50LnRhcmdldCwgJy5kanMtc2Nyb2xsYWJsZScsIHRydWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSB0aGlzLl9jb250YWluZXI7XG5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAvLyBwaW5jaCB0byB6b29tIGlzIG1hcHBlZCB0byB3aGVlbCArIGN0cmxLZXkgPSB0cnVlXG4gIC8vIGluIG1vZGVybiBicm93c2VycyAoISlcblxuICB2YXIgaXNab29tID0gZXZlbnQuY3RybEtleTtcblxuICB2YXIgaXNIb3Jpem9udGFsU2Nyb2xsID0gZXZlbnQuc2hpZnRLZXk7XG5cbiAgdmFyIGZhY3RvciA9IC0xICogdGhpcy5fc2NhbGUsXG4gICAgICBkZWx0YTtcblxuICBpZiAoaXNab29tKSB7XG4gICAgZmFjdG9yICo9IGV2ZW50LmRlbHRhTW9kZSA9PT0gMCA/IDAuMDIwIDogMC4zMjtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3IgKj0gZXZlbnQuZGVsdGFNb2RlID09PSAwID8gMS4wIDogMTYuMDtcbiAgfVxuXG4gIGlmIChpc1pvb20pIHtcbiAgICB2YXIgZWxlbWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgdmFyIG9mZnNldCA9IHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFggLSBlbGVtZW50UmVjdC5sZWZ0LFxuICAgICAgeTogZXZlbnQuY2xpZW50WSAtIGVsZW1lbnRSZWN0LnRvcFxuICAgIH07XG5cbiAgICBkZWx0YSA9IChcbiAgICAgIE1hdGguc3FydChcbiAgICAgICAgTWF0aC5wb3coZXZlbnQuZGVsdGFZLCAyKSArXG4gICAgICAgIE1hdGgucG93KGV2ZW50LmRlbHRhWCwgMilcbiAgICAgICkgKiBzaWduKGV2ZW50LmRlbHRhWSkgKiBmYWN0b3JcbiAgICApO1xuXG4gICAgLy8gem9vbSBpbiByZWxhdGl2ZSB0byBkaWFncmFtIHt4LHl9IGNvb3JkaW5hdGVzXG4gICAgdGhpcy56b29tKGRlbHRhLCBvZmZzZXQpO1xuICB9IGVsc2Uge1xuXG4gICAgaWYgKGlzSG9yaXpvbnRhbFNjcm9sbCkge1xuICAgICAgZGVsdGEgPSB7XG4gICAgICAgIGR4OiBmYWN0b3IgKiBldmVudC5kZWx0YVksXG4gICAgICAgIGR5OiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWx0YSA9IHtcbiAgICAgICAgZHg6IGZhY3RvciAqIGV2ZW50LmRlbHRhWCxcbiAgICAgICAgZHk6IGZhY3RvciAqIGV2ZW50LmRlbHRhWVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnNjcm9sbChkZWx0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogWm9vbSB3aXRoIGZpeGVkIHN0ZXAgc2l6ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgLSBab29tIGRlbHRhICgxIGZvciB6b29taW5nIGluLCAtMSBmb3Igb3V0KS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvblxuICovXG5ab29tU2Nyb2xsLnByb3RvdHlwZS5zdGVwWm9vbSA9IGZ1bmN0aW9uIHN0ZXBab29tKGRlbHRhLCBwb3NpdGlvbikge1xuXG4gIHZhciBzdGVwU2l6ZSA9IGdldFN0ZXBTaXplKFJBTkdFLCBOVU1fU1RFUFMpO1xuXG4gIHRoaXMuX3pvb20oZGVsdGEsIHBvc2l0aW9uLCBzdGVwU2l6ZSk7XG59O1xuXG5cbi8qKlxuICogWm9vbSBpbi9vdXQgZ2l2ZW4gYSBzdGVwIHNpemUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwU2l6ZVxuICovXG5ab29tU2Nyb2xsLnByb3RvdHlwZS5fem9vbSA9IGZ1bmN0aW9uKGRlbHRhLCBwb3NpdGlvbiwgc3RlcFNpemUpIHtcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblxuICB2YXIgZGlyZWN0aW9uID0gZGVsdGEgPiAwID8gMSA6IC0xO1xuXG4gIHZhciBjdXJyZW50TGluZWFyWm9vbUxldmVsID0gbG9nMTAoY2FudmFzLnpvb20oKSk7XG5cbiAgLy8gc25hcCB0byBhIHByb3hpbWF0ZSB6b29tIHN0ZXBcbiAgdmFyIG5ld0xpbmVhclpvb21MZXZlbCA9IE1hdGgucm91bmQoY3VycmVudExpbmVhclpvb21MZXZlbCAvIHN0ZXBTaXplKSAqIHN0ZXBTaXplO1xuXG4gIC8vIGluY3JlYXNlIG9yIGRlY3JlYXNlIG9uZSB6b29tIHN0ZXAgaW4gdGhlIGdpdmVuIGRpcmVjdGlvblxuICBuZXdMaW5lYXJab29tTGV2ZWwgKz0gc3RlcFNpemUgKiBkaXJlY3Rpb247XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBsb2dhcml0aG1pYyB6b29tIGxldmVsIGJhc2VkIG9uIHRoZSBsaW5lYXIgem9vbSBsZXZlbFxuICAvLyAoZS5nLiAyIGZvciBhbiBhYnNvbHV0ZSB4MiB6b29tKVxuICB2YXIgbmV3TG9nWm9vbUxldmVsID0gTWF0aC5wb3coMTAsIG5ld0xpbmVhclpvb21MZXZlbCk7XG5cbiAgY2FudmFzLnpvb20oY2FwKFJBTkdFLCBuZXdMb2dab29tTGV2ZWwpLCBwb3NpdGlvbik7XG59O1xuXG5cbi8qKlxuICogVG9nZ2xlIHRoZSB6b29tIHNjcm9sbCBhYmlsaXR5IHZpYSBtb3VzZSB3aGVlbC5cbiAqXG4gKiBAcGFyYW0gIHtib29sZWFufSBbbmV3RW5hYmxlZF0gbmV3IGVuYWJsZWQgc3RhdGVcbiAqL1xuWm9vbVNjcm9sbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKG5ld0VuYWJsZWQpIHtcblxuICB2YXIgZWxlbWVudCA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgdmFyIGhhbmRsZVdoZWVsID0gdGhpcy5faGFuZGxlV2hlZWw7XG5cbiAgdmFyIG9sZEVuYWJsZWQgPSB0aGlzLl9lbmFibGVkO1xuXG4gIGlmICh0eXBlb2YgbmV3RW5hYmxlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuZXdFbmFibGVkID0gIW9sZEVuYWJsZWQ7XG4gIH1cblxuICAvLyBvbmx5IHJlYWN0IG9uIGFjdHVhbCBjaGFuZ2VzXG4gIGlmIChvbGRFbmFibGVkICE9PSBuZXdFbmFibGVkKSB7XG5cbiAgICAvLyBhZGQgb3IgcmVtb3ZlIHdoZWVsIGxpc3RlbmVyIGJhc2VkIG9uXG4gICAgLy8gY2hhbmdlZCBlbmFibGVkIHN0YXRlXG4gICAgZG9tRXZlbnRbbmV3RW5hYmxlZCA/ICdiaW5kJyA6ICd1bmJpbmQnXShlbGVtZW50LCAnd2hlZWwnLCBoYW5kbGVXaGVlbCwgZmFsc2UpO1xuICB9XG5cbiAgdGhpcy5fZW5hYmxlZCA9IG5ld0VuYWJsZWQ7XG5cbiAgcmV0dXJuIG5ld0VuYWJsZWQ7XG59O1xuXG5cblpvb21TY3JvbGwucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24obmV3RW5hYmxlZCkge1xuICB0aGlzLnRvZ2dsZShuZXdFbmFibGVkKTtcbn07XG4iLCJpbXBvcnQge1xuICBsb2cxMFxufSBmcm9tICcuLi8uLi91dGlsL01hdGgnO1xuXG4vKipcbiAqIEdldCBzdGVwIHNpemUgZm9yIGdpdmVuIHJhbmdlIGFuZCBudW1iZXIgb2Ygc3RlcHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFuZ2UubWluXG4gKiBAcGFyYW0ge251bWJlcn0gcmFuZ2UubWF4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGVwU2l6ZShyYW5nZSwgc3RlcHMpIHtcblxuICB2YXIgbWluTGluZWFyUmFuZ2UgPSBsb2cxMChyYW5nZS5taW4pLFxuICAgICAgbWF4TGluZWFyUmFuZ2UgPSBsb2cxMChyYW5nZS5tYXgpO1xuXG4gIHZhciBhYnNvbHV0ZUxpbmVhclJhbmdlID0gTWF0aC5hYnMobWluTGluZWFyUmFuZ2UpICsgTWF0aC5hYnMobWF4TGluZWFyUmFuZ2UpO1xuXG4gIHJldHVybiBhYnNvbHV0ZUxpbmVhclJhbmdlIC8gc3RlcHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXAocmFuZ2UsIHNjYWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChyYW5nZS5taW4sIE1hdGgubWluKHJhbmdlLm1heCwgc2NhbGUpKTtcbn1cbiIsImltcG9ydCBab29tU2Nyb2xsIGZyb20gJy4vWm9vbVNjcm9sbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19pbml0X186IFsgJ3pvb21TY3JvbGwnIF0sXG4gIHpvb21TY3JvbGw6IFsgJ3R5cGUnLCBab29tU2Nyb2xsIF1cbn07IiwiaW1wb3J0IHtcbiAgYXNUUkJMLFxuICBnZXRPcmllbnRhdGlvbixcbiAgcm91bmRQb2ludFxufSBmcm9tICcuLi9sYXlvdXQvTGF5b3V0VXRpbCc7XG5cbmltcG9ydCB7XG4gIGNlbnRlcixcbiAgZGVsdGFcbn0gZnJvbSAnLi9Qb3NpdGlvblV0aWwnO1xuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWJzb2x1dGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIG5ldyBlbGVtZW50J3MgcG9zaXRpb25cbiAqXG4gKiBAcGFyYW0ge3BvaW50fSBwb2ludCBbYWJzb2x1dGVdXG4gKiBAcGFyYW0ge2JvdW5kc30gb2xkQm91bmRzXG4gKiBAcGFyYW0ge2JvdW5kc30gbmV3Qm91bmRzXG4gKlxuICogQHJldHVybiB7cG9pbnR9IHBvaW50IFthYnNvbHV0ZV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5ld0F0dGFjaFBvaW50KHBvaW50LCBvbGRCb3VuZHMsIG5ld0JvdW5kcykge1xuICB2YXIgb2xkQ2VudGVyID0gY2VudGVyKG9sZEJvdW5kcyksXG4gICAgICBuZXdDZW50ZXIgPSBjZW50ZXIobmV3Qm91bmRzKSxcbiAgICAgIG9sZERlbHRhID0gZGVsdGEocG9pbnQsIG9sZENlbnRlcik7XG5cbiAgdmFyIG5ld0RlbHRhID0ge1xuICAgIHg6IG9sZERlbHRhLnggKiAobmV3Qm91bmRzLndpZHRoIC8gb2xkQm91bmRzLndpZHRoKSxcbiAgICB5OiBvbGREZWx0YS55ICogKG5ld0JvdW5kcy5oZWlnaHQgLyBvbGRCb3VuZHMuaGVpZ2h0KVxuICB9O1xuXG4gIHJldHVybiByb3VuZFBvaW50KHtcbiAgICB4OiBuZXdDZW50ZXIueCArIG5ld0RlbHRhLngsXG4gICAgeTogbmV3Q2VudGVyLnkgKyBuZXdEZWx0YS55XG4gIH0pO1xufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc2hhcGUncyBkZWx0YSByZWxhdGl2ZSB0byBhIG5ldyBwb3NpdGlvblxuICogb2YgYSBjZXJ0YWluIGVsZW1lbnQncyBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5TaGFwZX0gcG9pbnQgW2Fic29sdXRlXVxuICogQHBhcmFtIHtib3VuZHN9IG9sZEJvdW5kc1xuICogQHBhcmFtIHtib3VuZHN9IG5ld0JvdW5kc1xuICpcbiAqIEByZXR1cm4ge2RlbHRhfSBkZWx0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV3QXR0YWNoU2hhcGVEZWx0YShzaGFwZSwgb2xkQm91bmRzLCBuZXdCb3VuZHMpIHtcbiAgdmFyIHNoYXBlQ2VudGVyID0gY2VudGVyKHNoYXBlKSxcbiAgICAgIG9sZENlbnRlciA9IGNlbnRlcihvbGRCb3VuZHMpLFxuICAgICAgbmV3Q2VudGVyID0gY2VudGVyKG5ld0JvdW5kcyksXG4gICAgICBzaGFwZURlbHRhID0gZGVsdGEoc2hhcGUsIHNoYXBlQ2VudGVyKSxcbiAgICAgIG9sZENlbnRlckRlbHRhID0gZGVsdGEoc2hhcGVDZW50ZXIsIG9sZENlbnRlciksXG4gICAgICBzdGlja3lQb3NpdGlvbkRlbHRhID0gZ2V0U3RpY2t5UG9zaXRpb25EZWx0YShzaGFwZUNlbnRlciwgb2xkQm91bmRzLCBuZXdCb3VuZHMpO1xuXG4gIGlmIChzdGlja3lQb3NpdGlvbkRlbHRhKSB7XG4gICAgcmV0dXJuIHN0aWNreVBvc2l0aW9uRGVsdGE7XG4gIH1cblxuICB2YXIgbmV3Q2VudGVyRGVsdGEgPSB7XG4gICAgeDogb2xkQ2VudGVyRGVsdGEueCAqIChuZXdCb3VuZHMud2lkdGggLyBvbGRCb3VuZHMud2lkdGgpLFxuICAgIHk6IG9sZENlbnRlckRlbHRhLnkgKiAobmV3Qm91bmRzLmhlaWdodCAvIG9sZEJvdW5kcy5oZWlnaHQpXG4gIH07XG5cbiAgdmFyIG5ld1NoYXBlQ2VudGVyID0ge1xuICAgIHg6IG5ld0NlbnRlci54ICsgbmV3Q2VudGVyRGVsdGEueCxcbiAgICB5OiBuZXdDZW50ZXIueSArIG5ld0NlbnRlckRlbHRhLnlcbiAgfTtcblxuICByZXR1cm4gcm91bmRQb2ludCh7XG4gICAgeDogbmV3U2hhcGVDZW50ZXIueCArIHNoYXBlRGVsdGEueCAtIHNoYXBlLngsXG4gICAgeTogbmV3U2hhcGVDZW50ZXIueSArIHNoYXBlRGVsdGEueSAtIHNoYXBlLnlcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFN0aWNreVBvc2l0aW9uRGVsdGEob2xkU2hhcGVDZW50ZXIsIG9sZEJvdW5kcywgbmV3Qm91bmRzKSB7XG4gIHZhciBvbGRUUkJMID0gYXNUUkJMKG9sZEJvdW5kcyksXG4gICAgICBuZXdUUkJMID0gYXNUUkJMKG5ld0JvdW5kcyk7XG5cbiAgaWYgKGlzTW92ZWQob2xkVFJCTCwgbmV3VFJCTCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBvbGRPcmllbnRhdGlvbiA9IGdldE9yaWVudGF0aW9uKG9sZEJvdW5kcywgb2xkU2hhcGVDZW50ZXIpLFxuICAgICAgc3RpY2t5UG9zaXRpb25EZWx0YSxcbiAgICAgIG5ld1NoYXBlQ2VudGVyLFxuICAgICAgbmV3T3JpZW50YXRpb247XG5cbiAgaWYgKG9sZE9yaWVudGF0aW9uID09PSAndG9wJykge1xuICAgIHN0aWNreVBvc2l0aW9uRGVsdGEgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogbmV3VFJCTC5ib3R0b20gLSBvbGRUUkJMLmJvdHRvbVxuICAgIH07XG4gIH0gZWxzZSBpZiAob2xkT3JpZW50YXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgc3RpY2t5UG9zaXRpb25EZWx0YSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiBuZXdUUkJMLnRvcCAtIG9sZFRSQkwudG9wXG4gICAgfTtcbiAgfSBlbHNlIGlmIChvbGRPcmllbnRhdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHN0aWNreVBvc2l0aW9uRGVsdGEgPSB7XG4gICAgICB4OiBuZXdUUkJMLmxlZnQgLSBvbGRUUkJMLmxlZnQsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfSBlbHNlIGlmIChvbGRPcmllbnRhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgc3RpY2t5UG9zaXRpb25EZWx0YSA9IHtcbiAgICAgIHg6IG5ld1RSQkwucmlnaHQgLSBvbGRUUkJMLnJpZ2h0LFxuICAgICAgeTogMFxuICAgIH07XG4gIH0gZWxzZSB7XG5cbiAgICAvLyBmYWxsYmFjayB0byBwcm9wb3J0aW9uYWwgbW92ZW1lbnQgZm9yIGNvcm5lci1wbGFjZWQgYXR0YWNobWVudHNcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG5ld1NoYXBlQ2VudGVyID0ge1xuICAgIHg6IG9sZFNoYXBlQ2VudGVyLnggKyBzdGlja3lQb3NpdGlvbkRlbHRhLngsXG4gICAgeTogb2xkU2hhcGVDZW50ZXIueSArIHN0aWNreVBvc2l0aW9uRGVsdGEueVxuICB9O1xuXG4gIG5ld09yaWVudGF0aW9uID0gZ2V0T3JpZW50YXRpb24obmV3Qm91bmRzLCBuZXdTaGFwZUNlbnRlcik7XG5cbiAgaWYgKG5ld09yaWVudGF0aW9uICE9PSBvbGRPcmllbnRhdGlvbikge1xuXG4gICAgLy8gZmFsbGJhY2sgdG8gcHJvcG9ydGlvbmFsIG1vdmVtZW50IGlmIG9yaWVudGF0aW9uIHdvdWxkIG90aGVyd2lzZSBjaGFuZ2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBzdGlja3lQb3NpdGlvbkRlbHRhO1xufVxuXG5mdW5jdGlvbiBpc01vdmVkKG9sZFRSQkwsIG5ld1RSQkwpIHtcbiAgcmV0dXJuIGlzSG9yaXpvbnRhbGx5TW92ZWQob2xkVFJCTCwgbmV3VFJCTCkgfHwgaXNWZXJ0aWNhbGx5TW92ZWQob2xkVFJCTCwgbmV3VFJCTCk7XG59XG5cbmZ1bmN0aW9uIGlzSG9yaXpvbnRhbGx5TW92ZWQob2xkVFJCTCwgbmV3VFJCTCkge1xuICByZXR1cm4gb2xkVFJCTC5yaWdodCAhPT0gbmV3VFJCTC5yaWdodCAmJiBvbGRUUkJMLmxlZnQgIT09IG5ld1RSQkwubGVmdDtcbn1cblxuZnVuY3Rpb24gaXNWZXJ0aWNhbGx5TW92ZWQob2xkVFJCTCwgbmV3VFJCTCkge1xuICByZXR1cm4gb2xkVFJCTC50b3AgIT09IG5ld1RSQkwudG9wICYmIG9sZFRSQkwuYm90dG9tICE9PSBuZXdUUkJMLmJvdHRvbTtcbn1cbiIsInZhciBUUkFQX1BSSU9SSVRZID0gNTAwMDtcblxuLyoqXG4gKiBJbnN0YWxscyBhIGNsaWNrIHRyYXAgdGhhdCBwcmV2ZW50cyBhIGdob3N0IGNsaWNrIGZvbGxvd2luZyBhIGRyYWdnaW5nIG9wZXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0byBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGluc3RhbGxlZCB0cmFwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChldmVudEJ1cywgZXZlbnROYW1lKSB7XG5cbiAgZXZlbnROYW1lID0gZXZlbnROYW1lIHx8ICdlbGVtZW50LmNsaWNrJztcblxuICBmdW5jdGlvbiB0cmFwKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGV2ZW50QnVzLm9uY2UoZXZlbnROYW1lLCBUUkFQX1BSSU9SSVRZLCB0cmFwKTtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZXZlbnRCdXMub2ZmKGV2ZW50TmFtZSwgdHJhcCk7XG4gIH07XG59IiwiLyoqXG4gKiBGYWlsc2FmZSByZW1vdmUgYW4gZWxlbWVudCBmcm9tIGEgY29sbGVjdGlvblxuICpcbiAqIEBwYXJhbSAge0FycmF5PE9iamVjdD59IFtjb2xsZWN0aW9uXVxuICogQHBhcmFtICB7T2JqZWN0fSBbZWxlbWVudF1cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBwcmV2aW91cyBpbmRleCBvZiB0aGUgZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGNvbGxlY3Rpb24sIGVsZW1lbnQpIHtcblxuICBpZiAoIWNvbGxlY3Rpb24gfHwgIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaWR4ID0gY29sbGVjdGlvbi5pbmRleE9mKGVsZW1lbnQpO1xuXG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgY29sbGVjdGlvbi5zcGxpY2UoaWR4LCAxKTtcbiAgfVxuXG4gIHJldHVybiBpZHg7XG59XG5cbi8qKlxuICogRmFpbCBzYXZlIGFkZCBhbiBlbGVtZW50IHRvIHRoZSBnaXZlbiBjb25uZWN0aW9uLCBlbnN1cmluZ1xuICogaXQgZG9lcyBub3QgeWV0IGV4aXN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY29sbGVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChjb2xsZWN0aW9uLCBlbGVtZW50LCBpZHgpIHtcblxuICBpZiAoIWNvbGxlY3Rpb24gfHwgIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpIHtcbiAgICBpZHggPSAtMTtcbiAgfVxuXG4gIHZhciBjdXJyZW50SWR4ID0gY29sbGVjdGlvbi5pbmRleE9mKGVsZW1lbnQpO1xuXG4gIGlmIChjdXJyZW50SWR4ICE9PSAtMSkge1xuXG4gICAgaWYgKGN1cnJlbnRJZHggPT09IGlkeCkge1xuXG4gICAgICAvLyBub3RoaW5nIHRvIGRvLCBwb3NpdGlvbiBoYXMgbm90IGNoYW5nZWRcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuXG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgY29sbGVjdGlvbi5zcGxpY2UoY3VycmVudElkeCwgMSk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIGFscmVhZHkgZXhpc3RzIGluIGNvbGxlY3Rpb25cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpZHggIT09IC0xKSB7XG5cbiAgICAvLyBpbnNlcnQgYXQgc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAgY29sbGVjdGlvbi5zcGxpY2UoaWR4LCAwLCBlbGVtZW50KTtcbiAgfSBlbHNlIHtcblxuICAgIC8vIHB1c2ggdG8gZW5kXG4gICAgY29sbGVjdGlvbi5wdXNoKGVsZW1lbnQpO1xuICB9XG59XG5cblxuLyoqXG4gKiBGYWlsIHNhdmUgZ2V0IHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IGluIGEgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb3IgLTEgaWYgY29sbGVjdGlvbiBvciBlbGVtZW50IGRvXG4gKiAgICAgICAgICAgICAgICAgIG5vdCBleGlzdCBvciB0aGUgZWxlbWVudCBpcyBub3QgY29udGFpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihjb2xsZWN0aW9uLCBlbGVtZW50KSB7XG5cbiAgaWYgKCFjb2xsZWN0aW9uIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb24uaW5kZXhPZihlbGVtZW50KTtcbn1cbiIsImltcG9ydCB7XG4gIGNsYXNzZXMgYXMgZG9tQ2xhc3Nlc1xufSBmcm9tICdtaW4tZG9tJztcblxudmFyIENVUlNPUl9DTFNfUEFUVEVSTiA9IC9eZGpzLWN1cnNvci0uKiQvO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQobW9kZSkge1xuICB2YXIgY2xhc3NlcyA9IGRvbUNsYXNzZXMoZG9jdW1lbnQuYm9keSk7XG5cbiAgY2xhc3Nlcy5yZW1vdmVNYXRjaGluZyhDVVJTT1JfQ0xTX1BBVFRFUk4pO1xuXG4gIGlmIChtb2RlKSB7XG4gICAgY2xhc3Nlcy5hZGQoJ2Rqcy1jdXJzb3ItJyArIG1vZGUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnNldCgpIHtcbiAgc2V0KG51bGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzKG1vZGUpIHtcbiAgdmFyIGNsYXNzZXMgPSBkb21DbGFzc2VzKGRvY3VtZW50LmJvZHkpO1xuXG4gIHJldHVybiBjbGFzc2VzLmhhcygnZGpzLWN1cnNvci0nICsgbW9kZSk7XG59XG4iLCJpbXBvcnQge1xuICBhc3NpZ24sXG4gIGZpbHRlcixcbiAgZmluZCxcbiAgaXNBcnJheSxcbiAgaXNOdW1iZXIsXG4gIGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZCxcbiAgZ3JvdXBCeSxcbiAgZm9yRWFjaFxufSBmcm9tICdtaW4tZGFzaCc7XG5cblxuLyoqXG4gKiBHZXQgcGFyZW50IGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLmJhc2U+fSBlbGVtZW50c1xuICpcbiAqIEByZXR1cm5zIHtBcnJheTxkanMubW9kZWwuQmFzZT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJlbnRzKGVsZW1lbnRzKSB7XG5cbiAgLy8gZmluZCBlbGVtZW50cyB0aGF0IGFyZSBub3QgY2hpbGRyZW4gb2YgYW55IG90aGVyIGVsZW1lbnRzXG4gIHJldHVybiBmaWx0ZXIoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIWZpbmQoZWxlbWVudHMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBlICE9PSBlbGVtZW50ICYmIGdldFBhcmVudChlbGVtZW50LCBlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGVsZW1lbnQsIHBhcmVudCkge1xuICBpZiAoIXBhcmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlbGVtZW50ID09PSBwYXJlbnQpIHtcbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG5cbiAgaWYgKCFlbGVtZW50LnBhcmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBnZXRQYXJlbnQoZWxlbWVudC5wYXJlbnQsIHBhcmVudCk7XG59XG5cblxuLyoqXG4gKiBBZGRzIGFuIGVsZW1lbnQgdG8gYSBjb2xsZWN0aW9uIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlXG4gKiBlbGVtZW50IHdhcyBhZGRlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGVsZW1lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gZVxuICogQHBhcmFtIHtib29sZWFufSB1bmlxdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChlbGVtZW50cywgZSwgdW5pcXVlKSB7XG4gIHZhciBjYW5BZGQgPSAhdW5pcXVlIHx8IGVsZW1lbnRzLmluZGV4T2YoZSkgPT09IC0xO1xuXG4gIGlmIChjYW5BZGQpIHtcbiAgICBlbGVtZW50cy5wdXNoKGUpO1xuICB9XG5cbiAgcmV0dXJuIGNhbkFkZDtcbn1cblxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCBjYWxsaW5nIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBgZm5gXG4gKiB3aXRoIChlbGVtZW50LCBpbmRleCwgcmVjdXJzaW9uRGVwdGgpLlxuICpcbiAqIFJlY3Vyc2UgaW50byBhbGwgZWxlbWVudHMgdGhhdCBhcmUgcmV0dXJuZWQgYnkgYGZuYC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXk8T2JqZWN0Pn0gZWxlbWVudHNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiBpdGVyYXRvciBmdW5jdGlvbiBjYWxsZWQgd2l0aCAoZWxlbWVudCwgaW5kZXgsIHJlY3Vyc2lvbkRlcHRoKVxuICogQHBhcmFtICB7bnVtYmVyfSBbZGVwdGhdIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoRWxlbWVudChlbGVtZW50cywgZm4sIGRlcHRoKSB7XG5cbiAgZGVwdGggPSBkZXB0aCB8fCAwO1xuXG4gIGlmICghaXNBcnJheShlbGVtZW50cykpIHtcbiAgICBlbGVtZW50cyA9IFsgZWxlbWVudHMgXTtcbiAgfVxuXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKHMsIGkpIHtcbiAgICB2YXIgZmlsdGVyID0gZm4ocywgaSwgZGVwdGgpO1xuXG4gICAgaWYgKGlzQXJyYXkoZmlsdGVyKSAmJiBmaWx0ZXIubGVuZ3RoKSB7XG4gICAgICBlYWNoRWxlbWVudChmaWx0ZXIsIGZuLCBkZXB0aCArIDEpO1xuICAgIH1cbiAgfSk7XG59XG5cblxuLyoqXG4gKiBDb2xsZWN0cyBzZWxmICsgY2hpbGQgZWxlbWVudHMgdXAgdG8gYSBnaXZlbiBkZXB0aCBmcm9tIGEgbGlzdCBvZiBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtkanMubW9kZWwuQmFzZXxBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzIHRoZSBlbGVtZW50cyB0byBzZWxlY3QgdGhlIGNoaWxkcmVuIGZyb21cbiAqIEBwYXJhbSAge2Jvb2xlYW59IHVuaXF1ZSB3aGV0aGVyIHRvIHJldHVybiBhIHVuaXF1ZSByZXN1bHQgc2V0IChubyBkdXBsaWNhdGVzKVxuICogQHBhcmFtICB7bnVtYmVyfSBtYXhEZXB0aCB0aGUgZGVwdGggdG8gc2VhcmNoIHRocm91Z2ggb3IgLTEgZm9yIGluZmluaXRlXG4gKlxuICogQHJldHVybiB7QXJyYXk8ZGpzLm1vZGVsLkJhc2U+fSBmb3VuZCBlbGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZkFuZENoaWxkcmVuKGVsZW1lbnRzLCB1bmlxdWUsIG1heERlcHRoKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIHByb2Nlc3NlZENoaWxkcmVuID0gW107XG5cbiAgZWFjaEVsZW1lbnQoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQsIGksIGRlcHRoKSB7XG4gICAgYWRkKHJlc3VsdCwgZWxlbWVudCwgdW5pcXVlKTtcblxuICAgIHZhciBjaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XG5cbiAgICAvLyBtYXggdHJhdmVyc2FsIGRlcHRoIG5vdCByZWFjaGVkIHlldFxuICAgIGlmIChtYXhEZXB0aCA9PT0gLTEgfHwgZGVwdGggPCBtYXhEZXB0aCkge1xuXG4gICAgICAvLyBjaGlsZHJlbiBleGlzdCAmJiBjaGlsZHJlbiBub3QgeWV0IHByb2Nlc3NlZFxuICAgICAgaWYgKGNoaWxkcmVuICYmIGFkZChwcm9jZXNzZWRDaGlsZHJlbiwgY2hpbGRyZW4sIHVuaXF1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gc2VsZiArIGRpcmVjdCBjaGlsZHJlbiBmb3IgYSBudW1iZXIgb2YgZWxlbWVudHNcbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzIHRvIHF1ZXJ5XG4gKiBAcGFyYW0gIHtib29sZWFufSBhbGxvd0R1cGxpY2F0ZXMgdG8gYWxsb3cgZHVwbGljYXRlcyBpbiB0aGUgcmVzdWx0IHNldFxuICpcbiAqIEByZXR1cm4ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gdGhlIGNvbGxlY3RlZCBlbGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZkFuZERpcmVjdENoaWxkcmVuKGVsZW1lbnRzLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgcmV0dXJuIHNlbGZBbmRDaGlsZHJlbihlbGVtZW50cywgIWFsbG93RHVwbGljYXRlcywgMSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gc2VsZiArIEFMTCBjaGlsZHJlbiBmb3IgYSBudW1iZXIgb2YgZWxlbWVudHNcbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxkanMubW9kZWwuQmFzZT59IGVsZW1lbnRzIHRvIHF1ZXJ5XG4gKiBAcGFyYW0gIHtib29sZWFufSBhbGxvd0R1cGxpY2F0ZXMgdG8gYWxsb3cgZHVwbGljYXRlcyBpbiB0aGUgcmVzdWx0IHNldFxuICpcbiAqIEByZXR1cm4ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gdGhlIGNvbGxlY3RlZCBlbGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZkFuZEFsbENoaWxkcmVuKGVsZW1lbnRzLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgcmV0dXJuIHNlbGZBbmRDaGlsZHJlbihlbGVtZW50cywgIWFsbG93RHVwbGljYXRlcywgLTEpO1xufVxuXG5cbi8qKlxuICogR2V0cyB0aGUgdGhlIGNsb3N1cmUgZm9yIGFsbCBzZWxlY3RlZCBlbGVtZW50cyxcbiAqIHRoZWlyIGVuY2xvc2VkIGNoaWxkcmVuIGFuZCBjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGRqcy5tb2RlbC5CYXNlPn0gZWxlbWVudHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzVG9wTGV2ZWw9dHJ1ZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZXhpc3RpbmdDbG9zdXJlXVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gbmV3Q2xvc3VyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xvc3VyZShlbGVtZW50cywgaXNUb3BMZXZlbCwgY2xvc3VyZSkge1xuXG4gIGlmIChpc1VuZGVmaW5lZChpc1RvcExldmVsKSkge1xuICAgIGlzVG9wTGV2ZWwgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KGlzVG9wTGV2ZWwpKSB7XG4gICAgY2xvc3VyZSA9IGlzVG9wTGV2ZWw7XG4gICAgaXNUb3BMZXZlbCA9IHRydWU7XG4gIH1cblxuXG4gIGNsb3N1cmUgPSBjbG9zdXJlIHx8IHt9O1xuXG4gIHZhciBhbGxTaGFwZXMgPSBjb3B5T2JqZWN0KGNsb3N1cmUuYWxsU2hhcGVzKSxcbiAgICAgIGFsbENvbm5lY3Rpb25zID0gY29weU9iamVjdChjbG9zdXJlLmFsbENvbm5lY3Rpb25zKSxcbiAgICAgIGVuY2xvc2VkRWxlbWVudHMgPSBjb3B5T2JqZWN0KGNsb3N1cmUuZW5jbG9zZWRFbGVtZW50cyksXG4gICAgICBlbmNsb3NlZENvbm5lY3Rpb25zID0gY29weU9iamVjdChjbG9zdXJlLmVuY2xvc2VkQ29ubmVjdGlvbnMpO1xuXG4gIHZhciB0b3BMZXZlbCA9IGNvcHlPYmplY3QoXG4gICAgY2xvc3VyZS50b3BMZXZlbCxcbiAgICBpc1RvcExldmVsICYmIGdyb3VwQnkoZWxlbWVudHMsIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuaWQ7IH0pXG4gICk7XG5cblxuICBmdW5jdGlvbiBoYW5kbGVDb25uZWN0aW9uKGMpIHtcbiAgICBpZiAodG9wTGV2ZWxbYy5zb3VyY2UuaWRdICYmIHRvcExldmVsW2MudGFyZ2V0LmlkXSkge1xuICAgICAgdG9wTGV2ZWxbYy5pZF0gPSBbIGMgXTtcbiAgICB9XG5cbiAgICAvLyBub3QgZW5jbG9zZWQgYXMgYSBjaGlsZCwgYnV0IG1heWJlIGxvZ2ljYWxseVxuICAgIC8vIChjb25uZWN0aW5nIHR3byBtb3ZlZCBlbGVtZW50cz8pXG4gICAgaWYgKGFsbFNoYXBlc1tjLnNvdXJjZS5pZF0gJiYgYWxsU2hhcGVzW2MudGFyZ2V0LmlkXSkge1xuICAgICAgZW5jbG9zZWRDb25uZWN0aW9uc1tjLmlkXSA9IGVuY2xvc2VkRWxlbWVudHNbYy5pZF0gPSBjO1xuICAgIH1cblxuICAgIGFsbENvbm5lY3Rpb25zW2MuaWRdID0gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZWxlbWVudCkge1xuXG4gICAgZW5jbG9zZWRFbGVtZW50c1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudC53YXlwb2ludHMpIHtcblxuICAgICAgLy8gcmVtZW1iZXIgY29ubmVjdGlvblxuICAgICAgZW5jbG9zZWRDb25uZWN0aW9uc1tlbGVtZW50LmlkXSA9IGFsbENvbm5lY3Rpb25zW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyByZW1lbWJlciBzaGFwZVxuICAgICAgYWxsU2hhcGVzW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcblxuICAgICAgLy8gcmVtZW1iZXIgYWxsIGNvbm5lY3Rpb25zXG4gICAgICBmb3JFYWNoKGVsZW1lbnQuaW5jb21pbmcsIGhhbmRsZUNvbm5lY3Rpb24pO1xuXG4gICAgICBmb3JFYWNoKGVsZW1lbnQub3V0Z29pbmcsIGhhbmRsZUNvbm5lY3Rpb24pO1xuXG4gICAgICAvLyByZWN1cnNlIGludG8gY2hpbGRyZW5cbiAgICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuO1xuICAgIH1cbiAgfVxuXG4gIGVhY2hFbGVtZW50KGVsZW1lbnRzLCBoYW5kbGVFbGVtZW50KTtcblxuICByZXR1cm4ge1xuICAgIGFsbFNoYXBlczogYWxsU2hhcGVzLFxuICAgIGFsbENvbm5lY3Rpb25zOiBhbGxDb25uZWN0aW9ucyxcbiAgICB0b3BMZXZlbDogdG9wTGV2ZWwsXG4gICAgZW5jbG9zZWRDb25uZWN0aW9uczogZW5jbG9zZWRDb25uZWN0aW9ucyxcbiAgICBlbmNsb3NlZEVsZW1lbnRzOiBlbmNsb3NlZEVsZW1lbnRzXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3Vycm91bmRpbmcgYmJveCBmb3IgYWxsIGVsZW1lbnRzIGluXG4gKiB0aGUgYXJyYXkgb3IgdGhlIGVsZW1lbnQgcHJpbWl0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZGpzLm1vZGVsLlNoYXBlPnxkanMubW9kZWwuU2hhcGV9IGVsZW1lbnRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0b3BSZWN1cnNpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJCb3goZWxlbWVudHMsIHN0b3BSZWN1cnNpb24pIHtcblxuICBzdG9wUmVjdXJzaW9uID0gISFzdG9wUmVjdXJzaW9uO1xuICBpZiAoIWlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuICB9XG5cbiAgdmFyIG1pblgsXG4gICAgICBtaW5ZLFxuICAgICAgbWF4WCxcbiAgICAgIG1heFk7XG5cbiAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgLy8gSWYgZWxlbWVudCBpcyBhIGNvbm5lY3Rpb24gdGhlIGJib3ggbXVzdCBiZSBjb21wdXRlZCBmaXJzdFxuICAgIHZhciBiYm94ID0gZWxlbWVudDtcbiAgICBpZiAoZWxlbWVudC53YXlwb2ludHMgJiYgIXN0b3BSZWN1cnNpb24pIHtcbiAgICAgIGJib3ggPSBnZXRCQm94KGVsZW1lbnQud2F5cG9pbnRzLCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IGJib3gueCxcbiAgICAgICAgeSA9IGJib3gueSxcbiAgICAgICAgaGVpZ2h0ID0gYmJveC5oZWlnaHQgfHwgMCxcbiAgICAgICAgd2lkdGggPSBiYm94LndpZHRoIHx8IDA7XG5cbiAgICBpZiAoeCA8IG1pblggfHwgbWluWCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW5YID0geDtcbiAgICB9XG4gICAgaWYgKHkgPCBtaW5ZIHx8IG1pblkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluWSA9IHk7XG4gICAgfVxuXG4gICAgaWYgKCh4ICsgd2lkdGgpID4gbWF4WCB8fCBtYXhYID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1heFggPSB4ICsgd2lkdGg7XG4gICAgfVxuICAgIGlmICgoeSArIGhlaWdodCkgPiBtYXhZIHx8IG1heFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWF4WSA9IHkgKyBoZWlnaHQ7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHg6IG1pblgsXG4gICAgeTogbWluWSxcbiAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZLFxuICAgIHdpZHRoOiBtYXhYIC0gbWluWFxuICB9O1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBhcmUgZW5jbG9zZWQgZnJvbSB0aGUgYm91bmRpbmcgYm94LlxuICpcbiAqICAgKiBJZiBiYm94Lih3aWR0aHxoZWlnaHQpIGlzIG5vdCBzcGVjaWZpZWQgdGhlIG1ldGhvZCByZXR1cm5zXG4gKiAgICAgYWxsIGVsZW1lbnRzIHdpdGggZWxlbWVudC54L3kgPiBiYm94LngveVxuICogICAqIElmIG9ubHkgYmJveC54IG9yIGJib3gueSBpcyBzcGVjaWZpZWQsIG1ldGhvZCByZXR1cm4gYWxsIGVsZW1lbnRzIHdpdGhcbiAqICAgICBlLnggPiBiYm94Lnggb3IgZS55ID4gYmJveC55XG4gKlxuICogQHBhcmFtIHtBcnJheTxkanMubW9kZWwuU2hhcGU+fSBlbGVtZW50cyBMaXN0IG9mIEVsZW1lbnRzIHRvIHNlYXJjaCB0aHJvdWdoXG4gKiBAcGFyYW0ge2Rqcy5tb2RlbC5TaGFwZX0gYmJveCB0aGUgZW5jbG9zaW5nIGJib3guXG4gKlxuICogQHJldHVybiB7QXJyYXk8ZGpzLm1vZGVsLlNoYXBlPn0gZW5jbG9zZWQgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVuY2xvc2VkRWxlbWVudHMoZWxlbWVudHMsIGJib3gpIHtcblxuICB2YXIgZmlsdGVyZWRFbGVtZW50cyA9IHt9O1xuXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgIHZhciBlID0gZWxlbWVudDtcblxuICAgIGlmIChlLndheXBvaW50cykge1xuICAgICAgZSA9IGdldEJCb3goZSk7XG4gICAgfVxuXG4gICAgaWYgKCFpc051bWJlcihiYm94LnkpICYmIChlLnggPiBiYm94LngpKSB7XG4gICAgICBmaWx0ZXJlZEVsZW1lbnRzW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcbiAgICB9XG4gICAgaWYgKCFpc051bWJlcihiYm94LngpICYmIChlLnkgPiBiYm94LnkpKSB7XG4gICAgICBmaWx0ZXJlZEVsZW1lbnRzW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcbiAgICB9XG4gICAgaWYgKGUueCA+IGJib3gueCAmJiBlLnkgPiBiYm94LnkpIHtcbiAgICAgIGlmIChpc051bWJlcihiYm94LndpZHRoKSAmJiBpc051bWJlcihiYm94LmhlaWdodCkgJiZcbiAgICAgICAgICBlLndpZHRoICsgZS54IDwgYmJveC53aWR0aCArIGJib3gueCAmJlxuICAgICAgICAgIGUuaGVpZ2h0ICsgZS55IDwgYmJveC5oZWlnaHQgKyBiYm94LnkpIHtcblxuICAgICAgICBmaWx0ZXJlZEVsZW1lbnRzW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAoIWlzTnVtYmVyKGJib3gud2lkdGgpIHx8ICFpc051bWJlcihiYm94LmhlaWdodCkpIHtcbiAgICAgICAgZmlsdGVyZWRFbGVtZW50c1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmlsdGVyZWRFbGVtZW50cztcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZShlbGVtZW50KSB7XG5cbiAgaWYgKCd3YXlwb2ludHMnIGluIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gJ2Nvbm5lY3Rpb24nO1xuICB9XG5cbiAgaWYgKCd4JyBpbiBlbGVtZW50KSB7XG4gICAgcmV0dXJuICdzaGFwZSc7XG4gIH1cblxuICByZXR1cm4gJ3Jvb3QnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGcmFtZUVsZW1lbnQoZWxlbWVudCkge1xuXG4gIHJldHVybiAhIShlbGVtZW50ICYmIGVsZW1lbnQuaXNGcmFtZSk7XG59XG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNyYzEsIHNyYzIpIHtcbiAgcmV0dXJuIGFzc2lnbih7fSwgc3JjMSB8fCB7fSwgc3JjMiB8fCB7fSk7XG59IiwiZnVuY3Rpb24gX19zdG9wUHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgaWYgKCFldmVudCB8fCB0eXBlb2YgZXZlbnQuc3RvcFByb3BhZ2F0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9yaWdpbmFsKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50LnNyY0V2ZW50O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZlbnQsIGltbWVkaWF0ZSkge1xuICBfX3N0b3BQcm9wYWdhdGlvbihldmVudCwgaW1tZWRpYXRlKTtcbiAgX19zdG9wUHJvcGFnYXRpb24oZ2V0T3JpZ2luYWwoZXZlbnQpLCBpbW1lZGlhdGUpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB0b1BvaW50KGV2ZW50KSB7XG5cbiAgaWYgKGV2ZW50LnBvaW50ZXJzICYmIGV2ZW50LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgIGV2ZW50ID0gZXZlbnQucG9pbnRlcnNbMF07XG4gIH1cblxuICBpZiAoZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCkge1xuICAgIGV2ZW50ID0gZXZlbnQudG91Y2hlc1swXTtcbiAgfVxuXG4gIHJldHVybiBldmVudCA/IHtcbiAgICB4OiBldmVudC5jbGllbnRYLFxuICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgfSA6IG51bGw7XG59IiwiaW1wb3J0IHtcbiAgZXZlcnksXG4gIGlzQXJyYXlcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqXG4gKiBAcGFyYW0gIHtQb2ludH0gIHBcbiAqIEBwYXJhbSAge1BvaW50fSAgcVxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gIGRpc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludERpc3RhbmNlKGEsIGIpIHtcbiAgaWYgKCFhIHx8ICFiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydChcbiAgICBNYXRoLnBvdyhhLnggLSBiLngsIDIpICtcbiAgICBNYXRoLnBvdyhhLnkgLSBiLnksIDIpXG4gICk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IHIgaXMgb24gdGhlIGxpbmUgYmV0d2VlbiBwIGFuZCBxXG4gKlxuICogQHBhcmFtICB7UG9pbnR9ICBwXG4gKiBAcGFyYW0gIHtQb2ludH0gIHFcbiAqIEBwYXJhbSAge1BvaW50fSAgclxuICogQHBhcmFtICB7bnVtYmVyfSBbYWNjdXJhY3k9NV0gYWNjdXJhY3kgZm9yIHBvaW50cyBvbiBsaW5lIGNoZWNrIChsb3dlciBpcyBiZXR0ZXIpXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c09uTGluZShwLCBxLCByLCBhY2N1cmFjeSkge1xuXG4gIGlmICh0eXBlb2YgYWNjdXJhY3kgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYWNjdXJhY3kgPSA1O1xuICB9XG5cbiAgaWYgKCFwIHx8ICFxIHx8ICFyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZhbCA9IChxLnggLSBwLngpICogKHIueSAtIHAueSkgLSAocS55IC0gcC55KSAqIChyLnggLSBwLngpLFxuICAgICAgZGlzdCA9IHBvaW50RGlzdGFuY2UocCwgcSk7XG5cbiAgLy8gQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85MDc0OTEvNDEyMTkwXG4gIHJldHVybiBNYXRoLmFicyh2YWwgLyBkaXN0KSA8PSBhY2N1cmFjeTtcbn1cblxuXG52YXIgQUxJR05FRF9USFJFU0hPTEQgPSAyO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIHBvaW50cyBhcmUgaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHkgYWxpZ25lZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50PnxQb2ludH1cbiAqIEBwYXJhbSB7UG9pbnR9XG4gKlxuICogQHJldHVybiB7c3RyaW5nfGJvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNBbGlnbmVkKGEsIGIpIHtcbiAgdmFyIHBvaW50cztcblxuICBpZiAoaXNBcnJheShhKSkge1xuICAgIHBvaW50cyA9IGE7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gWyBhLCBiIF07XG4gIH1cblxuICBpZiAocG9pbnRzQWxpZ25lZEhvcml6b250YWxseShwb2ludHMpKSB7XG4gICAgcmV0dXJuICdoJztcbiAgfVxuXG4gIGlmIChwb2ludHNBbGlnbmVkVmVydGljYWxseShwb2ludHMpKSB7XG4gICAgcmV0dXJuICd2JztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c0FsaWduZWRIb3Jpem9udGFsbHkoYSwgYikge1xuICB2YXIgcG9pbnRzO1xuXG4gIGlmIChpc0FycmF5KGEpKSB7XG4gICAgcG9pbnRzID0gYTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBbIGEsIGIgXTtcbiAgfVxuXG4gIHZhciBmaXJzdFBvaW50ID0gcG9pbnRzLnNsaWNlKCkuc2hpZnQoKTtcblxuICByZXR1cm4gZXZlcnkocG9pbnRzLCBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBNYXRoLmFicyhmaXJzdFBvaW50LnkgLSBwb2ludC55KSA8PSBBTElHTkVEX1RIUkVTSE9MRDtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNBbGlnbmVkVmVydGljYWxseShhLCBiKSB7XG4gIHZhciBwb2ludHM7XG5cbiAgaWYgKGlzQXJyYXkoYSkpIHtcbiAgICBwb2ludHMgPSBhO1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IFsgYSwgYiBdO1xuICB9XG5cbiAgdmFyIGZpcnN0UG9pbnQgPSBwb2ludHMuc2xpY2UoKS5zaGlmdCgpO1xuXG4gIHJldHVybiBldmVyeShwb2ludHMsIGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGZpcnN0UG9pbnQueCAtIHBvaW50LngpIDw9IEFMSUdORURfVEhSRVNIT0xEO1xuICB9KTtcbn1cblxuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBwIGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlIHJlY3RcbiAqXG4gKiBAcGFyYW0gIHtQb2ludH0gIHBcbiAqIEBwYXJhbSAge1JlY3R9IHJlY3RcbiAqIEBwYXJhbSAge251bWJlcn0gdG9sZXJhbmNlXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50SW5SZWN0KHAsIHJlY3QsIHRvbGVyYW5jZSkge1xuICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgMDtcblxuICByZXR1cm4gcC54ID4gcmVjdC54IC0gdG9sZXJhbmNlICYmXG4gICAgICAgICBwLnkgPiByZWN0LnkgLSB0b2xlcmFuY2UgJiZcbiAgICAgICAgIHAueCA8IHJlY3QueCArIHJlY3Qud2lkdGggKyB0b2xlcmFuY2UgJiZcbiAgICAgICAgIHAueSA8IHJlY3QueSArIHJlY3QuaGVpZ2h0ICsgdG9sZXJhbmNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwb2ludCBpbiB0aGUgbWlkZGxlIG9mIHBvaW50cyBwIGFuZCBxXG4gKlxuICogQHBhcmFtICB7UG9pbnR9ICBwXG4gKiBAcGFyYW0gIHtQb2ludH0gIHFcbiAqXG4gKiBAcmV0dXJuIHtQb2ludH0gbWlkZGxlIHBvaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaWRQb2ludChwLCBxKSB7XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZChwLnggKyAoKHEueCAtIHAueCkgLyAyLjApKSxcbiAgICB5OiBNYXRoLnJvdW5kKHAueSArICgocS55IC0gcC55KSAvIDIuMCkpXG4gIH07XG59XG4iLCIvKipcbiAqIFNWR3MgZm9yIGVsZW1lbnRzIGFyZSBnZW5lcmF0ZWQgYnkgdGhlIHtAbGluayBHcmFwaGljc0ZhY3Rvcnl9LlxuICpcbiAqIFRoaXMgdXRpbGl0eSBnaXZlcyBxdWljayBhY2Nlc3MgdG8gdGhlIGltcG9ydGFudCBzZW1hbnRpY1xuICogcGFydHMgb2YgYW4gZWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZpc3VhbCBwYXJ0IG9mIGEgZGlhZ3JhbSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtTbmFwPFNWR0VsZW1lbnQ+fSBnZnhcbiAqXG4gKiBAcmV0dXJuIHtTbmFwPFNWR0VsZW1lbnQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmlzdWFsKGdmeCkge1xuICByZXR1cm4gZ2Z4LmNoaWxkTm9kZXNbMF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2hpbGRyZW4gZm9yIGEgZ2l2ZW4gZGlhZ3JhbSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7U25hcDxTVkdFbGVtZW50Pn0gZ2Z4XG4gKiBAcmV0dXJuIHtTbmFwPFNWR0VsZW1lbnQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oZ2Z4KSB7XG4gIHJldHVybiBnZngucGFyZW50Tm9kZS5jaGlsZE5vZGVzWzFdO1xufSIsIi8qKlxuICogVXRpbCB0aGF0IHByb3ZpZGVzIHVuaXF1ZSBJRHMuXG4gKlxuICogQGNsYXNzIGRqcy51dGlsLklkR2VuZXJhdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtZW1iZXJPZiBkanMudXRpbFxuICpcbiAqIFRoZSBpZHMgY2FuIGJlIGN1c3RvbWl6ZWQgdmlhIGEgZ2l2ZW4gcHJlZml4IGFuZCBjb250YWluIGEgcmFuZG9tIHZhbHVlIHRvIGF2b2lkIGNvbGxpc2lvbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBhIHByZWZpeCB0byBwcmVwZW5kIHRvIGdlbmVyYXRlZCBpZHMgKGZvciBiZXR0ZXIgcmVhZGFiaWxpdHkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIElkR2VuZXJhdG9yKHByZWZpeCkge1xuXG4gIHRoaXMuX2NvdW50ZXIgPSAwO1xuICB0aGlzLl9wcmVmaXggPSAocHJlZml4ID8gcHJlZml4ICsgJy0nIDogJycpICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMCkgKyAnLSc7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5leHQgdW5pcXVlIElELlxuICpcbiAqIEBtZXRob2QgZGpzLnV0aWwuSWRHZW5lcmF0b3IjbmV4dFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBpZFxuICovXG5JZEdlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcHJlZml4ICsgKCsrdGhpcy5fY291bnRlcik7XG59O1xuIiwiaW1wb3J0IHtcbiAgcG9pbnREaXN0YW5jZVxufSBmcm9tICcuL0dlb21ldHJ5JztcblxuaW1wb3J0IGludGVyc2VjdFBhdGhzIGZyb20gJ3BhdGgtaW50ZXJzZWN0aW9uJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICBtYXggPSBNYXRoLm1heDtcblxuXG5mdW5jdGlvbiBjaXJjbGVQYXRoKGNlbnRlciwgcikge1xuICB2YXIgeCA9IGNlbnRlci54LFxuICAgICAgeSA9IGNlbnRlci55O1xuXG4gIHJldHVybiBbXG4gICAgWydNJywgeCwgeV0sXG4gICAgWydtJywgMCwgLXJdLFxuICAgIFsnYScsIHIsIHIsIDAsIDEsIDEsIDAsIDIgKiByXSxcbiAgICBbJ2EnLCByLCByLCAwLCAxLCAxLCAwLCAtMiAqIHJdLFxuICAgIFsneiddXG4gIF07XG59XG5cbmZ1bmN0aW9uIGxpbmVQYXRoKHBvaW50cykge1xuICB2YXIgc2VnbWVudHMgPSBbXTtcblxuICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbihwLCBpZHgpIHtcbiAgICBzZWdtZW50cy5wdXNoKFsgaWR4ID09PSAwID8gJ00nIDogJ0wnLCBwLngsIHAueSBdKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNlZ21lbnRzO1xufVxuXG5cbnZhciBJTlRFUlNFQ1RJT05fVEhSRVNIT0xEID0gMTA7XG5cbmZ1bmN0aW9uIGdldEJlbmRwb2ludEludGVyc2VjdGlvbih3YXlwb2ludHMsIHJlZmVyZW5jZSkge1xuXG4gIHZhciBpLCB3O1xuXG4gIGZvciAoaSA9IDA7ICh3ID0gd2F5cG9pbnRzW2ldKTsgaSsrKSB7XG5cbiAgICBpZiAocG9pbnREaXN0YW5jZSh3LCByZWZlcmVuY2UpIDw9IElOVEVSU0VDVElPTl9USFJFU0hPTEQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiB3YXlwb2ludHNbaV0sXG4gICAgICAgIGJlbmRwb2ludDogdHJ1ZSxcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFBhdGhJbnRlcnNlY3Rpb24od2F5cG9pbnRzLCByZWZlcmVuY2UpIHtcblxuICB2YXIgaW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdFBhdGhzKGNpcmNsZVBhdGgocmVmZXJlbmNlLCBJTlRFUlNFQ1RJT05fVEhSRVNIT0xEKSwgbGluZVBhdGgod2F5cG9pbnRzKSk7XG5cbiAgdmFyIGEgPSBpbnRlcnNlY3Rpb25zWzBdLFxuICAgICAgYiA9IGludGVyc2VjdGlvbnNbaW50ZXJzZWN0aW9ucy5sZW5ndGggLSAxXSxcbiAgICAgIGlkeDtcblxuICBpZiAoIWEpIHtcblxuICAgIC8vIG5vIGludGVyc2VjdGlvblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGEgIT09IGIpIHtcblxuICAgIGlmIChhLnNlZ21lbnQyICE9PSBiLnNlZ21lbnQyKSB7XG5cbiAgICAgIC8vIHdlIHVzZSB0aGUgYmVuZHBvaW50IGluIGJldHdlZW4gYm90aCBzZWdtZW50c1xuICAgICAgLy8gYXMgdGhlIGludGVyc2VjdGlvbiBwb2ludFxuXG4gICAgICBpZHggPSBtYXgoYS5zZWdtZW50MiwgYi5zZWdtZW50MikgLSAxO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogd2F5cG9pbnRzW2lkeF0sXG4gICAgICAgIGJlbmRwb2ludDogdHJ1ZSxcbiAgICAgICAgaW5kZXg6IGlkeFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IHtcbiAgICAgICAgeDogKHJvdW5kKGEueCArIGIueCkgLyAyKSxcbiAgICAgICAgeTogKHJvdW5kKGEueSArIGIueSkgLyAyKVxuICAgICAgfSxcbiAgICAgIGluZGV4OiBhLnNlZ21lbnQyXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IHtcbiAgICAgIHg6IHJvdW5kKGEueCksXG4gICAgICB5OiByb3VuZChhLnkpXG4gICAgfSxcbiAgICBpbmRleDogYS5zZWdtZW50MlxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGNvbm5lY3Rpb24gdG93YXJkcyBhIGdpdmVuIHJlZmVyZW5jZSBwb2ludC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxQb2ludD59IHdheXBvaW50c1xuICogQHBhcmFtICB7UG9pbnR9IHJlZmVyZW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gaW50ZXJzZWN0aW9uIGRhdGEgKHNlZ21lbnQsIHBvaW50KVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBwcm94SW50ZXJzZWN0aW9uKHdheXBvaW50cywgcmVmZXJlbmNlKSB7XG4gIHJldHVybiBnZXRCZW5kcG9pbnRJbnRlcnNlY3Rpb24od2F5cG9pbnRzLCByZWZlcmVuY2UpIHx8IGdldFBhdGhJbnRlcnNlY3Rpb24od2F5cG9pbnRzLCByZWZlcmVuY2UpO1xufVxuIiwiLyoqXG4gKiBHZXQgdGhlIGxvZ2FyaXRobSBvZiB4IHdpdGggYmFzZSAxMFxuICogQHBhcmFtICB7SW50ZWdlcn0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5sb2coMTApO1xufVxuXG5leHBvcnQgeyBkZWx0YSBhcyBzdWJzdHJhY3QgfSBmcm9tICcuL1Bvc2l0aW9uVXRpbCc7XG4iLCJpbXBvcnQge1xuICBnZXRPcmlnaW5hbCBhcyBnZXRPcmlnaW5hbEV2ZW50XG59IGZyb20gJy4vRXZlbnQnO1xuXG5pbXBvcnQge1xuICBpc01hY1xufSBmcm9tICcuL1BsYXRmb3JtJztcblxuZXhwb3J0IHtcbiAgaXNNYWNcbn0gZnJvbSAnLi9QbGF0Zm9ybSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0J1dHRvbihldmVudCwgYnV0dG9uKSB7XG4gIHJldHVybiAoZ2V0T3JpZ2luYWxFdmVudChldmVudCkgfHwgZXZlbnQpLmJ1dHRvbiA9PT0gYnV0dG9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcmltYXJ5QnV0dG9uKGV2ZW50KSB7XG5cbiAgLy8gYnV0dG9uID09PSAwIC0+IGxlZnQgw6FrYSBwcmltYXJ5IG1vdXNlIGJ1dHRvblxuICByZXR1cm4gaXNCdXR0b24oZXZlbnQsIDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXhpbGlhcnlCdXR0b24oZXZlbnQpIHtcblxuICAvLyBidXR0b24gPT09IDEgLT4gYXV4aWxpYXJ5IMOha2Egd2hlZWwgYnV0dG9uXG4gIHJldHVybiBpc0J1dHRvbihldmVudCwgMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NlY29uZGFyeUJ1dHRvbihldmVudCkge1xuXG4gIC8vIGJ1dHRvbiA9PT0gMiAtPiByaWdodCDDoWthIHNlY29uZGFyeSBidXR0b25cbiAgcmV0dXJuIGlzQnV0dG9uKGV2ZW50LCAyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1ByaW1hcnlNb2RpZmllcihldmVudCkge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IGdldE9yaWdpbmFsRXZlbnQoZXZlbnQpIHx8IGV2ZW50O1xuXG4gIGlmICghaXNQcmltYXJ5QnV0dG9uKGV2ZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFVzZSBjbWQgYXMgcHJpbWFyeSBtb2RpZmllciBrZXkgZm9yIG1hYyBPU1xuICBpZiAoaXNNYWMoKSkge1xuICAgIHJldHVybiBvcmlnaW5hbEV2ZW50Lm1ldGFLZXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsRXZlbnQuY3RybEtleTtcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNTZWNvbmRhcnlNb2RpZmllcihldmVudCkge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IGdldE9yaWdpbmFsRXZlbnQoZXZlbnQpIHx8IGV2ZW50O1xuXG4gIHJldHVybiBpc1ByaW1hcnlCdXR0b24oZXZlbnQpICYmIG9yaWdpbmFsRXZlbnQuc2hpZnRLZXk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNNYWMoKSB7XG4gIHJldHVybiAoL21hYy9pKS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG59IiwiZXhwb3J0IGZ1bmN0aW9uIGNlbnRlcihib3VuZHMpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBib3VuZHMueCArIChib3VuZHMud2lkdGggLyAyKSxcbiAgICB5OiBib3VuZHMueSArIChib3VuZHMuaGVpZ2h0IC8gMilcbiAgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZGVsdGEoYSwgYikge1xuICByZXR1cm4ge1xuICAgIHg6IGEueCAtIGIueCxcbiAgICB5OiBhLnkgLSBiLnlcbiAgfTtcbn0iLCIvKipcbiAqIFJlbW92ZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYSBjb2xsZWN0aW9uIHVudGlsIGl0IGlzIGVtcHR5LlxuICpcbiAqIFRoaXMgaXMgYSBudWxsLXNhZmUgb3BlcmF0aW9uIHRoYXQgZW5zdXJlcyBlbGVtZW50c1xuICogYXJlIGJlaW5nIHJlbW92ZWQgZnJvbSB0aGUgZ2l2ZW4gY29sbGVjdGlvbiB1bnRpbCB0aGVcbiAqIGNvbGxlY3Rpb24gaXMgZW1wdHkuXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIGRlYWxzIHdpdGggdGhlIGZhY3QgdGhhdCBhIHJlbW92ZSBvcGVyYXRpb25cbiAqIG1heSB0b3VjaCwgaS5lLiByZW1vdmUgbXVsdGlwbGUgZWxlbWVudHMgaW4gdGhlIGNvbGxlY3Rpb25cbiAqIGF0IGEgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtjb2xsZWN0aW9uXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVtb3ZlRm5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fSB0aGUgY2xlYXJlZCBjb2xsZWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYXZlQ2xlYXIoY29sbGVjdGlvbiwgcmVtb3ZlRm4pIHtcblxuICBpZiAodHlwZW9mIHJlbW92ZUZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVGbiBpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghY29sbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlO1xuXG4gIHdoaWxlICgoZSA9IGNvbGxlY3Rpb25bMF0pKSB7XG4gICAgcmVtb3ZlRm4oZSk7XG4gIH1cblxuICByZXR1cm4gY29sbGVjdGlvbjtcbn1cbiIsImltcG9ydCB7XG4gIGF0dHIgYXMgc3ZnQXR0cixcbiAgY3JlYXRlIGFzIHN2Z0NyZWF0ZVxufSBmcm9tICd0aW55LXN2Zyc7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudHNUb1BhdGgoZWxlbWVudHMpIHtcbiAgcmV0dXJuIGVsZW1lbnRzLmpvaW4oJywnKS5yZXBsYWNlKC8sPyhbQS16XSksPy9nLCAnJDEnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvU1ZHUG9pbnRzKHBvaW50cykge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDAsIHA7IChwID0gcG9pbnRzW2ldKTsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IHAueCArICcsJyArIHAueSArICcgJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaW5lKHBvaW50cywgYXR0cnMpIHtcblxuICB2YXIgbGluZSA9IHN2Z0NyZWF0ZSgncG9seWxpbmUnKTtcbiAgc3ZnQXR0cihsaW5lLCB7IHBvaW50czogdG9TVkdQb2ludHMocG9pbnRzKSB9KTtcblxuICBpZiAoYXR0cnMpIHtcbiAgICBzdmdBdHRyKGxpbmUsIGF0dHJzKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTGluZShnZngsIHBvaW50cykge1xuICBzdmdBdHRyKGdmeCwgeyBwb2ludHM6IHRvU1ZHUG9pbnRzKHBvaW50cykgfSk7XG5cbiAgcmV0dXJuIGdmeDtcbn1cbiIsImltcG9ydCB7XHJcbiAgdHJhbnNmb3JtIGFzIHN2Z1RyYW5zZm9ybSxcclxuICBjcmVhdGVUcmFuc2Zvcm1cclxufSBmcm9tICd0aW55LXN2Zyc7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7PFNWR0VsZW1lbnQ+fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYW1vdW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKGdmeCwgeCwgeSwgYW5nbGUsIGFtb3VudCkge1xyXG4gIHZhciB0cmFuc2xhdGUgPSBjcmVhdGVUcmFuc2Zvcm0oKTtcclxuICB0cmFuc2xhdGUuc2V0VHJhbnNsYXRlKHgsIHkpO1xyXG5cclxuICB2YXIgcm90YXRlID0gY3JlYXRlVHJhbnNmb3JtKCk7XHJcbiAgcm90YXRlLnNldFJvdGF0ZShhbmdsZSB8fCAwLCAwLCAwKTtcclxuXHJcbiAgdmFyIHNjYWxlID0gY3JlYXRlVHJhbnNmb3JtKCk7XHJcbiAgc2NhbGUuc2V0U2NhbGUoYW1vdW50IHx8IDEsIGFtb3VudCB8fCAxKTtcclxuXHJcbiAgc3ZnVHJhbnNmb3JtKGdmeCwgWyB0cmFuc2xhdGUsIHJvdGF0ZSwgc2NhbGUgXSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKGdmeCwgeCwgeSkge1xyXG4gIHZhciB0cmFuc2xhdGUgPSBjcmVhdGVUcmFuc2Zvcm0oKTtcclxuICB0cmFuc2xhdGUuc2V0VHJhbnNsYXRlKHgsIHkpO1xyXG5cclxuICBzdmdUcmFuc2Zvcm0oZ2Z4LCB0cmFuc2xhdGUpO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUoZ2Z4LCBhbmdsZSkge1xyXG4gIHZhciByb3RhdGUgPSBjcmVhdGVUcmFuc2Zvcm0oKTtcclxuICByb3RhdGUuc2V0Um90YXRlKGFuZ2xlLCAwLCAwKTtcclxuXHJcbiAgc3ZnVHJhbnNmb3JtKGdmeCwgcm90YXRlKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKGdmeCwgYW1vdW50KSB7XHJcbiAgdmFyIHNjYWxlID0gY3JlYXRlVHJhbnNmb3JtKCk7XHJcbiAgc2NhbGUuc2V0U2NhbGUoYW1vdW50LCBhbW91bnQpO1xyXG5cclxuICBzdmdUcmFuc2Zvcm0oZ2Z4LCBzY2FsZSk7XHJcbn0iLCJpbXBvcnQge1xuICBpc09iamVjdCxcbiAgYXNzaWduLFxuICBmb3JFYWNoLFxuICByZWR1Y2Vcbn0gZnJvbSAnbWluLWRhc2gnO1xuXG5pbXBvcnQge1xuICBhcHBlbmQgYXMgc3ZnQXBwZW5kLFxuICBhdHRyIGFzIHN2Z0F0dHIsXG4gIGNyZWF0ZSBhcyBzdmdDcmVhdGUsXG4gIHJlbW92ZSBhcyBzdmdSZW1vdmVcbn0gZnJvbSAndGlueS1zdmcnO1xuXG52YXIgREVGQVVMVF9CT1hfUEFERElORyA9IDA7XG5cbnZhciBERUZBVUxUX0xBQkVMX1NJWkUgPSB7XG4gIHdpZHRoOiAxNTAsXG4gIGhlaWdodDogNTBcbn07XG5cblxuZnVuY3Rpb24gcGFyc2VBbGlnbihhbGlnbikge1xuXG4gIHZhciBwYXJ0cyA9IGFsaWduLnNwbGl0KCctJyk7XG5cbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsOiBwYXJ0c1swXSB8fCAnY2VudGVyJyxcbiAgICB2ZXJ0aWNhbDogcGFydHNbMV0gfHwgJ3RvcCdcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYWRkaW5nKHBhZGRpbmcpIHtcblxuICBpZiAoaXNPYmplY3QocGFkZGluZykpIHtcbiAgICByZXR1cm4gYXNzaWduKHsgdG9wOiAwLCBsZWZ0OiAwLCByaWdodDogMCwgYm90dG9tOiAwIH0sIHBhZGRpbmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHBhZGRpbmcsXG4gICAgICBsZWZ0OiBwYWRkaW5nLFxuICAgICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgICBib3R0b206IHBhZGRpbmdcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRleHRCQm94KHRleHQsIGZha2VUZXh0KSB7XG5cbiAgZmFrZVRleHQudGV4dENvbnRlbnQgPSB0ZXh0O1xuXG4gIHZhciB0ZXh0QkJveDtcblxuICB0cnkge1xuICAgIHZhciBiYm94LFxuICAgICAgICBlbXB0eUxpbmUgPSB0ZXh0ID09PSAnJztcblxuICAgIC8vIGFkZCBkdW1teSB0ZXh0LCB3aGVuIGxpbmUgaXMgZW1wdHkgdG9cbiAgICAvLyBkZXRlcm1pbmUgY29ycmVjdCBoZWlnaHRcbiAgICBmYWtlVGV4dC50ZXh0Q29udGVudCA9IGVtcHR5TGluZSA/ICdkdW1teScgOiB0ZXh0O1xuXG4gICAgdGV4dEJCb3ggPSBmYWtlVGV4dC5nZXRCQm94KCk7XG5cbiAgICAvLyB0YWtlIHRleHQgcmVuZGVyaW5nIHJlbGF0ZWQgaG9yaXpvbnRhbFxuICAgIC8vIHBhZGRpbmcgaW50byBhY2NvdW50XG4gICAgYmJveCA9IHtcbiAgICAgIHdpZHRoOiB0ZXh0QkJveC53aWR0aCArIHRleHRCQm94LnggKiAyLFxuICAgICAgaGVpZ2h0OiB0ZXh0QkJveC5oZWlnaHRcbiAgICB9O1xuXG4gICAgaWYgKGVtcHR5TGluZSkge1xuXG4gICAgICAvLyBjb3JyZWN0IHdpZHRoXG4gICAgICBiYm94LndpZHRoID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gYmJveDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgfVxufVxuXG5cbi8qKlxuICogTGF5b3V0IHRoZSBuZXh0IGxpbmUgYW5kIHJldHVybiB0aGUgbGF5b3V0ZWQgZWxlbWVudC5cbiAqXG4gKiBBbHRlcnMgdGhlIGxpbmVzIHBhc3NlZC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxzdHJpbmc+fSBsaW5lc1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbGluZSBkZXNjcmlwdG9yLCBhbiBvYmplY3QgeyB3aWR0aCwgaGVpZ2h0LCB0ZXh0IH1cbiAqL1xuZnVuY3Rpb24gbGF5b3V0TmV4dChsaW5lcywgbWF4V2lkdGgsIGZha2VUZXh0KSB7XG5cbiAgdmFyIG9yaWdpbmFsTGluZSA9IGxpbmVzLnNoaWZ0KCksXG4gICAgICBmaXRMaW5lID0gb3JpZ2luYWxMaW5lO1xuXG4gIHZhciB0ZXh0QkJveDtcblxuICBmb3IgKDs7KSB7XG4gICAgdGV4dEJCb3ggPSBnZXRUZXh0QkJveChmaXRMaW5lLCBmYWtlVGV4dCk7XG5cbiAgICB0ZXh0QkJveC53aWR0aCA9IGZpdExpbmUgPyB0ZXh0QkJveC53aWR0aCA6IDA7XG5cbiAgICAvLyB0cnkgdG8gZml0XG4gICAgaWYgKGZpdExpbmUgPT09ICcgJyB8fCBmaXRMaW5lID09PSAnJyB8fCB0ZXh0QkJveC53aWR0aCA8IE1hdGgucm91bmQobWF4V2lkdGgpIHx8IGZpdExpbmUubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIGZpdChsaW5lcywgZml0TGluZSwgb3JpZ2luYWxMaW5lLCB0ZXh0QkJveCk7XG4gICAgfVxuXG4gICAgZml0TGluZSA9IHNob3J0ZW5MaW5lKGZpdExpbmUsIHRleHRCQm94LndpZHRoLCBtYXhXaWR0aCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZml0KGxpbmVzLCBmaXRMaW5lLCBvcmlnaW5hbExpbmUsIHRleHRCQm94KSB7XG4gIGlmIChmaXRMaW5lLmxlbmd0aCA8IG9yaWdpbmFsTGluZS5sZW5ndGgpIHtcbiAgICB2YXIgcmVtYWluZGVyID0gb3JpZ2luYWxMaW5lLnNsaWNlKGZpdExpbmUubGVuZ3RoKS50cmltKCk7XG5cbiAgICBsaW5lcy51bnNoaWZ0KHJlbWFpbmRlcik7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB0ZXh0QkJveC53aWR0aCxcbiAgICBoZWlnaHQ6IHRleHRCQm94LmhlaWdodCxcbiAgICB0ZXh0OiBmaXRMaW5lXG4gIH07XG59XG5cbnZhciBTT0ZUX0JSRUFLID0gJ1xcdTAwQUQnO1xuXG5cbi8qKlxuICogU2hvcnRlbnMgYSBsaW5lIGJhc2VkIG9uIHNwYWNpbmcgYW5kIGh5cGhlbnMuXG4gKiBSZXR1cm5zIHRoZSBzaG9ydGVuZWQgcmVzdWx0IG9uIHN1Y2Nlc3MuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBsaW5lXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG1heExlbmd0aCB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIG9mIHRoZSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHNob3J0ZW5lZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gc2VtYW50aWNTaG9ydGVuKGxpbmUsIG1heExlbmd0aCkge1xuXG4gIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoLyhcXHN8LXxcXHUwMEFEKS9nKSxcbiAgICAgIHBhcnQsXG4gICAgICBzaG9ydGVuZWRQYXJ0cyA9IFtdLFxuICAgICAgbGVuZ3RoID0gMDtcblxuICAvLyB0cnkgdG8gc2hvcnRlbiB2aWEgYnJlYWsgY2hhcnNcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblxuICAgIHdoaWxlICgocGFydCA9IHBhcnRzLnNoaWZ0KCkpKSB7XG4gICAgICBpZiAocGFydC5sZW5ndGggKyBsZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgc2hvcnRlbmVkUGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgbGVuZ3RoICs9IHBhcnQubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyByZW1vdmUgcHJldmlvdXMgcGFydCwgdG9vIGlmIGh5cGhlbiBkb2VzIG5vdCBmaXQgYW55bW9yZVxuICAgICAgICBpZiAocGFydCA9PT0gJy0nIHx8IHBhcnQgPT09IFNPRlRfQlJFQUspIHtcbiAgICAgICAgICBzaG9ydGVuZWRQYXJ0cy5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBsYXN0ID0gc2hvcnRlbmVkUGFydHNbc2hvcnRlbmVkUGFydHMubGVuZ3RoIC0gMV07XG5cbiAgLy8gdHJhbnNsYXRlIHRyYWlsaW5nIHNvZnQgYnJlYWsgdG8gYWN0dWFsIGh5cGhlblxuICBpZiAobGFzdCAmJiBsYXN0ID09PSBTT0ZUX0JSRUFLKSB7XG4gICAgc2hvcnRlbmVkUGFydHNbc2hvcnRlbmVkUGFydHMubGVuZ3RoIC0gMV0gPSAnLSc7XG4gIH1cblxuICByZXR1cm4gc2hvcnRlbmVkUGFydHMuam9pbignJyk7XG59XG5cblxuZnVuY3Rpb24gc2hvcnRlbkxpbmUobGluZSwgd2lkdGgsIG1heFdpZHRoKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1heChsaW5lLmxlbmd0aCAqIChtYXhXaWR0aCAvIHdpZHRoKSwgMSk7XG5cbiAgLy8gdHJ5IHRvIHNob3J0ZW4gc2VtYW50aWNhbGx5IChpLmUuIGJhc2VkIG9uIHNwYWNlcyBhbmQgaHlwaGVucylcbiAgdmFyIHNob3J0ZW5lZExpbmUgPSBzZW1hbnRpY1Nob3J0ZW4obGluZSwgbGVuZ3RoKTtcblxuICBpZiAoIXNob3J0ZW5lZExpbmUpIHtcblxuICAgIC8vIGZvcmNlIHNob3J0ZW4gYnkgY3V0dGluZyB0aGUgbG9uZyB3b3JkXG4gICAgc2hvcnRlbmVkTGluZSA9IGxpbmUuc2xpY2UoMCwgTWF0aC5tYXgoTWF0aC5yb3VuZChsZW5ndGggLSAxKSwgMSkpO1xuICB9XG5cbiAgcmV0dXJuIHNob3J0ZW5lZExpbmU7XG59XG5cblxuZnVuY3Rpb24gZ2V0SGVscGVyU3ZnKCkge1xuICB2YXIgaGVscGVyU3ZnID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hlbHBlci1zdmcnKTtcblxuICBpZiAoIWhlbHBlclN2Zykge1xuICAgIGhlbHBlclN2ZyA9IHN2Z0NyZWF0ZSgnc3ZnJyk7XG5cbiAgICBzdmdBdHRyKGhlbHBlclN2Zywge1xuICAgICAgaWQ6ICdoZWxwZXItc3ZnJyxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgc3R5bGU6ICd2aXNpYmlsaXR5OiBoaWRkZW47IHBvc2l0aW9uOiBmaXhlZCdcbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGVscGVyU3ZnKTtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJTdmc7XG59XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxhYmVsIHV0aWxpdHlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge0RpbWVuc2lvbnN9IGNvbmZpZy5zaXplXG4gKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnBhZGRpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcuc3R5bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcuYWxpZ25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGV4dChjb25maWcpIHtcblxuICB0aGlzLl9jb25maWcgPSBhc3NpZ24oe30sIHtcbiAgICBzaXplOiBERUZBVUxUX0xBQkVMX1NJWkUsXG4gICAgcGFkZGluZzogREVGQVVMVF9CT1hfUEFERElORyxcbiAgICBzdHlsZToge30sXG4gICAgYWxpZ246ICdjZW50ZXItdG9wJ1xuICB9LCBjb25maWcgfHwge30pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxheW91dGVkIHRleHQgYXMgYW4gU1ZHIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHJldHVybiB7U1ZHRWxlbWVudH1cbiAqL1xuVGV4dC5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMubGF5b3V0VGV4dCh0ZXh0LCBvcHRpb25zKS5lbGVtZW50O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGFiZWxzIGxheW91dGVkIGRpbWVuc2lvbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgdG8gbGF5b3V0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm4ge0RpbWVuc2lvbnN9XG4gKi9cblRleHQucHJvdG90eXBlLmdldERpbWVuc2lvbnMgPSBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmxheW91dFRleHQodGV4dCwgb3B0aW9ucykuZGltZW5zaW9ucztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGxhYmVsIGFuZCBpdHMgYm91bmRpbmcgYm94LlxuICpcbiAqIEBtZXRob2QgVGV4dCNjcmVhdGVUZXh0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgdGhlIHRleHQgdG8gcmVuZGVyIG9uIHRoZSBsYWJlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmFsaWduIGhvdyB0byBhbGlnbiBpbiB0aGUgYm91bmRpbmcgYm94LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW55IG9mIHsgJ2NlbnRlci1taWRkbGUnLCAnY2VudGVyLXRvcCcgfSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzIHRvICdjZW50ZXItdG9wJy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN0eWxlIHN0eWxlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5maXRCb3ggaW5kaWNhdGVzIGlmIGJveCB3aWxsIGJlIHJlY2FsY3VsYXRlZCB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXQgdGV4dFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0geyBlbGVtZW50LCBkaW1lbnNpb25zIH1cbiAqL1xuVGV4dC5wcm90b3R5cGUubGF5b3V0VGV4dCA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgdmFyIGJveCA9IGFzc2lnbih7fSwgdGhpcy5fY29uZmlnLnNpemUsIG9wdGlvbnMuYm94KSxcbiAgICAgIHN0eWxlID0gYXNzaWduKHt9LCB0aGlzLl9jb25maWcuc3R5bGUsIG9wdGlvbnMuc3R5bGUpLFxuICAgICAgYWxpZ24gPSBwYXJzZUFsaWduKG9wdGlvbnMuYWxpZ24gfHwgdGhpcy5fY29uZmlnLmFsaWduKSxcbiAgICAgIHBhZGRpbmcgPSBwYXJzZVBhZGRpbmcob3B0aW9ucy5wYWRkaW5nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBhZGRpbmcgOiB0aGlzLl9jb25maWcucGFkZGluZyksXG4gICAgICBmaXRCb3ggPSBvcHRpb25zLmZpdEJveCB8fCBmYWxzZTtcblxuICB2YXIgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQoc3R5bGUpO1xuXG4gIC8vIHdlIHNwbGl0IHRleHQgYnkgbGluZXMgYW5kIG5vcm1hbGl6ZVxuICAvLyB7c29mdCBicmVha30gKyB7bGluZSBicmVha30gPT4geyBsaW5lIGJyZWFrIH1cbiAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgvXFx1MDBBRD9cXHI/XFxuLyksXG4gICAgICBsYXlvdXRlZCA9IFtdO1xuXG4gIHZhciBtYXhXaWR0aCA9IGJveC53aWR0aCAtIHBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQ7XG5cbiAgLy8gZW5zdXJlIGNvcnJlY3QgcmVuZGVyaW5nIGJ5IGF0dGFjaGluZyBoZWxwZXIgdGV4dCBub2RlIHRvIGludmlzaWJsZSBTVkdcbiAgdmFyIGhlbHBlclRleHQgPSBzdmdDcmVhdGUoJ3RleHQnKTtcbiAgc3ZnQXR0cihoZWxwZXJUZXh0LCB7IHg6IDAsIHk6IDAgfSk7XG4gIHN2Z0F0dHIoaGVscGVyVGV4dCwgc3R5bGUpO1xuXG4gIHZhciBoZWxwZXJTdmcgPSBnZXRIZWxwZXJTdmcoKTtcblxuICBzdmdBcHBlbmQoaGVscGVyU3ZnLCBoZWxwZXJUZXh0KTtcblxuICB3aGlsZSAobGluZXMubGVuZ3RoKSB7XG4gICAgbGF5b3V0ZWQucHVzaChsYXlvdXROZXh0KGxpbmVzLCBtYXhXaWR0aCwgaGVscGVyVGV4dCkpO1xuICB9XG5cbiAgaWYgKGFsaWduLnZlcnRpY2FsID09PSAnbWlkZGxlJykge1xuICAgIHBhZGRpbmcudG9wID0gcGFkZGluZy5ib3R0b20gPSAwO1xuICB9XG5cbiAgdmFyIHRvdGFsSGVpZ2h0ID0gcmVkdWNlKGxheW91dGVkLCBmdW5jdGlvbihzdW0sIGxpbmUsIGlkeCkge1xuICAgIHJldHVybiBzdW0gKyAobGluZUhlaWdodCB8fCBsaW5lLmhlaWdodCk7XG4gIH0sIDApICsgcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcblxuICB2YXIgbWF4TGluZVdpZHRoID0gcmVkdWNlKGxheW91dGVkLCBmdW5jdGlvbihzdW0sIGxpbmUsIGlkeCkge1xuICAgIHJldHVybiBsaW5lLndpZHRoID4gc3VtID8gbGluZS53aWR0aCA6IHN1bTtcbiAgfSwgMCk7XG5cbiAgLy8gdGhlIHkgcG9zaXRpb24gb2YgdGhlIG5leHQgbGluZVxuICB2YXIgeSA9IHBhZGRpbmcudG9wO1xuXG4gIGlmIChhbGlnbi52ZXJ0aWNhbCA9PT0gJ21pZGRsZScpIHtcbiAgICB5ICs9IChib3guaGVpZ2h0IC0gdG90YWxIZWlnaHQpIC8gMjtcbiAgfVxuXG4gIC8vIG1hZ2ljIG51bWJlciBpbml0aWFsIG9mZnNldFxuICB5IC09IChsaW5lSGVpZ2h0IHx8IGxheW91dGVkWzBdLmhlaWdodCkgLyA0O1xuXG5cbiAgdmFyIHRleHRFbGVtZW50ID0gc3ZnQ3JlYXRlKCd0ZXh0Jyk7XG5cbiAgc3ZnQXR0cih0ZXh0RWxlbWVudCwgc3R5bGUpO1xuXG4gIC8vIGxheW91dCBlYWNoIGxpbmUgdGFraW5nIGludG8gYWNjb3VudCB0aGF0IHBhcmVudFxuICAvLyBzaGFwZSBtaWdodCByZXNpemUgdG8gZml0IHRleHQgc2l6ZVxuICBmb3JFYWNoKGxheW91dGVkLCBmdW5jdGlvbihsaW5lKSB7XG5cbiAgICB2YXIgeDtcblxuICAgIHkgKz0gKGxpbmVIZWlnaHQgfHwgbGluZS5oZWlnaHQpO1xuXG4gICAgc3dpdGNoIChhbGlnbi5ob3Jpem9udGFsKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB4ID0gcGFkZGluZy5sZWZ0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB4ID0gKChmaXRCb3ggPyBtYXhMaW5lV2lkdGggOiBtYXhXaWR0aClcbiAgICAgICAgLSBwYWRkaW5nLnJpZ2h0IC0gbGluZS53aWR0aCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG5cbiAgICAgIC8vIGFrYSBjZW50ZXJcbiAgICAgIHggPSBNYXRoLm1heCgoKChmaXRCb3ggPyBtYXhMaW5lV2lkdGggOiBtYXhXaWR0aClcbiAgICAgICAgLSBsaW5lLndpZHRoKSAvIDIgKyBwYWRkaW5nLmxlZnQpLCAwKTtcbiAgICB9XG5cbiAgICB2YXIgdHNwYW4gPSBzdmdDcmVhdGUoJ3RzcGFuJyk7XG4gICAgc3ZnQXR0cih0c3BhbiwgeyB4OiB4LCB5OiB5IH0pO1xuXG4gICAgdHNwYW4udGV4dENvbnRlbnQgPSBsaW5lLnRleHQ7XG5cbiAgICBzdmdBcHBlbmQodGV4dEVsZW1lbnQsIHRzcGFuKTtcbiAgfSk7XG5cbiAgc3ZnUmVtb3ZlKGhlbHBlclRleHQpO1xuXG4gIHZhciBkaW1lbnNpb25zID0ge1xuICAgIHdpZHRoOiBtYXhMaW5lV2lkdGgsXG4gICAgaGVpZ2h0OiB0b3RhbEhlaWdodFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICBlbGVtZW50OiB0ZXh0RWxlbWVudFxuICB9O1xufTtcblxuXG5mdW5jdGlvbiBnZXRMaW5lSGVpZ2h0KHN0eWxlKSB7XG4gIGlmICgnZm9udFNpemUnIGluIHN0eWxlICYmICdsaW5lSGVpZ2h0JyBpbiBzdHlsZSkge1xuICAgIHJldHVybiBzdHlsZS5saW5lSGVpZ2h0ICogcGFyc2VJbnQoc3R5bGUuZm9udFNpemUsIDEwKTtcbiAgfVxufSIsInZhciBDTEFTU19QQVRURVJOID0gL15jbGFzcyAvO1xuXG5mdW5jdGlvbiBpc0NsYXNzKGZuKSB7XG4gIHJldHVybiBDTEFTU19QQVRURVJOLnRlc3QoZm4udG9TdHJpbmcoKSk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuZnVuY3Rpb24gaGFzT3duUHJvcChvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5mdW5jdGlvbiBhbm5vdGF0ZSgpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgYXJncyA9IGFyZ3NbMF07XG4gIH1cblxuICB2YXIgZm4gPSBhcmdzLnBvcCgpO1xuXG4gIGZuLiRpbmplY3QgPSBhcmdzO1xuXG4gIHJldHVybiBmbjtcbn1cblxuXG4vLyBDdXJyZW50IGxpbWl0YXRpb25zOlxuLy8gLSBjYW4ndCBwdXQgaW50byBcImZ1bmN0aW9uIGFyZ1wiIGNvbW1lbnRzXG4vLyBmdW5jdGlvbiAvKiAobm8gcGFyZW50aGVzaXMgbGlrZSB0aGlzKSAqLyAoKXt9XG4vLyBmdW5jdGlvbiBhYmMoIC8qIHh4IChubyBwYXJlbnRoZXNpcyBsaWtlIHRoaXMpICovIGEsIGIpIHt9XG4vL1xuLy8gSnVzdCBwdXQgdGhlIGNvbW1lbnQgYmVmb3JlIGZ1bmN0aW9uIG9yIGluc2lkZTpcbi8vIC8qICgoKHRoaXMgaXMgZmluZSkpKSAqLyBmdW5jdGlvbihhLCBiKSB7fVxuLy8gZnVuY3Rpb24gYWJjKGEpIHsgLyogKCgodGhpcyBpcyBmaW5lKSkpICovfVxuLy9cbi8vIC0gY2FuJ3QgcmVsaWFibHkgYXV0by1hbm5vdGF0ZSBjb25zdHJ1Y3Rvcjsgd2UnbGwgbWF0Y2ggdGhlXG4vLyBmaXJzdCBjb25zdHJ1Y3RvciguLi4pIHBhdHRlcm4gZm91bmQgd2hpY2ggbWF5IGJlIHRoZSBvbmVcbi8vIG9mIGEgbmVzdGVkIGNsYXNzLCB0b28uXG5cbnZhciBDT05TVFJVQ1RPUl9BUkdTID0gL2NvbnN0cnVjdG9yXFxzKlteKF0qXFwoXFxzKihbXildKilcXCkvbTtcbnZhciBGTl9BUkdTID0gL14oPzphc3luYyApPyg/OmZ1bmN0aW9uXFxzKik/W14oXSpcXChcXHMqKFteKV0qKVxcKS9tO1xudmFyIEZOX0FSRyA9IC9cXC9cXCooW14qXSopXFwqXFwvL207XG5cbmZ1bmN0aW9uIHBhcnNlQW5ub3RhdGlvbnMoZm4pIHtcblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYW5ub3RhdGUgXCInICsgZm4gKyAnXCIuIEV4cGVjdGVkIGEgZnVuY3Rpb24hJyk7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSBmbi50b1N0cmluZygpLm1hdGNoKGlzQ2xhc3MoZm4pID8gQ09OU1RSVUNUT1JfQVJHUyA6IEZOX0FSR1MpO1xuXG4gIC8vIG1heSBwYXJzZSBjbGFzcyB3aXRob3V0IGNvbnN0cnVjdG9yXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gbWF0Y2hbMV0gJiYgbWF0Y2hbMV0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgbWF0Y2ggPSBhcmcubWF0Y2goRk5fQVJHKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXS50cmltKCkgOiBhcmcudHJpbSgpO1xuICB9KSB8fCBbXTtcbn1cblxuZnVuY3Rpb24gTW9kdWxlKCkge1xuICB2YXIgcHJvdmlkZXJzID0gW107XG5cbiAgdGhpcy5mYWN0b3J5ID0gZnVuY3Rpb24obmFtZSwgZmFjdG9yeSkge1xuICAgIHByb3ZpZGVycy5wdXNoKFtuYW1lLCAnZmFjdG9yeScsIGZhY3RvcnldKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLnZhbHVlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBwcm92aWRlcnMucHVzaChbbmFtZSwgJ3ZhbHVlJywgdmFsdWVdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLnR5cGUgPSBmdW5jdGlvbihuYW1lLCB0eXBlKSB7XG4gICAgcHJvdmlkZXJzLnB1c2goW25hbWUsICd0eXBlJywgdHlwZV0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMuZm9yRWFjaCA9IGZ1bmN0aW9uKGl0ZXJhdG9yKSB7XG4gICAgcHJvdmlkZXJzLmZvckVhY2goaXRlcmF0b3IpO1xuICB9O1xuXG59XG5cbmZ1bmN0aW9uIEluamVjdG9yKG1vZHVsZXMsIHBhcmVudCkge1xuICBwYXJlbnQgPSBwYXJlbnQgfHwge1xuICAgIGdldDogZnVuY3Rpb24obmFtZSwgc3RyaWN0KSB7XG4gICAgICBjdXJyZW50bHlSZXNvbHZpbmcucHVzaChuYW1lKTtcblxuICAgICAgaWYgKHN0cmljdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcignTm8gcHJvdmlkZXIgZm9yIFwiJyArIG5hbWUgKyAnXCIhJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBjdXJyZW50bHlSZXNvbHZpbmcgPSBbXTtcbiAgdmFyIHByb3ZpZGVycyA9IHRoaXMuX3Byb3ZpZGVycyA9IE9iamVjdC5jcmVhdGUocGFyZW50Ll9wcm92aWRlcnMgfHwgbnVsbCk7XG4gIHZhciBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHZhciBzZWxmID0gaW5zdGFuY2VzLmluamVjdG9yID0gdGhpcztcblxuICB2YXIgZXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcbiAgICB2YXIgc3RhY2sgPSBjdXJyZW50bHlSZXNvbHZpbmcuam9pbignIC0+ICcpO1xuICAgIGN1cnJlbnRseVJlc29sdmluZy5sZW5ndGggPSAwO1xuICAgIHJldHVybiBuZXcgRXJyb3Ioc3RhY2sgPyBtc2cgKyAnIChSZXNvbHZpbmc6ICcgKyBzdGFjayArICcpJyA6IG1zZyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5hbWVkIHNlcnZpY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0cmljdD10cnVlXSBpZiBmYWxzZSwgcmVzb2x2ZSBtaXNzaW5nIHNlcnZpY2VzIHRvIG51bGxcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIGdldCA9IGZ1bmN0aW9uKG5hbWUsIHN0cmljdCkge1xuICAgIGlmICghcHJvdmlkZXJzW25hbWVdICYmIG5hbWUuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgdmFyIHBpdm90ID0gZ2V0KHBhcnRzLnNoaWZ0KCkpO1xuXG4gICAgICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3RbcGFydHMuc2hpZnQoKV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwaXZvdDtcbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChpbnN0YW5jZXMsIG5hbWUpKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2VzW25hbWVdO1xuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKHByb3ZpZGVycywgbmFtZSkpIHtcbiAgICAgIGlmIChjdXJyZW50bHlSZXNvbHZpbmcuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgY3VycmVudGx5UmVzb2x2aW5nLnB1c2gobmFtZSk7XG4gICAgICAgIHRocm93IGVycm9yKCdDYW5ub3QgcmVzb2x2ZSBjaXJjdWxhciBkZXBlbmRlbmN5IScpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50bHlSZXNvbHZpbmcucHVzaChuYW1lKTtcbiAgICAgIGluc3RhbmNlc1tuYW1lXSA9IHByb3ZpZGVyc1tuYW1lXVswXShwcm92aWRlcnNbbmFtZV1bMV0pO1xuICAgICAgY3VycmVudGx5UmVzb2x2aW5nLnBvcCgpO1xuXG4gICAgICByZXR1cm4gaW5zdGFuY2VzW25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnQuZ2V0KG5hbWUsIHN0cmljdCk7XG4gIH07XG5cbiAgdmFyIGZuRGVmID0gZnVuY3Rpb24oZm4sIGxvY2Fscykge1xuXG4gICAgaWYgKHR5cGVvZiBsb2NhbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoaXNBcnJheShmbikpIHtcbiAgICAgICAgZm4gPSBhbm5vdGF0ZShmbi5zbGljZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBcIicgKyBmbiArICdcIi4gRXhwZWN0ZWQgYSBmdW5jdGlvbiEnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW5qZWN0ID0gZm4uJGluamVjdCB8fCBwYXJzZUFubm90YXRpb25zKGZuKTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gaW5qZWN0Lm1hcChmdW5jdGlvbihkZXApIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wKGxvY2FscywgZGVwKSkge1xuICAgICAgICByZXR1cm4gbG9jYWxzW2RlcF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0KGRlcCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm46IGZuLFxuICAgICAgZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXNcbiAgICB9O1xuICB9O1xuXG4gIHZhciBpbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKFR5cGUpIHtcbiAgICB2YXIgZGVmID0gZm5EZWYoVHlwZSk7XG5cbiAgICB2YXIgZm4gPSBkZWYuZm4sXG4gICAgICAgIGRlcGVuZGVuY2llcyA9IGRlZi5kZXBlbmRlbmNpZXM7XG5cbiAgICAvLyBpbnN0YW50aWF0ZSB2YXIgYXJncyBjb25zdHJ1Y3RvclxuICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KGZuLCBbIG51bGwgXS5jb25jYXQoZGVwZW5kZW5jaWVzKSk7XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKCk7XG4gIH07XG5cbiAgdmFyIGludm9rZSA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGxvY2Fscykge1xuICAgIHZhciBkZWYgPSBmbkRlZihmdW5jLCBsb2NhbHMpO1xuXG4gICAgdmFyIGZuID0gZGVmLmZuLFxuICAgICAgICBkZXBlbmRlbmNpZXMgPSBkZWYuZGVwZW5kZW5jaWVzO1xuXG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGRlcGVuZGVuY2llcyk7XG4gIH07XG5cblxuICB2YXIgY3JlYXRlUHJpdmF0ZUluamVjdG9yRmFjdG9yeSA9IGZ1bmN0aW9uKHByaXZhdGVDaGlsZEluamVjdG9yKSB7XG4gICAgcmV0dXJuIGFubm90YXRlKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHByaXZhdGVDaGlsZEluamVjdG9yLmdldChrZXkpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVDaGlsZCA9IGZ1bmN0aW9uKG1vZHVsZXMsIGZvcmNlTmV3SW5zdGFuY2VzKSB7XG4gICAgaWYgKGZvcmNlTmV3SW5zdGFuY2VzICYmIGZvcmNlTmV3SW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgdmFyIGZyb21QYXJlbnRNb2R1bGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdmFyIG1hdGNoZWRTY29wZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICB2YXIgcHJpdmF0ZUluamVjdG9yc0NhY2hlID0gW107XG4gICAgICB2YXIgcHJpdmF0ZUNoaWxkSW5qZWN0b3JzID0gW107XG4gICAgICB2YXIgcHJpdmF0ZUNoaWxkRmFjdG9yaWVzID0gW107XG5cbiAgICAgIHZhciBwcm92aWRlcjtcbiAgICAgIHZhciBjYWNoZUlkeDtcbiAgICAgIHZhciBwcml2YXRlQ2hpbGRJbmplY3RvcjtcbiAgICAgIHZhciBwcml2YXRlQ2hpbGRJbmplY3RvckZhY3Rvcnk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByb3ZpZGVycykge1xuICAgICAgICBwcm92aWRlciA9IHByb3ZpZGVyc1tuYW1lXTtcblxuICAgICAgICBpZiAoZm9yY2VOZXdJbnN0YW5jZXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICBpZiAocHJvdmlkZXJbMl0gPT09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgY2FjaGVJZHggPSBwcml2YXRlSW5qZWN0b3JzQ2FjaGUuaW5kZXhPZihwcm92aWRlclszXSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgIHByaXZhdGVDaGlsZEluamVjdG9yID0gcHJvdmlkZXJbM10uY3JlYXRlQ2hpbGQoW10sIGZvcmNlTmV3SW5zdGFuY2VzKTtcbiAgICAgICAgICAgICAgcHJpdmF0ZUNoaWxkSW5qZWN0b3JGYWN0b3J5ID0gY3JlYXRlUHJpdmF0ZUluamVjdG9yRmFjdG9yeShwcml2YXRlQ2hpbGRJbmplY3Rvcik7XG4gICAgICAgICAgICAgIHByaXZhdGVJbmplY3RvcnNDYWNoZS5wdXNoKHByb3ZpZGVyWzNdKTtcbiAgICAgICAgICAgICAgcHJpdmF0ZUNoaWxkSW5qZWN0b3JzLnB1c2gocHJpdmF0ZUNoaWxkSW5qZWN0b3IpO1xuICAgICAgICAgICAgICBwcml2YXRlQ2hpbGRGYWN0b3JpZXMucHVzaChwcml2YXRlQ2hpbGRJbmplY3RvckZhY3RvcnkpO1xuICAgICAgICAgICAgICBmcm9tUGFyZW50TW9kdWxlW25hbWVdID0gW3ByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeSwgbmFtZSwgJ3ByaXZhdGUnLCBwcml2YXRlQ2hpbGRJbmplY3Rvcl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tUGFyZW50TW9kdWxlW25hbWVdID0gW3ByaXZhdGVDaGlsZEZhY3Rvcmllc1tjYWNoZUlkeF0sIG5hbWUsICdwcml2YXRlJywgcHJpdmF0ZUNoaWxkSW5qZWN0b3JzW2NhY2hlSWR4XV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21QYXJlbnRNb2R1bGVbbmFtZV0gPSBbcHJvdmlkZXJbMl0sIHByb3ZpZGVyWzFdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0Y2hlZFNjb3Blc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHByb3ZpZGVyWzJdID09PSAnZmFjdG9yeScgfHwgcHJvdmlkZXJbMl0gPT09ICd0eXBlJykgJiYgcHJvdmlkZXJbMV0uJHNjb3BlKSB7XG4gICAgICAgICAgLyoganNoaW50IC1XMDgzICovXG4gICAgICAgICAgZm9yY2VOZXdJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbihzY29wZSkge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyWzFdLiRzY29wZS5pbmRleE9mKHNjb3BlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFtwcm92aWRlclsyXSwgcHJvdmlkZXJbMV1dO1xuICAgICAgICAgICAgICBtYXRjaGVkU2NvcGVzW3Njb3BlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yY2VOZXdJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbihzY29wZSkge1xuICAgICAgICBpZiAoIW1hdGNoZWRTY29wZXNbc2NvcGVdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwcm92aWRlciBmb3IgXCInICsgc2NvcGUgKyAnXCIuIENhbm5vdCB1c2UgcHJvdmlkZXIgZnJvbSB0aGUgcGFyZW50IScpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbW9kdWxlcy51bnNoaWZ0KGZyb21QYXJlbnRNb2R1bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSW5qZWN0b3IobW9kdWxlcywgc2VsZik7XG4gIH07XG5cbiAgdmFyIGZhY3RvcnlNYXAgPSB7XG4gICAgZmFjdG9yeTogaW52b2tlLFxuICAgIHR5cGU6IGluc3RhbnRpYXRlLFxuICAgIHZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlKSB7XG5cbiAgICBmdW5jdGlvbiBhcnJheVVud3JhcCh0eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGUgIT09ICd2YWx1ZScgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBhbm5vdGF0ZSh2YWx1ZS5zbGljZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIFRPRE8odm9qdGEpOiBoYW5kbGUgd3JvbmcgaW5wdXRzIChtb2R1bGVzKVxuICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBNb2R1bGUpIHtcbiAgICAgIG1vZHVsZS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ZpZGVyKSB7XG4gICAgICAgIHZhciBuYW1lID0gcHJvdmlkZXJbMF07XG4gICAgICAgIHZhciB0eXBlID0gcHJvdmlkZXJbMV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3ZpZGVyWzJdO1xuXG4gICAgICAgIHByb3ZpZGVyc1tuYW1lXSA9IFtmYWN0b3J5TWFwW3R5cGVdLCBhcnJheVVud3JhcCh0eXBlLCB2YWx1ZSksIHR5cGVdO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKG1vZHVsZS5fX2V4cG9ydHNfXykge1xuICAgICAgICB2YXIgY2xvbmVkTW9kdWxlID0gT2JqZWN0LmtleXMobW9kdWxlKS5yZWR1Y2UoZnVuY3Rpb24obSwga2V5KSB7XG4gICAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgMikgIT09ICdfXycpIHtcbiAgICAgICAgICAgIG1ba2V5XSA9IG1vZHVsZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgICAgICAgdmFyIHByaXZhdGVJbmplY3RvciA9IG5ldyBJbmplY3RvcigobW9kdWxlLl9fbW9kdWxlc19fIHx8IFtdKS5jb25jYXQoW2Nsb25lZE1vZHVsZV0pLCBzZWxmKTtcbiAgICAgICAgdmFyIGdldEZyb21Qcml2YXRlSW5qZWN0b3IgPSBhbm5vdGF0ZShmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICByZXR1cm4gcHJpdmF0ZUluamVjdG9yLmdldChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbW9kdWxlLl9fZXhwb3J0c19fLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcHJvdmlkZXJzW2tleV0gPSBbZ2V0RnJvbVByaXZhdGVJbmplY3Rvciwga2V5LCAncHJpdmF0ZScsIHByaXZhdGVJbmplY3Rvcl07XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmtleXMobW9kdWxlKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBpZiAobW9kdWxlW25hbWVdWzJdID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyc1tuYW1lXSA9IG1vZHVsZVtuYW1lXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdHlwZSA9IG1vZHVsZVtuYW1lXVswXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBtb2R1bGVbbmFtZV1bMV07XG5cbiAgICAgICAgICBwcm92aWRlcnNbbmFtZV0gPSBbZmFjdG9yeU1hcFt0eXBlXSwgYXJyYXlVbndyYXAodHlwZSwgdmFsdWUpLCB0eXBlXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBwdWJsaWMgQVBJXG4gIHRoaXMuZ2V0ID0gZ2V0O1xuICB0aGlzLmludm9rZSA9IGludm9rZTtcbiAgdGhpcy5pbnN0YW50aWF0ZSA9IGluc3RhbnRpYXRlO1xuICB0aGlzLmNyZWF0ZUNoaWxkID0gY3JlYXRlQ2hpbGQ7XG59XG5cbmV4cG9ydCB7IGFubm90YXRlLCBwYXJzZUFubm90YXRpb25zLCBNb2R1bGUsIEluamVjdG9yIH07XG4iLCIvKiEgSGFtbWVyLkpTIC0gdjIuMC43IC0gMjAxNi0wNC0yMlxuICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgSm9yaWsgVGFuZ2VsZGVyO1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgZXhwb3J0TmFtZSwgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxudmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xudmFyIFRFU1RfRUxFTUVOVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG52YXIgVFlQRV9GVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgbm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogc2V0IGEgdGltZW91dCB3aXRoIGEgZ2l2ZW4gc2NvcGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHNldFRpbWVvdXRDb250ZXh0KGZuLCB0aW1lb3V0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoYmluZEZuKGZuLCBjb250ZXh0KSwgdGltZW91dCk7XG59XG5cbi8qKlxuICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcbiAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxuICogdGhpcyBpcyB1c2VkIGJ5IGFsbCB0aGUgbWV0aG9kcyB0aGF0IGFjY2VwdCBhIHNpbmdsZSBhbmQgYXJyYXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xuICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaW52b2tlQXJyYXlBcmcoYXJnLCBmbiwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBpO1xuXG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvYmouZm9yRWFjaCkge1xuICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogd3JhcCBhIG1ldGhvZCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBhbmQgc3RhY2sgdHJhY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXRob2QsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZGVwcmVjYXRpb25NZXNzYWdlID0gJ0RFUFJFQ0FURUQgTUVUSE9EOiAnICsgbmFtZSArICdcXG4nICsgbWVzc2FnZSArICcgQVQgXFxuJztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICAgICAgdmFyIHN0YWNrID0gZSAmJiBlLnN0YWNrID8gZS5zdGFjay5yZXBsYWNlKC9eW15cXChdKz9bXFxuJF0vZ20sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXHMrYXRcXHMrL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG5cbiAgICAgICAgdmFyIGxvZyA9IHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS53YXJuIHx8IHdpbmRvdy5jb25zb2xlLmxvZyk7XG4gICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgIGxvZy5jYWxsKHdpbmRvdy5jb25zb2xlLCBkZXByZWNhdGlvbk1lc3NhZ2UsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICovXG52YXIgYXNzaWduO1xuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59IGVsc2Uge1xuICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXVxuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG52YXIgZXh0ZW5kID0gZGVwcmVjYXRlKGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICghbWVyZ2UgfHwgKG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn0sICdleHRlbmQnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIG1lcmdlID0gZGVwcmVjYXRlKGZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICAgIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbn0sICdtZXJnZScsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGlsZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXG4gICAgICAgIGNoaWxkUDtcblxuICAgIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xuICAgIGNoaWxkUC5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcblxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGFzc2lnbihjaGlsZFAsIHByb3BlcnRpZXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBzaW1wbGUgZnVuY3Rpb24gYmluZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZEZuKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBib29sT3JGbih2YWwsIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PSBUWVBFX0ZVTkNUSU9OKSB7XG4gICAgICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiB1c2UgdGhlIHZhbDIgd2hlbiB2YWwxIGlzIHVuZGVmaW5lZFxuICogQHBhcmFtIHsqfSB2YWwxXG4gKiBAcGFyYW0geyp9IHZhbDJcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBpZlVuZGVmaW5lZCh2YWwxLCB2YWwyKSB7XG4gICAgcmV0dXJuICh2YWwxID09PSB1bmRlZmluZWQpID8gdmFsMiA6IHZhbDE7XG59XG5cbi8qKlxuICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gKiBAbWV0aG9kIGhhc1BhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xufVxuXG4vKipcbiAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXG4gKi9cbmZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xuICAgIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seUZpbGxcbiAqIEBwYXJhbSB7QXJyYXl9IHNyY1xuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmluZEJ5S2V5XVxuICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAqL1xuZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQsIGZpbmRCeUtleSkge1xuICAgIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCkgfHwgKCFmaW5kQnlLZXkgJiYgc3JjW2ldID09PSBmaW5kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59XG5cbi8qKlxuICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbn1cblxuLyoqXG4gKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXG4gKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxuICovXG5mdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XG4gICAgICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChzcmNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIHNvcnRVbmlxdWVBcnJheShhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qKlxuICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcbiAqL1xuZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICAgIHZhciBwcmVmaXgsIHByb3A7XG4gICAgdmFyIGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IFZFTkRPUl9QUkVGSVhFUy5sZW5ndGgpIHtcbiAgICAgICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xuICAgICAgICBwcm9wID0gKHByZWZpeCkgPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcblxuICAgICAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBnZXQgYSB1bmlxdWUgaWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gKi9cbnZhciBfdW5pcXVlSWQgPSAxO1xuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gICAgcmV0dXJuIF91bmlxdWVJZCsrO1xufVxuXG4vKipcbiAqIGdldCB0aGUgd2luZG93IG9iamVjdCBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RG9jdW1lbnRWaWV3fFdpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICAgIHJldHVybiAoZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93KTtcbn1cblxudmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcblxudmFyIFNVUFBPUlRfVE9VQ0ggPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcbnZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luZG93LCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcbnZhciBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG52YXIgSU5QVVRfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG52YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcbnZhciBJTlBVVF9UWVBFX01PVVNFID0gJ21vdXNlJztcbnZhciBJTlBVVF9UWVBFX0tJTkVDVCA9ICdraW5lY3QnO1xuXG52YXIgQ09NUFVURV9JTlRFUlZBTCA9IDI1O1xuXG52YXIgSU5QVVRfU1RBUlQgPSAxO1xudmFyIElOUFVUX01PVkUgPSAyO1xudmFyIElOUFVUX0VORCA9IDQ7XG52YXIgSU5QVVRfQ0FOQ0VMID0gODtcblxudmFyIERJUkVDVElPTl9OT05FID0gMTtcbnZhciBESVJFQ1RJT05fTEVGVCA9IDI7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gNDtcbnZhciBESVJFQ1RJT05fVVAgPSA4O1xudmFyIERJUkVDVElPTl9ET1dOID0gMTY7XG5cbnZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xudmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xudmFyIERJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTDtcblxudmFyIFBST1BTX1hZID0gWyd4JywgJ3knXTtcbnZhciBQUk9QU19DTElFTlRfWFkgPSBbJ2NsaWVudFgnLCAnY2xpZW50WSddO1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSW5wdXQobWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0O1xuXG4gICAgLy8gc21hbGxlciB3cmFwcGVyIGFyb3VuZCB0aGUgaGFuZGxlciwgZm9yIHRoZSBzY29wZSBhbmQgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG1hbmFnZXIsXG4gICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxuICAgIHRoaXMuZG9tSGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuXG59XG5cbklucHV0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHsgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmV2RWwgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRJbnN0YW5jZShtYW5hZ2VyKSB7XG4gICAgdmFyIFR5cGU7XG4gICAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICAgIGlmIChpbnB1dENsYXNzKSB7XG4gICAgICAgIFR5cGUgPSBpbnB1dENsYXNzO1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9QT0lOVEVSX0VWRU5UUykge1xuICAgICAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gICAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgICAgICBUeXBlID0gTW91c2VJbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChUeXBlKShtYW5hZ2VyLCBpbnB1dEhhbmRsZXIpO1xufVxuXG4vKipcbiAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGlucHV0SGFuZGxlcihtYW5hZ2VyLCBldmVudFR5cGUsIGlucHV0KSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBpc0ZpcnN0ID0gKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuICAgIHZhciBpc0ZpbmFsID0gKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuXG4gICAgaW5wdXQuaXNGaXJzdCA9ICEhaXNGaXJzdDtcbiAgICBpbnB1dC5pc0ZpbmFsID0gISFpc0ZpbmFsO1xuXG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgbWFuYWdlci5zZXNzaW9uID0ge307XG4gICAgfVxuXG4gICAgLy8gc291cmNlIGV2ZW50IGlzIHRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBkb21FdmVudHNcbiAgICAvLyBsaWtlICd0b3VjaHN0YXJ0LCBtb3VzZXVwLCBwb2ludGVyZG93bidcbiAgICBpbnB1dC5ldmVudFR5cGUgPSBldmVudFR5cGU7XG5cbiAgICAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcbiAgICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTtcblxuICAgIC8vIGVtaXQgc2VjcmV0IGV2ZW50XG4gICAgbWFuYWdlci5lbWl0KCdoYW1tZXIuaW5wdXQnLCBpbnB1dCk7XG5cbiAgICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XG4gICAgbWFuYWdlci5zZXNzaW9uLnByZXZJbnB1dCA9IGlucHV0O1xufVxuXG4vKipcbiAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICAgIHZhciBzZXNzaW9uID0gbWFuYWdlci5zZXNzaW9uO1xuICAgIHZhciBwb2ludGVycyA9IGlucHV0LnBvaW50ZXJzO1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgIC8vIHN0b3JlIHRoZSBmaXJzdCBpbnB1dCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGFuZCBkaXJlY3Rpb25cbiAgICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0SW5wdXQgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gdG8gY29tcHV0ZSBzY2FsZSBhbmQgcm90YXRpb24gd2UgbmVlZCB0byBzdG9yZSB0aGUgbXVsdGlwbGUgdG91Y2hlc1xuICAgIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RJbnB1dCA9IHNlc3Npb24uZmlyc3RJbnB1dDtcbiAgICB2YXIgZmlyc3RNdWx0aXBsZSA9IHNlc3Npb24uZmlyc3RNdWx0aXBsZTtcbiAgICB2YXIgb2Zmc2V0Q2VudGVyID0gZmlyc3RNdWx0aXBsZSA/IGZpcnN0TXVsdGlwbGUuY2VudGVyIDogZmlyc3RJbnB1dC5jZW50ZXI7XG5cbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgICBpbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcblxuICAgIGlucHV0LmFuZ2xlID0gZ2V0QW5nbGUob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICAgIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuXG4gICAgY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpO1xuICAgIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG5cbiAgICB2YXIgb3ZlcmFsbFZlbG9jaXR5ID0gZ2V0VmVsb2NpdHkoaW5wdXQuZGVsdGFUaW1lLCBpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHkgPSAoYWJzKG92ZXJhbGxWZWxvY2l0eS54KSA+IGFicyhvdmVyYWxsVmVsb2NpdHkueSkpID8gb3ZlcmFsbFZlbG9jaXR5LnggOiBvdmVyYWxsVmVsb2NpdHkueTtcblxuICAgIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gICAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcblxuICAgIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogKChpbnB1dC5wb2ludGVycy5sZW5ndGggPlxuICAgICAgICBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycykgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyk7XG5cbiAgICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpO1xuXG4gICAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcbiAgICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmIChoYXNQYXJlbnQoaW5wdXQuc3JjRXZlbnQudGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldCA9IGlucHV0LnNyY0V2ZW50LnRhcmdldDtcbiAgICB9XG4gICAgaW5wdXQudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG4gICAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgICAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IHByZXZJbnB1dC5kZWx0YVggfHwgMCxcbiAgICAgICAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxuICAgICAgICB9O1xuXG4gICAgICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcbiAgICAgICAgICAgIHk6IGNlbnRlci55XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gICAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG59XG5cbi8qKlxuICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQsXG4gICAgICAgIGRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGxhc3QudGltZVN0YW1wLFxuICAgICAgICB2ZWxvY2l0eSwgdmVsb2NpdHlYLCB2ZWxvY2l0eVksIGRpcmVjdGlvbjtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfQ0FOQ0VMICYmIChkZWx0YVRpbWUgPiBDT01QVVRFX0lOVEVSVkFMIHx8IGxhc3QudmVsb2NpdHkgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgICAgICB2YXIgZGVsdGFZID0gaW5wdXQuZGVsdGFZIC0gbGFzdC5kZWx0YVk7XG5cbiAgICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgdmVsb2NpdHlYID0gdi54O1xuICAgICAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgICAgIHZlbG9jaXR5ID0gKGFicyh2LngpID4gYWJzKHYueSkpID8gdi54IDogdi55O1xuICAgICAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgICAgIHNlc3Npb24ubGFzdEludGVydmFsID0gaW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlIGxhdGVzdCB2ZWxvY2l0eSBpbmZvIGlmIGl0IGRvZXNuJ3Qgb3ZlcnRha2UgYSBtaW5pbXVtIHBlcmlvZFxuICAgICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xuICAgICAgICB2ZWxvY2l0eVkgPSBsYXN0LnZlbG9jaXR5WTtcbiAgICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gICAgaW5wdXQudmVsb2NpdHlZID0gdmVsb2NpdHlZO1xuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbn1cblxuLyoqXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxuICovXG5mdW5jdGlvbiBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCkge1xuICAgIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxuICAgIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICAgIHZhciBwb2ludGVycyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgICBwb2ludGVyc1tpXSA9IHtcbiAgICAgICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgICAgICAgY2xpZW50WTogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVTdGFtcDogbm93KCksXG4gICAgICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICAgICAgY2VudGVyOiBnZXRDZW50ZXIocG9pbnRlcnMpLFxuICAgICAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcbiAgICAgICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRYKSxcbiAgICAgICAgICAgIHk6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHggPSAwLCB5ID0gMCwgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBwb2ludGVyc0xlbmd0aCkge1xuICAgICAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XG4gICAgICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXG4gICAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgICB9O1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgICAgIHk6IHkgLyBkZWx0YVRpbWUgfHwgMFxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICAgIH1cblxuICAgIGlmIChhYnMoeCkgPj0gYWJzKHkpKSB7XG4gICAgICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cbiAgICByZXR1cm4geSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IHAxIHt4LCB5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIHt4LCB5fVxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMVxuICogQHBhcmFtIHtPYmplY3R9IHAyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gKi9cbmZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0sIFBST1BTX0NMSUVOVF9YWSkgLyBnZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbnZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gICAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gICAgbW91c2V1cDogSU5QVVRfRU5EXG59O1xuXG52YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbnZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcblxuLyoqXG4gKiBNb3VzZSBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gTW91c2VJbnB1dCgpIHtcbiAgICB0aGlzLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcblxuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gICAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTtcblxuLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAgIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgMzogSU5QVVRfVFlQRV9QRU4sXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcbn07XG5cbnZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO1xuXG4vLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcbmlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgIXdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICAgIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG59XG5cbi8qKlxuICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcbn1cblxuaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG5cbiAgICAgICAgdmFyIGlzVG91Y2ggPSAocG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCk7XG5cbiAgICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgdmFyIHN0b3JlSW5kZXggPSBpbkFycmF5KHN0b3JlLCBldi5wb2ludGVySWQsICdwb2ludGVySWQnKTtcblxuICAgICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgcmVtb3ZlUG9pbnRlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcbiAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xudmFyIFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBUb3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTaW5nbGVUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuICAgICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgICAgIC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG59XG5cbnZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG4gICAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xuXG4gICAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgICB9XG5cbiAgICB2YXIgaSxcbiAgICAgICAgdGFyZ2V0VG91Y2hlcyxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXSxcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICAgIH0pO1xuXG4gICAgLy8gY29sbGVjdCB0b3VjaGVzXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXNcbiAgICBdO1xufVxuXG4vKipcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG52YXIgREVEVVBfRElTVEFOQ0UgPSAyNTtcblxuZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KCkge1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbih0aGlzLmhhbmRsZXIsIHRoaXMpO1xuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuXG4gICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBudWxsO1xuICAgIHRoaXMubGFzdFRvdWNoZXMgPSBbXTtcbn1cblxuaW5oZXJpdChUb3VjaE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGFuZCB0b3VjaCBldmVudHNcbiAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRNRWhhbmRsZXIobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBpc1RvdWNoID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKSxcbiAgICAgICAgICAgIGlzTW91c2UgPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfTU9VU0UpO1xuXG4gICAgICAgIGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHJlY29yZCB0b3VjaGVzIHRvICBkZS1kdXBlIHN5bnRoZXRpYyBtb3VzZSBldmVudFxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgcmVjb3JkVG91Y2hlcy5jYWxsKHRoaXMsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgaW5wdXREYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG91Y2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gcmVjb3JkVG91Y2hlcyhldmVudFR5cGUsIGV2ZW50RGF0YSkge1xuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICB0aGlzLnByaW1hcnlUb3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcjtcbiAgICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRMYXN0VG91Y2goZXZlbnREYXRhKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXTtcblxuICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLnByaW1hcnlUb3VjaCkge1xuICAgICAgICB2YXIgbGFzdFRvdWNoID0ge3g6IHRvdWNoLmNsaWVudFgsIHk6IHRvdWNoLmNsaWVudFl9O1xuICAgICAgICB0aGlzLmxhc3RUb3VjaGVzLnB1c2gobGFzdFRvdWNoKTtcbiAgICAgICAgdmFyIGx0cyA9IHRoaXMubGFzdFRvdWNoZXM7XG4gICAgICAgIHZhciByZW1vdmVMYXN0VG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpID0gbHRzLmluZGV4T2YobGFzdFRvdWNoKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KHJlbW92ZUxhc3RUb3VjaCwgREVEVVBfVElNRU9VVCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bnRoZXRpY0V2ZW50KGV2ZW50RGF0YSkge1xuICAgIHZhciB4ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFgsIHkgPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gdC54KSwgZHkgPSBNYXRoLmFicyh5IC0gdC55KTtcbiAgICAgICAgaWYgKGR4IDw9IERFRFVQX0RJU1RBTkNFICYmIGR5IDw9IERFRFVQX0RJU1RBTkNFKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xudmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xudmFyIFRPVUNIX0FDVElPTl9NQVAgPSBnZXRUb3VjaEFjdGlvblByb3BzKCk7XG5cbi8qKlxuICogVG91Y2ggQWN0aW9uXG4gKiBzZXRzIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBvciB1c2VzIHRoZSBqcyBhbHRlcm5hdGl2ZVxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5zZXQodmFsdWUpO1xufVxuXG5Ub3VjaEFjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZSBvbiB0aGUgZWxlbWVudCBvciBlbmFibGUgdGhlIHBvbHlmaWxsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgICBpZiAodmFsdWUgPT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbUFJFRklYRURfVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgY29tcHV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChyZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHRzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjtcblxuICAgICAgICAvLyBpZiB0aGUgdG91Y2ggYWN0aW9uIGRpZCBwcmV2ZW50ZWQgb25jZSB0aGlzIHNlc3Npb25cbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCkge1xuICAgICAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICB2YXIgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1ldO1xuICAgICAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9YXTtcblxuICAgICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICAgICAgLy9kbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcblxuICAgICAgICAgICAgdmFyIGlzVGFwUG9pbnRlciA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIHZhciBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgICAgICAgdmFyIGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICAgICAgICBpZiAoaXNUYXBQb2ludGVyICYmIGlzVGFwTW92ZW1lbnQgJiYgaXNUYXBUb3VjaFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTm9uZSB8fFxuICAgICAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XG4gICAgICAgICAgICAoaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cbiAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbihzcmNFdmVudCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAvLyBub25lXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcblxuICAgIC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAgIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAgIC8vIHdlIG5lZWQgbm9uZSAoYXMgb3RoZXJ3aXNlIHdpdGggcGFuLXggcGFuLXkgY29tYmluZWQgbm9uZSBvZiB0aGVzZVxuICAgIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG4gICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgLy8gcGFuLXggT1IgcGFuLXlcbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICAgIH1cblxuICAgIC8vIG1hbmlwdWxhdGlvblxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgICB9XG5cbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG5cbmZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uUHJvcHMoKSB7XG4gICAgaWYgKCFOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRvdWNoTWFwID0ge307XG4gICAgdmFyIGNzc1N1cHBvcnRzID0gd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLnN1cHBvcnRzO1xuICAgIFsnYXV0bycsICdtYW5pcHVsYXRpb24nLCAncGFuLXknLCAncGFuLXgnLCAncGFuLXggcGFuLXknLCAnbm9uZSddLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG5cbiAgICAgICAgLy8gSWYgY3NzLnN1cHBvcnRzIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IHRoZXJlIGlzIG5hdGl2ZSB0b3VjaC1hY3Rpb24gYXNzdW1lIGl0IHN1cHBvcnRzXG4gICAgICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICAgICAgdG91Y2hNYXBbdmFsXSA9IGNzc1N1cHBvcnRzID8gd2luZG93LkNTUy5zdXBwb3J0cygndG91Y2gtYWN0aW9uJywgdmFsKSA6IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdWNoTWFwO1xufVxuXG4vKipcbiAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcbiAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cbiAqIFRoZSBkZWZpbml0aW9uIG9mIGEgaW5wdXQgc2Vzc2lvbiBpcyBmcm9tIHRoZSBmaXJzdCBpbnB1dCB1bnRpbCB0aGUgbGFzdCBpbnB1dCwgd2l0aCBhbGwgaXQncyBtb3ZlbWVudCBpbiBpdC4gKlxuICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXG4gKlxuICogT24gZWFjaCByZWNvZ25pemluZyBjeWNsZSAoc2VlIE1hbmFnZXIucmVjb2duaXplKSB0aGUgLnJlY29nbml6ZSgpIG1ldGhvZCBpcyBleGVjdXRlZFxuICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cbiAqXG4gKiBJZiB0aGUgcmVjb2duaXplciBoYXMgdGhlIHN0YXRlIEZBSUxFRCwgQ0FOQ0VMTEVEIG9yIFJFQ09HTklaRUQgKGVxdWFscyBFTkRFRCksIGl0IGlzIHJlc2V0IHRvXG4gKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxuICpcbiAqICAgICAgICAgICAgICAgUG9zc2libGVcbiAqICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxuICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxuICogICBGYWlsZWQgICAgICBDYW5jZWxsZWQgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICBSZWNvZ25pemVkICAgICAgIEJlZ2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXG4gKi9cbnZhciBTVEFURV9QT1NTSUJMRSA9IDE7XG52YXIgU1RBVEVfQkVHQU4gPSAyO1xudmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xudmFyIFNUQVRFX0VOREVEID0gODtcbnZhciBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XG52YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG52YXIgU1RBVEVfRkFJTEVEID0gMzI7XG5cbi8qKlxuICogUmVjb2duaXplclxuICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuXG4gICAgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBpZlVuZGVmaW5lZCh0aGlzLm9wdGlvbnMuZW5hYmxlLCB0cnVlKTtcblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcblxuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xufVxuXG5SZWNvZ25pemVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgZGVmYXVsdHM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGFsc28gdXBkYXRlIHRoZSB0b3VjaEFjdGlvbiwgaW4gY2FzZSBzb21ldGhpbmcgY2hhbmdlZCBhYm91dCB0aGUgZGlyZWN0aW9ucy9lbmFibGVkIHN0YXRlXG4gICAgICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgcmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcbiAgICAgICAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgcmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGlmIChpbkFycmF5KHJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpID09PSAtMSkge1xuICAgICAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkodGhpcy5yZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1JlcXVpcmVGYWlsdXJlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xuICAgICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYubWFuYWdlci5lbWl0KGV2ZW50LCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcbiAgICAgICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50KTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xuXG4gICAgICAgIGlmIChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpIHsgLy8gYWRkaXRpb25hbCBldmVudChwYW5sZWZ0LCBwYW5yaWdodCwgcGluY2hpbiwgcGluY2hvdXQuLi4pXG4gICAgICAgICAgICBlbWl0KGlucHV0LmFkZGl0aW9uYWxFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuICAgICAgICBpZiAoc3RhdGUgPj0gU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXG4gICAgICogaWYgdHJ1ZSwgaXQgZW1pdHMgYSBnZXN0dXJlIGV2ZW50LFxuICAgICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICB0cnlFbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FuIHdlIGVtaXQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuRW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAgICAgLy8gc28gd2UgY2FuIGNoYW5nZSB0aGUgaW5wdXREYXRhIHdpdGhvdXQgbWVzc2luZyB1cCB0aGUgb3RoZXIgcmVjb2duaXplcnNcbiAgICAgICAgdmFyIGlucHV0RGF0YUNsb25lID0gYXNzaWduKHt9LCBpbnB1dERhdGEpO1xuXG4gICAgICAgIC8vIGlzIGlzIGVuYWJsZWQgYW5kIGFsbG93IHJlY29nbml6aW5nP1xuICAgICAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnByb2Nlc3MoaW5wdXREYXRhQ2xvbmUpO1xuXG4gICAgICAgIC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxuICAgICAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXG4gICAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICogQHJldHVybnMge0NvbnN0fSBTVEFURVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0RGF0YSkgeyB9LCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHsgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXG4gICAgICogbGlrZSB3aGVuIGFub3RoZXIgaXMgYmVpbmcgcmVjb2duaXplZCBvciBpdCBpcyBkaXNhYmxlZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkgeyB9XG59O1xuXG4vKipcbiAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxuICogQHBhcmFtIHtDb25zdH0gc3RhdGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gKi9cbmZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgICAgIHJldHVybiAnY2FuY2VsJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9DSEFOR0VEKSB7XG4gICAgICAgIHJldHVybiAnbW92ZSc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgICAgIHJldHVybiAnc3RhcnQnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXG4gKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgICAgIHJldHVybiAnZG93bic7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQKSB7XG4gICAgICAgIHJldHVybiAndXAnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9MRUZUKSB7XG4gICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxuICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxuICovXG5mdW5jdGlvbiBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgcmVjb2duaXplcikge1xuICAgIHZhciBtYW5hZ2VyID0gcmVjb2duaXplci5tYW5hZ2VyO1xuICAgIGlmIChtYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xufVxuXG4vKipcbiAqIFRoaXMgcmVjb2duaXplciBpcyBqdXN0IHVzZWQgYXMgYSBiYXNlIGZvciB0aGUgc2ltcGxlIGF0dHJpYnV0ZSByZWNvZ25pemVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBBdHRyUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoQXR0clJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY2hlY2sgaWYgaXQgdGhlIHJlY29nbml6ZXIgcmVjZWl2ZXMgdmFsaWQgaW5wdXQsIGxpa2UgaW5wdXQuZGlzdGFuY2UgPiAxMC5cbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmVjb2duaXplZFxuICAgICAqL1xuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Kn0gU3RhdGVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gaW5wdXQuZXZlbnRUeXBlO1xuXG4gICAgICAgIHZhciBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgICAgICB2YXIgaXNWYWxpZCA9IHRoaXMuYXR0clRlc3QoaW5wdXQpO1xuXG4gICAgICAgIC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcbiAgICAgICAgaWYgKGlzUmVjb2duaXplZCAmJiAoZXZlbnRUeXBlICYgSU5QVVRfQ0FOQ0VMIHx8ICFpc1ZhbGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVjb2duaXplZCB8fCBpc1ZhbGlkKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGFuXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQYW5SZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnBYID0gbnVsbDtcbiAgICB0aGlzLnBZID0gbnVsbDtcbn1cblxuaW5oZXJpdChQYW5SZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGFuUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGFuJyxcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0FMTFxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgIH0sXG5cbiAgICBkaXJlY3Rpb25UZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIGhhc01vdmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gaW5wdXQuZGlzdGFuY2U7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgICAgIHZhciB4ID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICB2YXIgeSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICAvLyBsb2NrIHRvIGF4aXM/XG4gICAgICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeCA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh4IDwgMCkgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHggIT0gdGhpcy5wWDtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh5ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geSAhPSB0aGlzLnBZO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAoISh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pICYmIHRoaXMuZGlyZWN0aW9uVGVzdChpbnB1dCkpKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcblxuICAgICAgICB0aGlzLnBYID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQaW5jaFxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChQaW5jaFJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BpbmNoJyxcbiAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICBwb2ludGVyczogMlxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LnNjYWxlICE9PSAxKSB7XG4gICAgICAgICAgICB2YXIgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XG4gICAgICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFByZXNzXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbn1cblxuaW5oZXJpdChQcmVzc1JlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFByZXNzUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGltZTogMjUxLCAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgICB0aHJlc2hvbGQ6IDkgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9BVVRPXTtcbiAgICB9LFxuXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCAoaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXQgJiYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSb3RhdGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVyIGFyZSBtb3ZpbmcgaW4gYSBjaXJjdWxhciBtb3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFJvdGF0ZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncm90YXRlJyxcbiAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICBwb2ludGVyczogMlxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFN3aXBlXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTd2lwZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBTd2lwZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgdmVsb2NpdHk6IDAuMyxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgdmVsb2NpdHk7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIGRpcmVjdGlvbiAmIGlucHV0Lm9mZnNldERpcmVjdGlvbiAmJlxuICAgICAgICAgICAgaW5wdXQuZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkICYmXG4gICAgICAgICAgICBpbnB1dC5tYXhQb2ludGVycyA9PSB0aGlzLm9wdGlvbnMucG9pbnRlcnMgJiZcbiAgICAgICAgICAgIGFicyh2ZWxvY2l0eSkgPiB0aGlzLm9wdGlvbnMudmVsb2NpdHkgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0Lm9mZnNldERpcmVjdGlvbik7XG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbiwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQSB0YXAgaXMgZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxuICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gKiBhIHNpbmdsZSB0YXAuXG4gKlxuICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG4gICAgdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgIHRoaXMucENlbnRlciA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbn1cblxuaW5oZXJpdChUYXBSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3RhcCcsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0YXBzOiAxLFxuICAgICAgICBpbnRlcnZhbDogMzAwLCAvLyBtYXggdGltZSBiZXR3ZWVuIHRoZSBtdWx0aS10YXAgdGFwc1xuICAgICAgICB0aW1lOiAyNTAsIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICAgIHRocmVzaG9sZDogOSwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgICAgcG9zVGhyZXNob2xkOiAxMCAvLyBhIG11bHRpLXRhcCBjYW4gYmUgYSBiaXQgb2ZmIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgICB9LFxuXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICBpZiAoKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSAmJiAodGhpcy5jb3VudCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gKGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsKSA6IHRydWU7XG4gICAgICAgICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XG5cbiAgICAgICAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRNdWx0aVRhcCB8fCAhdmFsaWRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcbiAgICAgICAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG4gICAgICAgICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xuICAgICAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEhhbW1lcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5yZWNvZ25pemVycyA9IGlmVW5kZWZpbmVkKG9wdGlvbnMucmVjb2duaXplcnMsIEhhbW1lci5kZWZhdWx0cy5wcmVzZXQpO1xuICAgIHJldHVybiBuZXcgTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuSGFtbWVyLlZFUlNJT04gPSAnMi4wLjcnO1xuXG4vKipcbiAqIGRlZmF1bHQgc2V0dGluZ3NcbiAqIEBuYW1lc3BhY2VcbiAqL1xuSGFtbWVyLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXG4gICAgICogQnV0IHRoaXMgaXMgc2xvd2VyIGFuZCB1bnVzZWQgYnkgc2ltcGxlIGltcGxlbWVudGF0aW9ucywgc28gZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGRvbUV2ZW50czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cbiAgICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IGNvbXB1dGVcbiAgICAgKi9cbiAgICB0b3VjaEFjdGlvbjogVE9VQ0hfQUNUSU9OX0NPTVBVVEUsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgZW5hYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRVhQRVJJTUVOVEFMIEZFQVRVUkUgLS0gY2FuIGJlIHJlbW92ZWQvY2hhbmdlZFxuICAgICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuICAgICAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXG4gICAgICogQHR5cGUge051bGx8RXZlbnRUYXJnZXR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0VGFyZ2V0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogZm9yY2UgYW4gaW5wdXQgY2xhc3NcbiAgICAgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRDbGFzczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgcmVjb2duaXplciBzZXR1cCB3aGVuIGNhbGxpbmcgYEhhbW1lcigpYFxuICAgICAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHByZXNldDogW1xuICAgICAgICAvLyBSZWNvZ25pemVyQ2xhc3MsIG9wdGlvbnMsIFtyZWNvZ25pemVXaXRoLCAuLi5dLCBbcmVxdWlyZUZhaWx1cmUsIC4uLl1cbiAgICAgICAgW1JvdGF0ZVJlY29nbml6ZXIsIHtlbmFibGU6IGZhbHNlfV0sXG4gICAgICAgIFtQaW5jaFJlY29nbml6ZXIsIHtlbmFibGU6IGZhbHNlfSwgWydyb3RhdGUnXV0sXG4gICAgICAgIFtTd2lwZVJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfV0sXG4gICAgICAgIFtQYW5SZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH0sIFsnc3dpcGUnXV0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXIsIHtldmVudDogJ2RvdWJsZXRhcCcsIHRhcHM6IDJ9LCBbJ3RhcCddXSxcbiAgICAgICAgW1ByZXNzUmVjb2duaXplcl1cbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cbiAgICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqL1xuICAgIGNzc1Byb3BzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlIHRoZSBXaW5kb3dzIFBob25lIGdyaXBwZXJzIHdoZW4gcHJlc3NpbmcgYW4gZWxlbWVudC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaFNlbGVjdDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxuICAgICAgICAgKiBPbiBpT1MsIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0IHN1Y2ggYXMgYSBsaW5rLCBTYWZhcmkgZGlzcGxheXNcbiAgICAgICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29udGVudFpvb21pbmc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJEcmFnOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgICAqL1xuICAgICAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gICAgfVxufTtcblxudmFyIFNUT1AgPSAxO1xudmFyIEZPUkNFRF9TVE9QID0gMjtcblxuLyoqXG4gKiBNYW5hZ2VyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBIYW1tZXIuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuICAgIHRoaXMub2xkQ3NzUHJvcHMgPSB7fTtcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XG4gICAgdGhpcy50b3VjaEFjdGlvbiA9IG5ldyBUb3VjaEFjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuXG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG5cbiAgICBlYWNoKHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyAoaXRlbVswXSkoaXRlbVsxXSkpO1xuICAgICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcbiAgICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xufVxuXG5NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcbiAgICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJ1biB0aGUgdG91Y2gtYWN0aW9uIHBvbHlmaWxsXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXI7XG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG5cbiAgICAgICAgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuICAgICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjtcblxuICAgICAgICAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxuICAgICAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IChjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSkge1xuICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgcmVjb2duaXplcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XG5cbiAgICAgICAgICAgIC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgICAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxuICAgICAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAgICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxuICAgICAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkICE9PSBGT1JDRURfU1RPUCAmJiAoIC8vIDFcbiAgICAgICAgICAgICAgICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkgeyAvLyAzXG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemUoaW5wdXREYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG4gICAgICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgJiYgcmVjb2duaXplci5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCkpIHtcbiAgICAgICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgYSByZWNvZ25pemVyIGJ5IGl0cyBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxuICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ2FkZCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcbiAgICAgICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcblxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ3JlbW92ZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcblxuICAgICAgICAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkocmVjb2duaXplcnMsIHJlY29nbml6ZXIpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbmQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXVxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gdHJpZ2dlciBkb20gZXZlbnRzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XG4gICAgICAgIGlmICghaGFuZGxlcnMgfHwgIWhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS50eXBlID0gZXZlbnQ7XG4gICAgICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtCb29sZWFufSBhZGRcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHByb3A7XG4gICAgZWFjaChtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHByb3AgPSBwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKTtcbiAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSB8fCAnJztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYWRkKSB7XG4gICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHMgPSB7fTtcbiAgICB9XG59XG5cbi8qKlxuICogdHJpZ2dlciBkb20gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICAgIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcbiAgICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG59XG5cbmFzc2lnbihIYW1tZXIsIHtcbiAgICBJTlBVVF9TVEFSVDogSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcbiAgICBJTlBVVF9FTkQ6IElOUFVUX0VORCxcbiAgICBJTlBVVF9DQU5DRUw6IElOUFVUX0NBTkNFTCxcblxuICAgIFNUQVRFX1BPU1NJQkxFOiBTVEFURV9QT1NTSUJMRSxcbiAgICBTVEFURV9CRUdBTjogU1RBVEVfQkVHQU4sXG4gICAgU1RBVEVfQ0hBTkdFRDogU1RBVEVfQ0hBTkdFRCxcbiAgICBTVEFURV9FTkRFRDogU1RBVEVfRU5ERUQsXG4gICAgU1RBVEVfUkVDT0dOSVpFRDogU1RBVEVfUkVDT0dOSVpFRCxcbiAgICBTVEFURV9DQU5DRUxMRUQ6IFNUQVRFX0NBTkNFTExFRCxcbiAgICBTVEFURV9GQUlMRUQ6IFNUQVRFX0ZBSUxFRCxcblxuICAgIERJUkVDVElPTl9OT05FOiBESVJFQ1RJT05fTk9ORSxcbiAgICBESVJFQ1RJT05fTEVGVDogRElSRUNUSU9OX0xFRlQsXG4gICAgRElSRUNUSU9OX1JJR0hUOiBESVJFQ1RJT05fUklHSFQsXG4gICAgRElSRUNUSU9OX1VQOiBESVJFQ1RJT05fVVAsXG4gICAgRElSRUNUSU9OX0RPV046IERJUkVDVElPTl9ET1dOLFxuICAgIERJUkVDVElPTl9IT1JJWk9OVEFMOiBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgICBESVJFQ1RJT05fVkVSVElDQUw6IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICBESVJFQ1RJT05fQUxMOiBESVJFQ1RJT05fQUxMLFxuXG4gICAgTWFuYWdlcjogTWFuYWdlcixcbiAgICBJbnB1dDogSW5wdXQsXG4gICAgVG91Y2hBY3Rpb246IFRvdWNoQWN0aW9uLFxuXG4gICAgVG91Y2hJbnB1dDogVG91Y2hJbnB1dCxcbiAgICBNb3VzZUlucHV0OiBNb3VzZUlucHV0LFxuICAgIFBvaW50ZXJFdmVudElucHV0OiBQb2ludGVyRXZlbnRJbnB1dCxcbiAgICBUb3VjaE1vdXNlSW5wdXQ6IFRvdWNoTW91c2VJbnB1dCxcbiAgICBTaW5nbGVUb3VjaElucHV0OiBTaW5nbGVUb3VjaElucHV0LFxuXG4gICAgUmVjb2duaXplcjogUmVjb2duaXplcixcbiAgICBBdHRyUmVjb2duaXplcjogQXR0clJlY29nbml6ZXIsXG4gICAgVGFwOiBUYXBSZWNvZ25pemVyLFxuICAgIFBhbjogUGFuUmVjb2duaXplcixcbiAgICBTd2lwZTogU3dpcGVSZWNvZ25pemVyLFxuICAgIFBpbmNoOiBQaW5jaFJlY29nbml6ZXIsXG4gICAgUm90YXRlOiBSb3RhdGVSZWNvZ25pemVyLFxuICAgIFByZXNzOiBQcmVzc1JlY29nbml6ZXIsXG5cbiAgICBvbjogYWRkRXZlbnRMaXN0ZW5lcnMsXG4gICAgb2ZmOiByZW1vdmVFdmVudExpc3RlbmVycyxcbiAgICBlYWNoOiBlYWNoLFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBpbmhlcml0OiBpbmhlcml0LFxuICAgIGJpbmRGbjogYmluZEZuLFxuICAgIHByZWZpeGVkOiBwcmVmaXhlZFxufSk7XG5cbi8vIHRoaXMgcHJldmVudHMgZXJyb3JzIHdoZW4gSGFtbWVyIGlzIGxvYWRlZCBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EXG4vLyAgc3R5bGUgbG9hZGVyIGJ1dCBieSBzY3JpcHQgdGFnLCBub3QgYnkgdGhlIGxvYWRlci5cbnZhciBmcmVlR2xvYmFsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fSkpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbmZyZWVHbG9iYWwuSGFtbWVyID0gSGFtbWVyO1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGFtbWVyO1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XG59IGVsc2Uge1xuICAgIHdpbmRvd1tleHBvcnROYW1lXSA9IEhhbW1lcjtcbn1cblxufSkod2luZG93LCBkb2N1bWVudCwgJ0hhbW1lcicpO1xuIiwiZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBoYXRfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbnZhciBoYXQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRzLCBiYXNlKSB7XG4gICAgaWYgKCFiYXNlKSBiYXNlID0gMTY7XG4gICAgaWYgKGJpdHMgPT09IHVuZGVmaW5lZCkgYml0cyA9IDEyODtcbiAgICBpZiAoYml0cyA8PSAwKSByZXR1cm4gJzAnO1xuICAgIFxuICAgIHZhciBkaWdpdHMgPSBNYXRoLmxvZyhNYXRoLnBvdygyLCBiaXRzKSkgLyBNYXRoLmxvZyhiYXNlKTtcbiAgICBmb3IgKHZhciBpID0gMjsgZGlnaXRzID09PSBJbmZpbml0eTsgaSAqPSAyKSB7XG4gICAgICAgIGRpZ2l0cyA9IE1hdGgubG9nKE1hdGgucG93KDIsIGJpdHMgLyBpKSkgLyBNYXRoLmxvZyhiYXNlKSAqIGk7XG4gICAgfVxuICAgIFxuICAgIHZhciByZW0gPSBkaWdpdHMgLSBNYXRoLmZsb29yKGRpZ2l0cyk7XG4gICAgXG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5mbG9vcihkaWdpdHMpOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBiYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgcmVzID0geCArIHJlcztcbiAgICB9XG4gICAgXG4gICAgaWYgKHJlbSkge1xuICAgICAgICB2YXIgYiA9IE1hdGgucG93KGJhc2UsIHJlbSk7XG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYikudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIHJlcyA9IHggKyByZXM7XG4gICAgfVxuICAgIFxuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChyZXMsIGJhc2UpO1xuICAgIGlmIChwYXJzZWQgIT09IEluZmluaXR5ICYmIHBhcnNlZCA+PSBNYXRoLnBvdygyLCBiaXRzKSkge1xuICAgICAgICByZXR1cm4gaGF0KGJpdHMsIGJhc2UpXG4gICAgfVxuICAgIGVsc2UgcmV0dXJuIHJlcztcbn07XG5cbmhhdC5yYWNrID0gZnVuY3Rpb24gKGJpdHMsIGJhc2UsIGV4cGFuZEJ5KSB7XG4gICAgdmFyIGZuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGl0ZXJzID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGl0ZXJzICsrID4gMTApIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kQnkpIGJpdHMgKz0gZXhwYW5kQnk7XG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBtYW55IElEIGNvbGxpc2lvbnMsIHVzZSBtb3JlIGJpdHMnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgaWQgPSBoYXQoYml0cywgYmFzZSk7XG4gICAgICAgIH0gd2hpbGUgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhhdHMsIGlkKSk7XG4gICAgICAgIFxuICAgICAgICBoYXRzW2lkXSA9IGRhdGE7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIHZhciBoYXRzID0gZm4uaGF0cyA9IHt9O1xuICAgIFxuICAgIGZuLmdldCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gZm4uaGF0c1tpZF07XG4gICAgfTtcbiAgICBcbiAgICBmbi5zZXQgPSBmdW5jdGlvbiAoaWQsIHZhbHVlKSB7XG4gICAgICAgIGZuLmhhdHNbaWRdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIFxuICAgIGZuLmJpdHMgPSBiaXRzIHx8IDEyODtcbiAgICBmbi5iYXNlID0gYmFzZSB8fCAxNjtcbiAgICByZXR1cm4gZm47XG59O1xufSk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGlkIGdlbmVyYXRvciAvIGNhY2hlIGluc3RhbmNlLlxuICpcbiAqIFlvdSBtYXkgb3B0aW9uYWxseSBwcm92aWRlIGEgc2VlZCB0aGF0IGlzIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiBAcGFyYW0ge1NlZWR9IHNlZWRcbiAqL1xuXG5mdW5jdGlvbiBJZHMoc2VlZCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSWRzKSkge1xuICAgIHJldHVybiBuZXcgSWRzKHNlZWQpO1xuICB9XG5cbiAgc2VlZCA9IHNlZWQgfHwgWzEyOCwgMzYsIDFdO1xuICB0aGlzLl9zZWVkID0gc2VlZC5sZW5ndGggPyBoYXRfMS5yYWNrKHNlZWRbMF0sIHNlZWRbMV0sIHNlZWRbMl0pIDogc2VlZDtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBuZXh0IGlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZWxlbWVudF0gZWxlbWVudCB0byBiaW5kIHRoZSBpZCB0b1xuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gaWRcbiAqL1xuXG5JZHMucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gdGhpcy5fc2VlZChlbGVtZW50IHx8IHRydWUpO1xufTtcbi8qKlxuICogR2VuZXJhdGUgYSBuZXh0IGlkIHdpdGggYSBnaXZlbiBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtlbGVtZW50XSBlbGVtZW50IHRvIGJpbmQgdGhlIGlkIHRvXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBpZFxuICovXG5cblxuSWRzLnByb3RvdHlwZS5uZXh0UHJlZml4ZWQgPSBmdW5jdGlvbiAocHJlZml4LCBlbGVtZW50KSB7XG4gIHZhciBpZDtcblxuICBkbyB7XG4gICAgaWQgPSBwcmVmaXggKyB0aGlzLm5leHQodHJ1ZSk7XG4gIH0gd2hpbGUgKHRoaXMuYXNzaWduZWQoaWQpKTsgLy8gY2xhaW0ge3ByZWZpeH17cmFuZG9tfVxuXG5cbiAgdGhpcy5jbGFpbShpZCwgZWxlbWVudCk7IC8vIHJldHVyblxuXG4gIHJldHVybiBpZDtcbn07XG4vKipcbiAqIE1hbnVhbGx5IGNsYWltIGFuIGV4aXN0aW5nIGlkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtTdHJpbmd9IFtlbGVtZW50XSBlbGVtZW50IHRoZSBpZCBpcyBjbGFpbWVkIGJ5XG4gKi9cblxuXG5JZHMucHJvdG90eXBlLmNsYWltID0gZnVuY3Rpb24gKGlkLCBlbGVtZW50KSB7XG4gIHRoaXMuX3NlZWQuc2V0KGlkLCBlbGVtZW50IHx8IHRydWUpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBpZCBoYXMgYWxyZWFkeSBiZWVuIGFzc2lnbmVkLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gaWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuXG5JZHMucHJvdG90eXBlLmFzc2lnbmVkID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiB0aGlzLl9zZWVkLmdldChpZCkgfHwgZmFsc2U7XG59O1xuLyoqXG4gKiBVbmNsYWltIGFuIGlkLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gaWQgdGhlIGlkIHRvIHVuY2xhaW1cbiAqL1xuXG5cbklkcy5wcm90b3R5cGUudW5jbGFpbSA9IGZ1bmN0aW9uIChpZCkge1xuICBkZWxldGUgdGhpcy5fc2VlZC5oYXRzW2lkXTtcbn07XG4vKipcbiAqIENsZWFyIGFsbCBjbGFpbWVkIGlkcy5cbiAqL1xuXG5cbklkcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoYXRzID0gdGhpcy5fc2VlZC5oYXRzLFxuICAgICAgaWQ7XG5cbiAgZm9yIChpZCBpbiBoYXRzKSB7XG4gICAgdGhpcy51bmNsYWltKGlkKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgSWRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBGbGF0dGVuIGFycmF5LCBvbmUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PD8+fSBhcnJcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTw/Pn1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycik7XG59XG5cbnZhciBuYXRpdmVUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbmF0aXZlSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNOaWwob2JqKSB7XG4gIHJldHVybiBvYmogPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gIHJldHVybiBuYXRpdmVUb1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5mdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICB2YXIgdGFnID0gbmF0aXZlVG9TdHJpbmcuY2FsbChvYmopO1xuICByZXR1cm4gdGFnID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8IHRhZyA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nIHx8IHRhZyA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyB8fCB0YWcgPT09ICdbb2JqZWN0IEFzeW5jR2VuZXJhdG9yRnVuY3Rpb25dJyB8fCB0YWcgPT09ICdbb2JqZWN0IFByb3h5XSc7XG59XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG4vKipcbiAqIEVuc3VyZSBjb2xsZWN0aW9uIGlzIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5mdW5jdGlvbiBlbnN1cmVBcnJheShvYmopIHtcbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignbXVzdCBzdXBwbHkgYXJyYXknKTtcbn1cbi8qKlxuICogUmV0dXJuIHRydWUsIGlmIHRhcmdldCBvd25zIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xuICByZXR1cm4gbmF0aXZlSGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSk7XG59XG5cbi8qKlxuICogRmluZCBlbGVtZW50IGluIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtICB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbnxPYmplY3R9IG1hdGNoZXJcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZmluZChjb2xsZWN0aW9uLCBtYXRjaGVyKSB7XG4gIG1hdGNoZXIgPSB0b01hdGNoZXIobWF0Y2hlcik7XG4gIHZhciBtYXRjaDtcbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICBpZiAobWF0Y2hlcih2YWwsIGtleSkpIHtcbiAgICAgIG1hdGNoID0gdmFsO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYXRjaDtcbn1cbi8qKlxuICogRmluZCBlbGVtZW50IGluZGV4IGluIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtICB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gbWF0Y2hlclxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kSW5kZXgoY29sbGVjdGlvbiwgbWF0Y2hlcikge1xuICBtYXRjaGVyID0gdG9NYXRjaGVyKG1hdGNoZXIpO1xuICB2YXIgaWR4ID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IC0xIDogdW5kZWZpbmVkO1xuICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgIGlmIChtYXRjaGVyKHZhbCwga2V5KSkge1xuICAgICAgaWR4ID0ga2V5O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpZHg7XG59XG4vKipcbiAqIEZpbmQgZWxlbWVudCBpbiBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gY29sbGVjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IG1hdGNoZXJcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIG1hdGNoZXIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgIGlmIChtYXRjaGVyKHZhbCwga2V5KSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgY29sbGVjdGlvbjsgcmV0dXJuaW5nIHNvbWV0aGluZ1xuICogKG5vbi11bmRlZmluZWQpIHdpbGwgc3RvcCBpdGVyYXRpb24uXG4gKlxuICogQHBhcmFtICB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJldHVybiByZXN1bHQgdGhhdCBzdG9wcGVkIHRoZSBpdGVyYXRpb25cbiAqL1xuXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdG9yKSB7XG4gIHZhciB2YWwsIHJlc3VsdDtcblxuICBpZiAoaXNVbmRlZmluZWQoY29sbGVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29udmVydEtleSA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyB0b051bSA6IGlkZW50aXR5O1xuXG4gIGZvciAodmFyIGtleSBpbiBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKGhhcyhjb2xsZWN0aW9uLCBrZXkpKSB7XG4gICAgICB2YWwgPSBjb2xsZWN0aW9uW2tleV07XG4gICAgICByZXN1bHQgPSBpdGVyYXRvcih2YWwsIGNvbnZlcnRLZXkoa2V5KSk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFJldHVybiBjb2xsZWN0aW9uIHdpdGhvdXQgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gbWF0Y2hlclxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHdpdGhvdXQoYXJyLCBtYXRjaGVyKSB7XG4gIGlmIChpc1VuZGVmaW5lZChhcnIpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZW5zdXJlQXJyYXkoYXJyKTtcbiAgbWF0Y2hlciA9IHRvTWF0Y2hlcihtYXRjaGVyKTtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICByZXR1cm4gIW1hdGNoZXIoZWwsIGlkeCk7XG4gIH0pO1xufVxuLyoqXG4gKiBSZWR1Y2UgY29sbGVjdGlvbiwgcmV0dXJuaW5nIGEgc2luZ2xlIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtICB7QW55fSByZXN1bHRcbiAqXG4gKiBAcmV0dXJuIHtBbnl9IHJlc3VsdCByZXR1cm5lZCBmcm9tIGxhc3QgaXRlcmF0b3JcbiAqL1xuXG5mdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0b3IsIHJlc3VsdCkge1xuICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgcmVzdWx0ID0gaXRlcmF0b3IocmVzdWx0LCB2YWx1ZSwgaWR4KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cbiAqIG1hdGNoZXMgdGhlIGNyaXRlcmlhLlxuICpcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gY29sbGVjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IG1hdGNoZXJcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIG1hdGNoZXIpIHtcbiAgcmV0dXJuICEhcmVkdWNlKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChtYXRjaGVzLCB2YWwsIGtleSkge1xuICAgIHJldHVybiBtYXRjaGVzICYmIG1hdGNoZXIodmFsLCBrZXkpO1xuICB9LCB0cnVlKTtcbn1cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgc29tZSBlbGVtZW50cyBpbiB0aGUgY29sbGVjdGlvblxuICogbWF0Y2ggdGhlIGNyaXRlcmlhLlxuICpcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gY29sbGVjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IG1hdGNoZXJcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgbWF0Y2hlcikge1xuICByZXR1cm4gISFmaW5kKGNvbGxlY3Rpb24sIG1hdGNoZXIpO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBjb2xsZWN0aW9uIGludG8gYW5vdGhlciBjb2xsZWN0aW9uXG4gKiBieSBwaXBpbmcgZWFjaCBtZW1iZXIgdGhyb3VnaCB0aGUgZ2l2ZW4gZm4uXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSAgIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICpcbiAqIEByZXR1cm4ge0FycmF5fSB0cmFuc2Zvcm1lZCBjb2xsZWN0aW9uXG4gKi9cblxuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGZuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICByZXN1bHQucHVzaChmbih2YWwsIGtleSkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogR2V0IHRoZSBjb2xsZWN0aW9ucyBrZXlzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gY29sbGVjdGlvblxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGtleXMoY29sbGVjdGlvbikge1xuICByZXR1cm4gY29sbGVjdGlvbiAmJiBPYmplY3Qua2V5cyhjb2xsZWN0aW9uKSB8fCBbXTtcbn1cbi8qKlxuICogU2hvcnRoYW5kIGZvciBga2V5cyhvKS5sZW5ndGhgLlxuICpcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gY29sbGVjdGlvblxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIGtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xufVxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlcyBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiB2YWx1ZXMoY29sbGVjdGlvbikge1xuICByZXR1cm4gbWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9KTtcbn1cbi8qKlxuICogR3JvdXAgY29sbGVjdGlvbiBtZW1iZXJzIGJ5IGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBleHRyYWN0b3JcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IG1hcCB3aXRoIHsgYXR0clZhbHVlID0+IFsgYSwgYiwgYyBdIH1cbiAqL1xuXG5mdW5jdGlvbiBncm91cEJ5KGNvbGxlY3Rpb24sIGV4dHJhY3Rvcikge1xuICB2YXIgZ3JvdXBlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGV4dHJhY3RvciA9IHRvRXh0cmFjdG9yKGV4dHJhY3Rvcik7XG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhciBkaXNjcmltaW5hdG9yID0gZXh0cmFjdG9yKHZhbCkgfHwgJ18nO1xuICAgIHZhciBncm91cCA9IGdyb3VwZWRbZGlzY3JpbWluYXRvcl07XG5cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICBncm91cCA9IGdyb3VwZWRbZGlzY3JpbWluYXRvcl0gPSBbXTtcbiAgICB9XG5cbiAgICBncm91cC5wdXNoKHZhbCk7XG4gIH0pO1xuICByZXR1cm4gZ3JvdXBlZDtcbn1cbmZ1bmN0aW9uIHVuaXF1ZUJ5KGV4dHJhY3Rvcikge1xuICBleHRyYWN0b3IgPSB0b0V4dHJhY3RvcihleHRyYWN0b3IpO1xuICB2YXIgZ3JvdXBlZCA9IHt9O1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjb2xsZWN0aW9ucyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgY29sbGVjdGlvbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgZm9yRWFjaChjb2xsZWN0aW9ucywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gZ3JvdXBCeShjLCBleHRyYWN0b3IsIGdyb3VwZWQpO1xuICB9KTtcbiAgdmFyIHJlc3VsdCA9IG1hcChncm91cGVkLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICByZXR1cm4gdmFsWzBdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciB1bmlvbkJ5ID0gdW5pcXVlQnk7XG4vKipcbiAqIFNvcnQgY29sbGVjdGlvbiBieSBjcml0ZXJpYS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge1N0cmluZ3xGdW5jdGlvbn0gZXh0cmFjdG9yXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gc29ydEJ5KGNvbGxlY3Rpb24sIGV4dHJhY3Rvcikge1xuICBleHRyYWN0b3IgPSB0b0V4dHJhY3RvcihleHRyYWN0b3IpO1xuICB2YXIgc29ydGVkID0gW107XG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICB2YXIgZGlzYyA9IGV4dHJhY3Rvcih2YWx1ZSwga2V5KTtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICBkOiBkaXNjLFxuICAgICAgdjogdmFsdWVcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgc29ydGVkLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIHZhciBkID0gc29ydGVkW2lkeF0uZDtcblxuICAgICAgaWYgKGRpc2MgPCBkKSB7XG4gICAgICAgIHNvcnRlZC5zcGxpY2UoaWR4LCAwLCBlbnRyeSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IC8vIG5vdCBpbnNlcnRlZCwgYXBwZW5kICghKVxuXG5cbiAgICBzb3J0ZWQucHVzaChlbnRyeSk7XG4gIH0pO1xuICByZXR1cm4gbWFwKHNvcnRlZCwgZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS52O1xuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCBwYXR0ZXJuIG1hdGNoZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBtYXRjaGVyID0gbWF0Y2hQYXR0ZXJuKHsgaWQ6IDEgfSk7XG4gKlxuICogdmFyIGVsZW1lbnQgPSBmaW5kKGVsZW1lbnRzLCBtYXRjaGVyKTtcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhdHRlcm5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gbWF0Y2hlckZuXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBldmVyeShwYXR0ZXJuLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICAgIHJldHVybiBlbFtrZXldID09PSB2YWw7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvRXh0cmFjdG9yKGV4dHJhY3Rvcikge1xuICByZXR1cm4gaXNGdW5jdGlvbihleHRyYWN0b3IpID8gZXh0cmFjdG9yIDogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZVtleHRyYWN0b3JdO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0b01hdGNoZXIobWF0Y2hlcikge1xuICByZXR1cm4gaXNGdW5jdGlvbihtYXRjaGVyKSA/IG1hdGNoZXIgOiBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlID09PSBtYXRjaGVyO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eShhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn1cblxuZnVuY3Rpb24gdG9OdW0oYXJnKSB7XG4gIHJldHVybiBOdW1iZXIoYXJnKTtcbn1cblxuLyoqXG4gKiBEZWJvdW5jZSBmbiwgY2FsbGluZyBpdCBvbmx5IG9uY2UgaWZcbiAqIHRoZSBnaXZlbiB0aW1lIGVsYXBzZWQgYmV0d2VlbiBjYWxscy5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSAge051bWJlcn0gdGltZW91dFxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZm4sIHRpbWVvdXQpIHtcbiAgdmFyIHRpbWVyO1xuICB2YXIgbGFzdEFyZ3M7XG4gIHZhciBsYXN0VGhpcztcbiAgdmFyIGxhc3ROb3c7XG5cbiAgZnVuY3Rpb24gZmlyZSgpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgc2NoZWR1bGVkRGlmZiA9IGxhc3ROb3cgKyB0aW1lb3V0IC0gbm93O1xuXG4gICAgaWYgKHNjaGVkdWxlZERpZmYgPiAwKSB7XG4gICAgICByZXR1cm4gc2NoZWR1bGUoc2NoZWR1bGVkRGlmZik7XG4gICAgfVxuXG4gICAgZm4uYXBwbHkobGFzdFRoaXMsIGxhc3RBcmdzKTtcbiAgICB0aW1lciA9IGxhc3ROb3cgPSBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUodGltZW91dCkge1xuICAgIHRpbWVyID0gc2V0VGltZW91dChmaXJlLCB0aW1lb3V0KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbGFzdE5vdyA9IERhdGUubm93KCk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgIGxhc3RUaGlzID0gdGhpczsgLy8gZW5zdXJlIGFuIGV4ZWN1dGlvbiBpcyBzY2hlZHVsZWRcblxuICAgIGlmICghdGltZXIpIHtcbiAgICAgIHNjaGVkdWxlKHRpbWVvdXQpO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogVGhyb3R0bGUgZm4sIGNhbGxpbmcgYXQgbW9zdCBvbmNlXG4gKiBpbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGludGVydmFsXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259IHRocm90dGxlZCBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBpbnRlcnZhbCkge1xuICB2YXIgdGhyb3R0bGluZyA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aHJvdHRsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm4uYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgIHRocm90dGxpbmcgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3R0bGluZyA9IGZhbHNlO1xuICAgIH0sIGludGVydmFsKTtcbiAgfTtcbn1cbi8qKlxuICogQmluZCBmdW5jdGlvbiBhZ2FpbnN0IHRhcmdldCA8dGhpcz4uXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgdGFyZ2V0XG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259IGJvdW5kIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gYmluZChmbiwgdGFyZ2V0KSB7XG4gIHJldHVybiBmbi5iaW5kKHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogQ29udmVuaWVuY2Ugd3JhcHBlciBmb3IgYE9iamVjdC5hc3NpZ25gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvdGhlcnNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvdGhlcnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG90aGVyc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodm9pZCAwLCBbdGFyZ2V0XS5jb25jYXQob3RoZXJzKSk7XG59XG4vKipcbiAqIFNldHMgYSBuZXN0ZWQgcHJvcGVydHkgb2YgYSBnaXZlbiBvYmplY3QgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAqXG4gKiBUaGlzIG11dGF0ZXMgdGhlIG9iamVjdCBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2YgdGhlIHNldCBvcGVyYXRpb24uXG4gKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKVtdfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBuZXN0ZWQgdmFsdWUuXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqL1xuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwYXRoLCB2YWx1ZSkge1xuICB2YXIgY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgZm9yRWFjaChwYXRoLCBmdW5jdGlvbiAoa2V5LCBpZHgpIHtcbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIGtleTogX19wcm90b19fJyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRLZXkgPSBwYXRoW2lkeCArIDFdO1xuICAgIHZhciBuZXh0VGFyZ2V0ID0gY3VycmVudFRhcmdldFtrZXldO1xuXG4gICAgaWYgKGlzRGVmaW5lZChuZXh0S2V5KSAmJiBpc05pbChuZXh0VGFyZ2V0KSkge1xuICAgICAgbmV4dFRhcmdldCA9IGN1cnJlbnRUYXJnZXRba2V5XSA9IGlzTmFOKCtuZXh0S2V5KSA/IHt9IDogW107XG4gICAgfVxuXG4gICAgaWYgKGlzVW5kZWZpbmVkKG5leHRLZXkpKSB7XG4gICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIGRlbGV0ZSBjdXJyZW50VGFyZ2V0W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50VGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFRhcmdldCA9IG5leHRUYXJnZXQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogR2V0cyBhIG5lc3RlZCBwcm9wZXJ0eSBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2YgdGhlIGdldCBvcGVyYXRpb24uXG4gKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKVtdfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBuZXN0ZWQgdmFsdWUuXG4gKiBAcGFyYW0ge2FueX0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBubyB2YWx1ZSBleGlzdHMuXG4gKi9cblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciBjdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICBmb3JFYWNoKHBhdGgsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAvLyBhY2Nlc3NpbmcgbmlsIHByb3BlcnR5IHlpZWxkcyA8dW5kZWZpbmVkPlxuICAgIGlmIChpc05pbChjdXJyZW50VGFyZ2V0KSkge1xuICAgICAgY3VycmVudFRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldFtrZXldO1xuICB9KTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKGN1cnJlbnRUYXJnZXQpID8gZGVmYXVsdFZhbHVlIDogY3VycmVudFRhcmdldDtcbn1cbi8qKlxuICogUGljayBnaXZlbiBwcm9wZXJ0aWVzIGZyb20gdGhlIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtBcnJheX0gcHJvcGVydGllc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gcGljayh0YXJnZXQsIHByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgb2JqID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IHRhcmdldFtwcm9wXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBQaWNrIGFsbCB0YXJnZXQgcHJvcGVydGllcywgZXhjbHVkaW5nIHRoZSBnaXZlbiBvbmVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnRpZXNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIG9taXQodGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIG9iaiA9IE9iamVjdCh0YXJnZXQpO1xuICBmb3JFYWNoKG9iaiwgZnVuY3Rpb24gKHByb3AsIGtleSkge1xuICAgIGlmIChwcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gcHJvcDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZSBgLi4uc291cmNlc2AgaW50byBnaXZlbiB0YXJnZXQuXG4gKlxuICogRG9lcyBzdXBwb3J0IG1lcmdpbmcgb2JqZWN0czsgZG9lcyBub3Qgc3VwcG9ydCBtZXJnaW5nIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIHNvdXJjZXNbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBpZiAoIXNvdXJjZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZvckVhY2goc291cmNlcywgZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIC8vIHNraXAgbm9uLW9iaiBzb3VyY2VzLCBpLmUuIG51bGxcbiAgICBpZiAoIXNvdXJjZSB8fCAhaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvckVhY2goc291cmNlLCBmdW5jdGlvbiAoc291cmNlVmFsLCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldFZhbCA9IHRhcmdldFtrZXldO1xuXG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlVmFsKSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHRhcmdldFZhbCkpIHtcbiAgICAgICAgICAvLyBvdmVycmlkZSB0YXJnZXRba2V5XSB3aXRoIG9iamVjdFxuICAgICAgICAgIHRhcmdldFZhbCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZSh0YXJnZXRWYWwsIHNvdXJjZVZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVZhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCB7IGFzc2lnbiwgYmluZCwgZGVib3VuY2UsIGVuc3VyZUFycmF5LCBldmVyeSwgZmlsdGVyLCBmaW5kLCBmaW5kSW5kZXgsIGZsYXR0ZW4sIGZvckVhY2gsIGdldCwgZ3JvdXBCeSwgaGFzLCBpc0FycmF5LCBpc0RlZmluZWQsIGlzRnVuY3Rpb24sIGlzTmlsLCBpc051bWJlciwgaXNPYmplY3QsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCwga2V5cywgbWFwLCBtYXRjaFBhdHRlcm4sIG1lcmdlLCBvbWl0LCBwaWNrLCByZWR1Y2UsIHNldCwgc2l6ZSwgc29tZSwgc29ydEJ5LCB0aHJvdHRsZSwgdW5pb25CeSwgdW5pcXVlQnksIHZhbHVlcywgd2l0aG91dCB9O1xuIiwiLyoqXG4gKiBTZXQgYXR0cmlidXRlIGBuYW1lYCB0byBgdmFsYCwgb3IgZ2V0IGF0dHIgYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gW3ZhbF1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGF0dHIoZWwsIG5hbWUsIHZhbCkge1xuICAvLyBnZXRcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIH1cblxuICAvLyByZW1vdmVcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cblxuICAvLyBzZXRcbiAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbCk7XG5cbiAgcmV0dXJuIGVsO1xufVxuXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbnZhciBpbmRleG9mID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NvbXBvbmVudC9jbGFzc2VzXG4gKlxuICogV2l0aG91dCB0aGUgY29tcG9uZW50IGJpdHMuXG4gKi9cblxuLyoqXG4gKiBXaGl0ZXNwYWNlIHJlZ2V4cC5cbiAqL1xuXG52YXIgcmUgPSAvXFxzKy87XG5cbi8qKlxuICogdG9TdHJpbmcgcmVmZXJlbmNlLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV3JhcCBgZWxgIGluIGEgYENsYXNzTGlzdGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjbGFzc2VzKGVsKSB7XG4gIHJldHVybiBuZXcgQ2xhc3NMaXN0KGVsKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IENsYXNzTGlzdCBmb3IgYGVsYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBDbGFzc0xpc3QoZWwpIHtcbiAgaWYgKCFlbCB8fCAhZWwubm9kZVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgRE9NIGVsZW1lbnQgcmVmZXJlbmNlIGlzIHJlcXVpcmVkJyk7XG4gIH1cbiAgdGhpcy5lbCA9IGVsO1xuICB0aGlzLmxpc3QgPSBlbC5jbGFzc0xpc3Q7XG59XG5cbi8qKlxuICogQWRkIGNsYXNzIGBuYW1lYCBpZiBub3QgYWxyZWFkeSBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgLy8gY2xhc3NMaXN0XG4gIGlmICh0aGlzLmxpc3QpIHtcbiAgICB0aGlzLmxpc3QuYWRkKG5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZmFsbGJhY2tcbiAgdmFyIGFyciA9IHRoaXMuYXJyYXkoKTtcbiAgdmFyIGkgPSBpbmRleG9mKGFyciwgbmFtZSk7XG4gIGlmICghfmkpIGFyci5wdXNoKG5hbWUpO1xuICB0aGlzLmVsLmNsYXNzTmFtZSA9IGFyci5qb2luKCcgJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgY2xhc3MgYG5hbWVgIHdoZW4gcHJlc2VudCwgb3JcbiAqIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlXG4gKiBhbnkgd2hpY2ggbWF0Y2guXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCdbb2JqZWN0IFJlZ0V4cF0nID09IHRvU3RyaW5nLmNhbGwobmFtZSkpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVNYXRjaGluZyhuYW1lKTtcbiAgfVxuXG4gIC8vIGNsYXNzTGlzdFxuICBpZiAodGhpcy5saXN0KSB7XG4gICAgdGhpcy5saXN0LnJlbW92ZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIHZhciBpID0gaW5kZXhvZihhcnIsIG5hbWUpO1xuICBpZiAofmkpIGFyci5zcGxpY2UoaSwgMSk7XG4gIHRoaXMuZWwuY2xhc3NOYW1lID0gYXJyLmpvaW4oJyAnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgY2xhc3NlcyBtYXRjaGluZyBgcmVgLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5yZW1vdmVNYXRjaGluZyA9IGZ1bmN0aW9uIChyZSkge1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZS50ZXN0KGFycltpXSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgY2xhc3MgYG5hbWVgLCBjYW4gZm9yY2Ugc3RhdGUgdmlhIGBmb3JjZWAuXG4gKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBjbGFzc0xpc3QsIGJ1dCBkbyBub3Qgc3VwcG9ydCBgZm9yY2VgIHlldCxcbiAqIHRoZSBtaXN0YWtlIHdpbGwgYmUgZGV0ZWN0ZWQgYW5kIGNvcnJlY3RlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChuYW1lLCBmb3JjZSkge1xuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGZvcmNlKSB7XG4gICAgICBpZiAoZm9yY2UgIT09IHRoaXMubGlzdC50b2dnbGUobmFtZSwgZm9yY2UpKSB7XG4gICAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7IC8vIHRvZ2dsZSBhZ2FpbiB0byBjb3JyZWN0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZmFsbGJhY2tcbiAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgZm9yY2UpIHtcbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICB0aGlzLnJlbW92ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmhhcyhuYW1lKSkge1xuICAgICAgdGhpcy5yZW1vdmUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgb2YgY2xhc3Nlcy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICB2YXIgc3RyID0gY2xhc3NOYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgdmFyIGFyciA9IHN0ci5zcGxpdChyZSk7XG4gIGlmICgnJyA9PT0gYXJyWzBdKSBhcnIuc2hpZnQoKTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgY2xhc3MgYG5hbWVgIGlzIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5oYXMgPSBDbGFzc0xpc3QucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubGlzdCA/IHRoaXMubGlzdC5jb250YWlucyhuYW1lKSA6ICEhfmluZGV4b2YodGhpcy5hcnJheSgpLCBuYW1lKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBjaGlsZHJlbiBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBjbGVhcihlbCkge1xuXG4gIHZhciBjO1xuXG4gIHdoaWxlIChlbC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgIGMgPSBlbC5jaGlsZE5vZGVzWzBdO1xuICAgIGVsLnJlbW92ZUNoaWxkKGMpO1xuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG52YXIgcHJvdG8gPSB0eXBlb2YgRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBFbGVtZW50LnByb3RvdHlwZSA6IHt9O1xudmFyIHZlbmRvciA9IHByb3RvLm1hdGNoZXNcbiAgfHwgcHJvdG8ubWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5tb3pNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ubXNNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ub01hdGNoZXNTZWxlY3RvcjtcblxudmFyIG1hdGNoZXNTZWxlY3RvciA9IG1hdGNoO1xuXG4vKipcbiAqIE1hdGNoIGBlbGAgdG8gYHNlbGVjdG9yYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG1hdGNoKGVsLCBzZWxlY3Rvcikge1xuICBpZiAoIWVsIHx8IGVsLm5vZGVUeXBlICE9PSAxKSByZXR1cm4gZmFsc2U7XG4gIGlmICh2ZW5kb3IpIHJldHVybiB2ZW5kb3IuY2FsbChlbCwgc2VsZWN0b3IpO1xuICB2YXIgbm9kZXMgPSBlbC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldID09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2xvc2VzdFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtCb29sZWFufSBjaGVja1lvdXJTZWxmIChvcHRpb25hbClcbiAqL1xuZnVuY3Rpb24gY2xvc2VzdCAoZWxlbWVudCwgc2VsZWN0b3IsIGNoZWNrWW91clNlbGYpIHtcbiAgdmFyIGN1cnJlbnRFbGVtID0gY2hlY2tZb3VyU2VsZiA/IGVsZW1lbnQgOiBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgd2hpbGUgKGN1cnJlbnRFbGVtICYmIGN1cnJlbnRFbGVtLm5vZGVUeXBlICE9PSBkb2N1bWVudC5ET0NVTUVOVF9OT0RFICYmIGN1cnJlbnRFbGVtLm5vZGVUeXBlICE9PSBkb2N1bWVudC5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG5cbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKGN1cnJlbnRFbGVtLCBzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiBjdXJyZW50RWxlbTtcbiAgICB9XG5cbiAgICBjdXJyZW50RWxlbSA9IGN1cnJlbnRFbGVtLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yKGN1cnJlbnRFbGVtLCBzZWxlY3RvcikgPyBjdXJyZW50RWxlbSA6IG51bGw7XG59XG5cbnZhciBiaW5kID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAnYXR0YWNoRXZlbnQnLFxuICAgIHVuYmluZCA9IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2RldGFjaEV2ZW50JyxcbiAgICBwcmVmaXggPSBiaW5kICE9PSAnYWRkRXZlbnRMaXN0ZW5lcicgPyAnb24nIDogJyc7XG5cbi8qKlxuICogQmluZCBgZWxgIGV2ZW50IGB0eXBlYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIGJpbmRfMSA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIGVsW2JpbmRdKHByZWZpeCArIHR5cGUsIGZuLCBjYXB0dXJlIHx8IGZhbHNlKTtcbiAgcmV0dXJuIGZuO1xufTtcblxuLyoqXG4gKiBVbmJpbmQgYGVsYCBldmVudCBgdHlwZWAncyBjYWxsYmFjayBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIHVuYmluZF8xID0gZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCBjYXB0dXJlKXtcbiAgZWxbdW5iaW5kXShwcmVmaXggKyB0eXBlLCBmbiwgY2FwdHVyZSB8fCBmYWxzZSk7XG4gIHJldHVybiBmbjtcbn07XG5cbnZhciBjb21wb25lbnRFdmVudCA9IHtcblx0YmluZDogYmluZF8xLFxuXHR1bmJpbmQ6IHVuYmluZF8xXG59O1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuLyoqXG4gKiBEZWxlZ2F0ZSBldmVudCBgdHlwZWAgdG8gYHNlbGVjdG9yYFxuICogYW5kIGludm9rZSBgZm4oZSlgLiBBIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBpcyByZXR1cm5lZCB3aGljaCBtYXkgYmUgcGFzc2VkIHRvIGAudW5iaW5kKClgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vLyBTb21lIGV2ZW50cyBkb24ndCBidWJibGUsIHNvIHdlIHdhbnQgdG8gYmluZCB0byB0aGUgY2FwdHVyZSBwaGFzZSBpbnN0ZWFkXG4vLyB3aGVuIGRlbGVnYXRpbmcuXG52YXIgZm9yY2VDYXB0dXJlRXZlbnRzID0gWydmb2N1cycsICdibHVyJ107XG5cbmZ1bmN0aW9uIGJpbmQkMShlbCwgc2VsZWN0b3IsIHR5cGUsIGZuLCBjYXB0dXJlKSB7XG4gIGlmIChmb3JjZUNhcHR1cmVFdmVudHMuaW5kZXhPZih0eXBlKSAhPT0gLTEpIHtcbiAgICBjYXB0dXJlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRFdmVudC5iaW5kKGVsLCB0eXBlLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgZS5kZWxlZ2F0ZVRhcmdldCA9IGNsb3Nlc3QodGFyZ2V0LCBzZWxlY3RvciwgdHJ1ZSwgZWwpO1xuICAgIGlmIChlLmRlbGVnYXRlVGFyZ2V0KSB7XG4gICAgICBmbi5jYWxsKGVsLCBlKTtcbiAgICB9XG4gIH0sIGNhcHR1cmUpO1xufVxuXG4vKipcbiAqIFVuYmluZCBldmVudCBgdHlwZWAncyBjYWxsYmFjayBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB1bmJpbmQkMShlbCwgdHlwZSwgZm4sIGNhcHR1cmUpIHtcbiAgaWYgKGZvcmNlQ2FwdHVyZUV2ZW50cy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuICAgIGNhcHR1cmUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudEV2ZW50LnVuYmluZChlbCwgdHlwZSwgZm4sIGNhcHR1cmUpO1xufVxuXG52YXIgZGVsZWdhdGUgPSB7XG4gIGJpbmQ6IGJpbmQkMSxcbiAgdW5iaW5kOiB1bmJpbmQkMVxufTtcblxuLyoqXG4gKiBFeHBvc2UgYHBhcnNlYC5cbiAqL1xuXG52YXIgZG9taWZ5ID0gcGFyc2U7XG5cbi8qKlxuICogVGVzdHMgZm9yIGJyb3dzZXIgc3VwcG9ydC5cbiAqL1xuXG52YXIgaW5uZXJIVE1MQnVnID0gZmFsc2U7XG52YXIgYnVnVGVzdERpdjtcbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIGJ1Z1Rlc3REaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgLy8gU2V0dXBcbiAgYnVnVGVzdERpdi5pbm5lckhUTUwgPSAnICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj1cIi9hXCI+YTwvYT48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIvPic7XG4gIC8vIE1ha2Ugc3VyZSB0aGF0IGxpbmsgZWxlbWVudHMgZ2V0IHNlcmlhbGl6ZWQgY29ycmVjdGx5IGJ5IGlubmVySFRNTFxuICAvLyBUaGlzIHJlcXVpcmVzIGEgd3JhcHBlciBlbGVtZW50IGluIElFXG4gIGlubmVySFRNTEJ1ZyA9ICFidWdUZXN0RGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaW5rJykubGVuZ3RoO1xuICBidWdUZXN0RGl2ID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFdyYXAgbWFwIGZyb20ganF1ZXJ5LlxuICovXG5cbnZhciBtYXAgPSB7XG4gIGxlZ2VuZDogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gIHRyOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcbiAgY29sOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgLy8gZm9yIHNjcmlwdC9saW5rL3N0eWxlIHRhZ3MgdG8gd29yayBpbiBJRTYtOCwgeW91IGhhdmUgdG8gd3JhcFxuICAvLyBpbiBhIGRpdiB3aXRoIGEgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIGluIGZyb250LCBoYSFcbiAgX2RlZmF1bHQ6IGlubmVySFRNTEJ1ZyA/IFsxLCAnWDxkaXY+JywgJzwvZGl2PiddIDogWzAsICcnLCAnJ11cbn07XG5cbm1hcC50ZCA9XG5tYXAudGggPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxubWFwLm9wdGlvbiA9XG5tYXAub3B0Z3JvdXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsICc8L3NlbGVjdD4nXTtcblxubWFwLnRoZWFkID1cbm1hcC50Ym9keSA9XG5tYXAuY29sZ3JvdXAgPVxubWFwLmNhcHRpb24gPVxubWFwLnRmb290ID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG5cbm1hcC5wb2x5bGluZSA9XG5tYXAuZWxsaXBzZSA9XG5tYXAucG9seWdvbiA9XG5tYXAuY2lyY2xlID1cbm1hcC50ZXh0ID1cbm1hcC5saW5lID1cbm1hcC5wYXRoID1cbm1hcC5yZWN0ID1cbm1hcC5nID0gWzEsICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2ZXJzaW9uPVwiMS4xXCI+JywnPC9zdmc+J107XG5cbi8qKlxuICogUGFyc2UgYGh0bWxgIGFuZCByZXR1cm4gYSBET00gTm9kZSBpbnN0YW5jZSwgd2hpY2ggY291bGQgYmUgYSBUZXh0Tm9kZSxcbiAqIEhUTUwgRE9NIE5vZGUgb2Ygc29tZSBraW5kICg8ZGl2PiBmb3IgZXhhbXBsZSksIG9yIGEgRG9jdW1lbnRGcmFnbWVudFxuICogaW5zdGFuY2UsIGRlcGVuZGluZyBvbiB0aGUgY29udGVudHMgb2YgdGhlIGBodG1sYCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgLSBIVE1MIHN0cmluZyB0byBcImRvbWlmeVwiXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgLSBUaGUgYGRvY3VtZW50YCBpbnN0YW5jZSB0byBjcmVhdGUgdGhlIE5vZGUgZm9yXG4gKiBAcmV0dXJuIHtET01Ob2RlfSB0aGUgVGV4dE5vZGUsIERPTSBOb2RlLCBvciBEb2N1bWVudEZyYWdtZW50IGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShodG1sLCBkb2MpIHtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBodG1sKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdHJpbmcgZXhwZWN0ZWQnKTtcblxuICAvLyBkZWZhdWx0IHRvIHRoZSBnbG9iYWwgYGRvY3VtZW50YCBvYmplY3RcbiAgaWYgKCFkb2MpIGRvYyA9IGRvY3VtZW50O1xuXG4gIC8vIHRhZyBuYW1lXG4gIHZhciBtID0gLzwoW1xcdzpdKykvLmV4ZWMoaHRtbCk7XG4gIGlmICghbSkgcmV0dXJuIGRvYy5jcmVhdGVUZXh0Tm9kZShodG1sKTtcblxuICBodG1sID0gaHRtbC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7IC8vIFJlbW92ZSBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2VcblxuICB2YXIgdGFnID0gbVsxXTtcblxuICAvLyBib2R5IHN1cHBvcnRcbiAgaWYgKHRhZyA9PSAnYm9keScpIHtcbiAgICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xuICAgIGVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGVsLnJlbW92ZUNoaWxkKGVsLmxhc3RDaGlsZCk7XG4gIH1cblxuICAvLyB3cmFwIG1hcFxuICB2YXIgd3JhcCA9IG1hcFt0YWddIHx8IG1hcC5fZGVmYXVsdDtcbiAgdmFyIGRlcHRoID0gd3JhcFswXTtcbiAgdmFyIHByZWZpeCA9IHdyYXBbMV07XG4gIHZhciBzdWZmaXggPSB3cmFwWzJdO1xuICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsLmlubmVySFRNTCA9IHByZWZpeCArIGh0bWwgKyBzdWZmaXg7XG4gIHdoaWxlIChkZXB0aC0tKSBlbCA9IGVsLmxhc3RDaGlsZDtcblxuICAvLyBvbmUgZWxlbWVudFxuICBpZiAoZWwuZmlyc3RDaGlsZCA9PSBlbC5sYXN0Q2hpbGQpIHtcbiAgICByZXR1cm4gZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gIH1cblxuICAvLyBzZXZlcmFsIGVsZW1lbnRzXG4gIHZhciBmcmFnbWVudCA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCkpO1xuICB9XG5cbiAgcmV0dXJuIGZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBxdWVyeShzZWxlY3RvciwgZWwpIHtcbiAgZWwgPSBlbCB8fCBkb2N1bWVudDtcblxuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIGFsbChzZWxlY3RvciwgZWwpIHtcbiAgZWwgPSBlbCB8fCBkb2N1bWVudDtcblxuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShlbCkge1xuICBlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xufVxuXG5leHBvcnQgeyBhdHRyLCBjbGFzc2VzLCBjbGVhciwgY2xvc2VzdCwgZGVsZWdhdGUsIGRvbWlmeSwgY29tcG9uZW50RXZlbnQgYXMgZXZlbnQsIG1hdGNoZXNTZWxlY3RvciBhcyBtYXRjaGVzLCBxdWVyeSwgYWxsIGFzIHF1ZXJ5QWxsLCByZW1vdmUgfTtcbiIsImltcG9ydCB7IGZvckVhY2gsIGFzc2lnbiwgZmluZCwgZmlsdGVyLCBoYXMsIGlzU3RyaW5nLCBtYXAgfSBmcm9tICdtaW4tZGFzaCc7XG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tICdzYXhlbic7XG5pbXBvcnQgeyBjb2VyY2VUeXBlLCBwYXJzZU5hbWVOUywgaXNTaW1wbGVUeXBlLCBNb2RkbGUgfSBmcm9tICdtb2RkbGUnO1xuXG5mdW5jdGlvbiBoYXNMb3dlckNhc2VBbGlhcyhwa2cpIHtcbiAgcmV0dXJuIHBrZy54bWwgJiYgcGtnLnhtbC50YWdBbGlhcyA9PT0gJ2xvd2VyQ2FzZSc7XG59XG5cbnZhciBERUZBVUxUX05TX01BUCA9IHtcbiAgJ3hzaSc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZScsXG4gICd4bWwnOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxudmFyIFhTSV9UWVBFID0gJ3hzaTp0eXBlJztcblxuZnVuY3Rpb24gc2VyaWFsaXplRm9ybWF0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQueG1sICYmIGVsZW1lbnQueG1sLnNlcmlhbGl6ZTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplQXNUeXBlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZUZvcm1hdChlbGVtZW50KSA9PT0gWFNJX1RZUEU7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFzUHJvcGVydHkoZWxlbWVudCkge1xuICByZXR1cm4gc2VyaWFsaXplRm9ybWF0KGVsZW1lbnQpID09PSAncHJvcGVydHknO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuXG5mdW5jdGlvbiBhbGlhc1RvTmFtZShhbGlhc05zLCBwa2cpIHtcblxuICBpZiAoIWhhc0xvd2VyQ2FzZUFsaWFzKHBrZykpIHtcbiAgICByZXR1cm4gYWxpYXNOcy5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIGFsaWFzTnMucHJlZml4ICsgJzonICsgY2FwaXRhbGl6ZShhbGlhc05zLmxvY2FsTmFtZSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpeGVkVG9OYW1lKG5hbWVOcywgcGtnKSB7XG5cbiAgdmFyIG5hbWUgPSBuYW1lTnMubmFtZSxcbiAgICAgIGxvY2FsTmFtZSA9IG5hbWVOcy5sb2NhbE5hbWU7XG5cbiAgdmFyIHR5cGVQcmVmaXggPSBwa2cueG1sICYmIHBrZy54bWwudHlwZVByZWZpeDtcblxuICBpZiAodHlwZVByZWZpeCAmJiBsb2NhbE5hbWUuaW5kZXhPZih0eXBlUHJlZml4KSA9PT0gMCkge1xuICAgIHJldHVybiBuYW1lTnMucHJlZml4ICsgJzonICsgbG9jYWxOYW1lLnNsaWNlKHR5cGVQcmVmaXgubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVYc2lUeXBlTmFtZShuYW1lLCBtb2RlbCkge1xuXG4gIHZhciBuYW1lTnMgPSBwYXJzZU5hbWVOUyhuYW1lKTtcbiAgdmFyIHBrZyA9IG1vZGVsLmdldFBhY2thZ2UobmFtZU5zLnByZWZpeCk7XG5cbiAgcmV0dXJuIHByZWZpeGVkVG9OYW1lKG5hbWVOcywgcGtnKTtcbn1cblxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbW9kZGxlIGRlc2NyaXB0b3IgZm9yIGEgZ2l2ZW4gaW5zdGFuY2Ugb3IgdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtNb2RkbGVFbGVtZW50fEZ1bmN0aW9ufSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbW9kZGxlIGRlc2NyaXB0b3JcbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LiRkZXNjcmlwdG9yO1xufVxuXG5cbi8qKlxuICogQSBwYXJzZSBjb250ZXh0LlxuICpcbiAqIEBjbGFzc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0VsZW1lbnRIYW5kbGVyfSBvcHRpb25zLnJvb3RIYW5kbGVyIHRoZSByb290IGhhbmRsZXIgZm9yIHBhcnNpbmcgYSBkb2N1bWVudFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sYXg9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGlnbm9yZSBpbnZhbGlkIGVsZW1lbnRzXG4gKi9cbmZ1bmN0aW9uIENvbnRleHQob3B0aW9ucykge1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge0VsZW1lbnRIYW5kbGVyfSByb290SGFuZGxlclxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBsYXhcbiAgICovXG5cbiAgYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuZWxlbWVudHNCeUlkID0ge307XG4gIHRoaXMucmVmZXJlbmNlcyA9IFtdO1xuICB0aGlzLndhcm5pbmdzID0gW107XG5cbiAgLyoqXG4gICAqIEFkZCBhbiB1bnJlc29sdmVkIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZVxuICAgKi9cbiAgdGhpcy5hZGRSZWZlcmVuY2UgPSBmdW5jdGlvbihyZWZlcmVuY2UpIHtcbiAgICB0aGlzLnJlZmVyZW5jZXMucHVzaChyZWZlcmVuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBwcm9jZXNzZWQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICB0aGlzLmFkZEVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHRocm93IGVycm9yKCdleHBlY3RlZCBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzQnlJZCA9IHRoaXMuZWxlbWVudHNCeUlkO1xuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnQpO1xuXG4gICAgdmFyIGlkUHJvcGVydHkgPSBkZXNjcmlwdG9yLmlkUHJvcGVydHksXG4gICAgICAgIGlkO1xuXG4gICAgaWYgKGlkUHJvcGVydHkpIHtcbiAgICAgIGlkID0gZWxlbWVudC5nZXQoaWRQcm9wZXJ0eS5uYW1lKTtcblxuICAgICAgaWYgKGlkKSB7XG5cbiAgICAgICAgLy8gZm9yIFFOYW1lIHZhbGlkYXRpb24gYXMgcGVyIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVDaGFyXG4gICAgICAgIGlmICghL14oW2Etel1bXFx3LS5dKjopP1thLXpfXVtcXHctLl0qJC9pLnRlc3QoaWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIElEIDwnICsgaWQgKyAnPicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnRzQnlJZFtpZF0pIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcignZHVwbGljYXRlIElEIDwnICsgaWQgKyAnPicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHNCeUlkW2lkXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW4gaW1wb3J0IHdhcm5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB3YXJuaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB3YXJuaW5nLm1lc3NhZ2VcbiAgICogQHBhcmFtIHtFcnJvcn0gW3dhcm5pbmcuZXJyb3JdXG4gICAqL1xuICB0aGlzLmFkZFdhcm5pbmcgPSBmdW5jdGlvbih3YXJuaW5nKSB7XG4gICAgdGhpcy53YXJuaW5ncy5wdXNoKHdhcm5pbmcpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBCYXNlSGFuZGxlcigpIHt9XG5cbkJhc2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHt9O1xuQmFzZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQgPSBmdW5jdGlvbigpIHt9O1xuQmFzZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8qKlxuICogQSBzaW1wbGUgcGFzcyB0aHJvdWdoIGhhbmRsZXIgdGhhdCBkb2VzIG5vdGhpbmcgZXhjZXB0IGZvclxuICogaWdub3JpbmcgYWxsIGlucHV0IGl0IHJlY2VpdmVzLlxuICpcbiAqIFRoaXMgaXMgdXNlZCB0byBpZ25vcmUgdW5rbm93biBlbGVtZW50cyBhbmRcbiAqIGF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIE5vb3BIYW5kbGVyKCkgeyB9XG5cbk5vb3BIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUhhbmRsZXIucHJvdG90eXBlKTtcblxuTm9vcEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBCb2R5SGFuZGxlcigpIHt9XG5cbkJvZHlIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUhhbmRsZXIucHJvdG90eXBlKTtcblxuQm9keUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHRoaXMuYm9keSA9ICh0aGlzLmJvZHkgfHwgJycpICsgdGV4dDtcbn07XG5cbmZ1bmN0aW9uIFJlZmVyZW5jZUhhbmRsZXIocHJvcGVydHksIGNvbnRleHQpIHtcbiAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG5SZWZlcmVuY2VIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQm9keUhhbmRsZXIucHJvdG90eXBlKTtcblxuUmVmZXJlbmNlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgdGhyb3cgZXJyb3IoJ2V4cGVjdGVkIG5vIHN1YiBub2RlcycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuY3JlYXRlUmVmZXJlbmNlKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWZlcmVuY2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50LmlkID0gdGhpcy5ib2R5O1xufTtcblxuUmVmZXJlbmNlSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlUmVmZXJlbmNlID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4ge1xuICAgIHByb3BlcnR5OiB0aGlzLnByb3BlcnR5Lm5zLm5hbWUsXG4gICAgaWQ6ICcnXG4gIH07XG59O1xuXG5mdW5jdGlvbiBWYWx1ZUhhbmRsZXIocHJvcGVydHlEZXNjLCBlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMucHJvcGVydHlEZXNjID0gcHJvcGVydHlEZXNjO1xufVxuXG5WYWx1ZUhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCb2R5SGFuZGxlci5wcm90b3R5cGUpO1xuXG5WYWx1ZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciB2YWx1ZSA9IHRoaXMuYm9keSB8fCAnJyxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBwcm9wZXJ0eURlc2MgPSB0aGlzLnByb3BlcnR5RGVzYztcblxuICB2YWx1ZSA9IGNvZXJjZVR5cGUocHJvcGVydHlEZXNjLnR5cGUsIHZhbHVlKTtcblxuICBpZiAocHJvcGVydHlEZXNjLmlzTWFueSkge1xuICAgIGVsZW1lbnQuZ2V0KHByb3BlcnR5RGVzYy5uYW1lKS5wdXNoKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnNldChwcm9wZXJ0eURlc2MubmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIEJhc2VFbGVtZW50SGFuZGxlcigpIHt9XG5cbkJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJvZHlIYW5kbGVyLnByb3RvdHlwZSk7XG5cbkJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHBhcnNlciA9IHRoaXMsXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIGlmICghZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQobm9kZSk7XG5cbiAgICB0aGlzLmNvbnRleHQuYWRkRWxlbWVudChlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZXIgPSB0aGlzLmhhbmRsZUNoaWxkKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWRlci5FbGVtZW50SGFuZGxlclxuICpcbiAqL1xuZnVuY3Rpb24gRWxlbWVudEhhbmRsZXIobW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy50eXBlID0gbW9kZWwuZ2V0VHlwZSh0eXBlTmFtZSk7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSk7XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5hZGRSZWZlcmVuY2UgPSBmdW5jdGlvbihyZWZlcmVuY2UpIHtcbiAgdGhpcy5jb250ZXh0LmFkZFJlZmVyZW5jZShyZWZlcmVuY2UpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG5cbiAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KSxcbiAgICAgIGJvZHlQcm9wZXJ0eSA9IGRlc2NyaXB0b3IuYm9keVByb3BlcnR5O1xuXG4gIGlmICghYm9keVByb3BlcnR5KSB7XG4gICAgdGhyb3cgZXJyb3IoJ3VuZXhwZWN0ZWQgYm9keSB0ZXh0IDwnICsgdGV4dCArICc+Jyk7XG4gIH1cblxuICBCb2R5SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlVGV4dC5jYWxsKHRoaXMsIHRleHQpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciB2YWx1ZSA9IHRoaXMuYm9keSxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KSxcbiAgICAgIGJvZHlQcm9wZXJ0eSA9IGRlc2NyaXB0b3IuYm9keVByb3BlcnR5O1xuXG4gIGlmIChib2R5UHJvcGVydHkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gY29lcmNlVHlwZShib2R5UHJvcGVydHkudHlwZSwgdmFsdWUpO1xuICAgIGVsZW1lbnQuc2V0KGJvZHlQcm9wZXJ0eS5uYW1lLCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBtb2RlbCBmcm9tIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUgdGhlIHhtbCBub2RlXG4gKi9cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcyxcbiAgICAgIFR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihUeXBlKSxcbiAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICBpbnN0YW5jZSA9IG5ldyBUeXBlKHt9KSxcbiAgICAgIG1vZGVsID0gdGhpcy5tb2RlbCxcbiAgICAgIHByb3BOYW1lTnM7XG5cbiAgZm9yRWFjaChhdHRyaWJ1dGVzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXG4gICAgdmFyIHByb3AgPSBkZXNjcmlwdG9yLnByb3BlcnRpZXNCeU5hbWVbbmFtZV0sXG4gICAgICAgIHZhbHVlcztcblxuICAgIGlmIChwcm9wICYmIHByb3AuaXNSZWZlcmVuY2UpIHtcblxuICAgICAgaWYgKCFwcm9wLmlzTWFueSkge1xuICAgICAgICBjb250ZXh0LmFkZFJlZmVyZW5jZSh7XG4gICAgICAgICAgZWxlbWVudDogaW5zdGFuY2UsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3AubnMubmFtZSxcbiAgICAgICAgICBpZDogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIElEUkVGUzogcGFyc2UgcmVmZXJlbmNlcyBhcyB3aGl0ZXNwYWNlLXNlcGFyYXRlZCBsaXN0XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgZm9yRWFjaCh2YWx1ZXMsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBjb250ZXh0LmFkZFJlZmVyZW5jZSh7XG4gICAgICAgICAgICBlbGVtZW50OiBpbnN0YW5jZSxcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLm5zLm5hbWUsXG4gICAgICAgICAgICBpZDogdlxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcCkge1xuICAgICAgICB2YWx1ZSA9IGNvZXJjZVR5cGUocHJvcC50eXBlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChuYW1lICE9PSAneG1sbnMnKSB7XG4gICAgICAgIHByb3BOYW1lTnMgPSBwYXJzZU5hbWVOUyhuYW1lLCBkZXNjcmlwdG9yLm5zLnByZWZpeCk7XG5cbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBpbiBhIHdlbGwta25vd24gbmFtZXNwYWNlXG4gICAgICAgIC8vIGlmIHRoYXQgaXMgdGhlIGNhc2Ugd2UgZW1pdCBhIHdhcm5pbmcgdG8gaW5kaWNhdGUgcG90ZW50aWFsIG1pc3VzZVxuICAgICAgICBpZiAobW9kZWwuZ2V0UGFja2FnZShwcm9wTmFtZU5zLnByZWZpeCkpIHtcblxuICAgICAgICAgIGNvbnRleHQuYWRkV2FybmluZyh7XG4gICAgICAgICAgICBtZXNzYWdlOiAndW5rbm93biBhdHRyaWJ1dGUgPCcgKyBuYW1lICsgJz4nLFxuICAgICAgICAgICAgZWxlbWVudDogaW5zdGFuY2UsXG4gICAgICAgICAgICBwcm9wZXJ0eTogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUuZ2V0UHJvcGVydHlGb3JOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICB2YXIgbmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSk7XG5cbiAgdmFyIHR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcih0eXBlKTtcblxuICB2YXIgcHJvcGVydHlOYW1lID0gbmFtZU5zLm5hbWUsXG4gICAgICBwcm9wZXJ0eSA9IGRlc2NyaXB0b3IucHJvcGVydGllc0J5TmFtZVtwcm9wZXJ0eU5hbWVdLFxuICAgICAgZWxlbWVudFR5cGVOYW1lLFxuICAgICAgZWxlbWVudFR5cGU7XG5cbiAgLy8gc2VhcmNoIGZvciBwcm9wZXJ0aWVzIGJ5IG5hbWUgZmlyc3RcblxuICBpZiAocHJvcGVydHkgJiYgIXByb3BlcnR5LmlzQXR0cikge1xuXG4gICAgaWYgKHNlcmlhbGl6ZUFzVHlwZShwcm9wZXJ0eSkpIHtcbiAgICAgIGVsZW1lbnRUeXBlTmFtZSA9IG5vZGUuYXR0cmlidXRlc1tYU0lfVFlQRV07XG5cbiAgICAgIC8vIHhzaSB0eXBlIGlzIG9wdGlvbmFsLCBpZiBpdCBkb2VzIG5vdCBleGlzdHMgdGhlXG4gICAgICAvLyBkZWZhdWx0IHR5cGUgaXMgYXNzdW1lZFxuICAgICAgaWYgKGVsZW1lbnRUeXBlTmFtZSkge1xuXG4gICAgICAgIC8vIHRha2UgcG9zc2libGUgdHlwZSBwcmVmaXhlcyBmcm9tIFhNTFxuICAgICAgICAvLyBpbnRvIGFjY291bnQsIGkuZS46IHhzaTp0eXBlPVwidHtBY3R1YWxUeXBlfVwiXG4gICAgICAgIGVsZW1lbnRUeXBlTmFtZSA9IG5vcm1hbGl6ZVhzaVR5cGVOYW1lKGVsZW1lbnRUeXBlTmFtZSwgbW9kZWwpO1xuXG4gICAgICAgIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0VHlwZShlbGVtZW50VHlwZU5hbWUpO1xuXG4gICAgICAgIHJldHVybiBhc3NpZ24oe30sIHByb3BlcnR5LCB7XG4gICAgICAgICAgZWZmZWN0aXZlVHlwZTogZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50VHlwZSkubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZWFyY2ggZm9yIHByb3BlcnRpZXMgYnkgbmFtZSBmaXJzdFxuICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgfVxuXG4gIHZhciBwa2cgPSBtb2RlbC5nZXRQYWNrYWdlKG5hbWVOcy5wcmVmaXgpO1xuXG4gIGlmIChwa2cpIHtcbiAgICBlbGVtZW50VHlwZU5hbWUgPSBhbGlhc1RvTmFtZShuYW1lTnMsIHBrZyk7XG4gICAgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXRUeXBlKGVsZW1lbnRUeXBlTmFtZSk7XG5cbiAgICAvLyBzZWFyY2ggZm9yIGNvbGxlY3Rpb24gbWVtYmVycyBsYXRlclxuICAgIHByb3BlcnR5ID0gZmluZChkZXNjcmlwdG9yLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiAhcC5pc1ZpcnR1YWwgJiYgIXAuaXNSZWZlcmVuY2UgJiYgIXAuaXNBdHRyaWJ1dGUgJiYgZWxlbWVudFR5cGUuaGFzVHlwZShwLnR5cGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gYXNzaWduKHt9LCBwcm9wZXJ0eSwge1xuICAgICAgICBlZmZlY3RpdmVUeXBlOiBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnRUeXBlKS5uYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG5cbiAgICAvLyBwYXJzZSB1bmtub3duIGVsZW1lbnQgKG1heWJlIGV4dGVuc2lvbilcbiAgICBwcm9wZXJ0eSA9IGZpbmQoZGVzY3JpcHRvci5wcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gIXAuaXNSZWZlcmVuY2UgJiYgIXAuaXNBdHRyaWJ1dGUgJiYgcC50eXBlID09PSAnRWxlbWVudCc7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBlcnJvcigndW5yZWNvZ25pemVkIGVsZW1lbnQgPCcgKyBuYW1lTnMubmFtZSArICc+Jyk7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdFbGVtZW50RGVzY3JpcHRvclsnICsgZ2V0TW9kZGxlRGVzY3JpcHRvcih0aGlzLnR5cGUpLm5hbWUgKyAnXSc7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUudmFsdWVIYW5kbGVyID0gZnVuY3Rpb24ocHJvcGVydHlEZXNjLCBlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgVmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCk7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUucmVmZXJlbmNlSGFuZGxlciA9IGZ1bmN0aW9uKHByb3BlcnR5RGVzYykge1xuICByZXR1cm4gbmV3IFJlZmVyZW5jZUhhbmRsZXIocHJvcGVydHlEZXNjLCB0aGlzLmNvbnRleHQpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnRWxlbWVudCcpIHtcbiAgICByZXR1cm4gbmV3IEdlbmVyaWNFbGVtZW50SGFuZGxlcih0aGlzLm1vZGVsLCB0eXBlLCB0aGlzLmNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgdHlwZSwgdGhpcy5jb250ZXh0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgdGhlIGNoaWxkIGVsZW1lbnQgcGFyc2luZ1xuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUgdGhlIHhtbCBub2RlXG4gKi9cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVDaGlsZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHByb3BlcnR5RGVzYywgdHlwZSwgZWxlbWVudCwgY2hpbGRIYW5kbGVyO1xuXG4gIHByb3BlcnR5RGVzYyA9IHRoaXMuZ2V0UHJvcGVydHlGb3JOb2RlKG5vZGUpO1xuICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIHR5cGUgPSBwcm9wZXJ0eURlc2MuZWZmZWN0aXZlVHlwZSB8fCBwcm9wZXJ0eURlc2MudHlwZTtcblxuICBpZiAoaXNTaW1wbGVUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCk7XG4gIH1cblxuICBpZiAocHJvcGVydHlEZXNjLmlzUmVmZXJlbmNlKSB7XG4gICAgY2hpbGRIYW5kbGVyID0gdGhpcy5yZWZlcmVuY2VIYW5kbGVyKHByb3BlcnR5RGVzYykuaGFuZGxlTm9kZShub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIodHlwZSkuaGFuZGxlTm9kZShub2RlKTtcbiAgfVxuXG4gIHZhciBuZXdFbGVtZW50ID0gY2hpbGRIYW5kbGVyLmVsZW1lbnQ7XG5cbiAgLy8gY2hpbGQgaGFuZGxlcyBtYXkgZGVjaWRlIHRvIHNraXAgZWxlbWVudHNcbiAgLy8gYnkgbm90IHJldHVybmluZyBhbnl0aGluZ1xuICBpZiAobmV3RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICBpZiAocHJvcGVydHlEZXNjLmlzTWFueSkge1xuICAgICAgZWxlbWVudC5nZXQocHJvcGVydHlEZXNjLm5hbWUpLnB1c2gobmV3RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2V0KHByb3BlcnR5RGVzYy5uYW1lLCBuZXdFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHlEZXNjLmlzUmVmZXJlbmNlKSB7XG4gICAgICBhc3NpZ24obmV3RWxlbWVudCwge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jb250ZXh0LmFkZFJlZmVyZW5jZShuZXdFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBlc3RhYmxpc2ggY2hpbGQgLT4gcGFyZW50IHJlbGF0aW9uc2hpcFxuICAgICAgbmV3RWxlbWVudC4kcGFyZW50ID0gZWxlbWVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRIYW5kbGVyO1xufTtcblxuLyoqXG4gKiBBbiBlbGVtZW50IGhhbmRsZXIgdGhhdCBwZXJmb3JtcyBzcGVjaWFsIHZhbGlkYXRpb25cbiAqIHRvIGVuc3VyZSB0aGUgbm9kZSBpdCBnZXRzIGluaXRpYWxpemVkIHdpdGggbWF0Y2hlc1xuICogdGhlIGhhbmRsZXJzIHR5cGUgKG5hbWVzcGFjZSB3aXNlKS5cbiAqXG4gKiBAcGFyYW0ge01vZGRsZX0gbW9kZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlTmFtZVxuICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIFJvb3RFbGVtZW50SGFuZGxlcihtb2RlbCwgdHlwZU5hbWUsIGNvbnRleHQpIHtcbiAgRWxlbWVudEhhbmRsZXIuY2FsbCh0aGlzLCBtb2RlbCwgdHlwZU5hbWUsIGNvbnRleHQpO1xufVxuXG5Sb290RWxlbWVudEhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFbGVtZW50SGFuZGxlci5wcm90b3R5cGUpO1xuXG5Sb290RWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWUsXG4gICAgICBuYW1lTnMgPSBwYXJzZU5hbWVOUyhuYW1lKSxcbiAgICAgIG1vZGVsID0gdGhpcy5tb2RlbCxcbiAgICAgIHR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICBwa2cgPSBtb2RlbC5nZXRQYWNrYWdlKG5hbWVOcy5wcmVmaXgpLFxuICAgICAgdHlwZU5hbWUgPSBwa2cgJiYgYWxpYXNUb05hbWUobmFtZU5zLCBwa2cpIHx8IG5hbWU7XG5cbiAgLy8gdmVyaWZ5IHRoZSBjb3JyZWN0IG5hbWVzcGFjZSBpZiB3ZSBwYXJzZVxuICAvLyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgaGFuZGxlciB0cmVlXG4gIC8vXG4gIC8vIHRoaXMgZW5zdXJlcyB3ZSBkb24ndCBtaXN0YWtlbmx5IGltcG9ydCB3cm9uZyBuYW1lc3BhY2UgZWxlbWVudHNcbiAgaWYgKCF0eXBlLmhhc1R5cGUodHlwZU5hbWUpKSB7XG4gICAgdGhyb3cgZXJyb3IoJ3VuZXhwZWN0ZWQgZWxlbWVudCA8JyArIG5vZGUub3JpZ2luYWxOYW1lICsgJz4nKTtcbiAgfVxuXG4gIHJldHVybiBFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudC5jYWxsKHRoaXMsIG5vZGUpO1xufTtcblxuXG5mdW5jdGlvbiBHZW5lcmljRWxlbWVudEhhbmRsZXIobW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuR2VuZXJpY0VsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSk7XG5cbkdlbmVyaWNFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICB2YXIgbmFtZSA9IG5vZGUubmFtZSxcbiAgICAgIG5zID0gcGFyc2VOYW1lTlMobmFtZSksXG4gICAgICBwcmVmaXggPSBucy5wcmVmaXgsXG4gICAgICB1cmkgPSBub2RlLm5zW3ByZWZpeCArICckdXJpJ10sXG4gICAgICBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuXG4gIHJldHVybiB0aGlzLm1vZGVsLmNyZWF0ZUFueShuYW1lLCB1cmksIGF0dHJpYnV0ZXMpO1xufTtcblxuR2VuZXJpY0VsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVDaGlsZCA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICB2YXIgaGFuZGxlciA9IG5ldyBHZW5lcmljRWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgJ0VsZW1lbnQnLCB0aGlzLmNvbnRleHQpLmhhbmRsZU5vZGUobm9kZSksXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIHZhciBuZXdFbGVtZW50ID0gaGFuZGxlci5lbGVtZW50LFxuICAgICAgY2hpbGRyZW47XG5cbiAgaWYgKG5ld0VsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNoaWxkcmVuID0gZWxlbWVudC4kY2hpbGRyZW4gPSBlbGVtZW50LiRjaGlsZHJlbiB8fCBbXTtcbiAgICBjaGlsZHJlbi5wdXNoKG5ld0VsZW1lbnQpO1xuXG4gICAgLy8gZXN0YWJsaXNoIGNoaWxkIC0+IHBhcmVudCByZWxhdGlvbnNoaXBcbiAgICBuZXdFbGVtZW50LiRwYXJlbnQgPSBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXI7XG59O1xuXG5HZW5lcmljRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5ib2R5KSB7XG4gICAgdGhpcy5lbGVtZW50LiRib2R5ID0gdGhpcy5ib2R5O1xuICB9XG59O1xuXG4vKipcbiAqIEEgcmVhZGVyIGZvciBhIG1ldGEtbW9kZWxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtNb2RlbH0gb3B0aW9ucy5tb2RlbCB1c2VkIHRvIHJlYWQgeG1sIGZpbGVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubGF4IHdoZXRoZXIgdG8gbWFrZSBwYXJzZSBlcnJvcnMgd2FybmluZ3NcbiAqL1xuZnVuY3Rpb24gUmVhZGVyKG9wdGlvbnMpIHtcblxuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIE1vZGRsZSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBtb2RlbDogb3B0aW9uc1xuICAgIH07XG4gIH1cblxuICBhc3NpZ24odGhpcywgeyBsYXg6IGZhbHNlIH0sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFRoZSBmcm9tWE1MIHJlc3VsdC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJzZVJlc3VsdFxuICpcbiAqIEBwcm9wZXJ0eSB7TW9kZGxlRWxlbWVudH0gcm9vdEVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8T2JqZWN0Pn0gcmVmZXJlbmNlc1xuICogQHByb3BlcnR5IHtBcnJheTxFcnJvcj59IHdhcm5pbmdzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZWxlbWVudHNCeUlkIC0gYSBtYXBwaW5nIGNvbnRhaW5pbmcgZWFjaCBJRCAtPiBNb2RkbGVFbGVtZW50XG4gKi9cblxuLyoqXG4gKiBUaGUgZnJvbVhNTCByZXN1bHQuXG4gKlxuICogQHR5cGVkZWYge0Vycm9yfSBQYXJzZUVycm9yXG4gKlxuICogQHByb3BlcnR5IHtBcnJheTxFcnJvcj59IHdhcm5pbmdzXG4gKi9cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gWE1MIGludG8gYSBtb2RkbGUgZG9jdW1lbnQgdHJlZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30geG1sXG4gKiBAcGFyYW0ge0VsZW1lbnRIYW5kbGVyfE9iamVjdH0gb3B0aW9ucyBvciByb290SGFuZGxlclxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFBhcnNlUmVzdWx0LCBQYXJzZUVycm9yPn1cbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mcm9tWE1MID0gZnVuY3Rpb24oeG1sLCBvcHRpb25zLCBkb25lKSB7XG5cbiAgdmFyIHJvb3RIYW5kbGVyID0gb3B0aW9ucy5yb290SGFuZGxlcjtcblxuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEVsZW1lbnRIYW5kbGVyKSB7XG5cbiAgICAvLyByb290IGhhbmRsZXIgcGFzc2VkIHZpYSAoeG1sLCB7IHJvb3RIYW5kbGVyOiBFbGVtZW50SGFuZGxlciB9LCAuLi4pXG4gICAgcm9vdEhhbmRsZXIgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgIC8vIHJvb3RIYW5kbGVyIHBhc3NlZCB2aWEgKHhtbCwgJ3NvbWVTdHJpbmcnLCAuLi4pXG4gICAgICByb290SGFuZGxlciA9IHRoaXMuaGFuZGxlcihvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByb290SGFuZGxlciA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgLy8gcm9vdEhhbmRsZXIgcGFzc2VkIHZpYSAoeG1sLCB7IHJvb3RIYW5kbGVyOiAnc29tZVN0cmluZycgfSwgLi4uKVxuICAgICAgcm9vdEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIocm9vdEhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICBsYXggPSB0aGlzLmxheDtcblxuICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KGFzc2lnbih7fSwgb3B0aW9ucywgeyByb290SGFuZGxlcjogcm9vdEhhbmRsZXIgfSkpLFxuICAgICAgcGFyc2VyID0gbmV3IFBhcnNlcih7IHByb3h5OiB0cnVlIH0pLFxuICAgICAgc3RhY2sgPSBjcmVhdGVTdGFjaygpO1xuXG4gIHJvb3RIYW5kbGVyLmNvbnRleHQgPSBjb250ZXh0O1xuXG4gIC8vIHB1c2ggcm9vdCBoYW5kbGVyXG4gIHN0YWNrLnB1c2gocm9vdEhhbmRsZXIpO1xuXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtICB7RXJyb3J9IGVyclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZ2V0Q29udGV4dFxuICAgKiBAcGFyYW0gIHtib29sZWFufSBsYXhcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBoYW5kbGVkXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGdldENvbnRleHQsIGxheCkge1xuXG4gICAgdmFyIGN0eCA9IGdldENvbnRleHQoKTtcblxuICAgIHZhciBsaW5lID0gY3R4LmxpbmUsXG4gICAgICAgIGNvbHVtbiA9IGN0eC5jb2x1bW4sXG4gICAgICAgIGRhdGEgPSBjdHguZGF0YTtcblxuICAgIC8vIHdlIHJlY2VpdmUgdGhlIGZ1bGwgY29udGV4dCBkYXRhIGhlcmUsXG4gICAgLy8gZm9yIGVsZW1lbnRzIHRyaW0gZG93biB0aGUgaW5mb3JtYXRpb25cbiAgICAvLyB0byB0aGUgdGFnIG5hbWUsIG9ubHlcbiAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT09ICc8JyAmJiBkYXRhLmluZGV4T2YoJyAnKSAhPT0gLTEpIHtcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKDAsIGRhdGEuaW5kZXhPZignICcpKSArICc+JztcbiAgICB9XG5cbiAgICB2YXIgbWVzc2FnZSA9XG4gICAgICAndW5wYXJzYWJsZSBjb250ZW50ICcgKyAoZGF0YSA/IGRhdGEgKyAnICcgOiAnJykgKyAnZGV0ZWN0ZWRcXG5cXHQnICtcbiAgICAgICAgJ2xpbmU6ICcgKyBsaW5lICsgJ1xcblxcdCcgK1xuICAgICAgICAnY29sdW1uOiAnICsgY29sdW1uICsgJ1xcblxcdCcgK1xuICAgICAgICAnbmVzdGVkIGVycm9yOiAnICsgZXJyLm1lc3NhZ2U7XG5cbiAgICBpZiAobGF4KSB7XG4gICAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVdhcm5pbmcoZXJyLCBnZXRDb250ZXh0KSB7XG5cbiAgICAvLyBqdXN0IGxpa2UgaGFuZGxpbmcgZXJyb3JzIGluIDxsYXg9dHJ1ZT4gbW9kZVxuICAgIHJldHVybiBoYW5kbGVFcnJvcihlcnIsIGdldENvbnRleHQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgY29sbGVjdGVkIHJlZmVyZW5jZXMgb24gcGFyc2UgZW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZXMoKSB7XG5cbiAgICB2YXIgZWxlbWVudHNCeUlkID0gY29udGV4dC5lbGVtZW50c0J5SWQ7XG4gICAgdmFyIHJlZmVyZW5jZXMgPSBjb250ZXh0LnJlZmVyZW5jZXM7XG5cbiAgICB2YXIgaSwgcjtcblxuICAgIGZvciAoaSA9IDA7IChyID0gcmVmZXJlbmNlc1tpXSk7IGkrKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSByLmVsZW1lbnQ7XG4gICAgICB2YXIgcmVmZXJlbmNlID0gZWxlbWVudHNCeUlkW3IuaWRdO1xuICAgICAgdmFyIHByb3BlcnR5ID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KS5wcm9wZXJ0aWVzQnlOYW1lW3IucHJvcGVydHldO1xuXG4gICAgICBpZiAoIXJlZmVyZW5jZSkge1xuICAgICAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgICAgIG1lc3NhZ2U6ICd1bnJlc29sdmVkIHJlZmVyZW5jZSA8JyArIHIuaWQgKyAnPicsXG4gICAgICAgICAgZWxlbWVudDogci5lbGVtZW50LFxuICAgICAgICAgIHByb3BlcnR5OiByLnByb3BlcnR5LFxuICAgICAgICAgIHZhbHVlOiByLmlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHkuaXNNYW55KSB7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gZWxlbWVudC5nZXQocHJvcGVydHkubmFtZSksXG4gICAgICAgICAgICBpZHggPSBjb2xsZWN0aW9uLmluZGV4T2Yocik7XG5cbiAgICAgICAgLy8gd2UgcmVwbGFjZSBhbiBleGlzdGluZyBwbGFjZSBob2xkZXIgKGlkeCAhPSAtMSkgb3JcbiAgICAgICAgLy8gYXBwZW5kIHRvIHRoZSBjb2xsZWN0aW9uIGluc3RlYWRcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICBpZHggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmZXJlbmNlKSB7XG5cbiAgICAgICAgICAvLyByZW1vdmUgdW5yZXNvbHZhYmxlIHJlZmVyZW5jZVxuICAgICAgICAgIGNvbGxlY3Rpb24uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBhZGQgb3IgdXBkYXRlIHJlZmVyZW5jZSBpbiBjb2xsZWN0aW9uXG4gICAgICAgICAgY29sbGVjdGlvbltpZHhdID0gcmVmZXJlbmNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldChwcm9wZXJ0eS5uYW1lLCByZWZlcmVuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsb3NlKCkge1xuICAgIHN0YWNrLnBvcCgpLmhhbmRsZUVuZCgpO1xuICB9XG5cbiAgdmFyIFBSRUFNQkxFX1NUQVJUX1BBVFRFUk4gPSAvXjxcXD94bWwgL2k7XG5cbiAgdmFyIEVOQ09ESU5HX1BBVFRFUk4gPSAvIGVuY29kaW5nPVwiKFteXCJdKylcIi9pO1xuXG4gIHZhciBVVEZfOF9QQVRURVJOID0gL151dGYtOCQvaTtcblxuICBmdW5jdGlvbiBoYW5kbGVRdWVzdGlvbihxdWVzdGlvbikge1xuXG4gICAgaWYgKCFQUkVBTUJMRV9TVEFSVF9QQVRURVJOLnRlc3QocXVlc3Rpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gRU5DT0RJTkdfUEFUVEVSTi5leGVjKHF1ZXN0aW9uKTtcbiAgICB2YXIgZW5jb2RpbmcgPSBtYXRjaCAmJiBtYXRjaFsxXTtcblxuICAgIGlmICghZW5jb2RpbmcgfHwgVVRGXzhfUEFUVEVSTi50ZXN0KGVuY29kaW5nKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQuYWRkV2FybmluZyh7XG4gICAgICBtZXNzYWdlOlxuICAgICAgICAndW5zdXBwb3J0ZWQgZG9jdW1lbnQgZW5jb2RpbmcgPCcgKyBlbmNvZGluZyArICc+LCAnICtcbiAgICAgICAgJ2ZhbGxpbmcgYmFjayB0byBVVEYtOCdcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU9wZW4obm9kZSwgZ2V0Q29udGV4dCkge1xuICAgIHZhciBoYW5kbGVyID0gc3RhY2sucGVlaygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN0YWNrLnB1c2goaGFuZGxlci5oYW5kbGVOb2RlKG5vZGUpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcblxuICAgICAgaWYgKGhhbmRsZUVycm9yKGVyciwgZ2V0Q29udGV4dCwgbGF4KSkge1xuICAgICAgICBzdGFjay5wdXNoKG5ldyBOb29wSGFuZGxlcigpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDRGF0YSh0ZXh0LCBnZXRDb250ZXh0KSB7XG5cbiAgICB0cnkge1xuICAgICAgc3RhY2sucGVlaygpLmhhbmRsZVRleHQodGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBoYW5kbGVXYXJuaW5nKGVyciwgZ2V0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVGV4dCh0ZXh0LCBnZXRDb250ZXh0KSB7XG5cbiAgICAvLyBzdHJpcCB3aGl0ZXNwYWNlIG9ubHkgbm9kZXMsIGkuZS4gYmVmb3JlXG4gICAgLy8gPCFDREFUQVsgLi4uIF0+IHNlY3Rpb25zIGFuZCBpbiBiZXR3ZWVuIHRhZ3NcbiAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYW5kbGVDRGF0YSh0ZXh0LCBnZXRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciB1cmlNYXAgPSBtb2RlbC5nZXRQYWNrYWdlcygpLnJlZHVjZShmdW5jdGlvbih1cmlNYXAsIHApIHtcbiAgICB1cmlNYXBbcC51cmldID0gcC5wcmVmaXg7XG5cbiAgICByZXR1cm4gdXJpTWFwO1xuICB9LCB7XG4gICAgJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSc6ICd4bWwnIC8vIGFkZCBkZWZhdWx0IHhtbCBuc1xuICB9KTtcbiAgcGFyc2VyXG4gICAgLm5zKHVyaU1hcClcbiAgICAub24oJ29wZW5UYWcnLCBmdW5jdGlvbihvYmosIGRlY29kZVN0ciwgc2VsZkNsb3NpbmcsIGdldENvbnRleHQpIHtcblxuICAgICAgLy8gZ3JhY2VmdWxseSBoYW5kbGUgdW5wYXJzYWJsZSBhdHRyaWJ1dGVzIChhdHRycz1mYWxzZSlcbiAgICAgIHZhciBhdHRycyA9IG9iai5hdHRycyB8fCB7fTtcblxuICAgICAgdmFyIGRlY29kZWRBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKS5yZWR1Y2UoZnVuY3Rpb24oZCwga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRlY29kZVN0cihhdHRyc1trZXldKTtcblxuICAgICAgICBkW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgIG5hbWU6IG9iai5uYW1lLFxuICAgICAgICBvcmlnaW5hbE5hbWU6IG9iai5vcmlnaW5hbE5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGRlY29kZWRBdHRycyxcbiAgICAgICAgbnM6IG9iai5uc1xuICAgICAgfTtcblxuICAgICAgaGFuZGxlT3Blbihub2RlLCBnZXRDb250ZXh0KTtcbiAgICB9KVxuICAgIC5vbigncXVlc3Rpb24nLCBoYW5kbGVRdWVzdGlvbilcbiAgICAub24oJ2Nsb3NlVGFnJywgaGFuZGxlQ2xvc2UpXG4gICAgLm9uKCdjZGF0YScsIGhhbmRsZUNEYXRhKVxuICAgIC5vbigndGV4dCcsIGZ1bmN0aW9uKHRleHQsIGRlY29kZUVudGl0aWVzLCBnZXRDb250ZXh0KSB7XG4gICAgICBoYW5kbGVUZXh0KGRlY29kZUVudGl0aWVzKHRleHQpLCBnZXRDb250ZXh0KTtcbiAgICB9KVxuICAgIC5vbignZXJyb3InLCBoYW5kbGVFcnJvcilcbiAgICAub24oJ3dhcm4nLCBoYW5kbGVXYXJuaW5nKTtcblxuICAvLyBhc3luYyBYTUwgcGFyc2luZyB0byBtYWtlIHN1cmUgdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudFxuICAvLyAobm9kZSBvciBicm93ZXIpIGlzIGtlcHQgcmVzcG9uc2l2ZSBhbmQgdGhhdCBjZXJ0YWluIG9wdGltaXphdGlvblxuICAvLyBzdHJhdGVnaWVzIGNhbiBraWNrIGluLlxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICB2YXIgZXJyO1xuXG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlci5wYXJzZSh4bWwpO1xuXG4gICAgICByZXNvbHZlUmVmZXJlbmNlcygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuXG4gICAgdmFyIHJvb3RFbGVtZW50ID0gcm9vdEhhbmRsZXIuZWxlbWVudDtcblxuICAgIGlmICghZXJyICYmICFyb290RWxlbWVudCkge1xuICAgICAgZXJyID0gZXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBkb2N1bWVudCBhcyA8JyArIHJvb3RIYW5kbGVyLnR5cGUuJGRlc2NyaXB0b3IubmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdzID0gY29udGV4dC53YXJuaW5ncztcbiAgICB2YXIgcmVmZXJlbmNlcyA9IGNvbnRleHQucmVmZXJlbmNlcztcbiAgICB2YXIgZWxlbWVudHNCeUlkID0gY29udGV4dC5lbGVtZW50c0J5SWQ7XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnIud2FybmluZ3MgPSB3YXJuaW5ncztcblxuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgIHJvb3RFbGVtZW50OiByb290RWxlbWVudCxcbiAgICAgICAgZWxlbWVudHNCeUlkOiBlbGVtZW50c0J5SWQsXG4gICAgICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXMsXG4gICAgICAgIHdhcm5pbmdzOiB3YXJuaW5nc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cblJlYWRlci5wcm90b3R5cGUuaGFuZGxlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBSb290RWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgbmFtZSk7XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gY3JlYXRlU3RhY2soKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdGFjaywgJ3BlZWsnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzdGFjaztcbn1cblxudmFyIFhNTF9QUkVBTUJMRSA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz5cXG4nO1xuXG52YXIgRVNDQVBFX0FUVFJfQ0hBUlMgPSAvPHw+fCd8XCJ8JnxcXG5cXHJ8XFxuL2c7XG52YXIgRVNDQVBFX0NIQVJTID0gLzx8PnwmL2c7XG5cblxuZnVuY3Rpb24gTmFtZXNwYWNlcyhwYXJlbnQpIHtcblxuICB2YXIgcHJlZml4TWFwID0ge307XG4gIHZhciB1cmlNYXAgPSB7fTtcbiAgdmFyIHVzZWQgPSB7fTtcblxuICB2YXIgd2VsbGtub3duID0gW107XG4gIHZhciBjdXN0b20gPSBbXTtcblxuICAvLyBBUElcblxuICB0aGlzLmJ5VXJpID0gZnVuY3Rpb24odXJpKSB7XG4gICAgcmV0dXJuIHVyaU1hcFt1cmldIHx8IChcbiAgICAgIHBhcmVudCAmJiBwYXJlbnQuYnlVcmkodXJpKVxuICAgICk7XG4gIH07XG5cbiAgdGhpcy5hZGQgPSBmdW5jdGlvbihucywgaXNXZWxsa25vd24pIHtcblxuICAgIHVyaU1hcFtucy51cmldID0gbnM7XG5cbiAgICBpZiAoaXNXZWxsa25vd24pIHtcbiAgICAgIHdlbGxrbm93bi5wdXNoKG5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tLnB1c2gobnMpO1xuICAgIH1cblxuICAgIHRoaXMubWFwUHJlZml4KG5zLnByZWZpeCwgbnMudXJpKTtcbiAgfTtcblxuICB0aGlzLnVyaUJ5UHJlZml4ID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgcmV0dXJuIHByZWZpeE1hcFtwcmVmaXggfHwgJ3htbG5zJ107XG4gIH07XG5cbiAgdGhpcy5tYXBQcmVmaXggPSBmdW5jdGlvbihwcmVmaXgsIHVyaSkge1xuICAgIHByZWZpeE1hcFtwcmVmaXggfHwgJ3htbG5zJ10gPSB1cmk7XG4gIH07XG5cbiAgdGhpcy5nZXROU0tleSA9IGZ1bmN0aW9uKG5zKSB7XG4gICAgcmV0dXJuIChucy5wcmVmaXggIT09IHVuZGVmaW5lZCkgPyAobnMudXJpICsgJ3wnICsgbnMucHJlZml4KSA6IG5zLnVyaTtcbiAgfTtcblxuICB0aGlzLmxvZ1VzZWQgPSBmdW5jdGlvbihucykge1xuXG4gICAgdmFyIHVyaSA9IG5zLnVyaTtcbiAgICB2YXIgbnNLZXkgPSB0aGlzLmdldE5TS2V5KG5zKTtcblxuICAgIHVzZWRbbnNLZXldID0gdGhpcy5ieVVyaSh1cmkpO1xuXG4gICAgLy8gSW5mb3JtIHBhcmVudCByZWN1cnNpdmVseSBhYm91dCB0aGUgdXNhZ2Ugb2YgdGhpcyBOU1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5sb2dVc2VkKG5zKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5nZXRVc2VkID0gZnVuY3Rpb24obnMpIHtcblxuICAgIGZ1bmN0aW9uIGlzVXNlZChucykge1xuICAgICAgdmFyIG5zS2V5ID0gc2VsZi5nZXROU0tleShucyk7XG5cbiAgICAgIHJldHVybiB1c2VkW25zS2V5XTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgYWxsTnMgPSBbXS5jb25jYXQod2VsbGtub3duLCBjdXN0b20pO1xuXG4gICAgcmV0dXJuIGFsbE5zLmZpbHRlcihpc1VzZWQpO1xuICB9O1xuXG59XG5cbmZ1bmN0aW9uIGxvd2VyKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG5mdW5jdGlvbiBuYW1lVG9BbGlhcyhuYW1lLCBwa2cpIHtcbiAgaWYgKGhhc0xvd2VyQ2FzZUFsaWFzKHBrZykpIHtcbiAgICByZXR1cm4gbG93ZXIobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogY3RvcixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBuc05hbWUobnMpIHtcbiAgaWYgKGlzU3RyaW5nKG5zKSkge1xuICAgIHJldHVybiBucztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKG5zLnByZWZpeCA/IG5zLnByZWZpeCArICc6JyA6ICcnKSArIG5zLmxvY2FsTmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROc0F0dHJzKG5hbWVzcGFjZXMpIHtcblxuICByZXR1cm4gbWFwKG5hbWVzcGFjZXMuZ2V0VXNlZCgpLCBmdW5jdGlvbihucykge1xuICAgIHZhciBuYW1lID0gJ3htbG5zJyArIChucy5wcmVmaXggPyAnOicgKyBucy5wcmVmaXggOiAnJyk7XG4gICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgdmFsdWU6IG5zLnVyaSB9O1xuICB9KTtcblxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50TnMobnMsIGRlc2NyaXB0b3IpIHtcbiAgaWYgKGRlc2NyaXB0b3IuaXNHZW5lcmljKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7IGxvY2FsTmFtZTogZGVzY3JpcHRvci5ucy5sb2NhbE5hbWUgfSwgbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NpZ24oeyBsb2NhbE5hbWU6IG5hbWVUb0FsaWFzKGRlc2NyaXB0b3IubnMubG9jYWxOYW1lLCBkZXNjcmlwdG9yLiRwa2cpIH0sIG5zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eU5zKG5zLCBkZXNjcmlwdG9yKSB7XG4gIHJldHVybiBhc3NpZ24oeyBsb2NhbE5hbWU6IGRlc2NyaXB0b3IubnMubG9jYWxOYW1lIH0sIG5zKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VyaWFsaXphYmxlUHJvcGVydGllcyhlbGVtZW50KSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC4kZGVzY3JpcHRvcjtcblxuICByZXR1cm4gZmlsdGVyKGRlc2NyaXB0b3IucHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgIHZhciBuYW1lID0gcC5uYW1lO1xuXG4gICAgaWYgKHAuaXNWaXJ0dWFsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZG8gbm90IHNlcmlhbGl6ZSBkZWZhdWx0c1xuICAgIGlmICghaGFzKGVsZW1lbnQsIG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gZWxlbWVudFtuYW1lXTtcblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgZGVmYXVsdCBlcXVhbHNcbiAgICBpZiAodmFsdWUgPT09IHAuZGVmYXVsdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgbnVsbCBwcm9wZXJ0aWVzXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAuaXNNYW55ID8gdmFsdWUubGVuZ3RoIDogdHJ1ZTtcbiAgfSk7XG59XG5cbnZhciBFU0NBUEVfQVRUUl9NQVAgPSB7XG4gICdcXG4nOiAnIzEwJyxcbiAgJ1xcblxccic6ICcjMTAnLFxuICAnXCInOiAnIzM0JyxcbiAgJ1xcJyc6ICcjMzknLFxuICAnPCc6ICcjNjAnLFxuICAnPic6ICcjNjInLFxuICAnJic6ICcjMzgnXG59O1xuXG52YXIgRVNDQVBFX01BUCA9IHtcbiAgJzwnOiAnbHQnLFxuICAnPic6ICdndCcsXG4gICcmJzogJ2FtcCdcbn07XG5cbmZ1bmN0aW9uIGVzY2FwZShzdHIsIGNoYXJQYXR0ZXJuLCByZXBsYWNlTWFwKSB7XG5cbiAgLy8gZW5zdXJlIHdlIGFyZSBoYW5kbGluZyBzdHJpbmdzIGhlcmVcbiAgc3RyID0gaXNTdHJpbmcoc3RyKSA/IHN0ciA6ICcnICsgc3RyO1xuXG4gIHJldHVybiBzdHIucmVwbGFjZShjaGFyUGF0dGVybiwgZnVuY3Rpb24ocykge1xuICAgIHJldHVybiAnJicgKyByZXBsYWNlTWFwW3NdICsgJzsnO1xuICB9KTtcbn1cblxuLyoqXG4gKiBFc2NhcGUgYSBzdHJpbmcgYXR0cmlidXRlIHRvIG5vdCBjb250YWluIGFueSBiYWQgdmFsdWVzIChsaW5lIGJyZWFrcywgJ1wiJywgLi4uKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlc2NhcGVcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGVzY2FwZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUF0dHIoc3RyKSB7XG4gIHJldHVybiBlc2NhcGUoc3RyLCBFU0NBUEVfQVRUUl9DSEFSUywgRVNDQVBFX0FUVFJfTUFQKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlQm9keShzdHIpIHtcbiAgcmV0dXJuIGVzY2FwZShzdHIsIEVTQ0FQRV9DSEFSUywgRVNDQVBFX01BUCk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckF0dHJpYnV0ZXMocHJvcHMpIHtcbiAgcmV0dXJuIGZpbHRlcihwcm9wcywgZnVuY3Rpb24ocCkgeyByZXR1cm4gcC5pc0F0dHI7IH0pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJDb250YWluZWQocHJvcHMpIHtcbiAgcmV0dXJuIGZpbHRlcihwcm9wcywgZnVuY3Rpb24ocCkgeyByZXR1cm4gIXAuaXNBdHRyOyB9KTtcbn1cblxuXG5mdW5jdGlvbiBSZWZlcmVuY2VTZXJpYWxpemVyKHRhZ05hbWUpIHtcbiAgdGhpcy50YWdOYW1lID0gdGFnTmFtZTtcbn1cblxuUmVmZXJlbmNlU2VyaWFsaXplci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVmZXJlbmNlU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG8gPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgd3JpdGVyXG4gICAgLmFwcGVuZEluZGVudCgpXG4gICAgLmFwcGVuZCgnPCcgKyB0aGlzLnRhZ05hbWUgKyAnPicgKyB0aGlzLmVsZW1lbnQuaWQgKyAnPC8nICsgdGhpcy50YWdOYW1lICsgJz4nKVxuICAgIC5hcHBlbmROZXdMaW5lKCk7XG59O1xuXG5mdW5jdGlvbiBCb2R5U2VyaWFsaXplcigpIHt9XG5cbkJvZHlTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVWYWx1ZSA9XG5Cb2R5U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG8gPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgd3JpdGVyLmFwcGVuZChcbiAgICB0aGlzLmVzY2FwZVxuICAgICAgPyBlc2NhcGVCb2R5KHRoaXMudmFsdWUpXG4gICAgICA6IHRoaXMudmFsdWVcbiAgKTtcbn07XG5cbkJvZHlTZXJpYWxpemVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBpZiAocHJvcC50eXBlID09PSAnU3RyaW5nJyAmJiB2YWx1ZS5zZWFyY2goRVNDQVBFX0NIQVJTKSAhPT0gLTEpIHtcbiAgICB0aGlzLmVzY2FwZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIFZhbHVlU2VyaWFsaXplcih0YWdOYW1lKSB7XG4gIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG59XG5cbmluaGVyaXRzKFZhbHVlU2VyaWFsaXplciwgQm9keVNlcmlhbGl6ZXIpO1xuXG5WYWx1ZVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvID0gZnVuY3Rpb24od3JpdGVyKSB7XG5cbiAgd3JpdGVyXG4gICAgLmFwcGVuZEluZGVudCgpXG4gICAgLmFwcGVuZCgnPCcgKyB0aGlzLnRhZ05hbWUgKyAnPicpO1xuXG4gIHRoaXMuc2VyaWFsaXplVmFsdWUod3JpdGVyKTtcblxuICB3cml0ZXJcbiAgICAuYXBwZW5kKCc8LycgKyB0aGlzLnRhZ05hbWUgKyAnPicpXG4gICAgLmFwcGVuZE5ld0xpbmUoKTtcbn07XG5cbmZ1bmN0aW9uIEVsZW1lbnRTZXJpYWxpemVyKHBhcmVudCwgcHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gIHRoaXMuYm9keSA9IFtdO1xuICB0aGlzLmF0dHJzID0gW107XG5cbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMucHJvcGVydHlEZXNjcmlwdG9yID0gcHJvcGVydHlEZXNjcmlwdG9yO1xufVxuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgdmFyIGVsZW1lbnREZXNjcmlwdG9yID0gZWxlbWVudC4kZGVzY3JpcHRvcixcbiAgICAgIHByb3BlcnR5RGVzY3JpcHRvciA9IHRoaXMucHJvcGVydHlEZXNjcmlwdG9yO1xuXG4gIHZhciBvdGhlckF0dHJzLFxuICAgICAgcHJvcGVydGllcztcblxuICB2YXIgaXNHZW5lcmljID0gZWxlbWVudERlc2NyaXB0b3IuaXNHZW5lcmljO1xuXG4gIGlmIChpc0dlbmVyaWMpIHtcbiAgICBvdGhlckF0dHJzID0gdGhpcy5wYXJzZUdlbmVyaWMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgb3RoZXJBdHRycyA9IHRoaXMucGFyc2VOc0F0dHJpYnV0ZXMoZWxlbWVudCk7XG4gIH1cblxuICBpZiAocHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gICAgdGhpcy5ucyA9IHRoaXMubnNQcm9wZXJ0eVRhZ05hbWUocHJvcGVydHlEZXNjcmlwdG9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5zID0gdGhpcy5uc1RhZ05hbWUoZWxlbWVudERlc2NyaXB0b3IpO1xuICB9XG5cbiAgLy8gY29tcHV0ZSB0YWcgbmFtZVxuICB0aGlzLnRhZ05hbWUgPSB0aGlzLmFkZFRhZ05hbWUodGhpcy5ucyk7XG5cbiAgaWYgKCFpc0dlbmVyaWMpIHtcbiAgICBwcm9wZXJ0aWVzID0gZ2V0U2VyaWFsaXphYmxlUHJvcGVydGllcyhlbGVtZW50KTtcblxuICAgIHRoaXMucGFyc2VBdHRyaWJ1dGVzKGZpbHRlckF0dHJpYnV0ZXMocHJvcGVydGllcykpO1xuICAgIHRoaXMucGFyc2VDb250YWlubWVudHMoZmlsdGVyQ29udGFpbmVkKHByb3BlcnRpZXMpKTtcbiAgfVxuXG4gIHRoaXMucGFyc2VHZW5lcmljQXR0cmlidXRlcyhlbGVtZW50LCBvdGhlckF0dHJzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5uc1RhZ05hbWUgPSBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG4gIHZhciBlZmZlY3RpdmVOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChkZXNjcmlwdG9yLm5zKTtcbiAgcmV0dXJuIGdldEVsZW1lbnROcyhlZmZlY3RpdmVOcywgZGVzY3JpcHRvcik7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUubnNQcm9wZXJ0eVRhZ05hbWUgPSBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG4gIHZhciBlZmZlY3RpdmVOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChkZXNjcmlwdG9yLm5zKTtcbiAgcmV0dXJuIGdldFByb3BlcnR5TnMoZWZmZWN0aXZlTnMsIGRlc2NyaXB0b3IpO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmlzTG9jYWxOcyA9IGZ1bmN0aW9uKG5zKSB7XG4gIHJldHVybiBucy51cmkgPT09IHRoaXMubnMudXJpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFjdHVhbCBucyBhdHRyaWJ1dGUgbmFtZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VsZW1lbnQuaW5oZXJpdGVkPWZhbHNlXVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gbnNOYW1lXG4gKi9cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5uc0F0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgdmFyIG5zO1xuXG4gIGlmIChpc1N0cmluZyhlbGVtZW50KSkge1xuICAgIG5zID0gcGFyc2VOYW1lTlMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgbnMgPSBlbGVtZW50Lm5zO1xuICB9XG5cbiAgLy8gcmV0dXJuIGp1c3QgbG9jYWwgbmFtZSBmb3IgaW5oZXJpdGVkIGF0dHJpYnV0ZXNcbiAgaWYgKGVsZW1lbnQuaW5oZXJpdGVkKSB7XG4gICAgcmV0dXJuIHsgbG9jYWxOYW1lOiBucy5sb2NhbE5hbWUgfTtcbiAgfVxuXG4gIC8vIHBhcnNlICsgbG9nIGVmZmVjdGl2ZSBuc1xuICB2YXIgZWZmZWN0aXZlTnMgPSB0aGlzLmxvZ05hbWVzcGFjZVVzZWQobnMpO1xuXG4gIC8vIExPRyBBQ1RVQUwgbmFtZXNwYWNlIHVzZVxuICB0aGlzLmdldE5hbWVzcGFjZXMoKS5sb2dVc2VkKGVmZmVjdGl2ZU5zKTtcblxuICAvLyBzdHJpcCBwcmVmaXggaWYgc2FtZSBuYW1lc3BhY2UgbGlrZSBwYXJlbnRcbiAgaWYgKHRoaXMuaXNMb2NhbE5zKGVmZmVjdGl2ZU5zKSkge1xuICAgIHJldHVybiB7IGxvY2FsTmFtZTogbnMubG9jYWxOYW1lIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzc2lnbih7IGxvY2FsTmFtZTogbnMubG9jYWxOYW1lIH0sIGVmZmVjdGl2ZU5zKTtcbiAgfVxufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlR2VuZXJpYyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBib2R5ID0gdGhpcy5ib2R5O1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gW107XG5cbiAgZm9yRWFjaChlbGVtZW50LCBmdW5jdGlvbih2YWwsIGtleSkge1xuXG4gICAgdmFyIG5vbk5zQXR0cjtcblxuICAgIGlmIChrZXkgPT09ICckYm9keScpIHtcbiAgICAgIGJvZHkucHVzaChuZXcgQm9keVNlcmlhbGl6ZXIoKS5idWlsZCh7IHR5cGU6ICdTdHJpbmcnIH0sIHZhbCkpO1xuICAgIH0gZWxzZVxuICAgIGlmIChrZXkgPT09ICckY2hpbGRyZW4nKSB7XG4gICAgICBmb3JFYWNoKHZhbCwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgYm9keS5wdXNoKG5ldyBFbGVtZW50U2VyaWFsaXplcihzZWxmKS5idWlsZChjaGlsZCkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlXG4gICAgaWYgKGtleS5pbmRleE9mKCckJykgIT09IDApIHtcbiAgICAgIG5vbk5zQXR0ciA9IHNlbGYucGFyc2VOc0F0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbCk7XG5cbiAgICAgIGlmIChub25Oc0F0dHIpIHtcbiAgICAgICAgYXR0cmlidXRlcy5wdXNoKHsgbmFtZToga2V5LCB2YWx1ZTogdmFsIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBtb2RlbCA9IGVsZW1lbnQuJG1vZGVsO1xuXG4gIHZhciBuYW1lTnMgPSBwYXJzZU5hbWVOUyhuYW1lKTtcblxuICB2YXIgbnM7XG5cbiAgLy8gcGFyc2UgeG1sbnM6Zm9vPVwiaHR0cDovL2Zvby5iYXJcIlxuICBpZiAobmFtZU5zLnByZWZpeCA9PT0gJ3htbG5zJykge1xuICAgIG5zID0geyBwcmVmaXg6IG5hbWVOcy5sb2NhbE5hbWUsIHVyaTogdmFsdWUgfTtcbiAgfVxuXG4gIC8vIHBhcnNlIHhtbG5zPVwiaHR0cDovL2Zvby5iYXJcIlxuICBpZiAoIW5hbWVOcy5wcmVmaXggJiYgbmFtZU5zLmxvY2FsTmFtZSA9PT0gJ3htbG5zJykge1xuICAgIG5zID0geyB1cmk6IHZhbHVlIH07XG4gIH1cblxuICBpZiAoIW5zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKG1vZGVsICYmIG1vZGVsLmdldFBhY2thZ2UodmFsdWUpKSB7XG5cbiAgICAvLyByZWdpc3RlciB3ZWxsIGtub3duIG5hbWVzcGFjZVxuICAgIHRoaXMubG9nTmFtZXNwYWNlKG5zLCB0cnVlLCB0cnVlKTtcbiAgfSBlbHNlIHtcblxuICAgIC8vIGxvZyBjdXN0b20gbmFtZXNwYWNlIGRpcmVjdGx5IGFzIHVzZWRcbiAgICB2YXIgYWN0dWFsTnMgPSB0aGlzLmxvZ05hbWVzcGFjZVVzZWQobnMsIHRydWUpO1xuXG4gICAgdGhpcy5nZXROYW1lc3BhY2VzKCkubG9nVXNlZChhY3R1YWxOcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQYXJzZSBuYW1lc3BhY2VzIGFuZCByZXR1cm4gYSBsaXN0IG9mIGxlZnQgb3ZlciBnZW5lcmljIGF0dHJpYnV0ZXNcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGVsZW1lbnRcbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59XG4gKi9cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZU5zQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgZ2VuZXJpY0F0dHJzID0gZWxlbWVudC4kYXR0cnM7XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcblxuICAvLyBwYXJzZSBuYW1lc3BhY2UgYXR0cmlidXRlcyBmaXJzdFxuICAvLyBhbmQgbG9nIHRoZW0uIHB1c2ggbm9uIG5hbWVzcGFjZSBhdHRyaWJ1dGVzIHRvIGEgbGlzdFxuICAvLyBhbmQgcHJvY2VzcyB0aGVtIGxhdGVyXG4gIGZvckVhY2goZ2VuZXJpY0F0dHJzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXG4gICAgdmFyIG5vbk5zQXR0ciA9IHNlbGYucGFyc2VOc0F0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG5cbiAgICBpZiAobm9uTnNBdHRyKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gobm9uTnNBdHRyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlR2VuZXJpY0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZvckVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cikge1xuXG4gICAgLy8gZG8gbm90IHNlcmlhbGl6ZSB4c2k6dHlwZSBhdHRyaWJ1dGVcbiAgICAvLyBpdCBpcyBzZXQgbWFudWFsbHkgYmFzZWQgb24gdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiB0eXBlXG4gICAgaWYgKGF0dHIubmFtZSA9PT0gWFNJX1RZUEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2VsZi5hZGRBdHRyaWJ1dGUoc2VsZi5uc0F0dHJpYnV0ZU5hbWUoYXR0ci5uYW1lKSwgYXR0ci52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnbWlzc2luZyBuYW1lc3BhY2UgaW5mb3JtYXRpb24gZm9yICcsXG4gICAgICAgIGF0dHIubmFtZSwgJz0nLCBhdHRyLnZhbHVlLCAnb24nLCBlbGVtZW50LFxuICAgICAgICBlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlQ29udGFpbm1lbnRzID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuXG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGJvZHkgPSB0aGlzLmJvZHksXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQuZ2V0KHAubmFtZSksXG4gICAgICAgIGlzUmVmZXJlbmNlID0gcC5pc1JlZmVyZW5jZSxcbiAgICAgICAgaXNNYW55ID0gcC5pc01hbnk7XG5cbiAgICBpZiAoIWlzTWFueSkge1xuICAgICAgdmFsdWUgPSBbIHZhbHVlIF07XG4gICAgfVxuXG4gICAgaWYgKHAuaXNCb2R5KSB7XG4gICAgICBib2R5LnB1c2gobmV3IEJvZHlTZXJpYWxpemVyKCkuYnVpbGQocCwgdmFsdWVbMF0pKTtcbiAgICB9IGVsc2VcbiAgICBpZiAoaXNTaW1wbGVUeXBlKHAudHlwZSkpIHtcbiAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgYm9keS5wdXNoKG5ldyBWYWx1ZVNlcmlhbGl6ZXIoc2VsZi5hZGRUYWdOYW1lKHNlbGYubnNQcm9wZXJ0eVRhZ05hbWUocCkpKS5idWlsZChwLCB2KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICBpZiAoaXNSZWZlcmVuY2UpIHtcbiAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgYm9keS5wdXNoKG5ldyBSZWZlcmVuY2VTZXJpYWxpemVyKHNlbGYuYWRkVGFnTmFtZShzZWxmLm5zUHJvcGVydHlUYWdOYW1lKHApKSkuYnVpbGQodikpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gYWxsb3cgc2VyaWFsaXphdGlvbiB2aWEgdHlwZVxuICAgICAgLy8gcmF0aGVyIHRoYW4gZWxlbWVudCBuYW1lXG4gICAgICB2YXIgYXNUeXBlID0gc2VyaWFsaXplQXNUeXBlKHApLFxuICAgICAgICAgIGFzUHJvcGVydHkgPSBzZXJpYWxpemVBc1Byb3BlcnR5KHApO1xuXG4gICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVyO1xuXG4gICAgICAgIGlmIChhc1R5cGUpIHtcbiAgICAgICAgICBzZXJpYWxpemVyID0gbmV3IFR5cGVTZXJpYWxpemVyKHNlbGYsIHApO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgaWYgKGFzUHJvcGVydHkpIHtcbiAgICAgICAgICBzZXJpYWxpemVyID0gbmV3IEVsZW1lbnRTZXJpYWxpemVyKHNlbGYsIHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlcmlhbGl6ZXIgPSBuZXcgRWxlbWVudFNlcmlhbGl6ZXIoc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5LnB1c2goc2VyaWFsaXplci5idWlsZCh2KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmdldE5hbWVzcGFjZXMgPSBmdW5jdGlvbihsb2NhbCkge1xuXG4gIHZhciBuYW1lc3BhY2VzID0gdGhpcy5uYW1lc3BhY2VzLFxuICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICBwYXJlbnROYW1lc3BhY2VzO1xuXG4gIGlmICghbmFtZXNwYWNlcykge1xuICAgIHBhcmVudE5hbWVzcGFjZXMgPSBwYXJlbnQgJiYgcGFyZW50LmdldE5hbWVzcGFjZXMoKTtcblxuICAgIGlmIChsb2NhbCB8fCAhcGFyZW50TmFtZXNwYWNlcykge1xuICAgICAgdGhpcy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcyA9IG5ldyBOYW1lc3BhY2VzKHBhcmVudE5hbWVzcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lc3BhY2VzID0gcGFyZW50TmFtZXNwYWNlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZXNwYWNlcztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5sb2dOYW1lc3BhY2UgPSBmdW5jdGlvbihucywgd2VsbGtub3duLCBsb2NhbCkge1xuICB2YXIgbmFtZXNwYWNlcyA9IHRoaXMuZ2V0TmFtZXNwYWNlcyhsb2NhbCk7XG5cbiAgdmFyIG5zVXJpID0gbnMudXJpLFxuICAgICAgbnNQcmVmaXggPSBucy5wcmVmaXg7XG5cbiAgdmFyIGV4aXN0aW5nID0gbmFtZXNwYWNlcy5ieVVyaShuc1VyaSk7XG5cbiAgaWYgKG5zUHJlZml4ICE9PSAneG1sJyAmJiAoIWV4aXN0aW5nIHx8IGxvY2FsKSkge1xuICAgIG5hbWVzcGFjZXMuYWRkKG5zLCB3ZWxsa25vd24pO1xuICB9XG5cbiAgbmFtZXNwYWNlcy5tYXBQcmVmaXgobnNQcmVmaXgsIG5zVXJpKTtcblxuICByZXR1cm4gbnM7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUubG9nTmFtZXNwYWNlVXNlZCA9IGZ1bmN0aW9uKG5zLCBsb2NhbCkge1xuICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG1vZGVsID0gZWxlbWVudC4kbW9kZWwsXG4gICAgICBuYW1lc3BhY2VzID0gdGhpcy5nZXROYW1lc3BhY2VzKGxvY2FsKTtcblxuICAvLyBucyBtYXkgYmVcbiAgLy9cbiAgLy8gICAqIHByZWZpeCBvbmx5XG4gIC8vICAgKiBwcmVmaXg6dXJpXG4gIC8vICAgKiBsb2NhbE5hbWUgb25seVxuXG4gIHZhciBwcmVmaXggPSBucy5wcmVmaXgsXG4gICAgICB1cmkgPSBucy51cmksXG4gICAgICBuZXdQcmVmaXgsIGlkeCxcbiAgICAgIHdlbGxrbm93blVyaTtcblxuICAvLyBoYW5kbGUgYW5vbnltb3VzIG5hbWVzcGFjZXMgKGVsZW1lbnRGb3JtPXVucXVhbGlmaWVkKSwgY2YuICMyM1xuICBpZiAoIXByZWZpeCAmJiAhdXJpKSB7XG4gICAgcmV0dXJuIHsgbG9jYWxOYW1lOiBucy5sb2NhbE5hbWUgfTtcbiAgfVxuXG4gIHdlbGxrbm93blVyaSA9IERFRkFVTFRfTlNfTUFQW3ByZWZpeF0gfHwgbW9kZWwgJiYgKG1vZGVsLmdldFBhY2thZ2UocHJlZml4KSB8fCB7fSkudXJpO1xuXG4gIHVyaSA9IHVyaSB8fCB3ZWxsa25vd25VcmkgfHwgbmFtZXNwYWNlcy51cmlCeVByZWZpeChwcmVmaXgpO1xuXG4gIGlmICghdXJpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdubyBuYW1lc3BhY2UgdXJpIGdpdmVuIGZvciBwcmVmaXggPCcgKyBwcmVmaXggKyAnPicpO1xuICB9XG5cbiAgbnMgPSBuYW1lc3BhY2VzLmJ5VXJpKHVyaSk7XG5cbiAgaWYgKCFucykge1xuICAgIG5ld1ByZWZpeCA9IHByZWZpeDtcbiAgICBpZHggPSAxO1xuXG4gICAgLy8gZmluZCBhIHByZWZpeCB0aGF0IGlzIG5vdCBtYXBwZWQgeWV0XG4gICAgd2hpbGUgKG5hbWVzcGFjZXMudXJpQnlQcmVmaXgobmV3UHJlZml4KSkge1xuICAgICAgbmV3UHJlZml4ID0gcHJlZml4ICsgJ18nICsgaWR4Kys7XG4gICAgfVxuXG4gICAgbnMgPSB0aGlzLmxvZ05hbWVzcGFjZSh7IHByZWZpeDogbmV3UHJlZml4LCB1cmk6IHVyaSB9LCB3ZWxsa25vd25VcmkgPT09IHVyaSk7XG4gIH1cblxuICBpZiAocHJlZml4KSB7XG4gICAgbmFtZXNwYWNlcy5tYXBQcmVmaXgocHJlZml4LCB1cmkpO1xuICB9XG5cbiAgcmV0dXJuIG5zO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlQXR0cmlidXRlcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICBmb3JFYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcblxuICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQuZ2V0KHAubmFtZSk7XG5cbiAgICBpZiAocC5pc1JlZmVyZW5jZSkge1xuXG4gICAgICBpZiAoIXAuaXNNYW55KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuaWQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2godi5pZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElEUkVGUyBpcyBhIHdoaXRlc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgcmVmZXJlbmNlcy5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZXMuam9pbignICcpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgc2VsZi5hZGRBdHRyaWJ1dGUoc2VsZi5uc0F0dHJpYnV0ZU5hbWUocCksIHZhbHVlKTtcbiAgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuYWRkVGFnTmFtZSA9IGZ1bmN0aW9uKG5zVGFnTmFtZSkge1xuICB2YXIgYWN0dWFsTnMgPSB0aGlzLmxvZ05hbWVzcGFjZVVzZWQobnNUYWdOYW1lKTtcblxuICB0aGlzLmdldE5hbWVzcGFjZXMoKS5sb2dVc2VkKGFjdHVhbE5zKTtcblxuICByZXR1cm4gbnNOYW1lKG5zVGFnTmFtZSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGF0dHJzID0gdGhpcy5hdHRycztcblxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBlc2NhcGVBdHRyKHZhbHVlKTtcbiAgfVxuXG4gIGF0dHJzLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB2YXIgYXR0cnMgPSB0aGlzLmF0dHJzLFxuICAgICAgbmFtZXNwYWNlcyA9IHRoaXMubmFtZXNwYWNlcztcblxuICBpZiAobmFtZXNwYWNlcykge1xuICAgIGF0dHJzID0gZ2V0TnNBdHRycyhuYW1lc3BhY2VzKS5jb25jYXQoYXR0cnMpO1xuICB9XG5cbiAgZm9yRWFjaChhdHRycywgZnVuY3Rpb24oYSkge1xuICAgIHdyaXRlclxuICAgICAgLmFwcGVuZCgnICcpXG4gICAgICAuYXBwZW5kKG5zTmFtZShhLm5hbWUpKS5hcHBlbmQoJz1cIicpLmFwcGVuZChhLnZhbHVlKS5hcHBlbmQoJ1wiJyk7XG4gIH0pO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHZhciBmaXJzdEJvZHkgPSB0aGlzLmJvZHlbMF0sXG4gICAgICBpbmRlbnQgPSBmaXJzdEJvZHkgJiYgZmlyc3RCb2R5LmNvbnN0cnVjdG9yICE9PSBCb2R5U2VyaWFsaXplcjtcblxuICB3cml0ZXJcbiAgICAuYXBwZW5kSW5kZW50KClcbiAgICAuYXBwZW5kKCc8JyArIHRoaXMudGFnTmFtZSk7XG5cbiAgdGhpcy5zZXJpYWxpemVBdHRyaWJ1dGVzKHdyaXRlcik7XG5cbiAgd3JpdGVyLmFwcGVuZChmaXJzdEJvZHkgPyAnPicgOiAnIC8+Jyk7XG5cbiAgaWYgKGZpcnN0Qm9keSkge1xuXG4gICAgaWYgKGluZGVudCkge1xuICAgICAgd3JpdGVyXG4gICAgICAgIC5hcHBlbmROZXdMaW5lKClcbiAgICAgICAgLmluZGVudCgpO1xuICAgIH1cblxuICAgIGZvckVhY2godGhpcy5ib2R5LCBmdW5jdGlvbihiKSB7XG4gICAgICBiLnNlcmlhbGl6ZVRvKHdyaXRlcik7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5kZW50KSB7XG4gICAgICB3cml0ZXJcbiAgICAgICAgLnVuaW5kZW50KClcbiAgICAgICAgLmFwcGVuZEluZGVudCgpO1xuICAgIH1cblxuICAgIHdyaXRlci5hcHBlbmQoJzwvJyArIHRoaXMudGFnTmFtZSArICc+Jyk7XG4gIH1cblxuICB3cml0ZXIuYXBwZW5kTmV3TGluZSgpO1xufTtcblxuLyoqXG4gKiBBIHNlcmlhbGl6ZXIgZm9yIHR5cGVzIHRoYXQgaGFuZGxlcyBzZXJpYWxpemF0aW9uIG9mIGRhdGEgdHlwZXNcbiAqL1xuZnVuY3Rpb24gVHlwZVNlcmlhbGl6ZXIocGFyZW50LCBwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgRWxlbWVudFNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBwYXJlbnQsIHByb3BlcnR5RGVzY3JpcHRvcik7XG59XG5cbmluaGVyaXRzKFR5cGVTZXJpYWxpemVyLCBFbGVtZW50U2VyaWFsaXplcik7XG5cblR5cGVTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZU5zQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAvLyBleHRyYWN0ZWQgYXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IEVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZU5zQXR0cmlidXRlcy5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuXG4gIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC4kZGVzY3JpcHRvcjtcblxuICAvLyBvbmx5IHNlcmlhbGl6ZSB4c2k6dHlwZSBpZiBuZWNlc3NhcnlcbiAgaWYgKGRlc2NyaXB0b3IubmFtZSA9PT0gdGhpcy5wcm9wZXJ0eURlc2NyaXB0b3IudHlwZSkge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG5cbiAgdmFyIHR5cGVOcyA9IHRoaXMudHlwZU5zID0gdGhpcy5uc1RhZ05hbWUoZGVzY3JpcHRvcik7XG4gIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQodGhpcy50eXBlTnMpO1xuXG4gIC8vIGFkZCB4c2k6dHlwZSBhdHRyaWJ1dGUgdG8gcmVwcmVzZW50IHRoZSBlbGVtZW50c1xuICAvLyBhY3R1YWwgdHlwZVxuXG4gIHZhciBwa2cgPSBlbGVtZW50LiRtb2RlbC5nZXRQYWNrYWdlKHR5cGVOcy51cmkpLFxuICAgICAgdHlwZVByZWZpeCA9IChwa2cueG1sICYmIHBrZy54bWwudHlwZVByZWZpeCkgfHwgJyc7XG5cbiAgdGhpcy5hZGRBdHRyaWJ1dGUoXG4gICAgdGhpcy5uc0F0dHJpYnV0ZU5hbWUoWFNJX1RZUEUpLFxuICAgICh0eXBlTnMucHJlZml4ID8gdHlwZU5zLnByZWZpeCArICc6JyA6ICcnKSArIHR5cGVQcmVmaXggKyBkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZVxuICApO1xuXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcblxuVHlwZVNlcmlhbGl6ZXIucHJvdG90eXBlLmlzTG9jYWxOcyA9IGZ1bmN0aW9uKG5zKSB7XG4gIHJldHVybiBucy51cmkgPT09ICh0aGlzLnR5cGVOcyB8fCB0aGlzLm5zKS51cmk7XG59O1xuXG5mdW5jdGlvbiBTYXZpbmdXcml0ZXIoKSB7XG4gIHRoaXMudmFsdWUgPSAnJztcblxuICB0aGlzLndyaXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdGhpcy52YWx1ZSArPSBzdHI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIEZvcm1hdGluZ1dyaXRlcihvdXQsIGZvcm1hdCkge1xuXG4gIHZhciBpbmRlbnQgPSBbJyddO1xuXG4gIHRoaXMuYXBwZW5kID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgb3V0LndyaXRlKHN0cik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmFwcGVuZE5ld0xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBvdXQud3JpdGUoJ1xcbicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMuYXBwZW5kSW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgb3V0LndyaXRlKGluZGVudC5qb2luKCcgICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGluZGVudC5wdXNoKCcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLnVuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaW5kZW50LnBvcCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIEEgd3JpdGVyIGZvciBtZXRhLW1vZGVsIGJhY2tlZCBkb2N1bWVudCB0cmVlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG91dHB1dCBvcHRpb25zIHRvIHBhc3MgaW50byB0aGUgd3JpdGVyXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcihvcHRpb25zKSB7XG5cbiAgb3B0aW9ucyA9IGFzc2lnbih7IGZvcm1hdDogZmFsc2UsIHByZWFtYmxlOiB0cnVlIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGZ1bmN0aW9uIHRvWE1MKHRyZWUsIHdyaXRlcikge1xuICAgIHZhciBpbnRlcm5hbFdyaXRlciA9IHdyaXRlciB8fCBuZXcgU2F2aW5nV3JpdGVyKCk7XG4gICAgdmFyIGZvcm1hdGluZ1dyaXRlciA9IG5ldyBGb3JtYXRpbmdXcml0ZXIoaW50ZXJuYWxXcml0ZXIsIG9wdGlvbnMuZm9ybWF0KTtcblxuICAgIGlmIChvcHRpb25zLnByZWFtYmxlKSB7XG4gICAgICBmb3JtYXRpbmdXcml0ZXIuYXBwZW5kKFhNTF9QUkVBTUJMRSk7XG4gICAgfVxuXG4gICAgbmV3IEVsZW1lbnRTZXJpYWxpemVyKCkuYnVpbGQodHJlZSkuc2VyaWFsaXplVG8oZm9ybWF0aW5nV3JpdGVyKTtcblxuICAgIGlmICghd3JpdGVyKSB7XG4gICAgICByZXR1cm4gaW50ZXJuYWxXcml0ZXIudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b1hNTDogdG9YTUxcbiAgfTtcbn1cblxuZXhwb3J0IHsgUmVhZGVyLCBXcml0ZXIgfTtcbiIsImltcG9ydCB7IGZvckVhY2gsIGJpbmQsIHBpY2ssIGFzc2lnbiwgaXNTdHJpbmcsIGlzT2JqZWN0IH0gZnJvbSAnbWluLWRhc2gnO1xuXG4vKipcbiAqIE1vZGRsZSBiYXNlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIEJhc2UoKSB7IH1cblxuQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy4kbW9kZWwucHJvcGVydGllcy5nZXQodGhpcywgbmFtZSk7XG59O1xuXG5CYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLiRtb2RlbC5wcm9wZXJ0aWVzLnNldCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEEgbW9kZWwgZWxlbWVudCBmYWN0b3J5LlxuICpcbiAqIEBwYXJhbSB7TW9kZGxlfSBtb2RlbFxuICogQHBhcmFtIHtQcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIEZhY3RvcnkobW9kZWwsIHByb3BlcnRpZXMpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xufVxuXG5cbkZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVR5cGUgPSBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG5cbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcblxuICB2YXIgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2UucHJvdG90eXBlKTtcblxuICAvLyBpbml0aWFsaXplIGRlZmF1bHQgdmFsdWVzXG4gIGZvckVhY2goZGVzY3JpcHRvci5wcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG4gICAgaWYgKCFwLmlzTWFueSAmJiBwLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvdG90eXBlW3AubmFtZV0gPSBwLmRlZmF1bHQ7XG4gICAgfVxuICB9KTtcblxuICBwcm9wcy5kZWZpbmVNb2RlbChwcm90b3R5cGUsIG1vZGVsKTtcbiAgcHJvcHMuZGVmaW5lRGVzY3JpcHRvcihwcm90b3R5cGUsIGRlc2NyaXB0b3IpO1xuXG4gIHZhciBuYW1lID0gZGVzY3JpcHRvci5ucy5uYW1lO1xuXG4gIC8qKlxuICAgKiBUaGUgbmV3IHR5cGUgY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIE1vZGRsZUVsZW1lbnQoYXR0cnMpIHtcbiAgICBwcm9wcy5kZWZpbmUodGhpcywgJyR0eXBlJywgeyB2YWx1ZTogbmFtZSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICBwcm9wcy5kZWZpbmUodGhpcywgJyRhdHRycycsIHsgdmFsdWU6IHt9IH0pO1xuICAgIHByb3BzLmRlZmluZSh0aGlzLCAnJHBhcmVudCcsIHsgd3JpdGFibGU6IHRydWUgfSk7XG5cbiAgICBmb3JFYWNoKGF0dHJzLCBiaW5kKGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICB0aGlzLnNldChrZXksIHZhbCk7XG4gICAgfSwgdGhpcykpO1xuICB9XG5cbiAgTW9kZGxlRWxlbWVudC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG5cbiAgTW9kZGxlRWxlbWVudC5oYXNUeXBlID0gcHJvdG90eXBlLiRpbnN0YW5jZU9mID0gdGhpcy5tb2RlbC5oYXNUeXBlO1xuXG4gIC8vIHN0YXRpYyBsaW5rc1xuICBwcm9wcy5kZWZpbmVNb2RlbChNb2RkbGVFbGVtZW50LCBtb2RlbCk7XG4gIHByb3BzLmRlZmluZURlc2NyaXB0b3IoTW9kZGxlRWxlbWVudCwgZGVzY3JpcHRvcik7XG5cbiAgcmV0dXJuIE1vZGRsZUVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEJ1aWx0LWluIG1vZGRsZSB0eXBlc1xuICovXG52YXIgQlVJTFRJTlMgPSB7XG4gIFN0cmluZzogdHJ1ZSxcbiAgQm9vbGVhbjogdHJ1ZSxcbiAgSW50ZWdlcjogdHJ1ZSxcbiAgUmVhbDogdHJ1ZSxcbiAgRWxlbWVudDogdHJ1ZVxufTtcblxuLyoqXG4gKiBDb252ZXJ0ZXJzIGZvciBidWlsdCBpbiB0eXBlcyBmcm9tIHN0cmluZyByZXByZXNlbnRhdGlvbnNcbiAqL1xudmFyIFRZUEVfQ09OVkVSVEVSUyA9IHtcbiAgU3RyaW5nOiBmdW5jdGlvbihzKSB7IHJldHVybiBzOyB9LFxuICBCb29sZWFuOiBmdW5jdGlvbihzKSB7IHJldHVybiBzID09PSAndHJ1ZSc7IH0sXG4gIEludGVnZXI6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHBhcnNlSW50KHMsIDEwKTsgfSxcbiAgUmVhbDogZnVuY3Rpb24ocykgeyByZXR1cm4gcGFyc2VGbG9hdChzLCAxMCk7IH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHR5cGUgdG8gaXRzIHJlYWwgcmVwcmVzZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gY29lcmNlVHlwZSh0eXBlLCB2YWx1ZSkge1xuXG4gIHZhciBjb252ZXJ0ZXIgPSBUWVBFX0NPTlZFUlRFUlNbdHlwZV07XG5cbiAgaWYgKGNvbnZlcnRlcikge1xuICAgIHJldHVybiBjb252ZXJ0ZXIodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBnaXZlbiB0eXBlIGlzIGJ1aWx0LWluXG4gKi9cbmZ1bmN0aW9uIGlzQnVpbHRJbih0eXBlKSB7XG4gIHJldHVybiAhIUJVSUxUSU5TW3R5cGVdO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBnaXZlbiB0eXBlIGlzIHNpbXBsZVxuICovXG5mdW5jdGlvbiBpc1NpbXBsZSh0eXBlKSB7XG4gIHJldHVybiAhIVRZUEVfQ09OVkVSVEVSU1t0eXBlXTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBuYW1lc3BhY2VkIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBmb3JtIChuczopbG9jYWxOYW1lIHRvIGFuIG9iamVjdCxcbiAqIGdpdmVuIGEgZGVmYXVsdCBwcmVmaXggdG8gYXNzdW1lIGluIGNhc2Ugbm8gZXhwbGljaXQgbmFtZXNwYWNlIGlzIGdpdmVuLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlZmF1bHRQcmVmaXhdIHRoZSBkZWZhdWx0IHByZWZpeCB0byB0YWtlLCBpZiBub25lIGlzIHByZXNlbnQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgcGFyc2VkIG5hbWVcbiAqL1xuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUsIGRlZmF1bHRQcmVmaXgpIHtcbiAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgvOi8pLFxuICAgICAgbG9jYWxOYW1lLCBwcmVmaXg7XG5cbiAgLy8gbm8gcHJlZml4IChpLmUuIG9ubHkgbG9jYWwgbmFtZSlcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGxvY2FsTmFtZSA9IG5hbWU7XG4gICAgcHJlZml4ID0gZGVmYXVsdFByZWZpeDtcbiAgfSBlbHNlXG4gIC8vIHByZWZpeCArIGxvY2FsIG5hbWVcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGxvY2FsTmFtZSA9IHBhcnRzWzFdO1xuICAgIHByZWZpeCA9IHBhcnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgPHByZWZpeDpsb2NhbE5hbWU+IG9yIDxsb2NhbE5hbWU+LCBnb3QgJyArIG5hbWUpO1xuICB9XG5cbiAgbmFtZSA9IChwcmVmaXggPyBwcmVmaXggKyAnOicgOiAnJykgKyBsb2NhbE5hbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHByZWZpeDogcHJlZml4LFxuICAgIGxvY2FsTmFtZTogbG9jYWxOYW1lXG4gIH07XG59XG5cbi8qKlxuICogQSB1dGlsaXR5IHRvIGJ1aWxkIGVsZW1lbnQgZGVzY3JpcHRvcnMuXG4gKi9cbmZ1bmN0aW9uIERlc2NyaXB0b3JCdWlsZGVyKG5hbWVOcykge1xuICB0aGlzLm5zID0gbmFtZU5zO1xuICB0aGlzLm5hbWUgPSBuYW1lTnMubmFtZTtcbiAgdGhpcy5hbGxUeXBlcyA9IFtdO1xuICB0aGlzLmFsbFR5cGVzQnlOYW1lID0ge307XG4gIHRoaXMucHJvcGVydGllcyA9IFtdO1xuICB0aGlzLnByb3BlcnRpZXNCeU5hbWUgPSB7fTtcbn1cblxuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHBpY2sodGhpcywgW1xuICAgICducycsXG4gICAgJ25hbWUnLFxuICAgICdhbGxUeXBlcycsXG4gICAgJ2FsbFR5cGVzQnlOYW1lJyxcbiAgICAncHJvcGVydGllcycsXG4gICAgJ3Byb3BlcnRpZXNCeU5hbWUnLFxuICAgICdib2R5UHJvcGVydHknLFxuICAgICdpZFByb3BlcnR5J1xuICBdKTtcbn07XG5cbi8qKlxuICogQWRkIHByb3BlcnR5IGF0IGdpdmVuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwXG4gKiBAcGFyYW0ge051bWJlcn0gW2lkeF1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZhbGlkYXRlPXRydWVdXG4gKi9cbkRlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5hZGRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIGlkeCwgdmFsaWRhdGUpIHtcblxuICBpZiAodHlwZW9mIGlkeCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsaWRhdGUgPSBpZHg7XG4gICAgaWR4ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGhpcy5hZGROYW1lZFByb3BlcnR5KHAsIHZhbGlkYXRlICE9PSBmYWxzZSk7XG5cbiAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXM7XG5cbiAgaWYgKGlkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJvcGVydGllcy5zcGxpY2UoaWR4LCAwLCBwKTtcbiAgfSBlbHNlIHtcbiAgICBwcm9wZXJ0aWVzLnB1c2gocCk7XG4gIH1cbn07XG5cblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLnJlcGxhY2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9sZFByb3BlcnR5LCBuZXdQcm9wZXJ0eSwgcmVwbGFjZSkge1xuICB2YXIgb2xkTmFtZU5zID0gb2xkUHJvcGVydHkubnM7XG5cbiAgdmFyIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcHJvcGVydGllc0J5TmFtZSA9IHRoaXMucHJvcGVydGllc0J5TmFtZSxcbiAgICAgIHJlbmFtZSA9IG9sZFByb3BlcnR5Lm5hbWUgIT09IG5ld1Byb3BlcnR5Lm5hbWU7XG5cbiAgaWYgKG9sZFByb3BlcnR5LmlzSWQpIHtcbiAgICBpZiAoIW5ld1Byb3BlcnR5LmlzSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3Byb3BlcnR5IDwnICsgbmV3UHJvcGVydHkubnMubmFtZSArICc+IG11c3QgYmUgaWQgcHJvcGVydHkgJyArXG4gICAgICAgICd0byByZWZpbmUgPCcgKyBvbGRQcm9wZXJ0eS5ucy5uYW1lICsgJz4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldElkUHJvcGVydHkobmV3UHJvcGVydHksIGZhbHNlKTtcbiAgfVxuXG4gIGlmIChvbGRQcm9wZXJ0eS5pc0JvZHkpIHtcblxuICAgIGlmICghbmV3UHJvcGVydHkuaXNCb2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdwcm9wZXJ0eSA8JyArIG5ld1Byb3BlcnR5Lm5zLm5hbWUgKyAnPiBtdXN0IGJlIGJvZHkgcHJvcGVydHkgJyArXG4gICAgICAgICd0byByZWZpbmUgPCcgKyBvbGRQcm9wZXJ0eS5ucy5uYW1lICsgJz4nKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBDaGVjayBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5zZXRCb2R5UHJvcGVydHkobmV3UHJvcGVydHksIGZhbHNlKTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGV4aXN0ZW5jZSBhbmQgZ2V0IGxvY2F0aW9uIG9mIG9sZCBwcm9wZXJ0eVxuICB2YXIgaWR4ID0gcHJvcHMuaW5kZXhPZihvbGRQcm9wZXJ0eSk7XG4gIGlmIChpZHggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9wZXJ0eSA8JyArIG9sZE5hbWVOcy5uYW1lICsgJz4gbm90IGZvdW5kIGluIHByb3BlcnR5IGxpc3QnKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBvbGQgcHJvcGVydHlcbiAgcHJvcHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgLy8gcmVwbGFjaW5nIHRoZSBuYW1lZCBwcm9wZXJ0eSBpcyBpbnRlbnRpb25hbFxuICAvL1xuICAvLyAgKiB2YWxpZGF0ZSBvbmx5IGlmIHRoaXMgaXMgYSBcInJlbmFtZVwiIG9wZXJhdGlvblxuICAvLyAgKiBhZGQgYXQgc3BlY2lmaWMgaW5kZXggdW5sZXNzIHdlIFwicmVwbGFjZVwiXG4gIC8vXG4gIHRoaXMuYWRkUHJvcGVydHkobmV3UHJvcGVydHksIHJlcGxhY2UgPyB1bmRlZmluZWQgOiBpZHgsIHJlbmFtZSk7XG5cbiAgLy8gbWFrZSBuZXcgcHJvcGVydHkgYXZhaWxhYmxlIHVuZGVyIG9sZCBuYW1lXG4gIHByb3BlcnRpZXNCeU5hbWVbb2xkTmFtZU5zLm5hbWVdID0gcHJvcGVydGllc0J5TmFtZVtvbGROYW1lTnMubG9jYWxOYW1lXSA9IG5ld1Byb3BlcnR5O1xufTtcblxuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUucmVkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIHRhcmdldFByb3BlcnR5TmFtZSwgcmVwbGFjZSkge1xuXG4gIHZhciBuc1ByZWZpeCA9IHAubnMucHJlZml4O1xuICB2YXIgcGFydHMgPSB0YXJnZXRQcm9wZXJ0eU5hbWUuc3BsaXQoJyMnKTtcblxuICB2YXIgbmFtZSA9IHBhcnNlTmFtZShwYXJ0c1swXSwgbnNQcmVmaXgpO1xuICB2YXIgYXR0ck5hbWUgPSBwYXJzZU5hbWUocGFydHNbMV0sIG5hbWUucHJlZml4KS5uYW1lO1xuXG4gIHZhciByZWRlZmluZWRQcm9wZXJ0eSA9IHRoaXMucHJvcGVydGllc0J5TmFtZVthdHRyTmFtZV07XG4gIGlmICghcmVkZWZpbmVkUHJvcGVydHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlZmluZWQgcHJvcGVydHkgPCcgKyBhdHRyTmFtZSArICc+IG5vdCBmb3VuZCcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVwbGFjZVByb3BlcnR5KHJlZGVmaW5lZFByb3BlcnR5LCBwLCByZXBsYWNlKTtcbiAgfVxuXG4gIGRlbGV0ZSBwLnJlZGVmaW5lcztcbn07XG5cbkRlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5hZGROYW1lZFByb3BlcnR5ID0gZnVuY3Rpb24ocCwgdmFsaWRhdGUpIHtcbiAgdmFyIG5zID0gcC5ucyxcbiAgICAgIHByb3BzQnlOYW1lID0gdGhpcy5wcm9wZXJ0aWVzQnlOYW1lO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIHRoaXMuYXNzZXJ0Tm90RGVmaW5lZChwLCBucy5uYW1lKTtcbiAgICB0aGlzLmFzc2VydE5vdERlZmluZWQocCwgbnMubG9jYWxOYW1lKTtcbiAgfVxuXG4gIHByb3BzQnlOYW1lW25zLm5hbWVdID0gcHJvcHNCeU5hbWVbbnMubG9jYWxOYW1lXSA9IHA7XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUucmVtb3ZlTmFtZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIG5zID0gcC5ucyxcbiAgICAgIHByb3BzQnlOYW1lID0gdGhpcy5wcm9wZXJ0aWVzQnlOYW1lO1xuXG4gIGRlbGV0ZSBwcm9wc0J5TmFtZVtucy5uYW1lXTtcbiAgZGVsZXRlIHByb3BzQnlOYW1lW25zLmxvY2FsTmFtZV07XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuc2V0Qm9keVByb3BlcnR5ID0gZnVuY3Rpb24ocCwgdmFsaWRhdGUpIHtcblxuICBpZiAodmFsaWRhdGUgJiYgdGhpcy5ib2R5UHJvcGVydHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYm9keSBwcm9wZXJ0eSBkZWZpbmVkIG11bHRpcGxlIHRpbWVzICcgK1xuICAgICAgJyg8JyArIHRoaXMuYm9keVByb3BlcnR5Lm5zLm5hbWUgKyAnPiwgPCcgKyBwLm5zLm5hbWUgKyAnPiknKTtcbiAgfVxuXG4gIHRoaXMuYm9keVByb3BlcnR5ID0gcDtcbn07XG5cbkRlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5zZXRJZFByb3BlcnR5ID0gZnVuY3Rpb24ocCwgdmFsaWRhdGUpIHtcblxuICBpZiAodmFsaWRhdGUgJiYgdGhpcy5pZFByb3BlcnR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2lkIHByb3BlcnR5IGRlZmluZWQgbXVsdGlwbGUgdGltZXMgJyArXG4gICAgICAnKDwnICsgdGhpcy5pZFByb3BlcnR5Lm5zLm5hbWUgKyAnPiwgPCcgKyBwLm5zLm5hbWUgKyAnPiknKTtcbiAgfVxuXG4gIHRoaXMuaWRQcm9wZXJ0eSA9IHA7XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYXNzZXJ0Tm90RGVmaW5lZCA9IGZ1bmN0aW9uKHAsIG5hbWUpIHtcbiAgdmFyIHByb3BlcnR5TmFtZSA9IHAubmFtZSxcbiAgICAgIGRlZmluZWRQcm9wZXJ0eSA9IHRoaXMucHJvcGVydGllc0J5TmFtZVtwcm9wZXJ0eU5hbWVdO1xuXG4gIGlmIChkZWZpbmVkUHJvcGVydHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAncHJvcGVydHkgPCcgKyBwcm9wZXJ0eU5hbWUgKyAnPiBhbHJlYWR5IGRlZmluZWQ7ICcgK1xuICAgICAgJ292ZXJyaWRlIG9mIDwnICsgZGVmaW5lZFByb3BlcnR5LmRlZmluZWRCeS5ucy5uYW1lICsgJyMnICsgZGVmaW5lZFByb3BlcnR5Lm5zLm5hbWUgKyAnPiBieSAnICtcbiAgICAgICc8JyArIHAuZGVmaW5lZEJ5Lm5zLm5hbWUgKyAnIycgKyBwLm5zLm5hbWUgKyAnPiBub3QgYWxsb3dlZCB3aXRob3V0IHJlZGVmaW5lcycpO1xuICB9XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnByb3BlcnRpZXNCeU5hbWVbbmFtZV07XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYWRkVHJhaXQgPSBmdW5jdGlvbih0LCBpbmhlcml0ZWQpIHtcblxuICB2YXIgdHlwZXNCeU5hbWUgPSB0aGlzLmFsbFR5cGVzQnlOYW1lLFxuICAgICAgdHlwZXMgPSB0aGlzLmFsbFR5cGVzO1xuXG4gIHZhciB0eXBlTmFtZSA9IHQubmFtZTtcblxuICBpZiAodHlwZU5hbWUgaW4gdHlwZXNCeU5hbWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3JFYWNoKHQucHJvcGVydGllcywgYmluZChmdW5jdGlvbihwKSB7XG5cbiAgICAvLyBjbG9uZSBwcm9wZXJ0eSB0byBhbGxvdyBleHRlbnNpb25zXG4gICAgcCA9IGFzc2lnbih7fSwgcCwge1xuICAgICAgbmFtZTogcC5ucy5sb2NhbE5hbWUsXG4gICAgICBpbmhlcml0ZWQ6IGluaGVyaXRlZFxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsICdkZWZpbmVkQnknLCB7XG4gICAgICB2YWx1ZTogdFxuICAgIH0pO1xuXG4gICAgdmFyIHJlcGxhY2VzID0gcC5yZXBsYWNlcyxcbiAgICAgICAgcmVkZWZpbmVzID0gcC5yZWRlZmluZXM7XG5cbiAgICAvLyBhZGQgcmVwbGFjZS9yZWRlZmluZSBzdXBwb3J0XG4gICAgaWYgKHJlcGxhY2VzIHx8IHJlZGVmaW5lcykge1xuICAgICAgdGhpcy5yZWRlZmluZVByb3BlcnR5KHAsIHJlcGxhY2VzIHx8IHJlZGVmaW5lcywgcmVwbGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocC5pc0JvZHkpIHtcbiAgICAgICAgdGhpcy5zZXRCb2R5UHJvcGVydHkocCk7XG4gICAgICB9XG4gICAgICBpZiAocC5pc0lkKSB7XG4gICAgICAgIHRoaXMuc2V0SWRQcm9wZXJ0eShwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkUHJvcGVydHkocCk7XG4gICAgfVxuICB9LCB0aGlzKSk7XG5cbiAgdHlwZXMucHVzaCh0KTtcbiAgdHlwZXNCeU5hbWVbdHlwZU5hbWVdID0gdDtcbn07XG5cbi8qKlxuICogQSByZWdpc3RyeSBvZiBNb2RkbGUgcGFja2FnZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQYWNrYWdlPn0gcGFja2FnZXNcbiAqIEBwYXJhbSB7UHJvcGVydGllc30gcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBSZWdpc3RyeShwYWNrYWdlcywgcHJvcGVydGllcykge1xuICB0aGlzLnBhY2thZ2VNYXAgPSB7fTtcbiAgdGhpcy50eXBlTWFwID0ge307XG5cbiAgdGhpcy5wYWNrYWdlcyA9IFtdO1xuXG4gIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG5cbiAgZm9yRWFjaChwYWNrYWdlcywgYmluZCh0aGlzLnJlZ2lzdGVyUGFja2FnZSwgdGhpcykpO1xufVxuXG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRQYWNrYWdlID0gZnVuY3Rpb24odXJpT3JQcmVmaXgpIHtcbiAgcmV0dXJuIHRoaXMucGFja2FnZU1hcFt1cmlPclByZWZpeF07XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUuZ2V0UGFja2FnZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucGFja2FnZXM7XG59O1xuXG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlclBhY2thZ2UgPSBmdW5jdGlvbihwa2cpIHtcblxuICAvLyBjb3B5IHBhY2thZ2VcbiAgcGtnID0gYXNzaWduKHt9LCBwa2cpO1xuXG4gIHZhciBwa2dNYXAgPSB0aGlzLnBhY2thZ2VNYXA7XG5cbiAgZW5zdXJlQXZhaWxhYmxlKHBrZ01hcCwgcGtnLCAncHJlZml4Jyk7XG4gIGVuc3VyZUF2YWlsYWJsZShwa2dNYXAsIHBrZywgJ3VyaScpO1xuXG4gIC8vIHJlZ2lzdGVyIHR5cGVzXG4gIGZvckVhY2gocGtnLnR5cGVzLCBiaW5kKGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgICB0aGlzLnJlZ2lzdGVyVHlwZShkZXNjcmlwdG9yLCBwa2cpO1xuICB9LCB0aGlzKSk7XG5cbiAgcGtnTWFwW3BrZy51cmldID0gcGtnTWFwW3BrZy5wcmVmaXhdID0gcGtnO1xuICB0aGlzLnBhY2thZ2VzLnB1c2gocGtnKTtcbn07XG5cblxuLyoqXG4gKiBSZWdpc3RlciBhIHR5cGUgZnJvbSBhIHNwZWNpZmljIHBhY2thZ2Ugd2l0aCB1c1xuICovXG5SZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXJUeXBlID0gZnVuY3Rpb24odHlwZSwgcGtnKSB7XG5cbiAgdHlwZSA9IGFzc2lnbih7fSwgdHlwZSwge1xuICAgIHN1cGVyQ2xhc3M6ICh0eXBlLnN1cGVyQ2xhc3MgfHwgW10pLnNsaWNlKCksXG4gICAgZXh0ZW5kczogKHR5cGUuZXh0ZW5kcyB8fCBbXSkuc2xpY2UoKSxcbiAgICBwcm9wZXJ0aWVzOiAodHlwZS5wcm9wZXJ0aWVzIHx8IFtdKS5zbGljZSgpLFxuICAgIG1ldGE6IGFzc2lnbigodHlwZS5tZXRhIHx8IHt9KSlcbiAgfSk7XG5cbiAgdmFyIG5zID0gcGFyc2VOYW1lKHR5cGUubmFtZSwgcGtnLnByZWZpeCksXG4gICAgICBuYW1lID0gbnMubmFtZSxcbiAgICAgIHByb3BlcnRpZXNCeU5hbWUgPSB7fTtcblxuICAvLyBwYXJzZSBwcm9wZXJ0aWVzXG4gIGZvckVhY2godHlwZS5wcm9wZXJ0aWVzLCBiaW5kKGZ1bmN0aW9uKHApIHtcblxuICAgIC8vIG5hbWVzcGFjZSBwcm9wZXJ0eSBuYW1lc1xuICAgIHZhciBwcm9wZXJ0eU5zID0gcGFyc2VOYW1lKHAubmFtZSwgbnMucHJlZml4KSxcbiAgICAgICAgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOcy5uYW1lO1xuXG4gICAgLy8gbmFtZXNwYWNlIHByb3BlcnR5IHR5cGVzXG4gICAgaWYgKCFpc0J1aWx0SW4ocC50eXBlKSkge1xuICAgICAgcC50eXBlID0gcGFyc2VOYW1lKHAudHlwZSwgcHJvcGVydHlOcy5wcmVmaXgpLm5hbWU7XG4gICAgfVxuXG4gICAgYXNzaWduKHAsIHtcbiAgICAgIG5zOiBwcm9wZXJ0eU5zLFxuICAgICAgbmFtZTogcHJvcGVydHlOYW1lXG4gICAgfSk7XG5cbiAgICBwcm9wZXJ0aWVzQnlOYW1lW3Byb3BlcnR5TmFtZV0gPSBwO1xuICB9LCB0aGlzKSk7XG5cbiAgLy8gdXBkYXRlIG5zICsgbmFtZVxuICBhc3NpZ24odHlwZSwge1xuICAgIG5zOiBucyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHByb3BlcnRpZXNCeU5hbWU6IHByb3BlcnRpZXNCeU5hbWVcbiAgfSk7XG5cbiAgZm9yRWFjaCh0eXBlLmV4dGVuZHMsIGJpbmQoZnVuY3Rpb24oZXh0ZW5kc05hbWUpIHtcbiAgICB2YXIgZXh0ZW5kZWQgPSB0aGlzLnR5cGVNYXBbZXh0ZW5kc05hbWVdO1xuXG4gICAgZXh0ZW5kZWQudHJhaXRzID0gZXh0ZW5kZWQudHJhaXRzIHx8IFtdO1xuICAgIGV4dGVuZGVkLnRyYWl0cy5wdXNoKG5hbWUpO1xuICB9LCB0aGlzKSk7XG5cbiAgLy8gbGluayB0byBwYWNrYWdlXG4gIHRoaXMuZGVmaW5lUGFja2FnZSh0eXBlLCBwa2cpO1xuXG4gIC8vIHJlZ2lzdGVyXG4gIHRoaXMudHlwZU1hcFtuYW1lXSA9IHR5cGU7XG59O1xuXG5cbi8qKlxuICogVHJhdmVyc2UgdGhlIHR5cGUgaGllcmFyY2h5IGZyb20gYm90dG9tIHRvIHRvcCxcbiAqIGNhbGxpbmcgaXRlcmF0b3Igd2l0aCAodHlwZSwgaW5oZXJpdGVkKSBmb3IgYWxsIGVsZW1lbnRzIGluXG4gKiB0aGUgaW5oZXJpdGFuY2UgY2hhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5zTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RyYWl0PWZhbHNlXVxuICovXG5SZWdpc3RyeS5wcm90b3R5cGUubWFwVHlwZXMgPSBmdW5jdGlvbihuc05hbWUsIGl0ZXJhdG9yLCB0cmFpdCkge1xuXG4gIHZhciB0eXBlID0gaXNCdWlsdEluKG5zTmFtZS5uYW1lKSA/IHsgbmFtZTogbnNOYW1lLm5hbWUgfSA6IHRoaXMudHlwZU1hcFtuc05hbWUubmFtZV07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZSB0aGUgc2VsZWN0ZWQgdHJhaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAgICovXG4gIGZ1bmN0aW9uIHRyYXZlcnNlVHJhaXQoY2xzKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlU3VwZXIoY2xzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZSB0aGUgc2VsZWN0ZWQgc3VwZXIgdHlwZSBvciB0cmFpdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RyYWl0PWZhbHNlXVxuICAgKi9cbiAgZnVuY3Rpb24gdHJhdmVyc2VTdXBlcihjbHMsIHRyYWl0KSB7XG4gICAgdmFyIHBhcmVudE5zID0gcGFyc2VOYW1lKGNscywgaXNCdWlsdEluKGNscykgPyAnJyA6IG5zTmFtZS5wcmVmaXgpO1xuICAgIHNlbGYubWFwVHlwZXMocGFyZW50TnMsIGl0ZXJhdG9yLCB0cmFpdCk7XG4gIH1cblxuICBpZiAoIXR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdHlwZSA8JyArIG5zTmFtZS5uYW1lICsgJz4nKTtcbiAgfVxuXG4gIGZvckVhY2godHlwZS5zdXBlckNsYXNzLCB0cmFpdCA/IHRyYXZlcnNlVHJhaXQgOiB0cmF2ZXJzZVN1cGVyKTtcblxuICAvLyBjYWxsIGl0ZXJhdG9yIHdpdGggKHR5cGUsIGluaGVyaXRlZD0hdHJhaXQpXG4gIGl0ZXJhdG9yKHR5cGUsICF0cmFpdCk7XG5cbiAgZm9yRWFjaCh0eXBlLnRyYWl0cywgdHJhdmVyc2VUcmFpdCk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIGRlc2NyaXB0b3IgZm9yIGEgdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgdGhlIG5hbWVzcGFjZWQgbmFtZSAobnM6bG9jYWxOYW1lKSBvZiB0aGUgdHlwZVxuICpcbiAqIEByZXR1cm4ge0Rlc2NyaXB0b3J9IHRoZSByZXN1bHRpbmcgZWZmZWN0aXZlIGRlc2NyaXB0b3JcbiAqL1xuUmVnaXN0cnkucHJvdG90eXBlLmdldEVmZmVjdGl2ZURlc2NyaXB0b3IgPSBmdW5jdGlvbihuYW1lKSB7XG5cbiAgdmFyIG5zTmFtZSA9IHBhcnNlTmFtZShuYW1lKTtcblxuICB2YXIgYnVpbGRlciA9IG5ldyBEZXNjcmlwdG9yQnVpbGRlcihuc05hbWUpO1xuXG4gIHRoaXMubWFwVHlwZXMobnNOYW1lLCBmdW5jdGlvbih0eXBlLCBpbmhlcml0ZWQpIHtcbiAgICBidWlsZGVyLmFkZFRyYWl0KHR5cGUsIGluaGVyaXRlZCk7XG4gIH0pO1xuXG4gIHZhciBkZXNjcmlwdG9yID0gYnVpbGRlci5idWlsZCgpO1xuXG4gIC8vIGRlZmluZSBwYWNrYWdlIGxpbmtcbiAgdGhpcy5kZWZpbmVQYWNrYWdlKGRlc2NyaXB0b3IsIGRlc2NyaXB0b3IuYWxsVHlwZXNbZGVzY3JpcHRvci5hbGxUeXBlcy5sZW5ndGggLSAxXS4kcGtnKTtcblxuICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cblxuUmVnaXN0cnkucHJvdG90eXBlLmRlZmluZVBhY2thZ2UgPSBmdW5jdGlvbih0YXJnZXQsIHBrZykge1xuICB0aGlzLnByb3BlcnRpZXMuZGVmaW5lKHRhcmdldCwgJyRwa2cnLCB7IHZhbHVlOiBwa2cgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBlbnN1cmVBdmFpbGFibGUocGFja2FnZU1hcCwgcGtnLCBpZGVudGlmaWVyS2V5KSB7XG5cbiAgdmFyIHZhbHVlID0gcGtnW2lkZW50aWZpZXJLZXldO1xuXG4gIGlmICh2YWx1ZSBpbiBwYWNrYWdlTWFwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYWNrYWdlIHdpdGggJyArIGlkZW50aWZpZXJLZXkgKyAnIDwnICsgdmFsdWUgKyAnPiBhbHJlYWR5IGRlZmluZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgdXRpbGl0eSB0aGF0IGdldHMgYW5kIHNldHMgcHJvcGVydGllcyBvZiBtb2RlbCBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICovXG5mdW5jdGlvbiBQcm9wZXJ0aWVzKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbn1cblxuXG4vKipcbiAqIFNldHMgYSBuYW1lZCBwcm9wZXJ0eSBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCB0aGUgcHJvcGVydHkgZ2V0cyBkZWxldGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqL1xuUHJvcGVydGllcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuXG4gIHZhciBwcm9wZXJ0eSA9IHRoaXMubW9kZWwuZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgbmFtZSk7XG5cbiAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5ICYmIHByb3BlcnR5Lm5hbWU7XG5cbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIC8vIHVuc2V0IHRoZSBwcm9wZXJ0eSwgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyB1bmRlZmluZWQ7XG4gICAgLy8gZGVsZXRlIGZyb20gJGF0dHJzIChmb3IgZXh0ZW5zaW9ucykgb3IgdGhlIHRhcmdldCBpdHNlbGZcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRhcmdldC4kYXR0cnNbbmFtZV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHNldCB0aGUgcHJvcGVydHksIGRlZmluaW5nIHdlbGwgZGVmaW5lZCBwcm9wZXJ0aWVzIG9uIHRoZSBmbHlcbiAgICAvLyBvciBzaW1wbHkgdXBkYXRpbmcgdGhlbSBpbiB0YXJnZXQuJGF0dHJzIChmb3IgZXh0ZW5zaW9ucylcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIGlmIChwcm9wZXJ0eU5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldFtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC4kYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Qcm9wZXJ0aWVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih0YXJnZXQsIG5hbWUpIHtcblxuICB2YXIgcHJvcGVydHkgPSB0aGlzLm1vZGVsLmdldFByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIG5hbWUpO1xuXG4gIGlmICghcHJvcGVydHkpIHtcbiAgICByZXR1cm4gdGFyZ2V0LiRhdHRyc1tuYW1lXTtcbiAgfVxuXG4gIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eS5uYW1lO1xuXG4gIC8vIGNoZWNrIGlmIGFjY2VzcyB0byBjb2xsZWN0aW9uIHByb3BlcnR5IGFuZCBsYXppbHkgaW5pdGlhbGl6ZSBpdFxuICBpZiAoIXRhcmdldFtwcm9wZXJ0eU5hbWVdICYmIHByb3BlcnR5LmlzTWFueSkge1xuICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIFtdKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHlOYW1lXTtcbn07XG5cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eSBvbiB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuUHJvcGVydGllcy5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCBvcHRpb25zKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIG9wdGlvbnMpO1xufTtcblxuXG4vKipcbiAqIERlZmluZSB0aGUgZGVzY3JpcHRvciBmb3IgYW4gZWxlbWVudFxuICovXG5Qcm9wZXJ0aWVzLnByb3RvdHlwZS5kZWZpbmVEZXNjcmlwdG9yID0gZnVuY3Rpb24odGFyZ2V0LCBkZXNjcmlwdG9yKSB7XG4gIHRoaXMuZGVmaW5lKHRhcmdldCwgJyRkZXNjcmlwdG9yJywgeyB2YWx1ZTogZGVzY3JpcHRvciB9KTtcbn07XG5cbi8qKlxuICogRGVmaW5lIHRoZSBtb2RlbCBmb3IgYW4gZWxlbWVudFxuICovXG5Qcm9wZXJ0aWVzLnByb3RvdHlwZS5kZWZpbmVNb2RlbCA9IGZ1bmN0aW9uKHRhcmdldCwgbW9kZWwpIHtcbiAgdGhpcy5kZWZpbmUodGFyZ2V0LCAnJG1vZGVsJywgeyB2YWx1ZTogbW9kZWwgfSk7XG59O1xuXG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5Lm5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiAhcHJvcGVydHkuaXNSZWZlcmVuY2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8vLyBNb2RkbGUgaW1wbGVtZW50YXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEBjbGFzcyBNb2RkbGVcbiAqXG4gKiBBIG1vZGVsIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGVsZW1lbnRzIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBNb2RkbGUgPSByZXF1aXJlKCdtb2RkbGUnKTtcbiAqXG4gKiB2YXIgcGtnID0ge1xuICogICBuYW1lOiAnbXlwYWNrYWdlJyxcbiAqICAgcHJlZml4OiAnbXknLFxuICogICB0eXBlczogW1xuICogICAgIHsgbmFtZTogJ1Jvb3QnIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgbW9kZGxlID0gbmV3IE1vZGRsZShbcGtnXSk7XG4gKlxuICogQHBhcmFtIHtBcnJheTxQYWNrYWdlPn0gcGFja2FnZXMgdGhlIHBhY2thZ2VzIHRvIGNvbnRhaW5cbiAqL1xuZnVuY3Rpb24gTW9kZGxlKHBhY2thZ2VzKSB7XG5cbiAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IFByb3BlcnRpZXModGhpcyk7XG5cbiAgdGhpcy5mYWN0b3J5ID0gbmV3IEZhY3RvcnkodGhpcywgdGhpcy5wcm9wZXJ0aWVzKTtcbiAgdGhpcy5yZWdpc3RyeSA9IG5ldyBSZWdpc3RyeShwYWNrYWdlcywgdGhpcy5wcm9wZXJ0aWVzKTtcblxuICB0aGlzLnR5cGVDYWNoZSA9IHt9O1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqXG4gKiBAbWV0aG9kIE1vZGRsZSNjcmVhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBmb28gPSBtb2RkbGUuY3JlYXRlKCdteTpGb28nKTtcbiAqIHZhciBiYXIgPSBtb2RkbGUuY3JlYXRlKCdteTpCYXInLCB7IGlkOiAnQkFSXzEnIH0pO1xuICpcbiAqIEBwYXJhbSAge1N0cmluZ3xPYmplY3R9IGRlc2NyaXB0b3IgdGhlIHR5cGUgZGVzY3JpcHRvciBvciBuYW1lIGtub3cgdG8gdGhlIG1vZGVsXG4gKiBAcGFyYW0gIHtPYmplY3R9IGF0dHJzICAgYSBudW1iZXIgb2YgYXR0cmlidXRlcyB0byBpbml0aWFsaXplIHRoZSBtb2RlbCBpbnN0YW5jZSB3aXRoXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgbW9kZWwgaW5zdGFuY2VcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihkZXNjcmlwdG9yLCBhdHRycykge1xuICB2YXIgVHlwZSA9IHRoaXMuZ2V0VHlwZShkZXNjcmlwdG9yKTtcblxuICBpZiAoIVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdHlwZSA8JyArIGRlc2NyaXB0b3IgKyAnPicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUeXBlKGF0dHJzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0eXBlIHJlcHJlc2VudGluZyBhIGdpdmVuIGRlc2NyaXB0b3JcbiAqXG4gKiBAbWV0aG9kIE1vZGRsZSNnZXRUeXBlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgRm9vID0gbW9kZGxlLmdldFR5cGUoJ215OkZvbycpO1xuICogdmFyIGZvbyA9IG5ldyBGb28oeyAnaWQnIDogJ0ZPT18xJyB9KTtcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBkZXNjcmlwdG9yIHRoZSB0eXBlIGRlc2NyaXB0b3Igb3IgbmFtZSBrbm93IHRvIHRoZSBtb2RlbFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIHRoZSB0eXBlIHJlcHJlc2VudGluZyB0aGUgZGVzY3JpcHRvclxuICovXG5Nb2RkbGUucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG5cbiAgdmFyIGNhY2hlID0gdGhpcy50eXBlQ2FjaGU7XG5cbiAgdmFyIG5hbWUgPSBpc1N0cmluZyhkZXNjcmlwdG9yKSA/IGRlc2NyaXB0b3IgOiBkZXNjcmlwdG9yLm5zLm5hbWU7XG5cbiAgdmFyIHR5cGUgPSBjYWNoZVtuYW1lXTtcblxuICBpZiAoIXR5cGUpIHtcbiAgICBkZXNjcmlwdG9yID0gdGhpcy5yZWdpc3RyeS5nZXRFZmZlY3RpdmVEZXNjcmlwdG9yKG5hbWUpO1xuICAgIHR5cGUgPSBjYWNoZVtuYW1lXSA9IHRoaXMuZmFjdG9yeS5jcmVhdGVUeXBlKGRlc2NyaXB0b3IpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhbnktZWxlbWVudCB0eXBlIHRvIGJlIHVzZWQgd2l0aGluIG1vZGVsIGluc3RhbmNlcy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgdGhhdCBsaWUgb3V0c2lkZSB0aGUgbWV0YS1tb2RlbC5cbiAqIFRoZSBjcmVhdGVkIGVsZW1lbnQgY29udGFpbnMgYWxsIHRoZSBtZXRhLWRhdGEgcmVxdWlyZWQgdG8gc2VyaWFsaXplIGl0XG4gKiBhcyBwYXJ0IG9mIG1ldGEtbW9kZWwgZWxlbWVudHMuXG4gKlxuICogQG1ldGhvZCBNb2RkbGUjY3JlYXRlQW55XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgZm9vID0gbW9kZGxlLmNyZWF0ZUFueSgndmVuZG9yOkZvbycsICdodHRwOi8vdmVuZG9yJywge1xuICogICB2YWx1ZTogJ2JhcidcbiAqIH0pO1xuICpcbiAqIHZhciBjb250YWluZXIgPSBtb2RkbGUuY3JlYXRlKCdteTpDb250YWluZXInLCAnaHR0cDovL215Jywge1xuICogICBhbnk6IFsgZm9vIF1cbiAqIH0pO1xuICpcbiAqIC8vIGdvIGFoZWFkIGFuZCBzZXJpYWxpemUgdGhlIHN0dWZmXG4gKlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSAgdGhlIG5hbWUgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSAge1N0cmluZ30gbnNVcmkgdGhlIG5hbWVzcGFjZSB1cmkgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSAge09iamVjdH0gW3Byb3BlcnRpZXNdIGEgbWFwIG9mIHByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2Ugd2l0aFxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgYW55IHR5cGUgaW5zdGFuY2VcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5jcmVhdGVBbnkgPSBmdW5jdGlvbihuYW1lLCBuc1VyaSwgcHJvcGVydGllcykge1xuXG4gIHZhciBuYW1lTnMgPSBwYXJzZU5hbWUobmFtZSk7XG5cbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgJHR5cGU6IG5hbWUsXG4gICAgJGluc3RhbmNlT2Y6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlID09PSB0aGlzLiR0eXBlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGlzR2VuZXJpYzogdHJ1ZSxcbiAgICBuczoge1xuICAgICAgcHJlZml4OiBuYW1lTnMucHJlZml4LFxuICAgICAgbG9jYWxOYW1lOiBuYW1lTnMubG9jYWxOYW1lLFxuICAgICAgdXJpOiBuc1VyaVxuICAgIH1cbiAgfTtcblxuICB0aGlzLnByb3BlcnRpZXMuZGVmaW5lRGVzY3JpcHRvcihlbGVtZW50LCBkZXNjcmlwdG9yKTtcbiAgdGhpcy5wcm9wZXJ0aWVzLmRlZmluZU1vZGVsKGVsZW1lbnQsIHRoaXMpO1xuICB0aGlzLnByb3BlcnRpZXMuZGVmaW5lKGVsZW1lbnQsICckcGFyZW50JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfSk7XG5cbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihhLCBrZXkpIHtcbiAgICBpZiAoaXNPYmplY3QoYSkgJiYgYS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbGVtZW50W2EubmFtZV0gPSBhLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50W2tleV0gPSBhO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSByZWdpc3RlcmVkIHBhY2thZ2UgYnkgdXJpIG9yIHByZWZpeFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHBhY2thZ2VcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5nZXRQYWNrYWdlID0gZnVuY3Rpb24odXJpT3JQcmVmaXgpIHtcbiAgcmV0dXJuIHRoaXMucmVnaXN0cnkuZ2V0UGFja2FnZSh1cmlPclByZWZpeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzbmFwc2hvdCBvZiBhbGwga25vd24gcGFja2FnZXNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwYWNrYWdlXG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuZ2V0UGFja2FnZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucmVnaXN0cnkuZ2V0UGFja2FnZXMoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVzY3JpcHRvciBmb3IgYW4gZWxlbWVudFxuICovXG5Nb2RkbGUucHJvdG90eXBlLmdldEVsZW1lbnREZXNjcmlwdG9yID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC4kZGVzY3JpcHRvcjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBkZXNjcmlwdG9yIG9yIGluc3RhbmNlXG4gKiByZXByZXNlbnRzIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIE1heSBiZSBhcHBsaWVkIHRvIHRoaXMsIGlmIGVsZW1lbnQgaXMgb21pdHRlZC5cbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5oYXNUeXBlID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdHlwZSA9IGVsZW1lbnQ7XG4gICAgZWxlbWVudCA9IHRoaXM7XG4gIH1cblxuICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuJG1vZGVsLmdldEVsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnQpO1xuXG4gIHJldHVybiAodHlwZSBpbiBkZXNjcmlwdG9yLmFsbFR5cGVzQnlOYW1lKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVzY3JpcHRvciBvZiBhbiBlbGVtZW50cyBuYW1lZCBwcm9wZXJ0eVxuICovXG5Nb2RkbGUucHJvdG90eXBlLmdldFByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIHJldHVybiB0aGlzLmdldEVsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnQpLnByb3BlcnRpZXNCeU5hbWVbcHJvcGVydHldO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbWFwcGVkIHR5cGUncyBkZXNjcmlwdG9yXG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuZ2V0VHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnR5cGVNYXBbdHlwZV07XG59O1xuXG5leHBvcnQgeyBNb2RkbGUsIGNvZXJjZVR5cGUsIGlzQnVpbHRJbiBhcyBpc0J1aWx0SW5UeXBlLCBpc1NpbXBsZSBhcyBpc1NpbXBsZVR5cGUsIHBhcnNlTmFtZSBhcyBwYXJzZU5hbWVOUyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9yZWZzJyk7XG5cbm1vZHVsZS5leHBvcnRzLkNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2xpYi9jb2xsZWN0aW9uJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFuIGVtcHR5IGNvbGxlY3Rpb24gc3R1Yi4gVXNlIHtAbGluayBSZWZzQ29sbGVjdGlvbi5leHRlbmR9IHRvIGV4dGVuZCBhXG4gKiBjb2xsZWN0aW9uIHdpdGggcmVmIHNlbWFudGljcy5cbiAqXG4gKiBAY2xhc3MgUmVmc0NvbGxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEV4dGVuZHMgYSBjb2xsZWN0aW9uIHdpdGgge0BsaW5rIFJlZnN9IGF3YXJlIG1ldGhvZHNcbiAqXG4gKiBAbWVtYmVyb2YgUmVmc0NvbGxlY3Rpb25cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxPYmplY3Q+fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtSZWZzfSByZWZzIGluc3RhbmNlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHByb3BlcnR5IHJlcHJlc2VudGVkIGJ5IHRoZSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldCBvYmplY3QgdGhlIGNvbGxlY3Rpb24gaXMgYXR0YWNoZWQgdG9cbiAqXG4gKiBAcmV0dXJuIHtSZWZzQ29sbGVjdGlvbjxPYmplY3Q+fSB0aGUgZXh0ZW5kZWQgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGNvbGxlY3Rpb24sIHJlZnMsIHByb3BlcnR5LCB0YXJnZXQpIHtcblxuICB2YXIgaW52ZXJzZVByb3BlcnR5ID0gcHJvcGVydHkuaW52ZXJzZTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gZWxlbWVudCBmcm9tIHRoZSBhcnJheSBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogQG1ldGhvZCBSZWZzQ29sbGVjdGlvbiNyZW1vdmVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29sbGVjdGlvbiwgJ3JlbW92ZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdmFyIGlkeCA9IHRoaXMuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgICAgLy8gdW5zZXQgaW52ZXJzZVxuICAgICAgICByZWZzLnVuc2V0KGVsZW1lbnQsIGludmVyc2VQcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5zIHRoZSBnaXZlbiBlbGVtZW50XG4gICAqXG4gICAqIEBtZXRob2QgUmVmc0NvbGxlY3Rpb24jY29udGFpbnNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gY2hlY2sgZm9yXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29sbGVjdGlvbiwgJ2NvbnRhaW5zJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIGFycmF5LCB1bmxlc3MgaXQgZXhpc3RzIGFscmVhZHkgKHNldCBzZW1hbnRpY3MpLlxuICAgKlxuICAgKiBAbWV0aG9kIFJlZnNDb2xsZWN0aW9uI2FkZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBhZGRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIGluZGV4IHRvIGFkZCBlbGVtZW50IHRvXG4gICAqICAgICAgICAgICAgICAgICAocG9zc2libHkgbW92aW5nIG90aGVyIGVsZW1lbnRzIGFyb3VuZClcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb2xsZWN0aW9uLCAnYWRkJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbihlbGVtZW50LCBpZHgpIHtcblxuICAgICAgdmFyIGN1cnJlbnRJZHggPSB0aGlzLmluZGV4T2YoZWxlbWVudCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaWR4ID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgIGlmIChjdXJyZW50SWR4ICE9PSAtMSkge1xuICAgICAgICAgIC8vIGVsZW1lbnQgYWxyZWFkeSBpbiBjb2xsZWN0aW9uICghKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0byBlbmQgb2YgYXJyYXksIGFzIG5vIGlkeCBpcyBzcGVjaWZpZWRcbiAgICAgICAgaWR4ID0gdGhpcy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBhbHJlYWR5IGluIGNvbGxlY3Rpb25cbiAgICAgIGlmIChjdXJyZW50SWR4ICE9PSAtMSkge1xuXG4gICAgICAgIC8vIHJlbW92ZSBlbGVtZW50IGZyb20gY3VycmVudElkeFxuICAgICAgICB0aGlzLnNwbGljZShjdXJyZW50SWR4LCAxKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGVsZW1lbnQgYXQgaWR4XG4gICAgICB0aGlzLnNwbGljZShpZHgsIDAsIGVsZW1lbnQpO1xuXG4gICAgICBpZiAoY3VycmVudElkeCA9PT0gLTEpIHtcbiAgICAgICAgLy8gc2V0IGludmVyc2UsIHVubGVzcyBlbGVtZW50IHdhc1xuICAgICAgICAvLyBpbiBjb2xsZWN0aW9uIGFscmVhZHlcbiAgICAgICAgcmVmcy5zZXQoZWxlbWVudCwgaW52ZXJzZVByb3BlcnR5LCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gYSBzaW1wbGUgbWFya2VyLCBpZGVudGlmeWluZyB0aGlzIGVsZW1lbnRcbiAgLy8gYXMgYmVpbmcgYSByZWZzIGNvbGxlY3Rpb25cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbGxlY3Rpb24sICdfX3JlZnNfY29sbGVjdGlvbicsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuXG5mdW5jdGlvbiBpc0V4dGVuZGVkKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIGNvbGxlY3Rpb24uX19yZWZzX2NvbGxlY3Rpb24gPT09IHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcblxubW9kdWxlLmV4cG9ydHMuaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShlLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHByb3BlcnR5Lm5hbWUgfHwgcHJvcGVydHkpO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVDb2xsZWN0aW9uUHJvcGVydHkocmVmLCBwcm9wZXJ0eSwgdGFyZ2V0KSB7XG5cbiAgdmFyIGNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uLmV4dGVuZCh0YXJnZXRbcHJvcGVydHkubmFtZV0gfHwgW10sIHJlZiwgcHJvcGVydHksIHRhcmdldCk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkubmFtZSwge1xuICAgIGVudW1lcmFibGU6IHByb3BlcnR5LmVudW1lcmFibGUsXG4gICAgdmFsdWU6IGNvbGxlY3Rpb25cbiAgfSk7XG5cbiAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoKSB7XG5cbiAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgICAgcmVmLnNldChvLCBwcm9wZXJ0eS5pbnZlcnNlLCB0YXJnZXQpO1xuICAgIH0pO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkocmVmLCBwcm9wZXJ0eSwgdGFyZ2V0KSB7XG5cbiAgdmFyIGludmVyc2VQcm9wZXJ0eSA9IHByb3BlcnR5LmludmVyc2U7XG5cbiAgdmFyIF92YWx1ZSA9IHRhcmdldFtwcm9wZXJ0eS5uYW1lXTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eS5uYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiBwcm9wZXJ0eS5jb25maWd1cmFibGUsXG4gICAgZW51bWVyYWJsZTogcHJvcGVydHkuZW51bWVyYWJsZSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3ZhbHVlO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgIC8vIHJldHVybiBpZiB3ZSBhbHJlYWR5IHBlcmZvcm1lZCBhbGwgY2hhbmdlc1xuICAgICAgaWYgKHZhbHVlID09PSBfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2xkID0gX3ZhbHVlO1xuXG4gICAgICAvLyB0ZW1wb3Jhcnkgc2V0IG51bGxcbiAgICAgIF92YWx1ZSA9IG51bGw7XG5cbiAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgcmVmLnVuc2V0KG9sZCwgaW52ZXJzZVByb3BlcnR5LCB0YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICBfdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgLy8gc2V0IGludmVyc2UgdmFsdWVcbiAgICAgIHJlZi5zZXQoX3ZhbHVlLCBpbnZlcnNlUHJvcGVydHksIHRhcmdldCk7XG4gICAgfVxuICB9KTtcblxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVmZXJlbmNlcyBvYmplY3QgZGVmaW5pbmcgdHdvIGludmVyc2x5IHJlbGF0ZWRcbiAqIGF0dHJpYnV0ZSBkZXNjcmlwdG9ycyBhIGFuZCBiLlxuICpcbiAqIDxwPlxuICogICBXaGVuIGJvdW5kIHRvIGFuIG9iamVjdCB1c2luZyB7QGxpbmsgUmVmcyNiaW5kfSB0aGUgcmVmZXJlbmNlc1xuICogICBnZXQgYWN0aXZhdGVkIGFuZCBlbnN1cmUgdGhhdCBhZGQgYW5kIHJlbW92ZSBvcGVyYXRpb25zIGFyZSBhcHBsaWVkXG4gKiAgIHJldmVyc2VseSwgdG9vLlxuICogPC9wPlxuICpcbiAqIDxwPlxuICogICBGb3IgYXR0cmlidXRlcyByZXByZXNlbnRlZCBhcyBjb2xsZWN0aW9ucyB7QGxpbmsgUmVmc30gcHJvdmlkZXMgdGhlXG4gKiAgIHtAbGluayBSZWZzQ29sbGVjdGlvbiNhZGR9LCB7QGxpbmsgUmVmc0NvbGxlY3Rpb24jcmVtb3ZlfSBhbmQge0BsaW5rIFJlZnNDb2xsZWN0aW9uI2NvbnRhaW5zfSBleHRlbnNpb25zXG4gKiAgIHRoYXQgbXVzdCBiZSB1c2VkIHRvIHByb3Blcmx5IGhvb2sgaW50byB0aGUgaW52ZXJzZSBjaGFuZ2UgbWVjaGFuaXNtLlxuICogPC9wPlxuICpcbiAqIEBjbGFzcyBSZWZzXG4gKlxuICogQGNsYXNzZGVzYyBBIGJpLWRpcmVjdGlvbmFsIHJlZmVyZW5jZSBiZXR3ZWVuIHR3byBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSB7UmVmcy5BdHRyaWJ1dGVEZXNjcmlwdG9yfSBhIHByb3BlcnR5IGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7UmVmcy5BdHRyaWJ1dGVEZXNjcmlwdG9yfSBiIHByb3BlcnR5IGRlc2NyaXB0b3JcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciByZWZzID0gUmVmcyh7IG5hbWU6ICd3aGVlbHMnLCBjb2xsZWN0aW9uOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH0sIHsgbmFtZTogJ2NhcicgfSk7XG4gKlxuICogdmFyIGNhciA9IHsgbmFtZTogJ3RveW90YScgfTtcbiAqIHZhciB3aGVlbHMgPSBbeyBwb3M6ICdmcm9udC1sZWZ0JyB9LCB7IHBvczogJ2Zyb250LXJpZ2h0JyB9XTtcbiAqXG4gKiByZWZzLmJpbmQoY2FyLCAnd2hlZWxzJyk7XG4gKlxuICogY2FyLndoZWVscyAvLyBbXVxuICogY2FyLndoZWVscy5hZGQod2hlZWxzWzBdKTtcbiAqIGNhci53aGVlbHMuYWRkKHdoZWVsc1sxXSk7XG4gKlxuICogY2FyLndoZWVscyAvLyBbeyBwb3M6ICdmcm9udC1sZWZ0JyB9LCB7IHBvczogJ2Zyb250LXJpZ2h0JyB9XVxuICpcbiAqIHdoZWVsc1swXS5jYXIgLy8geyBuYW1lOiAndG95b3RhJyB9O1xuICogY2FyLndoZWVscy5yZW1vdmUod2hlZWxzWzBdKTtcbiAqXG4gKiB3aGVlbHNbMF0uY2FyIC8vIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBSZWZzKGEsIGIpIHtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVmcykpIHtcbiAgICByZXR1cm4gbmV3IFJlZnMoYSwgYik7XG4gIH1cblxuICAvLyBsaW5rXG4gIGEuaW52ZXJzZSA9IGI7XG4gIGIuaW52ZXJzZSA9IGE7XG5cbiAgdGhpcy5wcm9wcyA9IHt9O1xuICB0aGlzLnByb3BzW2EubmFtZV0gPSBhO1xuICB0aGlzLnByb3BzW2IubmFtZV0gPSBiO1xufVxuXG4vKipcbiAqIEJpbmRzIG9uZSBzaWRlIG9mIGEgYmktZGlyZWN0aW9uYWwgcmVmZXJlbmNlIHRvIGFcbiAqIHRhcmdldCBvYmplY3QuXG4gKlxuICogQG1lbWJlck9mIFJlZnNcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5SZWZzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdGhpcy5wcm9wc1twcm9wZXJ0eV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJvcGVydHkgPCcgKyBwcm9wZXJ0eSArICc+IGluIHJlZicpO1xuICAgIH1cbiAgICBwcm9wZXJ0eSA9IHRoaXMucHJvcHNbcHJvcGVydHldO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5LmNvbGxlY3Rpb24pIHtcbiAgICBkZWZpbmVDb2xsZWN0aW9uUHJvcGVydHkodGhpcywgcHJvcGVydHksIHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHRhcmdldCk7XG4gIH1cbn07XG5cblJlZnMucHJvdG90eXBlLmVuc3VyZVJlZnNDb2xsZWN0aW9uID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSkge1xuXG4gIHZhciBjb2xsZWN0aW9uID0gdGFyZ2V0W3Byb3BlcnR5Lm5hbWVdO1xuXG4gIGlmICghQ29sbGVjdGlvbi5pc0V4dGVuZGVkKGNvbGxlY3Rpb24pKSB7XG4gICAgZGVmaW5lQ29sbGVjdGlvblByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB0YXJnZXQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59O1xuXG5SZWZzLnByb3RvdHlwZS5lbnN1cmVCb3VuZCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSkge1xuICAgIHRoaXMuYmluZCh0YXJnZXQsIHByb3BlcnR5KTtcbiAgfVxufTtcblxuUmVmcy5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuXG4gIGlmICh0YXJnZXQpIHtcbiAgICB0aGlzLmVuc3VyZUJvdW5kKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgaWYgKHByb3BlcnR5LmNvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuZW5zdXJlUmVmc0NvbGxlY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSkucmVtb3ZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0W3Byb3BlcnR5Lm5hbWVdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufTtcblxuUmVmcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcblxuICBpZiAodGFyZ2V0KSB7XG4gICAgdGhpcy5lbnN1cmVCb3VuZCh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgIGlmIChwcm9wZXJ0eS5jb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLmVuc3VyZVJlZnNDb2xsZWN0aW9uKHRhcmdldCwgcHJvcGVydHkpLmFkZCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFtwcm9wZXJ0eS5uYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWZzO1xuXG5cbi8qKlxuICogQW4gYXR0cmlidXRlIGRlc2NyaXB0b3IgdG8gYmUgdXNlZCBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBpbiBhIHtAbGluayBSZWZzfSBpbnN0YW5jZVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlZnMuQXR0cmlidXRlRGVzY3JpcHRvclxuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbGxlY3Rpb249ZmFsc2VdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlbnVtZXJhYmxlPWZhbHNlXVxuICovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBzb3VyY2UgY29kZSBhZGFwdGVkIGZyb20gU25hcC5zdmcgKGxpY2Vuc2VkIEFwYWNoZS0yLjApLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlLXdlYnBsYXRmb3JtL1NuYXAuc3ZnL2Jsb2IvbWFzdGVyL3NyYy9wYXRoLmpzXG4gKi9cblxuLyogZXNsaW50IG5vLWZhbGx0aHJvdWdoOiBcIm9mZlwiICovXG5cbnZhciBwMnMgPSAvLD8oW2Etel0pLD8vZ2ksXG4gICAgdG9GbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgbWF0aCA9IE1hdGgsXG4gICAgUEkgPSBtYXRoLlBJLFxuICAgIG1taW4gPSBtYXRoLm1pbixcbiAgICBtbWF4ID0gbWF0aC5tYXgsXG4gICAgcG93ID0gbWF0aC5wb3csXG4gICAgYWJzID0gbWF0aC5hYnMsXG4gICAgcGF0aENvbW1hbmQgPSAvKFthLXpdKVtcXHMsXSooKC0/XFxkKlxcLj9cXGQqKD86ZVstK10/XFxkKyk/W1xcc10qLD9bXFxzXSopKykvaWcsXG4gICAgcGF0aFZhbHVlcyA9IC8oLT9cXGQqXFwuP1xcZCooPzplWy0rXT9cXGQrKT8pW1xcc10qLD9bXFxzXSovaWc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvKSB7IHJldHVybiBvIGluc3RhbmNlb2YgQXJyYXk7IH07XG5cbmZ1bmN0aW9uIGhhc1Byb3BlcnR5KG9iaiwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BlcnR5KTtcbn1cblxuZnVuY3Rpb24gY2xvbmUob2JqKSB7XG5cbiAgaWYgKHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZXMgPSBuZXcgb2JqLmNvbnN0cnVjdG9yO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzUHJvcGVydHkob2JqLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGNsb25lKG9ialtrZXldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiByZXB1c2goYXJyYXksIGl0ZW0pIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2goYXJyYXkuc3BsaWNlKGksIDEpWzBdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWNoZXIoZikge1xuXG4gIGZ1bmN0aW9uIG5ld2YoKSB7XG5cbiAgICB2YXIgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgYXJncyA9IGFyZy5qb2luKCdcXHUyNDAwJyksXG4gICAgICAgIGNhY2hlID0gbmV3Zi5jYWNoZSA9IG5ld2YuY2FjaGUgfHwge30sXG4gICAgICAgIGNvdW50ID0gbmV3Zi5jb3VudCA9IG5ld2YuY291bnQgfHwgW107XG5cbiAgICBpZiAoaGFzUHJvcGVydHkoY2FjaGUsIGFyZ3MpKSB7XG4gICAgICByZXB1c2goY291bnQsIGFyZ3MpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FyZ3NdO1xuICAgIH1cblxuICAgIGNvdW50Lmxlbmd0aCA+PSAxZTMgJiYgZGVsZXRlIGNhY2hlW2NvdW50LnNoaWZ0KCldO1xuICAgIGNvdW50LnB1c2goYXJncyk7XG4gICAgY2FjaGVbYXJnc10gPSBmLmFwcGx5KDAsIGFyZyk7XG5cbiAgICByZXR1cm4gY2FjaGVbYXJnc107XG4gIH1cbiAgcmV0dXJuIG5ld2Y7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aFN0cmluZyhwYXRoU3RyaW5nKSB7XG5cbiAgaWYgKCFwYXRoU3RyaW5nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcHRoID0gcGF0aHMocGF0aFN0cmluZyk7XG5cbiAgaWYgKHB0aC5hcnIpIHtcbiAgICByZXR1cm4gY2xvbmUocHRoLmFycik7XG4gIH1cblxuICB2YXIgcGFyYW1Db3VudHMgPSB7IGE6IDcsIGM6IDYsIGg6IDEsIGw6IDIsIG06IDIsIHE6IDQsIHM6IDQsIHQ6IDIsIHY6IDEsIHo6IDAgfSxcbiAgICAgIGRhdGEgPSBbXTtcblxuICBpZiAoaXNBcnJheShwYXRoU3RyaW5nKSAmJiBpc0FycmF5KHBhdGhTdHJpbmdbMF0pKSB7IC8vIHJvdWdoIGFzc3VtcHRpb25cbiAgICBkYXRhID0gY2xvbmUocGF0aFN0cmluZyk7XG4gIH1cblxuICBpZiAoIWRhdGEubGVuZ3RoKSB7XG5cbiAgICBTdHJpbmcocGF0aFN0cmluZykucmVwbGFjZShwYXRoQ29tbWFuZCwgZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgdmFyIHBhcmFtcyA9IFtdLFxuICAgICAgICAgIG5hbWUgPSBiLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGMucmVwbGFjZShwYXRoVmFsdWVzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGIgJiYgcGFyYW1zLnB1c2goK2IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChuYW1lID09ICdtJyAmJiBwYXJhbXMubGVuZ3RoID4gMikge1xuICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIDIpKSk7XG4gICAgICAgIG5hbWUgPSAnbCc7XG4gICAgICAgIGIgPSBiID09ICdtJyA/ICdsJyA6ICdMJztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHBhcmFtcy5sZW5ndGggPj0gcGFyYW1Db3VudHNbbmFtZV0pIHtcbiAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zLnNwbGljZSgwLCBwYXJhbUNvdW50c1tuYW1lXSkpKTtcbiAgICAgICAgaWYgKCFwYXJhbUNvdW50c1tuYW1lXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkYXRhLnRvU3RyaW5nID0gcGF0aHMudG9TdHJpbmc7XG4gIHB0aC5hcnIgPSBjbG9uZShkYXRhKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGF0aHMocHMpIHtcbiAgdmFyIHAgPSBwYXRocy5wcyA9IHBhdGhzLnBzIHx8IHt9O1xuXG4gIGlmIChwW3BzXSkge1xuICAgIHBbcHNdLnNsZWVwID0gMTAwO1xuICB9IGVsc2Uge1xuICAgIHBbcHNdID0ge1xuICAgICAgc2xlZXA6IDEwMFxuICAgIH07XG4gIH1cblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGtleSBpbiBwKSB7XG4gICAgICBpZiAoaGFzUHJvcGVydHkocCwga2V5KSAmJiBrZXkgIT0gcHMpIHtcbiAgICAgICAgcFtrZXldLnNsZWVwLS07XG4gICAgICAgICFwW2tleV0uc2xlZXAgJiYgZGVsZXRlIHBba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwW3BzXTtcbn1cblxuZnVuY3Rpb24gcmVjdEJCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgeSA9IHgueTtcbiAgICB3aWR0aCA9IHgud2lkdGg7XG4gICAgaGVpZ2h0ID0geC5oZWlnaHQ7XG4gICAgeCA9IHgueDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4MjogeCArIHdpZHRoLFxuICAgIHkyOiB5ICsgaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhdGhUb1N0cmluZygpIHtcbiAgcmV0dXJuIHRoaXMuam9pbignLCcpLnJlcGxhY2UocDJzLCAnJDEnKTtcbn1cblxuZnVuY3Rpb24gcGF0aENsb25lKHBhdGhBcnJheSkge1xuICB2YXIgcmVzID0gY2xvbmUocGF0aEFycmF5KTtcbiAgcmVzLnRvU3RyaW5nID0gcGF0aFRvU3RyaW5nO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBmaW5kRG90c0F0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgdCkge1xuICB2YXIgdDEgPSAxIC0gdCxcbiAgICAgIHQxMyA9IHBvdyh0MSwgMyksXG4gICAgICB0MTIgPSBwb3codDEsIDIpLFxuICAgICAgdDIgPSB0ICogdCxcbiAgICAgIHQzID0gdDIgKiB0LFxuICAgICAgeCA9IHQxMyAqIHAxeCArIHQxMiAqIDMgKiB0ICogYzF4ICsgdDEgKiAzICogdCAqIHQgKiBjMnggKyB0MyAqIHAyeCxcbiAgICAgIHkgPSB0MTMgKiBwMXkgKyB0MTIgKiAzICogdCAqIGMxeSArIHQxICogMyAqIHQgKiB0ICogYzJ5ICsgdDMgKiBwMnk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBmaXhFcnJvcih4KSxcbiAgICB5OiBmaXhFcnJvcih5KVxuICB9O1xufVxuXG5mdW5jdGlvbiBiZXppZXJCQm94KHBvaW50cykge1xuXG4gIHZhciBiYm94ID0gY3VydmVCQm94LmFwcGx5KG51bGwsIHBvaW50cyk7XG5cbiAgcmV0dXJuIHJlY3RCQm94KFxuICAgIGJib3gueDAsXG4gICAgYmJveC55MCxcbiAgICBiYm94LngxIC0gYmJveC54MCxcbiAgICBiYm94LnkxIC0gYmJveC55MFxuICApO1xufVxuXG5mdW5jdGlvbiBpc1BvaW50SW5zaWRlQkJveChiYm94LCB4LCB5KSB7XG4gIHJldHVybiB4ID49IGJib3gueCAmJlxuICAgIHggPD0gYmJveC54ICsgYmJveC53aWR0aCAmJlxuICAgIHkgPj0gYmJveC55ICYmXG4gICAgeSA8PSBiYm94LnkgKyBiYm94LmhlaWdodDtcbn1cblxuZnVuY3Rpb24gaXNCQm94SW50ZXJzZWN0KGJib3gxLCBiYm94Mikge1xuICBiYm94MSA9IHJlY3RCQm94KGJib3gxKTtcbiAgYmJveDIgPSByZWN0QkJveChiYm94Mik7XG4gIHJldHVybiBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueCwgYmJveDEueSlcbiAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueDIsIGJib3gxLnkpXG4gICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngsIGJib3gxLnkyKVxuICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gyLCBiYm94MS54MiwgYmJveDEueTIpXG4gICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngsIGJib3gyLnkpXG4gICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55KVxuICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54LCBiYm94Mi55MilcbiAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueDIsIGJib3gyLnkyKVxuICAgIHx8IChiYm94MS54IDwgYmJveDIueDIgJiYgYmJveDEueCA+IGJib3gyLnhcbiAgICAgICAgfHwgYmJveDIueCA8IGJib3gxLngyICYmIGJib3gyLnggPiBiYm94MS54KVxuICAgICYmIChiYm94MS55IDwgYmJveDIueTIgJiYgYmJveDEueSA+IGJib3gyLnlcbiAgICAgICAgfHwgYmJveDIueSA8IGJib3gxLnkyICYmIGJib3gyLnkgPiBiYm94MS55KTtcbn1cblxuZnVuY3Rpb24gYmFzZTModCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgdmFyIHQxID0gLTMgKiBwMSArIDkgKiBwMiAtIDkgKiBwMyArIDMgKiBwNCxcbiAgICAgIHQyID0gdCAqIHQxICsgNiAqIHAxIC0gMTIgKiBwMiArIDYgKiBwMztcbiAgcmV0dXJuIHQgKiB0MiAtIDMgKiBwMSArIDMgKiBwMjtcbn1cblxuZnVuY3Rpb24gYmV6bGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgeikge1xuXG4gIGlmICh6ID09IG51bGwpIHtcbiAgICB6ID0gMTtcbiAgfVxuXG4gIHogPSB6ID4gMSA/IDEgOiB6IDwgMCA/IDAgOiB6O1xuXG4gIHZhciB6MiA9IHogLyAyLFxuICAgICAgbiA9IDEyLFxuICAgICAgVHZhbHVlcyA9IFstLjEyNTIsLjEyNTIsLS4zNjc4LC4zNjc4LC0uNTg3MywuNTg3MywtLjc2OTksLjc2OTksLS45MDQxLC45MDQxLC0uOTgxNiwuOTgxNl0sXG4gICAgICBDdmFsdWVzID0gWzAuMjQ5MSwwLjI0OTEsMC4yMzM1LDAuMjMzNSwwLjIwMzIsMC4yMDMyLDAuMTYwMSwwLjE2MDEsMC4xMDY5LDAuMTA2OSwwLjA0NzIsMC4wNDcyXSxcbiAgICAgIHN1bSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgY3QgPSB6MiAqIFR2YWx1ZXNbaV0gKyB6MixcbiAgICAgICAgeGJhc2UgPSBiYXNlMyhjdCwgeDEsIHgyLCB4MywgeDQpLFxuICAgICAgICB5YmFzZSA9IGJhc2UzKGN0LCB5MSwgeTIsIHkzLCB5NCksXG4gICAgICAgIGNvbWIgPSB4YmFzZSAqIHhiYXNlICsgeWJhc2UgKiB5YmFzZTtcblxuICAgIHN1bSArPSBDdmFsdWVzW2ldICogbWF0aC5zcXJ0KGNvbWIpO1xuICB9XG5cbiAgcmV0dXJuIHoyICogc3VtO1xufVxuXG5cbmZ1bmN0aW9uIGludGVyc2VjdExpbmVzKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCkge1xuXG4gIGlmIChcbiAgICBtbWF4KHgxLCB4MikgPCBtbWluKHgzLCB4NCkgfHxcbiAgICAgIG1taW4oeDEsIHgyKSA+IG1tYXgoeDMsIHg0KSB8fFxuICAgICAgbW1heCh5MSwgeTIpIDwgbW1pbih5MywgeTQpIHx8XG4gICAgICBtbWluKHkxLCB5MikgPiBtbWF4KHkzLCB5NClcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG54ID0gKHgxICogeTIgLSB5MSAqIHgyKSAqICh4MyAtIHg0KSAtICh4MSAtIHgyKSAqICh4MyAqIHk0IC0geTMgKiB4NCksXG4gICAgICBueSA9ICh4MSAqIHkyIC0geTEgKiB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgKiB5NCAtIHkzICogeDQpLFxuICAgICAgZGVub21pbmF0b3IgPSAoeDEgLSB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgLSB4NCk7XG5cbiAgaWYgKCFkZW5vbWluYXRvcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBweCA9IGZpeEVycm9yKG54IC8gZGVub21pbmF0b3IpLFxuICAgICAgcHkgPSBmaXhFcnJvcihueSAvIGRlbm9taW5hdG9yKSxcbiAgICAgIHB4MiA9ICtweC50b0ZpeGVkKDIpLFxuICAgICAgcHkyID0gK3B5LnRvRml4ZWQoMik7XG5cbiAgaWYgKFxuICAgIHB4MiA8ICttbWluKHgxLCB4MikudG9GaXhlZCgyKSB8fFxuICAgICAgcHgyID4gK21tYXgoeDEsIHgyKS50b0ZpeGVkKDIpIHx8XG4gICAgICBweDIgPCArbW1pbih4MywgeDQpLnRvRml4ZWQoMikgfHxcbiAgICAgIHB4MiA+ICttbWF4KHgzLCB4NCkudG9GaXhlZCgyKSB8fFxuICAgICAgcHkyIDwgK21taW4oeTEsIHkyKS50b0ZpeGVkKDIpIHx8XG4gICAgICBweTIgPiArbW1heCh5MSwgeTIpLnRvRml4ZWQoMikgfHxcbiAgICAgIHB5MiA8ICttbWluKHkzLCB5NCkudG9GaXhlZCgyKSB8fFxuICAgICAgcHkyID4gK21tYXgoeTMsIHk0KS50b0ZpeGVkKDIpXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiB7IHg6IHB4LCB5OiBweSB9O1xufVxuXG5mdW5jdGlvbiBmaXhFcnJvcihudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogMTAwMDAwMDAwMDAwKSAvIDEwMDAwMDAwMDAwMDtcbn1cblxuZnVuY3Rpb24gZmluZEJlemllckludGVyc2VjdGlvbnMoYmV6MSwgYmV6MiwganVzdENvdW50KSB7XG4gIHZhciBiYm94MSA9IGJlemllckJCb3goYmV6MSksXG4gICAgICBiYm94MiA9IGJlemllckJCb3goYmV6Mik7XG5cbiAgaWYgKCFpc0JCb3hJbnRlcnNlY3QoYmJveDEsIGJib3gyKSkge1xuICAgIHJldHVybiBqdXN0Q291bnQgPyAwIDogW107XG4gIH1cblxuICAvLyBBcyBhbiBvcHRpbWl6YXRpb24sIGxpbmVzIHdpbGwgaGF2ZSBvbmx5IDEgc2VnbWVudFxuXG4gIHZhciBsMSA9IGJlemxlbi5hcHBseSgwLCBiZXoxKSxcbiAgICAgIGwyID0gYmV6bGVuLmFwcGx5KDAsIGJlejIpLFxuICAgICAgbjEgPSBpc0xpbmUoYmV6MSkgPyAxIDogfn4obDEgLyA1KSB8fCAxLFxuICAgICAgbjIgPSBpc0xpbmUoYmV6MikgPyAxIDogfn4obDIgLyA1KSB8fCAxLFxuICAgICAgZG90czEgPSBbXSxcbiAgICAgIGRvdHMyID0gW10sXG4gICAgICB4eSA9IHt9LFxuICAgICAgcmVzID0ganVzdENvdW50ID8gMCA6IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjEgKyAxOyBpKyspIHtcbiAgICB2YXIgcCA9IGZpbmREb3RzQXRTZWdtZW50LmFwcGx5KDAsIGJlejEuY29uY2F0KGkgLyBuMSkpO1xuICAgIGRvdHMxLnB1c2goeyB4OiBwLngsIHk6IHAueSwgdDogaSAvIG4xIH0pO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG4yICsgMTsgaSsrKSB7XG4gICAgcCA9IGZpbmREb3RzQXRTZWdtZW50LmFwcGx5KDAsIGJlejIuY29uY2F0KGkgLyBuMikpO1xuICAgIGRvdHMyLnB1c2goeyB4OiBwLngsIHk6IHAueSwgdDogaSAvIG4yIH0pO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG4xOyBpKyspIHtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjI7IGorKykge1xuICAgICAgdmFyIGRpID0gZG90czFbaV0sXG4gICAgICAgICAgZGkxID0gZG90czFbaSArIDFdLFxuICAgICAgICAgIGRqID0gZG90czJbal0sXG4gICAgICAgICAgZGoxID0gZG90czJbaiArIDFdLFxuICAgICAgICAgIGNpID0gYWJzKGRpMS54IC0gZGkueCkgPCAuMDEgPyAneScgOiAneCcsXG4gICAgICAgICAgY2ogPSBhYnMoZGoxLnggLSBkai54KSA8IC4wMSA/ICd5JyA6ICd4JyxcbiAgICAgICAgICBpcyA9IGludGVyc2VjdExpbmVzKGRpLngsIGRpLnksIGRpMS54LCBkaTEueSwgZGoueCwgZGoueSwgZGoxLngsIGRqMS55KSxcbiAgICAgICAgICBrZXk7XG5cbiAgICAgIGlmIChpcykge1xuICAgICAgICBrZXkgPSBpcy54LnRvRml4ZWQoOSkgKyAnIycgKyBpcy55LnRvRml4ZWQoOSk7XG5cbiAgICAgICAgaWYgKHh5W2tleV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHh5W2tleV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciB0MSA9IGRpLnQgKyBhYnMoKGlzW2NpXSAtIGRpW2NpXSkgLyAoZGkxW2NpXSAtIGRpW2NpXSkpICogKGRpMS50IC0gZGkudCksXG4gICAgICAgICAgICB0MiA9IGRqLnQgKyBhYnMoKGlzW2NqXSAtIGRqW2NqXSkgLyAoZGoxW2NqXSAtIGRqW2NqXSkpICogKGRqMS50IC0gZGoudCk7XG5cbiAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSAmJiB0MiA+PSAwICYmIHQyIDw9IDEpIHtcblxuICAgICAgICAgIGlmIChqdXN0Q291bnQpIHtcbiAgICAgICAgICAgIHJlcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICAgIHg6IGlzLngsXG4gICAgICAgICAgICAgIHk6IGlzLnksXG4gICAgICAgICAgICAgIHQxOiB0MSxcbiAgICAgICAgICAgICAgdDI6IHQyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5cbi8qKlxuICogRmluZCBvciBjb3VudHMgdGhlIGludGVyc2VjdGlvbnMgYmV0d2VlbiB0d28gU1ZHIHBhdGhzLlxuICpcbiAqIFJldHVybnMgYSBudW1iZXIgaW4gY291bnRpbmcgbW9kZSBhbmQgYSBsaXN0IG9mIGludGVyc2VjdGlvbnMgb3RoZXJ3aXNlLlxuICpcbiAqIEEgc2luZ2xlIGludGVyc2VjdGlvbiBlbnRyeSBjb250YWlucyB0aGUgaW50ZXJzZWN0aW9uIGNvb3JkaW5hdGVzICh4LCB5KVxuICogYXMgd2VsbCBhcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyB0aGUgaW50ZXJzZWN0aW5nIHNlZ21lbnRzXG4gKiBvbiBlYWNoIHBhdGggKHNlZ21lbnQxLCBzZWdtZW50MikgYW5kIHRoZSByZWxhdGl2ZSBsb2NhdGlvbiBvZiB0aGVcbiAqIGludGVyc2VjdGlvbiBvbiB0aGVzZSBzZWdtZW50cyAodDEsIHQyKS5cbiAqXG4gKiBUaGUgcGF0aCBtYXkgYmUgYW4gU1ZHIHBhdGggc3RyaW5nIG9yIGEgbGlzdCBvZiBwYXRoIGNvbXBvbmVudHNcbiAqIHN1Y2ggYXMgYFsgWyAnTScsIDAsIDEwIF0sIFsgJ0wnLCAyMCwgMCBdIF1gLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGludGVyc2VjdGlvbnMgPSBmaW5kUGF0aEludGVyc2VjdGlvbnMoXG4gKiAgICdNMCwwTDEwMCwxMDAnLFxuICogICBbIFsgJ00nLCAwLCAxMDAgXSwgWyAnTCcsIDEwMCwgMCBdIF1cbiAqICk7XG4gKlxuICogLy8gaW50ZXJzZWN0aW9ucyA9IFtcbiAqIC8vICAgeyB4OiA1MCwgeTogNTAsIHNlZ21lbnQxOiAxLCBzZWdtZW50MjogMSwgdDE6IDAuNSwgdDI6IDAuNSB9XG4gKiAvLyBdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXk8UGF0aERlZj59IHBhdGgxXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheTxQYXRoRGVmPn0gcGF0aDJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2p1c3RDb3VudD1mYWxzZV1cbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxJbnRlcnNlY3Rpb24+fE51bWJlcn1cbiAqL1xuZnVuY3Rpb24gZmluZFBhdGhJbnRlcnNlY3Rpb25zKHBhdGgxLCBwYXRoMiwganVzdENvdW50KSB7XG4gIHBhdGgxID0gcGF0aFRvQ3VydmUocGF0aDEpO1xuICBwYXRoMiA9IHBhdGhUb0N1cnZlKHBhdGgyKTtcblxuICB2YXIgeDEsIHkxLCB4MiwgeTIsIHgxbSwgeTFtLCB4Mm0sIHkybSwgYmV6MSwgYmV6MixcbiAgICAgIHJlcyA9IGp1c3RDb3VudCA/IDAgOiBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXRoMS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIHBpID0gcGF0aDFbaV07XG5cbiAgICBpZiAocGlbMF0gPT0gJ00nKSB7XG4gICAgICB4MSA9IHgxbSA9IHBpWzFdO1xuICAgICAgeTEgPSB5MW0gPSBwaVsyXTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAocGlbMF0gPT0gJ0MnKSB7XG4gICAgICAgIGJlejEgPSBbeDEsIHkxXS5jb25jYXQocGkuc2xpY2UoMSkpO1xuICAgICAgICB4MSA9IGJlejFbNl07XG4gICAgICAgIHkxID0gYmV6MVs3XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlejEgPSBbeDEsIHkxLCB4MSwgeTEsIHgxbSwgeTFtLCB4MW0sIHkxbV07XG4gICAgICAgIHgxID0geDFtO1xuICAgICAgICB5MSA9IHkxbTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcGF0aDIubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICB2YXIgcGogPSBwYXRoMltqXTtcblxuICAgICAgICBpZiAocGpbMF0gPT0gJ00nKSB7XG4gICAgICAgICAgeDIgPSB4Mm0gPSBwalsxXTtcbiAgICAgICAgICB5MiA9IHkybSA9IHBqWzJdO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKHBqWzBdID09ICdDJykge1xuICAgICAgICAgICAgYmV6MiA9IFt4MiwgeTJdLmNvbmNhdChwai5zbGljZSgxKSk7XG4gICAgICAgICAgICB4MiA9IGJlejJbNl07XG4gICAgICAgICAgICB5MiA9IGJlejJbN107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyLCB4MiwgeTIsIHgybSwgeTJtLCB4Mm0sIHkybV07XG4gICAgICAgICAgICB4MiA9IHgybTtcbiAgICAgICAgICAgIHkyID0geTJtO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbnRyID0gZmluZEJlemllckludGVyc2VjdGlvbnMoYmV6MSwgYmV6MiwganVzdENvdW50KTtcblxuICAgICAgICAgIGlmIChqdXN0Q291bnQpIHtcbiAgICAgICAgICAgIHJlcyArPSBpbnRyO1xuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IGludHIubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICAgICAgICBpbnRyW2tdLnNlZ21lbnQxID0gaTtcbiAgICAgICAgICAgICAgaW50cltrXS5zZWdtZW50MiA9IGo7XG4gICAgICAgICAgICAgIGludHJba10uYmV6MSA9IGJlejE7XG4gICAgICAgICAgICAgIGludHJba10uYmV6MiA9IGJlejI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoaW50cik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuXG5mdW5jdGlvbiBwYXRoVG9BYnNvbHV0ZShwYXRoQXJyYXkpIHtcbiAgdmFyIHB0aCA9IHBhdGhzKHBhdGhBcnJheSk7XG5cbiAgaWYgKHB0aC5hYnMpIHtcbiAgICByZXR1cm4gcGF0aENsb25lKHB0aC5hYnMpO1xuICB9XG5cbiAgaWYgKCFpc0FycmF5KHBhdGhBcnJheSkgfHwgIWlzQXJyYXkocGF0aEFycmF5ICYmIHBhdGhBcnJheVswXSkpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgIHBhdGhBcnJheSA9IHBhcnNlUGF0aFN0cmluZyhwYXRoQXJyYXkpO1xuICB9XG5cbiAgaWYgKCFwYXRoQXJyYXkgfHwgIXBhdGhBcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gW1snTScsIDAsIDBdXTtcbiAgfVxuXG4gIHZhciByZXMgPSBbXSxcbiAgICAgIHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICBteCA9IDAsXG4gICAgICBteSA9IDAsXG4gICAgICBzdGFydCA9IDAsXG4gICAgICBwYTA7XG5cbiAgaWYgKHBhdGhBcnJheVswXVswXSA9PSAnTScpIHtcbiAgICB4ID0gK3BhdGhBcnJheVswXVsxXTtcbiAgICB5ID0gK3BhdGhBcnJheVswXVsyXTtcbiAgICBteCA9IHg7XG4gICAgbXkgPSB5O1xuICAgIHN0YXJ0Kys7XG4gICAgcmVzWzBdID0gWydNJywgeCwgeV07XG4gIH1cblxuICBmb3IgKHZhciByLCBwYSwgaSA9IHN0YXJ0LCBpaSA9IHBhdGhBcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgcmVzLnB1c2gociA9IFtdKTtcbiAgICBwYSA9IHBhdGhBcnJheVtpXTtcbiAgICBwYTAgPSBwYVswXTtcblxuICAgIGlmIChwYTAgIT0gcGEwLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIHJbMF0gPSBwYTAudG9VcHBlckNhc2UoKTtcblxuICAgICAgc3dpdGNoIChyWzBdKSB7XG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgclsxXSA9IHBhWzFdO1xuICAgICAgICByWzJdID0gcGFbMl07XG4gICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgcls0XSA9IHBhWzRdO1xuICAgICAgICByWzVdID0gcGFbNV07XG4gICAgICAgIHJbNl0gPSArcGFbNl0gKyB4O1xuICAgICAgICByWzddID0gK3BhWzddICsgeTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdWJzpcbiAgICAgICAgclsxXSA9ICtwYVsxXSArIHk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSCc6XG4gICAgICAgIHJbMV0gPSArcGFbMV0gKyB4O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICBteCA9ICtwYVsxXSArIHg7XG4gICAgICAgIG15ID0gK3BhWzJdICsgeTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZvciAodmFyIGogPSAxLCBqaiA9IHBhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICByW2pdID0gK3BhW2pdICsgKChqICUgMikgPyB4IDogeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgayA9IDAsIGtrID0gcGEubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICByW2tdID0gcGFba107XG4gICAgICB9XG4gICAgfVxuICAgIHBhMCA9IHBhMC50b1VwcGVyQ2FzZSgpO1xuXG4gICAgc3dpdGNoIChyWzBdKSB7XG4gICAgY2FzZSAnWic6XG4gICAgICB4ID0gK214O1xuICAgICAgeSA9ICtteTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0gnOlxuICAgICAgeCA9IHJbMV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdWJzpcbiAgICAgIHkgPSByWzFdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTSc6XG4gICAgICBteCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgIG15ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgIGRlZmF1bHQ6XG4gICAgICB4ID0gcltyLmxlbmd0aCAtIDJdO1xuICAgICAgeSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH1cblxuICByZXMudG9TdHJpbmcgPSBwYXRoVG9TdHJpbmc7XG4gIHB0aC5hYnMgPSBwYXRoQ2xvbmUocmVzKTtcblxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBpc0xpbmUoYmV6KSB7XG4gIHJldHVybiAoXG4gICAgYmV6WzBdID09PSBiZXpbMl0gJiZcbiAgICBiZXpbMV0gPT09IGJlelszXSAmJlxuICAgIGJlels0XSA9PT0gYmV6WzZdICYmXG4gICAgYmV6WzVdID09PSBiZXpbN11cbiAgKTtcbn1cblxuZnVuY3Rpb24gbGluZVRvQ3VydmUoeDEsIHkxLCB4MiwgeTIpIHtcbiAgcmV0dXJuIFtcbiAgICB4MSwgeTEsIHgyLFxuICAgIHkyLCB4MiwgeTJcbiAgXTtcbn1cblxuZnVuY3Rpb24gcXViaWNUb0N1cnZlKHgxLCB5MSwgYXgsIGF5LCB4MiwgeTIpIHtcbiAgdmFyIF8xMyA9IDEgLyAzLFxuICAgICAgXzIzID0gMiAvIDM7XG5cbiAgcmV0dXJuIFtcbiAgICBfMTMgKiB4MSArIF8yMyAqIGF4LFxuICAgIF8xMyAqIHkxICsgXzIzICogYXksXG4gICAgXzEzICogeDIgKyBfMjMgKiBheCxcbiAgICBfMTMgKiB5MiArIF8yMyAqIGF5LFxuICAgIHgyLFxuICAgIHkyXG4gIF07XG59XG5cbmZ1bmN0aW9uIGFyY1RvQ3VydmUoeDEsIHkxLCByeCwgcnksIGFuZ2xlLCBsYXJnZV9hcmNfZmxhZywgc3dlZXBfZmxhZywgeDIsIHkyLCByZWN1cnNpdmUpIHtcblxuICAvLyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvZiB3aGVyZSB0aGlzIG1hdGggY2FtZSBmcm9tIHZpc2l0OlxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbiAgdmFyIF8xMjAgPSBQSSAqIDEyMCAvIDE4MCxcbiAgICAgIHJhZCA9IFBJIC8gMTgwICogKCthbmdsZSB8fCAwKSxcbiAgICAgIHJlcyA9IFtdLFxuICAgICAgeHksXG4gICAgICByb3RhdGUgPSBjYWNoZXIoZnVuY3Rpb24oeCwgeSwgcmFkKSB7XG4gICAgICAgIHZhciBYID0geCAqIG1hdGguY29zKHJhZCkgLSB5ICogbWF0aC5zaW4ocmFkKSxcbiAgICAgICAgICAgIFkgPSB4ICogbWF0aC5zaW4ocmFkKSArIHkgKiBtYXRoLmNvcyhyYWQpO1xuXG4gICAgICAgIHJldHVybiB7IHg6IFgsIHk6IFkgfTtcbiAgICAgIH0pO1xuXG4gIGlmICghcmVjdXJzaXZlKSB7XG4gICAgeHkgPSByb3RhdGUoeDEsIHkxLCAtcmFkKTtcbiAgICB4MSA9IHh5Lng7XG4gICAgeTEgPSB4eS55O1xuICAgIHh5ID0gcm90YXRlKHgyLCB5MiwgLXJhZCk7XG4gICAgeDIgPSB4eS54O1xuICAgIHkyID0geHkueTtcblxuICAgIHZhciB4ID0gKHgxIC0geDIpIC8gMixcbiAgICAgICAgeSA9ICh5MSAtIHkyKSAvIDI7XG5cbiAgICB2YXIgaCA9ICh4ICogeCkgLyAocnggKiByeCkgKyAoeSAqIHkpIC8gKHJ5ICogcnkpO1xuXG4gICAgaWYgKGggPiAxKSB7XG4gICAgICBoID0gbWF0aC5zcXJ0KGgpO1xuICAgICAgcnggPSBoICogcng7XG4gICAgICByeSA9IGggKiByeTtcbiAgICB9XG5cbiAgICB2YXIgcngyID0gcnggKiByeCxcbiAgICAgICAgcnkyID0gcnkgKiByeSxcbiAgICAgICAgayA9IChsYXJnZV9hcmNfZmxhZyA9PSBzd2VlcF9mbGFnID8gLTEgOiAxKSAqXG4gICAgICAgICAgICBtYXRoLnNxcnQoYWJzKChyeDIgKiByeTIgLSByeDIgKiB5ICogeSAtIHJ5MiAqIHggKiB4KSAvIChyeDIgKiB5ICogeSArIHJ5MiAqIHggKiB4KSkpLFxuICAgICAgICBjeCA9IGsgKiByeCAqIHkgLyByeSArICh4MSArIHgyKSAvIDIsXG4gICAgICAgIGN5ID0gayAqIC1yeSAqIHggLyByeCArICh5MSArIHkyKSAvIDIsXG4gICAgICAgIGYxID0gbWF0aC5hc2luKCgoeTEgLSBjeSkgLyByeSkudG9GaXhlZCg5KSksXG4gICAgICAgIGYyID0gbWF0aC5hc2luKCgoeTIgLSBjeSkgLyByeSkudG9GaXhlZCg5KSk7XG5cbiAgICBmMSA9IHgxIDwgY3ggPyBQSSAtIGYxIDogZjE7XG4gICAgZjIgPSB4MiA8IGN4ID8gUEkgLSBmMiA6IGYyO1xuICAgIGYxIDwgMCAmJiAoZjEgPSBQSSAqIDIgKyBmMSk7XG4gICAgZjIgPCAwICYmIChmMiA9IFBJICogMiArIGYyKTtcblxuICAgIGlmIChzd2VlcF9mbGFnICYmIGYxID4gZjIpIHtcbiAgICAgIGYxID0gZjEgLSBQSSAqIDI7XG4gICAgfVxuICAgIGlmICghc3dlZXBfZmxhZyAmJiBmMiA+IGYxKSB7XG4gICAgICBmMiA9IGYyIC0gUEkgKiAyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmMSA9IHJlY3Vyc2l2ZVswXTtcbiAgICBmMiA9IHJlY3Vyc2l2ZVsxXTtcbiAgICBjeCA9IHJlY3Vyc2l2ZVsyXTtcbiAgICBjeSA9IHJlY3Vyc2l2ZVszXTtcbiAgfVxuXG4gIHZhciBkZiA9IGYyIC0gZjE7XG5cbiAgaWYgKGFicyhkZikgPiBfMTIwKSB7XG4gICAgdmFyIGYyb2xkID0gZjIsXG4gICAgICAgIHgyb2xkID0geDIsXG4gICAgICAgIHkyb2xkID0geTI7XG5cbiAgICBmMiA9IGYxICsgXzEyMCAqIChzd2VlcF9mbGFnICYmIGYyID4gZjEgPyAxIDogLTEpO1xuICAgIHgyID0gY3ggKyByeCAqIG1hdGguY29zKGYyKTtcbiAgICB5MiA9IGN5ICsgcnkgKiBtYXRoLnNpbihmMik7XG4gICAgcmVzID0gYXJjVG9DdXJ2ZSh4MiwgeTIsIHJ4LCByeSwgYW5nbGUsIDAsIHN3ZWVwX2ZsYWcsIHgyb2xkLCB5Mm9sZCwgW2YyLCBmMm9sZCwgY3gsIGN5XSk7XG4gIH1cblxuICBkZiA9IGYyIC0gZjE7XG5cbiAgdmFyIGMxID0gbWF0aC5jb3MoZjEpLFxuICAgICAgczEgPSBtYXRoLnNpbihmMSksXG4gICAgICBjMiA9IG1hdGguY29zKGYyKSxcbiAgICAgIHMyID0gbWF0aC5zaW4oZjIpLFxuICAgICAgdCA9IG1hdGgudGFuKGRmIC8gNCksXG4gICAgICBoeCA9IDQgLyAzICogcnggKiB0LFxuICAgICAgaHkgPSA0IC8gMyAqIHJ5ICogdCxcbiAgICAgIG0xID0gW3gxLCB5MV0sXG4gICAgICBtMiA9IFt4MSArIGh4ICogczEsIHkxIC0gaHkgKiBjMV0sXG4gICAgICBtMyA9IFt4MiArIGh4ICogczIsIHkyIC0gaHkgKiBjMl0sXG4gICAgICBtNCA9IFt4MiwgeTJdO1xuXG4gIG0yWzBdID0gMiAqIG0xWzBdIC0gbTJbMF07XG4gIG0yWzFdID0gMiAqIG0xWzFdIC0gbTJbMV07XG5cbiAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgIHJldHVybiBbbTIsIG0zLCBtNF0uY29uY2F0KHJlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzID0gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpLmpvaW4oKS5zcGxpdCgnLCcpO1xuICAgIHZhciBuZXdyZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHJlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBuZXdyZXNbaV0gPSBpICUgMiA/IHJvdGF0ZShyZXNbaSAtIDFdLCByZXNbaV0sIHJhZCkueSA6IHJvdGF0ZShyZXNbaV0sIHJlc1tpICsgMV0sIHJhZCkueDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3cmVzO1xuICB9XG59XG5cbi8vIFJldHVybnMgYm91bmRpbmcgYm94IG9mIGN1YmljIGJlemllciBjdXJ2ZS5cbi8vIFNvdXJjZTogaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG4vLyBPcmlnaW5hbCB2ZXJzaW9uOiBOSVNISU8gSGlyb2thenVcbi8vIE1vZGlmaWNhdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vMjIzNDVcbmZ1bmN0aW9uIGN1cnZlQkJveCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIHR2YWx1ZXMgPSBbXSxcbiAgICAgIGJvdW5kcyA9IFtbXSwgW11dLFxuICAgICAgYSwgYiwgYywgdCwgdDEsIHQyLCBiMmFjLCBzcXJ0YjJhYztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuXG4gICAgaWYgKGkgPT0gMCkge1xuICAgICAgYiA9IDYgKiB4MCAtIDEyICogeDEgKyA2ICogeDI7XG4gICAgICBhID0gLTMgKiB4MCArIDkgKiB4MSAtIDkgKiB4MiArIDMgKiB4MztcbiAgICAgIGMgPSAzICogeDEgLSAzICogeDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgIH1cblxuICAgIGlmIChhYnMoYSkgPCAxZS0xMikge1xuXG4gICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHQgPSAtYyAvIGI7XG5cbiAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcbiAgICBzcXJ0YjJhYyA9IG1hdGguc3FydChiMmFjKTtcblxuICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuXG4gICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgfVxuXG4gICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuXG4gICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGogPSB0dmFsdWVzLmxlbmd0aCxcbiAgICAgIGpsZW4gPSBqLFxuICAgICAgbXQ7XG5cbiAgd2hpbGUgKGotLSkge1xuICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgIG10ID0gMSAtIHQ7XG4gICAgYm91bmRzWzBdW2pdID0gKG10ICogbXQgKiBtdCAqIHgwKSArICgzICogbXQgKiBtdCAqIHQgKiB4MSkgKyAoMyAqIG10ICogdCAqIHQgKiB4MikgKyAodCAqIHQgKiB0ICogeDMpO1xuICAgIGJvdW5kc1sxXVtqXSA9IChtdCAqIG10ICogbXQgKiB5MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeTEpICsgKDMgKiBtdCAqIHQgKiB0ICogeTIpICsgKHQgKiB0ICogdCAqIHkzKTtcbiAgfVxuXG4gIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgYm91bmRzWzBdW2psZW4gKyAxXSA9IHgzO1xuICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gIGJvdW5kc1swXS5sZW5ndGggPSBib3VuZHNbMV0ubGVuZ3RoID0gamxlbiArIDI7XG5cbiAgcmV0dXJuIHtcbiAgICB4MDogbW1pbi5hcHBseSgwLCBib3VuZHNbMF0pLFxuICAgIHkwOiBtbWluLmFwcGx5KDAsIGJvdW5kc1sxXSksXG4gICAgeDE6IG1tYXguYXBwbHkoMCwgYm91bmRzWzBdKSxcbiAgICB5MTogbW1heC5hcHBseSgwLCBib3VuZHNbMV0pXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhdGhUb0N1cnZlKHBhdGgpIHtcblxuICB2YXIgcHRoID0gcGF0aHMocGF0aCk7XG5cbiAgLy8gcmV0dXJuIGNhY2hlZCBjdXJ2ZSwgaWYgZXhpc3RpbmdcbiAgaWYgKHB0aC5jdXJ2ZSkge1xuICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmN1cnZlKTtcbiAgfVxuXG4gIHZhciBjdXJ2ZWRQYXRoID0gcGF0aFRvQWJzb2x1dGUocGF0aCksXG4gICAgICBhdHRycyA9IHsgeDogMCwgeTogMCwgYng6IDAsIGJ5OiAwLCBYOiAwLCBZOiAwLCBxeDogbnVsbCwgcXk6IG51bGwgfSxcbiAgICAgIHByb2Nlc3NQYXRoID0gZnVuY3Rpb24ocGF0aCwgZCwgcGF0aENvbW1hbmQpIHtcbiAgICAgICAgdmFyIG54LCBueTtcblxuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gWydDJywgZC54LCBkLnksIGQueCwgZC55LCBkLngsIGQueV07XG4gICAgICAgIH1cblxuICAgICAgICAhKHBhdGhbMF0gaW4geyBUOiAxLCBROiAxIH0pICYmIChkLnF4ID0gZC5xeSA9IG51bGwpO1xuXG4gICAgICAgIHN3aXRjaCAocGF0aFswXSkge1xuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICBkLlggPSBwYXRoWzFdO1xuICAgICAgICAgIGQuWSA9IHBhdGhbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQoYXJjVG9DdXJ2ZS5hcHBseSgwLCBbZC54LCBkLnldLmNvbmNhdChwYXRoLnNsaWNlKDEpKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICBpZiAocGF0aENvbW1hbmQgPT0gJ0MnIHx8IHBhdGhDb21tYW5kID09ICdTJykge1xuXG4gICAgICAgICAgICAvLyBJbiAnUycgY2FzZSB3ZSBoYXZlIHRvIHRha2UgaW50byBhY2NvdW50LCBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCBpcyBDL1MuXG4gICAgICAgICAgICBueCA9IGQueCAqIDIgLSBkLmJ4O1xuXG4gICAgICAgICAgICAvLyBBbmQgcmVmbGVjdCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIG55ID0gZC55ICogMiAtIGQuYnk7XG5cbiAgICAgICAgICAgIC8vIGNvbW1hbmQncyBjb250cm9sIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gb3Igc29tZSBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICAgIG54ID0gZC54O1xuICAgICAgICAgICAgbnkgPSBkLnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGggPSBbJ0MnLCBueCwgbnldLmNvbmNhdChwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgaWYgKHBhdGhDb21tYW5kID09ICdRJyB8fCBwYXRoQ29tbWFuZCA9PSAnVCcpIHtcblxuICAgICAgICAgICAgLy8gSW4gJ1QnIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgUS9ULlxuICAgICAgICAgICAgZC5xeCA9IGQueCAqIDIgLSBkLnF4O1xuXG4gICAgICAgICAgICAvLyBBbmQgbWFrZSBhIHJlZmxlY3Rpb24gc2ltaWxhclxuICAgICAgICAgICAgZC5xeSA9IGQueSAqIDIgLSBkLnF5O1xuXG4gICAgICAgICAgICAvLyB0byBjYXNlICdTJy5cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIG9yIHNvbWV0aGluZyBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICAgIGQucXggPSBkLng7XG4gICAgICAgICAgICBkLnF5ID0gZC55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KHF1YmljVG9DdXJ2ZShkLngsIGQueSwgZC5xeCwgZC5xeSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICBkLnF4ID0gcGF0aFsxXTtcbiAgICAgICAgICBkLnF5ID0gcGF0aFsyXTtcbiAgICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KHF1YmljVG9DdXJ2ZShkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSwgcGF0aFszXSwgcGF0aFs0XSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KGxpbmVUb0N1cnZlKGQueCwgZC55LCBwYXRoWzFdLCBwYXRoWzJdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQobGluZVRvQ3VydmUoZC54LCBkLnksIHBhdGhbMV0sIGQueSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KGxpbmVUb0N1cnZlKGQueCwgZC55LCBkLngsIHBhdGhbMV0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChsaW5lVG9DdXJ2ZShkLngsIGQueSwgZC5YLCBkLlkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfSxcblxuICAgICAgZml4QXJjID0gZnVuY3Rpb24ocHAsIGkpIHtcblxuICAgICAgICBpZiAocHBbaV0ubGVuZ3RoID4gNykge1xuICAgICAgICAgIHBwW2ldLnNoaWZ0KCk7XG4gICAgICAgICAgdmFyIHBpID0gcHBbaV07XG5cbiAgICAgICAgICB3aGlsZSAocGkubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXRoQ29tbWFuZHNbaV0gPSAnQSc7IC8vIGlmIGNyZWF0ZWQgbXVsdGlwbGUgQzpzLCB0aGVpciBvcmlnaW5hbCBzZWcgaXMgc2F2ZWRcbiAgICAgICAgICAgIHBwLnNwbGljZShpKyssIDAsIFsnQyddLmNvbmNhdChwaS5zcGxpY2UoMCwgNikpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgaWkgPSBjdXJ2ZWRQYXRoLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcGF0aENvbW1hbmRzID0gW10sIC8vIHBhdGggY29tbWFuZHMgb2Ygb3JpZ2luYWwgcGF0aCBwXG4gICAgICBwZmlyc3QgPSAnJywgLy8gdGVtcG9yYXJ5IGhvbGRlciBmb3Igb3JpZ2luYWwgcGF0aCBjb21tYW5kXG4gICAgICBwYXRoQ29tbWFuZCA9ICcnOyAvLyBob2xkZXIgZm9yIHByZXZpb3VzIHBhdGggY29tbWFuZCBvZiBvcmlnaW5hbCBwYXRoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gY3VydmVkUGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgY3VydmVkUGF0aFtpXSAmJiAocGZpcnN0ID0gY3VydmVkUGF0aFtpXVswXSk7IC8vIHNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcblxuICAgIGlmIChwZmlyc3QgIT0gJ0MnKSAvLyBDIGlzIG5vdCBzYXZlZCB5ZXQsIGJlY2F1c2UgaXQgbWF5IGJlIHJlc3VsdCBvZiBjb252ZXJzaW9uXG4gICAge1xuICAgICAgcGF0aENvbW1hbmRzW2ldID0gcGZpcnN0OyAvLyBTYXZlIGN1cnJlbnQgcGF0aCBjb21tYW5kXG4gICAgICBpICYmIChwYXRoQ29tbWFuZCA9IHBhdGhDb21tYW5kc1tpIC0gMV0pOyAvLyBHZXQgcHJldmlvdXMgcGF0aCBjb21tYW5kIHBhdGhDb21tYW5kXG4gICAgfVxuICAgIGN1cnZlZFBhdGhbaV0gPSBwcm9jZXNzUGF0aChjdXJ2ZWRQYXRoW2ldLCBhdHRycywgcGF0aENvbW1hbmQpOyAvLyBQcmV2aW91cyBwYXRoIGNvbW1hbmQgaXMgaW5wdXR0ZWQgdG8gcHJvY2Vzc1BhdGhcblxuICAgIGlmIChwYXRoQ29tbWFuZHNbaV0gIT0gJ0EnICYmIHBmaXJzdCA9PSAnQycpIHBhdGhDb21tYW5kc1tpXSA9ICdDJzsgLy8gQSBpcyB0aGUgb25seSBjb21tYW5kXG4gICAgLy8gd2hpY2ggbWF5IHByb2R1Y2UgbXVsdGlwbGUgQzpzXG4gICAgLy8gc28gd2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCBDIGlzIGFsc28gQyBpbiBvcmlnaW5hbCBwYXRoXG5cbiAgICBmaXhBcmMoY3VydmVkUGF0aCwgaSk7IC8vIGZpeEFyYyBhZGRzIGFsc28gdGhlIHJpZ2h0IGFtb3VudCBvZiBBOnMgdG8gcGF0aENvbW1hbmRzXG5cbiAgICB2YXIgc2VnID0gY3VydmVkUGF0aFtpXSxcbiAgICAgICAgc2VnbGVuID0gc2VnLmxlbmd0aDtcblxuICAgIGF0dHJzLnggPSBzZWdbc2VnbGVuIC0gMl07XG4gICAgYXR0cnMueSA9IHNlZ1tzZWdsZW4gLSAxXTtcbiAgICBhdHRycy5ieCA9IHRvRmxvYXQoc2VnW3NlZ2xlbiAtIDRdKSB8fCBhdHRycy54O1xuICAgIGF0dHJzLmJ5ID0gdG9GbG9hdChzZWdbc2VnbGVuIC0gM10pIHx8IGF0dHJzLnk7XG4gIH1cblxuICAvLyBjYWNoZSBjdXJ2ZVxuICBwdGguY3VydmUgPSBwYXRoQ2xvbmUoY3VydmVkUGF0aCk7XG5cbiAgcmV0dXJuIGN1cnZlZFBhdGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZFBhdGhJbnRlcnNlY3Rpb25zO1xuIiwidmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBFTlRJVFlfUEFUVEVSTiA9IC8mIyhcXGQrKTt8JiN4KFswLTlhLWZdKyk7fCYoXFx3Kyk7L2lnO1xuXG52YXIgRU5USVRZX01BUFBJTkcgPSB7XG4gICdhbXAnOiAnJicsXG4gICdhcG9zJzogJ1xcJycsXG4gICdndCc6ICc+JyxcbiAgJ2x0JzogJzwnLFxuICAncXVvdCc6ICdcIidcbn07XG5cbi8vIG1hcCBVUFBFUkNBU0UgdmFyaWFudHMgb2Ygc3VwcG9ydGVkIHNwZWNpYWwgY2hhcnNcbk9iamVjdC5rZXlzKEVOVElUWV9NQVBQSU5HKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgRU5USVRZX01BUFBJTkdbay50b1VwcGVyQ2FzZSgpXSA9IEVOVElUWV9NQVBQSU5HW2tdO1xufSk7XG5cblxuZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzKF8sIGQsIHgsIHopIHtcblxuICAvLyByZXNlcnZlZCBuYW1lcywgaS5lLiAmbmJzcDtcbiAgaWYgKHopIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChFTlRJVFlfTUFQUElORywgeikpIHtcbiAgICAgIHJldHVybiBFTlRJVFlfTUFQUElOR1t6XTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBmYWxsIGJhY2sgdG8gb3JpZ2luYWwgdmFsdWVcbiAgICAgIHJldHVybiAnJicgKyB6ICsgJzsnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRlY2ltYWwgZW5jb2RlZCBjaGFyXG4gIGlmIChkKSB7XG4gICAgcmV0dXJuIGZyb21DaGFyQ29kZShkKTtcbiAgfVxuXG4gIC8vIGhleCBlbmNvZGVkIGNoYXJcbiAgcmV0dXJuIGZyb21DaGFyQ29kZShwYXJzZUludCh4LCAxNikpO1xufVxuXG5cbi8qKlxuICogQSBiYXNpYyBlbnRpdHkgZGVjb2RlciB0aGF0IGNhbiBkZWNvZGUgYSBtaW5pbWFsXG4gKiBzdWItc2V0IG9mIHJlc2VydmVkIG5hbWVzICgmYW1wOykgYXMgd2VsbCBhc1xuICogaGV4ICgmI3hhYWY7KSBhbmQgZGVjaW1hbCAoJiMxMjMxOykgZW5jb2RlZCBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGRlY29kZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUVudGl0aWVzKHMpIHtcbiAgaWYgKHMubGVuZ3RoID4gMyAmJiBzLmluZGV4T2YoJyYnKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKEVOVElUWV9QQVRURVJOLCByZXBsYWNlRW50aXRpZXMpO1xuICB9XG5cbiAgcmV0dXJuIHM7XG59XG5cbnZhciBYU0lfVVJJID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlJztcbnZhciBYU0lfUFJFRklYID0gJ3hzaSc7XG52YXIgWFNJX1RZUEUgPSAneHNpOnR5cGUnO1xuXG52YXIgTk9OX1dISVRFU1BBQ0VfT1VUU0lERV9ST09UX05PREUgPSAnbm9uLXdoaXRlc3BhY2Ugb3V0c2lkZSBvZiByb290IG5vZGUnO1xuXG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihtc2cpO1xufVxuXG5mdW5jdGlvbiBtaXNzaW5nTmFtZXNwYWNlRm9yUHJlZml4KHByZWZpeCkge1xuICByZXR1cm4gJ21pc3NpbmcgbmFtZXNwYWNlIGZvciBwcmVmaXggPCcgKyBwcmVmaXggKyAnPic7XG59XG5cbmZ1bmN0aW9uIGdldHRlcihnZXRGbikge1xuICByZXR1cm4ge1xuICAgICdnZXQnOiBnZXRGbixcbiAgICAnZW51bWVyYWJsZSc6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xvbmVOc01hdHJpeChuc01hdHJpeCkge1xuICB2YXIgY2xvbmUgPSB7fSwga2V5O1xuICBmb3IgKGtleSBpbiBuc01hdHJpeCkge1xuICAgIGNsb25lW2tleV0gPSBuc01hdHJpeFtrZXldO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gdXJpUHJlZml4KHByZWZpeCkge1xuICByZXR1cm4gcHJlZml4ICsgJyR1cmknO1xufVxuXG5mdW5jdGlvbiBidWlsZE5zTWF0cml4KG5zVXJpVG9QcmVmaXgpIHtcbiAgdmFyIG5zTWF0cml4ID0ge30sXG4gICAgICB1cmksXG4gICAgICBwcmVmaXg7XG5cbiAgZm9yICh1cmkgaW4gbnNVcmlUb1ByZWZpeCkge1xuICAgIHByZWZpeCA9IG5zVXJpVG9QcmVmaXhbdXJpXTtcbiAgICBuc01hdHJpeFtwcmVmaXhdID0gcHJlZml4O1xuICAgIG5zTWF0cml4W3VyaVByZWZpeChwcmVmaXgpXSA9IHVyaTtcbiAgfVxuXG4gIHJldHVybiBuc01hdHJpeDtcbn1cblxuZnVuY3Rpb24gbm9vcEdldENvbnRleHQoKSB7XG4gIHJldHVybiB7ICdsaW5lJzogMCwgJ2NvbHVtbic6IDAgfTtcbn1cblxuZnVuY3Rpb24gdGhyb3dGdW5jKGVycikge1xuICB0aHJvdyBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBwYXJzZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0gIHshT2JqZWN0PHN0cmluZywgPz49fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG5cbiAgaWYgKCF0aGlzKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gIH1cblxuICB2YXIgcHJveHkgPSBvcHRpb25zICYmIG9wdGlvbnNbJ3Byb3h5J107XG5cbiAgdmFyIG9uVGV4dCxcbiAgICAgIG9uT3BlblRhZyxcbiAgICAgIG9uQ2xvc2VUYWcsXG4gICAgICBvbkNEQVRBLFxuICAgICAgb25FcnJvciA9IHRocm93RnVuYyxcbiAgICAgIG9uV2FybmluZyxcbiAgICAgIG9uQ29tbWVudCxcbiAgICAgIG9uUXVlc3Rpb24sXG4gICAgICBvbkF0dGVudGlvbjtcblxuICB2YXIgZ2V0Q29udGV4dCA9IG5vb3BHZXRDb250ZXh0O1xuXG4gIC8qKlxuICAgKiBEbyB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBjdXJyZW50IGVsZW1lbnRzIGF0dHJpYnV0ZXMgZm9yIG5hbWVzcGFjZXM/XG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdmFyIG1heWJlTlMgPSBmYWxzZTtcblxuICAvKipcbiAgICogRG8gd2UgcHJvY2VzcyBuYW1lc3BhY2VzIGF0IGFsbD9cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB2YXIgaXNOYW1lc3BhY2UgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIGNhdWdodCBlcnJvciByZXR1cm5lZCBvbiBwYXJzZSBlbmRcbiAgICpcbiAgICogQHR5cGUge0Vycm9yfVxuICAgKi9cbiAgdmFyIHJldHVybkVycm9yID0gbnVsbDtcblxuICAvKipcbiAgICogU2hvdWxkIHdlIHN0b3AgcGFyc2luZz9cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB2YXIgcGFyc2VTdG9wID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgbWFwIG9mIHsgdXJpOiBwcmVmaXggfSB1c2VkIGJ5IHRoZSBwYXJzZXIuXG4gICAqXG4gICAqIFRoaXMgbWFwIHdpbGwgZW5zdXJlIHdlIGNhbiBub3JtYWxpemUgcHJlZml4ZXMgZHVyaW5nIHByb2Nlc3Npbmc7XG4gICAqIGZvciBlYWNoIHVyaSwgb25seSBvbmUgcHJlZml4IHdpbGwgYmUgZXhwb3NlZCB0byB0aGUgaGFuZGxlcnMuXG4gICAqXG4gICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn19XG4gICAqL1xuICB2YXIgbnNVcmlUb1ByZWZpeDtcblxuICAvKipcbiAgICogSGFuZGxlIHBhcnNlIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8RXJyb3J9IGVyclxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyKSB7XG4gICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICBlcnIgPSBlcnJvcihlcnIpO1xuICAgIH1cblxuICAgIHJldHVybkVycm9yID0gZXJyO1xuXG4gICAgb25FcnJvcihlcnIsIGdldENvbnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwYXJzZSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEVycm9yfSBlcnJcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZVdhcm5pbmcoZXJyKSB7XG5cbiAgICBpZiAoIW9uV2FybmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgZXJyID0gZXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICBvbldhcm5pbmcoZXJyLCBnZXRDb250ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBwYXJzZSBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWVcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqXG4gICAqIEByZXR1cm4ge1BhcnNlcn1cbiAgICovXG4gIHRoaXNbJ29uJ10gPSBmdW5jdGlvbihuYW1lLCBjYikge1xuXG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyb3IoJ3JlcXVpcmVkIGFyZ3MgPG5hbWUsIGNiPicpO1xuICAgIH1cblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29wZW5UYWcnOiBvbk9wZW5UYWcgPSBjYjsgYnJlYWs7XG4gICAgY2FzZSAndGV4dCc6IG9uVGV4dCA9IGNiOyBicmVhaztcbiAgICBjYXNlICdjbG9zZVRhZyc6IG9uQ2xvc2VUYWcgPSBjYjsgYnJlYWs7XG4gICAgY2FzZSAnZXJyb3InOiBvbkVycm9yID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ3dhcm4nOiBvbldhcm5pbmcgPSBjYjsgYnJlYWs7XG4gICAgY2FzZSAnY2RhdGEnOiBvbkNEQVRBID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ2F0dGVudGlvbic6IG9uQXR0ZW50aW9uID0gY2I7IGJyZWFrOyAvLyA8IVhYWFhYIHp6eno9XCJlZWVlXCI+XG4gICAgY2FzZSAncXVlc3Rpb24nOiBvblF1ZXN0aW9uID0gY2I7IGJyZWFrOyAvLyA8PyAuLi4uICA/PlxuICAgIGNhc2UgJ2NvbW1lbnQnOiBvbkNvbW1lbnQgPSBjYjsgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IGVycm9yKCd1bnN1cHBvcnRlZCBldmVudDogJyArIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG5hbWVzcGFjZSB0byBwcmVmaXggbWFwcGluZy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogcGFyc2VyLm5zKHtcbiAgICogICAnaHR0cDovL2Zvbyc6ICdmb28nLFxuICAgKiAgICdodHRwOi8vYmFyJzogJ2JhcidcbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSAgeyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBuc01hcFxuICAgKlxuICAgKiBAcmV0dXJuIHtQYXJzZXJ9XG4gICAqL1xuICB0aGlzWyducyddID0gZnVuY3Rpb24obnNNYXApIHtcblxuICAgIGlmICh0eXBlb2YgbnNNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBuc01hcCA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnNNYXAgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBlcnJvcigncmVxdWlyZWQgYXJncyA8bnNNYXA9e30+Jyk7XG4gICAgfVxuXG4gICAgdmFyIF9uc1VyaVRvUHJlZml4ID0ge30sIGs7XG5cbiAgICBmb3IgKGsgaW4gbnNNYXApIHtcbiAgICAgIF9uc1VyaVRvUHJlZml4W2tdID0gbnNNYXBba107XG4gICAgfVxuXG4gICAgLy8gRk9SQ0UgZGVmYXVsdCBtYXBwaW5nIGZvciBzY2hlbWEgaW5zdGFuY2VcbiAgICBfbnNVcmlUb1ByZWZpeFtYU0lfVVJJXSA9IFhTSV9QUkVGSVg7XG5cbiAgICBpc05hbWVzcGFjZSA9IHRydWU7XG4gICAgbnNVcmlUb1ByZWZpeCA9IF9uc1VyaVRvUHJlZml4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHhtbCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30geG1sXG4gICAqXG4gICAqIEByZXR1cm4ge0Vycm9yfSByZXR1cm5FcnJvciwgaWYgbm90IHRocm93blxuICAgKi9cbiAgdGhpc1sncGFyc2UnXSA9IGZ1bmN0aW9uKHhtbCkge1xuICAgIGlmICh0eXBlb2YgeG1sICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgZXJyb3IoJ3JlcXVpcmVkIGFyZ3MgPHhtbD1zdHJpbmc+Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuRXJyb3IgPSBudWxsO1xuXG4gICAgcGFyc2UoeG1sKTtcblxuICAgIGdldENvbnRleHQgPSBub29wR2V0Q29udGV4dDtcbiAgICBwYXJzZVN0b3AgPSBmYWxzZTtcblxuICAgIHJldHVybiByZXR1cm5FcnJvcjtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBwYXJzaW5nLlxuICAgKi9cbiAgdGhpc1snc3RvcCddID0gZnVuY3Rpb24oKSB7XG4gICAgcGFyc2VTdG9wID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2Ugc3RyaW5nLCBpbnZva2luZyBjb25maWd1cmVkIGxpc3RlbmVycyBvbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHhtbFxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2UoeG1sKSB7XG4gICAgdmFyIG5zTWF0cml4U3RhY2sgPSBpc05hbWVzcGFjZSA/IFtdIDogbnVsbCxcbiAgICAgICAgbnNNYXRyaXggPSBpc05hbWVzcGFjZSA/IGJ1aWxkTnNNYXRyaXgobnNVcmlUb1ByZWZpeCkgOiBudWxsLFxuICAgICAgICBfbnNNYXRyaXgsXG4gICAgICAgIG5vZGVTdGFjayA9IFtdLFxuICAgICAgICBhbm9ueW1vdXNOc0NvdW50ID0gMCxcbiAgICAgICAgdGFnU3RhcnQgPSBmYWxzZSxcbiAgICAgICAgdGFnRW5kID0gZmFsc2UsXG4gICAgICAgIGkgPSAwLCBqID0gMCxcbiAgICAgICAgeCwgeSwgcSwgdywgdixcbiAgICAgICAgeG1sbnMsXG4gICAgICAgIGVsZW1lbnROYW1lLFxuICAgICAgICBfZWxlbWVudE5hbWUsXG4gICAgICAgIGVsZW1lbnRQcm94eVxuICAgICAgICA7XG5cbiAgICB2YXIgYXR0cnNTdHJpbmcgPSAnJyxcbiAgICAgICAgYXR0cnNTdGFydCA9IDAsXG4gICAgICAgIGNhY2hlZEF0dHJzIC8vIGZhbHNlID0gcGFyc2VkIHdpdGggZXJyb3JzLCBudWxsID0gbmVlZHMgcGFyc2luZ1xuICAgICAgICA7XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhdHRyaWJ1dGVzIG9uIGRlbWFuZCBhbmQgcmV0dXJucyB0aGUgcGFyc2VkIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBSZXR1cm4gc2VtYW50aWNzOiAoMSkgYGZhbHNlYCBvbiBhdHRyaWJ1dGUgcGFyc2UgZXJyb3IsXG4gICAgICogKDIpIG9iamVjdCBoYXNoIG9uIGV4dHJhY3RlZCBhdHRycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW58T2JqZWN0fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEF0dHJzKCkge1xuICAgICAgaWYgKGNhY2hlZEF0dHJzICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRBdHRycztcbiAgICAgIH1cblxuICAgICAgdmFyIG5zVXJpLFxuICAgICAgICAgIG5zVXJpUHJlZml4LFxuICAgICAgICAgIG5zTmFtZSxcbiAgICAgICAgICBkZWZhdWx0QWxpYXMgPSBpc05hbWVzcGFjZSAmJiBuc01hdHJpeFsneG1sbnMnXSxcbiAgICAgICAgICBhdHRyTGlzdCA9IGlzTmFtZXNwYWNlICYmIG1heWJlTlMgPyBbXSA6IG51bGwsXG4gICAgICAgICAgaSA9IGF0dHJzU3RhcnQsXG4gICAgICAgICAgcyA9IGF0dHJzU3RyaW5nLFxuICAgICAgICAgIGwgPSBzLmxlbmd0aCxcbiAgICAgICAgICBoYXNOZXdNYXRyaXgsXG4gICAgICAgICAgbmV3YWxpYXMsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgYWxpYXMsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhdHRycyA9IHt9LFxuICAgICAgICAgIHNlZW5BdHRycyA9IHt9LFxuICAgICAgICAgIHNraXBBdHRyLFxuICAgICAgICAgIHcsXG4gICAgICAgICAgajtcblxuICAgICAgcGFyc2VBdHRyOlxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgc2tpcEF0dHIgPSBmYWxzZTtcbiAgICAgICAgdyA9IHMuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPCAxNCAmJiB3ID4gOCkpIHsgLy8gV0hJVEVTUEFDRT17IFxcZlxcblxcclxcdFxcdn1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdhaXQgZm9yIG5vbiB3aGl0ZXNwYWNlIGNoYXJhY3RlclxuICAgICAgICBpZiAodyA8IDY1IHx8IHcgPiAxMjIgfHwgKHcgPiA5MCAmJiB3IDwgOTcpKSB7XG4gICAgICAgICAgaWYgKHcgIT09IDk1ICYmIHcgIT09IDU4KSB7IC8vIGNoYXIgOTVcIl9cIiA1OFwiOlwiXG4gICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdpbGxlZ2FsIGZpcnN0IGNoYXIgYXR0cmlidXRlIG5hbWUnKTtcbiAgICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXJzZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGw7IGorKykge1xuICAgICAgICAgIHcgPSBzLmNoYXJDb2RlQXQoaik7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB3ID4gOTYgJiYgdyA8IDEyMyB8fFxuICAgICAgICAgICAgdyA+IDY0ICYmIHcgPCA5MSB8fFxuICAgICAgICAgICAgdyA+IDQ3ICYmIHcgPCA1OSB8fFxuICAgICAgICAgICAgdyA9PT0gNDYgfHwgLy8gJy4nXG4gICAgICAgICAgICB3ID09PSA0NSB8fCAvLyAnLSdcbiAgICAgICAgICAgIHcgPT09IDk1IC8vICdfJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB3aGl0ZXNwYWNlXG4gICAgICAgICAgaWYgKHcgPT09IDMyIHx8ICh3IDwgMTQgJiYgdyA+IDgpKSB7IC8vIFdISVRFU1BBQ0VcbiAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ21pc3NpbmcgYXR0cmlidXRlIHZhbHVlJyk7XG4gICAgICAgICAgICBpID0gajtcblxuICAgICAgICAgICAgY29udGludWUgcGFyc2VBdHRyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGV4cGVjdGVkIFwiPVwiXG4gICAgICAgICAgaWYgKHcgPT09IDYxKSB7IC8vIFwiPVwiID09IDYxXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdpbGxlZ2FsIGF0dHJpYnV0ZSBuYW1lIGNoYXInKTtcbiAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gcy5zdWJzdHJpbmcoaSwgaik7XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICd4bWxuczp4bWxucycpIHtcbiAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdpbGxlZ2FsIGRlY2xhcmF0aW9uIG9mIHhtbG5zJyk7XG4gICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdyA9IHMuY2hhckNvZGVBdChqICsgMSk7XG5cbiAgICAgICAgaWYgKHcgPT09IDM0KSB7IC8vICdcIidcbiAgICAgICAgICBqID0gcy5pbmRleE9mKCdcIicsIGkgPSBqICsgMik7XG5cbiAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgIGogPSBzLmluZGV4T2YoJ1xcJycsIGkpO1xuXG4gICAgICAgICAgICBpZiAoaiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgaGFuZGxlV2FybmluZygnYXR0cmlidXRlIHZhbHVlIHF1b3RlIG1pc3NtYXRjaCcpO1xuICAgICAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAodyA9PT0gMzkpIHsgLy8gXCInXCJcbiAgICAgICAgICBqID0gcy5pbmRleE9mKCdcXCcnLCBpID0gaiArIDIpO1xuXG4gICAgICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgICAgICBqID0gcy5pbmRleE9mKCdcIicsIGkpO1xuXG4gICAgICAgICAgICBpZiAoaiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgaGFuZGxlV2FybmluZygnYXR0cmlidXRlIHZhbHVlIHF1b3RlIG1pc3NtYXRjaCcpO1xuICAgICAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlV2FybmluZygnbWlzc2luZyBhdHRyaWJ1dGUgdmFsdWUgcXVvdGVzJyk7XG4gICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gc2tpcCB0byBuZXh0IHNwYWNlXG4gICAgICAgICAgZm9yIChqID0gaiArIDE7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgIHcgPSBzLmNoYXJDb2RlQXQoaiArIDEpO1xuXG4gICAgICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPCAxNCAmJiB3ID4gOCkpIHsgLy8gV0hJVEVTUEFDRVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ21pc3NpbmcgY2xvc2luZyBxdW90ZXMnKTtcblxuICAgICAgICAgIGogPSBsO1xuICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2tpcEF0dHIpIHtcbiAgICAgICAgICB2YWx1ZSA9IHMuc3Vic3RyaW5nKGksIGopO1xuICAgICAgICB9XG5cbiAgICAgICAgaSA9IGo7XG5cbiAgICAgICAgLy8gZW5zdXJlIFNQQUNFIGZvbGxvd3MgYXR0cmlidXRlXG4gICAgICAgIC8vIHNraXAgaWxsZWdhbCBjb250ZW50IG90aGVyd2lzZVxuICAgICAgICAvLyBleGFtcGxlIGE9XCJiXCJjXG4gICAgICAgIGZvciAoOyBqICsgMSA8IGw7IGorKykge1xuICAgICAgICAgIHcgPSBzLmNoYXJDb2RlQXQoaiArIDEpO1xuXG4gICAgICAgICAgaWYgKHcgPT09IDMyIHx8ICh3IDwgMTQgJiYgdyA+IDgpKSB7IC8vIFdISVRFU1BBQ0VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZJUlNUIElMTEVHQUwgQ0hBUlxuICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdpbGxlZ2FsIGNoYXJhY3RlciBhZnRlciBhdHRyaWJ1dGUgZW5kJyk7XG4gICAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWR2YW5jZSBjdXJzb3IgdG8gbmV4dCBhdHRyaWJ1dGVcbiAgICAgICAgaSA9IGogKyAxO1xuXG4gICAgICAgIGlmIChza2lwQXR0cikge1xuICAgICAgICAgIGNvbnRpbnVlIHBhcnNlQXR0cjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGF0dHJpYnV0ZSByZS1kZWNsYXJhdGlvblxuICAgICAgICBpZiAobmFtZSBpbiBzZWVuQXR0cnMpIHtcbiAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdhdHRyaWJ1dGUgPCcgKyBuYW1lICsgJz4gYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZWVuQXR0cnNbbmFtZV0gPSB0cnVlO1xuXG4gICAgICAgIGlmICghaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIGV4dHJhY3QgbmFtZXNwYWNlIGluZm9ybWF0aW9uXG4gICAgICAgIGlmIChtYXliZU5TKSB7XG4gICAgICAgICAgbmV3YWxpYXMgPSAoXG4gICAgICAgICAgICBuYW1lID09PSAneG1sbnMnXG4gICAgICAgICAgICAgID8gJ3htbG5zJ1xuICAgICAgICAgICAgICA6IChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDEyMCAmJiBuYW1lLnN1YnN0cigwLCA2KSA9PT0gJ3htbG5zOicpXG4gICAgICAgICAgICAgICAgPyBuYW1lLnN1YnN0cig2KVxuICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBoYW5kbGUgeG1sbnMoOmFsaWFzKSBhc3NpZ25tZW50XG4gICAgICAgICAgaWYgKG5ld2FsaWFzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBuc1VyaSA9IGRlY29kZUVudGl0aWVzKHZhbHVlKTtcbiAgICAgICAgICAgIG5zVXJpUHJlZml4ID0gdXJpUHJlZml4KG5ld2FsaWFzKTtcblxuICAgICAgICAgICAgYWxpYXMgPSBuc1VyaVRvUHJlZml4W25zVXJpXTtcblxuICAgICAgICAgICAgaWYgKCFhbGlhcykge1xuXG4gICAgICAgICAgICAgIC8vIG5vIHByZWZpeCBkZWZpbmVkIG9yIHByZWZpeCBjb2xsaXNpb25cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChuZXdhbGlhcyA9PT0gJ3htbG5zJykgfHxcbiAgICAgICAgICAgICAgICAobnNVcmlQcmVmaXggaW4gbnNNYXRyaXggJiYgbnNNYXRyaXhbbnNVcmlQcmVmaXhdICE9PSBuc1VyaSlcbiAgICAgICAgICAgICAgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBhbG9jYXRlIGZyZWUgbnMgcHJlZml4XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgYWxpYXMgPSAnbnMnICsgKGFub255bW91c05zQ291bnQrKyk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHlwZW9mIG5zTWF0cml4W2FsaWFzXSAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFsaWFzID0gbmV3YWxpYXM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuc1VyaVRvUHJlZml4W25zVXJpXSA9IGFsaWFzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnNNYXRyaXhbbmV3YWxpYXNdICE9PSBhbGlhcykge1xuICAgICAgICAgICAgICBpZiAoIWhhc05ld01hdHJpeCkge1xuICAgICAgICAgICAgICAgIG5zTWF0cml4ID0gY2xvbmVOc01hdHJpeChuc01hdHJpeCk7XG4gICAgICAgICAgICAgICAgaGFzTmV3TWF0cml4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5zTWF0cml4W25ld2FsaWFzXSA9IGFsaWFzO1xuICAgICAgICAgICAgICBpZiAobmV3YWxpYXMgPT09ICd4bWxucycpIHtcbiAgICAgICAgICAgICAgICBuc01hdHJpeFt1cmlQcmVmaXgoYWxpYXMpXSA9IG5zVXJpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRBbGlhcyA9IGFsaWFzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbnNNYXRyaXhbbnNVcmlQcmVmaXhdID0gbnNVcmk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGV4cG9zZSB4bWxucyg6YXNkKT1cIi4uLlwiIGluIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjb2xsZWN0IGF0dHJpYnV0ZXMgdW50aWwgYWxsIG5hbWVzcGFjZVxuICAgICAgICAgIC8vIGRlY2xhcmF0aW9ucyBhcmUgcHJvY2Vzc2VkXG4gICAgICAgICAgYXR0ckxpc3QucHVzaChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgfSAvKiogZW5kIGlmIChtYXliZU5zKSAqL1xuXG4gICAgICAgIC8vIGhhbmRsZSBhdHRyaWJ1dGVzIG9uIGVsZW1lbnQgd2l0aG91dFxuICAgICAgICAvLyBuYW1lc3BhY2UgZGVjbGFyYXRpb25zXG4gICAgICAgIHcgPSBuYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgaWYgKHcgPT09IC0xKSB7XG4gICAgICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBucyBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICBpZiAoIShuc05hbWUgPSBuc01hdHJpeFtuYW1lLnN1YnN0cmluZygwLCB3KV0pKSB7XG4gICAgICAgICAgaGFuZGxlV2FybmluZyhtaXNzaW5nTmFtZXNwYWNlRm9yUHJlZml4KG5hbWUuc3Vic3RyaW5nKDAsIHcpKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gZGVmYXVsdEFsaWFzID09PSBuc05hbWVcbiAgICAgICAgICA/IG5hbWUuc3Vic3RyKHcgKyAxKVxuICAgICAgICAgIDogbnNOYW1lICsgbmFtZS5zdWJzdHIodyk7XG5cbiAgICAgICAgLy8gZW5kOiBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcblxuICAgICAgICAvLyBub3JtYWxpemUgeHNpOnR5cGUgbnMgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgIGlmIChuYW1lID09PSBYU0lfVFlQRSkge1xuICAgICAgICAgIHcgPSB2YWx1ZS5pbmRleE9mKCc6Jyk7XG5cbiAgICAgICAgICBpZiAodyAhPT0gLTEpIHtcbiAgICAgICAgICAgIG5zTmFtZSA9IHZhbHVlLnN1YnN0cmluZygwLCB3KTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGRlZmF1bHQgcHJlZml4ZXMsIGkuZS4geHM6U3RyaW5nIGdyYWNlZnVsbHlcbiAgICAgICAgICAgIG5zTmFtZSA9IG5zTWF0cml4W25zTmFtZV0gfHwgbnNOYW1lO1xuICAgICAgICAgICAgdmFsdWUgPSBuc05hbWUgKyB2YWx1ZS5zdWJzdHJpbmcodyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdEFsaWFzICsgJzonICsgdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5kOiBub3JtYWxpemUgeHNpOnR5cGUgbnMgYXR0cmlidXRlIHZhbHVlXG5cbiAgICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuXG4gICAgICAvLyBoYW5kbGUgZGVmZXJyZWQsIHBvc3NpYmx5IG5hbWVzcGFjZWQgYXR0cmlidXRlc1xuICAgICAgaWYgKG1heWJlTlMpIHtcblxuICAgICAgICAvLyBub3JtYWxpemUgY2FwdHVyZWQgYXR0cmlidXRlc1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gYXR0ckxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgICBuYW1lID0gYXR0ckxpc3RbaSsrXTtcbiAgICAgICAgICB2YWx1ZSA9IGF0dHJMaXN0W2ldO1xuXG4gICAgICAgICAgdyA9IG5hbWUuaW5kZXhPZignOicpO1xuXG4gICAgICAgICAgaWYgKHcgIT09IC0xKSB7XG5cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBucyBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgaWYgKCEobnNOYW1lID0gbnNNYXRyaXhbbmFtZS5zdWJzdHJpbmcoMCwgdyldKSkge1xuICAgICAgICAgICAgICBoYW5kbGVXYXJuaW5nKG1pc3NpbmdOYW1lc3BhY2VGb3JQcmVmaXgobmFtZS5zdWJzdHJpbmcoMCwgdykpKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5hbWUgPSBkZWZhdWx0QWxpYXMgPT09IG5zTmFtZVxuICAgICAgICAgICAgICA/IG5hbWUuc3Vic3RyKHcgKyAxKVxuICAgICAgICAgICAgICA6IG5zTmFtZSArIG5hbWUuc3Vic3RyKHcpO1xuXG4gICAgICAgICAgICAvLyBlbmQ6IG5vcm1hbGl6ZSBucyBhdHRyaWJ1dGUgbmFtZVxuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgeHNpOnR5cGUgbnMgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gWFNJX1RZUEUpIHtcbiAgICAgICAgICAgICAgdyA9IHZhbHVlLmluZGV4T2YoJzonKTtcblxuICAgICAgICAgICAgICBpZiAodyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuc05hbWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdyk7XG5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZGVmYXVsdCBwcmVmaXhlcywgaS5lLiB4czpTdHJpbmcgZ3JhY2VmdWxseVxuICAgICAgICAgICAgICAgIG5zTmFtZSA9IG5zTWF0cml4W25zTmFtZV0gfHwgbnNOYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnNOYW1lICsgdmFsdWUuc3Vic3RyaW5nKHcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdEFsaWFzICsgJzonICsgdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZW5kOiBub3JtYWxpemUgeHNpOnR5cGUgbnMgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuZDogbm9ybWFsaXplIGNhcHR1cmVkIGF0dHJpYnV0ZXNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlZEF0dHJzID0gYXR0cnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgcGFyc2UgY29udGV4dCB7IGxpbmUsIGNvbHVtbiwgcGFydCB9XG4gICAgICogZnJvbSB0aGUgY3VycmVudCBwYXJzZXIgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBhcnNlIGNvbnRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQYXJzZUNvbnRleHQoKSB7XG4gICAgICB2YXIgc3BsaXRzUmUgPSAvKFxcclxcbnxcXHJ8XFxuKS9nO1xuXG4gICAgICB2YXIgbGluZSA9IDA7XG4gICAgICB2YXIgY29sdW1uID0gMDtcbiAgICAgIHZhciBzdGFydE9mTGluZSA9IDA7XG4gICAgICB2YXIgZW5kT2ZMaW5lID0gajtcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHZhciBkYXRhO1xuXG4gICAgICB3aGlsZSAoaSA+PSBzdGFydE9mTGluZSkge1xuXG4gICAgICAgIG1hdGNoID0gc3BsaXRzUmUuZXhlYyh4bWwpO1xuXG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuZCBvZiBsaW5lID0gKGJyZWFrIGlkeCArIGJyZWFrIGNoYXJzKVxuICAgICAgICBlbmRPZkxpbmUgPSBtYXRjaFswXS5sZW5ndGggKyBtYXRjaC5pbmRleDtcblxuICAgICAgICBpZiAoZW5kT2ZMaW5lID4gaSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWR2YW5jZSB0byBuZXh0IGxpbmVcbiAgICAgICAgbGluZSArPSAxO1xuXG4gICAgICAgIHN0YXJ0T2ZMaW5lID0gZW5kT2ZMaW5lO1xuICAgICAgfVxuXG4gICAgICAvLyBFT0YgZXJyb3JzXG4gICAgICBpZiAoaSA9PSAtMSkge1xuICAgICAgICBjb2x1bW4gPSBlbmRPZkxpbmU7XG4gICAgICAgIGRhdGEgPSB4bWwuc3Vic3RyaW5nKGopO1xuICAgICAgfSBlbHNlXG5cbiAgICAgIC8vIHN0YXJ0IGVycm9yc1xuICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgZGF0YSA9IHhtbC5zdWJzdHJpbmcoaiwgaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG90aGVyIGVycm9yc1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbHVtbiA9IGkgLSBzdGFydE9mTGluZTtcbiAgICAgICAgZGF0YSA9IChqID09IC0xID8geG1sLnN1YnN0cmluZyhpKSA6IHhtbC5zdWJzdHJpbmcoaSwgaiArIDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ2RhdGEnOiBkYXRhLFxuICAgICAgICAnbGluZSc6IGxpbmUsXG4gICAgICAgICdjb2x1bW4nOiBjb2x1bW5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0Q29udGV4dCA9IGdldFBhcnNlQ29udGV4dDtcblxuXG4gICAgaWYgKHByb3h5KSB7XG4gICAgICBlbGVtZW50UHJveHkgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgICduYW1lJzogZ2V0dGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50TmFtZTtcbiAgICAgICAgfSksXG4gICAgICAgICdvcmlnaW5hbE5hbWUnOiBnZXR0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9lbGVtZW50TmFtZTtcbiAgICAgICAgfSksXG4gICAgICAgICdhdHRycyc6IGdldHRlcihnZXRBdHRycyksXG4gICAgICAgICducyc6IGdldHRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbnNNYXRyaXg7XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhY3R1YWwgcGFyc2UgbG9naWNcbiAgICB3aGlsZSAoaiAhPT0gLTEpIHtcblxuICAgICAgaWYgKHhtbC5jaGFyQ29kZUF0KGopID09PSA2MCkgeyAvLyBcIjxcIlxuICAgICAgICBpID0gajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSB4bWwuaW5kZXhPZignPCcsIGopO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSBlbmRcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICBpZiAobm9kZVN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5leHBlY3RlZCBlbmQgb2YgZmlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ21pc3Npbmcgc3RhcnQgdGFnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8IHhtbC5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoeG1sLnN1YnN0cmluZyhqKS50cmltKCkpIHtcbiAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoTk9OX1dISVRFU1BBQ0VfT1VUU0lERV9ST09UX05PREUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgdGV4dFxuICAgICAgaWYgKGogIT09IGkpIHtcblxuICAgICAgICBpZiAobm9kZVN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChvblRleHQpIHtcbiAgICAgICAgICAgIG9uVGV4dCh4bWwuc3Vic3RyaW5nKGosIGkpLCBkZWNvZGVFbnRpdGllcywgZ2V0Q29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoeG1sLnN1YnN0cmluZyhqLCBpKS50cmltKCkpIHtcbiAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoTk9OX1dISVRFU1BBQ0VfT1VUU0lERV9ST09UX05PREUpO1xuXG4gICAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdyA9IHhtbC5jaGFyQ29kZUF0KGkrMSk7XG5cbiAgICAgIC8vIHBhcnNlIGNvbW1lbnRzICsgQ0RBVEFcbiAgICAgIGlmICh3ID09PSAzMykgeyAvLyBcIiFcIlxuICAgICAgICBxID0geG1sLmNoYXJDb2RlQXQoaSsyKTtcblxuICAgICAgICAvLyBDREFUQSBzZWN0aW9uXG4gICAgICAgIGlmIChxID09PSA5MSAmJiB4bWwuc3Vic3RyKGkgKyAzLCA2KSA9PT0gJ0NEQVRBWycpIHsgLy8gOTEgPT0gXCJbXCJcbiAgICAgICAgICBqID0geG1sLmluZGV4T2YoJ11dPicsIGkpO1xuICAgICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCd1bmNsb3NlZCBjZGF0YScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvbkNEQVRBKSB7XG4gICAgICAgICAgICBvbkNEQVRBKHhtbC5zdWJzdHJpbmcoaSArIDksIGopLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGogKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbW1lbnRcbiAgICAgICAgaWYgKHEgPT09IDQ1ICYmIHhtbC5jaGFyQ29kZUF0KGkgKyAzKSA9PT0gNDUpIHsgLy8gNDUgPT0gXCItXCJcbiAgICAgICAgICBqID0geG1sLmluZGV4T2YoJy0tPicsIGkpO1xuICAgICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCd1bmNsb3NlZCBjb21tZW50Jyk7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICBpZiAob25Db21tZW50KSB7XG4gICAgICAgICAgICBvbkNvbW1lbnQoeG1sLnN1YnN0cmluZyhpICsgNCwgaiksIGRlY29kZUVudGl0aWVzLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGogKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSBxdWVzdGlvbiA8PyAuLi4gPz5cbiAgICAgIGlmICh3ID09PSA2MykgeyAvLyBcIj9cIlxuICAgICAgICBqID0geG1sLmluZGV4T2YoJz8+JywgaSk7XG4gICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgcXVlc3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvblF1ZXN0aW9uKSB7XG4gICAgICAgICAgb25RdWVzdGlvbih4bWwuc3Vic3RyaW5nKGksIGogKyAyKSwgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGogKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgY2xvc2luZyB0YWcgZm9yIGF0dGVudGlvbiBvciBzdGFuZGFyZCB0YWdzXG4gICAgICAvLyBmb3IgdGhhdCB3ZSBtdXN0IHNraXAgdGhyb3VnaCBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICAvLyAoZW5jbG9zZWQgaW4gc2luZ2xlIG9yIGRvdWJsZSBxdW90ZXMpXG4gICAgICBmb3IgKHggPSBpICsgMTsgOyB4KyspIHtcbiAgICAgICAgdiA9IHhtbC5jaGFyQ29kZUF0KHgpO1xuICAgICAgICBpZiAoaXNOYU4odikpIHtcbiAgICAgICAgICBqID0gLTE7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCd1bmNsb3NlZCB0YWcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFsxMF0gQXR0VmFsdWUgOjo9ICdcIicgKFtePCZcIl0gfCBSZWZlcmVuY2UpKiAnXCInIHwgXCInXCIgKFtePCYnXSB8IFJlZmVyZW5jZSkqIFwiJ1wiXG4gICAgICAgIC8vIHNraXBzIHRoZSBxdW90ZWQgc3RyaW5nXG4gICAgICAgIC8vIChkb3VibGUgcXVvdGVzKSBkb2VzIG5vdCBhcHBlYXIgaW4gYSBsaXRlcmFsIGVuY2xvc2VkIGJ5IChkb3VibGUgcXVvdGVzKVxuICAgICAgICAvLyAoc2luZ2xlIHF1b3RlKSBkb2VzIG5vdCBhcHBlYXIgaW4gYSBsaXRlcmFsIGVuY2xvc2VkIGJ5IChzaW5nbGUgcXVvdGUpXG4gICAgICAgIGlmICh2ID09PSAzNCkgeyAvLyAgJ1wiJ1xuICAgICAgICAgIHEgPSB4bWwuaW5kZXhPZignXCInLCB4ICsgMSk7XG4gICAgICAgICAgeCA9IHEgIT09IC0xID8gcSA6IHg7XG4gICAgICAgIH0gZWxzZSBpZiAodiA9PT0gMzkpIHsgLy8gXCInXCJcbiAgICAgICAgICBxID0geG1sLmluZGV4T2YoXCInXCIsIHggKyAxKTtcbiAgICAgICAgICB4ID0gcSAhPT0gLTEgPyBxIDogeDtcbiAgICAgICAgfSBlbHNlIGlmICh2ID09PSA2MikgeyAvLyAnPidcbiAgICAgICAgICBqID0geDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8vIHBhcnNlIGF0dGVudGlvbiA8ISAuLi4+XG4gICAgICAvLyBwcmV2aW91c2x5IGNvbW1lbnQgYW5kIENEQVRBIGhhdmUgYWxyZWFkeSBiZWVuIHBhcnNlZFxuICAgICAgaWYgKHcgPT09IDMzKSB7IC8vIFwiIVwiXG5cbiAgICAgICAgaWYgKG9uQXR0ZW50aW9uKSB7XG4gICAgICAgICAgb25BdHRlbnRpb24oeG1sLnN1YnN0cmluZyhpLCBqICsgMSksIGRlY29kZUVudGl0aWVzLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaiArPSAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZG9uJ3QgcHJvY2VzcyBhdHRyaWJ1dGVzO1xuICAgICAgLy8gdGhlcmUgYXJlIG5vbmVcbiAgICAgIGNhY2hlZEF0dHJzID0ge307XG5cbiAgICAgIC8vIGlmICh4bWwuY2hhckNvZGVBdChpKzEpID09PSA0NykgeyAvLyA8Ly4uLlxuICAgICAgaWYgKHcgPT09IDQ3KSB7IC8vIDwvLi4uXG4gICAgICAgIHRhZ1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIHRhZ0VuZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFub2RlU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdtaXNzaW5nIG9wZW4gdGFnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2ZXJpZnkgb3BlbiA8LT4gY2xvc2UgdGFnIG1hdGNoXG4gICAgICAgIHggPSBlbGVtZW50TmFtZSA9IG5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgcSA9IGkgKyAyICsgeC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHhtbC5zdWJzdHJpbmcoaSArIDIsIHEpICE9PSB4KSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdjbG9zaW5nIHRhZyBtaXNtYXRjaCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmVyaWZ5IGNoYXJzIGluIGNsb3NlIHRhZ1xuICAgICAgICBmb3IgKDsgcSA8IGo7IHErKykge1xuICAgICAgICAgIHcgPSB4bWwuY2hhckNvZGVBdChxKTtcblxuICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA+IDggJiYgdyA8IDE0KSkgeyAvLyBcXGZcXG5cXHJcXHRcXHYgc3BhY2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignY2xvc2UgdGFnJyk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHhtbC5jaGFyQ29kZUF0KGogLSAxKSA9PT0gNDcpIHsgLy8gLi4uLz5cbiAgICAgICAgICB4ID0gZWxlbWVudE5hbWUgPSB4bWwuc3Vic3RyaW5nKGkgKyAxLCBqIC0gMSk7XG5cbiAgICAgICAgICB0YWdTdGFydCA9IHRydWU7XG4gICAgICAgICAgdGFnRW5kID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBlbGVtZW50TmFtZSA9IHhtbC5zdWJzdHJpbmcoaSArIDEsIGopO1xuXG4gICAgICAgICAgdGFnU3RhcnQgPSB0cnVlO1xuICAgICAgICAgIHRhZ0VuZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEodyA+IDk2ICYmIHcgPCAxMjMgfHwgdyA+IDY0ICYmIHcgPCA5MSB8fCB3ID09PSA5NSB8fCB3ID09PSA1OCkpIHsgLy8gY2hhciA5NVwiX1wiIDU4XCI6XCJcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ2lsbGVnYWwgZmlyc3QgY2hhciBub2RlTmFtZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChxID0gMSwgeSA9IHgubGVuZ3RoOyBxIDwgeTsgcSsrKSB7XG4gICAgICAgICAgdyA9IHguY2hhckNvZGVBdChxKTtcblxuICAgICAgICAgIGlmICh3ID4gOTYgJiYgdyA8IDEyMyB8fCB3ID4gNjQgJiYgdyA8IDkxIHx8IHcgPiA0NyAmJiB3IDwgNTkgfHwgdyA9PT0gNDUgfHwgdyA9PT0gOTUgfHwgdyA9PSA0Nikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcgPT09IDMyIHx8ICh3IDwgMTQgJiYgdyA+IDgpKSB7IC8vIFxcZlxcblxcclxcdFxcdiBzcGFjZVxuICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB4LnN1YnN0cmluZygwLCBxKTtcblxuICAgICAgICAgICAgLy8gbWF5YmUgdGhlcmUgYXJlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGNhY2hlZEF0dHJzID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignaW52YWxpZCBub2RlTmFtZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0YWdFbmQpIHtcbiAgICAgICAgICBub2RlU3RhY2sucHVzaChlbGVtZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTmFtZXNwYWNlKSB7XG5cbiAgICAgICAgX25zTWF0cml4ID0gbnNNYXRyaXg7XG5cbiAgICAgICAgaWYgKHRhZ1N0YXJ0KSB7XG5cbiAgICAgICAgICAvLyByZW1lbWJlciBvbGQgbmFtZXNwYWNlXG4gICAgICAgICAgLy8gdW5sZXNzIHdlJ3JlIHNlbGYtY2xvc2luZ1xuICAgICAgICAgIGlmICghdGFnRW5kKSB7XG4gICAgICAgICAgICBuc01hdHJpeFN0YWNrLnB1c2goX25zTWF0cml4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FjaGVkQXR0cnMgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgLy8gcXVpY2sgY2hlY2ssIHdoZXRoZXIgdGhlcmUgbWF5IGJlIG5hbWVzcGFjZVxuICAgICAgICAgICAgLy8gZGVjbGFyYXRpb25zIG9uIHRoZSBub2RlOyBpZiB0aGF0IGlzIHRoZSBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGVhZ2VybHkgcGFyc2UgdGhlIG5vZGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgaWYgKChtYXliZU5TID0geC5pbmRleE9mKCd4bWxucycsIHEpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgYXR0cnNTdGFydCA9IHE7XG4gICAgICAgICAgICAgIGF0dHJzU3RyaW5nID0geDtcblxuICAgICAgICAgICAgICBnZXRBdHRycygpO1xuXG4gICAgICAgICAgICAgIG1heWJlTlMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZTtcblxuICAgICAgICB3ID0gZWxlbWVudE5hbWUuaW5kZXhPZignOicpO1xuICAgICAgICBpZiAodyAhPT0gLTEpIHtcbiAgICAgICAgICB4bWxucyA9IG5zTWF0cml4W2VsZW1lbnROYW1lLnN1YnN0cmluZygwLCB3KV07XG5cbiAgICAgICAgICAvLyBwcmVmaXggZ2l2ZW47IG5hbWVzcGFjZSBtdXN0IGV4aXN0XG4gICAgICAgICAgaWYgKCF4bWxucykge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdtaXNzaW5nIG5hbWVzcGFjZSBvbiA8JyArIF9lbGVtZW50TmFtZSArICc+Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZS5zdWJzdHIodyArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhtbG5zID0gbnNNYXRyaXhbJ3htbG5zJ107XG5cbiAgICAgICAgICAvLyBpZiBubyBkZWZhdWx0IG5hbWVzcGFjZSBpcyBkZWZpbmVkLFxuICAgICAgICAgIC8vIHdlJ2xsIGltcG9ydCB0aGUgZWxlbWVudCBhcyBhbm9ueW1vdXMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBpdCBpcyB1cCB0byB1c2VycyB0byBjb3JyZWN0IHRoYXQgdG8gdGhlIGRvY3VtZW50IGRlZmluZWRcbiAgICAgICAgICAvLyB0YXJnZXROYW1lc3BhY2UsIG9yIHdoYXRldmVyIHRoZWlyIHVuZGVyc2FuZGluZyBvZiB0aGVcbiAgICAgICAgICAvLyBYTUwgc3BlYyBtYW5kYXRlcy5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBuYW1lc3BhY2UgcHJlZml4cyBhcyBjb25maWd1cmVkXG4gICAgICAgIGlmICh4bWxucykge1xuICAgICAgICAgIGVsZW1lbnROYW1lID0geG1sbnMgKyAnOicgKyBlbGVtZW50TmFtZTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICh0YWdTdGFydCkge1xuICAgICAgICBhdHRyc1N0YXJ0ID0gcTtcbiAgICAgICAgYXR0cnNTdHJpbmcgPSB4O1xuXG4gICAgICAgIGlmIChvbk9wZW5UYWcpIHtcbiAgICAgICAgICBpZiAocHJveHkpIHtcbiAgICAgICAgICAgIG9uT3BlblRhZyhlbGVtZW50UHJveHksIGRlY29kZUVudGl0aWVzLCB0YWdFbmQsIGdldENvbnRleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvbk9wZW5UYWcoZWxlbWVudE5hbWUsIGdldEF0dHJzLCBkZWNvZGVFbnRpdGllcywgdGFnRW5kLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKHRhZ0VuZCkge1xuXG4gICAgICAgIGlmIChvbkNsb3NlVGFnKSB7XG4gICAgICAgICAgb25DbG9zZVRhZyhwcm94eSA/IGVsZW1lbnRQcm94eSA6IGVsZW1lbnROYW1lLCBkZWNvZGVFbnRpdGllcywgdGFnU3RhcnQsIGdldENvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgb2xkIG5hbWVzcGFjZVxuICAgICAgICBpZiAoaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgICBpZiAoIXRhZ1N0YXJ0KSB7XG4gICAgICAgICAgICBuc01hdHJpeCA9IG5zTWF0cml4U3RhY2sucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5zTWF0cml4ID0gX25zTWF0cml4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBqICs9IDE7XG4gICAgfVxuICB9IC8qKiBlbmQgcGFyc2UgKi9cblxufVxuXG5leHBvcnQgeyBQYXJzZXIsIGRlY29kZUVudGl0aWVzIGFzIGRlY29kZSB9O1xuIiwiZnVuY3Rpb24gZW5zdXJlSW1wb3J0ZWQoZWxlbWVudCwgdGFyZ2V0KSB7XG5cbiAgaWYgKGVsZW1lbnQub3duZXJEb2N1bWVudCAhPT0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgLy8gbWF5IGZhaWwgb24gd2Via2l0XG4gICAgICByZXR1cm4gdGFyZ2V0Lm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShlbGVtZW50LCB0cnVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZ25vcmVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBhcHBlbmRUbyB1dGlsaXR5XG4gKi9cblxuLyoqXG4gKiBBcHBlbmQgYSBub2RlIHRvIGEgdGFyZ2V0IGVsZW1lbnQgYW5kIHJldHVybiB0aGUgYXBwZW5kZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSB0YXJnZXRcbiAqXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fSB0aGUgYXBwZW5kZWQgbm9kZVxuICovXG5mdW5jdGlvbiBhcHBlbmRUbyhlbGVtZW50LCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5hcHBlbmRDaGlsZChlbnN1cmVJbXBvcnRlZChlbGVtZW50LCB0YXJnZXQpKTtcbn1cblxuLyoqXG4gKiBhcHBlbmQgdXRpbGl0eVxuICovXG5cbi8qKlxuICogQXBwZW5kIGEgbm9kZSB0byBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gbm9kZVxuICpcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIG5vZGUpIHtcbiAgYXBwZW5kVG8obm9kZSwgdGFyZ2V0KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBhdHRyaWJ1dGUgYWNjZXNzb3IgdXRpbGl0eVxuICovXG5cbnZhciBMRU5HVEhfQVRUUiA9IDI7XG5cbnZhciBDU1NfUFJPUEVSVElFUyA9IHtcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6IDEsXG4gICdiYXNlbGluZS1zaGlmdCc6IDEsXG4gICdjbGlwJzogMSxcbiAgJ2NsaXAtcGF0aCc6IDEsXG4gICdjbGlwLXJ1bGUnOiAxLFxuICAnY29sb3InOiAxLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6IDEsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAxLFxuICAnY29sb3ItcHJvZmlsZSc6IDEsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAxLFxuICAnY3Vyc29yJzogMSxcbiAgJ2RpcmVjdGlvbic6IDEsXG4gICdkaXNwbGF5JzogMSxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogMSxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogMSxcbiAgJ2ZpbGwnOiAxLFxuICAnZmlsbC1vcGFjaXR5JzogMSxcbiAgJ2ZpbGwtcnVsZSc6IDEsXG4gICdmaWx0ZXInOiAxLFxuICAnZmxvb2QtY29sb3InOiAxLFxuICAnZmxvb2Qtb3BhY2l0eSc6IDEsXG4gICdmb250JzogMSxcbiAgJ2ZvbnQtZmFtaWx5JzogMSxcbiAgJ2ZvbnQtc2l6ZSc6IExFTkdUSF9BVFRSLFxuICAnZm9udC1zaXplLWFkanVzdCc6IDEsXG4gICdmb250LXN0cmV0Y2gnOiAxLFxuICAnZm9udC1zdHlsZSc6IDEsXG4gICdmb250LXZhcmlhbnQnOiAxLFxuICAnZm9udC13ZWlnaHQnOiAxLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6IDEsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6IDEsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAxLFxuICAna2VybmluZyc6IDEsXG4gICdsZXR0ZXItc3BhY2luZyc6IDEsXG4gICdsaWdodGluZy1jb2xvcic6IDEsXG4gICdtYXJrZXInOiAxLFxuICAnbWFya2VyLWVuZCc6IDEsXG4gICdtYXJrZXItbWlkJzogMSxcbiAgJ21hcmtlci1zdGFydCc6IDEsXG4gICdtYXNrJzogMSxcbiAgJ29wYWNpdHknOiAxLFxuICAnb3ZlcmZsb3cnOiAxLFxuICAncG9pbnRlci1ldmVudHMnOiAxLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogMSxcbiAgJ3N0b3AtY29sb3InOiAxLFxuICAnc3RvcC1vcGFjaXR5JzogMSxcbiAgJ3N0cm9rZSc6IDEsXG4gICdzdHJva2UtZGFzaGFycmF5JzogMSxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogMSxcbiAgJ3N0cm9rZS1saW5lY2FwJzogMSxcbiAgJ3N0cm9rZS1saW5lam9pbic6IDEsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6IDEsXG4gICdzdHJva2Utb3BhY2l0eSc6IDEsXG4gICdzdHJva2Utd2lkdGgnOiBMRU5HVEhfQVRUUixcbiAgJ3RleHQtYW5jaG9yJzogMSxcbiAgJ3RleHQtZGVjb3JhdGlvbic6IDEsXG4gICd0ZXh0LXJlbmRlcmluZyc6IDEsXG4gICd1bmljb2RlLWJpZGknOiAxLFxuICAndmlzaWJpbGl0eSc6IDEsXG4gICd3b3JkLXNwYWNpbmcnOiAxLFxuICAnd3JpdGluZy1tb2RlJzogMVxufTtcblxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSkge1xuICBpZiAoQ1NTX1BST1BFUlRJRVNbbmFtZV0pIHtcbiAgICByZXR1cm4gbm9kZS5zdHlsZVtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGVOUyhudWxsLCBuYW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGh5cGhlbmF0ZWQgPSBuYW1lLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHR5cGUgPSBDU1NfUFJPUEVSVElFU1toeXBoZW5hdGVkXTtcblxuICBpZiAodHlwZSkge1xuICAgIC8vIGFwcGVuZCBwaXhlbCB1bml0LCB1bmxlc3MgcHJlc2VudFxuICAgIGlmICh0eXBlID09PSBMRU5HVEhfQVRUUiAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSkgKyAncHgnO1xuICAgIH1cblxuICAgIG5vZGUuc3R5bGVbaHlwaGVuYXRlZF0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG51bGwsIG5hbWUsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKG5vZGUsIGF0dHJzKSB7XG5cbiAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoYXR0cnMpLCBpLCBuYW1lO1xuXG4gIGZvciAoaSA9IDAsIG5hbWU7IChuYW1lID0gbmFtZXNbaV0pOyBpKyspIHtcbiAgICBzZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgYXR0cnNbbmFtZV0pO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyBvciBzZXRzIHJhdyBhdHRyaWJ1dGVzIG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0gIHtPYmplY3R9IFthdHRyc11cbiAqIEBwYXJhbSAge1N0cmluZ30gW25hbWVdXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFt2YWx1ZV1cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGF0dHIobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXRBdHRyaWJ1dGVzKG5vZGUsIG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxyXG4gKiBDbGVhciB1dGlsaXR5XHJcbiAqL1xyXG5mdW5jdGlvbiBpbmRleChhcnIsIG9iaikge1xyXG4gIGlmIChhcnIuaW5kZXhPZikge1xyXG4gICAgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XHJcbiAgfVxyXG5cclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcclxuICAgIGlmIChhcnJbaV0gPT09IG9iaikge1xyXG4gICAgICByZXR1cm4gaTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiAtMTtcclxufVxyXG5cclxudmFyIHJlID0gL1xccysvO1xyXG5cclxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuXHJcbmZ1bmN0aW9uIGRlZmluZWQobykge1xyXG4gIHJldHVybiB0eXBlb2YgbyAhPT0gJ3VuZGVmaW5lZCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcmFwIGBlbGAgaW4gYSBgQ2xhc3NMaXN0YC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxyXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gY2xhc3NlcyhlbCkge1xyXG4gIHJldHVybiBuZXcgQ2xhc3NMaXN0KGVsKTtcclxufVxyXG5cclxuZnVuY3Rpb24gQ2xhc3NMaXN0KGVsKSB7XHJcbiAgaWYgKCFlbCB8fCAhZWwubm9kZVR5cGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQSBET00gZWxlbWVudCByZWZlcmVuY2UgaXMgcmVxdWlyZWQnKTtcclxuICB9XHJcbiAgdGhpcy5lbCA9IGVsO1xyXG4gIHRoaXMubGlzdCA9IGVsLmNsYXNzTGlzdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZCBjbGFzcyBgbmFtZWAgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obmFtZSkge1xyXG5cclxuICAvLyBjbGFzc0xpc3RcclxuICBpZiAodGhpcy5saXN0KSB7XHJcbiAgICB0aGlzLmxpc3QuYWRkKG5hbWUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBmYWxsYmFja1xyXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XHJcbiAgdmFyIGkgPSBpbmRleChhcnIsIG5hbWUpO1xyXG4gIGlmICghfmkpIHtcclxuICAgIGFyci5wdXNoKG5hbWUpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGRlZmluZWQodGhpcy5lbC5jbGFzc05hbWUuYmFzZVZhbCkpIHtcclxuICAgIHRoaXMuZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBhcnIuam9pbignICcpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmVsLmNsYXNzTmFtZSA9IGFyci5qb2luKCcgJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgY2xhc3MgYG5hbWVgIHdoZW4gcHJlc2VudCwgb3JcclxuICogcGFzcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byByZW1vdmVcclxuICogYW55IHdoaWNoIG1hdGNoLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IG5hbWVcclxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obmFtZSkge1xyXG4gIGlmICgnW29iamVjdCBSZWdFeHBdJyA9PT0gdG9TdHJpbmcuY2FsbChuYW1lKSkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTWF0Y2hpbmcobmFtZSk7XHJcbiAgfVxyXG5cclxuICAvLyBjbGFzc0xpc3RcclxuICBpZiAodGhpcy5saXN0KSB7XHJcbiAgICB0aGlzLmxpc3QucmVtb3ZlKG5hbWUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBmYWxsYmFja1xyXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XHJcbiAgdmFyIGkgPSBpbmRleChhcnIsIG5hbWUpO1xyXG4gIGlmICh+aSkge1xyXG4gICAgYXJyLnNwbGljZShpLCAxKTtcclxuICB9XHJcbiAgdGhpcy5lbC5jbGFzc05hbWUuYmFzZVZhbCA9IGFyci5qb2luKCcgJyk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGFsbCBjbGFzc2VzIG1hdGNoaW5nIGByZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxyXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlTWF0Y2hpbmcgPSBmdW5jdGlvbihyZSkge1xyXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChyZS50ZXN0KGFycltpXSkpIHtcclxuICAgICAgdGhpcy5yZW1vdmUoYXJyW2ldKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogVG9nZ2xlIGNsYXNzIGBuYW1lYCwgY2FuIGZvcmNlIHN0YXRlIHZpYSBgZm9yY2VgLlxyXG4gKlxyXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGNsYXNzTGlzdCwgYnV0IGRvIG5vdCBzdXBwb3J0IGBmb3JjZWAgeWV0LFxyXG4gKiB0aGUgbWlzdGFrZSB3aWxsIGJlIGRldGVjdGVkIGFuZCBjb3JyZWN0ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VcclxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24obmFtZSwgZm9yY2UpIHtcclxuICAvLyBjbGFzc0xpc3RcclxuICBpZiAodGhpcy5saXN0KSB7XHJcbiAgICBpZiAoZGVmaW5lZChmb3JjZSkpIHtcclxuICAgICAgaWYgKGZvcmNlICE9PSB0aGlzLmxpc3QudG9nZ2xlKG5hbWUsIGZvcmNlKSkge1xyXG4gICAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7IC8vIHRvZ2dsZSBhZ2FpbiB0byBjb3JyZWN0XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIGZhbGxiYWNrXHJcbiAgaWYgKGRlZmluZWQoZm9yY2UpKSB7XHJcbiAgICBpZiAoIWZvcmNlKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5hZGQobmFtZSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICh0aGlzLmhhcyhuYW1lKSkge1xyXG4gICAgICB0aGlzLnJlbW92ZShuYW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuYWRkKG5hbWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFuIGFycmF5IG9mIGNsYXNzZXMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgY2xhc3NOYW1lID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XHJcbiAgdmFyIHN0ciA9IGNsYXNzTmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbiAgdmFyIGFyciA9IHN0ci5zcGxpdChyZSk7XHJcbiAgaWYgKCcnID09PSBhcnJbMF0pIHtcclxuICAgIGFyci5zaGlmdCgpO1xyXG4gIH1cclxuICByZXR1cm4gYXJyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGNsYXNzIGBuYW1lYCBpcyBwcmVzZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuQ2xhc3NMaXN0LnByb3RvdHlwZS5oYXMgPVxyXG5DbGFzc0xpc3QucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24obmFtZSkge1xyXG4gIHJldHVybiAoXHJcbiAgICB0aGlzLmxpc3QgP1xyXG4gICAgICB0aGlzLmxpc3QuY29udGFpbnMobmFtZSkgOlxyXG4gICAgICAhISB+aW5kZXgodGhpcy5hcnJheSgpLCBuYW1lKVxyXG4gICk7XHJcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG4gIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIENsZWFyIHV0aWxpdHlcbiAqL1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhlIGdpdmVuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gIHtET01FbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGUgZWxlbWVudCAoZm9yIGNoYWluaW5nKVxuICovXG5mdW5jdGlvbiBjbGVhcihlbGVtZW50KSB7XG4gIHZhciBjaGlsZDtcblxuICB3aGlsZSAoKGNoaWxkID0gZWxlbWVudC5maXJzdENoaWxkKSkge1xuICAgIHJlbW92ZShjaGlsZCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY2xvbmUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG59XG5cbnZhciBucyA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXG59O1xuXG4vKipcbiAqIERPTSBwYXJzaW5nIHV0aWxpdHlcbiAqL1xuXG52YXIgU1ZHX1NUQVJUID0gJzxzdmcgeG1sbnM9XCInICsgbnMuc3ZnICsgJ1wiJztcblxuZnVuY3Rpb24gcGFyc2Uoc3ZnKSB7XG5cbiAgdmFyIHVud3JhcCA9IGZhbHNlO1xuXG4gIC8vIGVuc3VyZSB3ZSBpbXBvcnQgYSB2YWxpZCBzdmcgZG9jdW1lbnRcbiAgaWYgKHN2Zy5zdWJzdHJpbmcoMCwgNCkgPT09ICc8c3ZnJykge1xuICAgIGlmIChzdmcuaW5kZXhPZihucy5zdmcpID09PSAtMSkge1xuICAgICAgc3ZnID0gU1ZHX1NUQVJUICsgc3ZnLnN1YnN0cmluZyg0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbmFtZXNwYWNlIHN2Z1xuICAgIHN2ZyA9IFNWR19TVEFSVCArICc+JyArIHN2ZyArICc8L3N2Zz4nO1xuICAgIHVud3JhcCA9IHRydWU7XG4gIH1cblxuICB2YXIgcGFyc2VkID0gcGFyc2VEb2N1bWVudChzdmcpO1xuXG4gIGlmICghdW53cmFwKSB7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICB2YXIgcGFyZW50ID0gcGFyc2VkLmZpcnN0Q2hpbGQ7XG5cbiAgd2hpbGUgKHBhcmVudC5maXJzdENoaWxkKSB7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIGZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50KHN2Zykge1xuXG4gIHZhciBwYXJzZXI7XG5cbiAgLy8gcGFyc2VcbiAgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICBwYXJzZXIuYXN5bmMgPSBmYWxzZTtcblxuICByZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdmcsICd0ZXh0L3htbCcpO1xufVxuXG4vKipcbiAqIENyZWF0ZSB1dGlsaXR5IGZvciBTVkcgZWxlbWVudHNcbiAqL1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgc3BlY2lmaWMgdHlwZSBmcm9tIG5hbWUgb3IgU1ZHIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvciBtYXJrdXAgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cnNdIGF0dHJpYnV0ZXMgdG8gc2V0IG9uIHRoZSBlbGVtZW50XG4gKlxuICogQHJldHVybnMge1NWR0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBhdHRycykge1xuICB2YXIgZWxlbWVudDtcblxuICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICc8Jykge1xuICAgIGVsZW1lbnQgPSBwYXJzZShuYW1lKS5maXJzdENoaWxkO1xuICAgIGVsZW1lbnQgPSBkb2N1bWVudC5pbXBvcnROb2RlKGVsZW1lbnQsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMuc3ZnLCBuYW1lKTtcbiAgfVxuXG4gIGlmIChhdHRycykge1xuICAgIGF0dHIoZWxlbWVudCwgYXR0cnMpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRXZlbnRzIGhhbmRsaW5nIHV0aWxpdHlcbiAqL1xuXG5mdW5jdGlvbiBvbihub2RlLCBldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIG9mZihub2RlLCBldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG59XG5cbi8qKlxuICogR2VvbWV0cnkgaGVscGVyc1xuICovXG5cbi8vIGZha2Ugbm9kZSB1c2VkIHRvIGluc3RhbnRpYXRlIHN2ZyBnZW9tZXRyeSBlbGVtZW50c1xudmFyIG5vZGUgPSBjcmVhdGUoJ3N2ZycpO1xuXG5mdW5jdGlvbiBleHRlbmQob2JqZWN0LCBwcm9wcykge1xuICB2YXIgaSwgaywga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcblxuICBmb3IgKGkgPSAwOyAoayA9IGtleXNbaV0pOyBpKyspIHtcbiAgICBvYmplY3Rba10gPSBwcm9wc1trXTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlUG9pbnQoeCwgeSkge1xuICB2YXIgcG9pbnQgPSBub2RlLmNyZWF0ZVNWR1BvaW50KCk7XG5cbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gIGNhc2UgMDpcbiAgICByZXR1cm4gcG9pbnQ7XG4gIGNhc2UgMjpcbiAgICB4ID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGV4dGVuZChwb2ludCwgeCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIG1hdHJpeCB2aWEgYXJncy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGNyZWF0ZU1hdHJpeCh7IGE6IDEsIGI6IDEgfSk7XG4gKiBjcmVhdGVNYXRyaXgoKTtcbiAqIGNyZWF0ZU1hdHJpeCgxLCAyLCAwLCAwLCAzMCwgMjApO1xuICpcbiAqIEByZXR1cm4ge1NWR01hdHJpeH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIG1hdHJpeCA9IG5vZGUuY3JlYXRlU1ZHTWF0cml4KCk7XG5cbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gIGNhc2UgMDpcbiAgICByZXR1cm4gbWF0cml4O1xuICBjYXNlIDE6XG4gICAgcmV0dXJuIGV4dGVuZChtYXRyaXgsIGEpO1xuICBjYXNlIDY6XG4gICAgcmV0dXJuIGV4dGVuZChtYXRyaXgsIHtcbiAgICAgIGE6IGEsXG4gICAgICBiOiBiLFxuICAgICAgYzogYyxcbiAgICAgIGQ6IGQsXG4gICAgICBlOiBlLFxuICAgICAgZjogZlxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybShtYXRyaXgpIHtcbiAgaWYgKG1hdHJpeCkge1xuICAgIHJldHVybiBub2RlLmNyZWF0ZVNWR1RyYW5zZm9ybUZyb21NYXRyaXgobWF0cml4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5jcmVhdGVTVkdUcmFuc2Zvcm0oKTtcbiAgfVxufVxuXG4vKipcbiAqIFNlcmlhbGl6YXRpb24gdXRpbFxuICovXG5cbnZhciBURVhUX0VOVElUSUVTID0gLyhbJjw+XXsxfSkvZztcbnZhciBBVFRSX0VOVElUSUVTID0gLyhbXFxuXFxyXCJdezF9KS9nO1xuXG52YXIgRU5USVRZX1JFUExBQ0VNRU5UID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJ1xcJydcbn07XG5cbmZ1bmN0aW9uIGVzY2FwZShzdHIsIHBhdHRlcm4pIHtcblxuICBmdW5jdGlvbiByZXBsYWNlRm4obWF0Y2gsIGVudGl0eSkge1xuICAgIHJldHVybiBFTlRJVFlfUkVQTEFDRU1FTlRbZW50aXR5XSB8fCBlbnRpdHk7XG4gIH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZUZuKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplKG5vZGUsIG91dHB1dCkge1xuXG4gIHZhciBpLCBsZW4sIGF0dHJNYXAsIGF0dHJOb2RlLCBjaGlsZE5vZGVzO1xuXG4gIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAvLyBURVhUXG4gIGNhc2UgMzpcbiAgICAvLyByZXBsYWNlIHNwZWNpYWwgWE1MIGNoYXJhY3RlcnNcbiAgICBvdXRwdXQucHVzaChlc2NhcGUobm9kZS50ZXh0Q29udGVudCwgVEVYVF9FTlRJVElFUykpO1xuICAgIGJyZWFrO1xuXG4gIC8vIEVMRU1FTlRcbiAgY2FzZSAxOlxuICAgIG91dHB1dC5wdXNoKCc8Jywgbm9kZS50YWdOYW1lKTtcblxuICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgYXR0ck1hcCA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGF0dHJNYXAubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgYXR0ck5vZGUgPSBhdHRyTWFwLml0ZW0oaSk7XG4gICAgICAgIG91dHB1dC5wdXNoKCcgJywgYXR0ck5vZGUubmFtZSwgJz1cIicsIGVzY2FwZShhdHRyTm9kZS52YWx1ZSwgQVRUUl9FTlRJVElFUyksICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgb3V0cHV0LnB1c2goJz4nKTtcbiAgICAgIGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHNlcmlhbGl6ZShjaGlsZE5vZGVzLml0ZW0oaSksIG91dHB1dCk7XG4gICAgICB9XG4gICAgICBvdXRwdXQucHVzaCgnPC8nLCBub2RlLnRhZ05hbWUsICc+Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcvPicpO1xuICAgIH1cbiAgICBicmVhaztcblxuICAvLyBDT01NRU5UXG4gIGNhc2UgODpcbiAgICBvdXRwdXQucHVzaCgnPCEtLScsIGVzY2FwZShub2RlLm5vZGVWYWx1ZSwgVEVYVF9FTlRJVElFUyksICctLT4nKTtcbiAgICBicmVhaztcblxuICAvLyBDREFUQVxuICBjYXNlIDQ6XG4gICAgb3V0cHV0LnB1c2goJzwhW0NEQVRBWycsIG5vZGUubm9kZVZhbHVlLCAnXV0+Jyk7XG4gICAgYnJlYWs7XG5cbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBoYW5kbGUgbm9kZSAnICsgbm9kZS5ub2RlVHlwZSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIGlubmVySFRNTCBsaWtlIGZ1bmN0aW9uYWxpdHkgZm9yIFNWRyBlbGVtZW50cy5cbiAqIGJhc2VkIG9uIGlubmVyU1ZHIChodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2lubmVyc3ZnKVxuICovXG5cblxuZnVuY3Rpb24gc2V0KGVsZW1lbnQsIHN2Zykge1xuXG4gIHZhciBwYXJzZWQgPSBwYXJzZShzdmcpO1xuXG4gIC8vIGNsZWFyIGVsZW1lbnQgY29udGVudHNcbiAgY2xlYXIoZWxlbWVudCk7XG5cbiAgaWYgKCFzdmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWlzRnJhZ21lbnQocGFyc2VkKSkge1xuICAgIC8vIGV4dHJhY3QgPHN2Zz4gZnJvbSBwYXJzZWQgZG9jdW1lbnRcbiAgICBwYXJzZWQgPSBwYXJzZWQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIG5vZGVzID0gc2xpY2UocGFyc2VkLmNoaWxkTm9kZXMpO1xuXG4gIC8vIGltcG9ydCArIGFwcGVuZCBlYWNoIG5vZGVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGFwcGVuZFRvKG5vZGVzW2ldLCBlbGVtZW50KTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGdldChlbGVtZW50KSB7XG4gIHZhciBjaGlsZCA9IGVsZW1lbnQuZmlyc3RDaGlsZCxcbiAgICAgIG91dHB1dCA9IFtdO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIHNlcmlhbGl6ZShjaGlsZCwgb3V0cHV0KTtcbiAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gaXNGcmFnbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50LWZyYWdtZW50Jztcbn1cblxuZnVuY3Rpb24gaW5uZXJTVkcoZWxlbWVudCwgc3ZnKSB7XG5cbiAgaWYgKHN2ZyAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICB0cnkge1xuICAgICAgc2V0KGVsZW1lbnQsIHN2Zyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvciBwYXJzaW5nIFNWRzogJyArIGUubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldChlbGVtZW50KTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNsaWNlKGFycikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcbn1cblxuLyoqXG4gKiBTZWxlY3Rpb24gdXRpbGl0aWVzXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0KG5vZGUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBub2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RBbGwobm9kZSwgc2VsZWN0b3IpIHtcbiAgdmFyIG5vZGVzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICByZXR1cm4gW10ubWFwLmNhbGwobm9kZXMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSk7XG59XG5cbi8qKlxuICogcHJlcGVuZFRvIHV0aWxpdHlcbiAqL1xuXG4vKipcbiAqIFByZXBlbmQgYSBub2RlIHRvIGEgdGFyZ2V0IGVsZW1lbnQgYW5kIHJldHVybiB0aGUgcHJlcGVuZGVkIG5vZGUuXG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gbm9kZVxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gdGFyZ2V0XG4gKlxuICogQHJldHVybiB7U1ZHRWxlbWVudH0gdGhlIHByZXBlbmRlZCBub2RlXG4gKi9cbmZ1bmN0aW9uIHByZXBlbmRUbyhub2RlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5pbnNlcnRCZWZvcmUoZW5zdXJlSW1wb3J0ZWQobm9kZSwgdGFyZ2V0KSwgdGFyZ2V0LmZpcnN0Q2hpbGQgfHwgbnVsbCk7XG59XG5cbi8qKlxuICogcHJlcGVuZCB1dGlsaXR5XG4gKi9cblxuLyoqXG4gKiBQcmVwZW5kIGEgbm9kZSB0byBhIHRhcmdldCBlbGVtZW50XG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSBub2RlXG4gKlxuICogQHJldHVybiB7U1ZHRWxlbWVudH0gdGhlIHRhcmdldCBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHByZXBlbmQodGFyZ2V0LCBub2RlKSB7XG4gIHByZXBlbmRUbyhub2RlLCB0YXJnZXQpO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFJlcGxhY2UgdXRpbGl0eVxuICovXG5cbmZ1bmN0aW9uIHJlcGxhY2UoZWxlbWVudCwgcmVwbGFjZW1lbnQpIHtcbiAgZWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbnN1cmVJbXBvcnRlZChyZXBsYWNlbWVudCwgZWxlbWVudCksIGVsZW1lbnQpO1xuICByZXR1cm4gcmVwbGFjZW1lbnQ7XG59XG5cbi8qKlxuICogdHJhbnNmb3JtIGFjY2Vzc29yIHV0aWxpdHlcbiAqL1xuXG5mdW5jdGlvbiB3cmFwTWF0cml4KHRyYW5zZm9ybUxpc3QsIHRyYW5zZm9ybSkge1xuICBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgU1ZHTWF0cml4KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybUxpc3QuY3JlYXRlU1ZHVHJhbnNmb3JtRnJvbU1hdHJpeCh0cmFuc2Zvcm0pO1xuICB9XG5cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuXG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm1zKHRyYW5zZm9ybUxpc3QsIHRyYW5zZm9ybXMpIHtcbiAgdmFyIGksIHQ7XG5cbiAgdHJhbnNmb3JtTGlzdC5jbGVhcigpO1xuXG4gIGZvciAoaSA9IDA7ICh0ID0gdHJhbnNmb3Jtc1tpXSk7IGkrKykge1xuICAgIHRyYW5zZm9ybUxpc3QuYXBwZW5kSXRlbSh3cmFwTWF0cml4KHRyYW5zZm9ybUxpc3QsIHQpKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvciBzZXQgdGhlIHRyYW5zZm9ybXMgb24gdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0gIHtTVkdUcmFuc2Zvcm18U1ZHTWF0cml4fEFycmF5PFNWR1RyYW5zZm9ybXxTVkdNYXRyaXg+fSBbdHJhbnNmb3Jtc11cbiAqXG4gKiBAcmV0dXJuIHtTVkdUcmFuc2Zvcm19IHRoZSBjb25zb2xpZGF0ZWQgdHJhbnNmb3JtXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCB0cmFuc2Zvcm1zKSB7XG4gIHZhciB0cmFuc2Zvcm1MaXN0ID0gbm9kZS50cmFuc2Zvcm0uYmFzZVZhbDtcblxuICBpZiAodHJhbnNmb3Jtcykge1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRyYW5zZm9ybXMpKSB7XG4gICAgICB0cmFuc2Zvcm1zID0gWyB0cmFuc2Zvcm1zIF07XG4gICAgfVxuXG4gICAgc2V0VHJhbnNmb3Jtcyh0cmFuc2Zvcm1MaXN0LCB0cmFuc2Zvcm1zKTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2Zvcm1MaXN0LmNvbnNvbGlkYXRlKCk7XG59XG5cbmV4cG9ydCB7IGFwcGVuZCwgYXBwZW5kVG8sIGF0dHIsIGNsYXNzZXMsIGNsZWFyLCBjbG9uZSwgY3JlYXRlLCBpbm5lclNWRywgcHJlcGVuZCwgcHJlcGVuZFRvLCByZW1vdmUsIHJlcGxhY2UsIHRyYW5zZm9ybSwgb24sIG9mZiwgY3JlYXRlUG9pbnQsIGNyZWF0ZU1hdHJpeCwgY3JlYXRlVHJhbnNmb3JtLCBzZWxlY3QsIHNlbGVjdEFsbCB9O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9saWIvaW5kZXguanNcIik7XG4iXSwic291cmNlUm9vdCI6IiJ9